{"paramTypes":["ChangeEvent"],"returnType":"void","methodCalls":{"getSource":1,"updateCarList":1,"getSelectedIndex":1},"constants":{},"annotations":[],"types":{"JTabbedPane":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void stateChanged(ChangeEvent changeEvent) {\n    JTabbedPane sourceTabbedPane = (JTabbedPane) changeEvent.getSource();\n    int index = sourceTabbedPane.getSelectedIndex();\n    if (index == 1) {\n        purchasePanel.updateCarList();\n    }\n}\n","name":"stateChanged","className":"","variables":{"sourceTabbedPane":2,"index":2,"changeEvent":2,"purchasePanel":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"addTab":2,"setSize":1,"getSource":1,"updateCarList":1,"getContentPane":1,"getSelectedIndex":1,"addChangeListener":1},"constants":{"\"Car creation\"":1,"\"Car purchase\"":1},"annotations":[],"types":{"JTabbedPane":1,"ChangeListener":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","CastExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["Casting","InnerMethod"],"exceptions":[],"text":"//The method init initializes the Applet with a Pane with two tabs\npublic void init() {\n    //list of car to be used in both CreatePanel & PurchasePanel\n    carList = new Vector();\n    //register panel uses the list of courses\n    purchasePanel = new PurchasePanel(carList);\n    createPanel = new CreatePanel(carList, purchasePanel);\n    //create a tabbed pane with two tabs\n    tPane = new JTabbedPane();\n    tPane.addTab(\"Car creation\", createPanel);\n    tPane.addTab(\"Car purchase\", purchasePanel);\n    getContentPane().add(tPane);\n    ChangeListener changeListener = new ChangeListener() {\n\n        public void stateChanged(ChangeEvent changeEvent) {\n            JTabbedPane sourceTabbedPane = (JTabbedPane) changeEvent.getSource();\n            int index = sourceTabbedPane.getSelectedIndex();\n            if (index == 1) {\n                purchasePanel.updateCarList();\n            }\n        }\n    };\n    tPane.addChangeListener(changeListener);\n    //set Applet size\n    setSize(APPLET_WIDTH, APPLET_HEIGHT);\n}\n","name":"init","className":"Assignment6","variables":{"createPanel":1,"changeListener":1,"tPane":4,"sourceTabbedPane":2,"index":2,"carList":3,"stateChanged":1,"purchasePanel":3,"changeEvent":2},"javaDoc":"","comments":"list of car to be used in both CreatePanel & PurchasePanel register panel uses the list of courses create a tabbed pane with two tabs set Applet size The method init initializes the Applet with a Pane with two tabs","isEmpty":false,"lineCount":10,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getFirst":1,"getSecond":1,"firstContaining":1,"System.out.println":4},"constants":{"\"a\"":1,"\"Tom\"":1,"\"Expected: Diana\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Expected: 1\"":1},"annotations":[],"types":{"String[]":1,"Pair<String, Integer>":1},"expressions":["VariableDeclarationExpr","ArrayInitializerExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String[] names = { \"Tom\", \"Diana\", \"Harry\" };\n    Pair<String, Integer> result = firstContaining(names, \"a\");\n    System.out.println(result.getFirst());\n    System.out.println(\"Expected: Diana\");\n    System.out.println(result.getSecond());\n    System.out.println(\"Expected: 1\");\n}\n","name":"main","className":"PairDemo","variables":{"args":1,"result":3,"names":1},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]","String"],"returnType":"Pair<String, Integer>","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the first String containing a given string, together \n      with its index.\n      @param strings an array of strings\n      @param sub a string\n      @return a pair (strings[i], i) where strings[i] is the first \n      strings[i] containing str, or a pair (null, -1) if there is no\n      match.\n   */\npublic static Pair<String, Integer> firstContaining(String[] strings, String sub) {\n    for (int i = 0; i < strings.length; i++) {\n        if (strings[i].contains(sub)) {\n            return new Pair<>(strings[i], i);\n        }\n    }\n    return new Pair<>(null, -1);\n}\n","name":"firstContaining","className":"PairDemo","variables":{"sub":1,"strings":3},"javaDoc":"Gets the first String containing a given string together with its index strings an array of strings sub a string a pair (strings[i] i) where strings[i] is the first strings[i] containing str or a pair (null -1) if there is no match","comments":"\n      Gets the first String containing a given string, together \n      with its index.\n      @param strings an array of strings\n      @param sub a string\n      @return a pair (strings[i], i) where strings[i] is the first \n      strings[i] containing str, or a pair (null, -1) if there is no\n      match.\n   ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["T","S"],"returnType":"Pair","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a pair containing two given elements.\n      @param firstElement the first element\n      @param secondElement the second element\n   */\npublic Pair(T firstElement, S secondElement) {\n    first = firstElement;\n    second = secondElement;\n}\n","name":"Pair","className":"Pair","variables":{"firstElement":2,"secondElement":2,"first":1,"second":1},"javaDoc":"Constructs a pair containing two given elements firstElement the first element secondElement the second element","comments":"\n      Constructs a pair containing two given elements.\n      @param firstElement the first element\n      @param secondElement the second element\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"T","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the first element of this pair.\n      @return the first element\n   */\npublic T getFirst() {\n    return first;\n}\n","name":"getFirst","className":"Pair","variables":{"first":1},"javaDoc":"Gets the first element of this pair the first element","comments":"\n      Gets the first element of this pair.\n      @return the first element\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"S","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the second element of this pair.\n      @return the second element\n   */\npublic S getSecond() {\n    return second;\n}\n","name":"getSecond","className":"Pair","variables":{"second":1},"javaDoc":"Gets the second element of this pair the second element","comments":"\n      Gets the second element of this pair.\n      @return the second element\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\")\"":1,"\"(\"":1,"\", \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"(\" + first + \", \" + second + \")\";\n}\n","name":"toString","className":"Pair","variables":{"first":1,"second":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"size":1,"push":1,"System.out.println":1},"constants":{"10":1},"annotations":[],"types":{"Stack<Integer>":1,"int":1,"Stack":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Stack<Integer> countdown = new Stack<>();\n    for (int i = 0; i <= 10; i++) {\n        countdown.push(i);\n    }\n    while (countdown.size() > 0) {\n        System.out.println(countdown.pop());\n    }\n}\n","name":"main","className":"StackDemo","variables":{"args":1,"countdown":4},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"Stack","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Stack() {\n    elements = new Object[INITIAL_SIZE];\n// elements = new E[INITIAL_SIZE] \n// is an error--cannot make a generic array\n}\n","name":"Stack","className":"Stack","variables":{"INITIAL_SIZE":1,"elements":1},"javaDoc":"","comments":"elements = new E[INITIAL_SIZE] is an error--cannot make a generic array ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"copyOf":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void push(E value) {\n    if (currentSize >= elements.length) {\n        elements = Arrays.copyOf(elements, 2 * elements.length);\n    }\n    elements[currentSize] = value;\n    currentSize++;\n}\n","name":"push","className":"Stack","variables":{"elements":2,"Arrays":1,"value":2,"currentSize":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"E","methodCalls":{},"constants":{},"annotations":["SuppressWarnings"],"types":{},"expressions":["ArrayAccessExpr","NameExpr","CastExpr","UnaryExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Suppresses \"unchecked\" warnings inside this method\n@SuppressWarnings(\"unchecked\")\npublic E pop() {\n    currentSize--;\n    // Cast causes \"unchecked\" warning\n    return (E) elements[currentSize];\n}\n","name":"pop","className":"Stack","variables":{"elements":1,"currentSize":2},"javaDoc":"","comments":"Suppresses \"unchecked\" warnings inside this method Cast causes \"unchecked\" warning ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int size() {\n    return currentSize;\n}\n","name":"size","className":"Stack","variables":{"currentSize":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["ArrayList<E>","ArrayList<? extends E>"],"returnType":"void","methodCalls":{"add":1},"constants":{},"annotations":[],"types":{},"expressions":["VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static <E> void addAll(ArrayList<E> lst, ArrayList<? extends E> other) // public static <E> void addAll(ArrayList<E> lst, ArrayList<E> other)\n// doesn't work with Student array list\n{\n    for (E e : other) {\n        lst.add(e);\n    }\n}\n","name":"addAll","className":"WildcardDemo","variables":{"other":2,"lst":2},"javaDoc":"","comments":"public static <E> void addAll(ArrayList<E> lst ArrayList<E> other) doesn't work with Student array list ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["ArrayList<E>"],"returnType":"E","methodCalls":{"size":1,"get":3,"compareTo":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static <E extends Comparable<? super E>> E max(ArrayList<E> a) // public static <E extends Comparable<E>> E max(ArrayList<E> a) \n// doesn't work with Student array list\n{\n    E largest = a.get(0);\n    for (int i = 1; i < a.size(); i++) {\n        if (a.get(i).compareTo(largest) > 0) {\n            largest = a.get(i);\n        }\n    }\n    return largest;\n}\n","name":"max","className":"WildcardDemo","variables":{"largest":3},"javaDoc":"","comments":"public static <E extends Comparable<E>> E max(ArrayList<E> a) doesn't work with Student array list ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"addAll":1,"max":1,"System.out.println":2},"constants":{"\"CS\"":2,"\"Fred\"":1,"\"Bio\"":1,"\"Sue\"":1,"\"Harry\"":1,"\"Ann\"":1},"annotations":[],"types":{"ArrayList<Student>":1,"ArrayList":2,"ArrayList<Person>":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    ArrayList<Student> students = new ArrayList<>();\n    students.add(new Student(\"Fred\", \"CS\"));\n    students.add(new Student(\"Ann\", \"Bio\"));\n    students.add(new Student(\"Sue\", \"CS\"));\n    ArrayList<Person> people = new ArrayList<>();\n    people.add(new Person(\"Harry\"));\n    addAll(people, students);\n    System.out.println(people);\n    System.out.println(max(students));\n}\n","name":"main","className":"WildcardDemo","variables":{"args":1,"students":4,"people":2},"javaDoc":"","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["String","String"],"returnType":"Student","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExplicitConstructorInvocationStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   */\npublic Student(String aName, String aMajor) {\n    super(aName);\n    major = aMajor;\n}\n","name":"Student","className":"Student","variables":{"major":1,"aName":2,"aMajor":2},"javaDoc":"Constructs a Student object aName the name of the student aMajor the major of the student","comments":"\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"]\"":1,"\"[major=\"":1},"annotations":[],"types":{},"expressions":["SuperExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return super.toString() + \"[major=\" + major + \"]\";\n}\n","name":"toString","className":"Student","variables":{"major":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"Person","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a Person object\n      @param aName the name of the person\n   */\npublic Person(String aName) {\n    name = aName;\n}\n","name":"Person","className":"Person","variables":{"aName":2,"name":1},"javaDoc":"Constructs a Person object aName the name of the person","comments":"\n      Constructs a Person object\n      @param aName the name of the person\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"constants":{"\"[name=\"":1,"\"]\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \"]\";\n}\n","name":"toString","className":"Person","variables":{"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Person"],"returnType":"int","methodCalls":{"compareTo":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int compareTo(Person other) {\n    return name.compareTo(other.name);\n}\n","name":"compareTo","className":"Person","variables":{"other":1,"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["E[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"constants":{"\" \"":1},"annotations":[],"types":{},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static <E> void print(E[] a) {\n    for (E e : a) {\n        System.out.print(e + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"PrintDemo","variables":{},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"constants":{"\" \"":1},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void print(int[] a) {\n    for (int e : a) {\n        System.out.print(e + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"PrintDemo","variables":{},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":3},"constants":{"\"lamb\"":1,"\"a\"":1,"25":1,"36":1,"\"little\"":1,"16":1,"\"had\"":1,"\"Mary\"":1},"annotations":[],"types":{"Color[]":1,"int[]":1,"String[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String[] words = { \"Mary\", \"had\", \"a\", \"little\", \"lamb\" };\n    Color[] colors = { Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW };\n    int[] squares = { 1, 4, 9, 16, 25, 36 };\n    // Calls print<String>\n    print(words);\n    // Calls print<Color>\n    print(colors);\n    // Calls non-generic print      \n    print(squares);\n}\n","name":"main","className":"PrintDemo","variables":{"args":1,"words":1,"squares":1,"colors":1},"javaDoc":"","comments":"Calls print<String> Calls print<Color> Calls non-generic print ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String","String"],"returnType":"Student","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExplicitConstructorInvocationStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   */\npublic Student(String aName, String aMajor) {\n    super(aName);\n    major = aMajor;\n}\n","name":"Student","className":"Student","variables":{"major":1,"aName":2,"aMajor":2},"javaDoc":"Constructs a Student object aName the name of the student aMajor the major of the student","comments":"\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"]\"":1,"\"[major=\"":1},"annotations":[],"types":{},"expressions":["SuperExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return super.toString() + \"[major=\" + major + \"]\";\n}\n","name":"toString","className":"Student","variables":{"major":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      This method is called for each visited node.\n      @param data the data of the node\n   */\nvoid visit(E data);\n","name":"visit","className":"Visitor","variables":{"data":1},"javaDoc":"This method is called for each visited node data the data of the node","comments":"\n      This method is called for each visited node.\n      @param data the data of the node\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.print":1},"constants":{"\" \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void visit(String data) {\n    System.out.print(data + \" \");\n}\n","name":"visit","className":"PrintVisitor","variables":{"data":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":5,"inorder":1,"System.out.print":1,"System.out.println":2},"constants":{"\"Expected: Dick Harry Juliet Romeo Tom\"":1,"\"Tom\"":1,"\" \"":1,"\"Juliet\"":1,"\"Dick\"":1,"\"Harry\"":1,"\"Romeo\"":1},"annotations":[],"types":{"BinarySearchTree<String>":1,"BinarySearchTree":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TypeDeclarationStmt","BlockStmt","ExpressionStmt"],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"exceptions":[],"text":"public static void main(String[] args) {\n    BinarySearchTree<String> names = new BinarySearchTree<>();\n    names.add(\"Romeo\");\n    names.add(\"Juliet\");\n    names.add(\"Tom\");\n    names.add(\"Dick\");\n    names.add(\"Harry\");\n    class PrintVisitor implements Visitor<String> {\n\n        public void visit(String data) {\n            System.out.print(data + \" \");\n        }\n    }\n    names.inorder(new PrintVisitor());\n    System.out.println();\n    System.out.println(\"Expected: Dick Harry Juliet Romeo Tom\");\n}\n","name":"main","className":"TreeTester","variables":{"args":1,"names":7,"data":2,"PrintVisitor":1,"visit":1},"javaDoc":"","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void visit(Object data) {\n    System.out.println(data);\n}\n","name":"visit","className":"PrintVisitor","variables":{"data":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":5,"inorder":1,"System.out.println":1},"constants":{"\"CS\"":1,"\"EE\"":1,"\"Tom\"":1,"\"Biology\"":1,"\"Juliet\"":1,"\"Leisure Studies\"":1,"\"Diana\"":1,"\"Art History\"":1,"\"Harry\"":1,"\"Romeo\"":1},"annotations":[],"types":{"BinarySearchTree2":1,"BinarySearchTree2<Student>":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TypeDeclarationStmt","BlockStmt","ExpressionStmt"],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"exceptions":[],"text":"public static void main(String[] args) {\n    BinarySearchTree2<Student> students = new BinarySearchTree2<>();\n    // Can form BinarySearchTree2<Student> even though Student\n    // implements Comparable<Person> and not Comparable<Student>\n    students.add(new Student(\"Romeo\", \"Art History\"));\n    students.add(new Student(\"Juliet\", \"CS\"));\n    students.add(new Student(\"Tom\", \"Leisure Studies\"));\n    students.add(new Student(\"Diana\", \"EE\"));\n    students.add(new Student(\"Harry\", \"Biology\"));\n    class PrintVisitor implements Visitor<Object> {\n\n        public void visit(Object data) {\n            System.out.println(data);\n        }\n    }\n    // Can pass a Visitor<Object>, not just a Visitor<Student>\n    students.inorder(new PrintVisitor());\n}\n","name":"main","className":"TreeTester2","variables":{"args":1,"data":1,"PrintVisitor":1,"students":7,"visit":1},"javaDoc":"","comments":"Can form BinarySearchTree2<Student> even though Student implements Comparable<Person> and not Comparable<Student> Can pass a Visitor<Object> not just a Visitor<Student> ","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"BinarySearchTree","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an empty tree.\n   */\npublic BinarySearchTree() {\n    root = null;\n}\n","name":"BinarySearchTree","className":"BinarySearchTree","variables":{"root":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"addNode":1},"constants":{"null":3},"annotations":[],"types":{"Node":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(E obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n}\n","name":"add","className":"BinarySearchTree","variables":{"obj":2,"root":3,"newNode":2},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"constants":{"null":1,"true":1,"false":1},"annotations":[],"types":{"Node":1,"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(E obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"BinarySearchTree","variables":{"current":4,"obj":1,"root":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"toBeRemoved.data.compareTo":1},"constants":{"null":7,"false":1,"true":1},"annotations":[],"types":{"boolean":1,"Node":5,"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(E obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    Node parent = null;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            parent = toBeRemoved;\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        if (// Found in root\n        parent == null) {\n            root = newChild;\n        } else if (parent.left == toBeRemoved) {\n            parent.left = newChild;\n        } else {\n            parent.right = newChild;\n        }\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallestParent = toBeRemoved;\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallestParent = smallest;\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    if (smallestParent == toBeRemoved) {\n        smallestParent.right = smallest.right;\n    } else {\n        smallestParent.left = smallest.right;\n    }\n}\n","name":"remove","className":"BinarySearchTree","variables":{"parent":3,"smallestParent":3,"toBeRemoved":8,"found":4,"newChild":6,"obj":1,"smallest":3,"root":2},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child Found in root \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"lineCount":18,"modifier":1}
{"paramTypes":["Visitor<E>"],"returnType":"void","methodCalls":{"inorder":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Prints the contents of the tree in sorted order.\n   */\npublic void inorder(Visitor<E> v) {\n    inorder(root, v);\n}\n","name":"inorder","className":"BinarySearchTree","variables":{},"javaDoc":"Prints the contents of the tree in sorted order","comments":"\n      Prints the contents of the tree in sorted order.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Node","Visitor<E>"],"returnType":"void","methodCalls":{"visit":1,"inorder":2},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   */\nprivate void inorder(Node parent, Visitor<E> v) {\n    if (parent == null) {\n        return;\n    }\n    inorder(parent.left, v);\n    v.visit(parent.data);\n    inorder(parent.right, v);\n}\n","name":"inorder","className":"BinarySearchTree","variables":{"parent":2},"javaDoc":"Prints a node and all of its descendants in sorted order parent the root of the subtree to print","comments":"\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   ","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"constants":{"null":2},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":3,"right":3},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"BinarySearchTree2","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an empty tree.\n   */\npublic BinarySearchTree2() {\n    root = null;\n}\n","name":"BinarySearchTree2","className":"BinarySearchTree2","variables":{"root":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"addNode":1},"constants":{"null":3},"annotations":[],"types":{"Node":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(E obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n}\n","name":"add","className":"BinarySearchTree2","variables":{"obj":2,"root":3,"newNode":2},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"constants":{"null":1,"true":1,"false":1},"annotations":[],"types":{"Node":1,"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(E obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"BinarySearchTree2","variables":{"current":4,"obj":1,"root":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"toBeRemoved.data.compareTo":1},"constants":{"null":7,"false":1,"true":1},"annotations":[],"types":{"boolean":1,"Node":5,"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(E obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    Node parent = null;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            parent = toBeRemoved;\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        if (// Found in root\n        parent == null) {\n            root = newChild;\n        } else if (parent.left == toBeRemoved) {\n            parent.left = newChild;\n        } else {\n            parent.right = newChild;\n        }\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallestParent = toBeRemoved;\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallestParent = smallest;\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    if (smallestParent == toBeRemoved) {\n        smallestParent.right = smallest.right;\n    } else {\n        smallestParent.left = smallest.right;\n    }\n}\n","name":"remove","className":"BinarySearchTree2","variables":{"parent":3,"smallestParent":3,"toBeRemoved":8,"found":4,"newChild":6,"obj":1,"smallest":3,"root":2},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child Found in root \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"lineCount":18,"modifier":1}
{"paramTypes":["Visitor<? super E>"],"returnType":"void","methodCalls":{"inorder":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Prints the contents of the tree in sorted order.\n   */\npublic void inorder(Visitor<? super E> v) {\n    inorder(root, v);\n}\n","name":"inorder","className":"BinarySearchTree2","variables":{},"javaDoc":"Prints the contents of the tree in sorted order","comments":"\n      Prints the contents of the tree in sorted order.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["BinarySearchTree2<T>.Node<T>","Visitor<? super T>"],"returnType":"void","methodCalls":{"visit":1,"inorder":2},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   */\nprivate static <T extends Comparable<? super T>> void inorder(BinarySearchTree2<T>.Node<T> parent, Visitor<? super T> v) {\n    if (parent == null) {\n        return;\n    }\n    inorder(parent.left, v);\n    v.visit(parent.data);\n    inorder(parent.right, v);\n}\n","name":"inorder","className":"BinarySearchTree2","variables":{"parent":2},"javaDoc":"Prints a node and all of its descendants in sorted order parent the root of the subtree to print","comments":"\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   ","isEmpty":false,"lineCount":4,"modifier":10}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"constants":{"null":2},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":3,"right":3},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"Person","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a Person object\n      @param aName the name of the person\n   */\npublic Person(String aName) {\n    name = aName;\n}\n","name":"Person","className":"Person","variables":{"aName":2,"name":1},"javaDoc":"Constructs a Person object aName the name of the person","comments":"\n      Constructs a Person object\n      @param aName the name of the person\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"constants":{"\"[name=\"":1,"\"]\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \"]\";\n}\n","name":"toString","className":"Person","variables":{"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Person"],"returnType":"int","methodCalls":{"compareTo":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int compareTo(Person other) {\n    return name.compareTo(other.name);\n}\n","name":"compareTo","className":"Person","variables":{"other":1,"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":2,"sum":2,"addFirst":4,"System.out.println":2},"constants":{"\"4\"":1,"\"Sum: \"":2},"annotations":[],"types":{"LinkedList":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // Here, we use the linked list class from Chapter 16\n    LinkedList numbers = new LinkedList();\n    numbers.addFirst(1);\n    numbers.addFirst(2);\n    numbers.addFirst(3);\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n    // No error message\n    numbers.addFirst(\"4\");\n    // No error\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n// ClassCastException\n}\n","name":"main","className":"UnsafeDemo","variables":{"args":1,"numbers":5},"javaDoc":"","comments":"ClassCastException Here we use the linked list class from Chapter 16 No error message No error ","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["LinkedList"],"returnType":"void","methodCalls":{"next":1,"listIterator":1,"hasNext":1,"System.out.print":1,"System.out.println":1},"constants":{"\" \"":1},"annotations":[],"types":{"ListIterator":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void print(LinkedList lst) {\n    ListIterator iter = lst.listIterator();\n    while (iter.hasNext()) {\n        System.out.print(iter.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"UnsafeDemo","variables":{"iter":3,"lst":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["LinkedList"],"returnType":"int","methodCalls":{"next":1,"listIterator":1,"hasNext":1},"constants":{},"annotations":[],"types":{"ListIterator":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","CastExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static int sum(LinkedList lst) {\n    int sum = 0;\n    ListIterator iter = lst.listIterator();\n    while (iter.hasNext()) {\n        sum = sum + (Integer) iter.next();\n    }\n    return sum;\n}\n","name":"sum","className":"UnsafeDemo","variables":{"iter":3,"sum":4,"lst":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Moves the iterator past the next element.\n      @return the traversed element\n   */\nObject next();\n","name":"next","className":"ListIterator","variables":{},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n      Moves the iterator past the next element.\n      @return the traversed element\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   */\nboolean hasNext();\n","name":"hasNext","className":"ListIterator","variables":{},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   */\nvoid add(Object element);\n","name":"add","className":"ListIterator","variables":{"element":1},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   */\nvoid remove();\n","name":"remove","className":"ListIterator","variables":{},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   */\nvoid set(Object element);\n","name":"set","className":"ListIterator","variables":{"element":1},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"LinkedList","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Constructs an empty linked list.\n   */\npublic LinkedList() {\n    first = null;\n}\n","name":"LinkedList","className":"LinkedList","variables":{"first":1},"javaDoc":"Constructs an empty linked list","comments":" \n      Constructs an empty linked list.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   */\npublic Object getFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    return first.data;\n}\n","name":"getFirst","className":"LinkedList","variables":{"first":1},"javaDoc":"Returns the first element in the linked list the first element in the linked list","comments":"\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{"Object":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes the first element in the linked list.\n      @return the removed element\n   */\npublic Object removeFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    return element;\n}\n","name":"removeFirst","className":"LinkedList","variables":{"first":2,"element":2},"javaDoc":"Removes the first element in the linked list the removed element","comments":"\n      Removes the first element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"Node":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   */\npublic void addFirst(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    first = newNode;\n}\n","name":"addFirst","className":"LinkedList","variables":{"newNode":2,"first":2,"element":2},"javaDoc":"Adds an element to the front of the linked list element the element to add","comments":"\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"ListIterator","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   */\npublic ListIterator listIterator() {\n    return new LinkedListIterator();\n}\n","name":"listIterator","className":"LinkedList","variables":{},"javaDoc":"Returns an iterator for iterating through this list an iterator for iterating through this list","comments":"\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"LinkedListIterator","methodCalls":{},"constants":{"null":2,"false":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BooleanLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Constructs an iterator that points to the front\n         of the linked list.\n      */\npublic LinkedListIterator() {\n    position = null;\n    previous = null;\n    isAfterNext = false;\n}\n","name":"LinkedListIterator","className":"LinkedListIterator","variables":{"previous":1,"position":1,"isAfterNext":1},"javaDoc":"Constructs an iterator that points to the front of the linked list","comments":"\n         Constructs an iterator that points to the front\n         of the linked list.\n      ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1},"constants":{"null":1,"true":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NullLiteralExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Moves the iterator past the next element.\n         @return the traversed element\n      */\npublic Object next() {\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    // Remember for remove\n    previous = position;\n    isAfterNext = true;\n    if (position == null) {\n        position = first;\n    } else {\n        position = position.next;\n    }\n    return position.data;\n}\n","name":"next","className":"LinkedListIterator","variables":{"previous":1,"position":4,"first":1,"isAfterNext":1},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"Remember for remove \n         Moves the iterator past the next element.\n         @return the traversed element\n      ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{"null":3},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      */\npublic boolean hasNext() {\n    if (position == null) {\n        return first != null;\n    } else {\n        return position.next != null;\n    }\n}\n","name":"hasNext","className":"LinkedListIterator","variables":{"position":1,"first":1},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"addFirst":1},"constants":{"null":1,"false":1},"annotations":[],"types":{"Node":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      */\npublic void add(Object element) {\n    if (position == null) {\n        addFirst(element);\n        position = first;\n    } else {\n        Node newNode = new Node();\n        newNode.data = element;\n        newNode.next = position.next;\n        position.next = newNode;\n        position = newNode;\n    }\n    isAfterNext = false;\n}\n","name":"add","className":"LinkedListIterator","variables":{"newNode":3,"position":3,"first":1,"element":2,"isAfterNext":1},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeFirst":1},"constants":{"false":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      */\npublic void remove() {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    if (position == first) {\n        removeFirst();\n    } else {\n        previous.next = position.next;\n    }\n    position = previous;\n    isAfterNext = false;\n}\n","name":"remove","className":"LinkedListIterator","variables":{"previous":1,"position":2,"first":1,"isAfterNext":2},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      */\npublic void set(Object element) {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    position.data = element;\n}\n","name":"set","className":"LinkedListIterator","variables":{"element":2,"isAfterNext":1},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"print":2,"sum":2,"System.out.println":2},"constants":{"\"4\"":1,"\"Sum: \"":2},"annotations":[],"types":{"ArrayList<Integer>":1,"ArrayList":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<>();\n    numbers.add(1);\n    numbers.add(2);\n    numbers.add(3);\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n    // Compiler error message\n    numbers.add(\"4\");\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n}\n","name":"main","className":"UnsafeDemo2","variables":{"args":1,"numbers":5},"javaDoc":"","comments":"Compiler error message ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["ArrayList<Integer>"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"hasNext":1,"System.out.print":1,"System.out.println":1},"constants":{"\" \"":1},"annotations":[],"types":{"Iterator<Integer>":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void print(ArrayList<Integer> lst) {\n    Iterator<Integer> iter = lst.iterator();\n    while (iter.hasNext()) {\n        System.out.print(iter.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"UnsafeDemo2","variables":{"iter":3,"lst":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["ArrayList<Integer>"],"returnType":"int","methodCalls":{"next":1,"iterator":1,"hasNext":1},"constants":{},"annotations":[],"types":{"Iterator<Integer>":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static int sum(ArrayList<Integer> lst) {\n    int sum = 0;\n    Iterator<Integer> iter = lst.iterator();\n    while (iter.hasNext()) {\n        // No cast needed\n        sum = sum + iter.next();\n    }\n    return sum;\n}\n","name":"sum","className":"UnsafeDemo2","variables":{"iter":3,"sum":4,"lst":2},"javaDoc":"","comments":"No cast needed ","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["E[]"],"returnType":"E","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static <E extends Comparable<E>> E max(E[] a) {\n    E largest = a[0];\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].compareTo(largest) > 0) {\n            largest = a[i];\n        }\n    }\n    return largest;\n}\n","name":"max","className":"MaxDemo","variables":{"largest":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"max":2,"System.out.println":2},"constants":{"\"lamb\"":1,"\"a\"":1,"25":1,"36":1,"\"little\"":1,"16":1,"\"had\"":1,"\"Mary\"":1},"annotations":[],"types":{"Color[]":1,"String[]":1,"Integer[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String[] words = { \"Mary\", \"had\", \"a\", \"little\", \"lamb\" };\n    Color[] colors = { Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW };\n    Integer[] squares = { 1, 4, 9, 16, 25, 36 };\n    // Calls max<String>\n    System.out.println(max(words));\n    // System.out.println(max(colors)); // Error: Color is not Comparable\n    // Calls max<Integer>\n    System.out.println(max(squares));\n}\n","name":"main","className":"MaxDemo","variables":{"args":1,"words":1,"squares":1,"colors":1},"javaDoc":"","comments":"System out println(max(colors)); // Error: Color is not Comparable Calls max<String> Calls max<Integer> ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","UnaryExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** Description of add(String ToBeAdded)\n\t * \t\t\t\t\t\tAdds string to array list\n\t * @param \t\t\t\tToBeAdded Is a string that is being searched for within the arraylist \n\t */\npublic void add(String ToBeAdded) {\n    mylist.add(counter, ToBeAdded);\n    counter++;\n}\n","name":"add","className":"StringListExt","variables":{"mylist":1,"counter":1,"ToBeAdded":1},"javaDoc":"Description of add(String ToBeAdded) Adds string to array list ToBeAdded Is a string that is being searched for within the arraylist","comments":" Description of add(String ToBeAdded)\n\t * \t\t\t\t\t\tAdds string to array list\n\t * @param \t\t\t\tToBeAdded Is a string that is being searched for within the arraylist \n\t ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"String","methodCalls":{"size":1,"get":1,"isEmpty":1},"constants":{"\"\"":1,"true":1,"\"Index doesn't exist\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** Description of get(int GettingInt)\n\t * @return\t\t\t\treturns the string element within the index the user inputs\n\t * @param \t\t\t\tGettingInt is the index of the string that the user wants to see \n\t */\npublic String get(int GettingInt) {\n    if (mylist.isEmpty() == true) {\n        return \"\";\n    }\n    if (GettingInt > mylist.size() || GettingInt < 0) {\n        return \"Index doesn't exist\";\n    }\n    return mylist.get(GettingInt);\n}\n","name":"get","className":"StringListExt","variables":{"mylist":3,"GettingInt":3},"javaDoc":"Description of get(int GettingInt) returns the string element within the index the user inputs GettingInt is the index of the string that the user wants to see","comments":" Description of get(int GettingInt)\n\t * @return\t\t\t\treturns the string element within the index the user inputs\n\t * @param \t\t\t\tGettingInt is the index of the string that the user wants to see \n\t ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** Description of get(int GettingInt)\n\t * @return\t\t\t    the amount of elements in the string array\n\t * @param \t\t\t\tToBeAdded Is a string that is being searched for within the arraylist \n\t */\npublic int length() {\n    return mylist.size();\n}\n","name":"length","className":"StringListExt","variables":{"mylist":1},"javaDoc":"Description of get(int GettingInt) the amount of elements in the string array ToBeAdded Is a string that is being searched for within the arraylist","comments":" Description of get(int GettingInt)\n\t * @return\t\t\t    the amount of elements in the string array\n\t * @param \t\t\t\tToBeAdded Is a string that is being searched for within the arraylist \n\t ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"size":1,"get":1,"isEmpty":1},"constants":{"\"\"":1,"true":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** Description of getLast()\n\t *  @return\t\t\t\tReturns the string in the last index of the string array\n\t */\npublic String getLast() {\n    if (mylist.isEmpty() == true) {\n        return \"\";\n    }\n    // returning last element in the list\n    return mylist.get(mylist.size() - 1);\n}\n","name":"getLast","className":"StringListExt","variables":{"mylist":3},"javaDoc":"Description of getLast() Returns the string in the last index of the string array","comments":"returning last element in the list  Description of getLast()\n\t *  @return\t\t\t\tReturns the string in the last index of the string array\n\t ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"size":1,"get":2,"isEmpty":1,"remove":1},"constants":{"true":3,"false":2},"annotations":[],"types":{"boolean":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** Description of remove(String gettingRemoved)\n\t * \t\t\t\t\t\tThis method deletes a certain string element from the string array\n\t *  @param\t\t\t\tThe string that needs to be removed from the string array\n\t */\npublic void remove(String gettingRemoved) {\n    int i = 0;\n    boolean found = true;\n    if (mylist.isEmpty() == true) {\n        found = false;\n    }\n    while (gettingRemoved != mylist.get(i) && found == true) {\n        i++;\n        if (i == mylist.size() - 1) {\n            found = false;\n        }\n    }\n    if (gettingRemoved == mylist.get(i)) {\n        mylist.remove(i);\n        counter--;\n    }\n}\n","name":"remove","className":"StringListExt","variables":{"found":4,"gettingRemoved":3,"mylist":5,"counter":1},"javaDoc":"Description of remove(String gettingRemoved) This method deletes a certain string element from the string array The string that needs to be removed from the string array","comments":" Description of remove(String gettingRemoved)\n\t * \t\t\t\t\t\tThis method deletes a certain string element from the string array\n\t *  @param\t\t\t\tThe string that needs to be removed from the string array\n\t ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":1,"println":1,"nextLine":1,"hasNextLine":1},"constants":{"\"test1.txt\"":1,"\"output.txt\"":1},"annotations":[],"types":{"Scanner":1,"String":1,"File":2,"PrintWriter":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["FileNotFoundException"],"text":"public static void main(String[] args) throws FileNotFoundException {\n    File inFile = new File(\"test1.txt\");\n    File outFile = new File(\"output.txt\");\n    try (Scanner in = new Scanner(inFile);\n        PrintWriter out = new PrintWriter(outFile)) {\n        while (in.hasNextLine()) {\n            String result = process(in.nextLine());\n            out.println(result);\n        }\n    }\n// Both in.close() and out.close() are called here\n}\n","name":"main","className":"ClosingResources","variables":{"args":1,"result":1,"outFile":2,"in":3,"inFile":2,"out":2},"javaDoc":"","comments":"Both in close() and out close() are called here ","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"parseInt":1},"constants":{"\"\"":1},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static String process(String line) {\n    int value = Integer.parseInt(line);\n    value++;\n    return \"\" + value;\n}\n","name":"process","className":"ClosingResources","variables":{"Integer":1,"line":1,"value":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readData":1,"getMessage":1,"System.out.println":2},"constants":{"\"fred.txt\"":1,"\"result: \"":1},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) {\n    try {\n        int result = readData(\"fred.txt\");\n        System.out.println(\"result: \" + result);\n    } catch (IOException exception) {\n        System.out.println(exception.getMessage());\n    }\n}\n","name":"main","className":"CheckedExceptions","variables":{"args":1,"result":2,"exception":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"int","methodCalls":{"hasNextInt":1,"nextInt":1},"constants":{},"annotations":[],"types":{"Scanner":1,"File":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["FileNotFoundException"],"text":"public static int readData(String filename) throws FileNotFoundException {\n    File inFile = new File(filename);\n    Scanner in = new Scanner(inFile);\n    int sum = 0;\n    while (in.hasNextInt()) {\n        sum = sum + in.nextInt();\n    }\n    return sum;\n}\n","name":"readData","className":"CheckedExceptions","variables":{"filename":2,"in":3,"sum":4,"inFile":2},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"parseDouble":1,"trim":1,"nextLine":1,"hasNextLine":1,"length":1,"close":2,"System.out.print":2,"charAt":1,"substring":2,"printf":2},"constants":{"\"\"":1,"\"%-20s%10.2f\\n\"":2,"':'":1,"\"Output file: \"":1,"\"Total:\"":1,"false":1,"true":1,"\"Input file: \"":1},"annotations":[],"types":{"Scanner":2,"boolean":1,"double":2,"char":1,"String":4,"File":1,"int":1,"PrintWriter":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","CharLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["FileNotFoundException"],"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Prompt for the input and output file names\n    Scanner console = new Scanner(System.in);\n    System.out.print(\"Input file: \");\n    String inputFileName = console.next();\n    System.out.print(\"Output file: \");\n    String outputFileName = console.next();\n    // Construct the Scanner and PrintWriter objects for reading and writing\n    File inputFile = new File(inputFileName);\n    Scanner in = new Scanner(inputFile);\n    PrintWriter out = new PrintWriter(outputFileName);\n    // Read the input and write the output\n    double total = 0;\n    // We read a line at a time since there may be spaces in the item names\n    while (in.hasNextLine()) {\n        String line = in.nextLine();\n        boolean found = false;\n        String item = \"\";\n        double price = 0;\n        for (int i = 0; !found && i < line.length(); i++) {\n            char ch = line.charAt(i);\n            if (ch == ':') {\n                found = true;\n                item = line.substring(0, i + 1);\n                price = Double.parseDouble(line.substring(i + 1).trim());\n                total = total + price;\n            }\n        }\n        // If no colon was found, we skip the line\n        if (found) {\n            out.printf(\"%-20s%10.2f\\n\", item, price);\n        }\n    }\n    out.printf(\"%-20s%10.2f\\n\", \"Total:\", total);\n    in.close();\n    out.close();\n}\n","name":"main","className":"Items","variables":{"console":3,"item":2,"outputFileName":2,"inputFileName":2,"in":4,"ch":2,"line":5,"Double":1,"out":4,"args":1,"inputFile":2,"total":3,"found":4,"price":3},"javaDoc":"","comments":"Prompt for the input and output file names Construct the Scanner and PrintWriter objects for reading and writing Read the input and write the output We read a line at a time since there may be spaces in the item names If no colon was found we skip the line ","isEmpty":false,"lineCount":16,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{"\"Amount exceeds balance\"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    if (amount > balance) {\n        throw new IllegalArgumentException(\"Amount exceeds balance\");\n    }\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":3,"balance":3},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1,"withdraw":1,"System.out.println":1},"constants":{"5000":1,"2000":1},"annotations":[],"types":{"BankAccount":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tests the methods of the BankAccount class.\n      @param args not used\n   */\npublic static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount();\n    harrysChecking.deposit(2000);\n    harrysChecking.withdraw(5000);\n    // The last statement is not executed since an exception has\n    // terminated the program\n    System.out.println(harrysChecking.getBalance());\n}\n","name":"main","className":"ThrowingExceptions","variables":{"args":1,"harrysChecking":4},"javaDoc":"Tests the methods of the BankAccount class args not used","comments":"The last statement is not executed since an exception has terminated the program \n      Tests the methods of the BankAccount class.\n      @param args not used\n   ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"double[]","methodCalls":{"readData":1},"constants":{},"annotations":[],"types":{"Scanner":1,"File":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"/**\n      Reads a data set.\n      @param filename the name of the file holding the data\n      @return the data in the file\n   */\npublic double[] readFile(String filename) throws IOException {\n    File inFile = new File(filename);\n    try (Scanner in = new Scanner(inFile)) {\n        readData(in);\n        return data;\n    }\n}\n","name":"readFile","className":"DataSetReader","variables":{"filename":2,"data":1,"in":1,"inFile":2},"javaDoc":"Reads a data set filename the name of the file holding the data the data in the file","comments":"\n      Reads a data set.\n      @param filename the name of the file holding the data\n      @return the data in the file\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Scanner"],"returnType":"void","methodCalls":{"readValue":1,"hasNextInt":1,"hasNext":1,"nextInt":1},"constants":{"\"Length expected\"":1,"\"End of file expected\"":1},"annotations":[],"types":{"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","ArrayCreationExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["BadDataException"],"text":"/**\n      Reads all data.\n      @param in the scanner that scans the data\n   */\nprivate void readData(Scanner in) throws BadDataException {\n    if (!in.hasNextInt()) {\n        throw new BadDataException(\"Length expected\");\n    }\n    int numberOfValues = in.nextInt();\n    data = new double[numberOfValues];\n    for (int i = 0; i < numberOfValues; i++) {\n        readValue(in, i);\n    }\n    if (in.hasNext()) {\n        throw new BadDataException(\"End of file expected\");\n    }\n}\n","name":"readData","className":"DataSetReader","variables":{"data":1,"in":4,"numberOfValues":3},"javaDoc":"Reads all data in the scanner that scans the data","comments":"\n      Reads all data.\n      @param in the scanner that scans the data\n   ","isEmpty":false,"lineCount":5,"modifier":2}
{"paramTypes":["Scanner","int"],"returnType":"void","methodCalls":{"hasNextDouble":1,"nextDouble":1},"constants":{"\"Data value expected\"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","ArrayAccessExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":["BadDataException"],"text":"/**\n      Reads one data value.\n      @param in the scanner that scans the data\n      @param i the position of the value to read\n   */\nprivate void readValue(Scanner in, int i) throws BadDataException {\n    if (!in.hasNextDouble()) {\n        throw new BadDataException(\"Data value expected\");\n    }\n    data[i] = in.nextDouble();\n}\n","name":"readValue","className":"DataSetReader","variables":{"data":1,"in":3},"javaDoc":"Reads one data value in the scanner that scans the data i the position of the value to read","comments":"\n      Reads one data value.\n      @param in the scanner that scans the data\n      @param i the position of the value to read\n   ","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"printStackTrace":1,"readFile":1,"getMessage":1,"System.out.println":4},"constants":{"\"File not found.\"":1,"\"Bad data: \"":1,"\"The sum is \"":1,"\"Please enter the file name: \"":1,"false":1,"true":1},"annotations":[],"types":{"Scanner":1,"boolean":1,"double[]":1,"double":2,"String":1,"DataSetReader":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","TryStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":["BadDataException","FileNotFoundException","IOException"],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    DataSetReader reader = new DataSetReader();\n    boolean done = false;\n    while (!done) {\n        try {\n            System.out.println(\"Please enter the file name: \");\n            String filename = in.next();\n            double[] data = reader.readFile(filename);\n            double sum = 0;\n            for (double d : data) {\n                sum = sum + d;\n            }\n            System.out.println(\"The sum is \" + sum);\n            done = true;\n        } catch (FileNotFoundException exception) {\n            System.out.println(\"File not found.\");\n        } catch (BadDataException exception) {\n            System.out.println(\"Bad data: \" + exception.getMessage());\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        }\n    }\n}\n","name":"main","className":"DataAnalyzer","variables":{"args":1,"exception":5,"filename":1,"data":2,"in":2,"reader":2,"sum":4,"done":3},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"BadDataException","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public BadDataException() {\n}\n","name":"BadDataException","className":"BadDataException","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["String"],"returnType":"BadDataException","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"public BadDataException(String message) {\n    super(message);\n}\n","name":"BadDataException","className":"BadDataException","variables":{"message":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"lastIndexOf":1,"contains":1,"hasNext":1,"openStream":1,"indexOf":1,"substring":1,"System.out.println":1},"constants":{"\"href=\\\"http://\"":1,"\"\\\"\"":2,"\"http://horstmann.com/index.html\"":1},"annotations":[],"types":{"Scanner":1,"String":2,"URL":1,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    String address = \"http://horstmann.com/index.html\";\n    URL pageLocation = new URL(address);\n    Scanner in = new Scanner(pageLocation.openStream());\n    while (in.hasNext()) {\n        String line = in.next();\n        if (line.contains(\"href=\\\"http://\")) {\n            int from = line.indexOf(\"\\\"\");\n            int to = line.lastIndexOf(\"\\\"\");\n            System.out.println(line.substring(from + 1, to));\n        }\n    }\n}\n","name":"main","className":"WebPageReader","variables":{"args":1,"pageLocation":2,"address":2,"in":3,"line":5,"from":2,"to":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"print":1,"encrypt":1,"usage":2,"useDelimiter":1,"hasNext":1,"close":2,"charAt":3},"constants":{"\"\"":3,"'-'":1,"'d'":1},"annotations":[],"types":{"Scanner":1,"char":3,"String":3,"int":4,"PrintWriter":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","CharLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":["FileNotFoundException"],"text":"public static void main(String[] args) throws FileNotFoundException {\n    final int DEFAULT_KEY = 3;\n    int key = DEFAULT_KEY;\n    String inFile = \"\";\n    String outFile = \"\";\n    // Number of command line arguments that are files\n    int files = 0;\n    for (int i = 0; i < args.length; i++) {\n        String arg = args[i];\n        if (arg.charAt(0) == '-') {\n            // It is a command line option\n            char option = arg.charAt(1);\n            if (option == 'd') {\n                key = -key;\n            } else {\n                usage();\n                return;\n            }\n        } else {\n            // It is a file name\n            files++;\n            if (files == 1) {\n                inFile = arg;\n            } else if (files == 2) {\n                outFile = arg;\n            }\n        }\n    }\n    if (files != 2) {\n        usage();\n        return;\n    }\n    Scanner in = new Scanner(new File(inFile));\n    // Process individual characters\n    in.useDelimiter(\"\");\n    PrintWriter out = new PrintWriter(outFile);\n    while (in.hasNext()) {\n        char from = in.next().charAt(0);\n        char to = encrypt(from, key);\n        out.print(to);\n    }\n    in.close();\n    out.close();\n}\n","name":"main","className":"CaesarCipher","variables":{"args":2,"outFile":3,"in":5,"arg":5,"files":5,"DEFAULT_KEY":2,"from":1,"to":1,"inFile":3,"key":3,"option":2,"out":3},"javaDoc":"","comments":"Number of command line arguments that are files It is a command line option It is a file name Process individual characters ","isEmpty":false,"lineCount":13,"modifier":9}
{"paramTypes":["char","int"],"returnType":"char","methodCalls":{},"constants":{"'Z'":1,"'z'":1,"26":1,"'A'":2,"'a'":2},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","CastExpr","CharLiteralExpr","EnclosedExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"/**\n      Encrypts upper- and lowercase characters by shifting them\n      according to a key.\n      @param ch the letter to be encrypted\n      @param key the encryption key\n      @return the encrypted letter      \n   */\npublic static char encrypt(char ch, int key) {\n    int base = 0;\n    if ('A' <= ch && ch <= 'Z') {\n        base = 'A';\n    } else if ('a' <= ch && ch <= 'z') {\n        base = 'a';\n    } else // Not a letter\n    {\n        return ch;\n    }\n    int offset = ch - base + key;\n    // Number of letters in the Roman alphabet\n    final int LETTERS = 26;\n    if (offset >= LETTERS) {\n        offset = offset - LETTERS;\n    } else if (offset < 0) {\n        offset = offset + LETTERS;\n    }\n    return (char) (base + offset);\n}\n","name":"encrypt","className":"CaesarCipher","variables":{"LETTERS":4,"offset":8,"ch":7,"key":2,"base":5},"javaDoc":"Encrypts upper- and lowercase characters by shifting them according to a key ch the letter to be encrypted key the encryption key the encrypted letter","comments":"Not a letter Number of letters in the Roman alphabet \n      Encrypts upper- and lowercase characters by shifting them\n      according to a key.\n      @param ch the letter to be encrypted\n      @param key the encryption key\n      @return the encrypted letter      \n   ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"Usage: java CaesarCipher [-d] infile outfile\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Prints a message describing proper usage.\n   */\npublic static void usage() {\n    System.out.println(\"Usage: java CaesarCipher [-d] infile outfile\");\n}\n","name":"usage","className":"CaesarCipher","variables":{},"javaDoc":"Prints a message describing proper usage","comments":"\n      Prints a message describing proper usage.\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"CountryValue","methodCalls":{"parseDouble":1,"trim":1,"isDigit":1,"isWhitespace":1,"charAt":2,"substring":2},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a CountryValue from an input line.\n      @param line a line containing a country name, followed by a value\n   */\npublic CountryValue(String line) {\n    // Locate the start of the first digit\n    int i = 0;\n    while (!Character.isDigit(line.charAt(i))) {\n        i++;\n    }\n    // Locate the end of the preceding word\n    int j = i - 1;\n    while (Character.isWhitespace(line.charAt(j))) {\n        j--;\n    }\n    // Extract the country name\n    country = line.substring(0, j + 1);\n    // Extract the value\n    value = Double.parseDouble(line.substring(i).trim());\n}\n","name":"CountryValue","className":"CountryValue","variables":{"country":1,"Character":2,"line":5,"value":1,"Double":1},"javaDoc":"Constructs a CountryValue from an input line line a line containing a country name followed by a value","comments":"Locate the start of the first digit Locate the end of the preceding word Extract the country name Extract the value \n      Constructs a CountryValue from an input line.\n      @param line a line containing a country name, followed by a value\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the country name.\n      @return the country name\n   */\npublic String getCountry() {\n    return country;\n}\n","name":"getCountry","className":"CountryValue","variables":{"country":1},"javaDoc":"Gets the country name the country name","comments":"\n      Gets the country name.\n      @return the country name\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the associated value.\n      @return the value associated with the country\n   */\npublic double getValue() {\n    return value;\n}\n","name":"getValue","className":"CountryValue","variables":{"value":1},"javaDoc":"Gets the associated value the value associated with the country","comments":"\n      Gets the associated value.\n      @return the value associated with the country\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getValue":3,"getCountry":1,"nextLine":2,"hasNextLine":2,"close":3,"printf":1},"constants":{"\"worldarea.txt\"":1,"\"worldpop.txt\"":1,"\"world_pop_density.txt\"":1,"\"%-40s%15.2f\\n\"":1},"annotations":[],"types":{"Scanner":2,"double":1,"CountryValue":2,"PrintWriter":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["FileNotFoundException"],"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Open input files\n    Scanner in1 = new Scanner(new File(\"worldpop.txt\"));\n    Scanner in2 = new Scanner(new File(\"worldarea.txt\"));\n    // Open output file\n    PrintWriter out = new PrintWriter(\"world_pop_density.txt\");\n    // Read lines from each file\n    while (in1.hasNextLine() && in2.hasNextLine()) {\n        CountryValue population = new CountryValue(in1.nextLine());\n        CountryValue area = new CountryValue(in2.nextLine());\n        // Compute and print the population density\n        double density = 0;\n        if (// Protect against division by zero\n        area.getValue() != 0) {\n            density = population.getValue() / area.getValue();\n        }\n        out.printf(\"%-40s%15.2f\\n\", population.getCountry(), density);\n    }\n    in1.close();\n    in2.close();\n    out.close();\n}\n","name":"main","className":"PopulationDensity","variables":{"args":1,"area":3,"density":2,"in2":4,"in1":4,"out":3,"population":3},"javaDoc":"","comments":"Open input files Open output file Read lines from each file Compute and print the population density Protect against division by zero ","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["double"],"returnType":"RecordReader","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a RecordReader with a zero total.\n   */\npublic RecordReader(double aLimit) {\n    total = 0;\n    limit = aLimit;\n}\n","name":"RecordReader","className":"RecordReader","variables":{"total":1,"limit":1,"aLimit":2},"javaDoc":"Constructs a RecordReader with a zero total","comments":"\n      Constructs a RecordReader with a zero total.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Scanner"],"returnType":"void","methodCalls":{"next":1,"nextInt":1,"nextDouble":1,"System.out.print":1},"constants":{"\" \"":1},"annotations":[],"types":{"double":1,"String":1,"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Reads an input record and prints the name if the current total is less \n      than the limit.\n      @param in the input stream\n   */\npublic void process(Scanner in) {\n    String name = in.next();\n    int count = in.nextInt();\n    double percent = in.nextDouble();\n    if (total < limit) {\n        System.out.print(name + \" \");\n    }\n    total = total + percent;\n}\n","name":"process","className":"RecordReader","variables":{"total":3,"in":4,"name":2,"count":1,"limit":1,"percent":2},"javaDoc":"Reads an input record and prints the name if the current total is less than the limit in the input stream","comments":"\n      Reads an input record and prints the name if the current total is less \n      than the limit.\n      @param in the input stream\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether there are more inputs to process\n      @return true if the limit has not yet been reached\n   */\npublic boolean hasMore() {\n    return total < limit;\n}\n","name":"hasMore","className":"RecordReader","variables":{"total":1,"limit":1},"javaDoc":"Checks whether there are more inputs to process true if the limit has not yet been reached","comments":"\n      Checks whether there are more inputs to process\n      @return true if the limit has not yet been reached\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":2,"hasMore":2,"nextInt":1,"System.out.print":1,"System.out.println":1},"constants":{"\" \"":1,"\"babynames.txt\"":1},"annotations":[],"types":{"Scanner":1,"RecordReader":2,"int":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["FileNotFoundException"],"text":"public static void main(String[] args) throws FileNotFoundException {\n    try (Scanner in = new Scanner(new File(\"babynames.txt\"))) {\n        RecordReader boys = new RecordReader(LIMIT);\n        RecordReader girls = new RecordReader(LIMIT);\n        while (boys.hasMore() || girls.hasMore()) {\n            int rank = in.nextInt();\n            System.out.print(rank + \" \");\n            boys.process(in);\n            girls.process(in);\n            System.out.println();\n        }\n    }\n}\n","name":"main","className":"BabyNames","variables":{"args":1,"in":2,"boys":3,"rank":2,"LIMIT":2,"girls":3},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"showOpenDialog":1,"getSelectedFile":1,"nextLine":1,"hasNextLine":2,"System.out.println":2},"constants":{"\"...\"":1,"null":2,"\": \"":1},"annotations":[],"types":{"Scanner":1,"JFileChooser":1,"String":1,"File":1,"int":2},"expressions":["ObjectCreationExpr","NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    JFileChooser chooser = new JFileChooser();\n    Scanner in = null;\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        File selectedFile = chooser.getSelectedFile();\n        in = new Scanner(selectedFile);\n        int lineNumber = 1;\n        final int MAX_LINES = 9;\n        while (in.hasNextLine() && lineNumber <= MAX_LINES) {\n            String line = in.nextLine();\n            System.out.println(lineNumber + \": \" + line);\n            lineNumber++;\n        }\n        if (in.hasNextLine()) {\n            System.out.println(\"...\");\n        }\n    }\n}\n","name":"main","className":"FileChooserDemo","variables":{"args":1,"selectedFile":2,"in":5,"line":2,"MAX_LINES":2,"chooser":3,"lineNumber":4},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"parseInt":1,"printStackTrace":1,"getMessage":1,"hasNext":1,"System.out.println":2},"constants":{"\"Sum: \"":1,"\"test1.txt\"":1},"annotations":[],"types":{"Scanner":1,"String":2,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["NumberFormatException","IOException"],"text":"public static void main(String[] args) {\n    try {\n        String filename = \"test1.txt\";\n        Scanner in = new Scanner(new File(filename));\n        int sum = 0;\n        while (in.hasNext()) {\n            String input = in.next();\n            int value = Integer.parseInt(input);\n            sum = sum + value;\n        }\n        System.out.println(\"Sum: \" + sum);\n    } catch (IOException exception) {\n        exception.printStackTrace();\n    } catch (NumberFormatException exception) {\n        System.out.println(exception.getMessage());\n    }\n}\n","name":"main","className":"CatchingExceptions","variables":{"args":1,"Integer":1,"exception":4,"input":1,"filename":2,"in":3,"sum":4,"value":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"hasNextDouble":1,"close":2,"System.out.print":2,"nextDouble":1,"printf":2},"constants":{"\"Output file: \"":1,"\"Total: %8.2f\\n\"":1,"\"%15.2f\\n\"":1,"\"Input file: \"":1},"annotations":[],"types":{"Scanner":2,"double":2,"String":2,"File":1,"PrintWriter":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["FileNotFoundException"],"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Prompt for the input and output file names\n    Scanner console = new Scanner(System.in);\n    System.out.print(\"Input file: \");\n    String inputFileName = console.next();\n    System.out.print(\"Output file: \");\n    String outputFileName = console.next();\n    // Construct the Scanner and PrintWriter objects for reading and writing\n    File inputFile = new File(inputFileName);\n    Scanner in = new Scanner(inputFile);\n    PrintWriter out = new PrintWriter(outputFileName);\n    // Read the input and write the output\n    double total = 0;\n    while (in.hasNextDouble()) {\n        double value = in.nextDouble();\n        out.printf(\"%15.2f\\n\", value);\n        total = total + value;\n    }\n    out.printf(\"Total: %8.2f\\n\", total);\n    in.close();\n    out.close();\n}\n","name":"main","className":"Total","variables":{"args":1,"console":3,"inputFile":2,"total":3,"outputFileName":2,"inputFileName":2,"in":4,"value":2,"out":4},"javaDoc":"","comments":"Prompt for the input and output file names Construct the Scanner and PrintWriter objects for reading and writing Read the input and write the output ","isEmpty":false,"lineCount":16,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{"\"withdrawal of \"":1,"\" exceeds balance of \"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    if (amount > balance) {\n        throw new InsufficientFundsException(\"withdrawal of \" + amount + \" exceeds balance of \" + balance);\n    }\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":4,"balance":4},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"InsufficientFundsException","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public InsufficientFundsException() {\n}\n","name":"InsufficientFundsException","className":"InsufficientFundsException","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["String"],"returnType":"InsufficientFundsException","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"public InsufficientFundsException(String message) {\n    super(message);\n}\n","name":"InsufficientFundsException","className":"InsufficientFundsException","variables":{"message":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1,"withdraw":1,"System.out.println":1},"constants":{"5000":1,"2000":1},"annotations":[],"types":{"BankAccount":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tests the methods of the BankAccount class.\n      @param args not used\n   */\npublic static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount();\n    harrysChecking.deposit(2000);\n    harrysChecking.withdraw(5000);\n    // The last statement is not executed since an exception has\n    // terminated the program\n    System.out.println(harrysChecking.getBalance());\n}\n","name":"main","className":"CustomExceptions","variables":{"args":1,"harrysChecking":4},"javaDoc":"Tests the methods of the BankAccount class args not used","comments":"The last statement is not executed since an exception has terminated the program \n      Tests the methods of the BankAccount class.\n      @param args not used\n   ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":2},"constants":{"\"Hello, World!\"":1,"\"Goodbye, World!\"":1},"annotations":[],"types":{"GreetingRunnable":2,"Thread":2},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    GreetingRunnable r1 = new GreetingRunnable(\"Hello, World!\");\n    GreetingRunnable r2 = new GreetingRunnable(\"Goodbye, World!\");\n    Thread t1 = new Thread(r1);\n    Thread t2 = new Thread(r2);\n    t1.start();\n    t2.start();\n}\n","name":"main","className":"GreetingThreadTester","variables":{"args":1,"r2":2,"t1":2,"t2":2,"r1":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String"],"returnType":"GreetingRunnable","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs the runnable object.\n      @param aGreeting the greeting to display\n   */\npublic GreetingRunnable(String aGreeting) {\n    greeting = aGreeting;\n}\n","name":"GreetingRunnable","className":"GreetingRunnable","variables":{"greeting":1,"aGreeting":2},"javaDoc":"Constructs the runnable object aGreeting the greeting to display","comments":"\n      Constructs the runnable object.\n      @param aGreeting the greeting to display\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":1},"constants":{"\" \"":1},"annotations":[],"types":{"int":1,"Date":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"public void run() {\n    try {\n        for (int i = 1; i <= REPETITIONS; i++) {\n            Date now = new Date();\n            System.out.println(now + \" \" + greeting);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"GreetingRunnable","variables":{"exception":1,"now":2,"greeting":1,"REPETITIONS":1,"Thread":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"completeTask":1,"System.out.println":2},"constants":{"\"Timer task started at:\"":1,"\"Timer task finished at:\"":1},"annotations":["Override"],"types":{},"expressions":["ObjectCreationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"@Override\npublic void run() {\n    System.out.println(\"Timer task started at:\" + new Date());\n    completeTask();\n    System.out.println(\"Timer task finished at:\" + new Date());\n}\n","name":"run","className":"UtilTimer","variables":{},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"printStackTrace":1},"constants":{"5000":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"private void completeTask() {\n    try {\n        //assuming it takes 5 secs to complete the task\n        Thread.sleep(5000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n","name":"completeTask","className":"UtilTimer","variables":{"Thread":1},"javaDoc":"","comments":"assuming it takes 5 secs to complete the task ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"scheduleAtFixedRate":1,"sleep":2,"cancel":1,"printStackTrace":2,"System.out.println":2},"constants":{"\"TimerTask cancelled\"":1,"120000":1,"30000":1,"true":1,"1000":1,"\"TimerTask started\"":1,"10":1},"annotations":[],"types":{"TimerTask":1,"Timer":1,"UtilTimer":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["InterruptedException"],"text":"public static void main(String args[]) {\n    TimerTask timerTask = new UtilTimer();\n    //running timer task as daemon thread\n    Timer timer = new Timer(true);\n    timer.scheduleAtFixedRate(timerTask, 0, 10 * 1000);\n    System.out.println(\"TimerTask started\");\n    //cancel after sometime\n    try {\n        Thread.sleep(120000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    timer.cancel();\n    System.out.println(\"TimerTask cancelled\");\n    try {\n        Thread.sleep(30000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n","name":"main","className":"UtilTimer","variables":{"args":1,"timer":3,"timerTask":1,"Thread":2},"javaDoc":"","comments":"running timer task as daemon thread cancel after sometime ","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":[],"returnType":"ReboundPanel","methodCalls":{"setPreferredSize":1,"start":1,"setBackground":1},"constants":{"100":1,"300":1,"40":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//-----------------------------------------------------------------\npublic ReboundPanel() {\n    timer = new Timer(DELAY, new ReboundListener());\n    timer.start();\n    x = 0;\n    y = 40;\n    moveX = 3;\n    moveY = 3;\n    setBackground(Color.black);\n    setPreferredSize(new Dimension(300, 100));\n}\n","name":"ReboundPanel","className":"ReboundPanel","variables":{"timer":2,"moveX":1,"moveY":1,"DELAY":1},"javaDoc":"","comments":"-----------------------------------------------------------------","isEmpty":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"Timer","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"// accessor method of timer to be used in the applet class.\npublic Timer getTimer() {\n    return timer;\n}\n","name":"getTimer","className":"ReboundPanel","variables":{"timer":1},"javaDoc":"","comments":" accessor method of timer to be used in the applet class.","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":1,"fillOval":1},"constants":{},"annotations":[],"types":{},"expressions":["SuperExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//  Draws the circle in the current location.\npublic void paintComponent(Graphics page) {\n    super.paintComponent(page);\n    page.setColor(Color.yellow);\n    page.fillOval(x, y, DIAMETER, DIAMETER);\n}\n","name":"paintComponent","className":"ReboundPanel","variables":{"page":3},"javaDoc":"","comments":"  Draws the circle in the current location.","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSize":2,"getHeight":1,"getWidth":1,"repaint":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//  Updates the position of the image and possibly the direction\n//  of movement whenever the timer fires an action event.\npublic void actionPerformed(ActionEvent event) {\n    x += moveX;\n    y += moveY;\n    //it changes its direction.\n    if (x <= 0 || x >= getSize().getWidth() - DIAMETER)\n        moveX = moveX * -1;\n    if (y <= 0 || y >= getSize().getHeight() - DIAMETER)\n        moveY = moveY * -1;\n    repaint();\n}\n","name":"actionPerformed","className":"ReboundListener","variables":{"DIAMETER":2,"moveX":3,"event":1,"moveY":3},"javaDoc":"","comments":"if the circle hits the applets boundary it changes its direction   of movement whenever the timer fires an action event.","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"getContentPane":1},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void init() {\n    panel = new ReboundPanel();\n    getContentPane().add(panel);\n}\n","name":"init","className":"Rebound","variables":{"panel":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"start":1,"getTimer":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//  Starts the animation when the applet is started.\npublic void start() {\n    panel.getTimer().start();\n}\n","name":"start","className":"Rebound","variables":{"panel":1},"javaDoc":"","comments":"  Starts the animation when the applet is started.","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"stop":1,"getTimer":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//  Stops the animation when the applet is stopped.\npublic void stop() {\n    panel.getTimer().stop();\n}\n","name":"stop","className":"Rebound","variables":{"panel":1},"javaDoc":"","comments":"  Stops the animation when the applet is stopped.","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"WholePanel","methodCalls":{"add":11,"this.redB.addActionListener":1,"addActionListener":6,"addMouseMotionListener":1,"setLayout":1,"setBackground":1,"addMouseListener":1},"constants":{"\"red\"":1,"\"Erase\"":1,"true":1,"\"Undo\"":1,"\"blue\"":1,"\"black\"":1,"\"orange\"":1,"\"green\"":1},"annotations":[],"types":{"ButtonGroup":1,"JSplitPane":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","AssignExpr","BooleanLiteralExpr","FieldAccessExpr","ArrayCreationExpr","ThisExpr","MethodCallExpr"],"statements":["ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public WholePanel() {\n    //initialize ArrayList\n    rectList = new ArrayList();\n    //default color to draw rectangles is black\n    currentColor = Color.black;\n    //create buttons\t  \n    erase = new JButton(\"Erase\");\n    undo = new JButton(\"Undo\");\n    erase.addActionListener(new ButtonListener());\n    undo.addActionListener(new ButtonListener());\n    //create radio buttons for 5 colors\n    //at the bginning, black will be chosen by default\n    blackB = new JRadioButton(\"black\", true);\n    redB = new JRadioButton(\"red\");\n    blueB = new JRadioButton(\"blue\");\n    greenB = new JRadioButton(\"green\");\n    orangeB = new JRadioButton(\"orange\");\n    //store 5 colors in an array\n    colorRButtons = new JRadioButton[5];\n    colorRButtons[0] = blackB;\n    colorRButtons[1] = redB;\n    colorRButtons[2] = blueB;\n    colorRButtons[3] = greenB;\n    colorRButtons[4] = orangeB;\n    colors = new Color[5];\n    colors[0] = Color.BLACK;\n    colors[1] = Color.RED;\n    colors[2] = Color.blue;\n    colors[3] = Color.green;\n    colors[4] = Color.ORANGE;\n    //Create a group of radio buttons so that at any time only one can be selected,\n    ButtonGroup group = new ButtonGroup();\n    for (int i = 0; i < colorRButtons.length; i++) group.add(colorRButtons[i]);\n    //add ColorListener to each of the radio buttons\n    blackB.addActionListener(new ColorListener());\n    this.redB.addActionListener(new ColorListener());\n    blueB.addActionListener(new ColorListener());\n    greenB.addActionListener(new ColorListener());\n    orangeB.addActionListener(new ColorListener());\n    //primary panel contains all radiobuttons, add the radio buttons to the panel\n    primary = new JPanel(new GridLayout(5, 1));\n    primary.add(blackB);\n    primary.add(redB);\n    primary.add(blueB);\n    primary.add(greenB);\n    primary.add(orangeB);\n    //canvas panel is where rectangles will be drawn, thus\n    //it will listen to a mouse event.\n    canvas = new CanvasPanel();\n    canvas.setBackground(Color.white);\n    //add MouseListener & MouseMotionListener to canvas\n    canvas.addMouseListener(new PointListener());\n    canvas.addMouseMotionListener(new PointListener());\n    leftPanel = new JPanel(new GridLayout(2, 1));\n    buttonPanel = new JPanel(new GridLayout(2, 1));\n    buttonPanel.add(undo);\n    buttonPanel.add(erase);\n    leftPanel.add(primary);\n    leftPanel.add(buttonPanel);\n    JSplitPane sp = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, leftPanel, canvas);\n    setLayout(new BorderLayout());\n    add(sp);\n}\n","name":"WholePanel","className":"WholePanel","variables":{"erase":2,"canvas":5,"redB":2,"leftPanel":4,"greenB":3,"colorRButtons":7,"currentColor":1,"colors":6,"undo":2,"orangeB":3,"rectList":1,"buttonPanel":3,"blackB":3,"sp":1,"blueB":3,"group":2,"primary":6},"javaDoc":"","comments":"create radio buttons for 5 colors canvas panel is where rectangles will be drawn thus initialize ArrayList default color to draw rectangles is black create buttons at the bginning black will be chosen by default store 5 colors in an array Create a group of radio buttons so that at any time only one can be selected add ColorListener to each of the radio buttons primary panel contains all radiobuttons add the radio buttons to the panel it will listen to a mouse event add MouseListener & MouseMotionListener to canvas ","isEmpty":false,"lineCount":51,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"size":2,"getSource":1,"repaint":1,"remove":1},"constants":{},"annotations":[],"types":{"Object":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    Object source = event.getSource();\n    if (// in case \"undo\" button is clicked\n    source == undo) {\n        if (rectList.size() > 0) {\n            // check whether there are any recs\n            rectList.remove(rectList.size() - 1);\n            canvas.repaint();\n        }\n    } else {\n        rectList = new ArrayList<Rect>();\n    }\n}\n","name":"actionPerformed","className":"ButtonListener","variables":{"undo":1,"canvas":1,"rectList":4,"source":2,"event":2},"javaDoc":"","comments":"in case \"undo\" button is clicked check whether there are any recs ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSource":1,"getText":1,"isSelected":1,"equalsIgnoreCase":1},"constants":{},"annotations":[],"types":{"JRadioButton":1,"String":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","CastExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BreakStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    JRadioButton tempButton = (JRadioButton) event.getSource();\n    if (tempButton.isSelected()) {\n        String colorText = tempButton.getText();\n        for (int i = 0; i < colorRButtons.length; i++) {\n            if (colorText.equalsIgnoreCase(colorRButtons[i].getText())) {\n                currentColor = colors[i];\n                //System.out.println(i);\n                break;\n            }\n        }\n    }\n}\n","name":"actionPerformed","className":"ColorListener","variables":{"colorText":2,"colorRButtons":1,"currentColor":1,"event":2,"tempButton":3,"colors":1},"javaDoc":"","comments":"System out println(colorText+ \" is selected\"); System out println(i); ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":1,"size":1,"repaint":2,"drawRect":1},"constants":{"true":1,"false":1},"annotations":[],"types":{"Object":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","SuperExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","CastExpr","EnclosedExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//this method draws all rectangles specified by a user\npublic void paintComponent(Graphics page) {\n    super.paintComponent(page);\n    if (mouseDragged == true) {\n        page.drawRect(x1, y1, x2, y2);\n        mouseDragged = false;\n        canvas.repaint();\n    } else {\n        if (rectList.size() > 0) {\n            for (Object o : rectList) {\n                //System.out.println(currentColor);\n                page.setColor(((Rect) o).getColor());\n                ((Rect) o).draw(page);\n                canvas.repaint();\n            }\n        }\n    }\n}\n","name":"paintComponent","className":"CanvasPanel","variables":{"canvas":2,"rectList":2,"mouseDragged":2,"page":3},"javaDoc":"","comments":"Only draw an outline of the rectangle when the mouse is draaged but not released fill the whole rectangel with the correct color when mouse is released System out println(currentColor); this method draws all rectangles specified by a user","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getPoint":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//in case that a user presses using a mouse,\n//record the point where it was pressed.\npublic void mousePressed(MouseEvent event) {\n    firstPoint = event.getPoint();\n    x1 = firstPoint.x;\n    y1 = firstPoint.y;\n}\n","name":"mousePressed","className":"PointListener","variables":{"firstPoint":1,"y1":1,"x1":1,"event":2},"javaDoc":"","comments":"record the point where it was pressed.","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"add":1,"getPoint":1,"abs":2,"repaint":1},"constants":{},"annotations":[],"types":{"Color":1,"Point":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//mouseReleased method takes the point where a mouse is released,\n//using the point and the pressed point to create a rectangle,\n//add it to the ArrayList \"rectList\", and call paintComponent method.\npublic void mouseReleased(MouseEvent event) {\n    Point newPoint = event.getPoint();\n    x2 = newPoint.x;\n    y2 = newPoint.y;\n    Color c = currentColor;\n    rectList.add(new Rect(firstPoint.x, firstPoint.y, Math.abs(newPoint.x - firstPoint.x), Math.abs(newPoint.y - firstPoint.y), c));\n    canvas.repaint();\n}\n","name":"mouseReleased","className":"PointListener","variables":{"newPoint":1,"canvas":1,"rectList":1,"y2":1,"x2":1,"currentColor":1,"event":2,"Math":2},"javaDoc":"","comments":"add it to the ArrayList \"rectList\", and call paintComponent method.","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getPoint":1,"paintComponent":1,"getGraphics":1,"repaint":1},"constants":{"true":1},"annotations":[],"types":{"Point":1},"expressions":["VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//mouseDragged method takes the point where a mouse is dragged\n//and call paintComponent method\npublic void mouseDragged(MouseEvent event) {\n    mouseDragged = true;\n    Point p3 = event.getPoint();\n    x3 = p3.x;\n    y3 = p3.y;\n    canvas.paintComponent(canvas.getGraphics());\n    canvas.repaint();\n}\n","name":"mouseDragged","className":"PointListener","variables":{"canvas":3,"p3":1,"mouseDragged":1,"y3":1,"x3":1,"event":2},"javaDoc":"","comments":"and call paintComponent method","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"// public void mouseClicked (MouseEvent event) {}\npublic void mouseEntered(MouseEvent event) {\n}\n","name":"mouseEntered","className":"PointListener","variables":{"event":1},"javaDoc":"","comments":" public void mouseClicked (MouseEvent event) {}","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void mouseExited(MouseEvent event) {\n}\n","name":"mouseExited","className":"PointListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void mouseMoved(MouseEvent event) {\n}\n","name":"mouseMoved","className":"PointListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["Vector<Car>"],"returnType":"PurchasePanel","methodCalls":{"add":8,"addActionListener":2,"format":1,"setSelectionMode":2,"setLayout":1,"getCurrencyInstance":1},"constants":{"\"Selected car(s)\"":1,"0.0d":1,"\" car(s) selected\"":1,"1.d":2,"\"Available car(s)\"":1,"\"Remove a Car\"":1,"\"Total amount: \"":1,"\"Pick a Car\"":1},"annotations":[],"types":{"GridBagConstraints":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// layouts\npublic PurchasePanel(Vector<Car> carList) {\n    numSelected = 0;\n    totalPrice = 0.0d;\n    this.carList = carList;\n    selectedList = new Vector();\n    cList = new JList(carList);\n    buyList = new JList(selectedList);\n    cList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    buyList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    available = new JLabel(\"Available car(s)\");\n    selected = new JLabel(\"Selected car(s)\");\n    lblSelectedCount = new JLabel(numSelected + \" car(s) selected\");\n    lblTotal = new JLabel(\"Total amount: \" + NumberFormat.getCurrencyInstance().format(totalPrice));\n    add = new JButton(\"Pick a Car\");\n    add.addActionListener(new ButtonListener());\n    remove = new JButton(\"Remove a Car\");\n    remove.addActionListener(new ButtonListener());\n    // ******Never forget to register the listener object with its source\n    // object ******//\n    GridBagConstraints c = new GridBagConstraints();\n    setLayout(new GridBagLayout());\n    c.anchor = GridBagConstraints.FIRST_LINE_START;\n    c.gridx = 0;\n    c.gridy = 0;\n    add(available, c);\n    c.gridx = 0;\n    c.gridy = 3;\n    add(selected, c);\n    c.gridx = 0;\n    c.gridy = 5;\n    add(lblSelectedCount, c);\n    c.gridx = 1;\n    c.gridy = 5;\n    add(lblTotal, c);\n    c.weightx = 1.d;\n    c.weighty = 1.d;\n    c.fill = GridBagConstraints.BOTH;\n    c.gridx = 0;\n    c.gridy = 1;\n    c.gridwidth = 2;\n    add(new JScrollPane(cList), c);\n    c.gridx = 0;\n    c.gridy = 2;\n    c.gridwidth = 1;\n    add(add, c);\n    c.gridx = 1;\n    c.gridy = 2;\n    c.gridwidth = 1;\n    add(remove, c);\n    c.gridx = 0;\n    c.gridy = 4;\n    c.gridwidth = 2;\n    add(new JScrollPane(buyList), c);\n}\n","name":"PurchasePanel","className":"PurchasePanel","variables":{"add":2,"lblSelectedCount":1,"totalPrice":1,"available":1,"carList":3,"lblTotal":1,"remove":2,"selectedList":2,"buyList":3,"cList":3,"numSelected":2,"selected":1,"NumberFormat":1},"javaDoc":"","comments":"Never forget to register the listener object with its source object //  layouts","isEmpty":false,"lineCount":51,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setListData":2},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// end of constructor\n// This method refresh the JList \"cList\" with pdated vector carList\n// information\npublic void updateCarList() {\n    cList.setListData(carList);\n    buyList.setListData(selectedList);\n}\n","name":"updateCarList","className":"PurchasePanel","variables":{"buyList":1,"cList":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"add":2,"getSource":2,"updateCarList":1,"format":1,"getSelectedValue":8,"equalsIgnoreCase":1,"getCurrencyInstance":1,"remove":2,"System.out.println":1,"setText":2},"constants":{"\"\"":1,"\" button is pushed!\"":1,"null":3,"\" car(s) selected\"":1,"\"Total amount: \"":1,"\"Pick a Car\"":1},"annotations":[],"types":{"String":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","CastExpr","FieldAccessExpr","EnclosedExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    String whichButton = \"\";\n    if (event.getSource() != null) {\n        whichButton = ((JButton) event.getSource()).getText();\n        System.out.println(whichButton + \" button is pushed!\");\n    }\n    if (whichButton.equalsIgnoreCase(\"Pick a Car\")) {\n        if (cList.getSelectedValue() != null) {\n            numSelected++;\n            totalPrice += ((Car) cList.getSelectedValue()).getPrice();\n            selectedList.add((Car) cList.getSelectedValue());\n            carList.remove(cList.getSelectedValue());\n        }\n    } else {\n        if (buyList.getSelectedValue() != null) {\n            numSelected--;\n            totalPrice -= ((Car) buyList.getSelectedValue()).getPrice();\n            carList.add((Car) buyList.getSelectedValue());\n            selectedList.remove(buyList.getSelectedValue());\n        }\n    }\n    lblSelectedCount.setText(numSelected + \" car(s) selected\");\n    lblTotal.setText(\"Total amount: \" + NumberFormat.getCurrencyInstance().format(totalPrice));\n    updateCarList();\n}\n","name":"actionPerformed","className":"ButtonListener","variables":{"selectedList":2,"buyList":4,"lblSelectedCount":1,"whichButton":4,"totalPrice":2,"cList":4,"numSelected":3,"carList":2,"event":3,"lblTotal":1,"NumberFormat":1},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"encryptStream":1,"nextInt":1,"System.out.print":3,"System.out.println":1},"constants":{"\"Output file: \"":1,"\"Encryption key: \"":1,"\"Error processing file: \"":1,"\"Input file: \"":1},"annotations":[],"types":{"Scanner":1,"InputStream":1,"FileOutputStream":1,"OutputStream":1,"String":2,"int":1,"FileInputStream":1,"CaesarCipher":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["IOException"],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Input file: \");\n    String inFile = in.next();\n    System.out.print(\"Output file: \");\n    String outFile = in.next();\n    System.out.print(\"Encryption key: \");\n    int key = in.nextInt();\n    try (InputStream inStream = new FileInputStream(inFile);\n        OutputStream outStream = new FileOutputStream(outFile)) {\n        CaesarCipher cipher = new CaesarCipher(key);\n        cipher.encryptStream(inStream, outStream);\n    } catch (IOException exception) {\n        System.out.println(\"Error processing file: \" + exception);\n    }\n}\n","name":"main","className":"CaesarEncryptor","variables":{"args":1,"cipher":2,"exception":2,"outFile":2,"in":4,"inStream":1,"outStream":1,"inFile":2,"key":2},"javaDoc":"","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["int"],"returnType":"CaesarCipher","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a cipher object with a given key.\n      @param aKey the encryption key\n   */\npublic CaesarCipher(int aKey) {\n    key = aKey;\n}\n","name":"CaesarCipher","className":"CaesarCipher","variables":{"aKey":2,"key":1},"javaDoc":"Constructs a cipher object with a given key aKey the encryption key","comments":"\n      Constructs a cipher object with a given key.\n      @param aKey the encryption key\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"read":1,"encrypt":1,"write":1},"constants":{"false":1,"true":1},"annotations":[],"types":{"boolean":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"/**\n      Encrypts the contents of an input stream.\n      @param in the input stream\n      @param out the output stream\n   */\npublic void encryptStream(InputStream in, OutputStream out) throws IOException {\n    boolean done = false;\n    while (!done) {\n        int next = in.read();\n        if (next == -1) {\n            done = true;\n        } else {\n            int encrypted = encrypt(next);\n            out.write(encrypted);\n        }\n    }\n}\n","name":"encryptStream","className":"CaesarCipher","variables":{"next":2,"encrypted":1,"in":2,"done":3,"out":2},"javaDoc":"Encrypts the contents of an input stream in the input stream out the output stream","comments":"\n      Encrypts the contents of an input stream.\n      @param in the input stream\n      @param out the output stream\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"constants":{"256":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","EnclosedExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Encrypts a value.\n      @param b the value to encrypt (between 0 and 255)\n      @return the encrypted value\n   */\npublic int encrypt(int b) {\n    return (b + key) % 256;\n}\n","name":"encrypt","className":"CaesarCipher","variables":{"key":1},"javaDoc":"Encrypts a value b the value to encrypt (between 0 and 255) the encrypted value","comments":"\n      Encrypts a value.\n      @param b the value to encrypt (between 0 and 255)\n      @return the encrypted value\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getParent":2,"resolve":2,"get":1,"toAbsolutePath":1,"replace":1,"toString":1,"getFileName":2,"System.out.print":2,"System.out.println":7},"constants":{"\"The sibling's file name: \"":1,"\" \"":1,"\"The sibling's path components: \"":1,"\"Changing the extension: \"":1,"\"Its parent: \"":1,"\".bak\"":1,"\"Relative path: \"":1,"\"input.txt\"":1,"\"A sibling: \"":1,"\".txt\"":1,"\"Absolute path: \"":1,"\"output.txt\"":1},"annotations":[],"types":{"Path":7},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Path inputPath = Paths.get(\"input.txt\");\n    System.out.println(\"Relative path: \" + inputPath);\n    Path absolutePath = inputPath.toAbsolutePath();\n    System.out.println(\"Absolute path: \" + absolutePath);\n    Path parent = absolutePath.getParent();\n    System.out.println(\"Its parent: \" + parent);\n    Path sibling = parent.resolve(\"output.txt\");\n    System.out.println(\"A sibling: \" + sibling);\n    Path fileName = sibling.getFileName();\n    System.out.println(\"The sibling's file name: \" + fileName);\n    System.out.print(\"The sibling's path components: \");\n    for (Path p : sibling) {\n        System.out.print(p + \" \");\n    }\n    System.out.println();\n    Path changedExtension = sibling.getParent().resolve(sibling.getFileName().toString().replace(\".txt\", \".bak\"));\n    System.out.println(\"Changing the extension: \" + changedExtension);\n}\n","name":"main","className":"PathDemo","variables":{"args":1,"parent":3,"fileName":2,"inputPath":3,"sibling":6,"absolutePath":3,"Paths":1,"changedExtension":2},"javaDoc":"","isEmpty":false,"lineCount":15,"modifier":9}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   */\npublic BankAccount(int anAccountNumber) {\n    accountNumber = anAccountNumber;\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":2,"balance":1,"accountNumber":1},"javaDoc":"Constructs a bank account with a zero balance anAccountNumber the account number for this account","comments":"\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   */\npublic BankAccount(int anAccountNumber, double initialBalance) {\n    accountNumber = anAccountNumber;\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":2,"balance":1,"initialBalance":2,"accountNumber":1},"javaDoc":"Constructs a bank account with a given balance anAccountNumber the account number for this account initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the account number of this bank account.\n      @return the account number\n   */\npublic int getAccountNumber() {\n    return accountNumber;\n}\n","name":"getAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"javaDoc":"Gets the account number of this bank account the account number","comments":"\n      Gets the account number of this bank account.\n      @return the account number\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankData","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a BankData object that is not associated with a file.\n   */\npublic BankData() {\n    file = null;\n}\n","name":"BankData","className":"BankData","variables":{"file":1},"javaDoc":"Constructs a BankData object that is not associated with a file","comments":"\n      Constructs a BankData object that is not associated with a file.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"close":1},"constants":{"null":1,"\"rw\"":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"/**\n      Opens the data file.\n      @param filename the name of the file containing bank\n      account information\n   */\npublic void open(String filename) throws IOException {\n    if (file != null) {\n        file.close();\n    }\n    file = new RandomAccessFile(filename, \"rw\");\n}\n","name":"open","className":"BankData","variables":{"filename":2,"file":3},"javaDoc":"Opens the data file filename the name of the file containing bank account information","comments":"\n      Opens the data file.\n      @param filename the name of the file containing bank\n      account information\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"length":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","CastExpr","NameExpr","EnclosedExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":["IOException"],"text":"/**\n      Gets the number of accounts in the file.\n      @return the number of accounts\n   */\npublic int size() throws IOException {\n    return (int) (file.length() / RECORD_SIZE);\n}\n","name":"size","className":"BankData","variables":{"file":1,"RECORD_SIZE":1},"javaDoc":"Gets the number of accounts in the file the number of accounts","comments":"\n      Gets the number of accounts in the file.\n      @return the number of accounts\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1},"constants":{"null":2},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"/**\n      Closes the data file.\n   */\npublic void close() throws IOException {\n    if (file != null) {\n        file.close();\n    }\n    file = null;\n}\n","name":"close","className":"BankData","variables":{"file":3},"javaDoc":"Closes the data file","comments":"\n      Closes the data file.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{"readDouble":1,"readInt":1,"seek":1},"constants":{},"annotations":[],"types":{"double":1,"int":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"/**\n      Reads a bank account record.\n      @param n the index of the account in the data file\n      @return a bank account object initialized with the file data\n   */\npublic BankAccount read(int n) throws IOException {\n    file.seek(n * RECORD_SIZE);\n    int accountNumber = file.readInt();\n    double balance = file.readDouble();\n    return new BankAccount(accountNumber, balance);\n}\n","name":"read","className":"BankData","variables":{"file":3,"RECORD_SIZE":1,"balance":2,"accountNumber":2},"javaDoc":"Reads a bank account record n the index of the account in the data file a bank account object initialized with the file data","comments":"\n      Reads a bank account record.\n      @param n the index of the account in the data file\n      @return a bank account object initialized with the file data\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"size":1,"readInt":1,"seek":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"/**\n      Finds the position of a bank account with a given number.\n      @param accountNumber the number to find\n      @return the position of the account with the given number, \n      or -1 if there is no such account\n   */\npublic int find(int accountNumber) throws IOException {\n    for (int i = 0; i < size(); i++) {\n        file.seek(i * RECORD_SIZE);\n        int a = file.readInt();\n        if (a == accountNumber) {\n            return i;\n        }\n    // Found a match            \n    }\n    // No match in the entire file\n    return -1;\n}\n","name":"find","className":"BankData","variables":{"file":2,"RECORD_SIZE":1,"accountNumber":2},"javaDoc":"Finds the position of a bank account with a given number accountNumber the number to find the position of the account with the given number or -1 if there is no such account","comments":"Found a match No match in the entire file \n      Finds the position of a bank account with a given number.\n      @param accountNumber the number to find\n      @return the position of the account with the given number, \n      or -1 if there is no such account\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","BankAccount"],"returnType":"void","methodCalls":{"writeInt":1,"getBalance":1,"getAccountNumber":1,"seek":1,"writeDouble":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"/**\n      Writes a bank account record to the data file.\n      @param n the index of the account in the data file\n      @param account the account to write\n   */\npublic void write(int n, BankAccount account) throws IOException {\n    file.seek(n * RECORD_SIZE);\n    file.writeInt(account.getAccountNumber());\n    file.writeDouble(account.getBalance());\n}\n","name":"write","className":"BankData","variables":{"file":3,"RECORD_SIZE":1,"account":3},"javaDoc":"Writes a bank account record to the data file n the index of the account in the data file account the account to write","comments":"\n      Writes a bank account record to the data file.\n      @param n the index of the account in the data file\n      @param account the account to write\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"read":1,"nextInt":1,"nextDouble":1,"getBalance":1,"size":1,"find":1,"deposit":1,"equalsIgnoreCase":1,"write":1,"open":1,"System.out.print":3,"System.out.println":2},"constants":{"\"Done? (Y/N) \"":1,"\"Account number: \"":1,"\"Adding new account.\"":1,"\"New balance: \"":1,"false":1,"true":1,"\"Amount to deposit: \"":1,"\"bank.dat\"":1,"\"Y\"":1},"annotations":[],"types":{"Scanner":1,"boolean":1,"BankData":1,"double":1,"BankAccount":1,"String":1,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    try (Scanner in = new Scanner(System.in);\n        BankData data = new BankData()) {\n        data.open(\"bank.dat\");\n        boolean done = false;\n        while (!done) {\n            System.out.print(\"Account number: \");\n            int accountNumber = in.nextInt();\n            System.out.print(\"Amount to deposit: \");\n            double amount = in.nextDouble();\n            int position = data.find(accountNumber);\n            BankAccount account;\n            if (position >= 0) {\n                account = data.read(position);\n                account.deposit(amount);\n                System.out.println(\"New balance: \" + account.getBalance());\n            } else // Add account\n            {\n                account = new BankAccount(accountNumber, amount);\n                position = data.size();\n                System.out.println(\"Adding new account.\");\n            }\n            data.write(position, account);\n            System.out.print(\"Done? (Y/N) \");\n            String input = in.next();\n            if (input.equalsIgnoreCase(\"Y\")) {\n                done = true;\n            }\n        }\n    }\n}\n","name":"main","className":"BankSimulator","variables":{"args":1,"input":2,"amount":2,"data":6,"in":4,"position":3,"accountNumber":2,"done":3,"account":5},"javaDoc":"","comments":"Add account ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"toLowerCase":1,"readAllLines":1,"sort":1,"toList":1,"copyOf":1,"delete":2,"getBytes":1,"filter":1,"contains":1,"size":1,"get":7,"readAllBytes":2,"limit":1,"exists":2,"toString":1,"copy":1,"lines":1,"write":3,"collect":1,"System.out.println":8},"constants":{"\".moved\"":1,"\"Size of \"":1,"\" yields \"":1,"\" is in \"":2,"\"Line 11: \"":1,"\" was copied to \"":1,"\";\"":1,"\".copied\"":1,"\": \"":1,"\"First ten bytes: \"":1,"\"UsefulFileOperations.java\"":1,"\"UTF-8\"":2,"\"The first ten lines containing a semicolon: \"":1,"null":1,"\" which was moved to \"":1,"\".sorted\"":1,"\".caesar\"":1,"\"The Caesar encryption of \"":1,"\" bytes\"":1,"\"The lowercase of \"":1,"\"Sorting the lines of \"":1,"10":3,"\".lowercase\"":1},"annotations":[],"types":{"Path":6,"byte[]":2,"String":2,"Stream<String>":1,"long":1,"int":2,"List<String>":2},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","LambdaExpr","NameExpr","StringLiteralExpr","UnaryExpr","AssignExpr","NullLiteralExpr","CastExpr","FieldAccessExpr","EnclosedExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    // Getting the size of a file\n    Path input = Paths.get(\"UsefulFileOperations.java\");\n    long size = Files.size(input);\n    System.out.println(\"Size of \" + input + \": \" + size + \" bytes\");\n    // Reading all lines\n    List<String> lines = Files.readAllLines(input);\n    System.out.println(\"Line 11: \" + lines.get(10));\n    // Reading all bytes\n    byte[] bytes = Files.readAllBytes(input);\n    byte[] firstTen = Arrays.copyOf(bytes, 10);\n    System.out.println(\"First ten bytes: \" + Arrays.toString(firstTen));\n    // Writing lines\n    Collections.sort(lines);\n    Path output1 = Paths.get(input + \".sorted\");\n    Files.write(output1, lines);\n    System.out.println(\"Sorting the lines of \" + input + \" yields \" + output1);\n    // Writing bytes\n    for (int i = 0; i < bytes.length; i++) {\n        bytes[i] = (byte) (bytes[i] + 3);\n    }\n    Path output2 = Paths.get(input + \".caesar\");\n    Files.write(output2, bytes);\n    System.out.println(\"The Caesar encryption of \" + input + \" is in \" + output2);\n    // Reading a file into a string\n    String contents = new String(Files.readAllBytes(input), \"UTF-8\");\n    // Writing a string to a file\n    Path output3 = Paths.get(input + \".lowercase\");\n    contents = contents.toLowerCase();\n    Files.write(output3, contents.getBytes(\"UTF-8\"));\n    System.out.println(\"The lowercase of \" + input + \" is in \" + output3);\n    String target = \";\";\n    final int MAX_LINES = 10;\n    List<String> result = null;\n    try (Stream<String> lineStream = Files.lines(input)) {\n        result = lineStream.filter( s -> s.contains(target)).limit(MAX_LINES).collect(Collectors.toList());\n    }\n    System.out.println(\"The first ten lines containing a semicolon: \" + result);\n    // Copying and moving\n    Path output4 = Paths.get(input + \".copied\");\n    if (Files.exists(output4)) {\n        Files.delete(output4);\n    }\n    Files.copy(input, output4);\n    Path output5 = Paths.get(output4 + \".moved\");\n    if (Files.exists(output5)) {\n        Files.delete(output5);\n    }\n    Files.move(output4, output5);\n    System.out.println(input + \" was copied to \" + output4 + \" which was moved to \" + output5);\n}\n","name":"main","className":"UsefulFileOperations","variables":{"output3":2,"Collectors":1,"output4":3,"output1":2,"output2":2,"output5":2,"lineStream":2,"target":1,"args":1,"result":3,"input":10,"size":2,"firstTen":1,"contents":4,"bytes":3,"MAX_LINES":1,"Paths":6,"Files":14,"lines":2,"Arrays":2,"Collections":1},"javaDoc":"","comments":"Getting the size of a file Reading all lines Reading all bytes Writing lines Writing bytes Reading a file into a string Writing a string to a file Copying and moving ","isEmpty":false,"lineCount":33,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getParent":2,"toAbsolutePath":1,"replace":2,"toList":2,"list":2,"filter":1,"contains":1,"get":1,"toString":1,"collect":2,"map":2,"getFileName":1,"System.out.println":2},"constants":{"\"_\"":1,"\".\"":1,"\"Sections with sample code: \"":1,"\"VisitingDirectories.java\"":1,"\"Entries in \"":1,"\": \"":1,"\"section_\"":2,"\"Section \"":1},"annotations":[],"types":{"Path":2,"Stream<Path>":2,"List<Path>":1,"List<String>":1},"expressions":["VariableDeclarationExpr","BinaryExpr","LambdaExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    Path startingDirectory = Paths.get(\"VisitingDirectories.java\").toAbsolutePath();\n    Path grandParent = startingDirectory.getParent().getParent();\n    try (Stream<Path> entries = Files.list(grandParent)) {\n        List<Path> paths = entries.collect(Collectors.toList());\n        System.out.println(\"Entries in \" + grandParent + \": \" + paths);\n    }\n    try (Stream<Path> entries = Files.list(grandParent)) {\n        List<String> result = entries.map( p -> p.getFileName().toString()).filter( s -> s.contains(\"section_\")).map( s -> s.replace(\"section_\", \"Section \").replace(\"_\", \".\")).collect(Collectors.toList());\n        System.out.println(\"Sections with sample code: \" + result);\n    }\n}\n","name":"main","className":"VisitingDirectories","variables":{"args":1,"startingDirectory":2,"grandParent":2,"result":2,"Collectors":2,"entries":4,"paths":2,"Paths":1,"Files":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getParent":1,"createTempDirectory":1,"get":3,"isRegularFile":1,"exists":2,"createDirectory":1,"createTempFile":1,"delete":2,"createFile":1,"isDirectory":1,"System.out.println":6},"constants":{"\" is a file: \"":1,"\"subdir/test.txt\"":1,"\"subdir/bad\"":1,"\"Created a temporary file \"":1,"\"Created a temporary directory \"":1,"\" is a directory: \"":1,"\"subdir\"":1,"\" exists: \"":2,"\"bigjava\"":2,"\".txt\"":1},"annotations":[],"types":{"Path":4},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    // Creating a directory and a file inside it\n    Files.createDirectory(Paths.get(\"subdir\"));\n    Path testPath = Paths.get(\"subdir/test.txt\");\n    Files.createFile(testPath);\n    // Checking that the file exists\n    System.out.println(testPath + \" exists: \" + Files.exists(testPath));\n    // But this one doesn't exist\n    Path badPath = Paths.get(\"subdir/bad\");\n    System.out.println(badPath + \" exists: \" + Files.exists(badPath));\n    // Confirming that it's a file and not a directory\n    System.out.println(testPath + \" is a file: \" + Files.isRegularFile(testPath));\n    System.out.println(testPath + \" is a directory: \" + Files.isDirectory(testPath));\n    // Deleting what was created\n    Files.delete(testPath);\n    Files.delete(testPath.getParent());\n    Path tempFile = Files.createTempFile(\"bigjava\", \".txt\");\n    System.out.println(\"Created a temporary file \" + tempFile);\n    Path tempDir = Files.createTempDirectory(\"bigjava\");\n    System.out.println(\"Created a temporary directory \" + tempDir);\n}\n","name":"main","className":"CreatingAndDeleting","variables":{"args":1,"testPath":5,"badPath":2,"tempFile":2,"tempDir":2,"Paths":3,"Files":10},"javaDoc":"","comments":"Creating a directory and a file inside it Checking that the file exists But this one doesn't exist Confirming that it's a file and not a directory Deleting what was created ","isEmpty":false,"lineCount":14,"modifier":9}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   */\npublic BankAccount(int anAccountNumber) {\n    accountNumber = anAccountNumber;\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":2,"balance":1,"accountNumber":1},"javaDoc":"Constructs a bank account with a zero balance anAccountNumber the account number for this account","comments":"\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   */\npublic BankAccount(int anAccountNumber, double initialBalance) {\n    accountNumber = anAccountNumber;\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":2,"balance":1,"initialBalance":2,"accountNumber":1},"javaDoc":"Constructs a bank account with a given balance anAccountNumber the account number for this account initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the account number of this bank account.\n      @return the account number\n   */\npublic int getAccountNumber() {\n    return accountNumber;\n}\n","name":"getAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"javaDoc":"Gets the account number of this bank account the account number","comments":"\n      Gets the account number of this bank account.\n      @return the account number\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Bank","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank with no bank accounts.\n   */\npublic Bank() {\n    accounts = new ArrayList<>();\n}\n","name":"Bank","className":"Bank","variables":{"accounts":1},"javaDoc":"Constructs a bank with no bank accounts","comments":"\n      Constructs a bank with no bank accounts.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["BankAccount"],"returnType":"void","methodCalls":{"add":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an account to this bank.\n      @param a the account to add\n   */\npublic void addAccount(BankAccount a) {\n    accounts.add(a);\n}\n","name":"addAccount","className":"Bank","variables":{"accounts":1},"javaDoc":"Adds an account to this bank a the account to add","comments":"\n      Adds an account to this bank.\n      @param a the account to add\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{"getAccountNumber":1},"constants":{"null":1},"annotations":[],"types":{"BankAccount":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Finds a bank account with a given number.\n      @param accountNumber the number to find\n      @return the account with the given number, or null if there\n      is no such account\n   */\npublic BankAccount find(int accountNumber) {\n    for (BankAccount a : accounts) {\n        if (// Found a match\n        a.getAccountNumber() == accountNumber) {\n            return a;\n        }\n    }\n    // No match in the entire array list\n    return null;\n}\n","name":"find","className":"Bank","variables":{"accounts":1,"accountNumber":2},"javaDoc":"Finds a bank account with a given number accountNumber the number to find the account with the given number or null if there is no such account","comments":"Found a match No match in the entire array list \n      Finds a bank account with a given number.\n      @param accountNumber the number to find\n      @return the account with the given number, or null if there\n      is no such account\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":2,"find":2,"writeObject":1,"exists":1,"deposit":1,"getAccountNumber":2,"addAccount":2,"readObject":1,"System.out.println":2},"constants":{"100":1,"1015":2,"20000":1,"1001":2,"10000":1,"\": \"":2,"\"bank.dat\"":1},"annotations":[],"types":{"Bank":1,"BankAccount":1,"ObjectOutputStream":1,"File":1,"ObjectInputStream":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","CastExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException","ClassNotFoundException"],"text":"public static void main(String[] args) throws IOException, ClassNotFoundException {\n    Bank firstBankOfJava;\n    File f = new File(\"bank.dat\");\n    if (f.exists()) {\n        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(f))) {\n            firstBankOfJava = (Bank) in.readObject();\n        }\n    } else {\n        firstBankOfJava = new Bank();\n        firstBankOfJava.addAccount(new BankAccount(1001, 20000));\n        firstBankOfJava.addAccount(new BankAccount(1015, 10000));\n    }\n    // Deposit some money\n    BankAccount a = firstBankOfJava.find(1001);\n    a.deposit(100);\n    System.out.println(a.getAccountNumber() + \": \" + a.getBalance());\n    a = firstBankOfJava.find(1015);\n    System.out.println(a.getAccountNumber() + \": \" + a.getBalance());\n    try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f))) {\n        out.writeObject(firstBankOfJava);\n    }\n}\n","name":"main","className":"SerialDemo","variables":{"args":1,"in":2,"firstBankOfJava":7,"out":2},"javaDoc":"","comments":"Deposit some money ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["String","String","String","int","double"],"returnType":"Student","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Student(String firstname, String lastname, String id, int credit, double rate) {\n    firstName = firstname;\n    lastName = lastname;\n    studentID = id;\n    creditNum = credit;\n    this.rate = rate;\n    tuition = 0;\n}\n","name":"Student","className":"Student","variables":{"studentID":1,"firstName":1,"lastName":1,"firstname":2,"rate":2,"creditNum":1,"id":2,"tuition":1,"credit":2,"lastname":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getCreditNum() {\n    return creditNum;\n}\n","name":"getCreditNum","className":"Student","variables":{"creditNum":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public abstract void computeTuition();\n","name":"computeTuition","className":"Student","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1025}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1,"getCurrencyInstance":1},"constants":{"\"\\nFirst name:\\t\\t\"":1,"\"Last name:\\t\\t\"":1,"\"Rate:\\t\\t\\t\"":1,"\"Student ID:\\t\\t\"":1,"\"+format.format(tuition)+\"":1,"\"Credits:\\t\\t\"":1,"\"Tuition:\\t\\t\"":1,"\"\\n\"":6},"annotations":[],"types":{"NumberFormat":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    NumberFormat format = NumberFormat.getCurrencyInstance();\n    return \"\\nFirst name:\\t\\t\" + firstName + \"\\n\" + \"Last name:\\t\\t\" + lastName + \"\\n\" + \"Student ID:\\t\\t\" + studentID + \"\\n\" + \"Credits:\\t\\t\" + creditNum + \"\\n\" + \"Rate:\\t\\t\\t\" + format.format(rate) + \"\\n\" + \"Tuition:\\t\\t\" + \"+format.format(tuition)+\" + \"\\n\";\n}\n","name":"toString","className":"Student","variables":{"studentID":1,"firstName":1,"lastName":1,"format":2,"creditNum":1,"NumberFormat":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":8,"parseInt":1,"nextLine":1,"equals":7,"push":5,"System.out.println":2},"constants":{"\"Q\"":1,"\"q\"":1,"\"/\"":1,"\"Enter one number or operator per line, Q to quit. \"":1,"\"-\"":1,"false":1,"true":1,"\"+\"":1,"\"*\"":1,"\"x\"":1},"annotations":[],"types":{"Integer":2,"Scanner":1,"boolean":1,"String":1,"Stack<Integer>":1,"Stack":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    Stack<Integer> results = new Stack<>();\n    System.out.println(\"Enter one number or operator per line, Q to quit. \");\n    boolean done = false;\n    while (!done) {\n        String input = in.nextLine();\n        if (input.equals(\"+\")) {\n            results.push(results.pop() + results.pop());\n        } else if (input.equals(\"-\")) {\n            Integer arg2 = results.pop();\n            results.push(results.pop() - arg2);\n        } else if (input.equals(\"*\") || input.equals(\"x\")) {\n            results.push(results.pop() * results.pop());\n        } else if (input.equals(\"/\")) {\n            Integer arg2 = results.pop();\n            results.push(results.pop() / arg2);\n        } else if (input.equals(\"Q\") || input.equals(\"q\")) {\n            done = true;\n        } else {\n            // Not an operator--push the input value\n            results.push(Integer.parseInt(input));\n        }\n        System.out.println(results);\n    }\n}\n","name":"main","className":"Calculator","variables":{"args":1,"Integer":1,"input":8,"arg2":4,"in":2,"results":14,"done":3},"javaDoc":"","comments":"If the command is an operator pop the arguments and push the result Not an operator--push the input value ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"Maze","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a maze from a string describing its contents.\n      @param contents strings consisting of * and spaces\n   */\npublic Maze(String[] contents) {\n    cells = contents;\n}\n","name":"Maze","className":"Maze","variables":{"cells":1,"contents":2},"javaDoc":"Constructs a maze from a string describing its contents contents strings consisting of and spaces","comments":"\n      Constructs a maze from a string describing its contents.\n      @param contents strings consisting of * and spaces\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"ArrayList<Path>","methodCalls":{"add":4,"extend":1,"isValid":4},"constants":{},"annotations":[],"types":{"Path":1,"ArrayList":1,"ArrayList<Path>":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Gets all paths emanating from a position in the maze.\n      @param row the row of the position\n      @param column the column of the position\n      @return all paths emanating from the position\n   */\npublic ArrayList<Path> pathsFrom(int row, int column) {\n    ArrayList<Path> paths = new ArrayList<>();\n    if (isValid(row - 1, column)) {\n        paths.add(new Path(row, column, Path.NORTH));\n    }\n    if (isValid(row, column + 1)) {\n        paths.add(new Path(row, column, Path.EAST));\n    }\n    if (isValid(row + 1, column)) {\n        paths.add(new Path(row, column, Path.SOUTH));\n    }\n    if (isValid(row, column - 1)) {\n        paths.add(new Path(row, column, Path.WEST));\n    }\n    for (Path p : paths) {\n        extend(p);\n    }\n    return paths;\n}\n","name":"pathsFrom","className":"Maze","variables":{"paths":7,"column":7,"row":7},"javaDoc":"Gets all paths emanating from a position in the maze row the row of the position column the column of the position all paths emanating from the position","comments":"\n      Gets all paths emanating from a position in the maze.\n      @param row the row of the position\n      @param column the column of the position\n      @return all paths emanating from the position\n   ","isEmpty":false,"lineCount":7,"modifier":1}
{"paramTypes":["Path"],"returnType":"void","methodCalls":{"move":1,"getNextRow":2,"getEndingRow":1,"getEndingColumn":1,"isValid":2,"countNeighbors":1,"isExit":1,"turn":3,"getNextColumn":2},"constants":{"false":1,"true":1},"annotations":[],"types":{"boolean":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Extends this path to the next exit, intersection, or dead end.\n      @param p the path to extend\n   */\nprivate void extend(Path p) {\n    boolean done = false;\n    while (!done) {\n        p.move();\n        int row = p.getEndingRow();\n        int column = p.getEndingColumn();\n        if (isExit(row, column) || countNeighbors(row, column) != 2) {\n            // Either a straight path or a turn\n            done = true;\n        } else {\n            row = p.getNextRow();\n            column = p.getNextColumn();\n            if (!isValid(row, column)) {\n                p.turn();\n                row = p.getNextRow();\n                column = p.getNextColumn();\n                if (!isValid(row, column)) {\n                    p.turn();\n                    p.turn();\n                }\n            }\n        }\n    }\n}\n","name":"extend","className":"Maze","variables":{"column":3,"row":3,"done":3},"javaDoc":"Extends this path to the next exit intersection or dead end p the path to extend","comments":"Either a straight path or a turn \n      Extends this path to the next exit, intersection, or dead end.\n      @param p the path to extend\n   ","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"constants":{"' '":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","CharLiteralExpr","EnclosedExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether a position is an exit.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is an exit\n   */\npublic boolean isExit(int row, int column) {\n    return (row == 0 || row == cells.length - 1 || column == 0 || column == cells[row].length() - 1) && cells[row].charAt(column) == ' ';\n}\n","name":"isExit","className":"Maze","variables":{"cells":2,"column":3,"row":5},"javaDoc":"Checks whether a position is an exit row the row of the position column the column of the position true if the position is an exit","comments":"\n      Checks whether a position is an exit.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is an exit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{"countNeighbors":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether a position is a dead end.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is a dead end\n   */\npublic boolean isDeadEnd(int row, int column) {\n    return countNeighbors(row, column) == 1;\n}\n","name":"isDeadEnd","className":"Maze","variables":{"column":1,"row":1},"javaDoc":"Checks whether a position is a dead end row the row of the position column the column of the position true if the position is a dead end","comments":"\n      Checks whether a position is a dead end.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is a dead end\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"constants":{"' '":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","CharLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether a position is within the maze and not a wall.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is valid\n   */\nprivate boolean isValid(int row, int column) {\n    return 0 <= row && row < cells.length && 0 <= column && column < cells[row].length() && cells[row].charAt(column) == ' ';\n}\n","name":"isValid","className":"Maze","variables":{"cells":2,"column":3,"row":5},"javaDoc":"Checks whether a position is within the maze and not a wall row the row of the position column the column of the position true if the position is valid","comments":"\n      Checks whether a position is within the maze and not a wall.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is valid\n   ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"isValid":4},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Counts the neighbors of a position.\n      @param row the row of the position\n      @param column the column of the position\n      @return the number of neighbors in the four compass directions\n      that are within the maze and not walls.\n   */\nprivate int countNeighbors(int row, int column) {\n    int count = 0;\n    if (isValid(row - 1, column)) {\n        count++;\n    }\n    if (isValid(row + 1, column)) {\n        count++;\n    }\n    if (isValid(row, column - 1)) {\n        count++;\n    }\n    if (isValid(row, column + 1)) {\n        count++;\n    }\n    return count;\n}\n","name":"countNeighbors","className":"Maze","variables":{"column":3,"count":6,"row":3},"javaDoc":"Counts the neighbors of a position row the row of the position column the column of the position the number of neighbors in the four compass directions that are within the maze and not walls","comments":"\n      Counts the neighbors of a position.\n      @param row the row of the position\n      @param column the column of the position\n      @return the number of neighbors in the four compass directions\n      that are within the maze and not walls.\n   ","isEmpty":false,"lineCount":6,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"solve":1},"constants":{"\"* ****         ***     ******\"":1,"\"******         ******* ******\"":1,"\"**     * ************** *****\"":1,"\"*      ******* ******* ******\"":1,"\"** *** * ********************\"":1,"\"* **** ******* **           *\"":1,"\"*****************************\"":1,"\"** *** *         *          *\"":1,"\"****** ******* *******  *****\"":1,"\"************** **************\"":1,"\"*    ********* ******* ******\"":1,"\"** *** * *******   **** *****\"":1,"\"** ***                      *\"":1},"annotations":[],"types":{"Maze":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","StringLiteralExpr","NameExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Maze maze = new Maze(new String[] { \"*****************************\", \"** ***                      *\", \"** *** * ********************\", \"** *** *         *          *\", \"** *** * *******   **** *****\", \"**     * ************** *****\", \"****** ******* *******  *****\", \"******         ******* ******\", \"*      ******* ******* ******\", \"* **** ******* **           *\", \"*    ********* ******* ******\", \"* ****         ***     ******\", \"************** **************\" });\n    solve(maze, 5, 8);\n}\n","name":"main","className":"MazeSolver","variables":{"args":1,"maze":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["Maze","int","int"],"returnType":"void","methodCalls":{"pop":1,"isDeadEnd":1,"size":1,"getEndingRow":1,"getEndingColumn":1,"isOpposite":1,"isExit":1,"pathsFrom":2,"push":2,"System.out.println":3},"constants":{"\"Following \"":1,"\"Dead end\"":1,"\"Exit!\"":1},"annotations":[],"types":{"Path":3,"Stack<Path>":1,"int":2,"Stack":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Traverses a maze, printing out a path to the exit.\n      @param maze the maze\n      @param param the row of the starting position\n      @param param the column of the starting position\n   */\npublic static void solve(Maze maze, int row, int column) {\n    Stack<Path> s = new Stack<>();\n    for (Path p : maze.pathsFrom(row, column)) {\n        s.push(p);\n    }\n    while (s.size() > 0) {\n        Path p = s.pop();\n        System.out.println(\"Following \" + p);\n        int r = p.getEndingRow();\n        int c = p.getEndingColumn();\n        if (maze.isExit(r, c)) {\n            System.out.println(\"Exit!\");\n            return;\n        } else if (maze.isDeadEnd(r, c)) {\n            System.out.println(\"Dead end\");\n        } else {\n            for (Path p2 : maze.pathsFrom(r, c)) {\n                if (!p2.isOpposite(p)) {\n                    s.push(p2);\n                }\n            }\n        }\n    }\n}\n","name":"solve","className":"MazeSolver","variables":{"p2":2,"column":1,"row":1,"maze":5},"javaDoc":"Traverses a maze printing out a path to the exit maze the maze param the row of the starting position param the column of the starting position","comments":"\n      Traverses a maze, printing out a path to the exit.\n      @param maze the maze\n      @param param the row of the starting position\n      @param param the column of the starting position\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int","int","int"],"returnType":"Path","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a path with a given position and direction\n      @param row the starting row\n      @param column the starting column\n      @param direction the starting direction\n   */\npublic Path(int row, int column, int direction) {\n    startingRow = row;\n    startingColumn = column;\n    startingDirection = direction;\n    endingRow = row;\n    endingColumn = column;\n    endingDirection = direction;\n}\n","name":"Path","className":"Path","variables":{"startingColumn":1,"startingDirection":1,"endingDirection":1,"column":3,"endingRow":1,"row":3,"endingColumn":1,"direction":3,"startingRow":1},"javaDoc":"Constructs a path with a given position and direction row the starting row column the starting column direction the starting direction","comments":"\n      Constructs a path with a given position and direction\n      @param row the starting row\n      @param column the starting column\n      @param direction the starting direction\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getNextRow":1,"getNextColumn":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Moves the ending position of this path one unit in the\n      current direction.\n   */\npublic void move() {\n    endingRow = getNextRow();\n    endingColumn = getNextColumn();\n}\n","name":"move","className":"Path","variables":{"endingRow":1,"endingColumn":1},"javaDoc":"Moves the ending position of this path one unit in the current direction","comments":"\n      Moves the ending position of this path one unit in the\n      current direction.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","EnclosedExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"/**\n      Turns the ending direction of this path clockwise.\n   */\npublic void turn() {\n    final int DIRECTIONS = 4;\n    endingDirection = (endingDirection + 1) % DIRECTIONS;\n}\n","name":"turn","className":"Path","variables":{"endingDirection":2,"DIRECTIONS":2},"javaDoc":"Turns the ending direction of this path clockwise","comments":"\n      Turns the ending direction of this path clockwise.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the ending row of this path.\n      @return the ending row\n   */\npublic int getEndingRow() {\n    return endingRow;\n}\n","name":"getEndingRow","className":"Path","variables":{"endingRow":1},"javaDoc":"Gets the ending row of this path the ending row","comments":"\n      Gets the ending row of this path.\n      @return the ending row\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the ending column of this path.\n      @return the ending column\n   */\npublic int getEndingColumn() {\n    return endingColumn;\n}\n","name":"getEndingColumn","className":"Path","variables":{"endingColumn":1},"javaDoc":"Gets the ending column of this path the ending column","comments":"\n      Gets the ending column of this path.\n      @return the ending column\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ArrayAccessExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the next row of this path if it continues in the ending\n      direction.\n      @return the next row\n   */\npublic int getNextRow() {\n    return endingRow + ROW_OFFSETS[endingDirection];\n}\n","name":"getNextRow","className":"Path","variables":{"endingDirection":1,"ROW_OFFSETS":1,"endingRow":1},"javaDoc":"Gets the next row of this path if it continues in the ending direction the next row","comments":"\n      Gets the next row of this path if it continues in the ending\n      direction.\n      @return the next row\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ArrayAccessExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the next column of this path if it continues in the ending\n      direction.\n      @return the next row\n   */\npublic int getNextColumn() {\n    return endingColumn + COLUMN_OFFSETS[endingDirection];\n}\n","name":"getNextColumn","className":"Path","variables":{"endingDirection":1,"endingColumn":1,"COLUMN_OFFSETS":1},"javaDoc":"Gets the next column of this path if it continues in the ending direction the next row","comments":"\n      Gets the next column of this path if it continues in the ending\n      direction.\n      @return the next row\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","EnclosedExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether two directions are opposites of each other.\n      @param dir1 a direction between 0 and 3\n      @param dir2 a direction between 0 and 3\n      @return true if they are opposites (i.e. 0 and 2, 1 and 3,\n      2 and 0, or 3 and 1)\n   */\nprivate static boolean isOpposite(int dir1, int dir2) {\n    return dir1 != dir2 && (dir1 + dir2) % 2 == 0;\n}\n","name":"isOpposite","className":"Path","variables":{"dir2":3,"dir1":3},"javaDoc":"Checks whether two directions are opposites of each other dir1 a direction between 0 and 3 dir2 a direction between 0 and 3 true if they are opposites (i e 0 and 2 1 and 3 2 and 0 or 3 and 1)","comments":"\n      Checks whether two directions are opposites of each other.\n      @param dir1 a direction between 0 and 3\n      @param dir2 a direction between 0 and 3\n      @return true if they are opposites (i.e. 0 and 2, 1 and 3,\n      2 and 0, or 3 and 1)\n   ","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["Path"],"returnType":"boolean","methodCalls":{"isOpposite":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Checks whether this path is the opposite of another one.\n      @param other another path that ends where this path starts\n      @return true if other is the opposite of this path\n   */\npublic boolean isOpposite(Path other) {\n    return startingRow == other.endingRow && startingColumn == other.endingColumn && isOpposite(startingDirection, other.endingDirection);\n}\n","name":"isOpposite","className":"Path","variables":{"startingColumn":1,"other":1,"startingRow":1},"javaDoc":"Checks whether this path is the opposite of another one other another path that ends where this path starts true if other is the opposite of this path","comments":"\n      Checks whether this path is the opposite of another one.\n      @param other another path that ends where this path starts\n      @return true if other is the opposite of this path\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"<->(\"":1,"\"NESW\"":2,"\",\"":2,"\")\"":2,"\"(\"":1},"annotations":[],"types":{"String":1},"expressions":["VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    String result = \"(\" + startingRow + \",\" + startingColumn + \")\" + \"NESW\".charAt(startingDirection);\n    if (endingRow != startingRow || endingColumn != startingColumn) {\n        result = result + \"<->(\" + endingRow + \",\" + endingColumn + \")\" + \"NESW\".charAt(endingDirection);\n    }\n    return result;\n}\n","name":"toString","className":"Path","variables":{"result":4,"startingColumn":2,"endingRow":2,"endingColumn":2,"startingRow":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":3,"add":2,"addLast":4,"listIterator":1,"remove":1,"System.out.println":2},"constants":{"\"Nina\"":1,"\"Tom\"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Romeo\"":1,"\"Expected: [Diana, Harry, Juliet, Nina, Tom]\"":1},"annotations":[],"types":{"LinkedList<String>":1,"ListIterator<String>":1,"LinkedList":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    LinkedList<String> staff = new LinkedList<>();\n    staff.addLast(\"Diana\");\n    staff.addLast(\"Harry\");\n    staff.addLast(\"Romeo\");\n    staff.addLast(\"Tom\");\n    // | in the comments indicates the iterator position\n    // |DHRT\n    ListIterator<String> iterator = staff.listIterator();\n    // D|HRT\n    iterator.next();\n    // DH|RT\n    iterator.next();\n    // Add more elements after second element\n    // DHJ|RT\n    iterator.add(\"Juliet\");\n    // DHJN|RT\n    iterator.add(\"Nina\");\n    // DHJNR|T\n    iterator.next();\n    // Remove last traversed element \n    // DHJN|T\n    iterator.remove();\n    // Print all elements\n    System.out.println(staff);\n    System.out.println(\"Expected: [Diana, Harry, Juliet, Nina, Tom]\");\n}\n","name":"main","className":"ListDemo","variables":{"args":1,"iterator":7,"staff":6},"javaDoc":"","comments":"| in the comments indicates the iterator position Add more elements after second element Remove last traversed element Print all elements |DHRT D|HRT DH|RT DHJ|RT DHJN|RT DHJNR|T DHJN|T ","isEmpty":false,"lineCount":18,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":8,"size":1,"remove":1,"System.out.println":1},"constants":{"\"Remove pencil sharpener shavings\"":1,"\"Replace light bulb\"":1,"\"Order cleaning supplies\"":1,"\"Shampoo carpets\"":1,"\"Empty trash\"":1,"\"Fix broken sink\"":1,"\"Water plants\"":1,"\"Clean coffee maker\"":1,"10":1},"annotations":[],"types":{"PriorityQueue":1,"PriorityQueue<WorkOrder>":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    PriorityQueue<WorkOrder> q = new PriorityQueue<>();\n    q.add(new WorkOrder(3, \"Shampoo carpets\"));\n    q.add(new WorkOrder(7, \"Empty trash\"));\n    q.add(new WorkOrder(8, \"Water plants\"));\n    q.add(new WorkOrder(10, \"Remove pencil sharpener shavings\"));\n    q.add(new WorkOrder(6, \"Replace light bulb\"));\n    q.add(new WorkOrder(1, \"Fix broken sink\"));\n    q.add(new WorkOrder(9, \"Clean coffee maker\"));\n    q.add(new WorkOrder(2, \"Order cleaning supplies\"));\n    while (q.size() > 0) {\n        System.out.println(q.remove());\n    }\n}\n","name":"main","className":"PriorityQueueDemo","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["int","String"],"returnType":"WorkOrder","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   */\npublic WorkOrder(int aPriority, String aDescription) {\n    priority = aPriority;\n    description = aDescription;\n}\n","name":"WorkOrder","className":"WorkOrder","variables":{"aPriority":2,"aDescription":2,"description":1,"priority":1},"javaDoc":"Constructs a work order with a given priority and description aPriority the priority of this work order aDescription the description of this work order","comments":"\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\", description=\"":1,"\"priority=\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"priority=\" + priority + \", description=\" + description;\n}\n","name":"toString","className":"WorkOrder","variables":{"description":1,"priority":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"WorkOrder":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","CastExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public int compareTo(Object otherObject) {\n    WorkOrder other = (WorkOrder) otherObject;\n    if (priority < other.priority) {\n        return -1;\n    } else if (priority > other.priority) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","name":"compareTo","className":"WorkOrder","variables":{"other":1,"priority":2,"otherObject":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"push":7,"System.out.println":1},"constants":{"\"Insert 'World'\"":1,"\"Insert 'Hello'\"":1,"\"Undo \"":1,"\"Insert '!'\"":1,"\"Insert ' '\"":1,"\"Insert '?'\"":1,"\"Insert ','\"":1,"\"Delete '?'\"":1},"annotations":[],"types":{"Stack<String>":1,"String":1,"int":1,"Stack":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Stack<String> commands = new Stack<>();\n    commands.push(\"Insert 'Hello'\");\n    commands.push(\"Insert ','\");\n    commands.push(\"Insert ' '\");\n    commands.push(\"Insert 'World'\");\n    commands.push(\"Insert '?'\");\n    commands.push(\"Delete '?'\");\n    commands.push(\"Insert '!'\");\n    // Now we undo the last four commands\n    for (int i = 1; i <= 4; i++) {\n        String command = commands.pop();\n        System.out.println(\"Undo \" + command);\n    }\n}\n","name":"main","className":"StackDemo","variables":{"args":1,"commands":9,"command":2},"javaDoc":"","comments":"Now we undo the last four commands ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":6,"size":1,"remove":3,"System.out.println":3},"constants":{"\"Joe: Expense Report #1\"":1,"\"Joe: Expense Report #2\"":1,"\"Cathy: Purchase Order #2\"":1,"\"Cathy: Purchase Order #1\"":1,"\"Printing \"":3,"\"Cathy: Meeting Memo\"":1,"\"Joe: Weekly Report\"":1},"annotations":[],"types":{"Queue<String>":1,"LinkedList":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Queue<String> jobs = new LinkedList<>();\n    jobs.add(\"Joe: Expense Report #1\");\n    jobs.add(\"Cathy: Meeting Memo\");\n    System.out.println(\"Printing \" + jobs.remove());\n    jobs.add(\"Cathy: Purchase Order #1\");\n    jobs.add(\"Joe: Expense Report #2\");\n    jobs.add(\"Joe: Weekly Report\");\n    System.out.println(\"Printing \" + jobs.remove());\n    jobs.add(\"Cathy: Purchase Order #2\");\n    while (jobs.size() > 0) {\n        System.out.println(\"Printing \" + jobs.remove());\n    }\n}\n","name":"main","className":"QueueDemo","variables":{"args":1,"jobs":11},"javaDoc":"","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"add":6,"size":3,"push":3,"remove":2,"System.out.println":6},"constants":{"\"Stack: \"":1,"\"Tom\"":3,"\"Queue: \"":1,"\"Diana\"":3,"\"Harry\"":3,"\"Priority Queue: \"":1},"annotations":[],"types":{"Stack<String>":1,"Queue<String>":1,"PriorityQueue":1,"LinkedList":1,"Stack":1,"PriorityQueue<String>":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    System.out.println(\"Stack: \");\n    Stack<String> s = new Stack<>();\n    s.push(\"Tom\");\n    s.push(\"Diana\");\n    s.push(\"Harry\");\n    while (s.size() > 0) {\n        System.out.println(s.pop());\n    }\n    System.out.println(\"Queue: \");\n    Queue<String> q = new LinkedList<>();\n    q.add(\"Tom\");\n    q.add(\"Diana\");\n    q.add(\"Harry\");\n    while (q.size() > 0) {\n        System.out.println(q.remove());\n    }\n    System.out.println(\"Priority Queue: \");\n    PriorityQueue<String> pq = new PriorityQueue<>();\n    pq.add(\"Tom\");\n    pq.add(\"Diana\");\n    pq.add(\"Harry\");\n    while (pq.size() > 0) {\n        System.out.println(pq.remove());\n    }\n}\n","name":"main","className":"StackQueueDemo","variables":{"args":1,"pq":6},"javaDoc":"","isEmpty":false,"lineCount":18,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"replace":1,"length":2,"error":5,"push":5,"precedence":2,"evaluateTop":3,"substring":1,"isOperator":1,"pop":4,"parseInt":1,"size":5,"isDigit":2,"System.out.print":1,"charAt":2,"System.out.println":1},"constants":{"\"\"":1,"\"Enter an expression: \"":1,"\" \"":1,"')'":1,"'('":3,"\"No matching )\"":1,"false":1,"\"No matching (\"":1,"true":1,"\"Number, operator, or parenthesis expected.\"":1,"\"Syntax error\"":2},"annotations":[],"types":{"Scanner":1,"boolean":1,"char":4,"Stack<Character>":1,"String":2,"Stack<Integer>":1,"int":2,"Stack":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","CharLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter an expression: \");\n    String expression = in.nextLine().replace(\" \", \"\");\n    Stack<Integer> numstack = new Stack<>();\n    Stack<Character> opstack = new Stack<>();\n    int pos = 0;\n    while (pos < expression.length()) {\n        char ch = expression.charAt(pos);\n        pos++;\n        if (isOperator(ch)) {\n            if (opstack.size() == 0) {\n                opstack.push(ch);\n            } else {\n                char oldOp = opstack.pop();\n                if (precedence(ch) > precedence(oldOp)) {\n                    opstack.push(oldOp);\n                } else {\n                    evaluateTop(numstack, oldOp);\n                }\n                opstack.push(ch);\n            }\n        } else if (ch == '(') {\n            opstack.push(ch);\n        } else if (ch == ')') {\n            boolean done = false;\n            while (!done) {\n                if (opstack.size() == 0) {\n                    error(\"No matching (\");\n                }\n                char oldOp = opstack.pop();\n                if (oldOp == '(') {\n                    done = true;\n                } else {\n                    evaluateTop(numstack, oldOp);\n                }\n            }\n        } else if (Character.isDigit(ch)) {\n            int start = pos - 1;\n            while (pos < expression.length() && Character.isDigit(expression.charAt(pos))) {\n                pos++;\n            }\n            String num = expression.substring(start, pos);\n            numstack.push(Integer.parseInt(num));\n        } else {\n            error(\"Number, operator, or parenthesis expected.\");\n        }\n    }\n    while (opstack.size() > 0) {\n        char oldOp = opstack.pop();\n        if (oldOp == '(') {\n            error(\"No matching )\");\n        } else {\n            evaluateTop(numstack, oldOp);\n        }\n    }\n    if (numstack.size() == 0) {\n        error(\"Syntax error\");\n    }\n    System.out.println(numstack.pop());\n    if (numstack.size() > 0) {\n        error(\"Syntax error\");\n    }\n}\n","name":"main","className":"ExpressionCalculator","variables":{"expression":6,"Character":2,"in":2,"ch":3,"oldOp":5,"numstack":5,"num":1,"start":1,"done":3,"args":1,"Integer":1,"pos":6,"opstack":11},"javaDoc":"","isEmpty":false,"lineCount":11,"modifier":9}
{"paramTypes":["char"],"returnType":"boolean","methodCalls":{},"constants":{"'-'":1,"'+'":1,"'*'":1,"'/'":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","CharLiteralExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tests if a token is an operator.\n      @param s the token\n      @return true if s is one of: + - * / ^\n   */\npublic static boolean isOperator(char ch) {\n    return ch == '+' || ch == '-' || ch == '*' || ch == '/';\n}\n","name":"isOperator","className":"ExpressionCalculator","variables":{"ch":5},"javaDoc":"Tests if a token is an operator s the token true if s is one of: + - / ^","comments":"\n      Tests if a token is an operator.\n      @param s the token\n      @return true if s is one of: + - * / ^\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"exit":1,"System.out.println":1},"constants":{"\"ERROR: \"":1,"\".\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Prints an error message and exits.\n      @param message information about the error\n   */\npublic static void error(String message) {\n    System.out.println(\"ERROR: \" + message + \".\");\n    System.exit(1);\n}\n","name":"error","className":"ExpressionCalculator","variables":{"message":2,"System":1},"javaDoc":"Prints an error message and exits message information about the error","comments":"\n      Prints an error message and exits.\n      @param message information about the error\n   ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["char"],"returnType":"int","methodCalls":{},"constants":{"'-'":1,"'+'":1,"'*'":1,"'/'":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","CharLiteralExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the precedence level of an operator.\n      @param s the operator\n      @return the precedence level (1 = lowest, 3 = highest)\n   */\npublic static int precedence(char ch) {\n    if (ch == '+' || ch == '-') {\n        return 1;\n    } else if (ch == '*' || ch == '/') {\n        return 2;\n    } else {\n        return 0;\n    }\n}\n","name":"precedence","className":"ExpressionCalculator","variables":{"ch":5},"javaDoc":"Computes the precedence level of an operator s the operator the precedence level (1 = lowest 3 = highest)","comments":"\n      Computes the precedence level of an operator.\n      @param s the operator\n      @return the precedence level (1 = lowest, 3 = highest)\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["Stack<Integer>","char"],"returnType":"void","methodCalls":{"pop":2,"size":2,"error":4,"push":1},"constants":{"'-'":1,"'+'":1,"'*'":1,"\"Divide by 0\"":1,"\"Syntax error\"":3,"'/'":1},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","CharLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Computes a new value and pushes it on the stack.\n      @param num the stack for the operands and result\n      @param op the operation to use\n   */\npublic static void evaluateTop(Stack<Integer> num, char op) {\n    if (num.size() == 0) {\n        error(\"Syntax error\");\n    }\n    int y = num.pop();\n    if (num.size() == 0) {\n        error(\"Syntax error\");\n    }\n    int x = num.pop();\n    int z = 0;\n    if (op == '*') {\n        z = x * y;\n    } else if (op == '/') {\n        if (y == 0) {\n            error(\"Divide by 0\");\n        } else {\n            z = x / y;\n        }\n    } else if (op == '+') {\n        z = x + y;\n    } else if (op == '-') {\n        z = x - y;\n    } else {\n        error(\"Syntax error\");\n    }\n    num.push(z);\n}\n","name":"evaluateTop","className":"ExpressionCalculator","variables":{"op":5,"num":6},"javaDoc":"Computes a new value and pushes it on the stack num the stack for the operands and result op the operation to use","comments":" \n      Computes a new value and pushes it on the stack.\n      @param num the stack for the operands and result\n      @param op the operation to use\n   ","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":2,"name":1,"anArea":2},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"hash":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int hashCode() {\n    return Objects.hash(name, area);\n}\n","name":"hashCode","className":"Country","variables":{"Objects":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"equals":1},"constants":{},"annotations":[],"types":{"Country":1},"expressions":["VariableDeclarationExpr","BinaryExpr","CastExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public boolean equals(Object otherObject) {\n    Country other = (Country) otherObject;\n    return name.equals(other.name) && area == other.area;\n}\n","name":"equals","className":"Country","variables":{"area":1,"other":1,"name":1,"otherObject":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"constants":{"\"[name=\"":1,"\"]\"":1,"\",area=\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \",area=\" + area + \"]\";\n}\n","name":"toString","className":"Country","variables":{"area":1,"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"hashCode":3,"System.out.println":4},"constants":{"\"hash code of country2=\"":1,"\"Thailand\"":1,"\"hash code of country1=\"":1,"30510":2,"\"Belgium\"":2,"514000":1,"\"hash code of country3=\"":1},"annotations":[],"types":{"Set<Country>":1,"Country":3,"HashSet":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Country country1 = new Country(\"Belgium\", 30510);\n    Country country2 = new Country(\"Thailand\", 514000);\n    Country country3 = new Country(\"Belgium\", 30510);\n    System.out.println(\"hash code of country1=\" + country1.hashCode());\n    System.out.println(\"hash code of country2=\" + country2.hashCode());\n    System.out.println(\"hash code of country3=\" + country3.hashCode());\n    // Add the countries to the hash set. \n    Set<Country> countries = new HashSet<>();\n    countries.add(country1);\n    countries.add(country2);\n    countries.add(country3);\n    // Print the set. Note that the set has two elements.\n    System.out.println(countries);\n}\n","name":"main","className":"HashCodePrinter","variables":{"args":1,"country1":2,"countries":4,"country3":2,"country2":2},"javaDoc":"","comments":"Add the countries to the hash set Print the set Note that the set has two elements ","isEmpty":false,"lineCount":13,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"size":2,"nextLine":1,"length":1,"System.out.print":3,"charAt":1,"push":1,"System.out.println":2},"constants":{"']'":2,"'}'":2,"\"Not balanced.\"":3,"\"Balanced.\"":1,"'['":2,"'{'":2,"')'":2,"'('":2,"\"Enter an expression with { [ ( ) ] }: \"":1},"annotations":[],"types":{"Scanner":1,"char":2,"Stack<Character>":1,"String":1,"int":1,"Stack":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","CharLiteralExpr","EnclosedExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter an expression with { [ ( ) ] }: \");\n    String expression = in.nextLine();\n    Stack<Character> parens = new Stack<>();\n    for (int i = 0; i < expression.length(); i++) {\n        char ch = expression.charAt(i);\n        if (ch == '(' || ch == '[' || ch == '{') {\n            parens.push(ch);\n        } else if (ch == ')' || ch == ']' || ch == '}') {\n            if (parens.size() == 0) {\n                System.out.println(\"Not balanced.\");\n                return;\n            }\n            char open = parens.pop();\n            if (!(open == '(' && ch == ')' || open == '[' && ch == ']' || open == '{' && ch == '}')) {\n                System.out.println(\"Not balanced.\");\n                return;\n            }\n        }\n    }\n    if (parens.size() == 0) {\n        System.out.print(\"Balanced.\");\n    } else {\n        System.out.print(\"Not balanced.\");\n    }\n}\n","name":"main","className":"ParenChecker","variables":{"args":1,"parens":5,"expression":3,"in":2,"ch":10,"open":4},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"contains":1,"readWords":2,"System.out.println":1},"constants":{"\"alice30.txt\"":1,"\"words\"":1},"annotations":[],"types":{"Set<String>":2,"String":1},"expressions":["VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":["FileNotFoundException"],"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Read the dictionary and the document\n    Set<String> dictionaryWords = readWords(\"words\");\n    Set<String> documentWords = readWords(\"alice30.txt\");\n    for (String word : documentWords) {\n        if (!dictionaryWords.contains(word)) {\n            System.out.println(word);\n        }\n    }\n}\n","name":"main","className":"SpellCheck","variables":{"args":1,"documentWords":2,"dictionaryWords":2,"word":1},"javaDoc":"","comments":"Read the dictionary and the document Print all words that are in the document but not the dictionary ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"Set<String>","methodCalls":{"add":1,"next":1,"toLowerCase":1,"useDelimiter":1,"hasNext":1},"constants":{"\"[^a-zA-Z]+\"":1},"annotations":[],"types":{"Scanner":1,"Set<String>":1,"HashSet":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["FileNotFoundException"],"text":"/**\n      Reads all words from a file.\n      @param filename the name of the file\n      @return a set with all lowercased words in the file. Here, a \n      word is a sequence of upper- and lowercase letters.\n   */\npublic static Set<String> readWords(String filename) throws FileNotFoundException {\n    Set<String> words = new HashSet<>();\n    Scanner in = new Scanner(new File(filename));\n    // Use any characters other than a-z or A-Z as delimiters\n    in.useDelimiter(\"[^a-zA-Z]+\");\n    while (in.hasNext()) {\n        words.add(in.next().toLowerCase());\n    }\n    return words;\n}\n","name":"readWords","className":"SpellCheck","variables":{"filename":2,"in":4,"words":3},"javaDoc":"Reads all words from a file filename the name of the file a set with all lowercased words in the file Here a word is a sequence of upper- and lowercase letters","comments":"Use any characters other than a-z or A-Z as delimiters \n      Reads all words from a file.\n      @param filename the name of the file\n      @return a set with all lowercased words in the file. Here, a \n      word is a sequence of upper- and lowercase letters.\n   ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"System.out.printf":1,"get":2,"hasNext":1,"clean":1,"keySet":1,"put":1},"constants":{"\"alice30.txt\"":1,"null":1,"\"%-20s%10d\\n\"":1},"annotations":[],"types":{"Integer":1,"Scanner":1,"Map<String, Integer>":1,"String":2,"TreeMap":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["FileNotFoundException"],"text":"public static void main(String[] args) throws FileNotFoundException {\n    Map<String, Integer> frequencies = new TreeMap<>();\n    Scanner in = new Scanner(new File(\"alice30.txt\"));\n    while (in.hasNext()) {\n        String word = clean(in.next());\n        // Get the old frequency count\n        Integer count = frequencies.get(word);\n        if (count == null) {\n            count = 1;\n        } else {\n            count = count + 1;\n        }\n        frequencies.put(word, count);\n    }\n    for (String key : frequencies.keySet()) {\n        System.out.printf(\"%-20s%10d\\n\", key, frequencies.get(key));\n    }\n}\n","name":"main","className":"WordFrequency","variables":{"args":1,"in":3,"count":5,"frequencies":5,"word":1,"key":1},"javaDoc":"","comments":"Print all words and counts Get the old frequency count If there was none put 1; otherwise increment the count ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"toLowerCase":1,"length":1,"charAt":1,"isLetter":1},"constants":{"\"\"":1},"annotations":[],"types":{"char":1,"String":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes characters from a string that are not letters.\n      @param s a string\n      @return a string with all the letters from s\n   */\npublic static String clean(String s) {\n    String r = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        if (Character.isLetter(c)) {\n            r = r + c;\n        }\n    }\n    return r.toLowerCase();\n}\n","name":"clean","className":"WordFrequency","variables":{"Character":1},"javaDoc":"Removes characters from a string that are not letters s a string a string with all the letters from s","comments":"\n      Removes characters from a string that are not letters.\n      @param s a string\n      @return a string with all the letters from s\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["double"],"returnType":"Event","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Event(double eventTime) {\n    time = eventTime;\n}\n","name":"Event","className":"Event","variables":{"eventTime":2,"time":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Simulation"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void process(Simulation sim) {\n}\n","name":"process","className":"Event","variables":{"sim":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getTime() {\n    return time;\n}\n","name":"getTime","className":"Event","variables":{"time":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Event"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int compareTo(Event other) {\n    if (time < other.time) {\n        return -1;\n    } else if (time > other.time) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","name":"compareTo","className":"Event","variables":{"other":1,"time":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"Customer","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n       Constructs a customer.\n       @param the time at which the customer entered the bank\n   */\npublic Customer(double time) {\n    arrivalTime = time;\n}\n","name":"Customer","className":"Customer","variables":{"arrivalTime":1,"time":2},"javaDoc":"Constructs a customer the time at which the customer entered the bank","comments":" \n       Constructs a customer.\n       @param the time at which the customer entered the bank\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the time at which the customer entered the bank.\n      @return the arrival time\n   */\ndouble getArrivalTime() {\n    return arrivalTime;\n}\n","name":"getArrivalTime","className":"Customer","variables":{"arrivalTime":1},"javaDoc":"Gets the time at which the customer entered the bank the arrival time","comments":"\n      Gets the time at which the customer entered the bank.\n      @return the arrival time\n   ","isEmpty":false,"lineCount":1,"modifier":0}
{"paramTypes":["double"],"returnType":"Arrival","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"/**\n      @param time the arrival time\n   */\npublic Arrival(double time) {\n    super(time);\n}\n","name":"Arrival","className":"Arrival","variables":{"time":2},"javaDoc":"time the arrival time","comments":"\n      @param time the arrival time\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Simulation"],"returnType":"void","methodCalls":{"add":1,"getCurrentTime":1},"constants":{},"annotations":[],"types":{"BankSimulation":1,"Customer":1,"double":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","CastExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void process(Simulation sim) {\n    double now = sim.getCurrentTime();\n    BankSimulation bank = (BankSimulation) sim;\n    Customer c = new Customer(now);\n    bank.add(c);\n}\n","name":"process","className":"Arrival","variables":{"bank":2,"sim":3,"now":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"BankSimulation","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public BankSimulation(int numberOfTellers) {\n    tellers = new Customer[numberOfTellers];\n    custQueue = new LinkedList<>();\n    totalCustomers = 0;\n    totalTime = 0;\n}\n","name":"BankSimulation","className":"BankSimulation","variables":{"totalCustomers":1,"tellers":1,"custQueue":1,"totalTime":1,"numberOfTellers":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Customer"],"returnType":"void","methodCalls":{"add":1,"addEvent":1,"expdist":1,"addToTeller":1,"getCurrentTime":1},"constants":{"null":1,"false":1,"true":1},"annotations":[],"types":{"boolean":1,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n       Adds a customer to the bank.\n       @param c the customer\n   */\npublic void add(Customer c) {\n    boolean addedToTeller = false;\n    for (int i = 0; !addedToTeller && i < tellers.length; i++) {\n        if (tellers[i] == null) {\n            addToTeller(i, c);\n            addedToTeller = true;\n        }\n    }\n    if (!addedToTeller) {\n        custQueue.add(c);\n    }\n    addEvent(new Arrival(getCurrentTime() + expdist(INTERARRIVAL)));\n}\n","name":"add","className":"BankSimulation","variables":{"tellers":1,"custQueue":1,"addedToTeller":4},"javaDoc":"Adds a customer to the bank c the customer","comments":" \n       Adds a customer to the bank.\n       @param c the customer\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","Customer"],"returnType":"void","methodCalls":{"addEvent":1,"expdist":1,"getCurrentTime":1},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a customer to a teller and schedules the departure event.\n      @param i the teller number\n      @param c the customer\n   */\nprivate void addToTeller(int i, Customer c) {\n    tellers[i] = c;\n    addEvent(new Departure(getCurrentTime() + expdist(PROCESSING), i));\n}\n","name":"addToTeller","className":"BankSimulation","variables":{"tellers":1},"javaDoc":"Adds a customer to a teller and schedules the departure event i the teller number c the customer","comments":"\n      Adds a customer to a teller and schedules the departure event.\n      @param i the teller number\n      @param c the customer\n   ","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"size":1,"getArrivalTime":1,"addToTeller":1,"getCurrentTime":1,"remove":1},"constants":{"null":1},"annotations":[],"types":{"Customer":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n       Removes a customer from a teller.\n       @param i teller position\n   */\npublic void remove(int i) {\n    Customer c = tellers[i];\n    tellers[i] = null;\n    // Update statistics\n    totalCustomers++;\n    totalTime = totalTime + getCurrentTime() - c.getArrivalTime();\n    if (custQueue.size() > 0) {\n        addToTeller(i, custQueue.remove());\n    }\n}\n","name":"remove","className":"BankSimulation","variables":{"totalCustomers":1,"tellers":2,"custQueue":2,"totalTime":2},"javaDoc":"Removes a customer from a teller i teller position","comments":"Update statistics  \n       Removes a customer from a teller.\n       @param i teller position\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"System.out.print":4,"System.out.println":1},"constants":{"\"C\"":2,"null":1,"\".\"":1,"\"<\"":1},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Displays tellers and queue.\n   */\npublic void display() {\n    for (int i = 0; i < tellers.length; i++) {\n        if (tellers[i] == null) {\n            System.out.print(\".\");\n        } else {\n            System.out.print(\"C\");\n        }\n    }\n    System.out.print(\"<\");\n    int q = custQueue.size();\n    for (int j = 1; j <= q; j++) {\n        System.out.print(\"C\");\n    }\n    System.out.println();\n}\n","name":"display","className":"BankSimulation","variables":{"tellers":1,"custQueue":1},"javaDoc":"Displays tellers and queue","comments":"\n      Displays tellers and queue.\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\" customers. Average time \"":1,"\" minutes.\"":1},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n       Displays a summary of the gathered statistics.\n   */\npublic void displaySummary() {\n    double averageTime = 0;\n    if (totalCustomers > 0) {\n        averageTime = totalTime / totalCustomers;\n    }\n    System.out.println(totalCustomers + \" customers. Average time \" + averageTime + \" minutes.\");\n}\n","name":"displaySummary","className":"BankSimulation","variables":{"totalCustomers":3,"averageTime":3,"totalTime":1},"javaDoc":"Displays a summary of the gathered statistics","comments":" \n       Displays a summary of the gathered statistics.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["double","int"],"returnType":"Departure","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExplicitConstructorInvocationStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      @param time the departure time\n      @param teller the teller holding the customer\n   */\npublic Departure(double time, int teller) {\n    super(time);\n    this.teller = teller;\n}\n","name":"Departure","className":"Departure","variables":{"teller":2,"time":2},"javaDoc":"time the departure time teller the teller holding the customer","comments":"\n      @param time the departure time\n      @param teller the teller holding the customer\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Simulation"],"returnType":"void","methodCalls":{"remove":1},"constants":{},"annotations":[],"types":{"BankSimulation":1},"expressions":["VariableDeclarationExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void process(Simulation sim) {\n    BankSimulation bank = (BankSimulation) sim;\n    bank.remove(teller);\n}\n","name":"process","className":"Departure","variables":{"bank":2,"sim":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addEvent":1,"run":1},"constants":{"17":1,"60":2},"annotations":[],"types":{"BankSimulation":1,"Simulation":1,"double":2,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables","PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    // 9 a.m.\n    final double START_TIME = 9 * 60;\n    // 5 p.m.\n    final double END_TIME = 17 * 60;\n    final int NTELLERS = 5;\n    Simulation sim = new BankSimulation(NTELLERS);\n    sim.addEvent(new Arrival(START_TIME));\n    sim.run(START_TIME, END_TIME);\n}\n","name":"main","className":"BankSimulationRunner","variables":{"args":1,"START_TIME":2,"END_TIME":1,"sim":3,"NTELLERS":2},"javaDoc":"","comments":"9 a m 5 p m ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"Simulation","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a discrete event simulation.\n   */\npublic Simulation() {\n    eventQueue = new PriorityQueue<>();\n}\n","name":"Simulation","className":"Simulation","variables":{"eventQueue":1},"javaDoc":"Constructs a discrete event simulation","comments":"\n      Constructs a discrete event simulation.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getCurrentTime() {\n    return currentTime;\n}\n","name":"getCurrentTime","className":"Simulation","variables":{"currentTime":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"double","methodCalls":{"random":1,"log":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Compute exponentially distributed random numbers.\n      @param mean the mean of the number sequence\n      @return a random number\n   */\npublic static double expdist(double mean) {\n    return -mean * Math.log(1 - Math.random());\n}\n","name":"expdist","className":"Simulation","variables":{"mean":2,"Math":2},"javaDoc":"Compute exponentially distributed random numbers mean the mean of the number sequence a random number","comments":"\n      Compute exponentially distributed random numbers.\n      @param mean the mean of the number sequence\n      @return a random number\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["Event"],"returnType":"void","methodCalls":{"add":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an event to the event queue.\n      @param evt the event to add\n   */\npublic void addEvent(Event evt) {\n    eventQueue.add(evt);\n}\n","name":"addEvent","className":"Simulation","variables":{"eventQueue":1,"evt":1},"javaDoc":"Adds an event to the event queue evt the event to add","comments":"\n      Adds an event to the event queue.\n      @param evt the event to add\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Displays intermediate results after each event.\n   */\npublic void display() {\n}\n","name":"display","className":"Simulation","variables":{},"javaDoc":"Displays intermediate results after each event","comments":"\n      Displays intermediate results after each event.\n   ","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Displays summary results after the end of the simulation.\n   */\npublic void displaySummary() {\n}\n","name":"displaySummary","className":"Simulation","variables":{},"javaDoc":"Displays summary results after the end of the simulation","comments":"\n      Displays summary results after the end of the simulation.\n   ","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{"process":1,"size":1,"getTime":1,"display":1,"displaySummary":1,"remove":1},"constants":{},"annotations":[],"types":{"Event":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void run(double startTime, double endTime) {\n    currentTime = startTime;\n    while (eventQueue.size() > 0 && currentTime <= endTime) {\n        Event event = eventQueue.remove();\n        currentTime = event.getTime();\n        event.process(this);\n        display();\n    }\n    displaySummary();\n}\n","name":"run","className":"Simulation","variables":{"currentTime":3,"eventQueue":2,"startTime":2,"endTime":2,"event":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"workWith":2,"System.out.println":2},"constants":{"\"Working with a TreeSet\"":1,"\"Working with an ArrayList\"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    System.out.println(\"Working with an ArrayList\");\n    workWith(new ArrayList<>());\n    System.out.println(\"Working with a TreeSet\");\n    workWith(new TreeSet<>());\n}\n","name":"main","className":"CollectionsDemo","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["Collection<String>"],"returnType":"void","methodCalls":{"add":5,"contains":2,"System.out.print":4,"remove":2,"System.out.println":4},"constants":{"\"Fred\"":1,"\" \"":2,"\"Tom\"":1,"\"Wilma\"":1,"\"Removing Harry and Tom: \"":1,"\"Sally\"":2,"\"Harry\"":4,"\"Looking for Harry and Sally: \"":1},"annotations":[],"types":{"String":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Shows how to work with a collection of strings.\n      @param coll a collection from the Java collections framework\n   */\npublic static void workWith(Collection<String> coll) {\n    coll.add(\"Harry\");\n    coll.add(\"Sally\");\n    coll.add(\"Fred\");\n    coll.add(\"Wilma\");\n    coll.add(\"Harry\");\n    System.out.println(coll);\n    System.out.print(\"Removing Harry and Tom: \");\n    System.out.print(coll.remove(\"Harry\") + \" \");\n    System.out.println(coll.remove(\"Tom\"));\n    System.out.print(\"Looking for Harry and Sally: \");\n    System.out.print(coll.contains(\"Harry\") + \" \");\n    System.out.println(coll.contains(\"Sally\"));\n    for (String s : coll) {\n        System.out.println(s);\n    }\n}\n","name":"workWith","className":"CollectionsDemo","variables":{"coll":11},"javaDoc":"Shows how to work with a collection of strings coll a collection from the Java collections framework","comments":"\n      Shows how to work with a collection of strings.\n      @param coll a collection from the Java collections framework\n   ","isEmpty":false,"lineCount":13,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"get":1,"keySet":1,"put":4,"System.out.println":1},"constants":{"\"Eve\"":1,"\" : \"":1,"\"Juliet\"":1,"\"Adam\"":1,"\"Romeo\"":1},"annotations":[],"types":{"Map<String, Color>":1,"Set<String>":1,"HashMap":1,"Color":1,"String":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Map<String, Color> favoriteColors = new HashMap<>();\n    favoriteColors.put(\"Juliet\", Color.BLUE);\n    favoriteColors.put(\"Romeo\", Color.GREEN);\n    favoriteColors.put(\"Adam\", Color.RED);\n    favoriteColors.put(\"Eve\", Color.BLUE);\n    // Print all keys and values in the map\n    Set<String> keySet = favoriteColors.keySet();\n    for (String key : keySet) {\n        Color value = favoriteColors.get(key);\n        System.out.println(key + \" : \" + value);\n    }\n}\n","name":"main","className":"MapDemo","variables":{"args":1,"favoriteColors":7,"keySet":2,"value":2,"key":2},"javaDoc":"","comments":"Print all keys and values in the map ","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void placeHolderMethod0() {\n    for (int i = 0; i < 5; i++) {\n        int sum = 0;\n        sum = sum + i;\n        System.out.println(sum);\n    }\n}\n","name":"placeHolderMethod0","className":"PlaceHolder","variables":{"sum":3},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"4.5":1},"annotations":[],"types":{"Integer":1,"double":1,"Double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void placeHolderMethod1() {\n    Double d = 4.5;\n    Integer i = 2;\n    double sum = d + i;\n    System.out.println(sum);\n}\n","name":"placeHolderMethod1","className":"PlaceHolder","variables":{"sum":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"7\"":1},"annotations":[],"types":{"String":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","EnclosedExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void placeHolderMethod2() {\n    int anInt = 7;\n    String aStr = \"7\";\n    System.out.println((anInt + anInt) + aStr);\n}\n","name":"placeHolderMethod2","className":"PlaceHolder","variables":{"anInt":3,"aStr":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["double","double","double"],"returnType":"double","methodCalls":{"max":2},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double max(double x, double y, double z) {\n    return Math.max(Math.max(x, y), z);\n}\n","name":"max","className":"PlaceHolder","variables":{"Math":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"constants":{"10":2},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void placeHolderMethod3() {\n    for (int i = 0; i <= 10; i++) {\n        System.out.println(i);\n    }\n    int i = 0;\n    while (i <= 10) {\n        System.out.println(i);\n        i++;\n    }\n}\n","name":"placeHolderMethod3","className":"PlaceHolder","variables":{},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"constants":{"\"x = y\"":1,"\"x != y\"":1},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void placeHolderMethod4() {\n    int x = 1;\n    int y = 2;\n    if (x != y)\n        System.out.println(\"x != y\");\n    if (x == y)\n        System.out.println(\"x = y\");\n}\n","name":"placeHolderMethod4","className":"PlaceHolder","variables":{},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void printFactorial(int aNumber) {\n    int factorial = 1;\n    for (int i = 1; i <= aNumber; i++) {\n        factorial = factorial * i;\n    }\n    System.out.println(factorial);\n}\n","name":"printFactorial","className":"PlaceHolder","variables":{"aNumber":2,"factorial":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3,"System.out.println":1},"constants":{"15.5":1,"21.7":1,"23.5":1},"annotations":[],"types":{"double":1,"ArrayList<Double>":1,"Double":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void printArrayListSum() {\n    ArrayList<Double> aList = new ArrayList<Double>();\n    aList.add(15.5);\n    aList.add(21.7);\n    aList.add(23.5);\n    double sum = 0;\n    for (Double e : aList) {\n        sum = sum + e;\n    }\n    System.out.println(sum);\n}\n","name":"printArrayListSum","className":"PlaceHolder","variables":{"aList":5,"sum":3},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3,"remove":1,"System.out.println":1},"constants":{"1.1":1,"2.2":1,"3.3":1},"annotations":[],"types":{"ArrayList<Double>":1,"Double":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void iterateArrayList() {\n    ArrayList<Double> list = new ArrayList<Double>();\n    list.add(1.1);\n    list.add(2.2);\n    list.add(3.3);\n    list.remove(0);\n    for (Double d : list) System.out.println(d);\n}\n","name":"iterateArrayList","className":"PlaceHolder","variables":{"list":6},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"length":2,"System.out.println":1},"constants":{"2008":1,"100":1,"2015":1,"2000":1,"30":1,"\"Sun Devil!\"":1,"20":1,"10":1},"annotations":[],"types":{"String":1,"int":2},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void printTextLength() {\n    int myYear = 2015;\n    String myText = new String(\"Sun Devil!\");\n    int result = 0;\n    if (myText.length() > 20) {\n        result = 1;\n        if (myText.length() < 30 && myYear >= 2008)\n            result += 5;\n    } else {\n        if (myYear >= 2000)\n            result += 10;\n        else\n            result += 100;\n    }\n    System.out.println(result);\n}\n","name":"printTextLength","className":"PlaceHolder","variables":{"result":5,"myText":3,"myYear":3},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"pop":1,"push":3,"System.out.println":1},"constants":{"\"Z\"":1,"\"Y\"":1,"\"X\"":1},"annotations":[],"types":{"Stack":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void printLetterStack() {\n    Stack letterStack = new Stack();\n    letterStack.push(\"X\");\n    letterStack.push(\"Y\");\n    letterStack.push(\"Z\");\n    letterStack.pop();\n    System.out.println(letterStack);\n}\n","name":"printLetterStack","className":"PlaceHolder","variables":{"letterStack":5},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"14":1,"20":1},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int i = 14;\n    int j = 20;\n    int k;\n    k = j / i * 7 % 4;\n    System.out.println(k);\n}\n","name":"main","className":"PlaceHolder","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":[],"returnType":"Reservation","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Constructs a new Reservation\n\t */\npublic Reservation() {\n    passengerList = new ArrayList<Comparable>();\n    flightList = new ArrayList<Comparable>();\n}\n","name":"Reservation","className":"Reservation","variables":{"flightList":1,"passengerList":1},"javaDoc":"Constructs a new Reservation","comments":"\n\t * Constructs a new Reservation\n\t ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"int","methodCalls":{"size":1,"get":1,"equalsIgnoreCase":1,"getPassengerID":1},"constants":{},"annotations":[],"types":{"Passenger":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","CastExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"/**\n\t * Checks if a passenger has a reservation based on passenger ID\n\t * @param s, The ID of a passenger as a String\n\t * @return the index of the passenger, or -1 if not found\n\t */\npublic int passengerExists(String s) {\n    for (int p = 0; p < passengerList.size(); p++) {\n        Passenger a = (Passenger) passengerList.get(p);\n        if (a.getPassengerID().equalsIgnoreCase(s))\n            return p;\n    }\n    return -1;\n}\n","name":"passengerExists","className":"Reservation","variables":{"passengerList":2},"javaDoc":"Checks if a passenger has a reservation based on passenger ID s The ID of a passenger as a String the index of the passenger or -1 if not found","comments":"\n\t * Checks if a passenger has a reservation based on passenger ID\n\t * @param s, The ID of a passenger as a String\n\t * @return the index of the passenger, or -1 if not found\n\t ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"add":1,"parseStringToPassenger":1,"passengerExists":1,"getPassengerID":1},"constants":{"true":1,"false":1},"annotations":[],"types":{"Passenger":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Adds a passenger, if the passenger is not a duplicate\n\t * @param s, The ID of the passenger as a String\n\t * @return true if was removed, false if not\n\t */\npublic boolean addPassenger(String s) {\n    //creates passenger object\n    Passenger p = PassengerParser.parseStringToPassenger(s);\n    if (passengerExists(p.getPassengerID()) == -1) {\n        passengerList.add(p);\n        return true;\n    }\n    return false;\n}\n","name":"addPassenger","className":"Reservation","variables":{"PassengerParser":1,"passengerList":1},"javaDoc":"Adds a passenger if the passenger is not a duplicate s The ID of the passenger as a String true if was removed false if not","comments":"creates passenger object \n\t * Adds a passenger, if the passenger is not a duplicate\n\t * @param s, The ID of the passenger as a String\n\t * @return true if was removed, false if not\n\t ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equalsIgnoreCase":1,"getPassengerID":1,"remove":1},"constants":{"true":1,"false":1},"annotations":[],"types":{"Comparable":1,"Passenger":1},"expressions":["VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","CastExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"/**\n\t * Removes a passenger, if the passenger exists\n\t * @param s, The ID of the passenger to remove\n\t * @return true if was removed, false if not\n\t */\npublic boolean removePassenger(String s) {\n    for (Comparable c : passengerList) {\n        Passenger p = (Passenger) c;\n        if (p.getPassengerID().equalsIgnoreCase(s)) {\n            passengerList.remove(c);\n            return true;\n        }\n    }\n    return false;\n}\n","name":"removePassenger","className":"Reservation","variables":{"passengerList":2},"javaDoc":"Removes a passenger if the passenger exists s The ID of the passenger to remove true if was removed false if not","comments":"\n\t * Removes a passenger, if the passenger exists\n\t * @param s, The ID of the passenger to remove\n\t * @return true if was removed, false if not\n\t ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSortedList":1},"constants":{},"annotations":[],"types":{"Sorts":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Creates a new sorter, updates the passengerList with a sorted list\n\t */\npublic void sortPassengers() {\n    Sorts s = new Sorts(passengerList);\n    passengerList = s.getSortedList();\n}\n","name":"sortPassengers","className":"Reservation","variables":{"passengerList":2},"javaDoc":"Creates a new sorter updates the passengerList with a sorted list","comments":"\n\t * Creates a new sorter, updates the passengerList with a sorted list\n\t ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"size":1,"toString":1},"constants":{"\"\"":1,"\"no passenger\\n\"":1},"annotations":[],"types":{"Comparable":1,"String":1,"Passenger":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","CastExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"/**\n\t * Outputs the list of passengers to the console\n\t * @return the string of all passengers\n\t */\npublic String listPassengers() {\n    String result = \"\";\n    if (passengerList.size() == 0)\n        result = \"no passenger\\n\";\n    else {\n        for (Comparable c : passengerList) {\n            Passenger p = (Passenger) c;\n            result += p.toString();\n        }\n    }\n    return result;\n}\n","name":"listPassengers","className":"Reservation","variables":{"result":4,"passengerList":2},"javaDoc":"Outputs the list of passengers to the console the string of all passengers","comments":"\n\t * Outputs the list of passengers to the console\n\t * @return the string of all passengers\n\t ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String","String","String"],"returnType":"int","methodCalls":{"getFlightNum":1,"getDeparture":1,"size":1,"get":1,"equalsIgnoreCase":3,"getAirlines":1,"getCity":1},"constants":{},"annotations":[],"types":{"Flight":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","CastExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"/**\n\t * Checks if a flight exist or not\n\t * @param airlinesName, the company name as a String\n\t * @param flightNum, the flight number as a String\n\t * @param depCity, the departure City as a String\n\t * @return the index of the flight, or -1 if the flight does not exist\n\t */\npublic int flightExists(String airlinesName, String flightNum, String depCity) {\n    for (int p = 0; p < flightList.size(); p++) {\n        Flight f = (Flight) flightList.get(p);\n        if (f.getAirlines().equalsIgnoreCase(airlinesName) && f.getFlightNum().equalsIgnoreCase(flightNum) && f.getDeparture().getCity().equalsIgnoreCase(depCity))\n            return p;\n    }\n    return -1;\n}\n","name":"flightExists","className":"Reservation","variables":{"flightNum":1,"flightList":2,"depCity":1,"airlinesName":1},"javaDoc":"Checks if a flight exist or not airlinesName the company name as a String flightNum the flight number as a String depCity the departure City as a String the index of the flight or -1 if the flight does not exist","comments":"\n\t * Checks if a flight exist or not\n\t * @param airlinesName, the company name as a String\n\t * @param flightNum, the flight number as a String\n\t * @param depCity, the departure City as a String\n\t * @return the index of the flight, or -1 if the flight does not exist\n\t ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"add":1,"getFlightNum":1,"getDeparture":1,"parseStringToFlight":1,"getAirlines":1,"flightExists":1,"getCity":1},"constants":{"true":1,"false":1},"annotations":[],"types":{"Flight":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Add a flight, provided a duplicate does not exist\n\t * @param s, String with information to pass to parser\n\t * @return true if flight was added, false if not\n\t */\nboolean addFlight(String s) {\n    //creates flight object\n    Flight p = FlightParser.parseStringToFlight(s);\n    if (flightExists(p.getAirlines(), p.getFlightNum(), p.getDeparture().getCity()) == -1) {\n        flightList.add(p);\n        //sortFlights();\n        return true;\n    }\n    return false;\n}\n","name":"addFlight","className":"Reservation","variables":{"flightList":1,"FlightParser":1},"javaDoc":"Add a flight provided a duplicate does not exist s String with information to pass to parser true if flight was added false if not","comments":"creates flight object sortFlights(); \n\t * Add a flight, provided a duplicate does not exist\n\t * @param s, String with information to pass to parser\n\t * @return true if flight was added, false if not\n\t ","isEmpty":false,"lineCount":3,"modifier":0}
{"paramTypes":["String","String","String"],"returnType":"boolean","methodCalls":{"getFlightNum":1,"getDeparture":1,"equalsIgnoreCase":3,"getAirlines":1,"remove":1,"getCity":1},"constants":{"true":1,"false":1},"annotations":[],"types":{"Comparable":1,"Flight":1},"expressions":["VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","CastExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"/**\n\t * Removes a flight, provided the flight exists\n\t * @param airlinesName\n\t * @param flightNum\n\t * @param depCity\n\t * @return true if flight was remvoed, false if not\n\t */\nboolean removeFlight(String airlinesName, String flightNum, String depCity) {\n    for (Comparable c : flightList) {\n        Flight f = (Flight) c;\n        if (f.getAirlines().equalsIgnoreCase(airlinesName) && f.getFlightNum().equalsIgnoreCase(flightNum) && f.getDeparture().getCity().equalsIgnoreCase(depCity)) {\n            flightList.remove(c);\n            return true;\n        }\n    }\n    return false;\n}\n","name":"removeFlight","className":"Reservation","variables":{"flightNum":1,"flightList":2,"depCity":1,"airlinesName":1},"javaDoc":"Removes a flight provided the flight exists airlinesName flightNum depCity true if flight was remvoed false if not","comments":"\n\t * Removes a flight, provided the flight exists\n\t * @param airlinesName\n\t * @param flightNum\n\t * @param depCity\n\t * @return true if flight was remvoed, false if not\n\t ","isEmpty":false,"lineCount":2,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSortedList":1},"constants":{},"annotations":[],"types":{"Sorts":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Creates a new sort object, and updates flightList with the sorted list\n\t */\npublic void sortFlights() {\n    Sorts s = new Sorts(flightList);\n    flightList = s.getSortedList();\n}\n","name":"sortFlights","className":"Reservation","variables":{"flightList":2},"javaDoc":"Creates a new sort object and updates flightList with the sorted list","comments":"\n\t * Creates a new sort object, and updates flightList with the sorted list\n\t ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"size":1,"toString":1},"constants":{"\"\"":1,"\"no flight\\n\"":1},"annotations":[],"types":{"Comparable":1,"Flight":1,"String":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","CastExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"/**\n\t * List all flights\n\t * @return A string with the list\n\t */\npublic String listFlights() {\n    String result = \"\";\n    if (flightList.size() == 0)\n        result = \"no flight\\n\";\n    else {\n        for (Comparable c : flightList) {\n            Flight f = (Flight) c;\n            result += f.toString();\n        }\n    }\n    return result;\n}\n","name":"listFlights","className":"Reservation","variables":{"result":4,"flightList":2},"javaDoc":"List all flights A string with the list","comments":"\n\t * List all flights\n\t * @return A string with the list\n\t ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"clear":2},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Closes the reservation by emptying the lists\n\t */\npublic void closeReservation() {\n    passengerList.clear();\n    flightList.clear();\n}\n","name":"closeReservation","className":"Reservation","variables":{"flightList":1,"passengerList":1},"javaDoc":"Closes the reservation by emptying the lists","comments":"\n\t * Closes the reservation by emptying the lists\n\t ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"setSize":1,"getContentPane":1},"constants":{"400":2},"annotations":[],"types":{"WholePanel":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void init() {\n    // create a WholePanel object and add it to the applet\n    WholePanel wholePanel = new WholePanel();\n    getContentPane().add(wholePanel);\n    //set applet size to 400 X 400\n    setSize(400, 400);\n}\n","name":"init","className":"Assignment7","variables":{"wholePanel":1},"javaDoc":"","comments":"create a WholePanel object and add it to the applet set applet size to 400 X 400 ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["double","double"],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public boolean contains(double x, double y);\n","name":"contains","className":"Shape","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["int","int","int","int"],"returnType":"Rectangle","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"Rectangle(int x0, int y0, int width, int height) {\n    this.x0 = x0;\n    this.y0 = y0;\n    this.width = width;\n    this.height = height;\n}\n","name":"Rectangle","className":"Rectangle","variables":{"y0":2,"x0":2,"width":2,"height":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getWidth() {\n    return width;\n}\n","name":"getWidth","className":"Rectangle","variables":{"width":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getHeight() {\n    return height;\n}\n","name":"getHeight","className":"Rectangle","variables":{"height":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getX() {\n    return x0;\n}\n","name":"getX","className":"Rectangle","variables":{"x0":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getY() {\n    return y0;\n}\n","name":"getY","className":"Rectangle","variables":{"y0":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double","double"],"returnType":"boolean","methodCalls":{"getHeight":1,"getWidth":1},"constants":{},"annotations":[],"types":{"double":2},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","EnclosedExpr","ThisExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public boolean contains(double x, double y) {\n    double x0 = this.getX();\n    double y0 = this.getY();\n    return (x >= x0 && y >= y0 && x < x0 + getWidth() && y < y0 + getHeight());\n}\n","name":"contains","className":"Rectangle","variables":{"y0":3,"x0":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"contains":1,"System.out.println":1},"constants":{"50":1,"20":1,"10":2},"annotations":[],"types":{"Shape":1,"Rectangle":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"// Objects Inheritance Classes ;Strings; Interfaces ; BooleanExpressions Variables ArithmeticOperations\npublic static void main(String args[]) {\n    Shape box = new Rectangle(0, 0, 10, 20);\n    System.out.println(box.contains(50, 10));\n}\n","name":"main","className":"Rectangle","variables":{"args":1,"box":2},"javaDoc":"","comments":" Objects Inheritance Classes ;Strings; Interfaces ; BooleanExpressions Variables ArithmeticOperations","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3,"remove":1,"System.out.println":1},"constants":{"1.1":1,"2.2":1,"3.3":1},"annotations":[],"types":{"ArrayList<Double>":1,"Double":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void listIteration() {\n    ArrayList<Double> list = new ArrayList<Double>();\n    list.add(1.1);\n    list.add(2.2);\n    list.add(3.3);\n    list.remove(0);\n    for (Double d : list) System.out.println(d);\n}\n","name":"listIteration","className":"Rectangle","variables":{"list":6},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"BinaryTree","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an empty tree.\n   */\npublic BinaryTree() {\n    root = null;\n}\n","name":"BinaryTree","className":"BinaryTree","variables":{"root":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"BinaryTree","methodCalls":{},"constants":{"null":2},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NullLiteralExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   */\npublic BinaryTree(Object rootData) {\n    root = new Node();\n    root.data = rootData;\n    root.left = null;\n    root.right = null;\n}\n","name":"BinaryTree","className":"BinaryTree","variables":{"root":1,"rootData":2},"javaDoc":"Constructs a tree with one node and no children rootData the data for the root","comments":"\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object","BinaryTree","BinaryTree"],"returnType":"BinaryTree","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a binary tree.\n      @param rootData the data for the root\n      @param left the left subtree\n      @param right the right subtree\n   */\npublic BinaryTree(Object rootData, BinaryTree left, BinaryTree right) {\n    root = new Node();\n    root.data = rootData;\n    root.left = left.root;\n    root.right = right.root;\n}\n","name":"BinaryTree","className":"BinaryTree","variables":{"left":1,"root":1,"rootData":2,"right":1},"javaDoc":"Constructs a binary tree rootData the data for the root left the left subtree right the right subtree","comments":"\n      Constructs a binary tree.\n      @param rootData the data for the root\n      @param left the left subtree\n      @param right the right subtree\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Node"],"returnType":"int","methodCalls":{"max":1,"height":2},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","IntegerLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Returns the height of the subtree whose root is the given node.\n      @param n a node or null\n      @return the height of the subtree, or 0 if n is null\n   */\nprivate static int height(Node n) {\n    if (n == null) {\n        return 0;\n    } else {\n        return 1 + Math.max(height(n.left), height(n.right));\n    }\n}\n","name":"height","className":"BinaryTree","variables":{"Math":1},"javaDoc":"Returns the height of the subtree whose root is the given node n a node or null the height of the subtree or 0 if n is null","comments":"\n      Returns the height of the subtree whose root is the given node.\n      @param n a node or null\n      @return the height of the subtree, or 0 if n is null\n   ","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":[],"returnType":"int","methodCalls":{"height":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Returns the height of this tree.\n      @return the height\n   */\npublic int height() {\n    return height(root);\n}\n","name":"height","className":"BinaryTree","variables":{},"javaDoc":"Returns the height of this tree the height","comments":"\n      Returns the height of this tree.\n      @return the height\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether this tree is empty.\n      @return true if this tree is empty\n   */\npublic boolean isEmpty() {\n    return root == null;\n}\n","name":"isEmpty","className":"BinaryTree","variables":{"root":1},"javaDoc":"Checks whether this tree is empty true if this tree is empty","comments":"\n      Checks whether this tree is empty.\n      @return true if this tree is empty\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the data at the root of this tree.\n      @return the root data\n   */\npublic Object data() {\n    return root.data;\n}\n","name":"data","className":"BinaryTree","variables":{},"javaDoc":"Gets the data at the root of this tree the root data","comments":"\n      Gets the data at the root of this tree.\n      @return the root data\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BinaryTree","methodCalls":{},"constants":{},"annotations":[],"types":{"BinaryTree":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the left subtree of this tree.\n      @return the left child of the root\n   */\npublic BinaryTree left() {\n    BinaryTree result = new BinaryTree();\n    result.root = root.left;\n    return result;\n}\n","name":"left","className":"BinaryTree","variables":{"result":2},"javaDoc":"Gets the left subtree of this tree the left child of the root","comments":"\n      Gets the left subtree of this tree.\n      @return the left child of the root\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"BinaryTree","methodCalls":{},"constants":{},"annotations":[],"types":{"BinaryTree":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the right subtree of this tree.\n      @return the right child of the root\n   */\npublic BinaryTree right() {\n    BinaryTree result = new BinaryTree();\n    result.root = root.right;\n    return result;\n}\n","name":"right","className":"BinaryTree","variables":{"result":2},"javaDoc":"Gets the right subtree of this tree the right child of the root","comments":"\n      Gets the right subtree of this tree.\n      @return the right child of the root\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"data":2,"left":1,"equals":3,"isEmpty":2,"toUpperCase":1,"right":1,"System.out.print":1,"System.out.println":1},"constants":{"\"Does it swim?\"":1,"\"It is an eagle.\"":1,"\"It is an ostrich.\"":1,"false":1,"\"Y\"":2,"\"It is a zebra.\"":1,"\"Does it fly?\"":1,"\"It is a penguin.\"":1,"\"Is it a mammal?\"":1,"\" (Y/N) \"":1,"\"N\"":1,"\"It is a tiger.\"":1,"true":1,"\"Is it a carnivore?\"":1,"\"Does it have stripes?\"":1,"\"It is a pig.\"":1},"annotations":[],"types":{"Scanner":1,"boolean":1,"BinaryTree":3,"String":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt","DoStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    BinaryTree questionTree = new BinaryTree(\"Is it a mammal?\", new BinaryTree(\"Does it have stripes?\", new BinaryTree(\"Is it a carnivore?\", new BinaryTree(\"It is a tiger.\"), new BinaryTree(\"It is a zebra.\")), new BinaryTree(\"It is a pig.\")), new BinaryTree(\"Does it fly?\", new BinaryTree(\"It is an eagle.\"), new BinaryTree(\"Does it swim?\", new BinaryTree(\"It is a penguin.\"), new BinaryTree(\"It is an ostrich.\"))));\n    boolean done = false;\n    Scanner in = new Scanner(System.in);\n    while (!done) {\n        BinaryTree left = questionTree.left();\n        BinaryTree right = questionTree.right();\n        if (left.isEmpty() && right.isEmpty()) {\n            System.out.println(questionTree.data());\n            done = true;\n        } else {\n            String response;\n            do {\n                System.out.print(questionTree.data() + \" (Y/N) \");\n                response = in.next().toUpperCase();\n            } while (!response.equals(\"Y\") && !response.equals(\"N\"));\n            if (response.equals(\"Y\")) {\n                questionTree = left;\n            } else {\n                questionTree = right;\n            }\n        }\n    }\n}\n","name":"main","className":"DecisionTreeDemo","variables":{"args":1,"in":2,"left":3,"response":5,"questionTree":7,"right":3,"done":3},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"MinHeap","methodCalls":{"add":1},"constants":{"null":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NullLiteralExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an empty heap.\n   */\npublic MinHeap() {\n    elements = new ArrayList<>();\n    elements.add(null);\n}\n","name":"MinHeap","className":"MinHeap","variables":{"elements":2},"javaDoc":"Constructs an empty heap","comments":"\n      Constructs an empty heap.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"add":1,"getParent":2,"getParentIndex":1,"set":2,"size":1,"compareTo":1},"constants":{"null":1},"annotations":[],"types":{"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a new element to this heap.\n      @param newElement the element to add\n   */\npublic void add(Comparable newElement) {\n    // Add a new leaf\n    elements.add(null);\n    int index = elements.size() - 1;\n    // Demote parents that are larger than the new element\n    while (index > 1 && getParent(index).compareTo(newElement) > 0) {\n        elements.set(index, getParent(index));\n        index = getParentIndex(index);\n    }\n    // Store the new element into the vacant slot\n    elements.set(index, newElement);\n}\n","name":"add","className":"MinHeap","variables":{"elements":4,"newElement":1,"index":3},"javaDoc":"Adds a new element to this heap newElement the element to add","comments":"Add a new leaf Demote parents that are larger than the new element Store the new element into the vacant slot \n      Adds a new element to this heap.\n      @param newElement the element to add\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"Comparable","methodCalls":{"get":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the minimum element stored in this heap.\n      @return the minimum element\n   */\npublic Comparable peek() {\n    return elements.get(1);\n}\n","name":"peek","className":"MinHeap","variables":{"elements":1},"javaDoc":"Gets the minimum element stored in this heap the minimum element","comments":"\n      Gets the minimum element stored in this heap.\n      @return the minimum element\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Comparable","methodCalls":{"set":1,"size":1,"fixHeap":1,"get":1,"remove":1},"constants":{},"annotations":[],"types":{"Comparable":2,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes the minimum element from this heap.\n      @return the minimum element\n   */\npublic Comparable remove() {\n    Comparable minimum = elements.get(1);\n    // Remove last element\n    int lastIndex = elements.size() - 1;\n    Comparable last = elements.remove(lastIndex);\n    if (lastIndex > 1) {\n        elements.set(1, last);\n        fixHeap();\n    }\n    return minimum;\n}\n","name":"remove","className":"MinHeap","variables":{"last":1,"elements":4,"lastIndex":2,"minimum":2},"javaDoc":"Removes the minimum element from this heap the minimum element","comments":"Remove last element \n      Removes the minimum element from this heap.\n      @return the minimum element\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getLeftChildIndex":1,"set":2,"size":1,"get":1,"compareTo":2,"getRightChild":2,"getRightChildIndex":2,"getLeftChild":1},"constants":{"true":1,"false":2},"annotations":[],"types":{"Comparable":2,"boolean":1,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Turns the tree back into a heap, provided only the root \n      node violates the heap condition.\n   */\nprivate void fixHeap() {\n    Comparable root = elements.get(1);\n    int lastIndex = elements.size() - 1;\n    // Promote children of removed root while they are smaller than root      \n    int index = 1;\n    boolean more = true;\n    while (more) {\n        int childIndex = getLeftChildIndex(index);\n        if (childIndex <= lastIndex) {\n            // Get smaller child \n            // Get left child first\n            Comparable child = getLeftChild(index);\n            // Use right child instead if it is smaller\n            if (getRightChildIndex(index) <= lastIndex && getRightChild(index).compareTo(child) < 0) {\n                childIndex = getRightChildIndex(index);\n                child = getRightChild(index);\n            }\n            // Check if smaller child is smaller than root\n            if (child.compareTo(root) < 0) {\n                // Promote child\n                elements.set(index, child);\n                index = childIndex;\n            } else {\n                // Root is smaller than both children\n                more = false;\n            }\n        } else {\n            // No children\n            more = false;\n        }\n    }\n    // Store root element in vacant slot\n    elements.set(index, root);\n}\n","name":"fixHeap","className":"MinHeap","variables":{"more":4,"root":1,"elements":4,"index":2,"lastIndex":3,"childIndex":4,"child":3},"javaDoc":"Turns the tree back into a heap provided only the root node violates the heap condition","comments":"Promote children of removed root while they are smaller than root Get smaller child Get left child first Use right child instead if it is smaller Check if smaller child is smaller than root Promote child Root is smaller than both children No children Store root element in vacant slot \n      Turns the tree back into a heap, provided only the root \n      node violates the heap condition.\n   ","isEmpty":false,"lineCount":7,"modifier":2}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"size":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether this heap is empty.\n   */\npublic boolean empty() {\n    return elements.size() == 1;\n}\n","name":"empty","className":"MinHeap","variables":{"elements":1},"javaDoc":"Checks whether this heap is empty","comments":"\n      Checks whether this heap is empty.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   */\nprivate static int getLeftChildIndex(int index) {\n    return 2 * index;\n}\n","name":"getLeftChildIndex","className":"MinHeap","variables":{"index":2},"javaDoc":"Returns the index of the left child index the index of a node in this heap the index of the left child of the given node","comments":"\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   ","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   */\nprivate static int getRightChildIndex(int index) {\n    return 2 * index + 1;\n}\n","name":"getRightChildIndex","className":"MinHeap","variables":{"index":2},"javaDoc":"Returns the index of the right child index the index of a node in this heap the index of the right child of the given node","comments":"\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   ","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the index of the parent.\n      @param index the index of a node in this heap\n      @return the index of the parent of the given node\n   */\nprivate static int getParentIndex(int index) {\n    return index / 2;\n}\n","name":"getParentIndex","className":"MinHeap","variables":{"index":2},"javaDoc":"Returns the index of the parent index the index of a node in this heap the index of the parent of the given node","comments":"\n      Returns the index of the parent.\n      @param index the index of a node in this heap\n      @return the index of the parent of the given node\n   ","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["int"],"returnType":"Comparable","methodCalls":{"get":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the value of the left child.\n      @param index the index of a node in this heap\n      @return the value of the left child of the given node\n   */\nprivate Comparable getLeftChild(int index) {\n    return elements.get(2 * index);\n}\n","name":"getLeftChild","className":"MinHeap","variables":{"elements":1,"index":2},"javaDoc":"Returns the value of the left child index the index of a node in this heap the value of the left child of the given node","comments":"\n      Returns the value of the left child.\n      @param index the index of a node in this heap\n      @return the value of the left child of the given node\n   ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["int"],"returnType":"Comparable","methodCalls":{"get":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the value of the right child.\n      @param index the index of a node in this heap\n      @return the value of the right child of the given node\n   */\nprivate Comparable getRightChild(int index) {\n    return elements.get(2 * index + 1);\n}\n","name":"getRightChild","className":"MinHeap","variables":{"elements":1,"index":2},"javaDoc":"Returns the value of the right child index the index of a node in this heap the value of the right child of the given node","comments":"\n      Returns the value of the right child.\n      @param index the index of a node in this heap\n      @return the value of the right child of the given node\n   ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["int"],"returnType":"Comparable","methodCalls":{"get":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the value of the parent.\n      @param index the index of a node in this heap\n      @return the value of the parent of the given node\n   */\nprivate Comparable getParent(int index) {\n    return elements.get(index / 2);\n}\n","name":"getParent","className":"MinHeap","variables":{"elements":1,"index":2},"javaDoc":"Returns the value of the parent index the index of a node in this heap the value of the parent of the given node","comments":"\n      Returns the value of the parent.\n      @param index the index of a node in this heap\n      @return the value of the parent of the given node\n   ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["int","String"],"returnType":"WorkOrder","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   */\npublic WorkOrder(int aPriority, String aDescription) {\n    priority = aPriority;\n    description = aDescription;\n}\n","name":"WorkOrder","className":"WorkOrder","variables":{"aPriority":2,"aDescription":2,"description":1,"priority":1},"javaDoc":"Constructs a work order with a given priority and description aPriority the priority of this work order aDescription the description of this work order","comments":"\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\", description=\"":1,"\"priority=\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"priority=\" + priority + \", description=\" + description;\n}\n","name":"toString","className":"WorkOrder","variables":{"description":1,"priority":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"WorkOrder":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","CastExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public int compareTo(Object otherObject) {\n    WorkOrder other = (WorkOrder) otherObject;\n    if (priority < other.priority) {\n        return -1;\n    }\n    if (priority > other.priority) {\n        return 1;\n    }\n    return 0;\n}\n","name":"compareTo","className":"WorkOrder","variables":{"other":1,"priority":2,"otherObject":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":8,"remove":1,"empty":1,"System.out.println":1},"constants":{"\"Remove pencil sharpener shavings\"":1,"\"Replace light bulb\"":1,"\"Order cleaning supplies\"":1,"\"Shampoo carpets\"":1,"\"Empty trash\"":1,"\"Fix broken sink\"":1,"\"Water plants\"":1,"\"Clean coffee maker\"":1,"10":1},"annotations":[],"types":{"MinHeap":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    MinHeap q = new MinHeap();\n    q.add(new WorkOrder(3, \"Shampoo carpets\"));\n    q.add(new WorkOrder(7, \"Empty trash\"));\n    q.add(new WorkOrder(8, \"Water plants\"));\n    q.add(new WorkOrder(10, \"Remove pencil sharpener shavings\"));\n    q.add(new WorkOrder(6, \"Replace light bulb\"));\n    q.add(new WorkOrder(1, \"Fix broken sink\"));\n    q.add(new WorkOrder(9, \"Clean coffee maker\"));\n    q.add(new WorkOrder(2, \"Order cleaning supplies\"));\n    while (!q.empty()) {\n        System.out.println(q.remove());\n    }\n}\n","name":"main","className":"HeapDemo","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":10,"print":1,"remove":4,"System.out.println":1},"constants":{"\"D\"":2,"\"C\"":1,"\"B\"":2,"\"A\"":2,"\"Expected: C E G H I J\"":1,"\"J\"":1,"\"I\"":1,"\"H\"":1,"\"G\"":1,"\"F\"":2,"\"E\"":1},"annotations":[],"types":{"BinarySearchTree":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    BinarySearchTree t = new BinarySearchTree();\n    t.add(\"D\");\n    t.add(\"B\");\n    t.add(\"A\");\n    t.add(\"C\");\n    t.add(\"F\");\n    t.add(\"E\");\n    t.add(\"I\");\n    t.add(\"G\");\n    t.add(\"H\");\n    t.add(\"J\");\n    // Removing leaf\n    t.remove(\"A\");\n    // Removing element with one child\n    t.remove(\"B\");\n    // Removing element with two children\n    t.remove(\"F\");\n    // Removing root\n    t.remove(\"D\");\n    t.print();\n    System.out.println(\"Expected: C E G H I J\");\n}\n","name":"main","className":"TreeTester","variables":{"args":1},"javaDoc":"","comments":"Removing leaf Removing element with one child Removing element with two children Removing root ","isEmpty":false,"lineCount":17,"modifier":9}
{"paramTypes":[],"returnType":"BinarySearchTree","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an empty tree.\n   */\npublic BinarySearchTree() {\n    root = null;\n}\n","name":"BinarySearchTree","className":"BinarySearchTree","variables":{"root":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"addNode":1},"constants":{"null":3},"annotations":[],"types":{"Node":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(Comparable obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n}\n","name":"add","className":"BinarySearchTree","variables":{"obj":2,"root":3,"newNode":2},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"constants":{"null":1,"true":1,"false":1},"annotations":[],"types":{"Node":1,"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(Comparable obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"BinarySearchTree","variables":{"current":4,"obj":1,"root":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"toBeRemoved.data.compareTo":1},"constants":{"null":7,"false":1,"true":1},"annotations":[],"types":{"boolean":1,"Node":5,"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(Comparable obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    Node parent = null;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            parent = toBeRemoved;\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        if (// Found in root\n        parent == null) {\n            root = newChild;\n        } else if (parent.left == toBeRemoved) {\n            parent.left = newChild;\n        } else {\n            parent.right = newChild;\n        }\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallestParent = toBeRemoved;\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallestParent = smallest;\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    if (smallestParent == toBeRemoved) {\n        smallestParent.right = smallest.right;\n    } else {\n        smallestParent.left = smallest.right;\n    }\n}\n","name":"remove","className":"BinarySearchTree","variables":{"parent":3,"smallestParent":3,"toBeRemoved":8,"found":4,"newChild":6,"obj":1,"smallest":3,"root":2},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child Found in root \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"lineCount":18,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"print":1,"System.out.println":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Prints the contents of the tree in sorted order.\n   */\npublic void print() {\n    print(root);\n    System.out.println();\n}\n","name":"print","className":"BinarySearchTree","variables":{},"javaDoc":"Prints the contents of the tree in sorted order","comments":"\n      Prints the contents of the tree in sorted order.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"print":2,"System.out.print":1},"constants":{"null":1,"\" \"":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   */\nprivate static void print(Node parent) {\n    if (parent == null) {\n        return;\n    }\n    print(parent.left);\n    System.out.print(parent.data + \" \");\n    print(parent.right);\n}\n","name":"print","className":"BinarySearchTree","variables":{"parent":2},"javaDoc":"Prints a node and all of its descendants in sorted order parent the root of the subtree to print","comments":"\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   ","isEmpty":false,"lineCount":4,"modifier":10}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"constants":{"null":2},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":3,"right":3},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Map<Character, Integer>"],"returnType":"HuffmanTree","methodCalls":{"add":2,"size":1,"get":1,"keySet":1,"remove":3},"constants":{},"annotations":[],"types":{"Node":4,"char":1,"PriorityQueue":1,"PriorityQueue<Node>":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Constructs a Huffman tree from given character frequencies.\n      @param frequencies a map whose keys are the characters to be encoded\n      and whose values are the frequencies of the characters\n   */\npublic HuffmanTree(Map<Character, Integer> frequencies) {\n    PriorityQueue<Node> nodes = new PriorityQueue<>();\n    for (char ch : frequencies.keySet()) {\n        Node newNode = new Node();\n        newNode.character = ch;\n        newNode.frequency = frequencies.get(ch);\n        nodes.add(newNode);\n    }\n    while (nodes.size() > 1) {\n        Node smallest = nodes.remove();\n        Node nextSmallest = nodes.remove();\n        Node newNode = new Node();\n        newNode.frequency = smallest.frequency + nextSmallest.frequency;\n        newNode.left = smallest;\n        newNode.right = nextSmallest;\n        nodes.add(newNode);\n    }\n    root = nodes.remove();\n}\n","name":"HuffmanTree","className":"HuffmanTree","variables":{"nextSmallest":2,"nodes":7,"ch":2,"smallest":2,"root":1,"newNode":2,"frequencies":3},"javaDoc":"Constructs a Huffman tree from given character frequencies frequencies a map whose keys are the characters to be encoded and whose values are the frequencies of the characters","comments":"\n      Constructs a Huffman tree from given character frequencies.\n      @param frequencies a map whose keys are the characters to be encoded\n      and whose values are the frequencies of the characters\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"length":1,"charAt":1},"constants":{"\"\"":1,"null":1,"'0'":1},"annotations":[],"types":{"Node":1,"char":1,"String":1,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","CharLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Decodes an encoded string.\n      @param input a string made up of 0 and 1\n   */\npublic String decode(String input) {\n    String result = \"\";\n    Node n = root;\n    for (int i = 0; i < input.length(); i++) {\n        char ch = input.charAt(i);\n        if (ch == '0') {\n            n = n.left;\n        } else {\n            n = n.right;\n        }\n        if (// n is a leaf\n        n.left == null) {\n            result = result + n.character;\n            n = root;\n        }\n    }\n    return result;\n}\n","name":"decode","className":"HuffmanTree","variables":{"result":4,"input":3,"ch":2,"root":2},"javaDoc":"Decodes an encoded string input a string made up of 0 and 1","comments":"n is a leaf \n      Decodes an encoded string.\n      @param input a string made up of 0 and 1\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"Map<Character, String>","methodCalls":{"fillEncodingMap":1},"constants":{"\"\"":1,"null":1},"annotations":[],"types":{"Map<Character, String>":1,"HashMap":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public Map<Character, String> getEncodingMap() {\n    Map<Character, String> map = new HashMap<>();\n    if (root != null) {\n        root.fillEncodingMap(map, \"\");\n    }\n    return map;\n}\n","name":"getEncodingMap","className":"HuffmanTree","variables":{"root":2,"map":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Node"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int compareTo(Node other) {\n    return frequency - other.frequency;\n}\n","name":"compareTo","className":"Node","variables":{"other":1,"frequency":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Map<Character, String>","String"],"returnType":"void","methodCalls":{"fillEncodingMap":2,"put":1},"constants":{"\"1\"":1,"null":1,"\"0\"":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void fillEncodingMap(Map<Character, String> map, String prefix) {\n    if (// it's a leaf\n    left == null) {\n        map.put(character, prefix);\n    } else {\n        left.fillEncodingMap(map, prefix + \"0\");\n        right.fillEncodingMap(map, prefix + \"1\");\n    }\n}\n","name":"fillEncodingMap","className":"Node","variables":{"left":2,"prefix":3,"right":1,"map":2},"javaDoc":"","comments":"it's a leaf ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"encode":1,"getEncodingMap":1,"decode":1,"put":13,"System.out.println":2},"constants":{"'N'":1,"'L'":1,"'H'":1,"472":1,"671":1,"354":1,"576":1,"357":1,"259":1,"'W'":1,"239":1,"'U'":1,"74":1,"'O'":1,"'M'":1,"'K'":1,"'I'":1,"'\\''":1,"2089":1,"'E'":1,"'A'":1,"660":1,"541":1,"\"ALOHA\"":1,"844":1,"849":1,"'P'":1},"annotations":[],"types":{"Map<Character, String>":1,"HashMap":1,"Map<Character, Integer>":1,"HuffmanTree":1,"String":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","CharLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Map<Character, Integer> frequencyMap = new HashMap<>();\n    frequencyMap.put('A', 2089);\n    frequencyMap.put('E', 576);\n    frequencyMap.put('H', 357);\n    frequencyMap.put('I', 671);\n    frequencyMap.put('K', 849);\n    frequencyMap.put('L', 354);\n    frequencyMap.put('M', 259);\n    frequencyMap.put('N', 660);\n    frequencyMap.put('O', 844);\n    frequencyMap.put('P', 239);\n    frequencyMap.put('U', 472);\n    frequencyMap.put('W', 74);\n    frequencyMap.put('\\'', 541);\n    HuffmanTree tree = new HuffmanTree(frequencyMap);\n    Map<Character, String> encodingMap = tree.getEncodingMap();\n    String encoded = encode(\"ALOHA\", encodingMap);\n    System.out.println(encoded);\n    String decoded = tree.decode(encoded);\n    System.out.println(decoded);\n}\n","name":"main","className":"HuffmanDemo","variables":{"args":1,"encodingMap":1,"tree":3,"decoded":1,"frequencyMap":15,"encoded":1},"javaDoc":"","isEmpty":false,"lineCount":20,"modifier":9}
{"paramTypes":["String","Map<Character, String>"],"returnType":"String","methodCalls":{"get":1,"length":1,"charAt":1},"constants":{"\"\"":1},"annotations":[],"types":{"char":1,"String":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static String encode(String toEncode, Map<Character, String> encodingMap) {\n    String result = \"\";\n    for (int i = 0; i < toEncode.length(); i++) {\n        char ch = toEncode.charAt(i);\n        result = result + encodingMap.get(ch);\n    }\n    return result;\n}\n","name":"encode","className":"HuffmanDemo","variables":{"result":4,"encodingMap":2,"ch":1,"toEncode":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"removalTestTemplate":1,"insertionTest":1,"removalTest":1,"testFromBook":1,"System.out.println":1},"constants":{"\"ABCDEFGHIJ\"":1,"\"All tests passed.\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    testFromBook();\n    insertionTest(\"ABCDEFGHIJ\");\n    removalTest(removalTestTemplate());\n    System.out.println(\"All tests passed.\");\n}\n","name":"main","className":"RedBlackTreeTester","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":10,"assertEquals":1,"toString":1,"remove":4},"constants":{"\"D\"":2,"\"C\"":1,"\"B\"":2,"\"A\"":2,"\"J\"":1,"\"I\"":1,"\"H\"":1,"\"C E G H I J \"":1,"\"G\"":1,"\"F\"":2,"\"E\"":1},"annotations":[],"types":{"RedBlackTree":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Runs the simple test from the textbook.\n   */\npublic static void testFromBook() {\n    RedBlackTree t = new RedBlackTree();\n    t.add(\"D\");\n    t.add(\"B\");\n    t.add(\"A\");\n    t.add(\"C\");\n    t.add(\"F\");\n    t.add(\"E\");\n    t.add(\"I\");\n    t.add(\"G\");\n    t.add(\"H\");\n    t.add(\"J\");\n    // Removing leaf\n    t.remove(\"A\");\n    // Removing element with one child\n    t.remove(\"B\");\n    // Removing element with two children\n    t.remove(\"F\");\n    // Removing root      \n    t.remove(\"D\");\n    assertEquals(\"C E G H I J \", t.toString());\n}\n","name":"testFromBook","className":"RedBlackTreeTester","variables":{},"javaDoc":"Runs the simple test from the textbook","comments":"Removing leaf Removing element with one child Removing element with two children Removing root \n      Runs the simple test from the textbook.\n   ","isEmpty":false,"lineCount":16,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getPermutations":1,"add":1,"length":1,"replace":1,"assertEquals":1,"toString":1,"substring":1},"constants":{"\"\"":1,"\" \"":1},"annotations":[],"types":{"RedBlackTree":1,"PermutationGenerator":1,"String":2,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Inserts all permutations of a string into a red-black tree and checks that \n      it contains the strings afterwards.\n      @param letters a string of letters without repetition\n   */\npublic static void insertionTest(String letters) {\n    PermutationGenerator gen = new PermutationGenerator(letters);\n    for (String perm : gen.getPermutations()) {\n        RedBlackTree t = new RedBlackTree();\n        for (int i = 0; i < perm.length(); i++) {\n            String s = perm.substring(i, i + 1);\n            t.add(s);\n        }\n        assertEquals(letters, t.toString().replace(\" \", \"\"));\n    }\n}\n","name":"insertionTest","className":"RedBlackTreeTester","variables":{"gen":2,"perm":3,"letters":2},"javaDoc":"Inserts all permutations of a string into a red-black tree and checks that it contains the strings afterwards letters a string of letters without repetition","comments":"\n      Inserts all permutations of a string into a red-black tree and checks that \n      it contains the strings afterwards.\n      @param letters a string of letters without repetition\n   ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["RedBlackTree"],"returnType":"void","methodCalls":{"mirror":1,"getNodes":1,"count":1,"costToRoot":2,"remove":1,"populate":1,"setLeftChild":1,"find":2,"checkRedBlack":2,"equals":1,"pow":1,"copy":1,"fullTree":2,"setRightChild":1},"constants":{"\" not deleted\"":1,"null":3,"true":1,"false":1,"\" deleted\"":1},"annotations":[],"types":{"RedBlackTree.Node[]":1,"Integer":1,"RedBlackTree":1,"Comparable":1,"boolean":1,"RedBlackTree.Node":3,"int":7},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ForeachStmt","ForStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":["IllegalStateException"],"text":"/**\n      Tests removal, given a template for a tree with a black node that\n      is to be deleted. All other nodes should be given all possible combinations \n      of red and black.\n      @param t the template for the test cases\n   */\npublic static void removalTest(RedBlackTree t) {\n    for (int m = 0; m <= 1; m++) {\n        // We don't recolor the root or toDelete\n        int nodesToColor = count(t.root) - 2;\n        for (int k = 0; k < Math.pow(2, nodesToColor); k++) {\n            RedBlackTree rb = new RedBlackTree();\n            if (m == 0) {\n                rb.root = copy(t.root);\n            } else {\n                rb.root = mirror(t.root);\n            }\n            RedBlackTree.Node[] nodes = getNodes(rb);\n            RedBlackTree.Node toDelete = null;\n            // Color with the bit pattern of k\n            int bits = k;\n            for (RedBlackTree.Node n : nodes) {\n                if (n == rb.root) {\n                    n.color = RedBlackTree.BLACK;\n                } else if (n.color == RedBlackTree.BLACK) {\n                    toDelete = n;\n                } else {\n                    n.color = bits % 2;\n                    bits = bits / 2;\n                }\n            }\n            // Add children to make equal costs to null\n            int targetCost = costToRoot(toDelete);\n            for (RedBlackTree.Node n : nodes) {\n                int cost = targetCost - costToRoot(n);\n                if (n.left == null) {\n                    n.setLeftChild(fullTree(cost));\n                }\n                if (n.right == null) {\n                    n.setRightChild(fullTree(cost));\n                }\n            }\n            int filledSize = populate(rb);\n            boolean good = true;\n            try {\n                checkRedBlack(rb);\n            } catch (IllegalStateException ex) {\n                good = false;\n            }\n            if (good) {\n                Comparable d = toDelete.data;\n                rb.remove(d);\n                checkRedBlack(rb);\n                for (Integer j = 0; j < filledSize; j++) {\n                    if (!rb.find(j) && !d.equals(j)) {\n                        throw new IllegalStateException(j + \" deleted\");\n                    }\n                    if (rb.find(d)) {\n                        throw new IllegalStateException(d + \" not deleted\");\n                    }\n                }\n            }\n        }\n    }\n}\n","name":"removalTest","className":"RedBlackTreeTester","variables":{"rb":4,"toDelete":2,"nodes":3,"cost":1,"ex":1,"filledSize":2,"targetCost":2,"nodesToColor":1,"bits":4,"Math":1,"good":3},"javaDoc":"Tests removal given a template for a tree with a black node that is to be deleted All other nodes should be given all possible combinations of red and black t the template for the test cases","comments":"We don't recolor the root or toDelete Color with the bit pattern of k Add children to make equal costs to null \n      Tests removal, given a template for a tree with a black node that\n      is to be deleted. All other nodes should be given all possible combinations \n      of red and black.\n      @param t the template for the test cases\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"RedBlackTree","methodCalls":{},"constants":{},"annotations":[],"types":{"RedBlackTree.Node[]":1,"RedBlackTree":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Makes a template for testing removal.\n      @return a partially complete red-black tree for the test. \n      The node to be removed is black.\n   */\nprivate static RedBlackTree removalTestTemplate() {\n    RedBlackTree template = new RedBlackTree();\n    /*\n                            n7\n                           /  \\\n                          n1   n8\n                         /  \\\n                       n0    n3\n                            /  \\\n                           n2*  n5\n                                /\\\n                              n4  n6\n      */\n    RedBlackTree.Node[] n = new RedBlackTree.Node[9];\n    for (int i = 0; i < n.length; i++) {\n        n[i] = new RedBlackTree.Node();\n    }\n    template.root = n[7];\n    n[7].setLeftChild(n[1]);\n    n[7].setRightChild(n[8]);\n    n[1].setLeftChild(n[0]);\n    n[1].setRightChild(n[3]);\n    n[3].setLeftChild(n[2]);\n    n[3].setRightChild(n[5]);\n    n[5].setLeftChild(n[4]);\n    n[5].setRightChild(n[6]);\n    n[2].color = RedBlackTree.BLACK;\n    return template;\n}\n","name":"removalTestTemplate","className":"RedBlackTreeTester","variables":{"template":2},"javaDoc":"Makes a template for testing removal a partially complete red-black tree for the test The node to be removed is black","comments":"n7 / \\ n1 n8 / \\ n0 n3 / \\ n2 n5 /\\ n4 n6 \n      Makes a template for testing removal.\n      @return a partially complete red-black tree for the test. \n      The node to be removed is black.\n   ","isEmpty":false,"lineCount":15,"modifier":10}
{"paramTypes":["RedBlackTree"],"returnType":"RedBlackTree.Node[]","methodCalls":{"getNodes":1,"count":1},"constants":{},"annotations":[],"types":{"RedBlackTree.Node[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Gets all nodes of this tree in sorted order.\n      @param t a red-black tree\n      @return an array of all nodes in t\n   */\nprivate static RedBlackTree.Node[] getNodes(RedBlackTree t) {\n    RedBlackTree.Node[] nodes = new RedBlackTree.Node[count(t.root)];\n    getNodes(t.root, nodes, 0);\n    return nodes;\n}\n","name":"getNodes","className":"RedBlackTreeTester","variables":{"nodes":2},"javaDoc":"Gets all nodes of this tree in sorted order t a red-black tree an array of all nodes in t","comments":"\n      Gets all nodes of this tree in sorted order.\n      @param t a red-black tree\n      @return an array of all nodes in t\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["RedBlackTree.Node","RedBlackTree.Node[]","int"],"returnType":"int","methodCalls":{"getNodes":2},"constants":{"null":1},"annotations":[],"types":{"int":2},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Gets all nodes of a subtree and fills them into an array.\n      @param n the root of the subtree\n      @param nodes the array into which to place the nodes\n      @param start the offset at which to start placing the nodes\n      @return the number of nodes placed\n   */\nprivate static int getNodes(RedBlackTree.Node n, RedBlackTree.Node[] nodes, int start) {\n    if (n == null) {\n        return 0;\n    }\n    int leftFilled = getNodes(n.left, nodes, start);\n    nodes[start + leftFilled] = n;\n    int rightFilled = getNodes(n.right, nodes, start + leftFilled + 1);\n    return leftFilled + 1 + rightFilled;\n}\n","name":"getNodes","className":"RedBlackTreeTester","variables":{"nodes":2,"rightFilled":2,"start":3,"leftFilled":4},"javaDoc":"Gets all nodes of a subtree and fills them into an array n the root of the subtree nodes the array into which to place the nodes start the offset at which to start placing the nodes the number of nodes placed","comments":"\n      Gets all nodes of a subtree and fills them into an array.\n      @param n the root of the subtree\n      @param nodes the array into which to place the nodes\n      @param start the offset at which to start placing the nodes\n      @return the number of nodes placed\n   ","isEmpty":false,"lineCount":5,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"int","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the cost from a node to a root.\n      @param n a node of a red-black tree\n      @return the number of black nodes between n and the root\n   */\nprivate static int costToRoot(RedBlackTree.Node n) {\n    int c = 0;\n    while (n != null) {\n        c = c + n.color;\n        n = n.parent;\n    }\n    return c;\n}\n","name":"costToRoot","className":"RedBlackTreeTester","variables":{},"javaDoc":"Computes the cost from a node to a root n a node of a red-black tree the number of black nodes between n and the root","comments":"\n      Computes the cost from a node to a root.\n      @param n a node of a red-black tree\n      @return the number of black nodes between n and the root\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"RedBlackTree.Node","methodCalls":{"setLeftChild":1,"copy":2,"setRightChild":1},"constants":{"null":2},"annotations":[],"types":{"RedBlackTree.Node":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Copies all nodes of a red-black tree.\n      @param n the root of a red-black tree\n      @return the root node of a copy of the tree\n   */\nprivate static RedBlackTree.Node copy(RedBlackTree.Node n) {\n    if (n == null) {\n        return null;\n    }\n    RedBlackTree.Node newNode = new RedBlackTree.Node();\n    newNode.setLeftChild(copy(n.left));\n    newNode.setRightChild(copy(n.right));\n    newNode.data = n.data;\n    newNode.color = n.color;\n    return newNode;\n}\n","name":"copy","className":"RedBlackTreeTester","variables":{"newNode":4},"javaDoc":"Copies all nodes of a red-black tree n the root of a red-black tree the root node of a copy of the tree","comments":"\n      Copies all nodes of a red-black tree.\n      @param n the root of a red-black tree\n      @return the root node of a copy of the tree\n   ","isEmpty":false,"lineCount":7,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"RedBlackTree.Node","methodCalls":{"mirror":2,"setLeftChild":1,"setRightChild":1},"constants":{"null":2},"annotations":[],"types":{"RedBlackTree.Node":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Generates the mirror image of a red-black tree\n      @param n the root of the tree to reflect\n      @return the root of the mirror image of the tree\n   */\nprivate static RedBlackTree.Node mirror(RedBlackTree.Node n) {\n    if (n == null) {\n        return null;\n    }\n    RedBlackTree.Node newNode = new RedBlackTree.Node();\n    newNode.setLeftChild(mirror(n.right));\n    newNode.setRightChild(mirror(n.left));\n    newNode.data = n.data;\n    newNode.color = n.color;\n    return newNode;\n}\n","name":"mirror","className":"RedBlackTreeTester","variables":{"newNode":4},"javaDoc":"Generates the mirror image of a red-black tree n the root of the tree to reflect the root of the mirror image of the tree","comments":"\n      Generates the mirror image of a red-black tree\n      @param n the root of the tree to reflect\n      @return the root of the mirror image of the tree\n   ","isEmpty":false,"lineCount":7,"modifier":10}
{"paramTypes":["int"],"returnType":"RedBlackTree.Node","methodCalls":{"setLeftChild":1,"fullTree":2,"setRightChild":1},"constants":{"null":1},"annotations":[],"types":{"RedBlackTree.Node":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Makes a full tree of black nodes of a given depth.\n      @param depth the desired depth\n      @return the root node of a full black tree\n   */\nprivate static RedBlackTree.Node fullTree(int depth) {\n    if (depth <= 0) {\n        return null;\n    }\n    RedBlackTree.Node r = new RedBlackTree.Node();\n    r.color = RedBlackTree.BLACK;\n    r.setLeftChild(fullTree(depth - 1));\n    r.setRightChild(fullTree(depth - 1));\n    return r;\n}\n","name":"fullTree","className":"RedBlackTreeTester","variables":{"depth":4},"javaDoc":"Makes a full tree of black nodes of a given depth depth the desired depth the root node of a full black tree","comments":"\n      Makes a full tree of black nodes of a given depth.\n      @param depth the desired depth\n      @return the root node of a full black tree\n   ","isEmpty":false,"lineCount":6,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"int","methodCalls":{"count":2},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","IntegerLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Counts the nodes in a tree\n      @param n the root of a red-black tree\n      @return the number of nodes in the tree\n   */\nprivate static int count(RedBlackTree.Node n) {\n    if (n == null) {\n        return 0;\n    } else {\n        return 1 + count(n.left) + count(n.right);\n    }\n}\n","name":"count","className":"RedBlackTreeTester","variables":{},"javaDoc":"Counts the nodes in a tree n the root of a red-black tree the number of nodes in the tree","comments":"\n      Counts the nodes in a tree\n      @param n the root of a red-black tree\n      @return the number of nodes in the tree\n   ","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["RedBlackTree"],"returnType":"int","methodCalls":{"getNodes":1},"constants":{},"annotations":[],"types":{"RedBlackTree.Node[]":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Populates this tree with the values 0, 1, 2, ... .\n      @param t a red-black tree\n      @return the number of nodes in t\n   */\nprivate static int populate(RedBlackTree t) {\n    RedBlackTree.Node[] nodes = getNodes(t);\n    for (int i = 0; i < nodes.length; i++) {\n        nodes[i].data = new Integer(i);\n    }\n    return nodes.length;\n}\n","name":"populate","className":"RedBlackTreeTester","variables":{"nodes":2},"javaDoc":"Populates this tree with the values 0 1 2 t a red-black tree the number of nodes in t","comments":"\n      Populates this tree with the values 0, 1, 2, ... .\n      @param t a red-black tree\n      @return the number of nodes in t\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["RedBlackTree"],"returnType":"void","methodCalls":{"nodes[i].data.compareTo":1,"getNodes":1,"checkRedBlack":1},"constants":{"true":1,"\" is larger than \"":1},"annotations":[],"types":{"RedBlackTree.Node[]":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ThrowStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Checks whether a red-black tree is valid and throws an exception if not.\n      @param t the tree to test\n   */\npublic static void checkRedBlack(RedBlackTree t) {\n    checkRedBlack(t.root, true);\n    // Check that it's a BST\n    RedBlackTree.Node[] nodes = getNodes(t);\n    for (int i = 0; i < nodes.length - 1; i++) {\n        if (nodes[i].data.compareTo(nodes[i + 1].data) > 0) {\n            throw new IllegalStateException(nodes[i].data + \" is larger than \" + nodes[i + 1].data);\n        }\n    }\n}\n","name":"checkRedBlack","className":"RedBlackTreeTester","variables":{"nodes":5},"javaDoc":"Checks whether a red-black tree is valid and throws an exception if not t the tree to test","comments":"Check that it's a BST \n      Checks whether a red-black tree is valid and throws an exception if not.\n      @param t the tree to test\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["RedBlackTree.Node","boolean"],"returnType":"int","methodCalls":{"checkRedBlack":2},"constants":{"false":2,"\" have different black depths\"":1,"\" is not root and has no parent\"":1,"\" is red\"":1,"\" has bad parent link\"":2,"\" is not black\"":1,"\"Parent of red \"":1,"\"Left child of \"":1,"\"Left and right children of \"":1,"null":4,"\" has color \"":1,"\"Root \"":1,"\" is root and has a parent\"":1,"\"Right child of \"":1},"annotations":[],"types":{"int":2},"expressions":["NullLiteralExpr","IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ThrowStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Checks that the tree with the given node is a red-black tree, and throws an\n      exception if a structural error is found.\n      @param n the root of the subtree to check\n      @param isRoot true if this is the root of the tree\n      @return the black depth of this subtree \n   */\nprivate static int checkRedBlack(RedBlackTree.Node n, boolean isRoot) {\n    if (n == null) {\n        return 0;\n    }\n    int nleft = checkRedBlack(n.left, false);\n    int nright = checkRedBlack(n.right, false);\n    if (nleft != nright) {\n        throw new IllegalStateException(\"Left and right children of \" + n.data + \" have different black depths\");\n    }\n    if (n.parent == null) {\n        if (!isRoot) {\n            throw new IllegalStateException(n.data + \" is not root and has no parent\");\n        }\n        if (n.color != RedBlackTree.BLACK) {\n            throw new IllegalStateException(\"Root \" + n.data + \" is not black\");\n        }\n    } else {\n        if (isRoot) {\n            throw new IllegalStateException(n.data + \" is root and has a parent\");\n        }\n        if (n.color == RedBlackTree.RED && n.parent.color == RedBlackTree.RED) {\n            throw new IllegalStateException(\"Parent of red \" + n.data + \" is red\");\n        }\n    }\n    if (n.left != null && n.left.parent != n) {\n        throw new IllegalStateException(\"Left child of \" + n.data + \" has bad parent link\");\n    }\n    if (n.right != null && n.right.parent != n) {\n        throw new IllegalStateException(\"Right child of \" + n.data + \" has bad parent link\");\n    }\n    if (n.color != RedBlackTree.RED && n.color != RedBlackTree.BLACK) {\n        throw new IllegalStateException(n.data + \" has color \" + n.color);\n    }\n    return n.color + nleft;\n}\n","name":"checkRedBlack","className":"RedBlackTreeTester","variables":{"nright":2,"isRoot":3,"nleft":3},"javaDoc":"Checks that the tree with the given node is a red-black tree and throws an exception if a structural error is found n the root of the subtree to check isRoot true if this is the root of the tree the black depth of this subtree","comments":"\n      Checks that the tree with the given node is a red-black tree, and throws an\n      exception if a structural error is found.\n      @param n the root of the subtree to check\n      @param isRoot true if this is the root of the tree\n      @return the black depth of this subtree \n   ","isEmpty":false,"lineCount":9,"modifier":10}
{"paramTypes":["Object","Object"],"returnType":"void","methodCalls":{"equals":1},"constants":{"null":2,"\"Expected \"":1,"\" but found \"":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt"],"concepts":[],"exceptions":[],"text":"public static void assertEquals(Object expected, Object actual) {\n    if (expected == null && actual != null || !expected.equals(actual)) {\n        throw new AssertionError(\"Expected \" + expected + \" but found \" + actual);\n    }\n}\n","name":"assertEquals","className":"RedBlackTreeTester","variables":{"actual":3,"expected":4},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"PermutationGenerator","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a permutation generator.\n      @param aWord the word to permute\n   */\npublic PermutationGenerator(String aWord) {\n    word = aWord;\n}\n","name":"PermutationGenerator","className":"PermutationGenerator","variables":{"aWord":2,"word":1},"javaDoc":"Constructs a permutation generator aWord the word to permute","comments":"\n      Constructs a permutation generator.\n      @param aWord the word to permute\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ArrayList<String>","methodCalls":{"add":2,"getPermutations":1,"length":2,"substring":2,"charAt":1},"constants":{},"annotations":[],"types":{"ArrayList":1,"ArrayList<String>":2,"String":2,"PermutationGenerator":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ForStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Gets all permutations of a given word.\n   */\npublic ArrayList<String> getPermutations() {\n    ArrayList<String> permutations = new ArrayList<>();\n    // The empty string has a single permutation: itself\n    if (word.length() == 0) {\n        permutations.add(word);\n        return permutations;\n    }\n    // Loop through all character positions\n    for (int i = 0; i < word.length(); i++) {\n        // Form a simpler word by removing the ith character\n        String shorterWord = word.substring(0, i) + word.substring(i + 1);\n        // Generate all permutations of the simpler word\n        PermutationGenerator shorterPermutationGenerator = new PermutationGenerator(shorterWord);\n        ArrayList<String> shorterWordPermutations = shorterPermutationGenerator.getPermutations();\n        // each permutation of the simpler word, \n        for (String s : shorterWordPermutations) {\n            permutations.add(word.charAt(i) + s);\n        }\n    }\n    // Return all permutations\n    return permutations;\n}\n","name":"getPermutations","className":"PermutationGenerator","variables":{"shorterPermutationGenerator":2,"shorterWord":2,"shorterWordPermutations":2,"permutations":5,"word":5},"javaDoc":"Gets all permutations of a given word","comments":"The empty string has a single permutation: itself Loop through all character positions Add the removed character to the front of Form a simpler word by removing the ith character Generate all permutations of the simpler word each permutation of the simpler word Return all permutations \n      Gets all permutations of a given word.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"RedBlackTree","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an empty tree.\n   */\npublic RedBlackTree() {\n    root = null;\n}\n","name":"RedBlackTree","className":"RedBlackTree","variables":{"root":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"addNode":1,"fixAfterAdd":1},"constants":{"null":3},"annotations":[],"types":{"Node":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(Comparable obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n    fixAfterAdd(newNode);\n}\n","name":"add","className":"RedBlackTree","variables":{"obj":2,"root":3,"newNode":2},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"constants":{"null":1,"true":1,"false":1},"annotations":[],"types":{"Node":1,"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(Comparable obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"RedBlackTree","variables":{"current":4,"obj":1,"root":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"fixBeforeRemove":2,"toBeRemoved.data.compareTo":1,"replaceWith":2},"constants":{"null":5,"false":1,"true":1},"annotations":[],"types":{"boolean":1,"Node":3,"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(Comparable obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        fixBeforeRemove(toBeRemoved);\n        replaceWith(toBeRemoved, newChild);\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    fixBeforeRemove(smallest);\n    replaceWith(smallest, smallest.right);\n}\n","name":"remove","className":"RedBlackTree","variables":{"toBeRemoved":4,"found":4,"newChild":3,"obj":1,"smallest":2,"root":1},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"lineCount":17,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Yields the contents of the tree in sorted order\n      @return all data items traversed in inorder, with a space after each item\n   */\npublic String toString() {\n    return toString(root);\n}\n","name":"toString","className":"RedBlackTree","variables":{},"javaDoc":"Yields the contents of the tree in sorted order all data items traversed in inorder with a space after each item","comments":"\n      Yields the contents of the tree in sorted order\n      @return all data items traversed in inorder, with a space after each item\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Node"],"returnType":"String","methodCalls":{"toString":2},"constants":{"\"\"":1,"null":1,"\" \"":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Yields the contents of the subtree with the given root in sorted order\n      @param parent the root of the subtree\n      @return all data items traversed in inorder, with a space after each item\n   */\nprivate static String toString(Node parent) {\n    if (parent == null) {\n        return \"\";\n    }\n    return toString(parent.left) + parent.data + \" \" + toString(parent.right);\n}\n","name":"toString","className":"RedBlackTree","variables":{"parent":2},"javaDoc":"Yields the contents of the subtree with the given root in sorted order parent the root of the subtree all data items traversed in inorder with a space after each item","comments":"\n      Yields the contents of the subtree with the given root in sorted order\n      @param parent the root of the subtree\n      @return all data items traversed in inorder, with a space after each item\n   ","isEmpty":false,"lineCount":2,"modifier":10}
{"paramTypes":[],"returnType":"Node","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n         Constructs a red node with no data.\n      */\npublic Node() {\n}\n","name":"Node","className":"Node","variables":{},"javaDoc":"Constructs a red node with no data","comments":"\n         Constructs a red node with no data.\n      ","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Sets the left child and updates its parent reference.\n         @param child the new left child\n      */\npublic void setLeftChild(Node child) {\n    left = child;\n    if (child != null) {\n        child.parent = this;\n    }\n}\n","name":"setLeftChild","className":"Node","variables":{"left":1,"child":3},"javaDoc":"Sets the left child and updates its parent reference child the new left child","comments":"\n         Sets the left child and updates its parent reference.\n         @param child the new left child\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Sets the right child and updates its parent reference.\n         @param child the new right child\n      */\npublic void setRightChild(Node child) {\n    right = child;\n    if (child != null) {\n        child.parent = this;\n    }\n}\n","name":"setRightChild","className":"Node","variables":{"right":1,"child":3},"javaDoc":"Sets the right child and updates its parent reference child the new right child","comments":"\n         Sets the right child and updates its parent reference.\n         @param child the new right child\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"constants":{"null":2},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","ThisExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n            left.parent = this;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n            right.parent = this;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":3,"right":3},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Node","Node"],"returnType":"void","methodCalls":{"toBeReplaced.parent.setLeftChild":1,"toBeReplaced.parent.setRightChild":1},"constants":{"null":2},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Updates the parent's and replacement node's links when this node is replaced.\n      Also updates the root reference if it is replaced.\n      @param toBeReplaced the node that is to be replaced\n      @param replacement the node that replaces that node\n   */\nprivate void replaceWith(Node toBeReplaced, Node replacement) {\n    if (toBeReplaced.parent == null) {\n        replacement.parent = null;\n        root = replacement;\n    } else if (toBeReplaced == toBeReplaced.parent.left) {\n        toBeReplaced.parent.setLeftChild(replacement);\n    } else {\n        toBeReplaced.parent.setRightChild(replacement);\n    }\n}\n","name":"replaceWith","className":"RedBlackTree","variables":{"toBeReplaced":2,"root":1,"replacement":2},"javaDoc":"Updates the parent's and replacement node's links when this node is replaced Also updates the root reference if it is replaced toBeReplaced the node that is to be replaced replacement the node that replaces that node","comments":"\n      Updates the parent's and replacement node's links when this node is replaced.\n      Also updates the root reference if it is replaced.\n      @param toBeReplaced the node that is to be replaced\n      @param replacement the node that replaces that node\n   ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"fixDoubleRed":1},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Restores the tree to a red-black tree after a node has been added.\n      @param newNode the node that has been added\n   */\nprivate void fixAfterAdd(Node newNode) {\n    if (newNode.parent == null) {\n        newNode.color = BLACK;\n    } else {\n        newNode.color = RED;\n        if (newNode.parent.color == RED) {\n            fixDoubleRed(newNode);\n        }\n    }\n}\n","name":"fixAfterAdd","className":"RedBlackTree","variables":{"RED":2,"newNode":1,"BLACK":1},"javaDoc":"Restores the tree to a red-black tree after a node has been added newNode the node that has been added","comments":"\n      Restores the tree to a red-black tree after a node has been added.\n      @param newNode the node that has been added\n   ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"bubbleUp":1},"constants":{"null":3},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \t\n     Fixes the tree so that it is a red-black tree after a node has been removed.\n     @param toBeRemoved the node that is to be removed\n   */\nprivate void fixBeforeRemove(Node toBeRemoved) {\n    if (toBeRemoved.color == RED) {\n        return;\n    }\n    if (// It is not a leaf\n    toBeRemoved.left != null || toBeRemoved.right != null) {\n        // Color the child black\n        if (toBeRemoved.left == null) {\n            toBeRemoved.right.color = BLACK;\n        } else {\n            toBeRemoved.left.color = BLACK;\n        }\n    } else {\n        bubbleUp(toBeRemoved.parent);\n    }\n}\n","name":"fixBeforeRemove","className":"RedBlackTree","variables":{"RED":1,"toBeRemoved":1,"BLACK":2},"javaDoc":"Fixes the tree so that it is a red-black tree after a node has been removed toBeRemoved the node that is to be removed","comments":"It is not a leaf Color the child black  \t\n     Fixes the tree so that it is a red-black tree after a node has been removed.\n     @param toBeRemoved the node that is to be removed\n   ","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"bubbleUpFix":2,"bubbleUp":1},"constants":{"null":2},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Move a charge from two children of a parent\n      @param parent a node with two children, or null (in which case nothing is done)\n   */\nprivate void bubbleUp(Node parent) {\n    if (parent == null) {\n        return;\n    }\n    parent.color++;\n    parent.left.color--;\n    parent.right.color--;\n    if (bubbleUpFix(parent.left)) {\n        return;\n    }\n    if (bubbleUpFix(parent.right)) {\n        return;\n    }\n    if (parent.color == DOUBLE_BLACK) {\n        if (parent.parent == null) {\n            parent.color = BLACK;\n        } else {\n            bubbleUp(parent.parent);\n        }\n    }\n}\n","name":"bubbleUp","className":"RedBlackTree","variables":{"parent":2,"DOUBLE_BLACK":1,"BLACK":1},"javaDoc":"Move a charge from two children of a parent parent a node with two children or null (in which case nothing is done)","comments":"\n      Move a charge from two children of a parent\n      @param parent a node with two children, or null (in which case nothing is done)\n   ","isEmpty":false,"lineCount":7,"modifier":2}
{"paramTypes":["Node"],"returnType":"boolean","methodCalls":{"fixNegativeRed":1,"fixDoubleRed":2},"constants":{"null":2,"true":3,"false":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Fixes a negative-red or double-red violation introduced by bubbling up.\n      @param child the child to check for negative-red or double-red violations\n      @return true if the tree was fixed\n   */\nprivate boolean bubbleUpFix(Node child) {\n    if (child.color == NEGATIVE_RED) {\n        fixNegativeRed(child);\n        return true;\n    } else if (child.color == RED) {\n        if (child.left != null && child.left.color == RED) {\n            fixDoubleRed(child.left);\n            return true;\n        }\n        if (child.right != null && child.right.color == RED) {\n            fixDoubleRed(child.right);\n            return true;\n        }\n    }\n    return false;\n}\n","name":"bubbleUpFix","className":"RedBlackTree","variables":{"RED":3,"NEGATIVE_RED":1,"child":1},"javaDoc":"Fixes a negative-red or double-red violation introduced by bubbling up child the child to check for negative-red or double-red violations true if the tree was fixed","comments":"\n      Fixes a negative-red or double-red violation introduced by bubbling up.\n      @param child the child to check for negative-red or double-red violations\n      @return true if the tree was fixed\n   ","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"setLeftChild":3,"fixDoubleRed":1,"setRightChild":3,"replaceWith":1},"constants":{"null":1},"annotations":[],"types":{"Node":3},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Fixes a \"double red\" violation.\n      @param child the child with a red parent\n   */\nprivate void fixDoubleRed(Node child) {\n    Node parent = child.parent;\n    Node grandParent = parent.parent;\n    if (grandParent == null) {\n        parent.color = BLACK;\n        return;\n    }\n    Node n1, n2, n3, t1, t2, t3, t4;\n    if (parent == grandParent.left) {\n        n3 = grandParent;\n        t4 = grandParent.right;\n        if (child == parent.left) {\n            n1 = child;\n            n2 = parent;\n            t1 = child.left;\n            t2 = child.right;\n            t3 = parent.right;\n        } else {\n            n1 = parent;\n            n2 = child;\n            t1 = parent.left;\n            t2 = child.left;\n            t3 = child.right;\n        }\n    } else {\n        n1 = grandParent;\n        t1 = grandParent.left;\n        if (child == parent.left) {\n            n2 = child;\n            n3 = parent;\n            t2 = child.left;\n            t3 = child.right;\n            t4 = parent.right;\n        } else {\n            n2 = parent;\n            n3 = child;\n            t2 = parent.left;\n            t3 = child.left;\n            t4 = child.right;\n        }\n    }\n    replaceWith(grandParent, n2);\n    n1.setLeftChild(t1);\n    n1.setRightChild(t2);\n    n2.setLeftChild(n1);\n    n2.setRightChild(n3);\n    n3.setLeftChild(t3);\n    n3.setRightChild(t4);\n    n2.color = grandParent.color - 1;\n    n1.color = BLACK;\n    n3.color = BLACK;\n    if (n2 == root) {\n        root.color = BLACK;\n    } else if (n2.color == RED && n2.parent.color == RED) {\n        fixDoubleRed(n2);\n    }\n}\n","name":"fixDoubleRed","className":"RedBlackTree","variables":{"t4":4,"parent":6,"n1":6,"n2":8,"n3":6,"grandParent":4,"RED":2,"root":1,"BLACK":4,"t1":4,"t2":5,"child":7,"t3":5},"javaDoc":"Fixes a \"double red\" violation child the child with a red parent","comments":"\n      Fixes a \"double red\" violation.\n      @param child the child with a red parent\n   ","isEmpty":false,"lineCount":16,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"setLeftChild":6,"fixDoubleRed":2,"setRightChild":6,"replaceWith":2},"constants":{"null":2},"annotations":[],"types":{"Node":16},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Fixes a \"negative red\" violation.\n      @param negRed the negative red node\n   */\nprivate void fixNegativeRed(Node negRed) {\n    Node parent = negRed.parent;\n    Node child;\n    if (parent.left == negRed) {\n        Node n1 = negRed.left;\n        Node n2 = negRed;\n        Node n3 = negRed.right;\n        Node n4 = parent;\n        Node t1 = n3.left;\n        Node t2 = n3.right;\n        Node t3 = n4.right;\n        n1.color = RED;\n        n2.color = BLACK;\n        n4.color = BLACK;\n        replaceWith(n4, n3);\n        n3.setLeftChild(n2);\n        n3.setRightChild(n4);\n        n2.setLeftChild(n1);\n        n2.setRightChild(t1);\n        n4.setLeftChild(t2);\n        n4.setRightChild(t3);\n        child = n1;\n    } else // Mirror image\n    {\n        Node n4 = negRed.right;\n        Node n3 = negRed;\n        Node n2 = negRed.left;\n        Node n1 = parent;\n        Node t3 = n2.right;\n        Node t2 = n2.left;\n        Node t1 = n1.left;\n        n4.color = RED;\n        n3.color = BLACK;\n        n1.color = BLACK;\n        replaceWith(n1, n2);\n        n2.setRightChild(n3);\n        n2.setLeftChild(n1);\n        n3.setRightChild(n4);\n        n3.setLeftChild(t3);\n        n1.setRightChild(t2);\n        n1.setLeftChild(t1);\n        child = n4;\n    }\n    if (child.left != null && child.left.color == RED) {\n        fixDoubleRed(child.left);\n    } else if (child.right != null && child.right.color == RED) {\n        fixDoubleRed(child.right);\n    }\n}\n","name":"fixNegativeRed","className":"RedBlackTree","variables":{"RED":4,"parent":3,"n1":5,"n2":6,"negRed":4,"n3":6,"n4":5,"BLACK":4,"t1":2,"t2":2,"child":3,"t3":2},"javaDoc":"Fixes a \"negative red\" violation negRed the negative red node","comments":"Mirror image \n      Fixes a \"negative red\" violation.\n      @param negRed the negative red node\n   ","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"constants":{},"annotations":[],"types":{"Node":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      */\npublic int size() {\n    int sum = 0;\n    for (Node child : children) {\n        sum = sum + child.size();\n    }\n    return 1 + sum;\n}\n","name":"size","className":"Node","variables":{"children":1,"sum":4,"child":2},"javaDoc":"Computes the size of the subtree whose root is this node the number of nodes in the subtree","comments":"\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Tree","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an empty tree.\n   */\npublic Tree() {\n    root = null;\n}\n","name":"Tree","className":"Tree","variables":{"root":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"Tree","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   */\npublic Tree(Object rootData) {\n    root = new Node();\n    root.data = rootData;\n    root.children = new ArrayList<>();\n}\n","name":"Tree","className":"Tree","variables":{"root":1,"rootData":2},"javaDoc":"Constructs a tree with one node and no children rootData the data for the root","comments":"\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Tree"],"returnType":"void","methodCalls":{"root.children.add":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a subtree as the last child of the root.\n   */\npublic void addSubtree(Tree subtree) {\n    root.children.add(subtree.root);\n}\n","name":"addSubtree","className":"Tree","variables":{"subtree":1},"javaDoc":"Adds a subtree as the last child of the root","comments":"\n      Adds a subtree as the last child of the root.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   */\npublic int size() {\n    if (root == null) {\n        return 0;\n    } else {\n        return root.size();\n    }\n}\n","name":"size","className":"Tree","variables":{"root":2},"javaDoc":"Computes the size of this tree the number of nodes in the tree","comments":"\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addSubtree":3,"size":1,"System.out.println":1},"constants":{"\"Anne\"":1,"\"Peter\"":1,"\"Size: \"":1,"\"Savannah\"":1,"\"Zara\"":1},"annotations":[],"types":{"Tree":4},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Tree t1 = new Tree(\"Anne\");\n    Tree t2 = new Tree(\"Peter\");\n    t1.addSubtree(t2);\n    Tree t3 = new Tree(\"Zara\");\n    t1.addSubtree(t3);\n    Tree t4 = new Tree(\"Savannah\");\n    t2.addSubtree(t4);\n    System.out.println(\"Size: \" + t1.size());\n}\n","name":"main","className":"TreeDemo","variables":{"args":1,"t4":1,"t1":4,"t2":2,"t3":1},"javaDoc":"","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"length":2,"generator":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"temp":2},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"constants":{"100":1,"20":1},"annotations":[],"types":{"int[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    HeapSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"HeapSortDemo","variables":{"args":1,"HeapSorter":1,"Arrays":2,"ArrayUtil":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"fixHeap":2,"swap":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","EnclosedExpr","UnaryExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    int n = a.length - 1;\n    for (int i = (n - 1) / 2; i >= 0; i--) {\n        fixHeap(a, i, n);\n    }\n    while (n > 0) {\n        ArrayUtil.swap(a, 0, n);\n        n--;\n        fixHeap(a, 0, n);\n    }\n}\n","name":"sort","className":"HeapSorter","variables":{"ArrayUtil":1},"javaDoc":"Sorts an array using selection sort a the array to sort","comments":"\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{"getLeftChildIndex":1,"getRightChildIndex":1},"constants":{"true":1,"false":2},"annotations":[],"types":{"boolean":1,"int":4},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Ensures the heap property for a subtree, provided its\n      children already fulfill the heap property.\n      @param a the array to sort\n      @param rootIndex the index of the subtree to be fixed\n      @param lastIndex the last valid index of the tree that \n      contains the subtree to be fixed\n   */\nprivate static void fixHeap(int[] a, int rootIndex, int lastIndex) {\n    // Remove root\n    int rootValue = a[rootIndex];\n    // Promote children while they are larger than the root      \n    int index = rootIndex;\n    boolean more = true;\n    while (more) {\n        int childIndex = getLeftChildIndex(index);\n        if (childIndex <= lastIndex) {\n            // Use right child instead if it is larger\n            int rightChildIndex = getRightChildIndex(index);\n            if (rightChildIndex <= lastIndex && a[rightChildIndex] > a[childIndex]) {\n                childIndex = rightChildIndex;\n            }\n            if (a[childIndex] > rootValue) {\n                // Promote child\n                a[index] = a[childIndex];\n                index = childIndex;\n            } else {\n                // Root value is larger than both children\n                more = false;\n            }\n        } else {\n            // No children\n            more = false;\n        }\n    }\n    // Store root value in vacant slot\n    a[index] = rootValue;\n}\n","name":"fixHeap","className":"HeapSorter","variables":{"rootValue":3,"more":4,"rootIndex":3,"index":4,"lastIndex":3,"childIndex":7,"rightChildIndex":4},"javaDoc":"Ensures the heap property for a subtree provided its children already fulfill the heap property a the array to sort rootIndex the index of the subtree to be fixed lastIndex the last valid index of the tree that contains the subtree to be fixed","comments":"Promote children while they are larger than the root Remove root Use right child instead if it is larger Promote child Root value is larger than both children No children Store root value in vacant slot \n      Ensures the heap property for a subtree, provided its\n      children already fulfill the heap property.\n      @param a the array to sort\n      @param rootIndex the index of the subtree to be fixed\n      @param lastIndex the last valid index of the tree that \n      contains the subtree to be fixed\n   ","isEmpty":false,"lineCount":6,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   */\nprivate static int getLeftChildIndex(int index) {\n    return 2 * index + 1;\n}\n","name":"getLeftChildIndex","className":"HeapSorter","variables":{"index":2},"javaDoc":"Returns the index of the left child index the index of a node in this heap the index of the left child of the given node","comments":"\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   ","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   */\nprivate static int getRightChildIndex(int index) {\n    return 2 * index + 2;\n}\n","name":"getRightChildIndex","className":"HeapSorter","variables":{"index":2},"javaDoc":"Returns the index of the right child index the index of a node in this heap the index of the right child of the given node","comments":"\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   ","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"constants":{},"annotations":[],"types":{"Node":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      */\npublic int size() {\n    int sum = 0;\n    for (Node child : children) {\n        sum = sum + child.size();\n    }\n    return 1 + sum;\n}\n","name":"size","className":"Node","variables":{"children":1,"sum":4,"child":2},"javaDoc":"Computes the size of the subtree whose root is this node the number of nodes in the subtree","comments":"\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Tree","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an empty tree.\n   */\npublic Tree() {\n    root = null;\n}\n","name":"Tree","className":"Tree","variables":{"root":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"Tree","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   */\npublic Tree(Object rootData) {\n    root = new Node();\n    root.data = rootData;\n    root.children = new LinkedList<>();\n}\n","name":"Tree","className":"Tree","variables":{"root":1,"rootData":2},"javaDoc":"Constructs a tree with one node and no children rootData the data for the root","comments":"\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Tree"],"returnType":"void","methodCalls":{"root.children.add":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a subtree as the last child of the root.\n   */\npublic void addSubtree(Tree subtree) {\n    root.children.add(subtree.root);\n}\n","name":"addSubtree","className":"Tree","variables":{"subtree":1},"javaDoc":"Adds a subtree as the last child of the root","comments":"\n      Adds a subtree as the last child of the root.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   */\npublic int size() {\n    if (root == null) {\n        return 0;\n    } else {\n        return root.size();\n    }\n}\n","name":"size","className":"Tree","variables":{"root":2},"javaDoc":"Computes the size of this tree the number of nodes in the tree","comments":"\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n         This method is called for each visited node.\n         @param data the data of the node\n      */\nvoid visit(Object data);\n","name":"visit","className":"Visitor","variables":{"data":1},"javaDoc":"This method is called for each visited node data the data of the node","comments":"\n         This method is called for each visited node.\n         @param data the data of the node\n      ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Visitor"],"returnType":"void","methodCalls":{"preorder":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Traverses this tree in preorder.\n      @param v the visitor to be invoked at each node\n   */\npublic void preorder(Visitor v) {\n    preorder(root, v);\n}\n","name":"preorder","className":"Tree","variables":{},"javaDoc":"Traverses this tree in preorder v the visitor to be invoked at each node","comments":"\n      Traverses this tree in preorder.\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Node","Visitor"],"returnType":"void","methodCalls":{"visit":1,"preorder":1},"constants":{"null":1},"annotations":[],"types":{"Node":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Traverses the tree with a given root in preorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   */\nprivate static void preorder(Node n, Visitor v) {\n    if (n == null) {\n        return;\n    }\n    v.visit(n.data);\n    for (Node c : n.children) {\n        preorder(c, v);\n    }\n}\n","name":"preorder","className":"Tree","variables":{},"javaDoc":"Traverses the tree with a given root in preorder n the root of the tree v the visitor to be invoked at each node","comments":"\n      Traverses the tree with a given root in preorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["Visitor"],"returnType":"void","methodCalls":{"postorder":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Traverses this tree in postorder.\n      @param v the visitor to be invoked at each node\n   */\npublic void postorder(Visitor v) {\n    postorder(root, v);\n}\n","name":"postorder","className":"Tree","variables":{},"javaDoc":"Traverses this tree in postorder v the visitor to be invoked at each node","comments":"\n      Traverses this tree in postorder.\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Node","Visitor"],"returnType":"void","methodCalls":{"visit":1,"postorder":1},"constants":{"null":1},"annotations":[],"types":{"Node":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Traverses the tree with a given root in postorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   */\nprivate static void postorder(Node n, Visitor v) {\n    if (n == null) {\n        return;\n    }\n    for (Node c : n.children) {\n        postorder(c, v);\n    }\n    v.visit(n.data);\n}\n","name":"postorder","className":"Tree","variables":{},"javaDoc":"Traverses the tree with a given root in postorder n the root of the tree v the visitor to be invoked at each node","comments":"\n      Traverses the tree with a given root in postorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["Node"],"returnType":"BreadthFirstIterator","methodCalls":{"add":1},"constants":{"null":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NullLiteralExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Constructs an iterator for a given tree.\n         @param root the root of the tree\n      */\npublic BreadthFirstIterator(Node root) {\n    q = new LinkedList<>();\n    if (root != null) {\n        q.add(root);\n    }\n}\n","name":"BreadthFirstIterator","className":"BreadthFirstIterator","variables":{"root":2},"javaDoc":"Constructs an iterator for a given tree root the root of the tree","comments":"\n         Constructs an iterator for a given tree.\n         @param root the root of the tree\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"size":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public boolean hasNext() {\n    return q.size() > 0;\n}\n","name":"hasNext","className":"BreadthFirstIterator","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"add":1,"remove":1},"constants":{},"annotations":[],"types":{"Node":2},"expressions":["VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Object next() {\n    Node n = q.remove();\n    for (Node c : n.children) {\n        q.add(c);\n    }\n    return n.data;\n}\n","name":"next","className":"BreadthFirstIterator","variables":{},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr"],"statements":["ThrowStmt"],"concepts":[],"exceptions":[],"text":"public void remove() {\n    throw new UnsupportedOperationException();\n}\n","name":"remove","className":"BreadthFirstIterator","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public Iterator iterator() {\n    return new BreadthFirstIterator(root);\n}\n","name":"iterator","className":"Tree","variables":{"root":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"length":1,"toString":1,"System.out.println":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void visit(Object data) {\n    System.out.println(data);\n    if (data.toString().length() <= 5) {\n        counter++;\n    }\n}\n","name":"visit","className":"ShortNameCounter","variables":{"data":2,"counter":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"addSubtree":3,"iterator":1,"length":2,"toString":2,"hasNext":1,"preorder":1,"System.out.println":4},"constants":{"\"Anne\"":1,"\"Peter\"":1,"\"Short names: \"":2,"\"Savannah\"":1,"\"Zara\"":1},"annotations":[],"types":{"Iterator":1,"Tree":4,"ShortNameCounter":1,"Object":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","TypeDeclarationStmt","BlockStmt","ExpressionStmt"],"concepts":["InnerMethod","InnerClass"],"exceptions":[],"text":"public static void main(String[] args) {\n    Tree t1 = new Tree(\"Anne\");\n    Tree t2 = new Tree(\"Peter\");\n    t1.addSubtree(t2);\n    Tree t3 = new Tree(\"Zara\");\n    t1.addSubtree(t3);\n    Tree t4 = new Tree(\"Savannah\");\n    t2.addSubtree(t4);\n    // Count short names with visitor\n    class ShortNameCounter implements Tree.Visitor {\n\n        public int counter = 0;\n\n        public void visit(Object data) {\n            System.out.println(data);\n            if (data.toString().length() <= 5) {\n                counter++;\n            }\n        }\n    }\n    ShortNameCounter v = new ShortNameCounter();\n    t1.preorder(v);\n    System.out.println(\"Short names: \" + v.counter);\n    // Count short names with iterator\n    Iterator iter = t1.iterator();\n    int counter = 0;\n    while (iter.hasNext()) {\n        Object data = iter.next();\n        System.out.println(data);\n        if (data.toString().length() <= 5) {\n            counter++;\n        }\n    }\n    System.out.println(\"Short names: \" + counter);\n}\n","name":"main","className":"TraversalDemo","variables":{"args":1,"t4":1,"data":4,"ShortNameCounter":1,"iter":3,"counter":5,"visit":1,"t1":5,"t2":2,"t3":1},"javaDoc":"","comments":"Count short names with visitor Count short names with iterator ","isEmpty":false,"lineCount":15,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":2},"constants":{"\"Sum: \"":1,"10":1},"annotations":[],"types":{"int[]":1,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] values = new int[10];\n    for (int i = 0; i < values.length; i++) {\n        values[i] = i * i;\n    }\n    // In this loop, we don't need the index value. \n    // The enhanced for loop simplifies the code.\n    int total = 0;\n    for (int element : values) {\n        System.out.println(element);\n        total = total + element;\n    }\n    System.out.println(\"Sum: \" + total);\n}\n","name":"main","className":"EnhancedForLoopDemo","variables":{"args":1,"total":4,"values":3,"element":2},"javaDoc":"","comments":"In this loop we need the index value so we can't use an enhanced for loop In this loop we don't need the index value The enhanced for loop simplifies the code ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":1,"System.out.println":1},"constants":{"11":1,"13":1,"21":1},"annotations":[],"types":{"int[]":1,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] values = { 9, 13, 21, 4, 11, 7, 1, 3 };\n    int i = 0;\n    int j = values.length / 2;\n    while (i < values.length / 2) {\n        // Swap values at positions i and j\n        int temp = values[i];\n        values[i] = values[j];\n        values[j] = temp;\n        i++;\n        j++;\n    }\n    System.out.println(Arrays.toString(values));\n}\n","name":"main","className":"SwapHalves","variables":{"args":1,"temp":2,"values":5,"Arrays":1},"javaDoc":"","comments":"Swap values at positions i and j ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":3,"System.out.println":1},"constants":{"\"Kazakhstan\"":1,"\"%15s\"":1,"\"%8d\"":1,"\"Germany\"":1,"\"United States\"":1,"\"        Country    Gold  Silver  Bronze   Total\"":1,"\"Italy\"":1,"\"South Korea\"":1,"\"Canada\"":1,"\"%8d\\n\"":1,"\"Japan\"":1,"\"Russia\"":1},"annotations":[],"types":{"int[][]":1,"String[]":1,"int":5},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","ArrayAccessExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int COUNTRIES = 8;\n    final int MEDALS = 3;\n    String[] countries = { \"Canada\", \"Italy\", \"Germany\", \"Japan\", \"Kazakhstan\", \"Russia\", \"South Korea\", \"United States\" };\n    int[][] counts = { { 0, 3, 0 }, { 0, 0, 1 }, { 0, 0, 1 }, { 1, 0, 0 }, { 0, 0, 1 }, { 3, 1, 1 }, { 0, 1, 0 }, { 1, 0, 1 } };\n    System.out.println(\"        Country    Gold  Silver  Bronze   Total\");\n    // Print countries, counts, and row totals\n    for (int i = 0; i < COUNTRIES; i++) {\n        // Process the ith row\n        System.out.printf(\"%15s\", countries[i]);\n        int total = 0;\n        // Print each row element and update the row total\n        for (int j = 0; j < MEDALS; j++) {\n            System.out.printf(\"%8d\", counts[i][j]);\n            total = total + counts[i][j];\n        }\n        // Display the row total and print a new line\n        System.out.printf(\"%8d\\n\", total);\n    }\n}\n","name":"main","className":"Medals","variables":{"args":1,"total":3,"COUNTRIES":2,"counts":3,"countries":2,"MEDALS":2},"javaDoc":"","comments":"Print countries counts and row totals Process the ith row Print each row element and update the row total Display the row total and print a new line ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"hasNextDouble":1,"nextDouble":1,"System.out.print":2,"System.out.println":2},"constants":{"\"Please enter values, Q to quit:\"":1,"\" <== largest value\"":1,"100":1},"annotations":[],"types":{"Scanner":1,"double[]":1,"double":1,"int":4},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int LENGTH = 100;\n    double[] values = new double[LENGTH];\n    int currentSize = 0;\n    // Read inputs\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble() && currentSize < values.length) {\n        values[currentSize] = in.nextDouble();\n        currentSize++;\n    }\n    // Find the largest value\n    double largest = values[0];\n    for (int i = 1; i < currentSize; i++) {\n        if (values[i] > largest) {\n            largest = values[i];\n        }\n    }\n    for (int i = 0; i < currentSize; i++) {\n        System.out.print(values[i]);\n        if (values[i] == largest) {\n            System.out.print(\" <== largest value\");\n        }\n        System.out.println();\n    }\n}\n","name":"main","className":"LargestInArray","variables":{"args":1,"largest":4,"in":3,"LENGTH":2,"values":7,"currentSize":6},"javaDoc":"","comments":"Read inputs Find the largest value Print all values marking the largest ","isEmpty":false,"lineCount":12,"modifier":9}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   */\npublic Student(int capacity) {\n    scores = new double[capacity];\n    scoresSize = 0;\n}\n","name":"Student","className":"Student","variables":{"scoresSize":1,"scores":1,"capacity":2},"javaDoc":"Constructs a student with no scores and a maximum number of scores @capacity the maximum number of scores for this student","comments":"\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"boolean","methodCalls":{},"constants":{"true":1,"false":1},"annotations":[],"types":{},"expressions":["ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   */\npublic boolean addScore(double score) {\n    if (scoresSize < scores.length) {\n        scores[scoresSize] = score;\n        scoresSize++;\n        return true;\n    } else {\n        return false;\n    }\n}\n","name":"addScore","className":"Student","variables":{"scoresSize":3,"score":2,"scores":1},"javaDoc":"Adds a score for this student score the score to add true if the score was added false if there was no room to add the score","comments":"\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   */\npublic double sum() {\n    double total = 0;\n    for (int i = 0; i < scoresSize; i++) {\n        total = total + scores[i];\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"scoresSize":1,"total":4,"scores":1},"javaDoc":"Computes the sum of the scores of this student the sum of the scores","comments":"\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   */\npublic double minimum() {\n    if (scoresSize == 0) {\n        return 0;\n    }\n    double smallest = scores[0];\n    for (int i = 1; i < scoresSize; i++) {\n        if (scores[i] < smallest) {\n            smallest = scores[i];\n        }\n    }\n    return smallest;\n}\n","name":"minimum","className":"Student","variables":{"scoresSize":2,"scores":3,"smallest":4},"javaDoc":"Gets the minimum score of this student the minimum score or 0 if there are no scores","comments":"\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sum":1,"minimum":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped.\n   */\npublic double finalScore() {\n    if (scoresSize == 0) {\n        return 0;\n    } else {\n        return sum() - minimum();\n    }\n}\n","name":"finalScore","className":"Student","variables":{"scoresSize":1},"javaDoc":"Gets the final score for this student the sum of the scores with the lowest score dropped","comments":"\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"finalScore":1,"addScore":1,"hasNextDouble":1,"nextDouble":1,"System.out.println":3},"constants":{"\"Please enter values, Q to quit:\"":1,"100":1,"\"Too many scores.\"":1,"\"Final score: \"":1},"annotations":[],"types":{"Scanner":1,"Student":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    Student fred = new Student(100);\n    System.out.println(\"Please enter values, Q to quit:\");\n    while (in.hasNextDouble()) {\n        if (!fred.addScore(in.nextDouble())) {\n            System.out.println(\"Too many scores.\");\n            return;\n        }\n    }\n    System.out.println(\"Final score: \" + fred.finalScore());\n}\n","name":"main","className":"ScoreAnalyzer","variables":{"args":1,"in":3,"fred":3},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int"],"returnType":"Dice","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Dice(int sides) {\n    // counters[0] is not used\n    counters = new int[sides + 1];\n}\n","name":"Dice","className":"Dice","variables":{"counters":1,"sides":2},"javaDoc":"","comments":"counters[0] is not used ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"hasNextInt":1,"nextInt":1,"System.out.println":2},"constants":{"\"Please enter values, Q to quit:\"":1,"\" is not a valid input.\"":1},"annotations":[],"types":{"Scanner":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void countInputs() {\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextInt()) {\n        int value = in.nextInt();\n        if (1 <= value && value <= counters.length) {\n            counters[value]++;\n        } else {\n            System.out.println(value + \" is not a valid input.\");\n        }\n    }\n}\n","name":"countInputs","className":"Dice","variables":{"counters":1,"in":3,"value":5},"javaDoc":"","comments":"Increment the counter for the input value ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":1},"constants":{"\"%2d: %4d\\n\"":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void printCounters() {\n    for (int i = 1; i < counters.length; i++) {\n        System.out.printf(\"%2d: %4d\\n\", i, counters[i]);\n    }\n}\n","name":"printCounters","className":"Dice","variables":{"counters":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"countInputs":1,"printCounters":1},"constants":{},"annotations":[],"types":{"Dice":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int SIDES = 6;\n    Dice dice = new Dice(SIDES);\n    dice.countInputs();\n    dice.printCounters();\n}\n","name":"main","className":"DiceAnalyzer","variables":{"args":1,"dice":3,"SIDES":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":3,"System.out.print":1,"System.out.println":3},"constants":{"809":2,"46":1,"24":1,"26":1,"\"Africa\"":1,"5268":1,"172":1,"392":1,"111":1,"133":1,"276":1,"511":1,"635":1,"\"Asia\"":1,"3634":1,"30":1,"74":1,"\"North America\"":1,"\"%5d\"":2,"13":1,"\"                Year 1750 1800 1850 1900 1950 2000 2050\"":1,"16":1,"38":1,"\"Europe\"":1,"163":1,"\"               World\"":1,"221":1,"1766":1,"1402":1,"167":1,"203":1,"\"%20s\"":1,"106":1,"502":1,"107":1,"767":1,"547":1,"82":1,"307":1,"947":1,"408":1,"628":1,"\"Australia\"":1,"729":1,"\"South America\"":1},"annotations":[],"types":{"int[][]":1,"String[]":1,"int":7},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","ArrayAccessExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int ROWS = 6;\n    final int COLUMNS = 7;\n    int[][] populations = { { 106, 107, 111, 133, 221, 767, 1766 }, { 502, 635, 809, 947, 1402, 3634, 5268 }, { 2, 2, 2, 6, 13, 30, 46 }, { 163, 203, 276, 408, 547, 729, 628 }, { 2, 7, 26, 82, 172, 307, 392 }, { 16, 24, 38, 74, 167, 511, 809 } };\n    String[] continents = { \"Africa\", \"Asia\", \"Australia\", \"Europe\", \"North America\", \"South America\" };\n    System.out.println(\"                Year 1750 1800 1850 1900 1950 2000 2050\");\n    for (int i = 0; i < ROWS; i++) {\n        // Print the ith row\n        System.out.printf(\"%20s\", continents[i]);\n        for (int j = 0; j < COLUMNS; j++) {\n            System.out.printf(\"%5d\", populations[i][j]);\n        }\n        // Start a new line at the end of the row\n        System.out.println();\n    }\n    // Print column totals\n    System.out.print(\"               World\");\n    for (int j = 0; j < COLUMNS; j++) {\n        int total = 0;\n        for (int i = 0; i < ROWS; i++) {\n            total = total + populations[i][j];\n        }\n        System.out.printf(\"%5d\", total);\n    }\n    System.out.println();\n}\n","name":"main","className":"WorldPopulation","variables":{"args":1,"total":3,"COLUMNS":3,"populations":3,"continents":2,"ROWS":3},"javaDoc":"","comments":"Print population data Print column totals Print the ith row Start a new line at the end of the row ","isEmpty":false,"lineCount":11,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":4,"System.out.println":6},"constants":{"\"You entered the following scores:\"":1,"\"Fred\"":1,"100":1,"\"Enter scores, -1 to quit: \"":1,"\"Cindy\"":1,"\" \"":4,"false":1,"true":1,"\"Amy\"":1,"42":1,"\"Henry\"":1},"annotations":[],"types":{"Scanner":1,"boolean":1,"int[]":3,"String[]":1,"int":8},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","AssignExpr","ArrayInitializerExpr","BooleanLiteralExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    // An array of five values, initialized in a loop\n    int[] values = new int[5];\n    for (int i = 0; i < values.length; i++) {\n        values[i] = 2 * i;\n    }\n    // An array of four strings, with initial values specified\n    String[] names = { \"Fred\", \"Amy\", \"Cindy\", \"Henry\" };\n    for (int i = 0; i < values.length; i++) {\n        System.out.print(values[i] + \" \");\n    }\n    System.out.println();\n    for (int i = 0; i < names.length; i++) {\n        System.out.print(names[i] + \" \");\n    }\n    System.out.println();\n    // When you copy an array variable, you get another reference \n    // to the same array. (See Section 7.1.2.)\n    int[] copy = values;\n    values[0] = 42;\n    for (int i = 0; i < copy.length; i++) {\n        System.out.print(copy[i] + \" \");\n    }\n    System.out.println();\n    // Here, we read numbers into a partially filled array.\n    // (See Section 7.1.4.)\n    System.out.println(\"Enter scores, -1 to quit: \");\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    int currentSize = 0;\n    final int LENGTH = 100;\n    int[] scores = new int[LENGTH];\n    while (!done && currentSize < LENGTH) {\n        int score = in.nextInt();\n        if (score == -1) {\n            done = true;\n        } else {\n            scores[currentSize] = score;\n            currentSize++;\n        }\n    }\n    System.out.println(\"You entered the following scores:\");\n    for (int i = 0; i < currentSize; i++) {\n        System.out.print(scores[i] + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"ArrayDemo","variables":{"args":1,"score":3,"names":2,"in":2,"scores":3,"values":5,"LENGTH":3,"copy":2,"done":3,"currentSize":5},"javaDoc":"","comments":"An array of five values initialized in a loop An array of four strings with initial values specified These loops print the elements in both arrays When you copy an array variable you get another reference to the same array (See Section 7 1 2 ) We change values[0] which is the same as copy[0] Here we read numbers into a partially filled array (See Section 7 1 4 ) ","isEmpty":false,"lineCount":29,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pick":1,"show":2,"getSampleValues":1},"constants":{},"annotations":[],"types":{"int[]":1,"SoundClip":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    SoundClip clip = new SoundClip();\n    clip.pick();\n    clip.show();\n    int[] samples = clip.getSampleValues();\n    for (int i = 0; i < samples.length; i++) {\n        samples[i] = 3 * samples[i];\n    }\n    clip.show();\n}\n","name":"main","className":"SoundClipDemo","variables":{"args":1,"clip":5,"samples":3},"javaDoc":"","comments":"In this example we don't need the sample rate If you do call clip getSampleRate(); ","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":[],"returnType":"int[]","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int[] getSampleValues() {\n    return samples;\n}\n","name":"getSampleValues","className":"SoundClip","variables":{"samples":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getSampleRate() {\n    return sampleRate;\n}\n","name":"getSampleRate","className":"SoundClip","variables":{"sampleRate":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showOpenDialog":1,"load":1,"getSelectedFile":1},"constants":{"null":1,"\".\"":1},"annotations":[],"types":{"JFileChooser":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Displays a file chooser for picking a clip.\n   */\npublic void pick() {\n    JFileChooser chooser = new JFileChooser(\".\");\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        load(chooser.getSelectedFile());\n    }\n}\n","name":"pick","className":"SoundClip","variables":{"chooser":3},"javaDoc":"Displays a file chooser for picking a clip","comments":"\n      Displays a file chooser for picking a clip.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":1},"constants":{"null":1,"true":1},"annotations":[],"types":{"JFrame":1,"SoundClipFrame":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Shows a frame with the sample values and a Play button\n   */\npublic void show() {\n    if (samples != null) {\n        JFrame frame = new SoundClipFrame();\n        frame.setVisible(true);\n    }\n}\n","name":"show","className":"SoundClip","variables":{"samples":1,"frame":2},"javaDoc":"Shows a frame with the sample values and a Play button","comments":"\n      Shows a frame with the sample values and a Play button\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["File"],"returnType":"void","methodCalls":{"getSignedInt2":1,"read":1,"getUnsignedInt2":4,"getMessage":1,"getUnsignedInt4":1,"error":5},"constants":{"22":1,"34":1,"24":1,"16":1,"\"Not an uncompressed sound file.\"":1,"\"Not a 16 bit sound file.\"":1,"40":1,"\"Premature end of file\"":1,"\"Not a mono sound file.\"":1,"20":1},"annotations":[],"types":{"InputStream":1,"FileInputStream":1,"int":7},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","CastExpr","UnaryExpr","ArrayCreationExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","TryStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["Exception"],"text":"/**\n      Loads a picture from a given source. \n      @param source the image source.\n      @return true if the file was loaded successfully\n   */\nprivate void load(File source) {\n    try {\n        InputStream in = new FileInputStream(source);\n        for (int i = 0; i < HEADER_SIZE; i++) {\n            int b = in.read();\n            if (b == -1) {\n                error(\"Premature end of file\");\n            }\n            header[i] = (byte) b;\n        }\n        int formatType = getUnsignedInt2(20);\n        if (formatType != 1) {\n            error(\"Not an uncompressed sound file.\");\n        }\n        int numChannels = getUnsignedInt2(22);\n        if (numChannels != 1) {\n            error(\"Not a mono sound file.\");\n        }\n        sampleRate = getUnsignedInt2(24);\n        int bitsPerSample = getUnsignedInt2(34);\n        if (bitsPerSample != 16) {\n            error(\"Not a 16 bit sound file.\");\n        }\n        // Read data size and allocate data array\n        // 2 bytes per data\n        int dataSize = getUnsignedInt4(40) / 2;\n        samples = new int[dataSize];\n        // Read sound data\n        for (int i = 0; i < dataSize; i++) {\n            samples[i] = getSignedInt2(in);\n        }\n    } catch (Exception ex) {\n        error(ex.getMessage());\n    }\n}\n","name":"load","className":"SoundClip","variables":{"numChannels":2,"bitsPerSample":2,"ex":2,"in":2,"HEADER_SIZE":1,"header":1,"dataSize":3,"source":2,"formatType":2,"sampleRate":1,"samples":2},"javaDoc":"Loads a picture from a given source source the image source true if the file was loaded successfully","comments":"Read data size and allocate data array 2 bytes per data Read sound data \n      Loads a picture from a given source. \n      @param source the image source.\n      @return true if the file was loaded successfully\n   ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"showMessageDialog":1},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void error(String message) {\n    JOptionPane.showMessageDialog(null, message);\n}\n","name":"error","className":"SoundClip","variables":{"message":1,"JOptionPane":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"constants":{"256":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets a byte from the header as an unsigned value.\n      @param offset the offset from the start of the header\n      @return the integer\n   */\nprivate int getUnsignedInt1(int offset) {\n    int result = header[offset];\n    if (result >= 0) {\n        return result;\n    } else {\n        return result + 256;\n    }\n}\n","name":"getUnsignedInt1","className":"SoundClip","variables":{"result":4,"offset":2,"header":1},"javaDoc":"Gets a byte from the header as an unsigned value offset the offset from the start of the header the integer","comments":"\n      Gets a byte from the header as an unsigned value.\n      @param offset the offset from the start of the header\n      @return the integer\n   ","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"getUnsignedInt1":1},"constants":{"256":1},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets an unsigned 4-byte integer from the header\n      @param offset the offset from the start of the header\n      @return the integer \n   */\nprivate int getUnsignedInt4(int offset) {\n    int result = 0;\n    int base = 1;\n    for (int i = 0; i < 4; i++) {\n        result = result + getUnsignedInt1(offset + i) * base;\n        base = base * 256;\n    }\n    return result;\n}\n","name":"getUnsignedInt4","className":"SoundClip","variables":{"result":4,"offset":2,"base":4},"javaDoc":"Gets an unsigned 4-byte integer from the header offset the offset from the start of the header the integer","comments":"\n      Gets an unsigned 4-byte integer from the header\n      @param offset the offset from the start of the header\n      @return the integer \n   ","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"getUnsignedInt1":2},"constants":{"256":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets an unsigned 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   */\nprivate int getUnsignedInt2(int offset) {\n    return getUnsignedInt1(offset) + 256 * getUnsignedInt1(offset + 1);\n}\n","name":"getUnsignedInt2","className":"SoundClip","variables":{"offset":2},"javaDoc":"Gets an unsigned 2-byte integer from a random access file in the file the integer","comments":"\n      Gets an unsigned 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["InputStream"],"returnType":"int","methodCalls":{"read":2},"constants":{"256":1,"65536":1,"32768":1},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"/**\n      Gets a signed 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   */\nprivate static int getSignedInt2(InputStream in) throws IOException {\n    int lo = in.read();\n    int hi = in.read();\n    int result = lo + 256 * hi;\n    if (result >= 32768) {\n        result = result - 65536;\n    }\n    return result;\n}\n","name":"getSignedInt2","className":"SoundClip","variables":{"result":5,"hi":2,"lo":2,"in":3},"javaDoc":"Gets a signed 2-byte integer from a random access file in the file the integer","comments":"\n      Gets a signed 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   ","isEmpty":false,"lineCount":5,"modifier":10}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"constants":{},"annotations":["Override"],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"@Override\npublic void windowClosing(WindowEvent event) {\n    frames--;\n    if (frames == 0)\n        System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"frames":2,"event":1,"System":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getHeight":1,"min":1,"max":1,"getWidth":1,"drawLine":1},"constants":{"32767":1},"annotations":[],"types":{"int":7},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public void paintComponent(Graphics graph) {\n    int increment = samples.length / getWidth();\n    final int LARGEST = 32767;\n    int x = 0;\n    for (int i = 0; i < samples.length; i = i + increment) {\n        int value = samples[i];\n        value = Math.min(LARGEST, value);\n        value = Math.max(-LARGEST, value);\n        int height = getHeight() / 2;\n        int y = height - samples[i] * height / LARGEST;\n        graph.drawLine(x, y, x, height);\n        x++;\n    }\n}\n","name":"paintComponent","className":"","variables":{"LARGEST":3,"increment":2,"Math":2,"value":3,"graph":2,"samples":2,"height":3},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"play":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    play();\n}\n","name":"actionPerformed","className":"","variables":{"event":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"SoundClipFrame","methodCalls":{"add":3,"play":1,"addWindowListener":1,"exit":1,"getHeight":1,"min":1,"max":1,"addActionListener":1,"getWidth":1,"drawLine":1,"copyOf":1,"setBounds":1},"constants":{"100":1,"200":1,"\"Play\"":1,"800":1,"32767":1},"annotations":[],"types":{"JPanel":1,"JComponent":1,"JButton":1,"int":10},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","MarkerAnnotationExpr","UnaryExpr","AssignExpr","FieldAccessExpr","ThisExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["InnerMethod","FinalVariables"],"exceptions":[],"text":"public SoundClipFrame() {\n    frames++;\n    offsets++;\n    samples = Arrays.copyOf(SoundClip.this.samples, SoundClip.this.samples.length);\n    addWindowListener(new WindowAdapter() {\n\n        @Override\n        public void windowClosing(WindowEvent event) {\n            frames--;\n            if (frames == 0)\n                System.exit(0);\n        }\n    });\n    final int FRAME_WIDTH = 800;\n    final int FRAME_HEIGHT = 200;\n    final int OFFSET_WIDTH = 100;\n    setBounds(offsets * OFFSET_WIDTH, offsets * OFFSET_WIDTH, FRAME_WIDTH, FRAME_HEIGHT);\n    JComponent component = new JComponent() {\n\n        public void paintComponent(Graphics graph) {\n            int increment = samples.length / getWidth();\n            final int LARGEST = 32767;\n            int x = 0;\n            for (int i = 0; i < samples.length; i = i + increment) {\n                int value = samples[i];\n                value = Math.min(LARGEST, value);\n                value = Math.max(-LARGEST, value);\n                int height = getHeight() / 2;\n                int y = height - samples[i] * height / LARGEST;\n                graph.drawLine(x, y, x, height);\n                x++;\n            }\n        }\n    };\n    add(component);\n    JPanel panel = new JPanel();\n    JButton button = new JButton(\"Play\");\n    button.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent event) {\n            play();\n        }\n    });\n    panel.add(button);\n    add(panel, BorderLayout.SOUTH);\n}\n","name":"SoundClipFrame","className":"SoundClipFrame","variables":{"frames":3,"FRAME_HEIGHT":1,"paintComponent":1,"increment":2,"Math":2,"samples":3,"System":1,"graph":2,"button":2,"actionPerformed":1,"component":1,"FRAME_WIDTH":1,"offsets":3,"windowClosing":1,"LARGEST":3,"Arrays":1,"event":2,"panel":2,"Override":1,"value":3,"SoundClip":2,"OFFSET_WIDTH":3,"height":3},"javaDoc":"","isEmpty":false,"lineCount":15,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getAudioInputStream":1,"getClip":1,"start":1,"getMessage":1,"error":1,"open":1},"constants":{"256":2,"65536":1},"annotations":[],"types":{"byte[]":1,"Clip":1,"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","CastExpr","FieldAccessExpr","EnclosedExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"private void play() {\n    byte[] out = new byte[HEADER_SIZE + 2 * samples.length];\n    for (int i = 0; i < HEADER_SIZE; i++) {\n        out[i] = header[i];\n    }\n    for (int i = 0; i < samples.length; i++) {\n        int value = samples[i];\n        if (value < 0) {\n            value = value + 65536;\n        }\n        out[HEADER_SIZE + 2 * i] = (byte) (value % 256);\n        out[HEADER_SIZE + 2 * i + 1] = (byte) (value / 256);\n    }\n    try {\n        Clip clip = AudioSystem.getClip();\n        clip.open(AudioSystem.getAudioInputStream(new ByteArrayInputStream(out)));\n        clip.start();\n    } catch (Exception ex) {\n        error(ex.getMessage());\n    }\n}\n","name":"play","className":"SoundClipFrame","variables":{"ex":2,"AudioSystem":2,"HEADER_SIZE":4,"header":1,"value":6,"samples":1,"clip":3,"out":5},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":[],"returnType":"Student","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Student() {\n    scores = new ArrayList<Double>();\n}\n","name":"Student","className":"Student","variables":{"scores":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"add":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n   */\npublic void addScore(double score) {\n    scores.add(score);\n}\n","name":"addScore","className":"Student","variables":{"score":1,"scores":1},"javaDoc":"Adds a score for this student score the score to add","comments":"\n      Adds a score for this student.\n      @param score the score to add\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":2,"get":2},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   */\npublic int minimumPosition() {\n    if (scores.size() == 0) {\n        return -1;\n    }\n    int smallestPosition = 0;\n    for (int i = 1; i < scores.size(); i++) {\n        if (scores.get(i) < scores.get(smallestPosition)) {\n            smallestPosition = i;\n        }\n    }\n    return smallestPosition;\n}\n","name":"minimumPosition","className":"Student","variables":{"smallestPosition":3,"scores":4},"javaDoc":"Gets the position of the minimum score the position of the smallest element of values or -1 if there are no scores","comments":"\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the sum of the scores\n      @return the total score\n   */\npublic double sum() {\n    double total = 0;\n    for (double score : scores) {\n        total = total + score;\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"score":2,"total":4,"scores":1},"javaDoc":"Computes the sum of the scores the total score","comments":"\n      Computes the sum of the scores\n      @return the total score\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"remove":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   */\npublic void removeScore(int pos) {\n    scores.remove(pos);\n/*\n        Alternatively, for a more efficient implementation,\n        follow Section 7.3.6:\n        int lastPosition = scores.size() - 1;\n        scores.set(pos, scores.get(lastPosition));\n        scores.remove(lastPosition);\n      */\n}\n","name":"removeScore","className":"Student","variables":{"pos":1,"scores":1},"javaDoc":"Removes a score at a given position pos the position of the score to remove","comments":"Alternatively for a more efficient implementation follow Section 7 3 6: int lastPosition = scores size() - 1; scores set(pos scores get(lastPosition)); scores remove(lastPosition); \n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"size":1,"get":3,"hasNextDouble":1,"nextDouble":1,"System.out.print":2,"System.out.println":2},"constants":{"\"Please enter values, Q to quit:\"":1,"\" <== largest value\"":1},"annotations":[],"types":{"Scanner":1,"double":2,"ArrayList<Double>":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForeachStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    ArrayList<Double> values = new ArrayList<Double>();\n    // Read inputs\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble()) {\n        values.add(in.nextDouble());\n    }\n    // Find the largest value\n    double largest = values.get(0);\n    for (int i = 1; i < values.size(); i++) {\n        if (values.get(i) > largest) {\n            largest = values.get(i);\n        }\n    }\n    for (double element : values) {\n        System.out.print(element);\n        if (element == largest) {\n            System.out.print(\" <== largest value\");\n        }\n        System.out.println();\n    }\n}\n","name":"main","className":"LargestInArrayList","variables":{"args":1,"largest":4,"in":3,"values":7,"element":2},"javaDoc":"","comments":"Read inputs Find the largest value Print all values marking the largest ","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addScore":1,"minimumPosition":1,"sum":1,"hasNextDouble":1,"nextDouble":1,"removeScore":1,"System.out.println":3},"constants":{"\"Please enter values, Q to quit:\"":1,"\"At least one score is required.\"":1,"\"Final score: \"":1},"annotations":[],"types":{"Scanner":1,"double":1,"Student":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Student fred = new Student();\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble()) {\n        fred.addScore(in.nextDouble());\n    }\n    int pos = fred.minimumPosition();\n    if (pos == -1) {\n        System.out.println(\"At least one score is required.\");\n    } else {\n        fred.removeScore(pos);\n        double total = fred.sum();\n        System.out.println(\"Final score: \" + total);\n    }\n}\n","name":"main","className":"ScoreAnalyzer","variables":{"args":1,"total":2,"in":3,"pos":2,"fred":5},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   */\npublic Student(int capacity) {\n    scores = new double[capacity];\n    scoresSize = 0;\n}\n","name":"Student","className":"Student","variables":{"scoresSize":1,"scores":1,"capacity":2},"javaDoc":"Constructs a student with no scores and a maximum number of scores @capacity the maximum number of scores for this student","comments":"\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"boolean","methodCalls":{},"constants":{"true":1,"false":1},"annotations":[],"types":{},"expressions":["ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   */\npublic boolean addScore(double score) {\n    if (scoresSize < scores.length) {\n        scores[scoresSize] = score;\n        scoresSize++;\n        return true;\n    } else {\n        return false;\n    }\n}\n","name":"addScore","className":"Student","variables":{"scoresSize":3,"score":2,"scores":1},"javaDoc":"Adds a score for this student score the score to add true if the score was added false if there was no room to add the score","comments":"\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   */\npublic double sum() {\n    double total = 0;\n    for (int i = 0; i < scoresSize; i++) {\n        total = total + scores[i];\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"scoresSize":1,"total":4,"scores":1},"javaDoc":"Computes the sum of the scores of this student the sum of the scores","comments":"\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   */\npublic double minimum() {\n    if (scoresSize == 0) {\n        return 0;\n    }\n    double smallest = scores[0];\n    for (int i = 1; i < scoresSize; i++) {\n        if (scores[i] < smallest) {\n            smallest = scores[i];\n        }\n    }\n    return smallest;\n}\n","name":"minimum","className":"Student","variables":{"scoresSize":2,"scores":3,"smallest":4},"javaDoc":"Gets the minimum score of this student the minimum score or 0 if there are no scores","comments":"\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sum":1,"minimum":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped if \n      there are at least two scores, or 0 if there are no scores.\n   */\npublic double finalScore() {\n    if (scoresSize == 0) {\n        return 0;\n    } else if (scoresSize == 1) {\n        return scores[0];\n    } else {\n        return sum() - minimum();\n    }\n}\n","name":"finalScore","className":"Student","variables":{"scoresSize":2,"scores":1},"javaDoc":"Gets the final score for this student the sum of the scores with the lowest score dropped if there are at least two scores or 0 if there are no scores","comments":"\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped if \n      there are at least two scores, or 0 if there are no scores.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"finalScore":1,"addScore":1,"hasNextDouble":1,"nextDouble":2,"System.out.println":3},"constants":{"100":1,"\"Too many scores.\"":1,"\"Final score: \"":1,"\"Expected: \"":1},"annotations":[],"types":{"Scanner":1,"double":1,"Student":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    double expected = in.nextDouble();\n    Student fred = new Student(100);\n    while (in.hasNextDouble()) {\n        if (!fred.addScore(in.nextDouble())) {\n            System.out.println(\"Too many scores.\");\n            return;\n        }\n    }\n    System.out.println(\"Final score: \" + fred.finalScore());\n    System.out.println(\"Expected: \" + expected);\n}\n","name":"main","className":"ScoreTester","variables":{"args":1,"in":4,"expected":2,"fred":3},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"finalScore":1,"addScore":3,"System.out.println":2},"constants":{"100":1,"\"Expected: 30\"":1,"\"Final score: \"":1,"20":1,"10":1},"annotations":[],"types":{"Student":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Student fred = new Student(100);\n    fred.addScore(10);\n    fred.addScore(20);\n    fred.addScore(5);\n    System.out.println(\"Final score: \" + fred.finalScore());\n    System.out.println(\"Expected: 30\");\n}\n","name":"main","className":"ScoreTester1","variables":{"args":1,"fred":5},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   */\npublic Student(int capacity) {\n    scores = new double[capacity];\n    scoresSize = 0;\n}\n","name":"Student","className":"Student","variables":{"scoresSize":1,"scores":1,"capacity":2},"javaDoc":"Constructs a student with no scores and a maximum number of scores @capacity the maximum number of scores for this student","comments":"\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"boolean","methodCalls":{},"constants":{"true":1,"false":1},"annotations":[],"types":{},"expressions":["ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   */\npublic boolean addScore(double score) {\n    if (scoresSize < scores.length) {\n        scores[scoresSize] = score;\n        scoresSize++;\n        return true;\n    } else {\n        return false;\n    }\n}\n","name":"addScore","className":"Student","variables":{"scoresSize":3,"score":2,"scores":1},"javaDoc":"Adds a score for this student score the score to add true if the score was added false if there was no room to add the score","comments":"\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   */\npublic int minimumPosition() {\n    if (scoresSize == 0) {\n        return -1;\n    }\n    int smallestPosition = 0;\n    for (int i = 1; i < scoresSize; i++) {\n        if (scores[i] < scores[smallestPosition]) {\n            smallestPosition = i;\n        }\n    }\n    return smallestPosition;\n}\n","name":"minimumPosition","className":"Student","variables":{"scoresSize":2,"smallestPosition":4,"scores":2},"javaDoc":"Gets the position of the minimum score the position of the smallest element of values or -1 if there are no scores","comments":"\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the sum of the scores\n      @return the total score\n   */\npublic double sum() {\n    double total = 0;\n    for (int i = 0; i < scoresSize; i++) {\n        total = total + scores[i];\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"scoresSize":1,"total":4,"scores":1},"javaDoc":"Computes the sum of the scores the total score","comments":"\n      Computes the sum of the scores\n      @return the total score\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   */\npublic void removeScore(int pos) {\n    // Remove the element at this position--see Section 7.3.6\n    scores[pos] = scores[scoresSize - 1];\n    scoresSize--;\n}\n","name":"removeScore","className":"Student","variables":{"scoresSize":2,"pos":2,"scores":2},"javaDoc":"Removes a score at a given position pos the position of the score to remove","comments":"Remove the element at this position--see Section 7 3 6 \n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addScore":1,"minimumPosition":1,"sum":1,"hasNextDouble":1,"nextDouble":1,"removeScore":1,"System.out.println":4},"constants":{"\"Please enter values, Q to quit:\"":1,"100":1,"\"Too many scores.\"":1,"\"At least one score is required.\"":1,"\"Final score: \"":1},"annotations":[],"types":{"Scanner":1,"double":1,"Student":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Student fred = new Student(100);\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble()) {\n        if (!fred.addScore(in.nextDouble())) {\n            System.out.println(\"Too many scores.\");\n            return;\n        }\n    }\n    int pos = fred.minimumPosition();\n    if (pos == -1) {\n        System.out.println(\"At least one score is required.\");\n    } else {\n        fred.removeScore(pos);\n        double total = fred.sum();\n        System.out.println(\"Final score: \" + total);\n    }\n}\n","name":"main","className":"ScoreAnalyzer","variables":{"args":1,"total":2,"in":3,"pos":2,"fred":5},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextDouble":2,"System.out.println":1},"constants":{"\"Estimate for pi: \"":1,"4.0":1,"10000":1},"annotations":[],"types":{"Random":1,"double":4,"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int TRIES = 10000;\n    Random generator = new Random();\n    int hits = 0;\n    for (int i = 1; i <= TRIES; i++) {\n        // Generate two random numbers between -1 and 1\n        double r = generator.nextDouble();\n        double x = -1 + 2 * r;\n        r = generator.nextDouble();\n        double y = -1 + 2 * r;\n        if (x * x + y * y <= 1) {\n            hits++;\n        }\n    }\n    /*\n         The ratio hits / tries is approximately the same as the ratio \n         circle area / square area = pi / 4\n      */\n    double piEstimate = 4.0 * hits / TRIES;\n    System.out.println(\"Estimate for pi: \" + piEstimate);\n}\n","name":"main","className":"MonteCarlo","variables":{"args":1,"hits":3,"generator":3,"piEstimate":2,"TRIES":3},"javaDoc":"","comments":"The ratio hits / tries is approximately the same as the ratio circle area / square area = pi / 4 Generate two random numbers between -1 and 1 Check whether the point lies in the unit circle ","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"countSyllables":1,"endsWith":1,"System.out.println":2},"constants":{"\"Syllables in \"":1,"\".\"":1,"\"Enter a sentence ending in a period.\"":1,"\": \"":1},"annotations":[],"types":{"Scanner":1,"Word":1,"String":1,"int":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ExpressionStmt","DoStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.println(\"Enter a sentence ending in a period.\");\n    String input;\n    do {\n        input = in.next();\n        Word w = new Word(input);\n        int syllables = w.countSyllables();\n        System.out.println(\"Syllables in \" + input + \": \" + syllables);\n    } while (!input.endsWith(\".\"));\n}\n","name":"main","className":"SyllableCounter","variables":{"args":1,"input":5,"in":2,"syllables":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String"],"returnType":"Word","methodCalls":{"length":2,"isLetter":2,"charAt":2,"substring":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a word by removing leading and trailing non-\n      letter characters, such as punctuation marks.\n      @param s the input string\n   */\npublic Word(String s) {\n    int i = 0;\n    while (i < s.length() && !Character.isLetter(s.charAt(i))) {\n        i++;\n    }\n    int j = s.length() - 1;\n    while (j > i && !Character.isLetter(s.charAt(j))) {\n        j--;\n    }\n    text = s.substring(i, j);\n}\n","name":"Word","className":"Word","variables":{"Character":2,"text":1},"javaDoc":"Constructs a word by removing leading and trailing non- letter characters such as punctuation marks s the input string","comments":"\n      Constructs a word by removing leading and trailing non-\n      letter characters, such as punctuation marks.\n      @param s the input string\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the text of the word, after removal of the\n      leading and trailing non-letter characters.\n      @return the text of the word\n   */\npublic String getText() {\n    return text;\n}\n","name":"getText","className":"Word","variables":{"text":1},"javaDoc":"Returns the text of the word after removal of the leading and trailing non-letter characters the text of the word","comments":"\n      Returns the text of the word, after removal of the\n      leading and trailing non-letter characters.\n      @return the text of the word\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"length":1,"indexOf":1,"charAt":2},"constants":{"false":1,"true":1,"'e'":1,"'E'":1,"\"aeiouyAEIOUY\"":1},"annotations":[],"types":{"boolean":1,"char":1,"String":1,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","CharLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Counts the syllables in the word.\n      @return the syllable count\n   */\npublic int countSyllables() {\n    int count = 0;\n    int end = text.length() - 1;\n    // The empty string has no syllables\n    if (end < 0) {\n        return 0;\n    }\n    // An e at the end of the word doesn't count as a vowel\n    char ch = text.charAt(end);\n    if (ch == 'e' || ch == 'E') {\n        end--;\n    }\n    boolean insideVowelGroup = false;\n    for (int i = 0; i <= end; i++) {\n        ch = text.charAt(i);\n        String vowels = \"aeiouyAEIOUY\";\n        if (vowels.indexOf(ch) >= 0) {\n            // ch is a vowel\n            if (!insideVowelGroup) {\n                // Start of new vowel group\n                count++;\n                insideVowelGroup = true;\n            }\n        }\n    }\n    // Every word has at least one syllable\n    if (count == 0) {\n        count = 1;\n    }\n    return count;\n}\n","name":"countSyllables","className":"Word","variables":{"vowels":2,"ch":4,"count":5,"end":4,"insideVowelGroup":3,"text":3},"javaDoc":"Counts the syllables in the word the syllable count","comments":"The empty string has no syllables An e at the end of the word doesn't count as a vowel ch is a vowel Start of new vowel group Every word has at least one syllable \n      Counts the syllables in the word.\n      @return the syllable count\n   ","isEmpty":false,"lineCount":9,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":1,"nextDouble":1,"System.out.println":2},"constants":{"\"Average salary: \"":1,"\"Enter salaries, -1 to finish: \"":1,"\"No data\"":1},"annotations":[],"types":{"Scanner":1,"double":3,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    double sum = 0;\n    int count = 0;\n    double salary = 0;\n    System.out.print(\"Enter salaries, -1 to finish: \");\n    Scanner in = new Scanner(System.in);\n    while (salary != -1) {\n        salary = in.nextDouble();\n        if (salary != -1) {\n            sum = sum + salary;\n            count++;\n        }\n    }\n    if (count > 0) {\n        double average = sum / count;\n        System.out.println(\"Average salary: \" + average);\n    } else {\n        System.out.println(\"No data\");\n    }\n}\n","name":"main","className":"SentinelDemo","variables":{"args":1,"average":2,"in":2,"count":4,"sum":4,"salary":5},"javaDoc":"","comments":"Process data until the sentinel is entered Compute and print the average ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"cast":1,"System.out.print":1,"System.out.println":1},"constants":{"\" \"":1,"10":1},"annotations":[],"types":{"Die":1,"int":3},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    Die d = new Die(6);\n    final int TRIES = 10;\n    for (int i = 1; i <= TRIES; i++) {\n        int n = d.cast();\n        System.out.print(n + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"DieSimulator","variables":{"args":1,"TRIES":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int"],"returnType":"Die","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a die with a given number of sides.\n      @param s the number of sides, e.g. 6 for a normal die\n   */\npublic Die(int s) {\n    sides = s;\n    generator = new Random();\n}\n","name":"Die","className":"Die","variables":{"sides":1,"generator":1},"javaDoc":"Constructs a die with a given number of sides s the number of sides e g 6 for a normal die","comments":"\n      Constructs a die with a given number of sides.\n      @param s the number of sides, e.g. 6 for a normal die\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Simulates a throw of the die\n      @return the face of the die \n   */\npublic int cast() {\n    return 1 + generator.nextInt(sides);\n}\n","name":"cast","className":"Die","variables":{"generator":1},"javaDoc":"Simulates a throw of the die the face of the die","comments":"\n      Simulates a throw of the die\n      @return the face of the die \n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"waitYears":1,"System.out.printf":1},"constants":{"\"The balance after %d years is %.2f\\n\"":1,"10000":1,"20":1},"annotations":[],"types":{"double":3,"int":1,"Investment":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final double INITIAL_BALANCE = 10000;\n    final double RATE = 5;\n    final int YEARS = 20;\n    Investment invest = new Investment(INITIAL_BALANCE, RATE);\n    invest.waitYears(YEARS);\n    double balance = invest.getBalance();\n    System.out.printf(\"The balance after %d years is %.2f\\n\", YEARS, balance);\n}\n","name":"main","className":"InvestmentRunner","variables":{"args":1,"YEARS":1,"balance":1,"RATE":2,"invest":3,"INITIAL_BALANCE":2},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["double","double"],"returnType":"Investment","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   */\npublic Investment(double aBalance, double aRate) {\n    balance = aBalance;\n    rate = aRate;\n    year = 0;\n}\n","name":"Investment","className":"Investment","variables":{"balance":1,"rate":1,"year":1,"aBalance":2,"aRate":2},"javaDoc":"Constructs an Investment object from a starting balance and interest rate aBalance the starting balance aRate the interest rate in percent","comments":"\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{"100":1},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   */\npublic void waitForBalance(double targetBalance) {\n    while (balance < targetBalance) {\n        year++;\n        double interest = balance * rate / 100;\n        balance = balance + interest;\n    }\n}\n","name":"waitForBalance","className":"Investment","variables":{"targetBalance":2,"balance":4,"year":1,"interest":2,"rate":1},"javaDoc":"Keeps accumulating interest until a target balance has been reached targetBalance the desired balance","comments":"\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{"100":1},"annotations":[],"types":{"double":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Keeps accumulating interest for a given number of years.\n      @param numberOfYears the number of years to wait\n   */\npublic void waitYears(int numberOfYears) {\n    for (int i = 1; i <= numberOfYears; i++) {\n        double interest = balance * rate / 100;\n        balance = balance + interest;\n    }\n    year = year + numberOfYears;\n}\n","name":"waitYears","className":"Investment","variables":{"balance":3,"interest":2,"rate":1,"year":2,"numberOfYears":3},"javaDoc":"Keeps accumulating interest for a given number of years numberOfYears the number of years to wait","comments":"\n      Keeps accumulating interest for a given number of years.\n      @param numberOfYears the number of years to wait\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current investment balance.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"Investment","variables":{"balance":1},"javaDoc":"Gets the current investment balance the current balance","comments":"\n      Gets the current investment balance.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   */\npublic int getYears() {\n    return year;\n}\n","name":"getYears","className":"Investment","variables":{"year":1},"javaDoc":"Gets the number of years this investment has accumulated interest the number of years since the start of the investment","comments":"\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":1,"charAt":1,"substring":2,"System.out.println":1},"constants":{"'-'":1,"\"4123-5678-9012-3450\"":1,"' '":1},"annotations":[],"types":{"char":1,"String":3,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","CharLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String creditCardNumber = \"4123-5678-9012-3450\";\n    int i = 0;\n    while (i < creditCardNumber.length()) {\n        char ch = creditCardNumber.charAt(i);\n        if (ch == ' ' || ch == '-') {\n            // Remove the character at position i\n            String before = creditCardNumber.substring(0, i);\n            String after = creditCardNumber.substring(i + 1);\n            creditCardNumber = before + after;\n        } else {\n            i++;\n        }\n    }\n    System.out.println(creditCardNumber);\n}\n","name":"main","className":"CCNumber","variables":{"args":1,"ch":3,"before":2,"creditCardNumber":6,"after":2},"javaDoc":"","comments":"Remove the character at position i ","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getHeight":1,"getRed":1,"getGreen":1,"setColorAt":1,"load":1,"getColorAt":1,"getWidth":1,"getBlue":1},"constants":{"255":3,"\"queen-mary.png\"":1},"annotations":[],"types":{"Picture":1,"Color":2,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Picture pic = new Picture();\n    pic.load(\"queen-mary.png\");\n    for (int x = 0; x < pic.getWidth(); x++) {\n        for (int y = 0; y < pic.getHeight(); y++) {\n            Color original = pic.getColorAt(x, y);\n            Color negative = new Color(255 - original.getRed(), 255 - original.getGreen(), 255 - original.getBlue());\n            pic.setColorAt(x, y, negative);\n        }\n    }\n}\n","name":"main","className":"Negative","variables":{"args":1,"negative":1,"original":4,"pic":6},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"Picture","methodCalls":{"add":1,"setVisible":1,"setDefaultCloseOperation":1,"pack":1},"constants":{"\"(No image)\"":1,"true":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a picture with no image.\n   */\npublic Picture() {\n    frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    label = new JLabel(\"(No image)\");\n    frame.add(label);\n    frame.pack();\n    frame.setVisible(true);\n}\n","name":"Picture","className":"Picture","variables":{"label":1,"frame":5},"javaDoc":"Constructs a picture with no image","comments":"\n      Constructs a picture with no image.\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Picture","methodCalls":{"setIcon":1,"add":1,"setVisible":1,"setDefaultCloseOperation":1,"pack":1},"constants":{"\"\"":1,"true":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a picture with a given width and height.\n      @param width the desired width\n      @param height the desired height\n   */\npublic Picture(int width, int height) {\n    frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    label = new JLabel(\"\");\n    image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n    label.setIcon(new ImageIcon(image));\n    frame.add(label);\n    frame.pack();\n    frame.setVisible(true);\n}\n","name":"Picture","className":"Picture","variables":{"image":2,"width":2,"label":2,"height":2,"frame":5},"javaDoc":"Constructs a picture with a given width and height width the desired width height the desired height","comments":"\n      Constructs a picture with a given width and height.\n      @param width the desired width\n      @param height the desired height\n   ","isEmpty":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getWidth":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the width of this picture.\n      @return the width\n   */\npublic int getWidth() {\n    return image.getWidth();\n}\n","name":"getWidth","className":"Picture","variables":{"image":1},"javaDoc":"Gets the width of this picture the width","comments":"\n      Gets the width of this picture.\n      @return the width\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getHeight":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the height of this picture.\n      @return the height\n   */\npublic int getHeight() {\n    return image.getHeight();\n}\n","name":"getHeight","className":"Picture","variables":{"image":1},"javaDoc":"Gets the height of this picture the height","comments":"\n      Gets the height of this picture.\n      @return the height\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"read":2,"printStackTrace":1,"startsWith":1,"setImage":1},"constants":{"null":1,"\"http://\"":1},"annotations":[],"types":{"BufferedImage":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"/**\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n   */\npublic void load(String source) {\n    try {\n        this.source = source;\n        BufferedImage img;\n        if (source.startsWith(\"http://\"))\n            img = ImageIO.read(new URL(source).openStream());\n        else\n            img = ImageIO.read(new File(source));\n        setImage(img);\n    } catch (Exception ex) {\n        this.source = null;\n        ex.printStackTrace();\n    }\n}\n","name":"load","className":"Picture","variables":{"img":3,"ex":2,"source":5,"ImageIO":2},"javaDoc":"Loads a picture from a given source source the image source If the source starts with http:// it is a URL otherwise a filename","comments":"\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"load":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Reloads this picture, undoing any manipulations.\n   */\npublic void reload() {\n    load(source);\n}\n","name":"reload","className":"Picture","variables":{},"javaDoc":"Reloads this picture undoing any manipulations","comments":"\n      Reloads this picture, undoing any manipulations.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showOpenDialog":1,"load":1,"getSelectedFile":1,"getAbsolutePath":1},"constants":{"null":1,"\".\"":1},"annotations":[],"types":{"JFileChooser":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Displays a file chooser for picking a picture.\n   */\npublic void pick() {\n    JFileChooser chooser = new JFileChooser(\".\");\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        load(chooser.getSelectedFile().getAbsolutePath());\n    }\n}\n","name":"pick","className":"Picture","variables":{"chooser":3},"javaDoc":"Displays a file chooser for picking a picture","comments":"\n      Displays a file chooser for picking a picture.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["BufferedImage"],"returnType":"void","methodCalls":{"setIcon":1,"pack":1,"setText":1},"constants":{"\" \"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void setImage(BufferedImage image) {\n    this.image = image;\n    label.setIcon(new ImageIcon(image));\n    label.setText(\" \");\n    frame.pack();\n}\n","name":"setImage","className":"Picture","variables":{"image":3,"label":2,"frame":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":["int","int"],"returnType":"Color","methodCalls":{"getColorModel":1,"getDataElements":1,"getRaster":1,"getRGB":1},"constants":{"null":1,"true":1},"annotations":[],"types":{"ColorModel":1,"Raster":1,"int":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   */\npublic Color getColorAt(int x, int y) {\n    Raster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    int argb = model.getRGB(raster.getDataElements(x, y, null));\n    return new Color(argb, true);\n}\n","name":"getColorAt","className":"Picture","variables":{"image":2,"argb":2,"raster":2,"model":2},"javaDoc":"Gets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) the color of the pixel at position (x y)","comments":"\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int","Color"],"returnType":"void","methodCalls":{"getColorModel":1,"getDataElements":1,"setDataElements":1,"repaint":1,"getRaster":1,"getRGB":1},"constants":{"null":1},"annotations":[],"types":{"WritableRaster":1,"ColorModel":1,"Object":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   */\npublic void setColorAt(int x, int y, Color c) {\n    WritableRaster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    Object colorData = model.getDataElements(c.getRGB(), null);\n    raster.setDataElements(x, y, colorData);\n    label.repaint();\n}\n","name":"setColorAt","className":"Picture","variables":{"image":2,"colorData":1,"raster":2,"model":2,"label":1},"javaDoc":"Sets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) c the color for the pixel at position (x y)","comments":"\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getYears":1,"waitForBalance":1,"System.out.println":1},"constants":{"10000":1,"\" years\"":1,"\"The investment doubled after \"":1},"annotations":[],"types":{"double":2,"int":1,"Investment":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final double INITIAL_BALANCE = 10000;\n    final double RATE = 5;\n    Investment invest = new Investment(INITIAL_BALANCE, RATE);\n    invest.waitForBalance(2 * INITIAL_BALANCE);\n    int years = invest.getYears();\n    System.out.println(\"The investment doubled after \" + years + \" years\");\n}\n","name":"main","className":"InvestmentRunner","variables":{"args":1,"RATE":2,"invest":3,"INITIAL_BALANCE":3,"years":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["double","double"],"returnType":"Investment","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   */\npublic Investment(double aBalance, double aRate) {\n    balance = aBalance;\n    rate = aRate;\n    year = 0;\n}\n","name":"Investment","className":"Investment","variables":{"balance":1,"rate":1,"year":1,"aBalance":2,"aRate":2},"javaDoc":"Constructs an Investment object from a starting balance and interest rate aBalance the starting balance aRate the interest rate in percent","comments":"\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{"100":1},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   */\npublic void waitForBalance(double targetBalance) {\n    while (balance < targetBalance) {\n        year++;\n        double interest = balance * rate / 100;\n        balance = balance + interest;\n    }\n}\n","name":"waitForBalance","className":"Investment","variables":{"targetBalance":2,"balance":4,"year":1,"interest":2,"rate":1},"javaDoc":"Keeps accumulating interest until a target balance has been reached targetBalance the desired balance","comments":"\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current investment balance.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"Investment","variables":{"balance":1},"javaDoc":"Gets the current investment balance the current balance","comments":"\n      Gets the current investment balance.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   */\npublic int getYears() {\n    return year;\n}\n","name":"getYears","className":"Investment","variables":{"year":1},"javaDoc":"Gets the number of years this investment has accumulated interest the number of years since the start of the investment","comments":"\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":2,"System.out.print":2,"System.out.println":6},"constants":{"\"Enter input, 0 to quit: \"":1,"\"First negative: \"":1,"1.0":1,"false":2,"true":3,"\"Sum: \"":1,"\"Minimum: \"":1,"\"Negative values: \"":1,"\"Enter input: \"":1,"\"Maximum: \"":1,"\"Average: \"":1},"annotations":[],"types":{"Scanner":1,"boolean":2,"int":7},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter input: \");\n    int input = in.nextInt();\n    // The largest input\n    int min = input;\n    // The smallest input\n    int max = input;\n    // The number of inputs\n    int count = 1;\n    // The sum of the inputs\n    int sum = input;\n    // Set to true if we found at least one negative input\n    boolean foundNegative = false;\n    // The count of negative inputs\n    int negatives;\n    // The position of the first negative input\n    int firstNegative = 0;\n    if (input < 0) {\n        foundNegative = true;\n        firstNegative = 1;\n        negatives = 1;\n    } else {\n        negatives = 0;\n    }\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"Enter input, 0 to quit: \");\n        input = in.nextInt();\n        if (// Zero is the sentinel value\n        input == 0) {\n            done = true;\n        } else {\n            // Computing sum and average\n            sum = sum + input;\n            count++;\n            if (// Determining minimum and maximum\n            input < min) {\n                min = input;\n            } else if (input > max) {\n                max = input;\n            }\n            if (// Counting matches\n            input < 0) {\n                negatives++;\n                if (// Finding first match\n                !foundNegative) {\n                    foundNegative = true;\n                    firstNegative = count;\n                }\n            }\n        }\n    }\n    System.out.println(\"Minimum: \" + min);\n    System.out.println(\"Maximum: \" + max);\n    System.out.println(\"Sum: \" + sum);\n    System.out.println(\"Average: \" + sum * 1.0 / count);\n    System.out.println(\"Negative values: \" + negatives);\n    if (foundNegative) {\n        System.out.println(\"First negative: \" + firstNegative);\n    }\n}\n","name":"main","className":"LoopAlgorithms","variables":{"args":1,"input":13,"min":4,"negatives":5,"in":3,"max":4,"count":4,"sum":5,"foundNegative":5,"done":3,"firstNegative":4},"javaDoc":"","comments":"The largest input The smallest input The number of inputs The sum of the inputs Set to true if we found at least one negative input The count of negative inputs The position of the first negative input Zero is the sentinel value Computing sum and average Determining minimum and maximum Counting matches Finding first match ","isEmpty":false,"lineCount":19,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":3,"pow":1,"System.out.println":3},"constants":{"\"%10s\"":1,"\"%10d\"":1,"\"%10.0f\"":1,"\"x \"":1,"10":1},"annotations":[],"types":{"double":2,"int":4},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int NMAX = 4;\n    final double XMAX = 10;\n    for (int n = 1; n <= NMAX; n++) {\n        System.out.printf(\"%10d\", n);\n    }\n    System.out.println();\n    for (int n = 1; n <= NMAX; n++) {\n        System.out.printf(\"%10s\", \"x \");\n    }\n    System.out.println();\n    for (double x = 1; x <= XMAX; x++) {\n        for (int n = 1; n <= NMAX; n++) {\n            System.out.printf(\"%10.0f\", Math.pow(x, n));\n        }\n        System.out.println();\n    }\n}\n","name":"main","className":"PowerTable","variables":{"args":1,"NMAX":4,"XMAX":2,"Math":1},"javaDoc":"","comments":"Print table header Print table body Print table row ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sqrt":1,"System.out.print":1,"nextDouble":1,"System.out.println":1},"constants":{"\"The square root of the number is \"":1,"\"Enter a number >= 0: \"":1},"annotations":[],"types":{"Scanner":1,"double":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ExpressionStmt","DoStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    double value;\n    do {\n        System.out.print(\"Enter a number >= 0: \");\n        value = in.nextDouble();\n    } while (value < 0);\n    double root = Math.sqrt(value);\n    System.out.println(\"The square root of the number is \" + root);\n}\n","name":"main","className":"DoLoop","variables":{"args":1,"in":2,"root":2,"Math":1,"value":3},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"nextInt":1,"System.out.print":1,"findMax":1,"countNegative":1,"computePositiveSum":1},"constants":{"100":1,"\"The total number of negative numbers is \"":1,"\"The maximum number is \"":1,"\"\\n\"":2,"\"The sum of the positive numbers is \"":1},"annotations":[],"types":{"Scanner":1,"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // TODO Auto-generated method stub\n    int[] numbers = new int[100];\n    int totalNum = 0;\n    while (totalNum < numbers.length) {\n        Scanner console = new Scanner(System.in);\n        numbers[totalNum] = console.nextInt();\n        if (numbers[totalNum] != 0) {\n            totalNum++;\n        } else {\n            System.out.print(\"The maximum number is \" + findMax(numbers, totalNum) + \"\\n\" + \"The sum of the positive numbers is \" + computePositiveSum(numbers, totalNum) + \"\\n\" + \"The total number of negative numbers is \" + countNegative(numbers, totalNum));\n            System.exit(0);\n        }\n    }\n/*\n\t\tfor(int i=0;i<numbers.length;i++){\n\t\t\tScanner console = new Scanner(System.in);\n\t\t\tnumbers[i] = console.nextInt();\n\t\t\t\n\t\t\tif (numbers[i] != 0){\t\t\t\t\n\t\t\t\ttotalNum++;\t\t\t\n\t\t\t}else{\n\t\t\t\tSystem.out.print(\"The maximum number is \"+findMax(numbers,totalNum)+\"\\n\"+\n\t\t\t\t\t\t\"The sum of the positive numbers is \"+computePositiveSum(numbers,totalNum)+\"\\n\"+\n\t\t\t\t\t\t\"The total number of negative numbers is \"+ countNegative(numbers,totalNum));\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t*/\n}\n","name":"main","className":"Assignment2","variables":{"args":1,"console":2,"totalNum":5,"numbers":3,"System":1},"javaDoc":"","comments":"TODO Auto-generated method stub for(int i=0;i<numbers length;i++){ Scanner console = new Scanner(System in); numbers[i] = console nextInt(); if (numbers[i] != 0){ totalNum++; }else{ System out print(\"The maximum number is \"+findMax(numbers totalNum)+\"\\n\"+ \"The sum of the positive numbers is \"+computePositiveSum(numbers totalNum)+\"\\n\"+ \"The total number of negative numbers is \"+ countNegative(numbers totalNum)); System exit(0); } } ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static int findMax(int[] numbers, int i) {\n    int max = 0;\n    for (int n : numbers) {\n        if (n > max)\n            max = n;\n    }\n    return max;\n}\n","name":"findMax","className":"Assignment2","variables":{"max":4,"numbers":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static int computePositiveSum(int[] numbers, int i) {\n    int pos = 0;\n    for (int n : numbers) {\n        if (n > 0)\n            pos += n;\n    }\n    return pos;\n}\n","name":"computePositiveSum","className":"Assignment2","variables":{"pos":3,"numbers":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static int countNegative(int[] numbers, int i) {\n    int count = 0;\n    for (int n : numbers) {\n        if (n < 0) {\n            count++;\n        }\n    }\n    return count;\n}\n","name":"countNegative","className":"Assignment2","variables":{"numbers":2,"count":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String"],"returnType":"Flight","methodCalls":{"setFlightNum":1,"setDeparture":1,"split":3,"setAirlines":1,"setArrival":1},"constants":{"\"?\"":8,"\"/\"":1,"\",\"":2},"annotations":[],"types":{"Flight":1,"String":12,"String[]":3,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static Flight parseStringToFlight(String lineToParse) {\n    String airlines = new String(\"?\");\n    String flightNum = new String(\"?\");\n    String temp3 = new String();\n    String temp4 = new String();\n    String row = new String();\n    String column = new String();\n    String city1 = new String(\"?\");\n    String city2 = new String(\"?\");\n    String time1 = new String(\"?\");\n    String time2 = new String(\"?\");\n    String date1 = new String(\"?\");\n    String date2 = new String(\"?\");\n    int rowNum = 1;\n    int columnNum = 1;\n    String[] tokens = lineToParse.split(\"/\");\n    //get the airlines\n    if (tokens[0].length() > 0) {\n        airlines = tokens[0].trim();\n    }\n    //get the flight number\n    if (tokens[1].length() > 0) {\n        flightNum = tokens[1].trim();\n    }\n    //get the departure information inluding city, time, and date\n    if (tokens[2].length() > 0) {\n        temp3 = tokens[2].trim();\n        String[] tokens2 = temp3.split(\",\");\n        if (tokens2[0].length() > 0)\n            city1 = tokens2[0].trim();\n        if (tokens2[1].length() > 0)\n            time1 = tokens2[1].trim();\n        if (tokens2.length == 3 && tokens2[2].length() > 0)\n            date1 = tokens2[2].trim();\n    }\n    //get the arrival information including city, time, and date\n    if (tokens.length == 4 && tokens[3].length() > 0) {\n        temp4 = tokens[3].trim();\n        String[] tokens3 = temp4.split(\",\");\n        if (tokens3[0].length() > 0)\n            city2 = tokens3[0].trim();\n        if (tokens3[1].length() > 0)\n            time2 = tokens3[1].trim();\n        if (tokens3.length == 3 && tokens3[2].length() > 0)\n            date2 = tokens3[2].trim();\n    }\n    //create a Flight object using extracted information.\n    Flight flight = new Flight();\n    flight.setAirlines(airlines);\n    flight.setFlightNum(flightNum);\n    flight.setDeparture(city1, time1, date1);\n    flight.setArrival(city2, time2, date2);\n    return flight;\n}\n","name":"parseStringToFlight","className":"FlightParser","variables":{"flight":6,"city1":2,"city2":2,"columnNum":1,"lineToParse":2,"column":1,"tokens2":7,"tokens3":7,"date2":2,"date1":2,"temp3":3,"time1":2,"time2":2,"flightNum":2,"temp4":3,"rowNum":1,"airlines":2,"tokens":9,"row":1},"javaDoc":"","comments":"get the airlines get the flight number get the departure information inluding city time and date get the arrival information including city time and date create a Flight object using extracted information ","isEmpty":false,"lineCount":25,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseDouble":1,"showMessageDialog":1,"showInputDialog":1},"constants":{"100":1,"\"Price after tax: \"":1,"null":1,"\"Enter price:\"":1,"8.5":1},"annotations":[],"types":{"double":2,"String":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","EnclosedExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    String input = JOptionPane.showInputDialog(\"Enter price:\");\n    double price = Double.parseDouble(input);\n    final double TAX_RATE = 8.5;\n    price = price * (1 + TAX_RATE / 100);\n    JOptionPane.showMessageDialog(null, \"Price after tax: \" + price);\n}\n","name":"main","className":"OptionPaneDemo","variables":{"args":1,"input":1,"price":4,"TAX_RATE":2,"JOptionPane":2,"Double":1},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"round":1,"System.out.print":4,"System.out.println":4},"constants":{"\"Price per liter: \"":1,"100":2,"\"Cents: \"":1,"2.59":1,"\"Dollars: \"":1,"\"Pennies: \"":1,"0.355":1},"annotations":[],"types":{"double":4,"int":4},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","CastExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting","FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    int cansPerPack = 6;\n    // Liters in a 12-ounce can\n    final double CAN_VOLUME = 0.355;\n    double totalVolume = cansPerPack * CAN_VOLUME;\n    double pricePerPack = 2.59;\n    double pricePerLiter = pricePerPack / totalVolume;\n    System.out.print(\"Price per liter: \");\n    System.out.println(pricePerLiter);\n    // The integer part of the price gives the whole dollars.\n    int dollars = (int) pricePerLiter;\n    System.out.print(\"Dollars: \");\n    System.out.println(dollars);\n    // Multiply by 100 and round to the nearest integer to get the \n    // price in pennies.\n    int pennies = (int) Math.round(pricePerLiter * 100);\n    System.out.print(\"Pennies: \");\n    System.out.println(pennies);\n    // The cents are the last two digits of this value.\n    int cents = pennies % 100;\n    System.out.print(\"Cents: \");\n    System.out.println(cents);\n}\n","name":"main","className":"PriceDemo","variables":{"args":1,"totalVolume":2,"pennies":2,"pricePerPack":2,"cents":1,"dollars":1,"CAN_VOLUME":2,"Math":1,"pricePerLiter":3,"cansPerPack":2},"javaDoc":"","comments":"The integer part of the price gives the whole dollars Multiply by 100 and round to the nearest integer to get the price in pennies The cents are the last two digits of this value Liters in a 12-ounce can ","isEmpty":false,"lineCount":20,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"System.out.print":2,"substring":2,"System.out.println":1},"constants":{"\"Enter your first name: \"":1,"\"Enter your significant other's first name: \"":1,"\"&\"":1},"annotations":[],"types":{"Scanner":1,"String":3},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    // Get the names of the couple\n    System.out.print(\"Enter your first name: \");\n    String first = in.next();\n    System.out.print(\"Enter your significant other's first name: \");\n    String second = in.next();\n    // Compute and display the inscription\n    String initials = first.substring(0, 1) + \"&\" + second.substring(0, 1);\n    System.out.println(initials);\n}\n","name":"main","className":"Initials","variables":{"args":1,"in":3,"initials":1,"first":2,"second":2},"javaDoc":"","comments":"Get the names of the couple Compute and display the inscription ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":2,"System.out.print":2,"nextDouble":2,"System.out.println":2},"constants":{"\"Please enter the price for a two-liter bottle: \"":1,"\"Bottle price per liter: %8.2f\"":1,"\"Pack price per liter:   %8.2f\"":1,"\"Please enter the price for a six-pack: \"":1,"0.355":1},"annotations":[],"types":{"Scanner":1,"double":7},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","EnclosedExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    // Read price per pack\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Please enter the price for a six-pack: \");\n    double packPrice = in.nextDouble();\n    // Read price per bottle\n    System.out.print(\"Please enter the price for a two-liter bottle: \");\n    double bottlePrice = in.nextDouble();\n    final double CANS_PER_PACK = 6;\n    // 12 oz. = 0.355 l \n    final double CAN_VOLUME = 0.355;\n    final double BOTTLE_VOLUME = 2;\n    // Compute and print price per liter\n    double packPricePerLiter = packPrice / (CANS_PER_PACK * CAN_VOLUME);\n    double bottlePricePerLiter = bottlePrice / BOTTLE_VOLUME;\n    System.out.printf(\"Pack price per liter:   %8.2f\", packPricePerLiter);\n    System.out.println();\n    System.out.printf(\"Bottle price per liter: %8.2f\", bottlePricePerLiter);\n    System.out.println();\n}\n","name":"main","className":"Volume","variables":{"args":1,"bottlePricePerLiter":1,"in":3,"bottlePrice":2,"CANS_PER_PACK":2,"packPricePerLiter":1,"CAN_VOLUME":2,"packPrice":2,"BOTTLE_VOLUME":2},"javaDoc":"","comments":"Read price per pack Read price per bottle Compute and print price per liter 12 oz = 0 355 l ","isEmpty":false,"lineCount":17,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":2,"nextInt":2,"System.out.print":2,"System.out.println":2},"constants":{"100":1,"25":1,"\"Quarters:     %6d\"":1,"\"Enter bill value (1 = $1 bill, 5 = $5 bill, etc.): \"":1,"\"Enter item price in pennies: \"":1,"\"Dollar coins: %6d\"":1},"annotations":[],"types":{"Scanner":1,"int":7},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    final int PENNIES_PER_DOLLAR = 100;\n    final int PENNIES_PER_QUARTER = 25;\n    System.out.print(\"Enter bill value (1 = $1 bill, 5 = $5 bill, etc.): \");\n    int billValue = in.nextInt();\n    System.out.print(\"Enter item price in pennies: \");\n    int itemPrice = in.nextInt();\n    // Compute change due\n    int changeDue = PENNIES_PER_DOLLAR * billValue - itemPrice;\n    int dollarCoins = changeDue / PENNIES_PER_DOLLAR;\n    changeDue = changeDue % PENNIES_PER_DOLLAR;\n    int quarters = changeDue / PENNIES_PER_QUARTER;\n    // Print change due\n    System.out.printf(\"Dollar coins: %6d\", dollarCoins);\n    System.out.println();\n    System.out.printf(\"Quarters:     %6d\", quarters);\n    System.out.println();\n}\n","name":"main","className":"VendingMachine","variables":{"args":1,"dollarCoins":1,"in":3,"PENNIES_PER_DOLLAR":4,"quarters":1,"billValue":2,"changeDue":5,"itemPrice":2,"PENNIES_PER_QUARTER":2},"javaDoc":"","comments":"Compute change due Print change due ","isEmpty":false,"lineCount":17,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getVolume":2,"getSurfaceArea":1,"System.out.println":6},"constants":{"146":1,"\"Expected: 224\"":1,"\"Expected: 333.33\"":1,"\"Expected: 2500000\"":1,"10":2,"230":1},"annotations":[],"types":{"Pyramid":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Pyramid sample = new Pyramid(10, 10);\n    System.out.println(sample.getVolume());\n    System.out.println(\"Expected: 333.33\");\n    System.out.println(sample.getSurfaceArea());\n    System.out.println(\"Expected: 224\");\n    Pyramid gizeh = new Pyramid(146, 230);\n    System.out.println(gizeh.getVolume());\n    /* \n         The following estimate is from \n         http://en.wikipedia.org/wiki/Great_Pyramid_of_Giza, citing\n         Levy, Janey (2005). The Great Pyramid of Giza: \n         Measuring Length, Area, Volume, and Angles. Rosen \n         Publishing Group. ISBN 1404260595.\n      */\n    System.out.println(\"Expected: 2500000\");\n}\n","name":"main","className":"PyramidTester","variables":{"args":1,"gizeh":2,"sample":3},"javaDoc":"","comments":"The following estimate is from http://en wikipedia org/wiki/Great_Pyramid_of_Giza citing Levy Janey (2005) The Great Pyramid of Giza: Measuring Length Area Volume and Angles Rosen Publishing Group ISBN 1404260595 ","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["double","double"],"returnType":"Pyramid","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a pyramid with a given height and baselength.\n      @param height the height\n      @param baseLength the length of one of the sides of the square base\n   */\npublic Pyramid(double height, double baseLength) {\n    this.height = height;\n    this.baseLength = baseLength;\n}\n","name":"Pyramid","className":"Pyramid","variables":{"baseLength":2,"height":2},"javaDoc":"Constructs a pyramid with a given height and baselength height the height baseLength the length of one of the sides of the square base","comments":"\n      Constructs a pyramid with a given height and baselength.\n      @param height the height\n      @param baseLength the length of one of the sides of the square base\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the volume of this pyramid.\n      @return the volume\n   */\npublic double getVolume() {\n    return height * baseLength * baseLength / 3;\n}\n","name":"getVolume","className":"Pyramid","variables":{"baseLength":2,"height":1},"javaDoc":"Gets the volume of this pyramid the volume","comments":"\n      Gets the volume of this pyramid.\n      @return the volume\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sqrt":1},"constants":{},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the surface area of this pyramid.\n      @return the surface area, not including the base\n   */\npublic double getSurfaceArea() {\n    double sideLength = Math.sqrt(height * height + baseLength * baseLength / 4);\n    return 2 * baseLength * sideLength;\n}\n","name":"getSurfaceArea","className":"Pyramid","variables":{"sideLength":2,"Math":1,"baseLength":3,"height":2},"javaDoc":"Gets the surface area of this pyramid the surface area not including the base","comments":"\n      Gets the surface area of this pyramid.\n      @return the surface area, not including the base\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sqrt":1,"pow":2,"System.out.print":5,"nextDouble":5,"System.out.println":1},"constants":{"\"Total time: \"":1,"\"Length of segment 1: \"":1,"\"Distance to item along x-axis: \"":1,"\"Distance to item along y-axis: \"":1,"\"Speed along segment 1: \"":1,"\"Speed along segment 2: \"":1},"annotations":[],"types":{"Scanner":1,"double":9},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Distance to item along x-axis: \");\n    double xDistance = in.nextDouble();\n    System.out.print(\"Distance to item along y-axis: \");\n    double yDistance = in.nextDouble();\n    System.out.print(\"Length of segment 1: \");\n    double segment1Length = in.nextDouble();\n    System.out.print(\"Speed along segment 1: \");\n    double segment1Speed = in.nextDouble();\n    System.out.print(\"Speed along segment 2: \");\n    double segment2Speed = in.nextDouble();\n    double segment1Time = segment1Length / segment1Speed;\n    double segment2Length = Math.sqrt(Math.pow(xDistance - segment1Length, 2) + Math.pow(yDistance, 2));\n    double segment2Time = segment2Length / segment2Speed;\n    double totalTime = segment1Time + segment2Time;\n    System.out.println(\"Total time: \" + totalTime);\n}\n","name":"main","className":"TravelTime","variables":{"args":1,"xDistance":2,"segment1Time":2,"segment2Length":2,"in":6,"totalTime":2,"yDistance":1,"segment2Time":2,"segment1Speed":2,"Math":3,"segment1Length":3,"segment2Speed":2},"javaDoc":"","isEmpty":false,"lineCount":16,"modifier":9}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":2,"purchase":2},"javaDoc":"Records the purchase price of an item amount the price of the purchased item","comments":"\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Processes the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   */\npublic void receivePayment(int dollars, int quarters, int dimes, int nickels, int pennies) {\n    payment = dollars + quarters * QUARTER_VALUE + dimes * DIME_VALUE + nickels * NICKEL_VALUE + pennies * PENNY_VALUE;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"NICKEL_VALUE":1,"dimes":2,"nickels":2,"quarters":2,"pennies":2,"dollars":2,"payment":1,"QUARTER_VALUE":1,"DIME_VALUE":1,"PENNY_VALUE":1},"javaDoc":"Processes the payment received from the customer dollars the number of dollars in the payment quarters the number of quarters in the payment dimes the number of dimes in the payment nickels the number of nickels in the payment pennies the number of pennies in the payment","comments":"\n      Processes the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":4,"receivePayment":2,"giveChange":2,"System.out.print":2,"System.out.println":4},"constants":{"23":1,"19.25":1,"\"Expected: 2.0\"":1,"2.25":1,"0.75":1,"\"Change: \"":2,"1.50":1,"\"Expected: 0.25\"":1},"annotations":[],"types":{"CashRegister":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(0.75);\n    register.recordPurchase(1.50);\n    register.receivePayment(2, 0, 5, 0, 0);\n    System.out.print(\"Change: \");\n    System.out.println(register.giveChange());\n    System.out.println(\"Expected: 0.25\");\n    register.recordPurchase(2.25);\n    register.recordPurchase(19.25);\n    register.receivePayment(23, 2, 0, 0, 0);\n    System.out.print(\"Change: \");\n    System.out.println(register.giveChange());\n    System.out.println(\"Expected: 2.0\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"args":1,"register":9},"javaDoc":"","isEmpty":false,"lineCount":13,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":2,"System.out.print":2,"System.out.println":2},"constants":{"\"Tile width: \"":1,"\"Gap at each end: \"":1,"2.0":1,"\"Number of tiles: \"":1,"\"Total width: \"":1},"annotations":[],"types":{"Scanner":1,"double":1,"int":4},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","EnclosedExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Total width: \");\n    int totalWidth = in.nextInt();\n    System.out.print(\"Tile width: \");\n    int tileWidth = in.nextInt();\n    int numberOfPairs = (totalWidth - tileWidth) / (2 * tileWidth);\n    int numberOfTiles = 1 + 2 * numberOfPairs;\n    double gap = (totalWidth - numberOfTiles * tileWidth) / 2.0;\n    System.out.println(\"Number of tiles: \" + numberOfTiles);\n    System.out.println(\"Gap at each end: \" + gap);\n}\n","name":"main","className":"Tiles","variables":{"args":1,"in":3,"gap":2,"numberOfPairs":2,"numberOfTiles":3,"tileWidth":4,"totalWidth":3},"javaDoc":"","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"165":1,"\" moon-pounds.\"":1,"0.17":1,"\" earth-pounds is equivalent to \"":1},"annotations":[],"types":{"double":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String args[]) {\n    // weight on earth  \n    double earthweight;\n    // weight on moon   \n    double moonweight;\n    earthweight = 165;\n    moonweight = earthweight * 0.17;\n    System.out.println(earthweight + \" earth-pounds is equivalent to \" + moonweight + \" moon-pounds.\");\n}\n","name":"main","className":"Moon","variables":{"args":1,"earthweight":4,"moonweight":3},"javaDoc":"","comments":"weight on earth weight on moon ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.println":2},"constants":{"144":1,"12":1,"39.37":1,"\" meters.\"":1,"\" inches is \"":1},"annotations":[],"types":{"double":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String args[]) {\n    double inches, meters;\n    int counter;\n    counter = 0;\n    for (inches = 1; inches <= 144; inches++) {\n        // convert to meters \n        meters = inches / 39.37;\n        System.out.println(inches + \" inches is \" + meters + \" meters.\");\n        counter++;\n        // every 12th line, print a blank line        \n        if (counter == 12) {\n            System.out.println();\n            // reset the line counter \n            counter = 0;\n        }\n    }\n}\n","name":"main","className":"InchToMeterTable","variables":{"args":1,"inches":6,"counter":5,"meters":3},"javaDoc":"","comments":"convert to meters every 12th line print a blank line reset the line counter ","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"100":1,"\" is prime.\"":1,"true":1,"false":1},"annotations":[],"types":{"boolean":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","EnclosedExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String args[]) {\n    int i, j;\n    boolean isprime;\n    for (i = 2; i < 100; i++) {\n        isprime = true;\n        // see if the number is evenly divisible \n        for (j = 2; j <= i / j; j++) // if it is, then its not prime \n        if ((i % j) == 0)\n            isprime = false;\n        if (isprime)\n            System.out.println(i + \" is prime.\");\n    }\n}\n","name":"main","className":"Prime","variables":{"args":1,"isprime":4},"javaDoc":"","comments":"see if the number is evenly divisible if it is then its not prime ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"abs":1,"sqrt":1,"System.out.printf":3,"equals":1,"compareTo":1,"System.out.print":3,"System.out.println":4},"constants":{"\"comes before\"":1,"\"120\"":1,"\"comes after\"":1,"\"equal.\"":1,"\"is the same as\"":1,"\"identical. They are \"":1,"\"sqrt(2) times sqrt(2) is 2\"":1,"1E-14":1,"\"The strings \\\"%s\\\" and \\\"%s\\\" are \"":1,"\"20\"":1,"\"1\"":1,"2.0":1,"\"sqrt(2) times sqrt(2) is not four but %.18f\\n\"":1,"\"not \"":2,"\"sqrt(2) times sqrt(2) is approximately 2\"":1,"\"2 times 2 is four.\"":1,"\"The string \\\"%s\\\" %s the string \\\"%s\\\"\\n\"":1},"annotations":[],"types":{"double":3,"String":4,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    // Integers \n    int m = 2;\n    int n = 4;\n    if (m * m == n) {\n        System.out.println(\"2 times 2 is four.\");\n    }\n    // Floating-point numbers\n    double x = Math.sqrt(2);\n    double y = 2.0;\n    if (x * x == y) {\n        System.out.println(\"sqrt(2) times sqrt(2) is 2\");\n    } else {\n        System.out.printf(\"sqrt(2) times sqrt(2) is not four but %.18f\\n\", x * x);\n    }\n    final double EPSILON = 1E-14;\n    if (Math.abs(x * x - y) < EPSILON) {\n        System.out.println(\"sqrt(2) times sqrt(2) is approximately 2\");\n    }\n    // Strings\n    String s = \"120\";\n    String t = \"20\";\n    int result = s.compareTo(t);\n    String comparison;\n    if (result < 0) {\n        comparison = \"comes before\";\n    } else if (result > 0) {\n        comparison = \"comes after\";\n    } else {\n        comparison = \"is the same as\";\n    }\n    System.out.printf(\"The string \\\"%s\\\" %s the string \\\"%s\\\"\\n\", s, comparison, t);\n    String u = \"1\" + t;\n    System.out.printf(\"The strings \\\"%s\\\" and \\\"%s\\\" are \", s, u);\n    if (s != u) {\n        System.out.print(\"not \");\n    }\n    System.out.print(\"identical. They are \");\n    if (!s.equals(u)) {\n        System.out.print(\"not \");\n    }\n    System.out.println(\"equal.\");\n}\n","name":"main","className":"Compare","variables":{"args":1,"result":3,"comparison":4,"Math":2,"EPSILON":2},"javaDoc":"","comments":"Integers Floating-point numbers Strings ","isEmpty":false,"lineCount":23,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"System.out.printf":1,"equals":3,"System.out.println":2},"constants":{"\"Shipping cost to %s, %s: $%.2f\\n\"":1,"\"USA\"":1,"\"AK\"":1,"\"Enter the state or province: \"":1,"\"Enter the country: \"":1,"\"HI\"":1,"10":2},"annotations":[],"types":{"Scanner":1,"double":1,"String":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.println(\"Enter the state or province: \");\n    String state = in.next();\n    System.out.println(\"Enter the country: \");\n    String country = in.next();\n    double shippingCost;\n    if (country.equals(\"USA\")) {\n        if (// See Section 5.7 for the || (or) operator\n        state.equals(\"AK\") || state.equals(\"HI\")) {\n            shippingCost = 10;\n        } else {\n            shippingCost = 5;\n        }\n    } else {\n        shippingCost = 10;\n    }\n    System.out.printf(\"Shipping cost to %s, %s: $%.2f\\n\", state, country, shippingCost);\n}\n","name":"main","className":"Shipping","variables":{"args":1,"country":2,"shippingCost":4,"in":3,"state":3},"javaDoc":"","comments":"See Section 5 7 for the || (or) operator ","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["double"],"returnType":"Earthquake","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an Earthquake object.\n      @param magnitude the magnitude on the Richter scale\n   */\npublic Earthquake(double magnitude) {\n    richter = magnitude;\n}\n","name":"Earthquake","className":"Earthquake","variables":{"richter":1,"magnitude":2},"javaDoc":"Constructs an Earthquake object magnitude the magnitude on the Richter scale","comments":"\n      Constructs an Earthquake object.\n      @param magnitude the magnitude on the Richter scale\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"Many buildings destroyed\"":1,"\"Damage to poorly constructed buildings\"":1,"\"Most structures fall\"":1,"\"Many buildings considerably damaged, some collapse\"":1,"\"No destruction of buildings\"":1,"6.0":1,"7.0":1,"8.0":1,"4.5":1},"annotations":[],"types":{"String":1},"expressions":["VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets a description of the effect of the earthquake.\n      @return the description of the effect\n   */\npublic String getDescription() {\n    String description;\n    if (richter >= 8.0) {\n        description = \"Most structures fall\";\n    } else if (richter >= 7.0) {\n        description = \"Many buildings destroyed\";\n    } else if (richter >= 6.0) {\n        description = \"Many buildings considerably damaged, some collapse\";\n    } else if (richter >= 4.5) {\n        description = \"Damage to poorly constructed buildings\";\n    } else {\n        description = \"No destruction of buildings\";\n    }\n    return description;\n}\n","name":"getDescription","className":"Earthquake","variables":{"richter":4,"description":7},"javaDoc":"Gets a description of the effect of the earthquake the description of the effect","comments":"\n      Gets a description of the effect of the earthquake.\n      @return the description of the effect\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getDescription":1,"System.out.print":1,"nextDouble":1,"System.out.println":1},"constants":{"\"Enter a magnitude on the Richter scale: \"":1},"annotations":[],"types":{"Scanner":1,"Earthquake":1,"double":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter a magnitude on the Richter scale: \");\n    double magnitude = in.nextDouble();\n    Earthquake quake = new Earthquake(magnitude);\n    System.out.println(quake.getDescription());\n}\n","name":"main","className":"EarthquakeRunner","variables":{"args":1,"in":2,"quake":2,"magnitude":2},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":1,"System.out.print":1,"nextDouble":1},"constants":{"0.92":1,"\"Original price before discount: \"":1,"128":1,"0.84":1,"\"Discounted price: %.2f\\n\"":1},"annotations":[],"types":{"Scanner":1,"double":3},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Original price before discount: \");\n    double originalPrice = in.nextDouble();\n    double discountRate;\n    if (originalPrice < 128) {\n        discountRate = 0.92;\n    } else {\n        discountRate = 0.84;\n    }\n    double discountedPrice = discountRate * originalPrice;\n    System.out.printf(\"Discounted price: %.2f\\n\", discountedPrice);\n}\n","name":"main","className":"Sale","variables":{"args":1,"discountRate":4,"originalPrice":3,"discountedPrice":1,"in":2},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"length":3,"System.out.print":1,"substring":1,"System.out.println":1},"constants":{"\"Middle: \"":1,"\"Enter a string: \"":1},"annotations":[],"types":{"Scanner":1,"String":2,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter a string: \");\n    String str = in.next();\n    int position;\n    int length;\n    if (str.length() % 2 == 1) {\n        position = str.length() / 2;\n        length = 1;\n    } else {\n        position = str.length() / 2 - 1;\n        length = 2;\n    }\n    String result = str.substring(position, position + length);\n    System.out.println(\"Middle: \" + result);\n}\n","name":"main","className":"Middle","variables":{"args":1,"str":5,"result":2,"in":2,"length":4,"position":4},"javaDoc":"","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"System.out.println":1},"constants":{"13":1,"\"Floor: \"":1,"\"The elevator will travel to the actual floor \"":1},"annotations":[],"types":{"Scanner":1,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Floor: \");\n    int floor = in.nextInt();\n    // Adjust floor if necessary\n    int actualFloor;\n    if (floor > 13) {\n        actualFloor = floor - 1;\n    } else {\n        actualFloor = floor;\n    }\n    System.out.println(\"The elevator will travel to the actual floor \" + actualFloor);\n}\n","name":"main","className":"ElevatorSimulation","variables":{"args":1,"actualFloor":4,"in":2,"floor":4},"javaDoc":"","comments":"Adjust floor if necessary ","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextDouble":2,"System.out.print":1,"System.out.println":8},"constants":{"\"The first number is \"":1,"\"Enter two numbers (such as 3.5 4.5): \"":1,"\"The numbers have different signs\"":1,"0.01":2,"\"larger\"":1,"\"The numbers are close together\"":1,"\"They are the same.\"":1,"\"The numbers are one apart\"":1,"\"smaller\"":1,"\"The numbers have the same sign\"":1},"annotations":[],"types":{"Scanner":1,"double":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.println(\"Enter two numbers (such as 3.5 4.5): \");\n    double x = in.nextDouble();\n    double y = in.nextDouble();\n    if (x == y) {\n        System.out.println(\"They are the same.\");\n    } else {\n        System.out.print(\"The first number is \");\n        if (x > y) {\n            System.out.println(\"larger\");\n        } else {\n            System.out.println(\"smaller\");\n        }\n        if (-0.01 < x - y && x - y < 0.01) {\n            System.out.println(\"The numbers are close together\");\n        }\n        if (x == y + 1 || x == y - 1) {\n            System.out.println(\"The numbers are one apart\");\n        }\n        if (x > 0 && y > 0 || x < 0 && y < 0) {\n            System.out.println(\"The numbers have the same sign\");\n        } else {\n            System.out.println(\"The numbers have different signs\");\n        }\n    }\n}\n","name":"main","className":"Compare2","variables":{"args":1,"in":3},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"hasNextInt":1,"nextInt":1,"System.out.print":1,"System.out.println":4},"constants":{"13":2,"\"Error: There is no thirteenth floor.\"":1,"\"Floor: \"":1,"\"Error: The floor must be between 1 and 20.\"":1,"\"Error: Not an integer.\"":1,"20":1,"\"The elevator will travel to the actual floor \"":1},"annotations":[],"types":{"Scanner":1,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Floor: \");\n    if (in.hasNextInt()) {\n        // Now we know that the user entered an integer\n        int floor = in.nextInt();\n        if (floor == 13) {\n            System.out.println(\"Error: There is no thirteenth floor.\");\n        } else if (floor <= 0 || floor > 20) {\n            System.out.println(\"Error: The floor must be between 1 and 20.\");\n        } else {\n            // Now we know that the input is valid\n            int actualFloor = floor;\n            if (floor > 13) {\n                actualFloor = floor - 1;\n            }\n            System.out.println(\"The elevator will travel to the actual floor \" + actualFloor);\n        }\n    } else {\n        System.out.println(\"Error: Not an integer.\");\n    }\n}\n","name":"main","className":"ElevatorSimulation2","variables":{"args":1,"actualFloor":3,"in":3,"floor":7},"javaDoc":"","comments":"Now we know that the user entered an integer Now we know that the input is valid ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"equals":1,"getTax":1,"System.out.print":2,"nextDouble":1,"System.out.println":1},"constants":{"\"Are you married? (Y/N) \"":1,"\"Please enter your income: \"":1,"\"Tax: \"":1,"\"Y\"":1},"annotations":[],"types":{"Scanner":1,"double":1,"String":1,"int":1,"TaxReturn":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Please enter your income: \");\n    double income = in.nextDouble();\n    System.out.print(\"Are you married? (Y/N) \");\n    String input = in.next();\n    int status;\n    if (input.equals(\"Y\")) {\n        status = TaxReturn.MARRIED;\n    } else {\n        status = TaxReturn.SINGLE;\n    }\n    TaxReturn aTaxReturn = new TaxReturn(income, status);\n    System.out.println(\"Tax: \" + aTaxReturn.getTax());\n}\n","name":"main","className":"TaxCalculator","variables":{"args":1,"income":2,"input":2,"aTaxReturn":2,"in":3,"status":4},"javaDoc":"","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["double","int"],"returnType":"TaxReturn","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a TaxReturn object for a given income and \n      marital status.\n      @param anIncome the taxpayer income\n      @param aStatus either SINGLE or MARRIED\n   */\npublic TaxReturn(double anIncome, int aStatus) {\n    income = anIncome;\n    status = aStatus;\n}\n","name":"TaxReturn","className":"TaxReturn","variables":{"income":1,"anIncome":2,"aStatus":2,"status":1},"javaDoc":"Constructs a TaxReturn object for a given income and marital status anIncome the taxpayer income aStatus either SINGLE or MARRIED","comments":"\n      Constructs a TaxReturn object for a given income and \n      marital status.\n      @param anIncome the taxpayer income\n      @param aStatus either SINGLE or MARRIED\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","EnclosedExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public double getTax() {\n    double tax1 = 0;\n    double tax2 = 0;\n    if (status == SINGLE) {\n        if (income <= RATE1_SINGLE_LIMIT) {\n            tax1 = RATE1 * income;\n        } else {\n            tax1 = RATE1 * RATE1_SINGLE_LIMIT;\n            tax2 = RATE2 * (income - RATE1_SINGLE_LIMIT);\n        }\n    } else {\n        if (income <= RATE1_MARRIED_LIMIT) {\n            tax1 = RATE1 * income;\n        } else {\n            tax1 = RATE1 * RATE1_MARRIED_LIMIT;\n            tax2 = RATE2 * (income - RATE1_MARRIED_LIMIT);\n        }\n    }\n    return tax1 + tax2;\n}\n","name":"getTax","className":"TaxReturn","variables":{"tax1":6,"income":6,"RATE2":2,"tax2":4,"SINGLE":1,"RATE1":4,"RATE1_MARRIED_LIMIT":3,"RATE1_SINGLE_LIMIT":3,"status":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"nthFibonacciRecursive":2},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":["Recursion"],"exceptions":[],"text":"public static int nthFibonacciRecursive(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    return nthFibonacciRecursive(n - 1) + nthFibonacciRecursive(n - 2);\n}\n","name":"nthFibonacciRecursive","className":"RecursionSample","variables":{},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public static void nthFibonacciDynamic(int n) {\n}\n","name":"nthFibonacciDynamic","className":"RecursionSample","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":9}
{"paramTypes":["int","HashMap<Integer, Integer>"],"returnType":"int","methodCalls":{"nthFibonacciDynamic":2,"containsKey":1,"get":1,"put":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"public static int nthFibonacciDynamic(int n, HashMap<Integer, Integer> memo) {\n    if (memo.containsKey(n)) {\n        return memo.get(n);\n    }\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    int value = nthFibonacciDynamic(n - 1, memo) + nthFibonacciDynamic(n - 2, memo);\n    memo.put(n, value);\n    return value;\n}\n","name":"nthFibonacciDynamic","className":"RecursionSample","variables":{"memo":4,"value":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setBrandName":1,"setCPU":1,"nextLine":6,"length":2,"setPrice":1,"setMemory":1,"printMenu":2,"parseDouble":1,"parseInt":2,"toUpperCase":1,"charAt":1,"System.out.print":9,"System.out.println":1},"constants":{"'Z'":1,"\"Enter a cpu type:\\n\"":1,"\"Enter a computer memory:\\n\"":1,"\"What action would you like to perform?\"":1,"\"Enter a cpu speed:\\n\"":1,"\"Enter a brand name:\\n\"":1,"\"Unknown action\\n\"":2,"'Q'":1,"\"Please enter the computer information:\\n\"":1,"\"Enter a computer price:\\n\"":1},"annotations":[],"types":{"Scanner":1,"double":1,"char":1,"Computer":1,"String":4,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","CharLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["SwitchStmt","IfStmt","BreakStmt","BlockStmt","SwitchEntryStmt","ExpressionStmt","DoStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // local variables, can be accessed anywhere from the main method\n    char input1 = 'Z';\n    String inputInfo;\n    String brandName;\n    double price;\n    int memory;\n    String cpuType;\n    int cpuSpeed;\n    String line = new String();\n    // instantiate a Computer object\n    Computer computer1 = new Computer();\n    printMenu();\n    //Create a Scanner object to read user input\n    Scanner scan = new Scanner(System.in);\n    do // will ask for user input\n    {\n        System.out.println(\"What action would you like to perform?\");\n        line = scan.nextLine();\n        if (line.length() == 1) {\n            input1 = line.charAt(0);\n            input1 = Character.toUpperCase(input1);\n            // matches one of the case statement\n            switch(input1) {\n                case //Add Computer\n                'A':\n                    System.out.print(\"Please enter the computer information:\\n\");\n                    System.out.print(\"Enter a brand name:\\n\");\n                    brandName = scan.nextLine();\n                    computer1.setBrandName(brandName);\n                    System.out.print(\"Enter a computer price:\\n\");\n                    price = Double.parseDouble(scan.nextLine());\n                    computer1.setPrice(price);\n                    System.out.print(\"Enter a computer memory:\\n\");\n                    memory = Integer.parseInt(scan.nextLine());\n                    computer1.setMemory(memory);\n                    System.out.print(\"Enter a cpu type:\\n\");\n                    cpuType = scan.nextLine();\n                    System.out.print(\"Enter a cpu speed:\\n\");\n                    cpuSpeed = Integer.parseInt(scan.nextLine());\n                    computer1.setCPU(cpuType, cpuSpeed);\n                    break;\n                case //Display computer\n                'D':\n                    System.out.print(computer1);\n                    break;\n                case //Quit\n                'Q':\n                    break;\n                case //Display Menu\n                '?':\n                    printMenu();\n                    break;\n                default:\n                    System.out.print(\"Unknown action\\n\");\n                    break;\n            }\n        } else {\n            System.out.print(\"Unknown action\\n\");\n        }\n    } while (input1 != 'Q' || line.length() != 1);\n}\n","name":"main","className":"Assignment4","variables":{"inputInfo":1,"brandName":2,"cpuType":2,"memory":2,"cpuSpeed":2,"Character":1,"line":5,"input1":5,"scan":7,"Double":1,"args":1,"computer1":5,"Integer":2,"price":2},"javaDoc":"","comments":"local variables can be accessed anywhere from the main method instantiate a Computer object Create a Scanner object to read user input will ask for user input matches one of the case statement Add Computer Display computer Quit Display Menu ","isEmpty":false,"lineCount":12,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.print":1},"constants":{"\"A\\t\\tAdd Computer\\n\"":1,"\"Q\\t\\tQuit\\n\"":1,"\"?\\t\\tDisplay Help\\n\\n\"":1,"\"Choice\\t\\tAction\\n\"":1,"\"------\\t\\t------\\n\"":1,"\"D\\t\\tDisplay Computer\\n\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** The method printMenu displays the menu to a user**/\npublic static void printMenu() {\n    System.out.print(\"Choice\\t\\tAction\\n\" + \"------\\t\\t------\\n\" + \"A\\t\\tAdd Computer\\n\" + \"D\\t\\tDisplay Computer\\n\" + \"Q\\t\\tQuit\\n\" + \"?\\t\\tDisplay Help\\n\\n\");\n}\n","name":"printMenu","className":"Assignment4","variables":{},"javaDoc":"The method printMenu displays the menu to a user","comments":" The method printMenu displays the menu to a user*","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"Car","methodCalls":{},"constants":{"0.0":1,"\"?\"":2},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","DoubleLiteralExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Car() {\n    manufacturer = new String(\"?\");\n    brandName = new String(\"?\");\n    year = 0;\n    price = 0.0;\n}\n","name":"Car","className":"Car","variables":{"brandName":1,"year":1,"price":1,"manufacturer":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String","String","int","double"],"returnType":"Car","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//Overloaded constructor, used to initialize all instance varibles\npublic Car(String nManufacturer, String nBrandName, int nYear, double nPrice) {\n    manufacturer = nManufacturer;\n    brandName = nBrandName;\n    year = nYear;\n    price = nPrice;\n}\n","name":"Car","className":"Car","variables":{"brandName":1,"nYear":2,"nBrandName":2,"year":1,"price":1,"nManufacturer":2,"nPrice":2,"manufacturer":1},"javaDoc":"","comments":"Overloaded constructor, used to initialize all instance varibles","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"//Accessor method of the instance variable manufacturer\npublic String getManufacturer() {\n    return manufacturer;\n}\n","name":"getManufacturer","className":"Car","variables":{"manufacturer":1},"javaDoc":"","comments":"Accessor method of the instance variable manufacturer","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"//Accessor method of the instance variable brandName\npublic String getBrandName() {\n    return brandName;\n}\n","name":"getBrandName","className":"Car","variables":{"brandName":1},"javaDoc":"","comments":"Accessor method of the instance variable brandName","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"//Accessor method of the instance variable year\npublic int getYear() {\n    return year;\n}\n","name":"getYear","className":"Car","variables":{"year":1},"javaDoc":"","comments":"Accessor method of the instance variable year","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"//Accessor method of the instance variable price\npublic double getPrice() {\n    return price;\n}\n","name":"getPrice","className":"Car","variables":{"price":1},"javaDoc":"","comments":"Accessor method of the instance variable price","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1},"constants":{"\"Year:\\t\"":1,"\"\\nManufacturer:\\t\"":1,"\"\\n\\n\"":1,"\"Price:\\t\"":1,"\"Brand Name:\\t\"":1,"\"$0.00\"":1,"\"\\n\"":3},"annotations":[],"types":{"DecimalFormat":1,"String":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//toString method creates a string containing values of\n//instance variables using the specified format\npublic String toString() {\n    DecimalFormat fmt1 = new DecimalFormat(\"$0.00\");\n    String result = \"\\nManufacturer:\\t\" + manufacturer + \"\\n\" + \"Brand Name:\\t\" + brandName + \"\\n\" + \"Year:\\t\" + year + \"\\n\" + \"Price:\\t\" + fmt1.format(price) + \"\\n\\n\";\n    return result;\n}\n","name":"toString","className":"Car","variables":{"result":2,"brandName":1,"fmt1":2,"year":1,"manufacturer":1},"javaDoc":"","comments":"instance variables using the specified format","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Passenger","methodCalls":{},"constants":{"\"?\"":3},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Passenger() {\n    firstName = new String(\"?\");\n    lastName = new String(\"?\");\n    passengerID = new String(\"?\");\n    bookingNum = 0;\n}\n","name":"Passenger","className":"Passenger","variables":{"firstName":1,"lastName":1,"passengerID":1,"bookingNum":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getFirstName() {\n    return firstName;\n}\n","name":"getFirstName","className":"Passenger","variables":{"firstName":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getLastName() {\n    return lastName;\n}\n","name":"getLastName","className":"Passenger","variables":{"lastName":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getPassengerID() {\n    return passengerID;\n}\n","name":"getPassengerID","className":"Passenger","variables":{"passengerID":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getBookingNum() {\n    return bookingNum;\n}\n","name":"getBookingNum","className":"Passenger","variables":{"bookingNum":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setFirstName(String fname) {\n    firstName = fname;\n}\n","name":"setFirstName","className":"Passenger","variables":{"fname":2,"firstName":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setLastName(String lname) {\n    lastName = lname;\n}\n","name":"setLastName","className":"Passenger","variables":{"lastName":1,"lname":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setPassengerID(String pId) {\n    passengerID = pId;\n}\n","name":"setPassengerID","className":"Passenger","variables":{"passengerID":1,"pId":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setBookingNum(int bookings) {\n    bookingNum = bookings;\n}\n","name":"setBookingNum","className":"Passenger","variables":{"bookings":2,"bookingNum":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"\\nFirst name:\\t\\t\"":1,"\"Last name:\\t\\t\"":1,"\"\\n\\n\"":1,"\"Passenger ID:\\t\\t\"":1,"\"Number of bookings:\\t\"":1,"\"\\n\"":3},"annotations":[],"types":{"String":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    String passengerString;\n    passengerString = \"\\nFirst name:\\t\\t\" + firstName + \"\\n\" + \"Last name:\\t\\t\" + lastName + \"\\n\" + \"Passenger ID:\\t\\t\" + passengerID + \"\\n\" + \"Number of bookings:\\t\" + bookingNum + \"\\n\\n\";\n    return passengerString;\n}\n","name":"toString","className":"Passenger","variables":{"passengerString":3,"firstName":1,"lastName":1,"passengerID":1,"bookingNum":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"equals":1,"compareTo":2},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","NameExpr","CastExpr","FieldAccessExpr","EnclosedExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public int compareTo(Object other) {\n    int result;\n    if (lastName.equals(((Passenger) other).lastName))\n        result = firstName.compareTo(((Passenger) other).firstName);\n    else\n        result = lastName.compareTo(((Passenger) other).lastName);\n    return result;\n}\n","name":"compareTo","className":"Passenger","variables":{"result":4,"lastName":2,"firstName":1,"other":4},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":5},"constants":{"\"Hello\"":1,"\"00\"":1,"\"Goodbye\"":1,"\"World!\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // Prints 7\n    System.out.println(3 + 4);\n    // Prints \"Hello World!\" in two lines\n    System.out.println(\"Hello\");\n    System.out.println(\"World!\");\n    // Prints 00 but doesn't start a new line\n    System.out.print(\"00\");\n    // Prints 7 and starts a new line\n    System.out.println(3 + 4);\n    System.out.println(\"Goodbye\");\n}\n","name":"main","className":"PrintTester","variables":{"args":1},"javaDoc":"","comments":"Prints 7 Prints \"Hello World!\" in two lines Prints 00 but doesn't start a new line Prints 7 and starts a new line ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    System.out.println(1 / 0);\n// A run-time exception. The program terminates.\n}\n","name":"main","className":"Error3","variables":{"args":1},"javaDoc":"","comments":"A run-time exception The program terminates ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"Hello, Word!\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    System.out.println(\"Hello, Word!\");\n// A run-time error. The program doesn't do what it should.\n}\n","name":"main","className":"Error2","variables":{"args":1},"javaDoc":"","comments":"A run-time error The program doesn't do what it should ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.ou.println":1},"constants":{"\"Hello, World!\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // A compile-time error. \n    System.ou.println(\"Hello, World!\");\n}\n","name":"main","className":"Error1","variables":{"args":1},"javaDoc":"","comments":"A compile-time error ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"Hello, World!\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // Display a greeting in the console window\n    System.out.println(\"Hello, World!\");\n}\n","name":"main","className":"HelloPrinter","variables":{"args":1},"javaDoc":"","comments":"Display a greeting in the console window ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"\"Calculator\"":1,"true":1},"annotations":[],"types":{"JFrame":1,"CalculatorFrame":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new CalculatorFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"Calculator\");\n    frame.setVisible(true);\n}\n","name":"main","className":"CalculatorViewer","variables":{"args":1,"frame":4},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"CalculatorFrame","methodCalls":{"add":1,"createButtonPanel":1,"setSize":1},"constants":{"\"0\"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public CalculatorFrame() {\n    display = new JLabel(\"0\");\n    add(display, BorderLayout.NORTH);\n    createButtonPanel();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"CalculatorFrame","className":"CalculatorFrame","variables":{"display":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":17,"setLayout":1,"makeDigitButton":11,"makeOperatorButton":5},"constants":{"\"=\"":1,"\"9\"":1,"\"8\"":1,"\"7\"":1,"\"6\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"\"1\"":1,"\"0\"":1,"\"/\"":1,"\".\"":1,"\"-\"":1,"\"+\"":1,"\"*\"":1},"annotations":[],"types":{"JPanel":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates the button panel.\n   */\nprivate void createButtonPanel() {\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 4));\n    buttonPanel.add(makeDigitButton(\"7\"));\n    buttonPanel.add(makeDigitButton(\"8\"));\n    buttonPanel.add(makeDigitButton(\"9\"));\n    buttonPanel.add(makeOperatorButton(\"/\"));\n    buttonPanel.add(makeDigitButton(\"4\"));\n    buttonPanel.add(makeDigitButton(\"5\"));\n    buttonPanel.add(makeDigitButton(\"6\"));\n    buttonPanel.add(makeOperatorButton(\"*\"));\n    buttonPanel.add(makeDigitButton(\"1\"));\n    buttonPanel.add(makeDigitButton(\"2\"));\n    buttonPanel.add(makeDigitButton(\"3\"));\n    buttonPanel.add(makeOperatorButton(\"-\"));\n    buttonPanel.add(makeDigitButton(\"0\"));\n    buttonPanel.add(makeDigitButton(\".\"));\n    buttonPanel.add(makeOperatorButton(\"=\"));\n    buttonPanel.add(makeOperatorButton(\"+\"));\n    add(buttonPanel, BorderLayout.CENTER);\n}\n","name":"createButtonPanel","className":"CalculatorFrame","variables":{"buttonPanel":18},"javaDoc":"Creates the button panel","comments":"\n      Creates the button panel.\n   ","isEmpty":false,"lineCount":19,"modifier":2}
{"paramTypes":["String"],"returnType":"DigitButtonListener","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      */\npublic DigitButtonListener(String aDigit) {\n    digit = aDigit;\n}\n","name":"DigitButtonListener","className":"DigitButtonListener","variables":{"aDigit":2,"digit":1},"javaDoc":"Constructs a listener whose actionPerformed method adds a digit to the display aDigit the digit to add","comments":"\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":1,"setText":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    display.setText(display.getText() + digit);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"display":2,"event":1,"digit":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{"addActionListener":1},"constants":{},"annotations":[],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   */\npublic JButton makeDigitButton(String digit) {\n    JButton button = new JButton(digit);\n    ActionListener listener = new DigitButtonListener(digit);\n    button.addActionListener(listener);\n    return button;\n}\n","name":"makeDigitButton","className":"CalculatorFrame","variables":{"button":3,"listener":1,"digit":3},"javaDoc":"Makes a button representing a digit of a calculator digit the digit of the calculator the button of the calculator","comments":"\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{},"constants":{},"annotations":[],"types":{"JButton":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calcalator\n   */\npublic JButton makeOperatorButton(String op) {\n    JButton button = new JButton(op);\n    return button;\n}\n","name":"makeOperatorButton","className":"CalculatorFrame","variables":{"button":2,"op":2},"javaDoc":"Makes a button representing an operator of a calculator op the operator of the calculator the button of the calcalator","comments":"\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calcalator\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"constants":{"true":1},"annotations":[],"types":{"InvestmentFrame3":1,"JFrame":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new InvestmentFrame3();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer3","variables":{"args":1,"frame":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"InvestmentFrame3","methodCalls":{"createPanel":1,"setEditable":1,"setSize":1,"createButton":1,"setText":1,"createTextField":1},"constants":{"false":1,"\"\\n\"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public InvestmentFrame3() {\n    balance = INITIAL_BALANCE;\n    resultArea = new JTextArea(AREA_ROWS, AREA_COLUMNS);\n    resultArea.setText(balance + \"\\n\");\n    resultArea.setEditable(false);\n    createTextField();\n    createButton();\n    createPanel();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"InvestmentFrame3","className":"InvestmentFrame3","variables":{"AREA_ROWS":1,"balance":2,"AREA_COLUMNS":1,"resultArea":3,"INITIAL_BALANCE":1},"javaDoc":"","isEmpty":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"constants":{"\"\"":1,"\"Interest Rate: \"":1,"10":1},"annotations":[],"types":{"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"private void createTextField() {\n    rateLabel = new JLabel(\"Interest Rate: \");\n    final int FIELD_WIDTH = 10;\n    rateField = new JTextField(FIELD_WIDTH);\n    rateField.setText(\"\" + DEFAULT_RATE);\n}\n","name":"createTextField","className":"InvestmentFrame3","variables":{"rateLabel":1,"DEFAULT_RATE":1,"FIELD_WIDTH":2,"rateField":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"getText":1,"append":1},"constants":{"100":1,"\"\\n\"":1},"annotations":[],"types":{"double":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    double rate = Double.parseDouble(rateField.getText());\n    double interest = balance * rate / 100;\n    balance = balance + interest;\n    resultArea.append(balance + \"\\n\");\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"balance":4,"rate":2,"interest":2,"rateField":1,"resultArea":1,"event":1,"Double":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"addActionListener":1},"constants":{"\"Add Interest\"":1},"annotations":[],"types":{"ActionListener":1,"AddInterestListener":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"private void createButton() {\n    button = new JButton(\"Add Interest\");\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n}\n","name":"createButton","className":"InvestmentFrame3","variables":{"button":2,"listener":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5},"constants":{},"annotations":[],"types":{"JScrollPane":1,"JPanel":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void createPanel() {\n    JPanel panel = new JPanel();\n    panel.add(rateLabel);\n    panel.add(rateField);\n    panel.add(button);\n    JScrollPane scrollPane = new JScrollPane(resultArea);\n    panel.add(scrollPane);\n    add(panel);\n}\n","name":"createPanel","className":"InvestmentFrame3","variables":{"scrollPane":1,"resultArea":1,"panel":5},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":2}
{"paramTypes":[],"returnType":"ColorFrame","methodCalls":{"add":1,"createControlPanel":1,"setSize":1,"setSampleColor":1},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public ColorFrame() {\n    colorPanel = new JPanel();\n    add(colorPanel, BorderLayout.CENTER);\n    createControlPanel();\n    setSampleColor();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"ColorFrame","className":"ColorFrame","variables":{"colorPanel":1},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["ChangeEvent"],"returnType":"void","methodCalls":{"setSampleColor":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void stateChanged(ChangeEvent event) {\n    setSampleColor();\n}\n","name":"stateChanged","className":"ColorListener","variables":{"event":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":7,"setLayout":1,"addChangeListener":3},"constants":{"\"Green\"":1,"255":4,"\"Red\"":1,"175":2,"\"Blue\"":1},"annotations":[],"types":{"JPanel":1,"ColorListener":1,"ChangeListener":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public void createControlPanel() {\n    ChangeListener listener = new ColorListener();\n    redSlider = new JSlider(0, 255, 255);\n    redSlider.addChangeListener(listener);\n    greenSlider = new JSlider(0, 255, 175);\n    greenSlider.addChangeListener(listener);\n    blueSlider = new JSlider(0, 255, 175);\n    blueSlider.addChangeListener(listener);\n    JPanel controlPanel = new JPanel();\n    controlPanel.setLayout(new GridLayout(3, 2));\n    controlPanel.add(new JLabel(\"Red\"));\n    controlPanel.add(redSlider);\n    controlPanel.add(new JLabel(\"Green\"));\n    controlPanel.add(greenSlider);\n    controlPanel.add(new JLabel(\"Blue\"));\n    controlPanel.add(blueSlider);\n    add(controlPanel, BorderLayout.SOUTH);\n}\n","name":"createControlPanel","className":"ColorFrame","variables":{"controlPanel":8,"greenSlider":2,"redSlider":2,"listener":1,"blueSlider":2},"javaDoc":"","isEmpty":false,"lineCount":16,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getValue":3,"repaint":1,"setBackground":1},"constants":{},"annotations":[],"types":{"int":3},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Reads the slider values and sets the panel to\n      the selected color.\n   */\npublic void setSampleColor() {\n    // Read slider values\n    int red = redSlider.getValue();\n    int green = greenSlider.getValue();\n    int blue = blueSlider.getValue();\n    // Set panel background to selected color\n    colorPanel.setBackground(new Color(red, green, blue));\n    colorPanel.repaint();\n}\n","name":"setSampleColor","className":"ColorFrame","variables":{"red":2,"colorPanel":2,"green":2,"blue":2,"greenSlider":1,"redSlider":1,"blueSlider":1},"javaDoc":"Reads the slider values and sets the panel to the selected color","comments":"Read slider values Set panel background to selected color \n      Reads the slider values and sets the panel to\n      the selected color.\n   ","isEmpty":false,"lineCount":7,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"constants":{"true":1},"annotations":[],"types":{"ColorFrame":1,"JFrame":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new ColorFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ColorViewer","variables":{"args":1,"frame":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"true":1,"\"A frame with two components\"":1},"annotations":[],"types":{"FilledFrame":1,"JFrame":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new FilledFrame();\n    frame.setTitle(\"A frame with two components\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"FilledFrameViewer2","variables":{"args":1,"frame":4},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"FilledFrame","methodCalls":{"createComponents":1,"setSize":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public FilledFrame() {\n    createComponents();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"FilledFrame","className":"FilledFrame","variables":{},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3},"constants":{"\"Hello, World!\"":1,"\"Click me!\"":1},"annotations":[],"types":{"JPanel":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void createComponents() {\n    button = new JButton(\"Click me!\");\n    label = new JLabel(\"Hello, World!\");\n    JPanel panel = new JPanel();\n    panel.add(button);\n    panel.add(label);\n    add(panel);\n}\n","name":"createComponents","className":"FilledFrame","variables":{"button":1,"label":1,"panel":3},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":2}
{"paramTypes":[],"returnType":"FontFrame","methodCalls":{"add":1,"setLabelFont":1,"createControlPanel":1,"setSize":1},"constants":{"\"Big Java\"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs the frame.\n   */\npublic FontFrame() {\n    // Construct text sample\n    label = new JLabel(\"Big Java\");\n    add(label, BorderLayout.CENTER);\n    // This listener is shared among all components\n    listener = new ChoiceListener();\n    createControlPanel();\n    setLabelFont();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"FontFrame","className":"FontFrame","variables":{"listener":1,"label":1},"javaDoc":"Constructs the frame","comments":"Construct text sample This listener is shared among all components \n      Constructs the frame.\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    setLabelFont();\n}\n","name":"actionPerformed","className":"ChoiceListener","variables":{"event":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":4,"createCheckBoxes":1,"createComboBox":1,"setLayout":1,"createRadioButtons":1},"constants":{},"annotations":[],"types":{"JPanel":4},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates the control panel to change the font.\n   */\npublic void createControlPanel() {\n    JPanel facenamePanel = createComboBox();\n    JPanel sizeGroupPanel = createCheckBoxes();\n    JPanel styleGroupPanel = createRadioButtons();\n    // Line up component panels\n    JPanel controlPanel = new JPanel();\n    controlPanel.setLayout(new GridLayout(3, 1));\n    controlPanel.add(facenamePanel);\n    controlPanel.add(sizeGroupPanel);\n    controlPanel.add(styleGroupPanel);\n    // Add panels to content pane\n    add(controlPanel, BorderLayout.SOUTH);\n}\n","name":"createControlPanel","className":"FontFrame","variables":{"controlPanel":5,"facenamePanel":1,"styleGroupPanel":1,"sizeGroupPanel":1},"javaDoc":"Creates the control panel to change the font","comments":"Line up component panels Add panels to content pane \n      Creates the control panel to change the font.\n   ","isEmpty":false,"lineCount":11,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":1,"addItem":3,"setEditable":1,"addActionListener":1},"constants":{"\"SansSerif\"":1,"true":1,"\"Monospaced\"":1,"\"Serif\"":1},"annotations":[],"types":{"JPanel":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates the combo box with the font style choices.\n      @return the panel containing the combo box\n   */\npublic JPanel createComboBox() {\n    facenameCombo = new JComboBox();\n    facenameCombo.addItem(\"Serif\");\n    facenameCombo.addItem(\"SansSerif\");\n    facenameCombo.addItem(\"Monospaced\");\n    facenameCombo.setEditable(true);\n    facenameCombo.addActionListener(listener);\n    JPanel panel = new JPanel();\n    panel.add(facenameCombo);\n    return panel;\n}\n","name":"createComboBox","className":"FontFrame","variables":{"facenameCombo":6,"panel":3},"javaDoc":"Creates the combo box with the font style choices the panel containing the combo box","comments":"\n      Creates the combo box with the font style choices.\n      @return the panel containing the combo box\n   ","isEmpty":false,"lineCount":9,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":2,"setBorder":1,"addActionListener":2},"constants":{"\"Bold\"":1,"\"Style\"":1,"\"Italic\"":1},"annotations":[],"types":{"JPanel":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates the check boxes for selecting bold and italic styles.\n      @return the panel containing the check boxes\n   */\npublic JPanel createCheckBoxes() {\n    italicCheckBox = new JCheckBox(\"Italic\");\n    italicCheckBox.addActionListener(listener);\n    boldCheckBox = new JCheckBox(\"Bold\");\n    boldCheckBox.addActionListener(listener);\n    JPanel panel = new JPanel();\n    panel.add(italicCheckBox);\n    panel.add(boldCheckBox);\n    panel.setBorder(new TitledBorder(new EtchedBorder(), \"Style\"));\n    return panel;\n}\n","name":"createCheckBoxes","className":"FontFrame","variables":{"panel":5,"italicCheckBox":2,"boldCheckBox":2},"javaDoc":"Creates the check boxes for selecting bold and italic styles the panel containing the check boxes","comments":"\n      Creates the check boxes for selecting bold and italic styles.\n      @return the panel containing the check boxes\n   ","isEmpty":false,"lineCount":9,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":6,"setSelected":1,"setBorder":1,"addActionListener":3},"constants":{"\"Medium\"":1,"true":1,"\"Size\"":1,"\"Large\"":1,"\"Small\"":1},"annotations":[],"types":{"JPanel":1,"ButtonGroup":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates the radio buttons to select the font size.\n      @return the panel containing the radio buttons\n   */\npublic JPanel createRadioButtons() {\n    smallButton = new JRadioButton(\"Small\");\n    smallButton.addActionListener(listener);\n    mediumButton = new JRadioButton(\"Medium\");\n    mediumButton.addActionListener(listener);\n    largeButton = new JRadioButton(\"Large\");\n    largeButton.addActionListener(listener);\n    largeButton.setSelected(true);\n    // Add radio buttons to button group\n    ButtonGroup group = new ButtonGroup();\n    group.add(smallButton);\n    group.add(mediumButton);\n    group.add(largeButton);\n    JPanel panel = new JPanel();\n    panel.add(smallButton);\n    panel.add(mediumButton);\n    panel.add(largeButton);\n    panel.setBorder(new TitledBorder(new EtchedBorder(), \"Size\"));\n    return panel;\n}\n","name":"createRadioButtons","className":"FontFrame","variables":{"mediumButton":2,"largeButton":3,"panel":6,"smallButton":2,"group":4},"javaDoc":"Creates the radio buttons to select the font size the panel containing the radio buttons","comments":"Add radio buttons to button group \n      Creates the radio buttons to select the font size.\n      @return the panel containing the radio buttons\n   ","isEmpty":false,"lineCount":18,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"isSelected":5,"setFont":1,"repaint":1,"getSelectedItem":1},"constants":{"24":1,"36":1,"48":1},"annotations":[],"types":{"String":1,"int":5},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","CastExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["Casting","FinalVariables"],"exceptions":[],"text":"/**\n      Gets user choice for font name, style, and size\n      and sets the font of the text sample.\n   */\npublic void setLabelFont() {\n    // Get font name   \n    String facename = (String) facenameCombo.getSelectedItem();\n    // Get font style\n    int style = 0;\n    if (italicCheckBox.isSelected()) {\n        style = style + Font.ITALIC;\n    }\n    if (boldCheckBox.isSelected()) {\n        style = style + Font.BOLD;\n    }\n    // Get font size   \n    int size = 0;\n    final int SMALL_SIZE = 24;\n    final int MEDIUM_SIZE = 36;\n    final int LARGE_SIZE = 48;\n    if (smallButton.isSelected()) {\n        size = SMALL_SIZE;\n    } else if (mediumButton.isSelected()) {\n        size = MEDIUM_SIZE;\n    } else if (largeButton.isSelected()) {\n        size = LARGE_SIZE;\n    }\n    // Set font of text field\n    label.setFont(new Font(facename, style, size));\n    label.repaint();\n}\n","name":"setLabelFont","className":"FontFrame","variables":{"SMALL_SIZE":2,"facenameCombo":1,"label":2,"LARGE_SIZE":2,"facename":2,"smallButton":1,"mediumButton":1,"largeButton":1,"size":5,"style":6,"MEDIUM_SIZE":2,"italicCheckBox":1,"boldCheckBox":1},"javaDoc":"Gets user choice for font name style and size and sets the font of the text sample","comments":"Get font style Get font size Set font of text field Get font name \n      Gets user choice for font name, style, and size\n      and sets the font of the text sample.\n   ","isEmpty":false,"lineCount":14,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"true":1,"\"FontViewer\"":1},"annotations":[],"types":{"JFrame":1,"FontFrame":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new FontFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"FontViewer\");\n    frame.setVisible(true);\n}\n","name":"main","className":"FontViewer","variables":{"args":1,"frame":4},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"\"Calculator\"":1,"true":1},"annotations":[],"types":{"JFrame":1,"CalculatorFrame":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new CalculatorFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"Calculator\");\n    frame.setVisible(true);\n}\n","name":"main","className":"CalculatorViewer","variables":{"args":1,"frame":4},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"CalculatorFrame","methodCalls":{"add":1,"createControlPanel":1,"createButtonPanel":1,"setSize":1},"constants":{"\"0\"":1,"\"=\"":1,"true":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public CalculatorFrame() {\n    createButtonPanel();\n    createControlPanel();\n    display = new JLabel(\"0\");\n    add(display, BorderLayout.NORTH);\n    lastValue = 0;\n    lastOperator = \"=\";\n    startNewValue = true;\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"CalculatorFrame","className":"CalculatorFrame","variables":{"lastValue":1,"lastOperator":1,"display":1,"startNewValue":1},"javaDoc":"","isEmpty":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":17,"setLayout":1,"makeDigitButton":11,"makeOperatorButton":5},"constants":{"\"=\"":1,"\"9\"":1,"\"8\"":1,"\"7\"":1,"\"6\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"\"1\"":1,"\"0\"":1,"\"/\"":1,"\".\"":1,"\"-\"":1,"\"+\"":1,"\"*\"":1},"annotations":[],"types":{"JPanel":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates the control panel with the text field \n      and buttons on the frame.\n   */\nprivate void createButtonPanel() {\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 4));\n    buttonPanel.add(makeDigitButton(\"7\"));\n    buttonPanel.add(makeDigitButton(\"8\"));\n    buttonPanel.add(makeDigitButton(\"9\"));\n    buttonPanel.add(makeOperatorButton(\"/\"));\n    buttonPanel.add(makeDigitButton(\"4\"));\n    buttonPanel.add(makeDigitButton(\"5\"));\n    buttonPanel.add(makeDigitButton(\"6\"));\n    buttonPanel.add(makeOperatorButton(\"*\"));\n    buttonPanel.add(makeDigitButton(\"1\"));\n    buttonPanel.add(makeDigitButton(\"2\"));\n    buttonPanel.add(makeDigitButton(\"3\"));\n    buttonPanel.add(makeOperatorButton(\"-\"));\n    buttonPanel.add(makeDigitButton(\"0\"));\n    buttonPanel.add(makeDigitButton(\".\"));\n    buttonPanel.add(makeOperatorButton(\"=\"));\n    buttonPanel.add(makeOperatorButton(\"+\"));\n    add(buttonPanel, BorderLayout.CENTER);\n}\n","name":"createButtonPanel","className":"CalculatorFrame","variables":{"buttonPanel":18},"javaDoc":"Creates the control panel with the text field and buttons on the frame","comments":"\n      Creates the control panel with the text field \n      and buttons on the frame.\n   ","isEmpty":false,"lineCount":19,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"tan":1,"log":2,"getText":1,"cos":1,"equals":8,"isSelected":3,"sin":1,"pow":1,"toRadians":1,"getSelectedItem":1,"setText":1},"constants":{"\"cos\"":2,"\"\"":1,"\"log\"":1,"\"tan\"":2,"\"sin\"":2,"true":1,"\"exp\"":1,"10":1},"annotations":[],"types":{"boolean":1,"double":2,"String":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","CastExpr","StringLiteralExpr","FieldAccessExpr","EnclosedExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    double value = Double.parseDouble(display.getText());\n    String mathOp = (String) mathOpCombo.getSelectedItem();\n    double base = 10;\n    if (baseeButton.isSelected()) {\n        base = Math.E;\n    } else if (base2Button.isSelected()) {\n        base = 2;\n    }\n    boolean radian = radianCheckBox.isSelected();\n    if (!radian && (mathOp.equals(\"sin\") || mathOp.equals(\"cos\") || mathOp.equals(\"tan\"))) {\n        value = Math.toRadians(value);\n    }\n    if (mathOp.equals(\"sin\")) {\n        value = Math.sin(value);\n    } else if (mathOp.equals(\"cos\")) {\n        value = Math.cos(value);\n    } else if (mathOp.equals(\"tan\")) {\n        value = Math.tan(value);\n    } else if (mathOp.equals(\"log\")) {\n        value = Math.log(value) / Math.log(base);\n    } else if (mathOp.equals(\"exp\")) {\n        value = Math.pow(base, value);\n    }\n    display.setText(\"\" + value);\n    startNewValue = true;\n}\n","name":"actionPerformed","className":"MathOpListener","variables":{"base2Button":1,"mathOp":9,"display":2,"Math":7,"Double":1,"radian":2,"radianCheckBox":1,"baseeButton":1,"startNewValue":1,"mathOpCombo":1,"event":1,"value":8,"base":3},"javaDoc":"","isEmpty":false,"lineCount":9,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":6,"setSelected":1,"setBorder":1},"constants":{"\"10\"":1,"\"2\"":1,"true":1,"\"Base\"":1,"\"e\"":1},"annotations":[],"types":{"JPanel":1,"ButtonGroup":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private JPanel createBaseButtons() {\n    baseeButton = new JRadioButton(\"e\");\n    base10Button = new JRadioButton(\"10\");\n    base2Button = new JRadioButton(\"2\");\n    baseeButton.setSelected(true);\n    ButtonGroup group = new ButtonGroup();\n    group.add(baseeButton);\n    group.add(base10Button);\n    group.add(base2Button);\n    JPanel basePanel = new JPanel();\n    basePanel.add(baseeButton);\n    basePanel.add(base10Button);\n    basePanel.add(base2Button);\n    basePanel.setBorder(new TitledBorder(new EtchedBorder(), \"Base\"));\n    return basePanel;\n}\n","name":"createBaseButtons","className":"CalculatorFrame","variables":{"base10Button":1,"base2Button":1,"baseeButton":2,"basePanel":6,"group":4},"javaDoc":"","isEmpty":false,"lineCount":14,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5,"addItem":5,"setSelected":1,"addActionListener":1,"createBaseButtons":1},"constants":{"\"Radian\"":1,"\"cos\"":1,"\"log\"":1,"\"tan\"":1,"true":1,"\"sin\"":1,"\"exp\"":1,"\"Apply\"":1},"annotations":[],"types":{"JPanel":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void createControlPanel() {\n    radianCheckBox = new JCheckBox(\"Radian\");\n    radianCheckBox.setSelected(true);\n    mathOpCombo = new JComboBox();\n    mathOpCombo.addItem(\"sin\");\n    mathOpCombo.addItem(\"cos\");\n    mathOpCombo.addItem(\"tan\");\n    mathOpCombo.addItem(\"log\");\n    mathOpCombo.addItem(\"exp\");\n    mathOpButton = new JButton(\"Apply\");\n    mathOpButton.addActionListener(new MathOpListener());\n    JPanel controlPanel = new JPanel();\n    controlPanel.add(radianCheckBox);\n    controlPanel.add(createBaseButtons());\n    controlPanel.add(mathOpCombo);\n    controlPanel.add(mathOpButton);\n    add(controlPanel, BorderLayout.SOUTH);\n}\n","name":"createControlPanel","className":"CalculatorFrame","variables":{"controlPanel":5,"mathOpButton":2,"mathOpCombo":6,"radianCheckBox":2},"javaDoc":"","isEmpty":false,"lineCount":16,"modifier":2}
{"paramTypes":["double","double","String"],"returnType":"double","methodCalls":{"equals":4},"constants":{"\"/\"":1,"\"-\"":1,"\"+\"":1,"\"*\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Combines two values with an operator.\n      @param value1 the first value\n      @param value2 the second value\n      @param op an operator (+, -, *, /, or =)\n   */\npublic double calculate(double value1, double value2, String op) {\n    if (op.equals(\"+\")) {\n        return value1 + value2;\n    } else if (op.equals(\"-\")) {\n        return value1 - value2;\n    } else if (op.equals(\"*\")) {\n        return value1 * value2;\n    } else if (op.equals(\"/\")) {\n        return value1 / value2;\n    } else // \"=\"\n    {\n        return value2;\n    }\n}\n","name":"calculate","className":"CalculatorFrame","variables":{"op":5,"value2":6,"value1":5},"javaDoc":"Combines two values with an operator value1 the first value value2 the second value op an operator (+ - / or =)","comments":"\"=\" \n      Combines two values with an operator.\n      @param value1 the first value\n      @param value2 the second value\n      @param op an operator (+, -, *, /, or =)\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"DigitButtonListener","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      */\npublic DigitButtonListener(String aDigit) {\n    digit = aDigit;\n}\n","name":"DigitButtonListener","className":"DigitButtonListener","variables":{"aDigit":2,"digit":1},"javaDoc":"Constructs a listener whose actionPerformed method adds a digit to the display aDigit the digit to add","comments":"\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":1,"setText":2},"constants":{"\"\"":1,"false":1},"annotations":[],"types":{},"expressions":["BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    if (startNewValue) {\n        display.setText(\"\");\n        startNewValue = false;\n    }\n    display.setText(display.getText() + digit);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"startNewValue":2,"display":3,"event":1,"digit":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{"addActionListener":1},"constants":{},"annotations":[],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   */\npublic JButton makeDigitButton(String digit) {\n    JButton button = new JButton(digit);\n    ActionListener listener = new DigitButtonListener(digit);\n    button.addActionListener(listener);\n    return button;\n}\n","name":"makeDigitButton","className":"CalculatorFrame","variables":{"button":3,"listener":1,"digit":3},"javaDoc":"Makes a button representing a digit of a calculator digit the digit of the calculator the button of the calculator","comments":"\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String"],"returnType":"OperatorButtonListener","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Constructs a listener whose actionPerformed method\n         schedules an operator for execution.\n      */\npublic OperatorButtonListener(String anOperator) {\n    operator = anOperator;\n}\n","name":"OperatorButtonListener","className":"OperatorButtonListener","variables":{"anOperator":2,"operator":1},"javaDoc":"Constructs a listener whose actionPerformed method schedules an operator for execution","comments":"\n         Constructs a listener whose actionPerformed method\n         schedules an operator for execution.\n      ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"getText":1,"calculate":1,"setText":1},"constants":{"\"\"":1,"true":1},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    if (!startNewValue) {\n        double value = Double.parseDouble(display.getText());\n        lastValue = calculate(lastValue, value, lastOperator);\n        display.setText(\"\" + lastValue);\n        startNewValue = true;\n    }\n    lastOperator = operator;\n}\n","name":"actionPerformed","className":"OperatorButtonListener","variables":{"lastValue":2,"lastOperator":1,"startNewValue":2,"display":2,"event":1,"value":1,"Double":1,"operator":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{"addActionListener":1},"constants":{},"annotations":[],"types":{"ActionListener":1,"JButton":1,"OperatorButtonListener":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calculator\n   */\npublic JButton makeOperatorButton(String op) {\n    JButton button = new JButton(op);\n    ActionListener listener = new OperatorButtonListener(op);\n    button.addActionListener(listener);\n    return button;\n}\n","name":"makeOperatorButton","className":"CalculatorFrame","variables":{"button":3,"op":3,"listener":1},"javaDoc":"Makes a button representing an operator of a calculator op the operator of the calculator the button of the calculator","comments":"\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calculator\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"constants":{"true":1},"annotations":[],"types":{"InvestmentFrame2":1,"JFrame":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new InvestmentFrame2();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer2","variables":{"args":1,"frame":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"InvestmentFrame2","methodCalls":{"createPanel":1,"setSize":1,"createButton":1,"createTextField":1},"constants":{"\"Balance: \"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public InvestmentFrame2() {\n    balance = INITIAL_BALANCE;\n    resultLabel = new JLabel(\"Balance: \" + balance);\n    createTextField();\n    createButton();\n    createPanel();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"InvestmentFrame2","className":"InvestmentFrame2","variables":{"balance":2,"INITIAL_BALANCE":1,"resultLabel":1},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"constants":{"\"\"":1,"\"Interest Rate: \"":1,"10":1},"annotations":[],"types":{"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"private void createTextField() {\n    rateLabel = new JLabel(\"Interest Rate: \");\n    final int FIELD_WIDTH = 10;\n    rateField = new JTextField(FIELD_WIDTH);\n    rateField.setText(\"\" + DEFAULT_RATE);\n}\n","name":"createTextField","className":"InvestmentFrame2","variables":{"rateLabel":1,"DEFAULT_RATE":1,"FIELD_WIDTH":2,"rateField":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"getText":1,"setText":1},"constants":{"100":1,"\"Balance: \"":1},"annotations":[],"types":{"double":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    double rate = Double.parseDouble(rateField.getText());\n    double interest = balance * rate / 100;\n    balance = balance + interest;\n    resultLabel.setText(\"Balance: \" + balance);\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"balance":4,"rate":2,"interest":2,"rateField":1,"event":1,"Double":1,"resultLabel":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"addActionListener":1},"constants":{"\"Add Interest\"":1},"annotations":[],"types":{"ActionListener":1,"AddInterestListener":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"private void createButton() {\n    button = new JButton(\"Add Interest\");\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n}\n","name":"createButton","className":"InvestmentFrame2","variables":{"button":2,"listener":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5},"constants":{},"annotations":[],"types":{"JPanel":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void createPanel() {\n    JPanel panel = new JPanel();\n    panel.add(rateLabel);\n    panel.add(rateField);\n    panel.add(button);\n    panel.add(resultLabel);\n    add(panel);\n}\n","name":"createPanel","className":"InvestmentFrame2","variables":{"panel":5},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"true":1,"\"FontViewer\"":1},"annotations":[],"types":{"JFrame":1,"FontFrame2":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new FontFrame2();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"FontViewer\");\n    frame.setVisible(true);\n}\n","name":"main","className":"FontViewer2","variables":{"args":1,"frame":4},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"FontFrame2","methodCalls":{"add":3,"setJMenuBar":1,"setLabelFont":1,"setSize":1,"createFileMenu":1,"createFontMenu":1},"constants":{"\"Big Java\"":1,"24":1,"\"Serif\"":1},"annotations":[],"types":{"JMenuBar":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs the frame.\n   */\npublic FontFrame2() {\n    // Construct text sample     \n    label = new JLabel(\"Big Java\");\n    add(label, BorderLayout.CENTER);\n    // Construct menu      \n    JMenuBar menuBar = new JMenuBar();\n    setJMenuBar(menuBar);\n    menuBar.add(createFileMenu());\n    menuBar.add(createFontMenu());\n    facename = \"Serif\";\n    fontsize = 24;\n    fontstyle = Font.PLAIN;\n    setLabelFont();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"FontFrame2","className":"FontFrame2","variables":{"menuBar":3,"fontstyle":1,"fontsize":1,"label":1,"facename":1},"javaDoc":"Constructs the frame","comments":"Construct text sample Construct menu \n      Constructs the frame.\n   ","isEmpty":false,"lineCount":11,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"ExitItemListener","variables":{"event":1,"System":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":1,"addActionListener":1},"constants":{"\"File\"":1,"\"Exit\"":1},"annotations":[],"types":{"ActionListener":1,"ExitItemListener":1,"JMenuItem":1,"JMenu":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Creates the File menu.\n      @return the menu\n   */\npublic JMenu createFileMenu() {\n    JMenu menu = new JMenu(\"File\");\n    JMenuItem exitItem = new JMenuItem(\"Exit\");\n    ActionListener listener = new ExitItemListener();\n    exitItem.addActionListener(listener);\n    menu.add(exitItem);\n    return menu;\n}\n","name":"createFileMenu","className":"FontFrame2","variables":{"exitItem":2,"listener":1,"menu":3},"javaDoc":"Creates the File menu the menu","comments":"\n      Creates the File menu.\n      @return the menu\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":3,"createStyleMenu":1,"createSizeMenu":1,"createFaceMenu":1},"constants":{"\"Font\"":1},"annotations":[],"types":{"JMenu":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates the Font submenu.\n      @return the menu\n   */\npublic JMenu createFontMenu() {\n    JMenu menu = new JMenu(\"Font\");\n    menu.add(createFaceMenu());\n    menu.add(createSizeMenu());\n    menu.add(createStyleMenu());\n    return menu;\n}\n","name":"createFontMenu","className":"FontFrame2","variables":{"menu":5},"javaDoc":"Creates the Font submenu the menu","comments":"\n      Creates the Font submenu.\n      @return the menu\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":3,"createFaceItem":3},"constants":{"\"SansSerif\"":1,"\"Monospaced\"":1,"\"Serif\"":1,"\"Face\"":1},"annotations":[],"types":{"JMenu":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates the Face submenu.\n      @return the menu\n   */\npublic JMenu createFaceMenu() {\n    JMenu menu = new JMenu(\"Face\");\n    menu.add(createFaceItem(\"Serif\"));\n    menu.add(createFaceItem(\"SansSerif\"));\n    menu.add(createFaceItem(\"Monospaced\"));\n    return menu;\n}\n","name":"createFaceMenu","className":"FontFrame2","variables":{"menu":5},"javaDoc":"Creates the Face submenu the menu","comments":"\n      Creates the Face submenu.\n      @return the menu\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":2,"createSizeItem":2},"constants":{"\"Larger\"":1,"\"Size\"":1,"\"Smaller\"":1},"annotations":[],"types":{"JMenu":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","StringLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates the Size submenu.\n      @return the menu\n   */\npublic JMenu createSizeMenu() {\n    JMenu menu = new JMenu(\"Size\");\n    menu.add(createSizeItem(\"Smaller\", -1));\n    menu.add(createSizeItem(\"Larger\", 1));\n    return menu;\n}\n","name":"createSizeMenu","className":"FontFrame2","variables":{"menu":4},"javaDoc":"Creates the Size submenu the menu","comments":"\n      Creates the Size submenu.\n      @return the menu\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":4,"createStyleItem":4},"constants":{"\"Bold\"":1,"\"Style\"":1,"\"Bold Italic\"":1,"\"Italic\"":1,"\"Plain\"":1},"annotations":[],"types":{"JMenu":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates the Style submenu.\n      @return the menu\n   */\npublic JMenu createStyleMenu() {\n    JMenu menu = new JMenu(\"Style\");\n    menu.add(createStyleItem(\"Plain\", Font.PLAIN));\n    menu.add(createStyleItem(\"Bold\", Font.BOLD));\n    menu.add(createStyleItem(\"Italic\", Font.ITALIC));\n    menu.add(createStyleItem(\"Bold Italic\", Font.BOLD + Font.ITALIC));\n    return menu;\n}\n","name":"createStyleMenu","className":"FontFrame2","variables":{"menu":6},"javaDoc":"Creates the Style submenu the menu","comments":"\n      Creates the Style submenu.\n      @return the menu\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    facename = name;\n    setLabelFont();\n}\n","name":"actionPerformed","className":"FaceItemListener","variables":{"name":1,"event":1,"facename":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"JMenuItem","methodCalls":{"setLabelFont":1,"addActionListener":1},"constants":{},"annotations":[],"types":{"ActionListener":1,"JMenuItem":1,"FaceItemListener":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["TypeDeclarationStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"exceptions":[],"text":"/**\n      Creates a menu item to change the font face and set its action listener.\n      @param name the name of the font face\n      @return the menu item\n   */\npublic JMenuItem createFaceItem(final String name) {\n    class FaceItemListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            facename = name;\n            setLabelFont();\n        }\n    }\n    JMenuItem item = new JMenuItem(name);\n    ActionListener listener = new FaceItemListener();\n    item.addActionListener(listener);\n    return item;\n}\n","name":"createFaceItem","className":"FontFrame2","variables":{"actionPerformed":1,"item":3,"name":3,"listener":1,"event":1,"FaceItemListener":1,"facename":1},"javaDoc":"Creates a menu item to change the font face and set its action listener name the name of the font face the menu item","comments":"\n      Creates a menu item to change the font face and set its action listener.\n      @param name the name of the font face\n      @return the menu item\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    fontsize = fontsize + increment;\n    setLabelFont();\n}\n","name":"actionPerformed","className":"SizeItemListener","variables":{"fontsize":2,"increment":1,"event":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String","int"],"returnType":"JMenuItem","methodCalls":{"setLabelFont":1,"addActionListener":1},"constants":{},"annotations":[],"types":{"SizeItemListener":1,"ActionListener":1,"JMenuItem":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["TypeDeclarationStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"exceptions":[],"text":"/**\n      Creates a menu item to change the font size\n      and set its action listener.\n      @param name the name of the menu item\n      @param increment the amount by which to change the size\n      @return the menu item\n   */\npublic JMenuItem createSizeItem(String name, final int increment) {\n    class SizeItemListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            fontsize = fontsize + increment;\n            setLabelFont();\n        }\n    }\n    JMenuItem item = new JMenuItem(name);\n    ActionListener listener = new SizeItemListener();\n    item.addActionListener(listener);\n    return item;\n}\n","name":"createSizeItem","className":"FontFrame2","variables":{"actionPerformed":1,"SizeItemListener":1,"item":3,"name":2,"listener":1,"increment":2,"fontsize":2,"event":1},"javaDoc":"Creates a menu item to change the font size and set its action listener name the name of the menu item increment the amount by which to change the size the menu item","comments":"\n      Creates a menu item to change the font size\n      and set its action listener.\n      @param name the name of the menu item\n      @param increment the amount by which to change the size\n      @return the menu item\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    fontstyle = style;\n    setLabelFont();\n}\n","name":"actionPerformed","className":"StyleItemListener","variables":{"fontstyle":1,"style":1,"event":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String","int"],"returnType":"JMenuItem","methodCalls":{"setLabelFont":1,"addActionListener":1},"constants":{},"annotations":[],"types":{"ActionListener":1,"StyleItemListener":1,"JMenuItem":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["TypeDeclarationStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"exceptions":[],"text":"/**\n      Creates a menu item to change the font style\n      and set its action listener.\n      @param name the name of the menu item\n      @param style the new font style\n      @return the menu item\n   */\npublic JMenuItem createStyleItem(String name, final int style) {\n    class StyleItemListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            fontstyle = style;\n            setLabelFont();\n        }\n    }\n    JMenuItem item = new JMenuItem(name);\n    ActionListener listener = new StyleItemListener();\n    item.addActionListener(listener);\n    return item;\n}\n","name":"createStyleItem","className":"FontFrame2","variables":{"actionPerformed":1,"item":3,"fontstyle":1,"name":2,"StyleItemListener":1,"listener":1,"style":2,"event":1},"javaDoc":"Creates a menu item to change the font style and set its action listener name the name of the menu item style the new font style the menu item","comments":"\n      Creates a menu item to change the font style\n      and set its action listener.\n      @param name the name of the menu item\n      @param style the new font style\n      @return the menu item\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setFont":1},"constants":{},"annotations":[],"types":{"Font":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the font of the text sample.\n   */\npublic void setLabelFont() {\n    Font f = new Font(facename, fontstyle, fontsize);\n    label.setFont(f);\n}\n","name":"setLabelFont","className":"FontFrame2","variables":{"fontstyle":1,"fontsize":1,"label":1,"facename":1},"javaDoc":"Sets the font of the text sample","comments":"\n      Sets the font of the text sample.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":2,"translate":1},"constants":{"25":1,"15":1,"30":1,"20":1,"10":1},"annotations":[],"types":{"Rectangle":1,"Graphics2D":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void paintComponent(Graphics g) {\n    // Recover Graphics2D\n    Graphics2D g2 = (Graphics2D) g;\n    // Construct a rectangle and draw it\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    g2.draw(box);\n    // Move rectangle 15 units to the right and 25 units down\n    box.translate(15, 25);\n    // Draw moved rectangle\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent","variables":{"box":2,"g2":3},"javaDoc":"","comments":"Recover Graphics2D Construct a rectangle and draw it Move rectangle 15 units to the right and 25 units down Draw moved rectangle ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"300":1,"\"Two rectangles\"":1,"400":1,"true":1},"annotations":[],"types":{"JFrame":1,"RectangleComponent":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setTitle(\"Two rectangles\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    RectangleComponent component = new RectangleComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer","variables":{"args":1,"component":1,"frame":6},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":2,"translate":1},"constants":{"25":1,"15":1,"30":1,"20":1,"10":1},"annotations":[],"types":{"Rectangle":1,"Graphics2D":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void paintComponent(Graphics g) {\n    // Recover Graphics2D\n    Graphics2D g2 = (Graphics2D) g;\n    // Construct a rectangle and draw it\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    g2.draw(box);\n    // Move rectangle 15 units to the right and 25 units down\n    box.translate(15, 25);\n    // Draw moved rectangle\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent","variables":{"box":2,"g2":3},"javaDoc":"","comments":"Recover Graphics2D Construct a rectangle and draw it Move rectangle 15 units to the right and 25 units down Draw moved rectangle ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":4,"System.out.println":4},"constants":{"\"width: \"":4,"20":2,"10":3},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // Declares width and initializes it with 10\n    int width = 10;\n    System.out.print(\"width: \");\n    System.out.println(width);\n    // Changes width to 20\n    width = 20;\n    System.out.print(\"width: \");\n    System.out.println(width);\n    int height = 20;\n    // The right hand side can be an expression\n    width = height + 10;\n    System.out.print(\"width: \");\n    System.out.println(width);\n    // The same variable can occur on both sides\n    width = width + 10;\n    System.out.print(\"width: \");\n    System.out.println(width);\n}\n","name":"main","className":"VariableDemo","variables":{"args":1,"width":5,"height":2},"javaDoc":"","comments":"Declares width and initializes it with 10 Changes width to 20 The right hand side can be an expression The same variable can occur on both sides ","isEmpty":false,"lineCount":13,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getWidth":1,"System.out.print":4,"translate":1,"System.out.println":4},"constants":{"\"width: \"":1,"\"box: \"":3,"25":1,"15":1,"30":1,"20":1,"10":1},"annotations":[],"types":{"double":1,"Rectangle":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    System.out.print(\"box: \");\n    System.out.println(box);\n    // getWidth is an accessor method\n    double width = box.getWidth();\n    System.out.print(\"width: \");\n    System.out.println(width);\n    // Calling an accessor doesn't change the object\n    System.out.print(\"box: \");\n    System.out.println(box);\n    // translate is a mutator method\n    box.translate(15, 25);\n    // Calling a mutator changes the object.\n    System.out.print(\"box: \");\n    System.out.println(box);\n}\n","name":"main","className":"AccessorMutatorDemo","variables":{"args":1,"width":1,"box":3},"javaDoc":"","comments":"getWidth is an accessor method Calling an accessor doesn't change the object translate is a mutator method Calling a mutator changes the object ","isEmpty":false,"lineCount":15,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"300":1,"400":1,"true":1,"\"An empty frame\"":1},"annotations":[],"types":{"JFrame":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setTitle(\"An empty frame\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"EmptyFrameViewer","variables":{"args":1,"frame":5},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":2,"replace":1,"System.out.print":3,"System.out.println":4},"constants":{"\"numberOfCharacters: \"":1,"\"Mississippi\"":1,"\"river: \"":1,"\"issipp\"":1,"\"Hello, World!\"":1,"\"our\"":1,"\"greeting.length(): \"":1},"annotations":[],"types":{"String":2,"int":1},"expressions":["VariableDeclarationExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String greeting = \"Hello, World!\";\n    System.out.println(greeting);\n    // greeting is the argument in this call to the println method\n    int numberOfCharacters = greeting.length();\n    // The length method returns a value\n    System.out.print(\"numberOfCharacters: \");\n    System.out.println(numberOfCharacters);\n    // You can use the return value of one method as an argument of another method\n    System.out.print(\"greeting.length(): \");\n    System.out.println(greeting.length());\n    // The replace method has two arguments\n    String river = \"Mississippi\";\n    river = river.replace(\"issipp\", \"our\");\n    System.out.print(\"river: \");\n    System.out.println(river);\n}\n","name":"main","className":"MethodDemo","variables":{"args":1,"greeting":3,"numberOfCharacters":1,"river":3},"javaDoc":"","comments":"The length method returns a value You can use the return value of one method as an argument of another method greeting is the argument in this call to the println method The replace method has two arguments ","isEmpty":false,"lineCount":13,"modifier":9}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":3,"draw":2,"fill":2,"translate":1,"drawString":1},"constants":{"110":2,"100":1,"25":1,"15":2,"80":1,"70":1,"\"Hello, World!\"":1,"50":1,"150":1,"30":1,"10":1,"175":1},"annotations":[],"types":{"Line2D.Double":1,"Ellipse2D.Double":1,"Rectangle":1,"Graphics2D":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","CastExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void paintComponent(Graphics g) {\n    // Recover Graphics2D \n    Graphics2D g2 = (Graphics2D) g;\n    // Draw the head\n    Ellipse2D.Double head = new Ellipse2D.Double(5, 10, 100, 150);\n    g2.draw(head);\n    // Draw the eyes\n    g2.setColor(Color.GREEN);\n    Rectangle eye = new Rectangle(25, 70, 15, 15);\n    g2.fill(eye);\n    eye.translate(50, 0);\n    g2.fill(eye);\n    // Draw the mouth\n    Line2D.Double mouth = new Line2D.Double(30, 110, 80, 110);\n    g2.setColor(Color.RED);\n    g2.draw(mouth);\n    // Draw the greeting\n    g2.setColor(Color.BLUE);\n    g2.drawString(\"Hello, World!\", 5, 175);\n}\n","name":"paintComponent","className":"FaceComponent","variables":{"head":1,"eye":2,"mouth":1,"g2":9},"javaDoc":"","comments":"Recover Graphics2D Draw the head Draw the eyes Draw the mouth Draw the greeting ","isEmpty":false,"lineCount":13,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"\"An Alien Face\"":1,"true":1,"150":1,"250":1},"annotations":[],"types":{"JFrame":1,"FaceComponent":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(150, 250);\n    frame.setTitle(\"An Alien Face\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    FaceComponent component = new FaceComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"FaceViewer","variables":{"args":1,"component":1,"frame":6},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"daysFrom":1,"toString":1,"System.out.print":2,"System.out.println":2},"constants":{"\"Days alive: \"":1,"19":1,"\"Today: \"":1,"1955":1},"annotations":[],"types":{"Day":2,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Day jamesGoslingsBirthday = new Day(1955, 5, 19);\n    Day today = new Day();\n    System.out.print(\"Today: \");\n    System.out.println(today.toString());\n    int daysAlive = today.daysFrom(jamesGoslingsBirthday);\n    System.out.print(\"Days alive: \");\n    System.out.println(daysAlive);\n}\n","name":"main","className":"DaysAlivePrinter","variables":{"args":1,"daysAlive":1,"jamesGoslingsBirthday":1,"today":3},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"Day","methodCalls":{"get":3},"constants":{},"annotations":[],"types":{"GregorianCalendar":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a day object representing today's date.\n   */\npublic Day() {\n    GregorianCalendar today = new GregorianCalendar();\n    year = today.get(GregorianCalendar.YEAR);\n    month = today.get(GregorianCalendar.MONTH) + 1;\n    date = today.get(GregorianCalendar.DAY_OF_MONTH);\n}\n","name":"Day","className":"Day","variables":{"date":1,"month":1,"year":1,"today":4},"javaDoc":"Constructs a day object representing today's date","comments":"\n      Constructs a day object representing today's date.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"Day","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a day with a given year, month, and day\n      of the Julian/Gregorian calendar. The Julian calendar\n      is used for all days before October 15, 1582\n      @param aYear a year != 0\n      @param aMonth a month between 1 and 12\n      @param aDate a date between 1 and 31\n   */\npublic Day(int aYear, int aMonth, int aDate) {\n    year = aYear;\n    month = aMonth;\n    date = aDate;\n}\n","name":"Day","className":"Day","variables":{"date":1,"month":1,"year":1,"aMonth":2,"aDate":2,"aYear":2},"javaDoc":"Constructs a day with a given year month and day of the Julian/Gregorian calendar The Julian calendar is used for all days before October 15 1582 aYear a year != 0 aMonth a month between 1 and 12 aDate a date between 1 and 31","comments":"\n      Constructs a day with a given year, month, and day\n      of the Julian/Gregorian calendar. The Julian calendar\n      is used for all days before October 15, 1582\n      @param aYear a year != 0\n      @param aMonth a month between 1 and 12\n      @param aDate a date between 1 and 31\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the year of this day.\n      @return the year\n   */\npublic int getYear() {\n    return year;\n}\n","name":"getYear","className":"Day","variables":{"year":1},"javaDoc":"Returns the year of this day the year","comments":"\n      Returns the year of this day.\n      @return the year\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the month of this day.\n      @return the month\n   */\npublic int getMonth() {\n    return month;\n}\n","name":"getMonth","className":"Day","variables":{"month":1},"javaDoc":"Returns the month of this day the month","comments":"\n      Returns the month of this day.\n      @return the month\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the day of the month of this day.\n      @return the day of the month\n   */\npublic int getDate() {\n    return date;\n}\n","name":"getDate","className":"Day","variables":{"date":1},"javaDoc":"Returns the day of the month of this day the day of the month","comments":"\n      Returns the day of the month of this day.\n      @return the day of the month\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Day","methodCalls":{"nextDay":1,"previousDay":1},"constants":{},"annotations":[],"types":{"Day":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns a day that is a certain number of days away from\n      this day.\n      @param n the number of days, can be negative\n      @return a day that is n days away from this one\n   */\npublic Day addDays(int n) {\n    Day result = this;\n    while (n > 0) {\n        result = result.nextDay();\n        n--;\n    }\n    while (n < 0) {\n        result = result.previousDay();\n        n++;\n    }\n    return result;\n}\n","name":"addDays","className":"Day","variables":{"result":6},"javaDoc":"Returns a day that is a certain number of days away from this day n the number of days can be negative a day that is n days away from this one","comments":"\n      Returns a day that is a certain number of days away from\n      this day.\n      @param n the number of days, can be negative\n      @return a day that is n days away from this one\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Day"],"returnType":"int","methodCalls":{"compareTo":2,"previousDay":1,"nextDay":1},"constants":{},"annotations":[],"types":{"Day":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","ThisExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the number of days between this day and another\n      day.\n      @param other the other day\n      @return the number of days that this day is away from \n      the other (larger than 0 if this day comes later than <code>other</code>)\n   */\npublic int daysFrom(Day other) {\n    int n = 0;\n    Day d = this;\n    while (d.compareTo(other) > 0) {\n        d = d.previousDay();\n        n++;\n    }\n    while (d.compareTo(other) < 0) {\n        d = d.nextDay();\n        n--;\n    }\n    return n;\n}\n","name":"daysFrom","className":"Day","variables":{"other":1},"javaDoc":"Returns the number of days between this day and another day other the other day the number of days that this day is away from the other (larger than 0 if this day comes later than <code>other</code>)","comments":"\n      Returns the number of days between this day and another\n      day.\n      @param other the other day\n      @return the number of days that this day is away from \n      the other (larger than 0 if this day comes later than <code>other</code>)\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1},"constants":{"\"%04d-%02d-%02d\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return String.format(\"%04d-%02d-%02d\", year, month, date);\n}\n","name":"toString","className":"Day","variables":{"String":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Day"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["IfStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Compares this day with another day.\n      @param other the other day\n      @return a positive number if this day comes after the\n      other day, a negative number if this day comes before\n      the other day, and zero if the days are the same\n   */\nprivate int compareTo(Day other) {\n    if (year > other.year)\n        return 1;\n    if (year < other.year)\n        return -1;\n    if (month > other.month)\n        return 1;\n    if (month < other.month)\n        return -1;\n    return date - other.date;\n}\n","name":"compareTo","className":"Day","variables":{"date":1,"other":1,"month":2,"year":2},"javaDoc":"Compares this day with another day other the other day a positive number if this day comes after the other day a negative number if this day comes before the other day and zero if the days are the same","comments":"\n      Compares this day with another day.\n      @param other the other day\n      @return a positive number if this day comes after the\n      other day, a negative number if this day comes before\n      the other day, and zero if the days are the same\n   ","isEmpty":false,"lineCount":5,"modifier":2}
{"paramTypes":[],"returnType":"Day","methodCalls":{"daysPerMonth":1},"constants":{},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the next day.\n      @return the day following this day\n   */\nprivate Day nextDay() {\n    int y = year;\n    int m = month;\n    int d = date;\n    if (y == GREGORIAN_START_YEAR && m == GREGORIAN_START_MONTH && d == JULIAN_END_DAY)\n        d = GREGORIAN_START_DAY;\n    else if (d < daysPerMonth(y, m))\n        d++;\n    else {\n        d = 1;\n        m++;\n        if (m > DECEMBER) {\n            m = JANUARY;\n            y++;\n            if (y == 0)\n                y++;\n        }\n    }\n    return new Day(y, m, d);\n}\n","name":"nextDay","className":"Day","variables":{"date":1,"JANUARY":1,"month":1,"year":1,"GREGORIAN_START_MONTH":1,"GREGORIAN_START_DAY":1,"DECEMBER":1,"JULIAN_END_DAY":1,"GREGORIAN_START_YEAR":1},"javaDoc":"Computes the next day the day following this day","comments":"\n      Computes the next day.\n      @return the day following this day\n   ","isEmpty":false,"lineCount":5,"modifier":2}
{"paramTypes":[],"returnType":"Day","methodCalls":{"daysPerMonth":1},"constants":{},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the previous day.\n      @return the day preceding this day\n   */\nprivate Day previousDay() {\n    int y = year;\n    int m = month;\n    int d = date;\n    if (y == GREGORIAN_START_YEAR && m == GREGORIAN_START_MONTH && d == GREGORIAN_START_DAY)\n        d = JULIAN_END_DAY;\n    else if (d > 1)\n        d--;\n    else {\n        m--;\n        if (m < JANUARY) {\n            m = DECEMBER;\n            y--;\n            if (y == 0)\n                y--;\n        }\n        d = daysPerMonth(y, m);\n    }\n    return new Day(y, m, d);\n}\n","name":"previousDay","className":"Day","variables":{"date":1,"JANUARY":1,"month":1,"year":1,"GREGORIAN_START_MONTH":1,"GREGORIAN_START_DAY":1,"DECEMBER":1,"JULIAN_END_DAY":1,"GREGORIAN_START_YEAR":1},"javaDoc":"Computes the previous day the day preceding this day","comments":"\n      Computes the previous day.\n      @return the day preceding this day\n   ","isEmpty":false,"lineCount":5,"modifier":2}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"isLeapYear":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the days in a given month.\n      @param y the year\n      @param m the month\n      @return the last day in the given month\n   */\nprivate static int daysPerMonth(int y, int m) {\n    int days = DAYS_PER_MONTH[m - 1];\n    if (m == FEBRUARY && isLeapYear(y))\n        days++;\n    return days;\n}\n","name":"daysPerMonth","className":"Day","variables":{"days":3,"FEBRUARY":1,"DAYS_PER_MONTH":1},"javaDoc":"Gets the days in a given month y the year m the month the last day in the given month","comments":"\n      Gets the days in a given month.\n      @param y the year\n      @param m the month\n      @return the last day in the given month\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["int"],"returnType":"boolean","methodCalls":{},"constants":{"100":1,"400":1,"false":1,"true":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","EnclosedExpr"],"statements":["IfStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tests if a year is a leap year.\n      @param y the year\n      @return true if y is a leap year\n   */\nprivate static boolean isLeapYear(int y) {\n    if (y % 4 != 0)\n        return false;\n    if (y < GREGORIAN_START_YEAR)\n        return true;\n    return (y % 100 != 0) || (y % 400 == 0);\n}\n","name":"isLeapYear","className":"Day","variables":{"GREGORIAN_START_YEAR":1},"javaDoc":"Tests if a year is a leap year y the year true if y is a leap year","comments":"\n      Tests if a year is a leap year.\n      @param y the year\n      @return true if y is a leap year\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"daysFrom":1,"getYear":1,"addDays":1,"getDate":1,"getMonth":1,"System.out.println":8},"constants":{"15":1,"\"Expected: 3\"":1,"\"Expected: 2010\"":1,"\"Expected: 30\"":1,"2010":1,"\"Expected: 13\"":1,"30":1},"annotations":[],"types":{"Day":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // February 15, 2010\n    Day today = new Day(2010, 2, 15);\n    Day later = today.addDays(30);\n    System.out.println(later.getYear());\n    System.out.println(\"Expected: 2010\");\n    System.out.println(later.getMonth());\n    System.out.println(\"Expected: 3\");\n    System.out.println(later.getDate());\n    System.out.println(\"Expected: 13\");\n    System.out.println(later.daysFrom(today));\n    System.out.println(\"Expected: 30\");\n}\n","name":"main","className":"DayTester","variables":{"args":1,"later":5,"today":2},"javaDoc":"","comments":"February 15 2010 ","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"load":1},"constants":{"\"queen-mary.png\"":1},"annotations":[],"types":{"Picture":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Picture pic = new Picture();\n    pic.load(\"queen-mary.png\");\n}\n","name":"main","className":"PictureDemo","variables":{"args":1,"pic":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"border":1,"getHeight":1,"move":1,"load":1,"scale":1,"getWidth":1},"constants":{"\"queen-mary.png\"":1,"40":2,"20":2,"10":1},"annotations":[],"types":{"Picture":1,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Picture pic = new Picture();\n    pic.load(\"queen-mary.png\");\n    int newWidth = pic.getWidth() - 40;\n    int newHeight = pic.getHeight() - 40;\n    pic.scale(newWidth, newHeight);\n    pic.move(20, 20);\n    pic.border(10);\n}\n","name":"main","className":"BorderMaker","variables":{"args":1,"newWidth":1,"newHeight":1,"pic":7},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"Picture","methodCalls":{"add":1,"setVisible":1,"setDefaultCloseOperation":1,"pack":1},"constants":{"\"(No image)\"":1,"true":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a blank picture.\n   */\npublic Picture() {\n    frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    label = new JLabel(\"(No image)\");\n    frame.add(label);\n    frame.pack();\n    frame.setVisible(true);\n}\n","name":"Picture","className":"Picture","variables":{"label":1,"frame":5},"javaDoc":"Constructs a blank picture","comments":"\n      Constructs a blank picture.\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getWidth":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the width of this picture.\n      @return the width\n    */\npublic int getWidth() {\n    return image.getWidth();\n}\n","name":"getWidth","className":"Picture","variables":{"image":1},"javaDoc":"Gets the width of this picture the width","comments":"\n      Gets the width of this picture.\n      @return the width\n    ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getHeight":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the height of this picture.\n      @return the height\n    */\npublic int getHeight() {\n    return image.getHeight();\n}\n","name":"getHeight","className":"Picture","variables":{"image":1},"javaDoc":"Gets the height of this picture the height","comments":"\n      Gets the height of this picture.\n      @return the height\n    ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"read":2,"printStackTrace":1,"startsWith":1,"setImage":1},"constants":{"null":1,"\"http://\"":1},"annotations":[],"types":{"BufferedImage":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"/**\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n    */\npublic void load(String source) {\n    try {\n        this.source = source;\n        BufferedImage img;\n        if (source.startsWith(\"http://\"))\n            img = ImageIO.read(new URL(source).openStream());\n        else\n            img = ImageIO.read(new File(source));\n        setImage(img);\n    } catch (Exception ex) {\n        this.source = null;\n        ex.printStackTrace();\n    }\n}\n","name":"load","className":"Picture","variables":{"img":3,"ex":2,"source":5,"ImageIO":2},"javaDoc":"Loads a picture from a given source source the image source If the source starts with http:// it is a URL otherwise a filename","comments":"\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n    ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"load":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Reloads this picture, undoing any manipulations.\n    */\npublic void reload() {\n    load(source);\n}\n","name":"reload","className":"Picture","variables":{},"javaDoc":"Reloads this picture undoing any manipulations","comments":"\n      Reloads this picture, undoing any manipulations.\n    ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showOpenDialog":1,"load":1,"getSelectedFile":1,"getAbsolutePath":1},"constants":{"null":1,"\".\"":1},"annotations":[],"types":{"JFileChooser":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Displays a file chooser for picking a picture.\n    */\npublic void pick() {\n    JFileChooser chooser = new JFileChooser(\".\");\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        load(chooser.getSelectedFile().getAbsolutePath());\n    }\n}\n","name":"pick","className":"Picture","variables":{"chooser":3},"javaDoc":"Displays a file chooser for picking a picture","comments":"\n      Displays a file chooser for picking a picture.\n    ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"filter":1,"getTranslateInstance":1,"getHeight":1,"getWidth":1,"setImage":1},"constants":{},"annotations":[],"types":{"BufferedImageOp":1,"BufferedImage":1,"AffineTransformOp":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Moves this picture by the given amount in x- and y-direction. \n      @param dx the offset in the x-direction\n      @param dy the offset in the y-direction\n    */\npublic void move(int dx, int dy) {\n    BufferedImageOp op = new AffineTransformOp(AffineTransform.getTranslateInstance(dx, dy), AffineTransformOp.TYPE_BILINEAR);\n    BufferedImage filteredImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);\n    op.filter(image, filteredImage);\n    setImage(filteredImage);\n}\n","name":"move","className":"Picture","variables":{"op":2,"image":2,"dx":1,"dy":1,"AffineTransform":1,"filteredImage":1},"javaDoc":"Moves this picture by the given amount in x- and y-direction dx the offset in the x-direction dy the offset in the y-direction","comments":"\n      Moves this picture by the given amount in x- and y-direction. \n      @param dx the offset in the x-direction\n      @param dy the offset in the y-direction\n    ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"filter":1,"getHeight":2,"getWidth":2,"getScaleInstance":1,"setImage":1},"constants":{"1.0":2},"annotations":[],"types":{"BufferedImageOp":1,"double":2,"BufferedImage":1,"AffineTransformOp":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Scales this picture to a new size. If the new size is smaller \n      than the old size, the remainder is filled with transparent \n      pixels. If it is larger, it is clipped.\n      @param newWidth the new width of the picture\n      @param newHeight the new height of the picture\n   */\npublic void scale(int newWidth, int newHeight) {\n    double dx = newWidth * 1.0 / image.getWidth();\n    double dy = newHeight * 1.0 / image.getHeight();\n    BufferedImageOp op = new AffineTransformOp(AffineTransform.getScaleInstance(dx, dy), AffineTransformOp.TYPE_BILINEAR);\n    BufferedImage filteredImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);\n    op.filter(image, filteredImage);\n    setImage(filteredImage);\n}\n","name":"scale","className":"Picture","variables":{"image":4,"op":2,"newWidth":2,"dx":1,"dy":1,"newHeight":2,"AffineTransform":1,"filteredImage":1},"javaDoc":"Scales this picture to a new size If the new size is smaller than the old size the remainder is filled with transparent pixels If it is larger it is clipped newWidth the new width of the picture newHeight the new height of the picture","comments":"\n      Scales this picture to a new size. If the new size is smaller \n      than the old size, the remainder is filled with transparent \n      pixels. If it is larger, it is clipped.\n      @param newWidth the new width of the picture\n      @param newHeight the new height of the picture\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getHeight":2,"setColorAt":4,"getWidth":2},"constants":{},"annotations":[],"types":{"int":4},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a black border to the image.\n      @param width the border width\n   */\npublic void border(int width) {\n    for (int x = 0; x < width; x++) {\n        for (int y = 0; y < image.getHeight(); y++) {\n            setColorAt(x, y, Color.BLACK);\n            setColorAt(image.getWidth() - 1 - x, y, Color.BLACK);\n        }\n    }\n    for (int y = 0; y < width; y++) {\n        for (int x = width; x < image.getWidth() - width; x++) {\n            setColorAt(x, y, Color.BLACK);\n            setColorAt(x, image.getHeight() - 1 - y, Color.BLACK);\n        }\n    }\n}\n","name":"border","className":"Picture","variables":{"image":4,"width":5},"javaDoc":"Adds a black border to the image width the border width","comments":"\n      Adds a black border to the image.\n      @param width the border width\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Color","methodCalls":{"getColorModel":1,"getDataElements":1,"getRaster":1,"getRGB":1},"constants":{"null":1,"true":1},"annotations":[],"types":{"ColorModel":1,"Raster":1,"int":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   */\npublic Color getColorAt(int x, int y) {\n    Raster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    int argb = model.getRGB(raster.getDataElements(x, y, null));\n    return new Color(argb, true);\n}\n","name":"getColorAt","className":"Picture","variables":{"image":2,"argb":2,"raster":2,"model":2},"javaDoc":"Gets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) the color of the pixel at position (x y)","comments":"\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int","Color"],"returnType":"void","methodCalls":{"getColorModel":1,"getDataElements":1,"setDataElements":1,"repaint":1,"getRaster":1,"getRGB":1},"constants":{"null":1},"annotations":[],"types":{"WritableRaster":1,"ColorModel":1,"Object":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   */\npublic void setColorAt(int x, int y, Color c) {\n    WritableRaster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    Object colorData = model.getDataElements(c.getRGB(), null);\n    raster.setDataElements(x, y, colorData);\n    label.repaint();\n}\n","name":"setColorAt","className":"Picture","variables":{"image":2,"colorData":1,"raster":2,"model":2,"label":1},"javaDoc":"Sets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) c the color for the pixel at position (x y)","comments":"\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["BufferedImage"],"returnType":"void","methodCalls":{"setIcon":1,"getHeight":1,"setSize":1,"getWidth":1,"pack":1,"setText":1},"constants":{"\"\"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void setImage(BufferedImage image) {\n    this.image = image;\n    label.setIcon(new ImageIcon(image));\n    label.setText(\"\");\n    label.setSize(image.getWidth(), image.getHeight());\n    frame.pack();\n}\n","name":"setImage","className":"Picture","variables":{"image":5,"label":3,"frame":1},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"translate":1,"System.out.print":2,"System.out.println":4},"constants":{"\"x: \"":1,"25":1,"\"y: \"":1,"15":1,"\"Expected: 20\"":1,"\"Expected: 35\"":1,"30":1,"20":1,"10":1},"annotations":[],"types":{"Rectangle":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    // Move the rectangle\n    box.translate(15, 25);\n    // Print information about the moved rectangle \n    System.out.print(\"x: \");\n    System.out.println(box.getX());\n    System.out.println(\"Expected: 20\");\n    System.out.print(\"y: \");\n    System.out.println(box.getY());\n    System.out.println(\"Expected: 35\");\n}\n","name":"main","className":"MoveTester","variables":{"args":1,"box":4},"javaDoc":"","comments":"Move the rectangle Print information about the moved rectangle ","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":8,"translate":1,"System.out.println":10},"constants":{"12":1,"13":1,"25":1,"15":1,"\"luckyNumber2: \"":2,"\"luckyNumber: \"":2,"\"box: \"":2,"\"Mutating box2\"":1,"\"box2: \"":2,"\"Changing luckyNumber2\"":1,"30":1,"20":1,"10":1},"annotations":[],"types":{"Rectangle":2,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // Declare two object variables and copy the first into the second\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    Rectangle box2 = box;\n    // Both variables refer to the same object\n    System.out.print(\"box: \");\n    System.out.println(box);\n    System.out.print(\"box2: \");\n    System.out.println(box2);\n    System.out.println(\"Mutating box2\");\n    box2.translate(15, 25);\n    // Both variables refer to the mutated object\n    System.out.print(\"box: \");\n    System.out.println(box);\n    System.out.print(\"box2: \");\n    System.out.println(box2);\n    // Declare two number variables and copy the first into the second\n    int luckyNumber = 13;\n    int luckyNumber2 = luckyNumber;\n    System.out.print(\"luckyNumber: \");\n    System.out.println(luckyNumber);\n    System.out.print(\"luckyNumber2: \");\n    System.out.println(luckyNumber2);\n    System.out.println(\"Changing luckyNumber2\");\n    luckyNumber2 = 12;\n    // Only the second number changes.\n    System.out.print(\"luckyNumber: \");\n    System.out.println(luckyNumber);\n    System.out.print(\"luckyNumber2: \");\n    System.out.println(luckyNumber2);\n}\n","name":"main","className":"CopyDemo","variables":{"args":1,"luckyNumber2":2,"luckyNumber":2,"box2":2,"box":2},"javaDoc":"","comments":"Declare two object variables and copy the first into the second Both variables refer to the same object Both variables refer to the mutated object Declare two number variables and copy the first into the second Only the second number changes ","isEmpty":false,"lineCount":29,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":2,"System.out.println":3},"constants":{"\"box: \"":2,"30":2,"20":2,"10":2},"annotations":[],"types":{"Rectangle":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // Constructs and prints a rectangle\n    System.out.println(new Rectangle(5, 10, 20, 30));\n    // Constructs a rectangle and saves it in a variable\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    System.out.print(\"box: \");\n    System.out.println(box);\n    // The constructor with no arguments\n    box = new Rectangle();\n    System.out.print(\"box: \");\n    System.out.println(box);\n}\n","name":"main","className":"ConstructorDemo","variables":{"args":1,"box":2},"javaDoc":"","comments":"Constructs and prints a rectangle Constructs a rectangle and saves it in a variable The constructor with no arguments ","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":1,"parse":1,"System.out.println":1},"constants":{"\"items.xml\"":1},"annotations":[],"types":{"ArrayList<LineItem>":1,"LineItem":1,"ItemListParser":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"public static void main(String[] args) throws Exception {\n    ItemListParser parser = new ItemListParser();\n    ArrayList<LineItem> items = parser.parse(\"items.xml\");\n    for (LineItem anItem : items) {\n        System.out.println(anItem.format());\n    }\n}\n","name":"main","className":"ItemListParserDemo","variables":{"args":1,"parser":2,"anItem":2,"items":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Product","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   */\npublic Product(String aDescription, double aPrice) {\n    description = aDescription;\n    price = aPrice;\n}\n","name":"Product","className":"Product","variables":{"aDescription":2,"price":1,"description":1,"aPrice":2},"javaDoc":"Constructs a product from a description and a price aDescription the product description aPrice the product price","comments":"\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the product description.\n      @return the description\n   */\npublic String getDescription() {\n    return description;\n}\n","name":"getDescription","className":"Product","variables":{"description":1},"javaDoc":"Gets the product description the description","comments":"\n      Gets the product description.\n      @return the description\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the product price.\n      @return the unit price\n   */\npublic double getPrice() {\n    return price;\n}\n","name":"getPrice","className":"Product","variables":{"price":1},"javaDoc":"Gets the product price the unit price","comments":"\n      Gets the product price.\n      @return the unit price\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ItemListParser","methodCalls":{"newDocumentBuilder":1,"newXPath":1,"newInstance":2},"constants":{},"annotations":[],"types":{"XPathFactory":1,"DocumentBuilderFactory":1},"expressions":["VariableDeclarationExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":["ParserConfigurationException"],"text":"/**\n      Constructs a parser that can parse item lists.\n   */\npublic ItemListParser() throws ParserConfigurationException {\n    DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();\n    builder = dbfactory.newDocumentBuilder();\n    XPathFactory xpfactory = XPathFactory.newInstance();\n    path = xpfactory.newXPath();\n}\n","name":"ItemListParser","className":"ItemListParser","variables":{"xpfactory":2,"XPathFactory":1,"path":1,"DocumentBuilderFactory":1,"dbfactory":2,"builder":1},"javaDoc":"Constructs a parser that can parse item lists","comments":"\n      Constructs a parser that can parse item lists.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String"],"returnType":"ArrayList<LineItem>","methodCalls":{"parseInt":2,"parseDouble":1,"add":1,"parse":1,"evaluate":4},"constants":{"\"]/product/price\"":1,"\"count(/items/item)\"":1,"\"]/product/description\"":1,"\"/items/item[\"":3,"\"]/quantity\"":1},"annotations":[],"types":{"ArrayList<LineItem>":1,"double":1,"ArrayList":1,"Product":1,"LineItem":1,"String":1,"Document":1,"File":1,"int":3},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["XPathExpressionException","IOException","SAXException"],"text":"/**\n      Parses an XML file containing an item list.\n      @param fileName the name of the file\n      @return an array list containing all items in the XML file\n   */\npublic ArrayList<LineItem> parse(String fileName) throws SAXException, IOException, XPathExpressionException {\n    File f = new File(fileName);\n    Document doc = builder.parse(f);\n    ArrayList<LineItem> items = new ArrayList<>();\n    int itemCount = Integer.parseInt(path.evaluate(\"count(/items/item)\", doc));\n    for (int i = 1; i <= itemCount; i++) {\n        String description = path.evaluate(\"/items/item[\" + i + \"]/product/description\", doc);\n        double price = Double.parseDouble(path.evaluate(\"/items/item[\" + i + \"]/product/price\", doc));\n        Product pr = new Product(description, price);\n        int quantity = Integer.parseInt(path.evaluate(\"/items/item[\" + i + \"]/quantity\", doc));\n        LineItem it = new LineItem(pr, quantity);\n        items.add(it);\n    }\n    return items;\n}\n","name":"parse","className":"ItemListParser","variables":{"fileName":2,"pr":2,"quantity":2,"description":2,"it":1,"Double":1,"itemCount":2,"Integer":2,"path":4,"price":2,"builder":1,"doc":1,"items":3},"javaDoc":"Parses an XML file containing an item list fileName the name of the file an array list containing all items in the XML file","comments":"\n      Parses an XML file containing an item list.\n      @param fileName the name of the file\n      @return an array list containing all items in the XML file\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["Product","int"],"returnType":"LineItem","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   */\npublic LineItem(Product aProduct, int aQuantity) {\n    theProduct = aProduct;\n    quantity = aQuantity;\n}\n","name":"LineItem","className":"LineItem","variables":{"quantity":1,"aProduct":2,"aQuantity":2,"theProduct":1},"javaDoc":"Constructs an item from the product and quantity aProduct the product aQuantity the item quantity","comments":"\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getPrice":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the total cost of this line item.\n      @return the total price\n   */\npublic double getTotalPrice() {\n    return theProduct.getPrice() * quantity;\n}\n","name":"getTotalPrice","className":"LineItem","variables":{"quantity":1,"theProduct":1},"javaDoc":"Computes the total cost of this line item the total price","comments":"\n      Computes the total cost of this line item.\n      @return the total price\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1,"getTotalPrice":1,"getDescription":1,"getPrice":1},"constants":{"\"%-30s%8.2f%5d%8.2f\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Formats this item.\n      @return a formatted string of this item\n   */\npublic String format() {\n    return String.format(\"%-30s%8.2f%5d%8.2f\", theProduct.getDescription(), theProduct.getPrice(), quantity, getTotalPrice());\n}\n","name":"format","className":"LineItem","variables":{"String":1,"theProduct":2},"javaDoc":"Formats this item a formatted string of this item","comments":"\n      Formats this item.\n      @return a formatted string of this item\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","double"],"returnType":"Product","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   */\npublic Product(String aDescription, double aPrice) {\n    description = aDescription;\n    price = aPrice;\n}\n","name":"Product","className":"Product","variables":{"aDescription":2,"price":1,"description":1,"aPrice":2},"javaDoc":"Constructs a product from a description and a price aDescription the product description aPrice the product price","comments":"\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the product description.\n      @return the description\n   */\npublic String getDescription() {\n    return description;\n}\n","name":"getDescription","className":"Product","variables":{"description":1},"javaDoc":"Gets the product description the description","comments":"\n      Gets the product description.\n      @return the description\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the product price.\n      @return the unit price\n   */\npublic double getPrice() {\n    return price;\n}\n","name":"getPrice","className":"Product","variables":{"price":1},"javaDoc":"Gets the product price the unit price","comments":"\n      Gets the product price.\n      @return the unit price\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"writeToString":1,"build":1,"getImplementation":1,"createLSSerializer":1,"getFeature":1,"System.out.println":1},"constants":{"24.95":1,"\"Hair dryer\"":1,"29.95":1,"\"3.0\"":1,"\"LS\"":1,"\"Toaster\"":1},"annotations":[],"types":{"ArrayList<LineItem>":1,"ItemListBuilder":1,"DOMImplementationLS":1,"ArrayList":1,"DOMImplementation":1,"LSSerializer":1,"String":1,"Document":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","NameExpr","StringLiteralExpr","CastExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting","PolyMorphism"],"exceptions":["Exception"],"text":"public static void main(String[] args) throws Exception {\n    ArrayList<LineItem> items = new ArrayList<>();\n    items.add(new LineItem(new Product(\"Toaster\", 29.95), 3));\n    items.add(new LineItem(new Product(\"Hair dryer\", 24.95), 1));\n    ItemListBuilder builder = new ItemListBuilder();\n    Document doc = builder.build(items);\n    DOMImplementation impl = doc.getImplementation();\n    DOMImplementationLS implLS = (DOMImplementationLS) impl.getFeature(\"LS\", \"3.0\");\n    LSSerializer ser = implLS.createLSSerializer();\n    String out = ser.writeToString(doc);\n    System.out.println(out);\n}\n","name":"main","className":"ItemListBuilderDemo","variables":{"args":1,"impl":2,"ser":2,"implLS":2,"builder":2,"doc":2,"items":3,"out":1},"javaDoc":"","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["Product","int"],"returnType":"LineItem","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   */\npublic LineItem(Product aProduct, int aQuantity) {\n    theProduct = aProduct;\n    quantity = aQuantity;\n}\n","name":"LineItem","className":"LineItem","variables":{"quantity":1,"aProduct":2,"aQuantity":2,"theProduct":1},"javaDoc":"Constructs an item from the product and quantity aProduct the product aQuantity the item quantity","comments":"\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getPrice":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the total cost of this line item.\n      @return the total price\n   */\npublic double getTotalPrice() {\n    return theProduct.getPrice() * quantity;\n}\n","name":"getTotalPrice","className":"LineItem","variables":{"quantity":1,"theProduct":1},"javaDoc":"Computes the total cost of this line item the total price","comments":"\n      Computes the total cost of this line item.\n      @return the total price\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Product","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the product that this item describes.\n      @return the product\n   */\npublic Product getProduct() {\n    return theProduct;\n}\n","name":"getProduct","className":"LineItem","variables":{"theProduct":1},"javaDoc":"Gets the product that this item describes the product","comments":"\n      Gets the product that this item describes.\n      @return the product\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the quantity of the product that this item describes.\n      @return the quantity\n   */\npublic int getQuantity() {\n    return quantity;\n}\n","name":"getQuantity","className":"LineItem","variables":{"quantity":1},"javaDoc":"Gets the quantity of the product that this item describes the quantity","comments":"\n      Gets the quantity of the product that this item describes.\n      @return the quantity\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1,"getTotalPrice":1,"getDescription":1,"getPrice":1},"constants":{"\"%-30s%8.2f%5d%8.2f\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Formats this item.\n      @return a formatted string of this item\n   */\npublic String format() {\n    return String.format(\"%-30s%8.2f%5d%8.2f\", theProduct.getDescription(), theProduct.getPrice(), quantity, getTotalPrice());\n}\n","name":"format","className":"LineItem","variables":{"String":1,"theProduct":2},"javaDoc":"Formats this item a formatted string of this item","comments":"\n      Formats this item.\n      @return a formatted string of this item\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ItemListBuilder","methodCalls":{"newDocumentBuilder":1,"newInstance":1},"constants":{},"annotations":[],"types":{"DocumentBuilderFactory":1},"expressions":["VariableDeclarationExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":["ParserConfigurationException"],"text":"/**\n      Constructs an item list builder.\n   */\npublic ItemListBuilder() throws ParserConfigurationException {\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    builder = factory.newDocumentBuilder();\n}\n","name":"ItemListBuilder","className":"ItemListBuilder","variables":{"factory":2,"DocumentBuilderFactory":1,"builder":1},"javaDoc":"Constructs an item list builder","comments":"\n      Constructs an item list builder.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["ArrayList<LineItem>"],"returnType":"Document","methodCalls":{"appendChild":1,"createItems":1,"newDocument":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Builds a DOM document for an array list of items.\n      @param items the items\n      @return a DOM document describing the items\n   */\npublic Document build(ArrayList<LineItem> items) {\n    doc = builder.newDocument();\n    doc.appendChild(createItems(items));\n    return doc;\n}\n","name":"build","className":"ItemListBuilder","variables":{"builder":1,"doc":3,"items":1},"javaDoc":"Builds a DOM document for an array list of items items the items a DOM document describing the items","comments":"\n      Builds a DOM document for an array list of items.\n      @param items the items\n      @return a DOM document describing the items\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["ArrayList<LineItem>"],"returnType":"Element","methodCalls":{"appendChild":1,"createItem":1,"createElement":1},"constants":{"\"items\"":1},"annotations":[],"types":{"Element":1,"LineItem":1},"expressions":["VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Builds a DOM element for an array list of items.\n      @param items the items\n      @return a DOM element describing the items\n   */\nprivate Element createItems(ArrayList<LineItem> items) {\n    Element e = doc.createElement(\"items\");\n    for (LineItem anItem : items) {\n        e.appendChild(createItem(anItem));\n    }\n    return e;\n}\n","name":"createItems","className":"ItemListBuilder","variables":{"anItem":1,"doc":1,"items":2},"javaDoc":"Builds a DOM element for an array list of items items the items a DOM element describing the items","comments":"\n      Builds a DOM element for an array list of items.\n      @param items the items\n      @return a DOM element describing the items\n   ","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":["LineItem"],"returnType":"Element","methodCalls":{"appendChild":2,"getProduct":1,"createTextElement":1,"getQuantity":1,"createProduct":1,"createElement":1},"constants":{"\"quantity\"":1,"\"\"":1,"\"item\"":1},"annotations":[],"types":{"Element":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Builds a DOM element for an item.\n      @param anItem the item\n      @return a DOM element describing the item\n   */\nprivate Element createItem(LineItem anItem) {\n    Element e = doc.createElement(\"item\");\n    e.appendChild(createProduct(anItem.getProduct()));\n    e.appendChild(createTextElement(\"quantity\", \"\" + anItem.getQuantity()));\n    return e;\n}\n","name":"createItem","className":"ItemListBuilder","variables":{"anItem":3,"doc":1},"javaDoc":"Builds a DOM element for an item anItem the item a DOM element describing the item","comments":"\n      Builds a DOM element for an item.\n      @param anItem the item\n      @return a DOM element describing the item\n   ","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":["Product"],"returnType":"Element","methodCalls":{"appendChild":2,"createTextElement":2,"createElement":1,"getDescription":1,"getPrice":1},"constants":{"\"\"":1,"\"price\"":1,"\"product\"":1,"\"description\"":1},"annotations":[],"types":{"Element":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Builds a DOM element for a product.\n      @param p the product\n      @return a DOM element describing the product\n   */\nprivate Element createProduct(Product p) {\n    Element e = doc.createElement(\"product\");\n    e.appendChild(createTextElement(\"description\", p.getDescription()));\n    e.appendChild(createTextElement(\"price\", \"\" + p.getPrice()));\n    return e;\n}\n","name":"createProduct","className":"ItemListBuilder","variables":{"doc":1},"javaDoc":"Builds a DOM element for a product p the product a DOM element describing the product","comments":"\n      Builds a DOM element for a product.\n      @param p the product\n      @return a DOM element describing the product\n   ","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":["String","String"],"returnType":"Element","methodCalls":{"appendChild":1,"createTextNode":1,"createElement":1},"constants":{},"annotations":[],"types":{"Element":1,"Text":1},"expressions":["VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private Element createTextElement(String name, String text) {\n    Text t = doc.createTextNode(text);\n    Element e = doc.createElement(name);\n    e.appendChild(t);\n    return e;\n}\n","name":"createTextElement","className":"ItemListBuilder","variables":{"name":1,"doc":2,"text":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":3,"add":2,"addLast":4,"listIterator":1,"remove":1,"System.out.println":1},"constants":{"\"Nina\"":1,"\"Tom\"":1,"\"Juliet\"":1,"\"Dick\"":1,"\"Harry\"":1,"\"Romeo\"":1},"annotations":[],"types":{"LinkedList<String>":1,"ListIterator<String>":1,"String":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    LinkedList<String> staff = new LinkedList<String>();\n    staff.addLast(\"Dick\");\n    staff.addLast(\"Harry\");\n    staff.addLast(\"Romeo\");\n    staff.addLast(\"Tom\");\n    // | in the comments indicates the iterator position\n    // |DHRT\n    ListIterator<String> iterator = staff.listIterator();\n    // D|HRT\n    iterator.next();\n    // DH|RT\n    iterator.next();\n    // Add more elements after second element\n    // DHJ|RT\n    iterator.add(\"Juliet\");\n    // DHJN|RT\n    iterator.add(\"Nina\");\n    // DHJNR|T\n    iterator.next();\n    // Remove last traversed element, removed Romeo\n    // DHJN|T\n    iterator.remove();\n    for (String name : staff) System.out.println(name);\n}\n","name":"main","className":"ListTester","variables":{"args":1,"iterator":7,"name":1,"staff":7},"javaDoc":"","comments":"| in the comments indicates the iterator position Add more elements after second element Remove last traversed element removed Romeo Print all elements |DHRT D|HRT DH|RT DHJ|RT DHJN|RT DHJNR|T DHJN|T ","isEmpty":false,"lineCount":17,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"appendAtEnd":1,"appendAfter":1,"insertElement":1,"length":2,"readLine":15,"printMenu":2,"searchElement":1,"parseInt":6,"reverseFirstFew":1,"trim":15,"size":1,"getElement":1,"toUpperCase":1,"countHowMany":1,"toString":1,"setElement":1,"removeDuplicate":1,"removeElement":1,"System.out.print":31,"charAt":1},"constants":{"\"Which string do you want to append after:\\n\"":1,"\"The first \"":1,"\"Please enter a string to add:\\n\"":1,"\"Please enter the number of times you want to append:\\n\"":1,"\"Please enter the number of elements you want to reverse:\\n\"":1,"\"IO Exception\\n\"":1,"\" found at index \"":1,"\" is \"":1,"\"Please enter a string to count:\\n\"":1,"\" is removed from the linked list\\n\"":1,"\"Please enter a string to append at the end:\\n\"":1,"\"string at index \"":2,"\"Unknown action\\n\"":2,"\" elements are reversed\\n\"":1,"'Q'":1,"\" times at end of the linked list\\n\"":1,"\"Please enter a string to search:\\n\"":1,"\" not found\\n\"":1,"\"The current size is \"":1,"\"There are \"":1,"\" \"":1,"\"Please enter an index to search:\\n\"":1,"\" is inserted at index \"":1,"\" is set at index \"":1,"\" is removed\\n\"":1,"\"Please enter a string to remove:\\n\"":1,"\"Please enter the string you want to append:\\n\"":1,"\"Please enter an index to set:\\n\"":1,"\"What action would you like to perform?\\n\"":1,"\" is appended \"":1,"\"Please enter a new string to set:\\n\"":1,"\"Please enter an index to remove:\\n\"":1,"\"Please enter an index to add:\\n\"":1,"\"\\n\"":6,"\" found inside the linked list\\n\"":1,"\" is appended after \"":1},"annotations":[],"types":{"InputStreamReader":1,"char":1,"BufferedReader":1,"String":6,"int":8,"LinkedList":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","CharLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["SwitchStmt","IfStmt","BreakStmt","TryStmt","BlockStmt","SwitchEntryStmt","ExpressionStmt","DoStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) {\n    char input1;\n    String inputInfo = new String();\n    int operation2;\n    String line = new String();\n    // create a linked list to be used in this method.\n    LinkedList list1 = new LinkedList();\n    try {\n        // print out the menu\n        printMenu();\n        // create a BufferedReader object to read input from a keyboard\n        InputStreamReader isr = new InputStreamReader(System.in);\n        BufferedReader stdin = new BufferedReader(isr);\n        do {\n            System.out.print(\"What action would you like to perform?\\n\");\n            // read a line\n            line = stdin.readLine().trim();\n            input1 = line.charAt(0);\n            input1 = Character.toUpperCase(input1);\n            if (// check if a user entered only one\n            line.length() == 1) // character\n            {\n                switch(input1) {\n                    case // List Current Size\n                    'O':\n                        System.out.print(\"The current size is \" + list1.size() + \"\\n\");\n                        break;\n                    case // Add String\n                    'A':\n                        System.out.print(\"Please enter a string to add:\\n\");\n                        String str1 = stdin.readLine().trim();\n                        System.out.print(\"Please enter an index to add:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        int addIndex = Integer.parseInt(inputInfo);\n                        list1.insertElement(addIndex, str1);\n                        System.out.print(str1 + \" is inserted at index \" + addIndex + \"\\n\");\n                        break;\n                    case // Search for the Index of a String\n                    'I':\n                        System.out.print(\"Please enter a string to search:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        operation2 = list1.searchElement(inputInfo);\n                        if (operation2 > -1)\n                            System.out.print(inputInfo + \" found at index \" + operation2 + \"\\n\");\n                        else\n                            System.out.print(inputInfo + \" not found\\n\");\n                        break;\n                    case // Search for String at an Index\n                    'E':\n                        System.out.print(\"Please enter an index to search:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        int searchIndex = Integer.parseInt(inputInfo);\n                        System.out.print(\"string at index \" + searchIndex + \" is \" + list1.getElement(searchIndex) + \"\\n\");\n                        break;\n                    case // Set a new element at specified index\n                    'S':\n                        System.out.print(\"Please enter a new string to set:\\n\");\n                        String str2 = stdin.readLine().trim();\n                        System.out.print(\"Please enter an index to set:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        int setIndex = Integer.parseInt(inputInfo);\n                        list1.setElement(setIndex, str2);\n                        System.out.print(str2 + \" is set at index \" + setIndex + \"\\n\");\n                        break;\n                    case // Remove an element at a specified index\n                    'R':\n                        System.out.print(\"Please enter an index to remove:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        int removeIndex = Integer.parseInt(inputInfo);\n                        list1.removeElement(removeIndex);\n                        System.out.print(\"string at index \" + removeIndex + \" is removed\\n\");\n                        break;\n                    case // Count the number of occurences of a specific\n                    'C':\n                        // element\n                        System.out.print(\"Please enter a string to count:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        int counter1 = list1.countHowMany(inputInfo);\n                        System.out.print(\"There are \" + counter1 + \" \" + inputInfo + \" found inside the linked list\\n\");\n                        break;\n                    case // Remove all occurences of a given element\n                    'D':\n                        System.out.print(\"Please enter a string to remove:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        list1.removeDuplicate(inputInfo);\n                        System.out.print(inputInfo + \" is removed from the linked list\\n\");\n                        break;\n                    case // Append a given element a number of times at the\n                    'P':\n                        // end of the linked list\n                        System.out.print(\"Please enter a string to append at the end:\\n\");\n                        String str3 = stdin.readLine().trim();\n                        System.out.print(\"Please enter the number of times you want to append:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        int times = Integer.parseInt(inputInfo);\n                        list1.appendAtEnd(str3, times);\n                        System.out.print(str3 + \" is appended \" + times + \" times at end of the linked list\\n\");\n                        break;\n                    case // Append a given element after the first\n                    'T':\n                        // occurence of another element\n                        System.out.print(\"Which string do you want to append after:\\n\");\n                        String str4 = stdin.readLine().trim();\n                        System.out.print(\"Please enter the string you want to append:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        list1.appendAfter(str4, inputInfo);\n                        System.out.print(inputInfo + \" is appended after \" + str4 + \"\\n\");\n                        break;\n                    case // Reverse the first few element of the linked\n                    'V':\n                        // list\n                        System.out.print(\"Please enter the number of elements you want to reverse:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        int reverseNum = Integer.parseInt(inputInfo);\n                        list1.reverseFirstFew(reverseNum);\n                        System.out.print(\"The first \" + reverseNum + \" elements are reversed\\n\");\n                        break;\n                    case // List all strings inside the linked list\n                    'L':\n                        System.out.print(list1.toString());\n                        break;\n                    case // Quit\n                    'Q':\n                        break;\n                    case // Display Menu\n                    '?':\n                        printMenu();\n                        break;\n                    default:\n                        System.out.print(\"Unknown action\\n\");\n                        break;\n                }\n            } else {\n                System.out.print(\"Unknown action\\n\");\n            }\n        } while (input1 != 'Q' || line.length() != 1);\n    } catch (IOException exception) {\n        System.out.print(\"IO Exception\\n\");\n    }\n}\n","name":"main","className":"Assignment10","variables":{"exception":1,"inputInfo":16,"stdin":16,"Character":1,"reverseNum":2,"line":5,"counter1":2,"input1":5,"isr":2,"searchIndex":2,"removeIndex":2,"addIndex":2,"args":1,"list1":13,"Integer":6,"times":2,"operation2":4,"str3":2,"str4":2,"str1":2,"setIndex":2,"str2":2},"javaDoc":"","comments":"create a linked list to be used in this method print out the menu create a BufferedReader object to read input from a keyboard read a line check if a user entered only one character List Current Size Add String Search for the Index of a String Search for String at an Index Set a new element at specified index Remove an element at a specified index Count the number of occurences of a specific element Remove all occurences of a given element Append a given element a number of times at the end of the linked list Append a given element after the first occurence of another element Reverse the first few element of the linked list List all strings inside the linked list Quit Display Menu ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.print":1},"constants":{"\"I\\t\\tSearch Element\\n\"":1,"\"Choice\\t\\tAction\\n\"":1,"\"D\\t\\tRemove Duplicates\\n\"":1,"\"R\\t\\tRemove Element by Index\\n\"":1,"\"E\\t\\tGet Element by Index\\n\"":1,"\"P\\t\\tAppend at the End\\n\"":1,"\"Q\\t\\tQuit\\n\"":1,"\"T\\t\\tAppend After\\n\"":1,"\"A\\t\\tInsert Element by Index\\n\"":1,"\"L\\t\\tList Linked List\\n\"":1,"\"?\\t\\tDisplay Help\\n\\n\"":1,"\"V\\t\\tReverse First Few\\n\"":1,"\"S\\t\\tSet Element by Index\\n\"":1,"\"O\\t\\tList Current Size\\n\"":1,"\"------\\t\\t------\\n\"":1,"\"C\\t\\tCount How Many\\n\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** The method printMenu displays the menu to a user **/\npublic static void printMenu() {\n    System.out.print(\"Choice\\t\\tAction\\n\" + \"------\\t\\t------\\n\" + \"O\\t\\tList Current Size\\n\" + \"I\\t\\tSearch Element\\n\" + \"E\\t\\tGet Element by Index\\n\" + \"S\\t\\tSet Element by Index\\n\" + \"A\\t\\tInsert Element by Index\\n\" + \"R\\t\\tRemove Element by Index\\n\" + \"C\\t\\tCount How Many\\n\" + \"D\\t\\tRemove Duplicates\\n\" + \"P\\t\\tAppend at the End\\n\" + \"T\\t\\tAppend After\\n\" + \"V\\t\\tReverse First Few\\n\" + \"L\\t\\tList Linked List\\n\" + \"Q\\t\\tQuit\\n\" + \"?\\t\\tDisplay Help\\n\\n\");\n}\n","name":"printMenu","className":"Assignment10","variables":{},"javaDoc":"The method printMenu displays the menu to a user","comments":" The method printMenu displays the menu to a user *","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]"],"returnType":"BinarySearcher","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Constructs a BinarySearcher.\n\t * @param anArray a sorted array of integers\n\t */\npublic BinarySearcher(int[] anArray) {\n    sortedArray = anArray;\n}\n","name":"BinarySearcher","className":"BinarySearcher","variables":{"sortedArray":1,"anArray":2},"javaDoc":"Constructs a BinarySearcher anArray a sorted array of integers","comments":"\n\t * Constructs a BinarySearcher.\n\t * @param anArray a sorted array of integers\n\t ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":4},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","EnclosedExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Finds a value in a sorted array, using the binary search algorithm.\n\t * @param v the value to search\n\t * @return the index at which the value occurs, or -1 if it does not occur in the array\n\t */\npublic int search(int v) {\n    int low = 0;\n    int high = sortedArray.length - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        int diff = sortedArray[mid] - v;\n        if (// a[mid] == v\n        diff == 0)\n            return mid;\n        else if (// a[mid] < v\n        diff < 0)\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n    return -1;\n}\n","name":"search","className":"BinarySearcher","variables":{"high":4,"low":4,"sortedArray":1,"mid":5,"diff":3},"javaDoc":"Finds a value in a sorted array using the binary search algorithm v the value to search the index at which the value occurs or -1 if it does not occur in the array","comments":"a[mid] == v a[mid] < v \n\t * Finds a value in a sorted array, using the binary search algorithm.\n\t * @param v the value to search\n\t * @return the index at which the value occurs, or -1 if it does not occur in the array\n\t ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"search":1,"System.out.println":2},"constants":{"\"15 is not found!\"":1,"12":1,"\"mySortedArray[\"":1,"15":1,"17":1,"\"] = 15\"":1,"20":1,"32":1},"annotations":[],"types":{"BinarySearcher":1,"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] mySortedArray = { 1, 5, 8, 9, 12, 17, 20, 32 };\n    BinarySearcher searcher = new BinarySearcher(mySortedArray);\n    int foundIndex = searcher.search(15);\n    if (foundIndex == -1) {\n        System.out.println(\"15 is not found!\");\n    } else {\n        System.out.println(\"mySortedArray[\" + foundIndex + \"] = 15\");\n    }\n}\n","name":"main","className":"BinarySearchTester","variables":{"args":1,"searcher":2,"foundIndex":3,"mySortedArray":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]"],"returnType":"InsertionSorter","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an insertion sorter.\n      @param anArray the array to sort\n   */\npublic InsertionSorter(int[] anArray) {\n    a = anArray;\n}\n","name":"InsertionSorter","className":"InsertionSorter","variables":{"anArray":2},"javaDoc":"Constructs an insertion sorter anArray the array to sort","comments":"\n      Constructs an insertion sorter.\n      @param anArray the array to sort\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sorts the array managed by this insertion sorter\n   */\npublic void sort() {\n    for (int i = 1; i < a.length; i++) {\n        int next = a[i];\n        // Move all larger elements up\n        int j = i;\n        while (j > 0 && a[j - 1] > next) {\n            a[j] = a[j - 1];\n            j--;\n        }\n        // Insert the element\n        a[j] = next;\n    }\n}\n","name":"sort","className":"InsertionSorter","variables":{"next":3},"javaDoc":"Sorts the array managed by this insertion sorter","comments":"Move all larger elements up Insert the element \n      Sorts the array managed by this insertion sorter\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"linearSearch":1,"System.out.println":1},"constants":{"12":1,"\"aRandomArray[\"":1,"\"] = 7\"":1,"19":1,"10":1},"annotations":[],"types":{"int[]":1,"LinearSearcher":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] aRandomArray = { 12, 2, 4, 5, 6, 7, 1, 19, 10 };\n    //I want to find 7\n    LinearSearcher searcher = new LinearSearcher();\n    int foundIndex = searcher.linearSearch(aRandomArray, 7);\n    System.out.println(\"aRandomArray[\" + foundIndex + \"] = 7\");\n}\n","name":"main","className":"LinearSearchTester","variables":{"args":1,"searcher":2,"foundIndex":2,"aRandomArray":1},"javaDoc":"","comments":"I want to find 7 ","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int linearSearch(int[] anArray, int x) {\n    for (int i = 0; i < anArray.length; i++) {\n        if (anArray[i] == x) {\n            // return the found index in anArray\n            return i;\n        }\n    }\n    // didn't find the number x\n    return -1;\n}\n","name":"linearSearch","className":"LinearSearcher","variables":{"anArray":2},"javaDoc":"","comments":"return the found index in anArray didn't find the number x ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getAllArrayElementString":2,"sort":1,"System.out.println":2},"constants":{"11":1,"12":1,"17":1,"\"Un-sorted array: \"":1,"\"Sorted array: \"":1},"annotations":[],"types":{"SelectionSorter":1,"int[]":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] a = { 11, 9, 17, 5, 12 };\n    System.out.println(\"Un-sorted array: \" + getAllArrayElementString(a));\n    //11, 9, 17, 5, 12\n    SelectionSorter sorter = new SelectionSorter(a);\n    sorter.sort();\n    System.out.println(\"Sorted array: \" + getAllArrayElementString(a));\n}\n","name":"main","className":"SelectionSortTester","variables":{"args":1,"sorter":2},"javaDoc":"","comments":"11 9 17 5 12 ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int[]"],"returnType":"String","methodCalls":{},"constants":{"\"\"":1,"\", \"":1},"annotations":[],"types":{"String":1,"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","AssignExpr"],"statements":["BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static String getAllArrayElementString(int[] a) {\n    String arrayString = \"\";\n    for (int i : a) {\n        arrayString += i + \", \";\n    }\n    return arrayString;\n}\n","name":"getAllArrayElementString","className":"SelectionSortTester","variables":{"arrayString":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]"],"returnType":"SelectionSorter","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Constructs a selection sorter.\n\t * @param anArray the array to sort\n\t */\npublic SelectionSorter(int[] anArray) {\n    a = anArray;\n}\n","name":"SelectionSorter","className":"SelectionSorter","variables":{"anArray":2},"javaDoc":"Constructs a selection sorter anArray the array to sort","comments":"\n\t * Constructs a selection sorter.\n\t * @param anArray the array to sort\n\t ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"swap":1,"minimumPosition":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Sorts the array managed by this selection sorter.\n\t */\npublic void sort() {\n    for (int i = 0; i < a.length - 1; i++) {\n        int minPos = minimumPosition(i);\n        swap(minPos, i);\n    }\n}\n","name":"sort","className":"SelectionSorter","variables":{"minPos":1},"javaDoc":"Sorts the array managed by this selection sorter","comments":"\n\t * Sorts the array managed by this selection sorter.\n\t ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Swaps two entries of the array.\n\t * \n\t * @param i the first position to swap\n\t * @param j the second position to swap\n\t */\nprivate void swap(int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"SelectionSorter","variables":{"temp":2},"javaDoc":"Swaps two entries of the array i the first position to swap j the second position to swap","comments":"\n\t * Swaps two entries of the array.\n\t * \n\t * @param i the first position to swap\n\t * @param j the second position to swap\n\t ","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Finds the smallest element in a tail range of the array.\n\t * \n\t * @param from the first position in a to compare\n\t * @return the position of the smallest element in the range a[from] . . .\n\t *         a[a.length - 1]\n\t */\nprivate int minimumPosition(int from) {\n    int minPos = from;\n    for (int i = from + 1; i < a.length; i++) if (a[i] < a[minPos])\n        minPos = i;\n    return minPos;\n}\n","name":"minimumPosition","className":"SelectionSorter","variables":{"minPos":4,"from":3},"javaDoc":"Finds the smallest element in a tail range of the array from the first position in a to compare the position of the smallest element in the range a[from] a[a length - 1]","comments":"\n\t * Finds the smallest element in a tail range of the array.\n\t * \n\t * @param from the first position in a to compare\n\t * @return the position of the smallest element in the range a[from] . . .\n\t *         a[a.length - 1]\n\t ","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":["int","int","int","int","Color"],"returnType":"Rect","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Rect(int x1, int y1, int width, int height, Color color) {\n    x = x1;\n    y = y1;\n    this.width = width;\n    this.height = height;\n    this.color = color;\n}\n","name":"Rect","className":"Rect","variables":{"color":2,"y1":2,"width":2,"x1":2,"height":2},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"fillRect":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void draw(Graphics page) {\n    page.fillRect(x, y, width, height);\n}\n","name":"draw","className":"Rect","variables":{"page":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Color","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public Color getColor() {\n    return color;\n}\n","name":"getColor","className":"Rect","variables":{"color":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":1,"comparing":3,"sort":2,"parse":1,"toList":1,"sorted":1,"thenComparing":1,"get":1,"toString":2,"lines":1,"collect":1,"map":1,"System.out.println":3},"constants":{"\"../population.txt\"":1,"\" \"":1,"\"how much wood could a wood chuck chuck\"":1},"annotations":[],"types":{"List<Country>":1,"String[]":1,"Stream<String>":1,"Comparator<String>":1},"expressions":["VariableDeclarationExpr","LambdaExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodReferenceExpr","TypeExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    Comparator<String> comp = Comparator.comparing( t -> t.length());\n    String[] words = \"how much wood could a wood chuck chuck\".split(\" \");\n    Arrays.sort(words, comp);\n    System.out.println(Arrays.toString(words));\n    Arrays.sort(words, Comparator.comparing(String::length));\n    System.out.println(Arrays.toString(words));\n    try (Stream<String> lines = Files.lines(Paths.get(\"../population.txt\"))) {\n        List<Country> result = lines.map( line -> Country.parse(line)).sorted(Comparator.comparing(Country::getContinent).thenComparing(Country::getName)).collect(Collectors.toList());\n        System.out.println(result);\n    }\n}\n","name":"main","className":"ComparatorDemo","variables":{"args":1,"result":1,"comp":1,"Collectors":1,"line":1,"words":1,"Country":1,"Paths":1,"Arrays":4,"lines":2,"Files":1,"Comparator":3},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["String"],"returnType":"Country","methodCalls":{"parseInt":1,"split":1},"constants":{"\"\\\\|\"":1},"annotations":[],"types":{"Country":1,"String[]":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static Country parse(String line) {\n    String[] fields = line.split(\"\\\\|\");\n    Country country = new Country();\n    country.name = fields[0];\n    country.continent = fields[1];\n    country.population = Integer.parseInt(fields[2]);\n    return country;\n}\n","name":"parse","className":"Country","variables":{"Integer":1,"country":2,"line":2,"fields":4},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getContinent() {\n    return continent;\n}\n","name":"getContinent","className":"Country","variables":{"continent":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getPopulation() {\n    return population;\n}\n","name":"getPopulation","className":"Country","variables":{"population":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"|\"":2},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return name + \"|\" + continent + \"|\" + population;\n}\n","name":"toString","className":"Country","variables":{"continent":1,"name":1,"population":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"stream":1,"of":3,"get":1,"show":5,"lines":1},"constants":{"\"Hello\"":1,"\"a\"":1,"\"little\"":1,"\"../countries.txt\"":1,"\"A stream of lines from a file\"":1,"\"World\"":1,"\"Mary\"":1,"\"A stream of words from a list\"":1,"\"lamb\"":1,"\"A stream of individually specified digits\"":1,"\"had\"":1,"\"A stream of individually specified words\"":1,"\"A stream of digits from an array\"":1},"annotations":[],"types":{"Stream<Integer>":1,"ArrayList":1,"Stream<String>":2,"Integer[]":1,"List<String>":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayInitializerExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    Stream<String> words = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\");\n    show(\"A stream of individually specified words\", words);\n    Stream<Integer> digits = Stream.of(3, 1, 4, 1, 5, 9);\n    show(\"A stream of individually specified digits\", digits);\n    Integer[] digitArray = { 3, 1, 4, 1, 5, 9 };\n    digits = Stream.of(digitArray);\n    show(\"A stream of digits from an array\", digits);\n    List<String> wordList = new ArrayList<>();\n    // Populate wordList\n    wordList.add(\"Hello\");\n    wordList.add(\"World\");\n    words = wordList.stream();\n    show(\"A stream of words from a list\", words);\n    try (Stream<String> lines = Files.lines(Paths.get(\"../countries.txt\"))) {\n        show(\"A stream of lines from a file\", lines);\n    }\n}\n","name":"main","className":"Streams","variables":{"args":1,"wordList":4,"words":2,"digitArray":1,"Stream":3,"digits":2,"Paths":1,"lines":1,"Files":1},"javaDoc":"","comments":"Populate wordList ","isEmpty":false,"lineCount":13,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"constants":{"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"annotations":[],"types":{"List<T>":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Streams","variables":{"Collectors":1,"stream":2,"values":4,"caption":2,"Math":1,"SHOW_LIMIT":3},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":2,"sorted":2,"of":4,"length":6,"show":4,"distinct":2},"constants":{"\" \"":4,"\"Filtering with a simple lambda expression\"":1,"\"Filtering with a lambda expression with parameter type\"":1,"\"how much wood could a wood chuck chuck\"":4,"\"Sorting with a lambda expression with two parameters\"":1,"\"Sorting with a complex lambda expression\"":1},"annotations":[],"types":{"Stream<String>":3,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).filter( w -> w.length() > 4);\n    show(\"Filtering with a simple lambda expression\", words);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).filter((String w) -> w.length() > 4);\n    show(\"Filtering with a lambda expression with parameter type\", words);\n    Stream<String> distinctWords = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).distinct();\n    Stream<String> sortedWords = distinctWords.sorted(( s,  t) -> s.length() - t.length());\n    show(\"Sorting with a lambda expression with two parameters\", sortedWords);\n    distinctWords = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).distinct();\n    sortedWords = distinctWords.sorted(( v,  w) -> {\n        int first = v.length();\n        int second = w.length();\n        return first - second;\n    });\n    show(\"Sorting with a complex lambda expression\", sortedWords);\n}\n","name":"main","className":"Streams","variables":{"args":1,"sortedWords":2,"distinctWords":4,"words":2,"Stream":4,"first":2,"second":2},"javaDoc":"","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"constants":{"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"annotations":[],"types":{"List<T>":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Streams","variables":{"Collectors":1,"stream":2,"values":4,"caption":2,"Math":1,"SHOW_LIMIT":3},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"random":1,"show":4,"generate":2,"isPrime":1,"iterate":2},"constants":{"\"An infinite stream of ones\"":1,"\"An infinite stream of primes\"":1,"\"An infinite stream of integers\"":1,"\"An infinite stream of random numbers\"":1},"annotations":[],"types":{"Stream<Integer>":4},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","CastExpr","EnclosedExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Stream<Integer> ones = Stream.generate(() -> 1);\n    show(\"An infinite stream of ones\", ones);\n    Stream<Integer> dieTosses = Stream.generate(() -> 1 + (int) (6 * Math.random()));\n    show(\"An infinite stream of random numbers\", dieTosses);\n    Stream<Integer> integers = Stream.iterate(0,  n -> n + 1);\n    show(\"An infinite stream of integers\", integers);\n    integers = Stream.iterate(0,  n -> n + 1);\n    Stream<Integer> primes = integers.filter( n -> isPrime(n));\n    show(\"An infinite stream of primes\", primes);\n}\n","name":"main","className":"Infinite","variables":{"args":1,"primes":1,"ones":1,"Stream":4,"dieTosses":1,"Math":1,"integers":3},"javaDoc":"","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["int"],"returnType":"boolean","methodCalls":{"filter":1,"count":1,"limit":1,"iterate":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","LambdaExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static boolean isPrime(int number) {\n    return Stream.iterate(1,  n -> n + 1).limit(number).filter( n -> number % n == 0).count() == 2;\n}\n","name":"isPrime","className":"Infinite","variables":{"number":2,"Stream":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"constants":{"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"annotations":[],"types":{"List<T>":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Infinite","variables":{"Collectors":1,"stream":2,"values":4,"caption":2,"Math":1,"SHOW_LIMIT":3},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"of":1,"ifPresent":1,"get":1,"length":1,"isPresent":1,"findFirst":1,"orElse":1,"System.out.println":4},"constants":{"\"None of these countries has more than ten characters\"":1,"\"Uganda\"":1,"\"Botswana\"":1,"\"Togo\"":1,"\"Madagascar\"":1,"\"The first country with more than ten characters: \"":3,"\"Namibia\"":1,"\"Mozambique\"":1,"\"(None)\"":1,"\"Zimbabwe\"":1,"10":1},"annotations":[],"types":{"Optional<String>":1,"Stream<String>":1,"String":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"Zimbabwe\", \"Namibia\", \"Uganda\", \"Botswana\", \"Madagascar\", \"Mozambique\", // \"Ivory Coast\",\n    \"Swaziland\", \"Togo\");\n    Optional<String> optResult = words.filter( w -> w.length() > 10).findFirst();\n    // Using orElse\n    String first = optResult.orElse(\"(None)\");\n    System.out.println(\"The first country with more than ten characters: \" + first);\n    // Using ifPresent\n    optResult.ifPresent( v -> System.out.println(\"The first country with more than ten characters: \" + v));\n    // Using isPresent/get\n    if (optResult.isPresent()) {\n        System.out.println(\"The first country with more than ten characters: \" + optResult.get());\n    } else {\n        System.out.println(\"None of these countries has more than ten characters\");\n    }\n}\n","name":"main","className":"OptionalDemo","variables":{"args":1,"optResult":5,"words":2,"Stream":1,"first":2},"javaDoc":"","comments":"\"Ivory Coast\" Using orElse Using ifPresent Using isPresent/get ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":4,"toSet":1,"joining":1,"contains":4,"of":4,"toArray":1,"toString":1,"toList":1,"collect":3,"System.out.println":4},"constants":{"\"Collecting to a list: \"":1,"\"lamb\"":4,"\"a\"":8,"\"little\"":4,"\"had\"":4,"\"Converting to an array: \"":1,"\"Collecting to a set: \"":1,"\"Mary\"":4,"\", \"":1,"\"Joining with commas: \"":1},"annotations":[],"types":{"Set<String>":1,"Stream<String>":1,"String[]":1,"String":1,"List<String>":1},"expressions":["VariableDeclarationExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodReferenceExpr","TypeExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Stream<String> stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    String[] result1 = stream.toArray(String[]::new);\n    System.out.println(\"Converting to an array: \" + Arrays.toString(result1));\n    stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    List<String> result2 = stream.collect(Collectors.toList());\n    System.out.println(\"Collecting to a list: \" + result2);\n    stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    Set<String> result3 = stream.collect(Collectors.toSet());\n    System.out.println(\"Collecting to a set: \" + result3);\n    stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    String result4 = stream.collect(Collectors.joining(\", \"));\n    System.out.println(\"Joining with commas: \" + result4);\n}\n","name":"main","className":"Streams","variables":{"args":1,"Collectors":3,"stream":8,"Stream":4,"Arrays":1,"result4":2,"result3":2,"result2":2,"result1":1},"javaDoc":"","isEmpty":false,"lineCount":12,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"filter":2,"contains":1,"nextLine":1,"hasNextLine":1,"length":1,"System.out.println":2},"constants":{"\" and \"":1,"\"../countries.txt\"":1,"\"Countries with and in their name: \"":1,"\"Long country names: \"":1,"10":1},"annotations":[],"types":{"Scanner":1,"ArrayList":1,"List<String>":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../countries.txt\"));\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNextLine()) {\n        wordList.add(in.nextLine());\n    }\n    List<String> filtered = filter(wordList,  w -> w.length() > 10);\n    System.out.println(\"Long country names: \" + filtered);\n    filtered = filter(wordList, contains(\" and \"));\n    System.out.println(\"Countries with and in their name: \" + filtered);\n}\n","name":"main","className":"HigherOrderFunctions","variables":{"args":1,"filtered":4,"in":3,"wordList":2},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["List<T>","Predicate<T>"],"returnType":"List<T>","methodCalls":{"add":1,"test":1},"constants":{},"annotations":[],"types":{"ArrayList":1,"List<T>":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static <T> List<T> filter(List<T> values, Predicate<T> p) {\n    List<T> result = new ArrayList<>();\n    for (T value : values) {\n        if (p.test(value)) {\n            result.add(value);\n        }\n    }\n    return result;\n}\n","name":"filter","className":"HigherOrderFunctions","variables":{"result":3,"values":2,"value":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String"],"returnType":"Predicate<String>","methodCalls":{"indexOf":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","LambdaExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static Predicate<String> contains(String target) {\n    return  s -> s.indexOf(target) >= 0;\n}\n","name":"contains","className":"HigherOrderFunctions","variables":{"target":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"joining":1,"max":1,"count":1,"range":2,"sum":1,"findFirst":2,"orElse":4,"mapToObj":1,"filter":3,"min":1,"of":6,"toArray":1,"toString":1,"map":1,"collect":1,"System.out.println":9,"codePoints":1},"constants":{"\"\"":1,"35":1,"29":1,"\"How much wood could a woodchuck chuck?\"":1,"\"pos: \"":1,"' '":1,"\" | \"":1,"\"smallest: \"":1,"67.5":1,"100":3,"115":1,"\"largest: \"":1,"\"total: \"":1,"80":1,"\"average: \"":1,"\"spaces: \"":1,"10":1,"32":1,"54":1,"44.5":1,"65":1},"annotations":[],"types":{"double[]":1,"double":4,"int[]":1,"String":2,"int":2,"long":1,"OptionalDouble":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","CharLiteralExpr","UnaryExpr","AssignExpr","ArrayInitializerExpr","DoubleLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int n = 10;\n    int[] squares = IntStream.range(0, n).map( i -> i * i).toArray();\n    System.out.println(Arrays.toString(squares));\n    double[] values = { 32, 54, 67.5, 29, 35, 80, 115, 44.5, 100, 65 };\n    double total = DoubleStream.of(values).sum();\n    double average = DoubleStream.of(values).average().orElse(0);\n    double largest = DoubleStream.of(values).max().orElse(Double.MIN_VALUE);\n    double smallest = DoubleStream.of(values).min().orElse(Double.MAX_VALUE);\n    System.out.println(\"total: \" + total);\n    System.out.println(\"average: \" + average);\n    System.out.println(\"largest: \" + largest);\n    System.out.println(\"smallest: \" + smallest);\n    String str = \"How much wood could a woodchuck chuck?\";\n    long spaces = str.codePoints().filter( ch -> ch == ' ').count();\n    System.out.println(\"spaces: \" + spaces);\n    String result = DoubleStream.of(values).mapToObj( v -> \"\" + v).collect(Collectors.joining(\" | \"));\n    System.out.println(result);\n    OptionalDouble result2 = DoubleStream.of(values).filter( v -> v > 100).findFirst();\n    System.out.println(result2);\n    n = values.length;\n    int pos = IntStream.range(0, n).filter( i -> values[i] == 100).findFirst().orElse(-1);\n    System.out.println(\"pos: \" + pos);\n}\n","name":"main","className":"CommonAlgorithmsRevisited","variables":{"average":2,"largest":2,"Collectors":1,"ch":2,"smallest":2,"values":2,"squares":1,"args":1,"str":2,"result":1,"total":2,"pos":2,"spaces":2,"DoubleStream":6,"Arrays":1,"IntStream":2,"result2":1},"javaDoc":"","isEmpty":false,"lineCount":22,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getPopulation":6,"average":1,"groupingBy":2,"compare":1,"distinct":2,"parse":1,"toList":5,"orElse":1,"filter":3,"sorted":1,"stream":8,"findAny":1,"mapToInt":1,"get":1,"equals":1,"ifPresent":1,"limit":1,"lines":1,"map":3,"collect":7,"averagingInt":1,"getContinent":5,"System.out.println":8},"constants":{"\"../population.txt\"":1,"100_000_000":2,"\"Countries by continent: \"":1,"\"Average population by continent: \"":1,"\"Ten most populous countries: \"":1,"\"Africa\"":1,"\"A populous country: \"":1,"\"Continents with populous countries: \"":1,"\"Average population of all countries: \"":1,"\"African countries: \"":1,"\"Continents: \"":1,"10":1},"annotations":[],"types":{"Stream<Country>":2,"Map<String, Double>":1,"Optional<Country>":1,"double":1,"Map<String, List<Country>>":1,"List<Country>":2,"Stream<String>":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../population.txt\"))) {\n        Stream<Country> countries = lines.map( line -> Country.parse(line));\n        List<Country> countryList = countries.collect(Collectors.toList());\n        Stream<Country> africanCountries = countryList.stream().filter( c -> c.getContinent().equals(\"Africa\"));\n        System.out.println(\"African countries: \" + africanCountries.collect(Collectors.toList()));\n        Stream<String> continents = countryList.stream().map( c -> c.getContinent()).distinct();\n        System.out.println(\"Continents: \" + continents.collect(Collectors.toList()));\n        Stream<String> continentsWithPopulousCountries = countryList.stream().filter( c -> c.getPopulation() >= 100_000_000).map( c -> c.getContinent()).distinct();\n        System.out.println(\"Continents with populous countries: \" + continentsWithPopulousCountries.collect(Collectors.toList()));\n        Optional<Country> aPopulousCountry = countryList.stream().filter( country -> country.getPopulation() > 100_000_000).findAny();\n        aPopulousCountry.ifPresent( c -> System.out.println(\"A populous country: \" + c));\n        List<Country> mostPopulous = countryList.stream().sorted(( c,  d) -> Double.compare(d.getPopulation(), c.getPopulation())).limit(10).collect(Collectors.toList());\n        System.out.println(\"Ten most populous countries: \" + mostPopulous);\n        double average = countryList.stream().mapToInt( country -> country.getPopulation()).average().orElse(0);\n        System.out.println(\"Average population of all countries: \" + average);\n        Map<String, List<Country>> countriesByContinent = countryList.stream().collect(Collectors.groupingBy( c -> c.getContinent()));\n        System.out.println(\"Countries by continent: \" + countriesByContinent);\n        Map<String, Double> averagePopulationByContinent = countryList.stream().collect(Collectors.groupingBy( c -> c.getContinent(), Collectors.averagingInt( c -> c.getPopulation())));\n        System.out.println(\"Average population by continent: \" + averagePopulationByContinent);\n    }\n}\n","name":"main","className":"Countries","variables":{"Collectors":8,"country":4,"average":2,"aPopulousCountry":2,"line":1,"mostPopulous":2,"averagePopulationByContinent":2,"countries":2,"countryList":9,"africanCountries":2,"Double":1,"continents":2,"args":1,"continentsWithPopulousCountries":2,"Country":1,"Paths":1,"lines":2,"Files":1,"countriesByContinent":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"Country","methodCalls":{"parseInt":1,"split":1},"constants":{"\"\\\\|\"":1},"annotations":[],"types":{"Country":1,"String[]":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static Country parse(String line) {\n    String[] fields = line.split(\"\\\\|\");\n    Country country = new Country();\n    country.name = fields[0];\n    country.continent = fields[1];\n    country.population = Integer.parseInt(fields[2]);\n    return country;\n}\n","name":"parse","className":"Country","variables":{"Integer":1,"country":2,"line":2,"fields":4},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getContinent() {\n    return continent;\n}\n","name":"getContinent","className":"Country","variables":{"continent":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getPopulation() {\n    return population;\n}\n","name":"getPopulation","className":"Country","variables":{"population":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return name;\n}\n","name":"toString","className":"Country","variables":{"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"next":1,"filter":1,"size":1,"stream":2,"parallel":1,"forEach":1,"count":1,"length":2,"hasNext":1,"System.out.println":2},"constants":{"\"count: \"":1,"\"../words.txt\"":1,"10":2,"\"longWords.size(): \"":1},"annotations":[],"types":{"Scanner":1,"ArrayList":2,"long":1,"List<String>":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../words.txt\"));\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNext()) {\n        wordList.add(in.next());\n    }\n    long count = wordList.stream().filter( w -> w.length() > 10).count();\n    System.out.println(\"count: \" + count);\n    List<String> longWords = new ArrayList<>();\n    // The following code will probably throw an exception\n    wordList.stream().parallel().forEach( w -> {\n        if (w.length() > 10) {\n            longWords.add(w);\n        }\n    });\n    // If the program made it until here, the size will\n    // probably be wrong\n    System.out.println(\"longWords.size(): \" + longWords.size());\n}\n","name":"main","className":"Horror","variables":{"args":1,"in":3,"wordList":4,"count":2,"longWords":3},"javaDoc":"","comments":"If the program made it until here the size will The following code will probably throw an exception probably be wrong ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"max":1,"count":1,"length":1,"comparing":2,"toList":2,"orElse":2,"filter":11,"min":1,"get":5,"endsWith":5,"limit":1,"hasFiveVowels":5,"lines":5,"collect":2,"System.out.println":5},"constants":{"\"\"":2,"\"Number of words with all five vowels: \"":1,"\"'s\"":5,"\"All of that length: \"":1,"\"Longest: \"":1,"\"20 words with all five vowels: \"":1,"\"Shortest: \"":1,"\"../words.txt\"":5,"20":1},"annotations":[],"types":{"Stream<String>":5,"String":2,"long":1,"List<String>":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodReferenceExpr","TypeExpr","UnaryExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        long count = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).count();\n        System.out.println(\"Number of words with all five vowels: \" + count);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        List<String> examples = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).limit(20).collect(Collectors.toList());\n        System.out.println(\"20 words with all five vowels: \" + examples);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        String shortest = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).min(Comparator.comparing(String::length)).orElse(\"\");\n        System.out.println(\"Shortest: \" + shortest);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        List<String> allShortest = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).filter( w -> w.length() == 7).collect(Collectors.toList());\n        System.out.println(\"All of that length: \" + allShortest);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        String longest = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).max(Comparator.comparing(String::length)).orElse(\"\");\n        System.out.println(\"Longest: \" + longest);\n    }\n}\n","name":"main","className":"Words","variables":{"args":1,"Collectors":2,"longest":2,"examples":2,"count":2,"allShortest":2,"Paths":5,"lines":10,"Files":5,"shortest":2,"Comparator":2},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"filter":1,"toLowerCase":1,"count":1,"distinct":1,"codePoints":1},"constants":{"'i'":1,"'e'":1,"'u'":1,"'a'":1,"'o'":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","LambdaExpr","NameExpr","CharLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static boolean hasFiveVowels(String word) {\n    return word.toLowerCase().codePoints().filter( c -> c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').distinct().count() == 5;\n}\n","name":"hasFiveVowels","className":"Words","variables":{"word":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"List<Movie>","methodCalls":{"add":1,"parseInt":1,"nextLine":5,"hasNextLine":1,"getList":3,"getString":2},"constants":{},"annotations":[],"types":{"Scanner":1,"List<Movie>":1,"ArrayList":1,"String":5},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["WhileStmt","TryStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["IOException"],"text":"public static List<Movie> readMovies(String filename) throws IOException {\n    List<Movie> movies = new ArrayList<>();\n    try (Scanner in = new Scanner(new File(filename))) {\n        while (in.hasNextLine()) {\n            String nameLine = in.nextLine();\n            String yearLine = in.nextLine();\n            String directorsLine = in.nextLine();\n            String producersLine = in.nextLine();\n            String actorsLine = in.nextLine();\n            movies.add(new Movie(getString(nameLine), Integer.parseInt(getString(yearLine)), getList(directorsLine), getList(producersLine), getList(actorsLine)));\n        }\n    }\n    return movies;\n}\n","name":"readMovies","className":"Movies","variables":{"movies":3,"Integer":1,"filename":2,"in":7,"yearLine":1,"actorsLine":1,"directorsLine":1,"producersLine":1,"nameLine":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"trim":1,"indexOf":1,"substring":1},"constants":{"\":\"":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private static String getString(String line) {\n    int colon = line.indexOf(\":\");\n    return line.substring(colon + 1).trim();\n}\n","name":"getString","className":"Movies","variables":{"line":3,"colon":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":10}
{"paramTypes":["String"],"returnType":"List<String>","methodCalls":{"split":1,"of":1,"getString":1,"toList":1,"collect":1},"constants":{"\", \"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"private static List<String> getList(String line) {\n    return Stream.of(getString(line).split(\", \")).collect(Collectors.toList());\n/* Alternative without streams:\n      ArrayList<String> result = new ArrayList<>();\n      for (String s : getString(line).split(\", \"))\n      {\n         result.add(s);\n      }\n      return result;\n      */\n}\n","name":"getList","className":"Movies","variables":{"Collectors":1,"line":1,"Stream":1},"javaDoc":"","comments":"Alternative without streams: ArrayList<String> result = new ArrayList<>(); for (String s : getString(line) split(\" \")) { result add(s); } return result; ","isEmpty":false,"lineCount":2,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"groupingBy":2,"toList":2,"substring":1,"remove":1,"getActors":4,"getTitle":4,"readMovies":1,"stream":9,"ifPresent":1,"get":3,"map":3,"System.out.println":10,"counting":1,"getKey":1,"intersect":1,"max":3,"entrySet":1,"count":3,"comparing":1,"orElse":1,"filter":5,"getValue":1,"commonActorAndDirector":1,"size":8,"mapToInt":1,"getDirectors":3,"collect":4,"startsWith":2},"constants":{"\"\"":1,"\"The \"":1,"\" directed \"":1,"\"The most actors in a movie: \"":1,"\"Movie with most actors: \"":1,"\"X\"":1,"\"Movies by first letter: \"":1,"\"Movies that start with X: \"":1,"\"movies.txt\"":1,"\"Directors in the database: \"":1,"\" movies:\"":1,"\"Movies in which directors are actors: \"":2,"\"Movies starting with The: \"":1},"annotations":[],"types":{"List<Movie>":1,"Map<String, Long>":1,"Map<String, List<Movie>>":1,"String":1,"long":1,"int":1,"List<String>":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    List<Movie> movieList = readMovies(\"movies.txt\");\n    List<String> result1 = movieList.stream().map( m -> m.getTitle()).filter( t -> t.startsWith(\"X\")).collect(Collectors.toList());\n    System.out.println(\"Movies that start with X: \" + result1);\n    long count = movieList.stream().map( m -> intersect(m.getDirectors(), m.getActors())).filter( l -> l.size() > 0).count();\n    System.out.println(\"Movies in which directors are actors: \" + count);\n    count = movieList.stream().filter( m -> commonActorAndDirector(m)).count();\n    System.out.println(\"Movies in which directors are actors: \" + count);\n    int result2 = movieList.stream().mapToInt( m -> m.getActors().size()).max().orElse(0);\n    System.out.println(\"The most actors in a movie: \" + result2);\n    movieList.stream().max(( a,  b) -> a.getActors().size() - b.getActors().size()).ifPresent( m -> System.out.println(\"Movie with most actors: \" + m));\n    /* Alternative: \n      movieList.stream()\n         .max(Comparator.comparing(m -> m.getActors().size()))\n\t     .ifPresent(m -> System.out.println(\"Movie with most actors: \" + m));\n      */\n    Map<String, Long> firstLetters = movieList.stream().collect(Collectors.groupingBy( m -> m.getTitle().substring(0, 1), Collectors.counting()));\n    System.out.println(\"Movies by first letter: \" + firstLetters);\n    System.out.println(\"Movies starting with The: \" + movieList.stream().filter( m -> m.getTitle().startsWith(\"The \")).count());\n    Map<String, List<Movie>> moviesByDirector = movieList.stream().filter( m -> m.getDirectors().size() > 0).collect(Collectors.groupingBy( m -> m.getDirectors().get(0)));\n    moviesByDirector.remove(\"\");\n    System.out.println(\"Directors in the database: \" + moviesByDirector.size());\n    String mostProlificDirector = Collections.max(moviesByDirector.entrySet(), Comparator.comparing( e -> e.getValue().size())).getKey();\n    System.out.println(mostProlificDirector + \" directed \" + moviesByDirector.get(mostProlificDirector).size() + \" movies:\");\n    List<String> titles = moviesByDirector.get(mostProlificDirector).stream().map( m -> m.getTitle()).collect(Collectors.toList());\n    System.out.println(titles);\n}\n","name":"main","className":"Movies","variables":{"args":1,"moviesByDirector":6,"Collectors":5,"firstLetters":2,"count":4,"mostProlificDirector":2,"movieList":9,"titles":1,"Collections":1,"result2":2,"result1":2,"Comparator":1},"javaDoc":"","comments":"Alternative: movieList stream() max(Comparator comparing(m -> m getActors() size())) ifPresent(m -> System out println(\"Movie with most actors: \" + m)); ","isEmpty":false,"lineCount":21,"modifier":9}
{"paramTypes":["Movie"],"returnType":"boolean","methodCalls":{"contains":1,"getActors":1,"stream":1,"getDirectors":1,"anyMatch":1},"constants":{},"annotations":[],"types":{},"expressions":["LambdaExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static boolean commonActorAndDirector(Movie m) {\n    return m.getDirectors().stream().anyMatch( d -> m.getActors().contains(d));\n}\n","name":"commonActorAndDirector","className":"Movies","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["Collection<String>","Collection<String>"],"returnType":"Set<String>","methodCalls":{"retainAll":1},"constants":{},"annotations":[],"types":{"Set<String>":1,"HashSet":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static Set<String> intersect(Collection<String> a, Collection<String> b) {\n    Set<String> intersection = new HashSet<>(a);\n    intersection.retainAll(b);\n    return intersection;\n}\n","name":"intersect","className":"Movies","variables":{"intersection":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["List<String>"],"returnType":"boolean","methodCalls":{"lastIndexOf":1,"sorted":1,"stream":2,"equals":1,"toList":2,"collect":2,"map":1,"substring":1},"constants":{"\" \"":1},"annotations":[],"types":{"List<String>":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static boolean isSorted(List<String> names) {\n    List<String> lastNames = names.stream().map( n -> n.substring(n.lastIndexOf(\" \") + 1)).collect(Collectors.toList());\n    return lastNames.equals(lastNames.stream().sorted().collect(Collectors.toList()));\n}\n","name":"isSorted","className":"Movies","variables":{"Collectors":2,"names":2,"lastNames":3},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String","int","List<String>","List<String>","List<String>"],"returnType":"Movie","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Movie(String title, int year, List<String> directors, List<String> producers, List<String> actors) {\n    this.title = title;\n    this.year = year;\n    this.directors = directors;\n    this.producers = producers;\n    this.actors = actors;\n}\n","name":"Movie","className":"Movie","variables":{"actors":2,"year":2,"directors":2,"title":2,"producers":2},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public List<String> getActors() {\n    return actors;\n}\n","name":"getActors","className":"Movie","variables":{"actors":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public List<String> getDirectors() {\n    return directors;\n}\n","name":"getDirectors","className":"Movie","variables":{"directors":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public List<String> getProducers() {\n    return producers;\n}\n","name":"getProducers","className":"Movie","variables":{"producers":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getTitle() {\n    return title;\n}\n","name":"getTitle","className":"Movie","variables":{"title":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getYear() {\n    return year;\n}\n","name":"getYear","className":"Movie","variables":{"year":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"\\nProduced by: \"":1,"\"\\nYear: \"":1,"\"\\nDirected by: \"":1,"\"\\nActors: \"":1,"\"Name: \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"Name: \" + title + \"\\nYear: \" + year + \"\\nDirected by: \" + directors + \"\\nProduced by: \" + producers + \"\\nActors: \" + actors;\n}\n","name":"toString","className":"Movie","variables":{"actors":1,"year":1,"directors":1,"title":1,"producers":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"encode":2,"getJsonObject":1,"size":2,"createReader":1,"getJsonArray":1,"getString":1,"printFilm":1,"openStream":1,"readObject":1},"constants":{"\"\"":1,"\"    \\\"id\\\": \\\"/en/drama\\\"\"":1,"\"  \\\"name\\\": null,\"":1,"\"  \\\"type\\\": \\\"/film/film\\\",\"":1,"\"[{\"":1,"\"result\"":1,"\"}]\"":1,"\"  \\\"genre\\\": [{\"":1,"\"    \\\"id\\\": \\\"/en/united_states\\\"\"":1,"\"  }]\"":1,"\"  \\\"produced_by\\\": [],\"":1,"\"?query=\"":1,"\"  \\\"directed_by\\\": [],\"":1,"\"&key=\"":1,"\"&cursor\"":1,"\"=\"":1,"false":1,"\"  \\\"country\\\": [{\"":1,"100":1,"\"  \\\"starring\\\": [{\"":1,"\"UTF-8\"":2,"\"  }],\"":2,"null":2,"\"https://www.googleapis.com/freebase/v1/mqlread\"":1,"\"  \\\"initial_release_date\\\": null,\"":1,"\"    \\\"actor\\\": []\"":1,"\"cursor\"":1},"annotations":[],"types":{"JsonArray":1,"boolean":1,"InputStream":1,"JsonReader":1,"JsonObject":1,"String":5,"URL":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","ConditionalExpr","UnaryExpr","AssignExpr","NullLiteralExpr","BooleanLiteralExpr","EnclosedExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","TryStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"public static void main(String[] args) throws Exception {\n    String apiKey = args[0];\n    String urlString = \"https://www.googleapis.com/freebase/v1/mqlread\";\n    String query = \"[{\" + \"  \\\"type\\\": \\\"/film/film\\\",\" + \"  \\\"name\\\": null,\" + \"  \\\"initial_release_date\\\": null,\" + \"  \\\"directed_by\\\": [],\" + \"  \\\"produced_by\\\": [],\" + \"  \\\"starring\\\": [{\" + \"    \\\"actor\\\": []\" + \"  }],\" + \"  \\\"country\\\": [{\" + \"    \\\"id\\\": \\\"/en/united_states\\\"\" + \"  }],\" + \"  \\\"genre\\\": [{\" + \"    \\\"id\\\": \\\"/en/drama\\\"\" + \"  }]\" + \"}]\";\n    String cursor = null;\n    boolean done = false;\n    while (!done) {\n        String request = \"?query=\" + URLEncoder.encode(query, \"UTF-8\") + \"&key=\" + apiKey + \"&cursor\" + (cursor == null ? \"\" : \"=\" + URLEncoder.encode(cursor, \"UTF-8\"));\n        URL url = new URL(urlString + request);\n        try (InputStream in = url.openStream()) {\n            JsonReader reader = Json.createReader(in);\n            JsonObject contents = reader.readObject();\n            JsonArray result = contents.getJsonArray(\"result\");\n            for (int k = 0; k < result.size(); k++) {\n                printFilm(result.getJsonObject(k));\n            }\n            done = result.size() < 100;\n            if (!done) {\n                cursor = contents.getString(\"cursor\");\n            }\n        }\n    }\n}\n","name":"main","className":"Freebase","variables":{"cursor":3,"request":2,"apiKey":2,"in":1,"reader":2,"query":1,"urlString":2,"Json":1,"done":4,"url":2,"args":2,"result":4,"contents":3,"URLEncoder":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String","List<JsonValue>"],"returnType":"StringBuilder","methodCalls":{"size":1,"get":1,"replace":1,"toString":1,"append":4},"constants":{"\" \"":1,"\",\"":1,"\": \"":1,"\", \"":1},"annotations":[],"types":{"StringBuilder":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static StringBuilder format(String title, List<JsonValue> array) {\n    StringBuilder result = new StringBuilder();\n    result.append(title);\n    result.append(\": \");\n    for (int i = 0; i < array.size(); i++) {\n        if (i > 0) {\n            result.append(\", \");\n        }\n        result.append(array.get(i).toString().replace(\",\", \" \"));\n    }\n    return result;\n}\n","name":"format","className":"Freebase","variables":{"result":6,"array":3,"title":1},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["JsonObject"],"returnType":"void","methodCalls":{"getJsonObject":1,"size":1,"addAll":1,"get":1,"getJsonArray":4,"replace":1,"format":3,"toString":1,"getString":1,"substring":1,"System.out.println":5},"constants":{"\"\"":1,"\"Actors\"":1,"\"Produced by\"":1,"\"Year: \"":1,"\"\\\"\"":1,"\"actor\"":1,"\"Name: \"":1,"\"directed_by\"":1,"\"initial_release_date\"":1,"\"produced_by\"":1,"\"name\"":1,"\"starring\"":1,"\"Directed by\"":1},"annotations":[],"types":{"List<JsonValue>":1,"JsonArray":1,"ArrayList":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void printFilm(JsonObject film) {\n    System.out.println(\"Name: \" + film.getString(\"name\"));\n    System.out.println(\"Year: \" + film.get(\"initial_release_date\").toString().replace(\"\\\"\", \"\").substring(0, 4));\n    System.out.println(format(\"Directed by\", film.getJsonArray(\"directed_by\")));\n    System.out.println(format(\"Produced by\", film.getJsonArray(\"produced_by\")));\n    List<JsonValue> actors = new ArrayList<>();\n    JsonArray jactors = film.getJsonArray(\"starring\");\n    for (int i = 0; i < jactors.size(); i++) {\n        actors.addAll(jactors.getJsonObject(i).getJsonArray(\"actor\"));\n    }\n    System.out.println(format(\"Actors\", actors));\n}\n","name":"printFilm","className":"Freebase","variables":{"actors":2,"film":6,"jactors":3},"javaDoc":"","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sorted":2,"of":5,"toUpperCase":1,"show":6,"limit":2,"toArray":1,"toString":1,"map":3,"generate":1,"iterate":1,"System.out.println":1},"constants":{"80.0":1,"\"Sorting numbers with a method reference\"":1,"\" \"":4,"\"Constructing accounts with a constructor reference\"":1,"\"Using toArray with an array constructor reference: \"":1,"67.5":1,"0.0":1,"35.0":1,"\"how much wood could a wood chuck chuck\"":4,"32.0":1,"\"Mapping to uppercase with a lambda expression\"":1,"\"Mapping to uppercase with a method reference\"":1,"65.0":1,"54.0":1,"1000.0":1,"100.0":1,"\"Mapping with a constructor reference\"":1,"29.0":1,"115.0":1,"\"Sorting strings with a method reference\"":1,"44.5":1},"annotations":[],"types":{"Stream<Double>":1,"Stream<String>":1,"String[]":1,"Stream<BankAccount>":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodReferenceExpr","TypeExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).map( w -> w.toUpperCase());\n    show(\"Mapping to uppercase with a lambda expression\", words);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).map(String::toUpperCase);\n    show(\"Mapping to uppercase with a method reference\", words);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).sorted(String::compareTo);\n    show(\"Sorting strings with a method reference\", words);\n    Stream<Double> numbers = Stream.of(32.0, 54.0, 67.5, 29.0, 35.0, 80.0, 115.0, 44.5, 100.0, 65.0).sorted(Double::compare);\n    show(\"Sorting numbers with a method reference\", numbers);\n    Stream<BankAccount> accounts = Stream.generate(BankAccount::new).limit(5);\n    show(\"Constructing accounts with a constructor reference\", accounts);\n    accounts = Stream.iterate(0.0,  n -> n + 1000.0).map(BankAccount::new).limit(5);\n    show(\"Mapping with a constructor reference\", accounts);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \"));\n    String[] array = words.toArray(String[]::new);\n    System.out.println(\"Using toArray with an array constructor reference: \" + Arrays.toString(array));\n}\n","name":"main","className":"MethodReferences","variables":{"args":1,"array":1,"words":5,"numbers":1,"Stream":7,"accounts":2,"Arrays":1},"javaDoc":"","isEmpty":false,"lineCount":15,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"constants":{"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"annotations":[],"types":{"List<T>":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"MethodReferences","variables":{"Collectors":1,"stream":2,"values":4,"caption":2,"Math":1,"SHOW_LIMIT":3},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"]\"":1,"\"BankAccount[balance=\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"BankAccount[balance=\" + balance + \"]\";\n}\n","name":"toString","className":"BankAccount","variables":{"balance":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"filter":1,"nextLine":1,"stream":1,"hasNextLine":1,"length":2,"count":1,"System.out.println":2},"constants":{"\"../countries.txt\"":1,"\"Long words: \"":2,"10":2},"annotations":[],"types":{"Scanner":1,"ArrayList":1,"String":1,"long":1,"List<String>":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","LambdaExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../countries.txt\"));\n    // This file contains one country name per line\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNextLine()) {\n        wordList.add(in.nextLine());\n    }\n    // Now wordList is a list of country names\n    // Traditional loop for counting the long words\n    long count = 0;\n    for (String w : wordList) {\n        if (w.length() > 10) {\n            count++;\n        }\n    }\n    System.out.println(\"Long words: \" + count);\n    // The same computation with streams\n    count = wordList.stream().filter( w -> w.length() > 10).count();\n    System.out.println(\"Long words: \" + count);\n}\n","name":"main","className":"StreamDemo","variables":{"args":1,"in":3,"wordList":4,"count":5},"javaDoc":"","comments":"Now wordList is a list of country names This file contains one country name per line Traditional loop for counting the long words The same computation with streams ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"next":1,"max":1,"length":3,"hasNext":1,"orElse":1,"allMatch":1,"filter":2,"contains":1,"stream":3,"parallel":1,"findAny":1,"ifPresent":1,"endsWith":1,"System.out.print":1,"System.out.println":3},"constants":{"\"None found\"":1,"\"A word ending in y: \"":1,"\"All words contain an e: \"":1,"\"y\"":1,"\"The longest word: \"":1,"\"../words.txt\"":1,"10":1,"\"e\"":1},"annotations":[],"types":{"Scanner":1,"Optional<String>":1,"boolean":1,"ArrayList":1,"Stream<String>":1,"String":1,"List<String>":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../words.txt\"));\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNext()) {\n        wordList.add(in.next());\n    }\n    Stream<String> words = wordList.stream();\n    String result = words.parallel().filter( w -> w.length() > 10).filter( w -> w.endsWith(\"y\")).findAny().orElse(\"None found\");\n    // Note the use of findAny. Run this program several times\n    // and check whether the result changes\n    System.out.println(\"A word ending in y: \" + result);\n    words = wordList.stream();\n    Optional<String> result2 = words.max(( v,  w) -> v.length() - w.length());\n    System.out.print(\"The longest word: \");\n    result2.ifPresent( w -> System.out.println(w));\n    words = wordList.stream();\n    boolean result3 = words.allMatch( w -> w.contains(\"e\"));\n    System.out.println(\"All words contain an e: \" + result3);\n}\n","name":"main","className":"TerminalOperations","variables":{"args":1,"result":2,"in":3,"wordList":5,"words":6,"result3":2,"result2":2},"javaDoc":"","comments":"Note the use of findAny Run this program several times and check whether the result changes ","isEmpty":false,"lineCount":14,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"max":2,"length":3,"range":4,"sum":3,"orElse":2,"mapToObj":1,"substring":1,"ints":1,"sqrt":1,"mapToInt":2,"of":4,"toArray":6,"limit":1,"toString":6,"map":1,"System.out.println":11,"mapToDouble":1},"constants":{"\"Hello\"":2,"\"Mapping ints to doubles: \"":1,"\"Goodbye\"":1,"\"The sum of a range: \"":1,"\"Mapping ints to objects: \"":1,"\"World\"":3,"\"Computing a maximum of ints: \"":1,"\"The sum of a stream of ints from an array: \"":1,"\"The Unicode code points of the string Hello: \"":1,"\"The sum of a stream of ints: \"":1,"101":1,"\"Computing an average of ints: \"":1,"\"Mapping ints to ints: \"":1,"\"Mississippi\"":1,"\"Mapping objects to ints: \"":1,"\"Twenty random die tosses: \"":1,"20":3,"10":1},"annotations":[],"types":{"Random":1,"double":1,"int[]":1,"DoubleStream":1,"Stream<String>":2,"String":1,"IntStream":3,"int":2},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","LambdaExpr","NameExpr","StringLiteralExpr","MethodReferenceExpr","TypeExpr","AssignExpr","ArrayInitializerExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    IntStream stream = IntStream.of(3, 1, 4, 1, 5, 9);\n    System.out.println(\"The sum of a stream of ints: \" + stream.sum());\n    int[] values = { 3, 1, 4, 1, 5, 9 };\n    stream = IntStream.of(values);\n    System.out.println(\"The sum of a stream of ints from an array: \" + stream.sum());\n    stream = IntStream.range(1, 101);\n    System.out.println(\"The sum of a range: \" + stream.sum());\n    Random generator = new Random();\n    IntStream dieTosses = generator.ints(1, 7);\n    System.out.println(\"Twenty random die tosses: \" + Arrays.toString(dieTosses.limit(20).toArray()));\n    IntStream codePoints = \"Hello\".codePoints();\n    System.out.println(\"The Unicode code points of the string Hello: \" + Arrays.toString(codePoints.toArray()));\n    Stream<String> words = Stream.of(\"Hello\", \"World\");\n    stream = words.mapToInt( w -> w.length());\n    System.out.println(\"Mapping objects to ints: \" + Arrays.toString(stream.toArray()));\n    stream = IntStream.range(0, 20).map( n -> Math.max(n, 10));\n    System.out.println(\"Mapping ints to ints: \" + Arrays.toString(stream.toArray()));\n    String river = \"Mississippi\";\n    int n = river.length();\n    Stream<String> prefixes = IntStream.range(0, n).mapToObj( i -> river.substring(0, i + 1));\n    System.out.println(\"Mapping ints to objects: \" + Arrays.toString(prefixes.toArray(String[]::new)));\n    DoubleStream roots = IntStream.range(0, 20).mapToDouble( i -> Math.sqrt(i));\n    System.out.println(\"Mapping ints to doubles: \" + Arrays.toString(roots.toArray()));\n    words = Stream.of(\"Goodbye\", \"World\");\n    double average = words.mapToInt( w -> w.length()).average().orElse(0);\n    System.out.println(\"Computing an average of ints: \" + average);\n    int max = \"World\".codePoints().max().orElse(0);\n    System.out.println(\"Computing a maximum of ints: \" + max);\n}\n","name":"main","className":"PrimitiveStreams","variables":{"average":2,"max":2,"values":1,"words":4,"generator":2,"roots":2,"Math":2,"args":1,"prefixes":2,"stream":10,"Stream":2,"river":3,"dieTosses":2,"Arrays":6,"IntStream":6,"codePoints":2},"javaDoc":"","isEmpty":false,"lineCount":28,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"sorted":1,"of":6,"toLowerCase":3,"equals":1,"show":6,"length":1,"distinct":2,"map":6,"replaceAll":2,"substring":1},"constants":{"\"\"":2,"\"c\"":1,"\"A\"":3,"\"Mapping to lowercase: \"":1,"\"[aeiou]\"":2,"\" \"":3,"\"Distinct words\"":1,"\"Tale\"":3,"\"Counting consonants\"":1,"\"Sorted words\"":1,"\"Words with c\"":1,"\"how much wood could a wood chuck chuck\"":3,"\"of\"":3,"\"Cities\"":3,"\"Removing vowels\"":1,"\"Two\"":3},"annotations":[],"types":{"Stream<Integer>":1,"Stream<String>":6},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"A\", \"Tale\", \"of\", \"Two\", \"Cities\");\n    Stream<String> lowerCaseWords = words.map( w -> w.toLowerCase());\n    show(\"Mapping to lowercase: \", lowerCaseWords);\n    lowerCaseWords = Stream.of(\"A\", \"Tale\", \"of\", \"Two\", \"Cities\").map( w -> w.toLowerCase());\n    Stream<String> consonantsOnly = lowerCaseWords.map( w -> w.replaceAll(\"[aeiou]\", \"\"));\n    show(\"Removing vowels\", consonantsOnly);\n    consonantsOnly = Stream.of(\"A\", \"Tale\", \"of\", \"Two\", \"Cities\").map( w -> w.toLowerCase()).map( w -> w.replaceAll(\"[aeiou]\", \"\"));\n    Stream<Integer> consonantCount = consonantsOnly.map( w -> w.length());\n    show(\"Counting consonants\", consonantCount);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \"));\n    Stream<String> cWords = words.filter( w -> w.substring(0, 1).equals(\"c\"));\n    show(\"Words with c\", cWords);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \"));\n    Stream<String> distinctWords = words.distinct();\n    show(\"Distinct words\", distinctWords);\n    distinctWords = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).distinct();\n    Stream<String> sortedWords = distinctWords.sorted();\n    show(\"Sorted words\", sortedWords);\n}\n","name":"main","className":"Streams","variables":{"args":1,"sortedWords":1,"consonantCount":1,"distinctWords":3,"words":6,"consonantsOnly":3,"Stream":6,"lowerCaseWords":3,"cWords":1},"javaDoc":"","isEmpty":false,"lineCount":18,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"constants":{"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"annotations":[],"types":{"List<T>":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Streams","variables":{"Collectors":1,"stream":2,"values":4,"caption":2,"Math":1,"SHOW_LIMIT":3},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"get":1,"limit":1,"length":1,"distinct":1,"toList":1,"lines":1,"collect":1,"map":2,"substring":1,"System.out.println":1},"constants":{"\"...\"":1,"\"../countries.txt\"":1,"10":1},"annotations":[],"types":{"Stream<String>":1,"List<String>":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../countries.txt\"))) {\n        // Read the lines\n        List<String> result = lines.filter(// Keep only long words\n         w -> w.length() > 10).map(// Truncate to seven characters\n         w -> w.substring(0, 7)).map(// Add ellipses\n         w -> w + \"...\").distinct().limit(// Keep only the first twenty\n        20).collect(// Collect into a list\n        Collectors.toList());\n        System.out.println(result);\n    }\n}\n","name":"main","className":"StreamDemo","variables":{"args":1,"result":1,"Collectors":1,"Paths":1,"lines":2,"Files":1},"javaDoc":"","comments":"Read the lines Keep only long words Truncate to seven characters Add ellipses Remove duplicates Keep only the first twenty Collect into a list ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"counting":1,"groupingBy":4,"toSet":1,"maxBy":1,"of":4,"length":2,"collect":4,"substring":4,"System.out.println":4},"constants":{"\"Counts by first letter: \"":1,"\" \"":1,"\"if a woodchuck could chuck wood\"":1,"\"Longest word by first letter: \"":1,"\"how much wood would a woodchuck chuck \"":1,"\"Lists by first letter: \"":1,"\"Sets by first letter: \"":1},"annotations":[],"types":{"Map<String, Long>":1,"Map<String, List<String>>":1,"String[]":1,"Map<String, Set<String>>":1,"Map<String, Optional<String>>":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","LambdaExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","EnclosedExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String[] words = (\"how much wood would a woodchuck chuck \" + \"if a woodchuck could chuck wood\").split(\" \");\n    Map<String, List<String>> groups = Stream.of(words).collect(Collectors.groupingBy( w -> w.substring(0, 1)));\n    System.out.println(\"Lists by first letter: \" + groups);\n    Map<String, Set<String>> groupOfSets = Stream.of(words).collect(Collectors.groupingBy(// The function for extracting the keys\n     w -> w.substring(0, 1), // The group collector\n    Collectors.toSet()));\n    System.out.println(\"Sets by first letter: \" + groupOfSets);\n    Map<String, Long> groupCounts = Stream.of(words).collect(Collectors.groupingBy( w -> w.substring(0, 1), Collectors.counting()));\n    System.out.println(\"Counts by first letter: \" + groupCounts);\n    Map<String, Optional<String>> groupLongest = Stream.of(words).collect(Collectors.groupingBy(// The function for extracting the keys\n     w -> w.substring(0, 1), Collectors.maxBy(( v,  w) -> v.length() - w.length())));\n    // The comparator function\n    System.out.println(\"Longest word by first letter: \" + groupLongest);\n}\n","name":"main","className":"GroupDemo","variables":{"args":1,"Collectors":7,"words":1,"groups":2,"Stream":4,"groupOfSets":2,"groupCounts":2,"groupLongest":2},"javaDoc":"","comments":"The function for extracting the keys The group collector The function for extracting the keys The comparator function ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getPopulation":1,"groupingBy":1,"get":1,"parse":1,"lines":1,"map":1,"collect":1,"getContinent":1,"summingLong":1,"System.out.println":1},"constants":{"\"../population.txt\"":1,"\"Population per continent: \"":1},"annotations":[],"types":{"Stream<Country>":1,"Map<String, Long>":1,"Stream<String>":1},"expressions":["VariableDeclarationExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../population.txt\"))) {\n        Stream<Country> countries = lines.map( line -> Country.parse(line));\n        Map<String, Long> groupSum = countries.collect(Collectors.groupingBy(// The function for extracting the keys\n         c -> c.getContinent(), Collectors.summingLong(// The function for getting the summands\n         c -> c.getPopulation())));\n        System.out.println(\"Population per continent: \" + groupSum);\n    }\n}\n","name":"main","className":"GroupDemo2","variables":{"args":1,"Collectors":2,"groupSum":2,"line":1,"Country":1,"Paths":1,"countries":2,"lines":2,"Files":1},"javaDoc":"","comments":"The function for extracting the keys The function for getting the summands ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"Country","methodCalls":{"parseInt":1,"split":1},"constants":{"\"\\\\|\"":1},"annotations":[],"types":{"Country":1,"String[]":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static Country parse(String line) {\n    String[] fields = line.split(\"\\\\|\");\n    Country country = new Country();\n    country.name = fields[0];\n    country.continent = fields[1];\n    country.population = Integer.parseInt(fields[2]);\n    return country;\n}\n","name":"parse","className":"Country","variables":{"Integer":1,"country":2,"line":2,"fields":4},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getContinent() {\n    return continent;\n}\n","name":"getContinent","className":"Country","variables":{"continent":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getPopulation() {\n    return population;\n}\n","name":"getPopulation","className":"Country","variables":{"population":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"|\"":2},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return name + \"|\" + continent + \"|\" + population;\n}\n","name":"toString","className":"Country","variables":{"continent":1,"name":1,"population":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"closeReservation":1,"writeObject":1,"length":2,"sortFlights":1,"removeFlight":1,"readLine":17,"sortPassengers":1,"printMenu":2,"addPassenger":1,"flightExists":1,"readObject":1,"print":1,"trim":15,"toUpperCase":1,"addFlight":1,"passengerExists":1,"listPassengers":1,"listFlights":1,"removePassenger":1,"close":4,"System.out.print":50,"charAt":1},"constants":{"\" was written\\n\"":2,"\" was read\\n\"":2,"\" was not found\\n\"":2,"\"flight not found\\n\"":2,"\"IO Exception\\n\"":1,"\"Please enter the file name to write:\\n\"":2,"\"The first line of the file is:\\n\"":1,"\"An I/O error has occurred\\n\"":4,"\"The object is not serializable\\n\"":1,"\"Please enter the flight number to remove:\\n\"":1,"\"Please enter the passenger information to add:\\n\"":1,"\"flight removed\\n\"":1,"\"Please enter the airlines to search:\\n\"":1,"\"Unknown action\\n\"":2,"\"passenger not found\\n\"":2,"\"flight found\\n\"":1,"'Q'":1,"\"flight exists\\n\"":1,"\"passenger removed\\n\"":1,"\"Please enter the flight's departure city to remove:\\n\"":1,"\"Please enter the flight's departure city to search:\\n\"":1,"\"passenger exists\\n\"":1,"\"flight added\\n\"":1,"\"passenger found\\n\"":1,"\"passengers sorted\\n\"":1,"\"The Class is not found\\n\"":1,"\"Please enter the passengerID of a passenger to search:\\n\"":1,"\"What action would you like to perform?\\n\"":1,"\"Please enter the airlines to remove:\\n\"":1,"\"Please enter the passengerID to remove:\\n\"":1,"null":8,"\"Please enter the flight number to search:\\n\"":1,"\"Please enter a string to write in the file:\\n\"":1,"\"passenger added\\n\"":1,"true":4,"\"flights sorted\\n\"":1,"\"Please enter the flight information to add:\\n\"":1,"\"Please enter the file name to read:\\n\"":2,"\"\\n\"":2,"\"reservation closed\\n\"":1},"annotations":[],"types":{"InputStreamReader":1,"FileWriter":1,"String":7,"ObjectOutputStream":1,"int":1,"FileInputStream":1,"BufferedWriter":1,"Reservation":1,"boolean":1,"FileOutputStream":1,"char":1,"BufferedReader":2,"FileReader":1,"PrintWriter":1,"ObjectInputStream":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","CharLiteralExpr","UnaryExpr","AssignExpr","NullLiteralExpr","BooleanLiteralExpr","CastExpr","FieldAccessExpr","MethodCallExpr"],"statements":["SwitchStmt","IfStmt","BreakStmt","TryStmt","BlockStmt","SwitchEntryStmt","ExpressionStmt","DoStmt"],"concepts":[],"exceptions":["NotSerializableException","FileNotFoundException","IOException","ClassNotFoundException","Exception"],"text":"public static void main(String[] args) {\n    char input1;\n    String inputInfo = new String(), inputInfo2 = new String();\n    String name = new String(), flightNum = new String(), deptCity = new String();\n    boolean operation;\n    int operation2;\n    String line = new String();\n    String passengerInfo = new String(), flightInfo = new String();\n    String filename = new String();\n    // create a Reservation object. This is used throughout this class.\n    Reservation reservation1 = new Reservation();\n    try {\n        // print out the menu\n        printMenu();\n        // create a BufferedReader object to read input from a keyboard\n        InputStreamReader isr = new InputStreamReader(System.in);\n        BufferedReader stdin = new BufferedReader(isr);\n        do {\n            System.out.print(\"What action would you like to perform?\\n\");\n            //read a line\n            line = stdin.readLine().trim();\n            input1 = line.charAt(0);\n            input1 = Character.toUpperCase(input1);\n            if (//check if a user entered only one character\n            line.length() == 1) {\n                switch(input1) {\n                    case //Add Passenger\n                    'A':\n                        System.out.print(\"Please enter the passenger information to add:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        operation = reservation1.addPassenger(inputInfo);\n                        if (operation == true)\n                            System.out.print(\"passenger added\\n\");\n                        else\n                            System.out.print(\"passenger exists\\n\");\n                        break;\n                    case //Add Flight\n                    'B':\n                        System.out.print(\"Please enter the flight information to add:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        operation = reservation1.addFlight(inputInfo);\n                        if (operation == true)\n                            System.out.print(\"flight added\\n\");\n                        else\n                            System.out.print(\"flight exists\\n\");\n                        break;\n                    case //Search for Passenger\n                    'D':\n                        System.out.print(\"Please enter the passengerID of a passenger to search:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        operation2 = reservation1.passengerExists(inputInfo);\n                        if (operation2 > -1)\n                            System.out.print(\"passenger found\\n\");\n                        else\n                            System.out.print(\"passenger not found\\n\");\n                        break;\n                    case //Search for Flight\n                    'E':\n                        System.out.print(\"Please enter the airlines to search:\\n\");\n                        name = stdin.readLine().trim();\n                        System.out.print(\"Please enter the flight number to search:\\n\");\n                        flightNum = stdin.readLine().trim();\n                        System.out.print(\"Please enter the flight's departure city to search:\\n\");\n                        deptCity = stdin.readLine().trim();\n                        operation2 = reservation1.flightExists(name, flightNum, deptCity);\n                        if (operation2 > -1)\n                            System.out.print(\"flight found\\n\");\n                        else\n                            System.out.print(\"flight not found\\n\");\n                        break;\n                    case //List Passengers\n                    'L':\n                        System.out.print(reservation1.listPassengers());\n                        break;\n                    case //List Flights\n                    'M':\n                        System.out.print(reservation1.listFlights());\n                        break;\n                    case // Sort Passengers\n                    'O':\n                        reservation1.sortPassengers();\n                        System.out.print(\"passengers sorted\\n\");\n                        break;\n                    case // Sort Flights\n                    'P':\n                        reservation1.sortFlights();\n                        System.out.print(\"flights sorted\\n\");\n                        break;\n                    case //Quit\n                    'Q':\n                        break;\n                    case //Remove Passenger\n                    'R':\n                        System.out.print(\"Please enter the passengerID to remove:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        operation = reservation1.removePassenger(inputInfo);\n                        if (operation == true)\n                            System.out.print(\"passenger removed\\n\");\n                        else\n                            System.out.print(\"passenger not found\\n\");\n                        break;\n                    case //Remove Flight\n                    'S':\n                        System.out.print(\"Please enter the airlines to remove:\\n\");\n                        name = stdin.readLine().trim();\n                        System.out.print(\"Please enter the flight number to remove:\\n\");\n                        flightNum = stdin.readLine().trim();\n                        System.out.print(\"Please enter the flight's departure city to remove:\\n\");\n                        deptCity = stdin.readLine().trim();\n                        operation = reservation1.removeFlight(name, flightNum, deptCity);\n                        if (operation == true)\n                            System.out.print(\"flight removed\\n\");\n                        else\n                            System.out.print(\"flight not found\\n\");\n                        break;\n                    case //Close Reservation\n                    'T':\n                        reservation1.closeReservation();\n                        System.out.print(\"reservation closed\\n\");\n                        break;\n                    case //Write Text to a File\n                    'U':\n                        System.out.print(\"Please enter the file name to write:\\n\");\n                        filename = stdin.readLine().trim();\n                        FileWriter fw;\n                        BufferedWriter bw;\n                        PrintWriter outFile = null;\n                        try {\n                            fw = new FileWriter(filename);\n                            bw = new BufferedWriter(fw);\n                            outFile = new PrintWriter(bw);\n                            System.out.print(\"Please enter a string to write in the file:\\n\");\n                            String input = stdin.readLine();\n                            outFile.print(input + \"\\n\");\n                            System.out.print(filename + \" was written\\n\");\n                        } catch (IOException exception) {\n                            System.out.print(\"An I/O error has occurred\\n\");\n                        } finally {\n                            if (outFile != null)\n                                outFile.close();\n                        }\n                        break;\n                    case //Read Text from a File\n                    'V':\n                        System.out.print(\"Please enter the file name to read:\\n\");\n                        filename = stdin.readLine().trim();\n                        FileReader fr;\n                        BufferedReader inFile = null;\n                        try {\n                            fr = new FileReader(filename);\n                            inFile = new BufferedReader(fr);\n                            System.out.print(filename + \" was read\\n\");\n                            String output = inFile.readLine();\n                            System.out.print(\"The first line of the file is:\\n\");\n                            System.out.print(output + \"\\n\");\n                        } catch (FileNotFoundException exception) {\n                            System.out.print(filename + \" was not found\\n\");\n                        } catch (IOException exception) {\n                            System.out.print(\"An I/O error has occurred\\n\");\n                        } finally {\n                            if (inFile != null)\n                                inFile.close();\n                        }\n                        break;\n                    case //Serialize Reservation to a File\n                    'W':\n                        System.out.print(\"Please enter the file name to write:\\n\");\n                        filename = stdin.readLine().trim();\n                        FileOutputStream file;\n                        ObjectOutputStream outStream = null;\n                        try {\n                            file = new FileOutputStream(filename);\n                            outStream = new ObjectOutputStream(file);\n                            outStream.writeObject(reservation1);\n                            System.out.print(filename + \" was written\\n\");\n                        } catch (NotSerializableException exception) {\n                            System.out.print(\"The object is not serializable\\n\");\n                        } catch (IOException exception) {\n                            System.out.print(\"An I/O error has occurred\\n\");\n                        } finally {\n                            if (outStream != null)\n                                outStream.close();\n                        }\n                        break;\n                    case //Deserialize Reservation from a File\n                    'X':\n                        System.out.print(\"Please enter the file name to read:\\n\");\n                        filename = stdin.readLine().trim();\n                        FileInputStream file2;\n                        ObjectInputStream inStream = null;\n                        try {\n                            file2 = new FileInputStream(filename);\n                            inStream = new ObjectInputStream(file2);\n                            reservation1 = (Reservation) inStream.readObject();\n                            System.out.print(filename + \" was read\\n\");\n                        } catch (ClassNotFoundException exception) {\n                            System.out.print(\"The Class is not found\\n\");\n                        } catch (FileNotFoundException exception) {\n                            System.out.print(filename + \" was not found\\n\");\n                        } catch (Exception exception) {\n                            System.out.print(\"An I/O error has occurred\\n\");\n                        } finally {\n                            if (inStream != null)\n                                inStream.close();\n                        }\n                        break;\n                    case //Display Menu\n                    '?':\n                        printMenu();\n                        break;\n                    default:\n                        System.out.print(\"Unknown action\\n\");\n                        break;\n                }\n            } else {\n                System.out.print(\"Unknown action\\n\");\n            }\n        } while (input1 != 'Q' || line.length() != 1);\n    } catch (IOException exception) {\n        System.out.print(\"IO Exception\\n\");\n    }\n}\n","name":"main","className":"Assignment8","variables":{"exception":9,"stdin":17,"line":5,"inStream":5,"input1":5,"isr":2,"fr":3,"outStream":5,"output":2,"fw":3,"flightNum":3,"file":3,"operation2":5,"outFile":5,"bw":3,"inFile":5,"inputInfo":5,"flightInfo":1,"Character":1,"passengerInfo":1,"args":1,"input":2,"filename":15,"inputInfo2":1,"reservation1":13,"name":3,"file2":3,"deptCity":3,"operation":9},"javaDoc":"","comments":"create a Reservation object This is used throughout this class print out the menu create a BufferedReader object to read input from a keyboard read a line check if a user entered only one character Add Passenger Add Flight Search for Passenger Search for Flight List Passengers List Flights Sort Passengers Sort Flights Quit Remove Passenger Remove Flight Close Reservation Write Text to a File Read Text from a File Serialize Reservation to a File System out print(exception+\"\\n\"); Deserialize Reservation from a File Display Menu ","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.print":1},"constants":{"\"S\\t\\tRemove Flight\\n\"":1,"\"X\\t\\tDeserialize Reservation from File\\n\"":1,"\"E\\t\\tSearch for Flight\\n\"":1,"\"T\\t\\tClose Reservation\\n\"":1,"\"Choice\\t\\tAction\\n\"":1,"\"L\\t\\tList Passengers\\n\"":1,"\"P\\t\\tSort Flights\\n\"":1,"\"B\\t\\tAdd Flight\\n\"":1,"\"M\\t\\tList Flights\\n\"":1,"\"O\\t\\tSort Passengers\\n\"":1,"\"Q\\t\\tQuit\\n\"":1,"\"U\\t\\tWrite Text to File\\n\"":1,"\"A\\t\\tAdd Passenger\\n\"":1,"\"W\\t\\tSerialize Reservation to File\\n\"":1,"\"?\\t\\tDisplay Help\\n\\n\"":1,"\"D\\t\\tSearch for Passenger\\n\"":1,"\"R\\t\\tRemove Passenger\\n\"":1,"\"------\\t\\t------\\n\"":1,"\"V\\t\\tRead Text from File\\n\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** The method printMenu displays the menu to a user **/\npublic static void printMenu() {\n    System.out.print(\"Choice\\t\\tAction\\n\" + \"------\\t\\t------\\n\" + \"A\\t\\tAdd Passenger\\n\" + \"B\\t\\tAdd Flight\\n\" + \"D\\t\\tSearch for Passenger\\n\" + \"E\\t\\tSearch for Flight\\n\" + \"L\\t\\tList Passengers\\n\" + \"M\\t\\tList Flights\\n\" + \"O\\t\\tSort Passengers\\n\" + \"P\\t\\tSort Flights\\n\" + \"Q\\t\\tQuit\\n\" + \"R\\t\\tRemove Passenger\\n\" + \"S\\t\\tRemove Flight\\n\" + \"T\\t\\tClose Reservation\\n\" + \"U\\t\\tWrite Text to File\\n\" + \"V\\t\\tRead Text from File\\n\" + \"W\\t\\tSerialize Reservation to File\\n\" + \"X\\t\\tDeserialize Reservation from File\\n\" + \"?\\t\\tDisplay Help\\n\\n\");\n}\n","name":"printMenu","className":"Assignment8","variables":{},"javaDoc":"The method printMenu displays the menu to a user","comments":" The method printMenu displays the menu to a user *","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"CPU","methodCalls":{},"constants":{"\"?\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public CPU() {\n    // type to \"?\" and speed to 0.\n    type = \"?\";\n    speed = 0;\n}\n","name":"CPU","className":"CPU","variables":{"type":1,"speed":1},"javaDoc":"","comments":"type to \"?\" and speed to 0 ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getType() {\n    return type;\n}\n","name":"getType","className":"CPU","variables":{"type":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getSpeed() {\n    return speed;\n}\n","name":"getSpeed","className":"CPU","variables":{"speed":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setType(String t) {\n    type = t;\n}\n","name":"setType","className":"CPU","variables":{"type":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setSpeed(int s) {\n    speed = s;\n}\n","name":"setSpeed","className":"CPU","variables":{"speed":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"HZ\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return type + speed + \"HZ\";\n}\n","name":"toString","className":"CPU","variables":{"type":1,"speed":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Vector","PurchasePanel"],"returnType":"CreatePanel","methodCalls":{"add":15,"addActionListener":1,"setForeground":1,"setLayout":3},"constants":{"\" \"":1,"\"Price\"":1,"\"Manufacturer\"":1,"\"Brand Name\"":1,"\"Year\"":1,"30":1,"20":5,"\"Create a car\"":1},"annotations":[],"types":{"JPanel":3,"JLabel":4},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//Constructor\npublic CreatePanel(Vector carList, PurchasePanel buyPanel) {\n    this.carList = carList;\n    this.buyPanel = buyPanel;\n    message = new JLabel(\" \");\n    message.setForeground(Color.red);\n    //******Initialize all instance varibles and set up  the layouts ******//     \n    this.buyPanel = new PurchasePanel(this.carList);\n    JLabel manuLabel = new JLabel(\"Manufacturer\");\n    JLabel brandLabel = new JLabel(\"Brand Name\");\n    JLabel yearLabel = new JLabel(\"Year\");\n    JLabel priceLabel = new JLabel(\"Price\");\n    manuField = new JTextField(20);\n    brandField = new JTextField(20);\n    yearField = new JTextField(20);\n    priceField = new JTextField(20);\n    display = new JTextArea(20, 30);\n    myPanel = new JPanel();\n    myPanel.setLayout(new BorderLayout());\n    JPanel inputPanel = new JPanel();\n    inputPanel.setLayout(new BorderLayout());\n    JPanel parameterPane = new JPanel();\n    parameterPane.setLayout(new GridLayout(4, 1));\n    JPanel outputPanel = new JPanel();\n    myPanel.add(inputPanel, BorderLayout.WEST);\n    myPanel.add(outputPanel, BorderLayout.EAST);\n    inputPanel.add(message, BorderLayout.NORTH);\n    inputPanel.add(parameterPane, BorderLayout.CENTER);\n    parameterPane.add(manuLabel);\n    parameterPane.add(manuField);\n    parameterPane.add(brandLabel);\n    parameterPane.add(brandField);\n    parameterPane.add(yearLabel);\n    parameterPane.add(yearField);\n    parameterPane.add(priceLabel);\n    parameterPane.add(priceField);\n    //******Never forget to register the listener object with its source object, such as the following example ******//\n    createButton = new JButton(\"Create a car\");\n    createButton.addActionListener(new ButtonListener());\n    inputPanel.add(createButton, BorderLayout.SOUTH);\n    outputPanel.add(display);\n    add(myPanel);\n}\n","name":"CreatePanel","className":"CreatePanel","variables":{"yearField":1,"outputPanel":2,"buyPanel":2,"yearLabel":1,"display":1,"manuField":1,"carList":2,"message":2,"myPanel":4,"inputPanel":5,"parameterPane":10,"brandField":1,"priceField":1,"createButton":2,"brandLabel":1,"priceLabel":1,"manuLabel":1},"javaDoc":"","comments":"Initialize all instance varibles and set up the layouts // Never forget to register the listener object with its source object such as the following example // Constructor","isEmpty":false,"lineCount":39,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseInt":3,"parseDouble":2,"add":2,"getBrandName":1,"size":1,"getYear":1,"getText":5,"getManufacturer":1,"setForeground":1,"updateOutput":2,"equalsIgnoreCase":3,"setText":5},"constants":{"\"\"":1,"false":1,"true":1,"\"Please enter correct data format\"":1,"\"Car added\"":2,"\"Please fill all fields\"":1,"\"Car not added - duplicate\"":1},"annotations":[],"types":{"boolean":1,"Car":2,"Object":1,"String":4},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","CastExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ForeachStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":["NumberFormatException"],"text":"public void actionPerformed(ActionEvent event) {\n    //******declare all necessary local varibles here ******//\n    String manu;\n    String brand;\n    String year;\n    String price;\n    Car newCar;\n    message.setForeground(Color.RED);\n    //******In case any of the four textfields are empty, but the button is pushed ******//\n    if (manuField.getText().equalsIgnoreCase(\"\")) {\n        message.setText(\"Please fill all fields\");\n    } else {\n        try {\n            //******handle the button event here ******//  \n            manu = manuField.getText();\n            brand = brandField.getText();\n            year = yearField.getText();\n            price = priceField.getText();\n            if (carList.size() == 0) {\n                newCar = new Car(manu, brand, Integer.parseInt(year), Double.parseDouble(price));\n                carList.add(newCar);\n                //udpate\n                //buyPanel.updateCarList(); \t                \n                //display.append(newCar.toString());\n                updateOutput();\n                message.setText(\"Car added\");\n            } else {\n                boolean cont = false;\n                for (Object o : carList) {\n                    Car c = (Car) o;\n                    if (c.getBrandName().equalsIgnoreCase(brand) && c.getManufacturer().equalsIgnoreCase(manu) && c.getYear() == Integer.parseInt(year)) {\n                        message.setText(\"Car not added - duplicate\");\n                        cont = true;\n                    }\n                }\n                if (!cont) {\n                    newCar = new Car(manu, brand, Integer.parseInt(year), Double.parseDouble(price));\n                    carList.add(newCar);\n                    //udpate\n                    //buyPanel.updateCarList();         \t                \n                    //display.append(newCar.toString());\n                    updateOutput();\n                    message.setText(\"Car added\");\n                }\n            }\n        } catch (NumberFormatException ex) {\n            message.setText(\"Please enter correct data format\");\n        }\n    }\n}\n","name":"actionPerformed","className":"ButtonListener","variables":{"yearField":1,"year":2,"manu":4,"manuField":2,"carList":4,"message":6,"Double":2,"newCar":3,"Integer":3,"ex":1,"brandField":1,"priceField":1,"price":2,"event":1,"cont":3,"brand":4},"javaDoc":"","comments":"declare all necessary local varibles here // In case any of the four textfields are empty but the button is pushed // handle the button event here // udpate buyPanel updateCarList(); display append(newCar toString()); udpate buyPanel updateCarList(); display append(newCar toString()); ","isEmpty":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"updateCarList":1,"toString":1,"append":1,"setText":1},"constants":{},"annotations":[],"types":{"StringBuilder":1,"Object":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","CastExpr","EnclosedExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"//end of ButtonListener class\nprivate void updateOutput() {\n    buyPanel.updateCarList();\n    final StringBuilder op = new StringBuilder();\n    for (Object o : carList) {\n        op.append(((Car) o).toString());\n    //carList.addElement(o);\n    }\n    display.setText(op.toString());\n}\n","name":"updateOutput","className":"CreatePanel","variables":{"op":3,"buyPanel":1,"display":1,"carList":1},"javaDoc":"","comments":"carList addElement(o); ","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"moveRectangleTo":1,"getY":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void mousePressed(MouseEvent event) {\n    int x = event.getX();\n    int y = event.getY();\n    scene.moveRectangleTo(x, y);\n}\n","name":"mousePressed","className":"MousePressListener","variables":{"event":3,"scene":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"// Do-nothing methods\npublic void mouseReleased(MouseEvent event) {\n}\n","name":"mouseReleased","className":"MousePressListener","variables":{"event":1},"javaDoc":"","comments":" Do-nothing methods","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void mouseClicked(MouseEvent event) {\n}\n","name":"mouseClicked","className":"MousePressListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void mouseEntered(MouseEvent event) {\n}\n","name":"mouseEntered","className":"MousePressListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void mouseExited(MouseEvent event) {\n}\n","name":"mouseExited","className":"MousePressListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"getKeyStrokeForEvent":1,"equals":4,"replace":1,"toString":1,"moveRectangleBy":4},"constants":{"\"\"":1,"\"UP\"":1,"\"DOWN\"":1,"\"pressed \"":1,"\"LEFT\"":1,"\"RIGHT\"":1},"annotations":[],"types":{"String":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void keyPressed(KeyEvent event) {\n    String key = KeyStroke.getKeyStrokeForEvent(event).toString().replace(\"pressed \", \"\");\n    if (key.equals(\"DOWN\")) {\n        scene.moveRectangleBy(0, 1);\n    } else if (key.equals(\"UP\")) {\n        scene.moveRectangleBy(0, -1);\n    } else if (key.equals(\"LEFT\")) {\n        scene.moveRectangleBy(-1, 0);\n    } else if (key.equals(\"RIGHT\")) {\n        scene.moveRectangleBy(1, 0);\n    }\n}\n","name":"keyPressed","className":"KeyStrokeListener","variables":{"KeyStroke":1,"event":1,"key":5,"scene":4},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void keyTyped(KeyEvent event) {\n}\n","name":"keyTyped","className":"KeyStrokeListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void keyReleased(KeyEvent event) {\n}\n","name":"keyReleased","className":"KeyStrokeListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame3","methodCalls":{"add":1,"setSize":1,"addKeyListener":1,"setFocusable":1,"addMouseListener":1},"constants":{"true":1},"annotations":[],"types":{"MouseListener":1,"MousePressListener":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public RectangleFrame3() {\n    scene = new RectangleComponent3();\n    add(scene);\n    MouseListener listener = new MousePressListener();\n    scene.addMouseListener(listener);\n    scene.addKeyListener(new KeyStrokeListener());\n    scene.setFocusable(true);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"RectangleFrame3","className":"RectangleFrame3","variables":{"listener":1,"scene":4},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"RectangleComponent3","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public RectangleComponent3() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent3","className":"RectangleComponent3","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"constants":{},"annotations":[],"types":{"Graphics2D":1},"expressions":["VariableDeclarationExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent3","variables":{"g2":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"setLocation":1,"repaint":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   */\npublic void moveRectangleTo(int x, int y) {\n    box.setLocation(x, y);\n    repaint();\n}\n","name":"moveRectangleTo","className":"RectangleComponent3","variables":{"box":1},"javaDoc":"Moves the rectangle to the given location x the x-position of the new location y the y-position of the new location","comments":"\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"repaint":1,"translate":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   */\npublic void moveRectangleBy(int dx, int dy) {\n    box.translate(dx, dy);\n    repaint();\n}\n","name":"moveRectangleBy","className":"RectangleComponent3","variables":{"dx":1,"dy":1,"box":1},"javaDoc":"Moves the rectangle by a given amount dx the amount to move in the x-direction dy the amount to move in the y-direction","comments":"\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"constants":{"true":1},"annotations":[],"types":{"JFrame":1,"RectangleFrame3":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame3();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer3","variables":{"args":1,"frame":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"compare":1},"constants":{},"annotations":[],"types":{"BankAccount":1},"expressions":["VariableDeclarationExpr","CastExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public int compareTo(Object otherObject) {\n    BankAccount other = (BankAccount) otherObject;\n    return Double.compare(balance, other.balance);\n}\n","name":"compareTo","className":"BankAccount","variables":{"other":1,"Double":1,"otherObject":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"]\"":1,"\"BankAccount[balance=\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"BankAccount[balance=\" + balance + \"]\";\n}\n","name":"toString","className":"BankAccount","variables":{"balance":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":2,"sort":2,"System.out.println":2},"constants":{"30510":1,"\"James\"":1,"10000":1,"2000":1,"\"Alonzo\"":1,"\"Mauchly\"":1,"1729":1,"\"Gosling\"":1,"42":1,"\"Church\"":1,"\"John\"":1},"annotations":[],"types":{"Comparable[]":2},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Comparable[] accounts = new Comparable[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    Arrays.sort(accounts);\n    System.out.println(Arrays.toString(accounts));\n    Comparable[] people = new Comparable[3];\n    people[0] = new Person(\"James\", \"Gosling\", 42);\n    people[2] = new Person(\"Alonzo\", \"Church\", 30510);\n    people[1] = new Person(\"John\", \"Mauchly\", 1729);\n    Arrays.sort(people);\n    System.out.println(Arrays.toString(people));\n}\n","name":"main","className":"ComparableDemo","variables":{"args":1,"accounts":4,"Arrays":4,"people":4},"javaDoc":"","isEmpty":false,"lineCount":12,"modifier":9}
{"paramTypes":["String","String","int"],"returnType":"Person","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Person(String first, String last, int id) {\n    this.first = first;\n    this.last = last;\n    this.id = id;\n}\n","name":"Person","className":"Person","variables":{"last":2,"id":2,"first":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\",last=\"":1,"\"]\"":1,"\",id=\"":1,"\"Person[first=\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"Person[first=\" + first + \",last=\" + last + \",id=\" + id + \"]\";\n}\n","name":"toString","className":"Person","variables":{"last":1,"id":1,"first":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"Person":1},"expressions":["VariableDeclarationExpr","BinaryExpr","CastExpr","NameExpr","FieldAccessExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public int compareTo(Object otherObject) {\n    Person other = (Person) otherObject;\n    return id - other.id;\n}\n","name":"compareTo","className":"Person","variables":{"other":1,"id":1,"otherObject":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Computes the measure of the object.\n      @return the measure\n   */\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"javaDoc":"Computes the measure of the object the measure","comments":"\n      Computes the measure of the object.\n      @return the measure\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Measurable","Measurable"],"returnType":"Measurable","methodCalls":{"getMeasure":2},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"public static Measurable larger(Measurable obj1, Measurable obj2) {\n    if (obj1.getMeasure() > obj2.getMeasure()) {\n        return obj1;\n    } else {\n        return obj2;\n    }\n}\n","name":"larger","className":"ConversionTester","variables":{"obj2":3,"obj1":3},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"larger":1,"getName":1,"System.out.println":2},"constants":{"\"Thailand\"":1,"513120":1,"\"Country with larger area: \"":1,"\"Expected: Thailand\"":1,"\"Uruguay\"":1,"176220":1},"annotations":[],"types":{"Measurable":1,"Country":3,"String":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","CastExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public static void main(String[] args) {\n    Country uruguay = new Country(\"Uruguay\", 176220);\n    Country thailand = new Country(\"Thailand\", 513120);\n    Measurable max = larger(uruguay, thailand);\n    Country maxCountry = (Country) max;\n    String name = maxCountry.getName();\n    System.out.println(\"Country with larger area: \" + name);\n    System.out.println(\"Expected: Thailand\");\n}\n","name":"main","className":"ConversionTester","variables":{"args":1,"maxCountry":2,"max":2,"thailand":1,"name":2,"uruguay":1},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":2,"name":1,"anArea":2},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getMeasure() {\n    return balance;\n}\n","name":"getMeasure","className":"BankAccount","variables":{"balance":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"// An abstract method\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"javaDoc":"","comments":" An abstract method","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Measurable[]"],"returnType":"// A static method\ndouble","methodCalls":{"getMeasure":1},"constants":{},"annotations":[],"types":{"Measurable":1,"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"static // A static method\ndouble average(// A static method\nMeasurable[] objects) {\n    double sum = 0;\n    for (Measurable obj : objects) {\n        sum = sum + obj.getMeasure();\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Measurable","variables":{"obj":2,"objects":2,"sum":4},"javaDoc":"","comments":"A static method A static method A static method ","isEmpty":false,"lineCount":3,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":2,"System.out.println":4},"constants":{"\"Average balance: \"":1,"\"Thailand\"":1,"30510":1,"\"Average area: \"":1,"513120":1,"\"Belgium\"":1,"\"Expected: 239950\"":1,"10000":1,"2000":1,"\"Uruguay\"":1,"176220":1,"\"Expected: 4000\"":1},"annotations":[],"types":{"double":2,"Measurable[]":2},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // Calling the static average method\n    // with an array of BankAccount objects\n    Measurable[] accounts = new Measurable[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    double averageBalance = Measurable.average(accounts);\n    System.out.println(\"Average balance: \" + averageBalance);\n    System.out.println(\"Expected: 4000\");\n    // Calling the static average method\n    // with an array of Country objects\n    Measurable[] countries = new Measurable[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    double averageArea = Measurable.average(countries);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 239950\");\n}\n","name":"main","className":"MeasurableTester","variables":{"args":1,"Measurable":2,"accounts":4,"countries":4,"averageBalance":2,"averageArea":2},"javaDoc":"","comments":"Calling the static average method with an array of BankAccount objects Calling the static average method with an array of Country objects ","isEmpty":false,"lineCount":18,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":2,"name":1,"anArea":2},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object[]","Measurer"],"returnType":"double","methodCalls":{"measure":1},"constants":{},"annotations":[],"types":{"double":1,"Object":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   */\npublic static double average(Object[] objects, Measurer meas) {\n    double sum = 0;\n    for (Object obj : objects) {\n        sum = sum + meas.measure(obj);\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":1,"objects":2,"meas":2,"sum":4},"javaDoc":"Computes the average of the measures of the given objects objects an array of objects meas the measurer for the objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   */\ndouble measure(Object anObject);\n","name":"measure","className":"Measurer","variables":{"anObject":1},"javaDoc":"Computes the measure of an object anObject the object to be measured the measure","comments":"\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{"getHeight":1,"getWidth":1},"constants":{},"annotations":[],"types":{"double":1,"Rectangle":1},"expressions":["VariableDeclarationExpr","BinaryExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public double measure(Object anObject) {\n    Rectangle aRectangle = (Rectangle) anObject;\n    double area = aRectangle.getWidth() * aRectangle.getHeight();\n    return area;\n}\n","name":"measure","className":"AreaMeasurer","variables":{"area":2,"aRectangle":3,"anObject":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"getHeight":1,"getWidth":1,"System.out.println":2},"constants":{"\"Average area: \"":1,"15":1,"\"Expected: 625\"":1,"40":1,"30":3,"20":3,"10":2},"annotations":[],"types":{"Measurer":1,"double":2,"Rectangle":1,"Rectangle[]":1,"AreaMeasurer":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","NameExpr","CastExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["TypeDeclarationStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting","InnerMethod","PolyMorphism","InnerClass"],"exceptions":[],"text":"public static void main(String[] args) {\n    class AreaMeasurer implements Measurer {\n\n        public double measure(Object anObject) {\n            Rectangle aRectangle = (Rectangle) anObject;\n            double area = aRectangle.getWidth() * aRectangle.getHeight();\n            return area;\n        }\n    }\n    Measurer areaMeas = new AreaMeasurer();\n    Rectangle[] rects = new Rectangle[] { new Rectangle(5, 10, 20, 30), new Rectangle(10, 20, 30, 40), new Rectangle(20, 30, 5, 15) };\n    double averageArea = Data.average(rects, areaMeas);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 625\");\n}\n","name":"main","className":"MeasurerTester","variables":{"args":1,"area":2,"measure":1,"aRectangle":3,"anObject":2,"AreaMeasurer":1,"areaMeas":1,"rects":1,"Data":1,"averageArea":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"I was clicked.\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    System.out.println(\"I was clicked.\");\n}\n","name":"actionPerformed","className":"ClickListener","variables":{"event":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"addActionListener":1,"setDefaultCloseOperation":1},"constants":{"true":1,"\"Click me!\"":1},"annotations":[],"types":{"ActionListener":1,"JFrame":1,"JButton":1,"ClickListener":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    JButton button = new JButton(\"Click me!\");\n    frame.add(button);\n    ActionListener listener = new ClickListener();\n    button.addActionListener(listener);\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ButtonViewer","variables":{"args":1,"button":2,"listener":1,"frame":5},"javaDoc":"","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"name":1,"System.out.println":2},"constants":{"\"Expected: Amy Smith\"":1,"\"Smith\"":1,"\"Amy\"":1,"\"Name: \"":1},"annotations":[],"types":{"Named":1,"User":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Named user = new User(\"Amy\", \"Smith\");\n    System.out.println(\"Name: \" + user.name());\n    // And not \"(NONE)\"\n    System.out.println(\"Expected: Amy Smith\");\n}\n","name":"main","className":"ConflictingDefaultMethodsTester","variables":{"args":1,"user":2},"javaDoc":"","comments":"And not \"(NONE)\" ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"(NONE)\"":1},"annotations":[],"types":{},"expressions":["StringLiteralExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"default String name() {\n    return \"(NONE)\";\n}\n","name":"name","className":"Named","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":0}
{"paramTypes":["String","String"],"returnType":"User","methodCalls":{"substring":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","EnclosedExpr","AssignExpr","MethodCallExpr"],"statements":["ExplicitConstructorInvocationStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public User(String first, String last) {\n    super(first, last);\n    username = (first.substring(0, 1) + last).toLowerCase();\n}\n","name":"User","className":"User","variables":{"last":3,"first":3,"username":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String","String"],"returnType":"Person","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Person(String firstName, String lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n","name":"Person","className":"Person","variables":{"firstName":2,"lastName":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"firstName":1,"lastName":1},"constants":{"\" \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String name() {\n    return firstName() + \" \" + lastName();\n}\n","name":"name","className":"Person","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String firstName() {\n    return firstName;\n}\n","name":"firstName","className":"Person","variables":{"firstName":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String lastName() {\n    return lastName;\n}\n","name":"lastName","className":"Person","variables":{"lastName":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"addActionListener":1,"setDefaultCloseOperation":1,"System.out.println":1},"constants":{"\"I was clicked.\"":1,"true":1,"\"Click me!\"":1},"annotations":[],"types":{"JFrame":1,"JButton":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","LambdaExpr","BooleanLiteralExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    JButton button = new JButton(\"Click me!\");\n    frame.add(button);\n    button.addActionListener((ActionEvent event) -> System.out.println(\"I was clicked.\"));\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ButtonViewer","variables":{"args":1,"button":2,"event":1,"frame":5},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"void addScore(int studentId, double score);\n","name":"addScore","className":"IGradeBook","variables":{"studentId":1,"score":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"double getAverageScore(int studentId);\n","name":"getAverageScore","className":"IGradeBook","variables":{"studentId":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"void save(String filename);\n","name":"save","className":"IGradeBook","variables":{"filename":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"void load(String filename);\n","name":"load","className":"IGradeBook","variables":{"filename":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"MockGradeBook","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public MockGradeBook() {\n    scores = new ArrayList<Double>();\n}\n","name":"MockGradeBook","className":"MockGradeBook","variables":{"scores":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{"add":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void addScore(int studentId, double score) {\n    // Ignore studentId\n    scores.add(score);\n}\n","name":"addScore","className":"MockGradeBook","variables":{"studentId":1,"score":1,"scores":1},"javaDoc":"","comments":"Ignore studentId ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{"size":1},"constants":{},"annotations":[],"types":{"double":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public double getAverageScore(int studentId) {\n    double total = 0;\n    for (double x : scores) {\n        total = total + x;\n    }\n    return total / scores.size();\n}\n","name":"getAverageScore","className":"MockGradeBook","variables":{"studentId":1,"total":4,"scores":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void save(String filename) {\n// Do nothing\n}\n","name":"save","className":"MockGradeBook","variables":{"filename":1},"javaDoc":"","comments":"Do nothing ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":4},"constants":{"1.0":1,"2.0":1,"7.0":1,"9.0":1},"annotations":[],"types":{},"expressions":["DoubleLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void load(String filename) {\n    // Add sample scores\n    scores.add(1.0);\n    scores.add(7.0);\n    scores.add(2.0);\n    scores.add(9.0);\n}\n","name":"load","className":"MockGradeBook","variables":{"filename":1,"scores":4},"javaDoc":"","comments":"Add sample scores ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":3,"load":1,"getAverageScore":1,"equals":5,"addScore":1,"toUpperCase":1,"save":1,"nextInt":2,"System.out.print":6,"nextDouble":1,"System.out.println":1},"constants":{"\"A\"":1,"false":1,"\": \"":1,"\"Filename: \"":2,"\"Score: \"":1,"\"V\"":1,"\"S\"":1,"\"Q\"":1,"\"Average for \"":1,"\"ID: \"":2,"\"L\"":1,"true":1,"\"L)oad A)dd aV)erage S)ave Q)uit: \"":1},"annotations":[],"types":{"Scanner":1,"boolean":1,"MockGradeBook":1,"IGradeBook":1,"double":1,"String":3,"int":2},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    IGradeBook gradeBook = new MockGradeBook();\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"L)oad A)dd aV)erage S)ave Q)uit: \");\n        String command = in.next().toUpperCase();\n        if (command.equals(\"L\")) {\n            System.out.print(\"Filename: \");\n            String filename = in.next();\n            gradeBook.load(filename);\n        } else if (command.equals(\"S\")) {\n            System.out.print(\"Filename: \");\n            String filename = in.next();\n            gradeBook.save(filename);\n        } else if (command.equals(\"A\")) {\n            System.out.print(\"ID: \");\n            int id = in.nextInt();\n            System.out.print(\"Score: \");\n            double score = in.nextDouble();\n            gradeBook.addScore(id, score);\n        } else if (command.equals(\"V\")) {\n            System.out.print(\"ID: \");\n            int id = in.nextInt();\n            System.out.println(\"Average for \" + id + \": \" + gradeBook.getAverageScore(id));\n        } else if (command.equals(\"Q\")) {\n            done = true;\n        }\n    }\n}\n","name":"main","className":"GradingProgram","variables":{"args":1,"score":1,"filename":2,"in":7,"id":3,"done":3,"gradeBook":5,"command":6},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getMeasure() {\n    return balance;\n}\n","name":"getMeasure","className":"BankAccount","variables":{"balance":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"// An abstract method\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"javaDoc":"","comments":" An abstract method","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Measurable"],"returnType":"boolean","methodCalls":{"getMeasure":2},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"default boolean smallerThan(Measurable other) {\n    return getMeasure() < other.getMeasure();\n}\n","name":"smallerThan","className":"Measurable","variables":{"other":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":4},"constants":{"\"Thailand\"":1,"30510":1,"513120":1,"\"Belgium\"":1,"\"Uruguay is smaller than Belgium: \"":1,"\"Uruguay is smaller than Thailand: \"":1,"\"Expected: true\"":1,"\"Uruguay\"":1,"176220":1,"\"Expected: false\"":1},"annotations":[],"types":{"Measurable[]":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Measurable[] countries = new Measurable[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    System.out.println(\"Uruguay is smaller than Thailand: \" + countries[0].smallerThan(countries[1]));\n    System.out.println(\"Expected: true\");\n    System.out.println(\"Uruguay is smaller than Belgium: \" + countries[0].smallerThan(countries[2]));\n    System.out.println(\"Expected: false\");\n}\n","name":"main","className":"MeasurableTester","variables":{"args":1,"countries":8},"javaDoc":"","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":2,"name":1,"anArea":2},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"name":1,"System.out.println":2},"constants":{"\"Smith\"":1,"\"Amy\"":1,"\"Name: \"":1,"\"Expected: asmith\"":1},"annotations":[],"types":{"Named":1,"User":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Named user = new User(\"Amy\", \"Smith\");\n    System.out.println(\"Name: \" + user.name());\n    System.out.println(\"Expected: asmith\");\n}\n","name":"main","className":"ConflictingDefaultMethodsTester","variables":{"args":1,"user":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"(NONE)\"":1},"annotations":[],"types":{},"expressions":["StringLiteralExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"default String name() {\n    return \"(NONE)\";\n}\n","name":"name","className":"Named","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":0}
{"paramTypes":["String","String"],"returnType":"User","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public User(String first, String last) {\n    this.first = first;\n    this.last = last;\n}\n","name":"User","className":"User","variables":{"last":2,"first":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"substring":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","EnclosedExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"// This method MUST be implemented to resolve the conflict.\npublic String name() {\n    // Here, we provide a different implementation.\n    return (first.substring(0, 1) + last).toLowerCase();\n// You could have also called one of the default methods:\n// return Person.super.name();\n}\n","name":"name","className":"User","variables":{"last":1,"first":1},"javaDoc":"","comments":"You could have also called one of the default methods: return Person super name(); Here we provide a different implementation  This method MUST be implemented to resolve the conflict.","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String firstName() {\n    return first;\n}\n","name":"firstName","className":"User","variables":{"first":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String lastName() {\n    return last;\n}\n","name":"lastName","className":"User","variables":{"last":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"firstName":1,"lastName":1},"constants":{"\" \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"default String name() {\n    return firstName() + \" \" + lastName();\n}\n","name":"name","className":"Person","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"String firstName();\n","name":"firstName","className":"Person","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"String lastName();\n","name":"lastName","className":"Person","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"BankAccount":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","CastExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public int compareTo(Object otherObject) {\n    BankAccount other = (BankAccount) otherObject;\n    if (balance < other.balance) {\n        return -1;\n    }\n    if (balance > other.balance) {\n        return 1;\n    }\n    return 0;\n}\n","name":"compareTo","className":"BankAccount","variables":{"other":1,"balance":2,"otherObject":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":1,"System.out.print":1,"System.out.println":2},"constants":{"\" \"":1,"10000":1,"2000":1,"\"Expected: 0.0 2000.0 10000.0\"":1},"annotations":[],"types":{"BankAccount[]":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    BankAccount[] accounts = new BankAccount[3];\n    accounts[0] = new BankAccount(10000);\n    accounts[1] = new BankAccount(0);\n    accounts[2] = new BankAccount(2000);\n    Arrays.sort(accounts);\n    for (int i = 0; i < accounts.length; i++) {\n        System.out.print(accounts[i].getBalance() + \" \");\n    }\n    System.out.println();\n    System.out.println(\"Expected: 0.0 2000.0 10000.0\");\n}\n","name":"main","className":"ComparableTester","variables":{"args":1,"accounts":5,"Arrays":1},"javaDoc":"","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"constants":{"true":1},"annotations":[],"types":{"JFrame":1,"RectangleFrame2":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame2();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer2","variables":{"args":1,"frame":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"RectangleComponent2","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public RectangleComponent2() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent2","className":"RectangleComponent2","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"constants":{},"annotations":[],"types":{"Graphics2D":1},"expressions":["VariableDeclarationExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent2","variables":{"g2":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"setLocation":1,"repaint":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   */\npublic void moveRectangleTo(int x, int y) {\n    box.setLocation(x, y);\n    repaint();\n}\n","name":"moveRectangleTo","className":"RectangleComponent2","variables":{"box":1},"javaDoc":"Moves the rectangle to the given location x the x-position of the new location y the y-position of the new location","comments":"\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"moveRectangleTo":1,"getY":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void mousePressed(MouseEvent event) {\n    int x = event.getX();\n    int y = event.getY();\n    scene.moveRectangleTo(x, y);\n}\n","name":"mousePressed","className":"MousePressListener","variables":{"event":3,"scene":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"// Do-nothing methods\npublic void mouseReleased(MouseEvent event) {\n}\n","name":"mouseReleased","className":"MousePressListener","variables":{"event":1},"javaDoc":"","comments":" Do-nothing methods","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void mouseClicked(MouseEvent event) {\n}\n","name":"mouseClicked","className":"MousePressListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void mouseEntered(MouseEvent event) {\n}\n","name":"mouseEntered","className":"MousePressListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void mouseExited(MouseEvent event) {\n}\n","name":"mouseExited","className":"MousePressListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame2","methodCalls":{"add":1,"setSize":1,"addMouseListener":1},"constants":{},"annotations":[],"types":{"MouseListener":1,"MousePressListener":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public RectangleFrame2() {\n    scene = new RectangleComponent2();\n    add(scene);\n    MouseListener listener = new MousePressListener();\n    scene.addMouseListener(listener);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"RectangleFrame2","className":"RectangleFrame2","variables":{"listener":1,"scene":2},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"random":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","CastExpr","NameExpr","FieldAccessExpr","EnclosedExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int next() {\n    return (int) (Integer.MAX_VALUE * Math.random());\n}\n","name":"next","className":"RandomSequence","variables":{"Math":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":2,"display":2,"System.out.println":1},"constants":{"1000":2},"annotations":[],"types":{"LastDigitDistribution":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    LastDigitDistribution dist1 = new LastDigitDistribution();\n    dist1.process(new SquareSequence(), 1000);\n    dist1.display();\n    System.out.println();\n    LastDigitDistribution dist2 = new LastDigitDistribution();\n    dist2.process(new RandomSequence(), 1000);\n    dist2.display();\n}\n","name":"main","className":"SequenceDemo","variables":{"args":1,"dist1":3,"dist2":3},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"int next();\n","name":"next","className":"Sequence","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","UnaryExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public int next() {\n    n++;\n    return n * n;\n}\n","name":"next","className":"SquareSequence","variables":{},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"LastDigitDistribution","methodCalls":{},"constants":{"10":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a distribution whose counters are set to zero.\n   */\npublic LastDigitDistribution() {\n    counters = new int[10];\n}\n","name":"LastDigitDistribution","className":"LastDigitDistribution","variables":{"counters":1},"javaDoc":"Constructs a distribution whose counters are set to zero","comments":"\n      Constructs a distribution whose counters are set to zero.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Sequence","int"],"returnType":"void","methodCalls":{"next":1},"constants":{"10":1},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Processes values from this sequence.\n      @param seq the sequence from which to obtain the values\n      @param valuesToProcess the number of values to process\n   */\npublic void process(Sequence seq, int valuesToProcess) {\n    for (int i = 1; i <= valuesToProcess; i++) {\n        int value = seq.next();\n        int lastDigit = value % 10;\n        counters[lastDigit]++;\n    }\n}\n","name":"process","className":"LastDigitDistribution","variables":{"counters":1,"lastDigit":2,"valuesToProcess":2,"value":2,"seq":2},"javaDoc":"Processes values from this sequence seq the sequence from which to obtain the values valuesToProcess the number of values to process","comments":"\n      Processes values from this sequence.\n      @param seq the sequence from which to obtain the values\n      @param valuesToProcess the number of values to process\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\": \"":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Displays the counter values of this distribution.\n   */\npublic void display() {\n    for (int i = 0; i < counters.length; i++) {\n        System.out.println(i + \": \" + counters[i]);\n    }\n}\n","name":"display","className":"LastDigitDistribution","variables":{"counters":1},"javaDoc":"Displays the counter values of this distribution","comments":"\n      Displays the counter values of this distribution.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getMeasure() {\n    return balance;\n}\n","name":"getMeasure","className":"BankAccount","variables":{"balance":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Measurable[]"],"returnType":"double","methodCalls":{"getMeasure":1},"constants":{},"annotations":[],"types":{"Measurable":1,"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of Measurable objects\n      @return the average of the measures\n   */\npublic static double average(Measurable[] objects) {\n    double sum = 0;\n    for (Measurable obj : objects) {\n        sum = sum + obj.getMeasure();\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":2,"objects":2,"sum":4},"javaDoc":"Computes the average of the measures of the given objects objects an array of Measurable objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of Measurable objects\n      @return the average of the measures\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Computes the measure of the object.\n      @return the measure\n   */\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"javaDoc":"Computes the measure of the object the measure","comments":"\n      Computes the measure of the object.\n      @return the measure\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":2,"System.out.println":4},"constants":{"\"Average balance: \"":1,"\"Thailand\"":1,"30510":1,"\"Average area: \"":1,"513120":1,"\"Belgium\"":1,"\"Expected: 239950\"":1,"10000":1,"2000":1,"\"Uruguay\"":1,"176220":1,"\"Expected: 4000\"":1},"annotations":[],"types":{"double":2,"Measurable[]":2},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // Calling the average method with an array of BankAccount objects\n    Measurable[] accounts = new Measurable[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    double averageBalance = Data.average(accounts);\n    System.out.println(\"Average balance: \" + averageBalance);\n    System.out.println(\"Expected: 4000\");\n    // Calling the average method with an array of Country objects\n    Measurable[] countries = new Measurable[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    double averageArea = Data.average(countries);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 239950\");\n}\n","name":"main","className":"MeasurableTester","variables":{"args":1,"Data":2,"accounts":4,"countries":4,"averageBalance":2,"averageArea":2},"javaDoc":"","comments":"Calling the average method with an array of BankAccount objects Calling the average method with an array of Country objects ","isEmpty":false,"lineCount":14,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":2,"name":1,"anArea":2},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"moveRectangleTo":1,"getY":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void mousePressed(MouseEvent event) {\n    int x = event.getX();\n    int y = event.getY();\n    scene.moveRectangleTo(x, y);\n}\n","name":"mousePressed","className":"MousePressListener","variables":{"event":3,"scene":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"// Do-nothing methods\npublic void mouseReleased(MouseEvent event) {\n}\n","name":"mouseReleased","className":"MousePressListener","variables":{"event":1},"javaDoc":"","comments":" Do-nothing methods","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void mouseClicked(MouseEvent event) {\n}\n","name":"mouseClicked","className":"MousePressListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void mouseEntered(MouseEvent event) {\n}\n","name":"mouseEntered","className":"MousePressListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void mouseExited(MouseEvent event) {\n}\n","name":"mouseExited","className":"MousePressListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"getKeyStrokeForEvent":1,"equals":4,"replace":1,"toString":1,"moveRectangleBy":4},"constants":{"\"\"":1,"\"UP\"":1,"\"DOWN\"":1,"\"pressed \"":1,"\"LEFT\"":1,"\"RIGHT\"":1},"annotations":[],"types":{"String":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void keyPressed(KeyEvent event) {\n    String key = KeyStroke.getKeyStrokeForEvent(event).toString().replace(\"pressed \", \"\");\n    if (key.equals(\"DOWN\")) {\n        scene.moveRectangleBy(0, 1);\n    } else if (key.equals(\"UP\")) {\n        scene.moveRectangleBy(0, -1);\n    } else if (key.equals(\"LEFT\")) {\n        scene.moveRectangleBy(-1, 0);\n    } else if (key.equals(\"RIGHT\")) {\n        scene.moveRectangleBy(1, 0);\n    }\n}\n","name":"keyPressed","className":"KeyStrokeListener","variables":{"KeyStroke":1,"event":1,"key":5,"scene":4},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void keyTyped(KeyEvent event) {\n}\n","name":"keyTyped","className":"KeyStrokeListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void keyReleased(KeyEvent event) {\n}\n","name":"keyReleased","className":"KeyStrokeListener","variables":{"event":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame3","methodCalls":{"add":1,"setSize":1,"addKeyListener":1,"setFocusable":1,"addMouseListener":1},"constants":{"true":1},"annotations":[],"types":{"MouseListener":1,"MousePressListener":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public RectangleFrame3() {\n    scene = new RectangleComponent3();\n    add(scene);\n    MouseListener listener = new MousePressListener();\n    scene.addMouseListener(listener);\n    scene.addKeyListener(new KeyStrokeListener());\n    scene.setFocusable(true);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"RectangleFrame3","className":"RectangleFrame3","variables":{"listener":1,"scene":4},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"RectangleComponent3","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public RectangleComponent3() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent3","className":"RectangleComponent3","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"constants":{},"annotations":[],"types":{"Graphics2D":1},"expressions":["VariableDeclarationExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent3","variables":{"g2":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"setLocation":1,"repaint":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   */\npublic void moveRectangleTo(int x, int y) {\n    box.setLocation(x, y);\n    repaint();\n}\n","name":"moveRectangleTo","className":"RectangleComponent3","variables":{"box":1},"javaDoc":"Moves the rectangle to the given location x the x-position of the new location y the y-position of the new location","comments":"\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"repaint":1,"translate":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   */\npublic void moveRectangleBy(int dx, int dy) {\n    box.translate(dx, dy);\n    repaint();\n}\n","name":"moveRectangleBy","className":"RectangleComponent3","variables":{"dx":1,"dy":1,"box":1},"javaDoc":"Moves the rectangle by a given amount dx the amount to move in the x-direction dy the amount to move in the y-direction","comments":"\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"constants":{"true":1},"annotations":[],"types":{"JFrame":1,"RectangleFrame3":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame3();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer3","variables":{"args":1,"frame":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getBalance":2,"deposit":1,"setText":1},"constants":{"100":1,"\"balance: \"":1},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    double interest = account.getBalance() * INTEREST_RATE / 100;\n    account.deposit(interest);\n    label.setText(\"balance: \" + account.getBalance());\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"interest":1,"INTEREST_RATE":1,"label":1,"event":1,"account":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"setVisible":1,"getBalance":3,"setSize":1,"addActionListener":1,"deposit":1,"setDefaultCloseOperation":1,"setText":1},"constants":{"100":1,"true":1,"\"Add Interest\"":1,"\"balance: \"":2},"annotations":[],"types":{"JPanel":1,"ActionListener":1,"JFrame":1,"double":1,"AddInterestListener":1,"JButton":1,"JLabel":1,"BankAccount":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TypeDeclarationStmt","BlockStmt","ExpressionStmt"],"concepts":["InnerMethod","FinalVariables","PolyMorphism","InnerClass"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    // The button to trigger the calculation\n    JButton button = new JButton(\"Add Interest\");\n    // The application adds interest to this bank account\n    final BankAccount account = new BankAccount(INITIAL_BALANCE);\n    // The label for displaying the results\n    final JLabel label = new JLabel(\"balance: \" + account.getBalance());\n    // The panel that holds the user interface components\n    JPanel panel = new JPanel();\n    panel.add(button);\n    panel.add(label);\n    frame.add(panel);\n    class AddInterestListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            double interest = account.getBalance() * INTEREST_RATE / 100;\n            account.deposit(interest);\n            label.setText(\"balance: \" + account.getBalance());\n        }\n    }\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer2","variables":{"AddInterestListener":1,"listener":1,"label":2,"args":1,"button":2,"actionPerformed":1,"interest":1,"INTEREST_RATE":1,"INITIAL_BALANCE":1,"panel":3,"event":1,"account":5,"frame":5},"javaDoc":"","comments":"The button to trigger the calculation The application adds interest to this bank account The label for displaying the results The panel that holds the user interface components ","isEmpty":false,"lineCount":14,"modifier":9}
{"paramTypes":["Object[]","Measurer"],"returnType":"double","methodCalls":{"measure":1},"constants":{},"annotations":[],"types":{"double":1,"Object":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   */\npublic static double average(Object[] objects, Measurer meas) {\n    double sum = 0;\n    for (Object obj : objects) {\n        sum = sum + meas.measure(obj);\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":1,"objects":2,"meas":2,"sum":4},"javaDoc":"Computes the average of the measures of the given objects objects an array of objects meas the measurer for the objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   */\ndouble measure(Object anObject);\n","name":"measure","className":"Measurer","variables":{"anObject":1},"javaDoc":"Computes the measure of an object anObject the object to be measured the measure","comments":"\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{"getHeight":1,"getWidth":1},"constants":{},"annotations":[],"types":{"double":1,"Rectangle":1},"expressions":["VariableDeclarationExpr","BinaryExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public double measure(Object anObject) {\n    Rectangle aRectangle = (Rectangle) anObject;\n    double area = aRectangle.getWidth() * aRectangle.getHeight();\n    return area;\n}\n","name":"measure","className":"AreaMeasurer","variables":{"area":2,"aRectangle":3,"anObject":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"System.out.println":2},"constants":{"\"Average area: \"":1,"15":1,"\"Expected: 625\"":1,"40":1,"30":3,"20":3,"10":2},"annotations":[],"types":{"Measurer":1,"double":1,"Rectangle[]":1,"AreaMeasurer":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Measurer areaMeas = new AreaMeasurer();\n    Rectangle[] rects = new Rectangle[] { new Rectangle(5, 10, 20, 30), new Rectangle(10, 20, 30, 40), new Rectangle(20, 30, 5, 15) };\n    double averageArea = Data.average(rects, areaMeas);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 625\");\n}\n","name":"main","className":"MeasurerTester","variables":{"args":1,"areaMeas":1,"rects":1,"Data":1,"averageArea":2},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object[]","Measurer"],"returnType":"double","methodCalls":{"measure":1},"constants":{},"annotations":[],"types":{"double":1,"Object":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   */\npublic static double average(Object[] objects, Measurer meas) {\n    double sum = 0;\n    for (Object obj : objects) {\n        sum = sum + meas.measure(obj);\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":1,"objects":2,"meas":2,"sum":4},"javaDoc":"Computes the average of the measures of the given objects objects an array of objects meas the measurer for the objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   */\ndouble measure(Object anObject);\n","name":"measure","className":"Measurer","variables":{"anObject":1},"javaDoc":"Computes the measure of an object anObject the object to be measured the measure","comments":"\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":2,"getHeight":1,"getWidth":1,"System.out.println":4},"constants":{"\"Average balance: \"":1,"\"Average area: \"":1,"15":1,"\"Expected: 625\"":1,"10000":1,"2000":1,"40":1,"30":3,"\"Expected: 4000\"":1,"20":3,"10":2},"annotations":[],"types":{"Measurer":1,"double":2,"Rectangle[]":1,"Rectangle":1,"BankAccount[]":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","LambdaExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr","ArrayInitializerExpr","CastExpr","FieldAccessExpr","EnclosedExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public static void main(String[] args) {\n    BankAccount[] accounts = new BankAccount[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    double averageBalance = Data.average(accounts, (Object obj) -> ((BankAccount) obj).getBalance());\n    System.out.println(\"Average balance: \" + averageBalance);\n    System.out.println(\"Expected: 4000\");\n    Rectangle[] rects = new Rectangle[] { new Rectangle(5, 10, 20, 30), new Rectangle(10, 20, 30, 40), new Rectangle(20, 30, 5, 15) };\n    Measurer areaMeas = (Object obj) -> {\n        Rectangle r = (Rectangle) obj;\n        return r.getWidth() * r.getHeight();\n    };\n    double averageArea = Data.average(rects, areaMeas);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 625\");\n}\n","name":"main","className":"MeasurerTester","variables":{"args":1,"obj":4,"Data":2,"rects":1,"areaMeas":1,"accounts":4,"averageBalance":2,"averageArea":2},"javaDoc":"","isEmpty":false,"lineCount":12,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"true":1,"\"An animated rectangle\"":1},"annotations":[],"types":{"RectangleFrame":1,"JFrame":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame();\n    frame.setTitle(\"An animated rectangle\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer","variables":{"args":1,"frame":4},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"RectangleComponent","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public RectangleComponent() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent","className":"RectangleComponent","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"constants":{},"annotations":[],"types":{"Graphics2D":1},"expressions":["VariableDeclarationExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent","variables":{"g2":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"repaint":1,"translate":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   */\npublic void moveRectangleBy(int dx, int dy) {\n    box.translate(dx, dy);\n    repaint();\n}\n","name":"moveRectangleBy","className":"RectangleComponent","variables":{"dx":1,"dy":1,"box":1},"javaDoc":"Moves the rectangle by a given amount dx the amount to move in the x-direction dy the amount to move in the y-direction","comments":"\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"moveRectangleBy":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    scene.moveRectangleBy(1, 1);\n}\n","name":"actionPerformed","className":"TimerListener","variables":{"event":1,"scene":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame","methodCalls":{"add":1,"setSize":1,"start":1},"constants":{"100":1},"annotations":[],"types":{"ActionListener":1,"Timer":1,"TimerListener":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables","PolyMorphism"],"exceptions":[],"text":"public RectangleFrame() {\n    scene = new RectangleComponent();\n    add(scene);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    ActionListener listener = new TimerListener();\n    // Milliseconds between timer ticks\n    final int DELAY = 100;\n    Timer t = new Timer(DELAY, listener);\n    t.start();\n}\n","name":"RectangleFrame","className":"RectangleFrame","variables":{"listener":2,"DELAY":2,"scene":1},"javaDoc":"","comments":"Milliseconds between timer ticks ","isEmpty":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getBalance":2,"deposit":1,"System.out.println":1},"constants":{"100":1,"\"balance: \"":1},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    // The listener method accesses the account variable\n    // from the surrounding block\n    double interest = account.getBalance() * INTEREST_RATE / 100;\n    account.deposit(interest);\n    System.out.println(\"balance: \" + account.getBalance());\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"interest":1,"INTEREST_RATE":1,"event":1,"account":3},"javaDoc":"","comments":"The listener method accesses the account variable from the surrounding block ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"getBalance":2,"setSize":1,"addActionListener":1,"deposit":1,"setDefaultCloseOperation":1,"System.out.println":1},"constants":{"100":1,"true":1,"\"Add Interest\"":1,"\"balance: \"":1},"annotations":[],"types":{"ActionListener":1,"JFrame":1,"double":1,"AddInterestListener":1,"JButton":1,"BankAccount":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TypeDeclarationStmt","BlockStmt","ExpressionStmt"],"concepts":["InnerMethod","FinalVariables","PolyMorphism","InnerClass"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    // The button to trigger the calculation\n    JButton button = new JButton(\"Add Interest\");\n    frame.add(button);\n    // The application adds interest to this bank account\n    final BankAccount account = new BankAccount(INITIAL_BALANCE);\n    class AddInterestListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            // The listener method accesses the account variable\n            // from the surrounding block\n            double interest = account.getBalance() * INTEREST_RATE / 100;\n            account.deposit(interest);\n            System.out.println(\"balance: \" + account.getBalance());\n        }\n    }\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer1","variables":{"args":1,"button":2,"actionPerformed":1,"interest":1,"AddInterestListener":1,"INTEREST_RATE":1,"listener":1,"INITIAL_BALANCE":1,"event":1,"account":4,"frame":5},"javaDoc":"","comments":"The button to trigger the calculation The application adds interest to this bank account The listener method accesses the account variable from the surrounding block ","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["String","String","String","int","double","boolean"],"returnType":"PartTime","methodCalls":{},"constants":{"0.2":1},"annotations":[],"types":{},"expressions":["DoubleLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","ThisExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExplicitConstructorInvocationStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public PartTime(String firstname, String lastname, String id, int credits, double rate, boolean campus) {\n    super(firstname, lastname, id, credits, rate);\n    this.campus = campus;\n    if (!campus) {\n        studentProgramFee = studentProgramFee * 0.2;\n    }\n}\n","name":"PartTime","className":"PartTime","variables":{"studentProgramFee":2,"firstname":2,"credits":2,"rate":2,"campus":3,"id":2,"lastname":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":["Override"],"types":{},"expressions":["BinaryExpr","NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"@Override\npublic void computeTuition() {\n    this.tuition = rate * this.creditNum + studentProgramFee;\n}\n","name":"computeTuition","className":"PartTime","variables":{"studentProgramFee":1,"rate":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"\"":1},"annotations":[],"types":{},"expressions":["StringLiteralExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"\";\n}\n","name":"toString","className":"PartTime","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n// implementationfilled in later\n}\n","name":"BankAccount","className":"BankAccount","variables":{},"javaDoc":"Constructs a bank account with a zero balance","comments":"implementationfilled in later \n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n// implementationfilled in later\n}\n","name":"BankAccount","className":"BankAccount","variables":{"initialBalance":1},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"implementationfilled in later \n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n// implementationfilled in later\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"implementationfilled in later \n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n// implementationfilled in later\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"implementationfilled in later \n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    // implementationfilled in later\n    return 0;\n}\n","name":"getBalance","className":"BankAccount","variables":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"implementationfilled in later \n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"CashRegister","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a cash register with no money in it.\n      @param rate the tax rate for taxable purchases\n   */\npublic CashRegister(double rate) {\n    taxRate = rate;\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"taxRate":1,"rate":2,"purchase":1,"payment":1},"javaDoc":"Constructs a cash register with no money in it rate the tax rate for taxable purchases","comments":"\n      Constructs a cash register with no money in it.\n      @param rate the tax rate for taxable purchases\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Records the sale of a tax-free item.\n      @param amount the price of the item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":2,"purchase":2},"javaDoc":"Records the sale of a tax-free item amount the price of the item","comments":"\n      Records the sale of a tax-free item.\n      @param amount the price of the item\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Records the sale of a taxable item.\n      @param amount the price of the item\n   */\npublic void recordTaxablePurchase(double amount) {\n    taxablePurchase = taxablePurchase + amount;\n}\n","name":"recordTaxablePurchase","className":"CashRegister","variables":{"amount":2,"taxablePurchase":2},"javaDoc":"Records the sale of a taxable item amount the price of the item","comments":"\n      Records the sale of a taxable item.\n      @param amount the price of the item\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   */\npublic void receivePayment(double amount) {\n    payment = payment + amount;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"amount":2,"payment":2},"javaDoc":"Processes a payment received from the customer amount the amount of the payment","comments":"\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{"100":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Processes the sales tax due.\n      @return the sales tax due\n   */\npublic double getSalesTax() {\n    return taxablePurchase * taxRate / 100;\n}\n","name":"getSalesTax","className":"CashRegister","variables":{"taxRate":1,"taxablePurchase":1},"javaDoc":"Processes the sales tax due the sales tax due","comments":"\n      Processes the sales tax due.\n      @return the sales tax due\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase - get;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"get":1,"purchase":2,"payment":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":2,"receivePayment":1,"giveChange":1,"System.out.println":2},"constants":{"9.25":1,"29.50":1,"50":1,"\"Expected: 11.25\"":1},"annotations":[],"types":{"CashRegister":1,"double":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(29.50);\n    register.recordPurchase(9.25);\n    register.receivePayment(50);\n    double change = register.giveChange();\n    System.out.println(change);\n    System.out.println(\"Expected: 11.25\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"args":1,"change":1,"register":5},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getValue":2,"click":3,"System.out.print":2,"resetTo":1,"System.out.println":2},"constants":{"\"result: \"":2,"10":1},"annotations":[],"types":{"Counter":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Counter tally = new Counter();\n    tally.click();\n    tally.click();\n    // Sets result to 2\n    int result = tally.getValue();\n    System.out.print(\"result: \");\n    System.out.println(result);\n    tally.resetTo(10);\n    tally.click();\n    // Sets result to 11\n    result = tally.getValue();\n    System.out.print(\"result: \");\n    System.out.println(result);\n}\n","name":"main","className":"CounterDemo","variables":{"args":1,"result":2,"tally":7},"javaDoc":"","comments":"Sets result to 2 Sets result to 11 ","isEmpty":false,"lineCount":11,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Advances the value of this counter by 1.\n   */\npublic void click() {\n    int updatedValue = value + 1;\n    // updatedValue is a local variable\n    value = updatedValue;\n// updatedValue is forgotten here\n}\n","name":"click","className":"Counter","variables":{"value":2,"updatedValue":2},"javaDoc":"Advances the value of this counter by 1","comments":"updatedValue is forgotten here updatedValue is a local variable \n      Advances the value of this counter by 1.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Resets the value of this counter to a given value.\n   */\npublic void resetTo(int newValue) // newValue is a parameter variable\n// newValue is initialized with the argument of a method call\n{\n    value = newValue;\n// newValue is forgotten here     \n}\n","name":"resetTo","className":"Counter","variables":{"newValue":2,"value":1},"javaDoc":"Resets the value of this counter to a given value","comments":"newValue is a parameter variable newValue is initialized with the argument of a method call newValue is forgotten here \n      Resets the value of this counter to a given value.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current value of this counter.\n      @return the current value\n   */\npublic int getValue() {\n    return value;\n}\n","name":"getValue","className":"Counter","variables":{"value":1},"javaDoc":"Gets the current value of this counter the current value","comments":"\n      Gets the current value of this counter.\n      @return the current value\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"constants":{"100":2,"90":1},"annotations":[],"types":{"ItalianFlag":1,"Graphics2D":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    ItalianFlag flag = new ItalianFlag(100, 100, 90);\n    flag.draw(g2);\n}\n","name":"paintComponent","className":"ItalianFlagComponent","variables":{"flag":2,"g2":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"ItalianFlag","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public ItalianFlag(int x, int y, int aWidth) {\n    xLeft = x;\n    yTop = y;\n    width = aWidth;\n}\n","name":"ItalianFlag","className":"ItalianFlag","variables":{"xLeft":1,"aWidth":2,"yTop":1,"width":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Graphics2D"],"returnType":"void","methodCalls":{"setColor":3,"draw":2,"fill":2},"constants":{},"annotations":[],"types":{"Line2D.Double":2,"Rectangle":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void draw(Graphics2D g2) {\n    Rectangle leftRectangle = new Rectangle(xLeft, yTop, width / 3, width * 2 / 3);\n    Rectangle rightRectangle = new Rectangle(xLeft + 2 * width / 3, yTop, width / 3, width * 2 / 3);\n    Line2D.Double topLine = new Line2D.Double(xLeft + width / 3, yTop, xLeft + width * 2 / 3, yTop);\n    Line2D.Double bottomLine = new Line2D.Double(xLeft + width / 3, yTop + width * 2 / 3, xLeft + width * 2 / 3, yTop + width * 2 / 3);\n    g2.setColor(Color.GREEN);\n    g2.fill(leftRectangle);\n    g2.setColor(Color.RED);\n    g2.fill(rightRectangle);\n    g2.setColor(Color.BLACK);\n    g2.draw(topLine);\n    g2.draw(bottomLine);\n}\n","name":"draw","className":"ItalianFlag","variables":{"xLeft":6,"rightRectangle":1,"topLine":1,"leftRectangle":1,"yTop":6,"width":11,"g2":8,"bottomLine":1},"javaDoc":"","isEmpty":false,"lineCount":11,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setDefaultCloseOperation":1},"constants":{"300":1,"400":1,"true":1},"annotations":[],"types":{"JFrame":1,"ItalianFlagComponent":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    ItalianFlagComponent component = new ItalianFlagComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"ItalianFlagViewer","variables":{"args":1,"component":1,"frame":5},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Records the sale of an item.\n      @param amount the price of the item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":2,"purchase":2},"javaDoc":"Records the sale of an item amount the price of the item","comments":"\n      Records the sale of an item.\n      @param amount the price of the item\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   */\npublic void receivePayment(double amount) {\n    payment = payment + amount;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"amount":2,"payment":2},"javaDoc":"Processes a payment received from the customer amount the amount of the payment","comments":"\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":2,"receivePayment":1,"giveChange":1,"System.out.println":2},"constants":{"9.25":1,"29.50":1,"50":1,"\"Expected: 11.25\"":1},"annotations":[],"types":{"CashRegister":1,"double":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(29.50);\n    register.recordPurchase(9.25);\n    register.receivePayment(50);\n    double change = register.giveChange();\n    System.out.println(change);\n    System.out.println(\"Expected: 11.25\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"args":1,"change":1,"register":5},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"Menu","methodCalls":{},"constants":{"\"\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a menu with no options.\n   */\npublic Menu() {\n    menuText = \"\";\n    optionCount = 0;\n}\n","name":"Menu","className":"Menu","variables":{"menuText":1,"optionCount":1},"javaDoc":"Constructs a menu with no options","comments":"\n      Constructs a menu with no options.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{"\") \"":1,"\"\\n\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an option to the end of this menu.\n      @param option the option to add\n   */\npublic void addOption(String option) {\n    optionCount = optionCount + 1;\n    menuText = menuText + optionCount + \") \" + option + \"\\n\";\n}\n","name":"addOption","className":"Menu","variables":{"option":2,"optionCount":3,"menuText":2},"javaDoc":"Adds an option to the end of this menu option the option to add","comments":"\n      Adds an option to the end of this menu.\n      @param option the option to add\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Displays the menu on the console.\n   */\npublic void display() {\n    System.out.println(menuText);\n}\n","name":"display","className":"Menu","variables":{},"javaDoc":"Displays the menu on the console","comments":"\n      Displays the menu on the console.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addOption":4,"display":1},"constants":{"\"Open new account\"":1,"\"Quit\"":1,"\"Help\"":1,"\"Log into existing account\"":1},"annotations":[],"types":{"Menu":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Menu mainMenu = new Menu();\n    mainMenu.addOption(\"Open new account\");\n    mainMenu.addOption(\"Log into existing account\");\n    mainMenu.addOption(\"Help\");\n    mainMenu.addOption(\"Quit\");\n    mainMenu.display();\n}\n","name":"main","className":"MenuDemo","variables":{"args":1,"mainMenu":6},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getValue":1,"click":2,"System.out.print":1,"System.out.println":1},"constants":{"\"result: \"":1},"annotations":[],"types":{"Counter":1,"int":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Counter tally = new Counter();\n    tally.click();\n    tally.click();\n    // Sets result to 2\n    int result = tally.getValue();\n    System.out.print(\"result: \");\n    System.out.println(result);\n}\n","name":"main","className":"CounterDemo","variables":{"args":1,"result":1,"tally":4},"javaDoc":"","comments":"Sets result to 2 ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current value of this counter.\n      @return the current value\n   */\npublic int getValue() {\n    return value;\n}\n","name":"getValue","className":"Counter","variables":{"value":1},"javaDoc":"Gets the current value of this counter the current value","comments":"\n      Gets the current value of this counter.\n      @return the current value\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Advances the value of this counter by 1.\n   */\npublic void click() {\n    value = value + 1;\n}\n","name":"click","className":"Counter","variables":{"value":2},"javaDoc":"Advances the value of this counter by 1","comments":"\n      Advances the value of this counter by 1.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Resets the value of this counter to 0.\n   */\npublic void reset() {\n    value = 0;\n}\n","name":"reset","className":"Counter","variables":{"value":1},"javaDoc":"Resets the value of this counter to 0","comments":"\n      Resets the value of this counter to 0.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Counter","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a counter with a given value\n   */\npublic Counter(int value) {\n    this.value = value;\n// this. resolves the conflict between an instance variable\n// and a local variable with the same name\n}\n","name":"Counter","className":"Counter","variables":{"value":2},"javaDoc":"Constructs a counter with a given value","comments":"this resolves the conflict between an instance variable and a local variable with the same name \n      Constructs a counter with a given value\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Counter","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"public Counter() {\n    this(0);\n// Invokes the Counter(int value) constructor with value = 0\n}\n","name":"Counter","className":"Counter","variables":{},"javaDoc":"","comments":"Invokes the Counter(int value) constructor with value = 0 ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Advances the value of this counter by 1.\n   */\npublic void click() {\n    this.value = this.value + 1;\n// Using this makes it clear that the instance variable is updated\n}\n","name":"click","className":"Counter","variables":{},"javaDoc":"Advances the value of this counter by 1","comments":"Using this makes it clear that the instance variable is updated \n      Advances the value of this counter by 1.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getValue":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the previous value of this counter.\n      @return the previous value\n   */\npublic int getPrevious() {\n    return getValue() - 1;\n// When you call a method without an object, it is invoked\n// on the this reference, i.e this.getValue().\n}\n","name":"getPrevious","className":"Counter","variables":{},"javaDoc":"Gets the previous value of this counter the previous value","comments":"When you call a method without an object it is invoked on the this reference i e this getValue() \n      Gets the previous value of this counter.\n      @return the previous value\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current value of this counter.\n      @return the current value\n   */\npublic int getValue() {\n    return value;\n// Or, if you prefer, return this.value;\n}\n","name":"getValue","className":"Counter","variables":{"value":1},"javaDoc":"Gets the current value of this counter the current value","comments":"Or if you prefer return this value; \n      Gets the current value of this counter.\n      @return the current value\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"300":1,"400":1,"true":1,"\"Two cars\"":1},"annotations":[],"types":{"CarComponent":1,"JFrame":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setTitle(\"Two cars\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    CarComponent component = new CarComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"CarViewer","variables":{"args":1,"component":1,"frame":6},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["int","int"],"returnType":"Car","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a car with a given top left corner.\n      @param x the x coordinate of the top left corner\n      @param y the y coordinate of the top left corner\n   */\npublic Car(int x, int y) {\n    xLeft = x;\n    yTop = y;\n}\n","name":"Car","className":"Car","variables":{"xLeft":1,"yTop":1},"javaDoc":"Constructs a car with a given top left corner x the x coordinate of the top left corner y the y coordinate of the top left corner","comments":"\n      Constructs a car with a given top left corner.\n      @param x the x coordinate of the top left corner\n      @param y the y coordinate of the top left corner\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Graphics2D"],"returnType":"void","methodCalls":{"draw":6},"constants":{"60":1,"50":1,"40":2,"20":3,"10":10},"annotations":[],"types":{"Line2D.Double":3,"Rectangle":1,"Ellipse2D.Double":2,"Point2D.Double":4},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Draws the car.\n      @param g2 the graphics context\n   */\npublic void draw(Graphics2D g2) {\n    Rectangle body = new Rectangle(xLeft, yTop + 10, 60, 10);\n    Ellipse2D.Double frontTire = new Ellipse2D.Double(xLeft + 10, yTop + 20, 10, 10);\n    Ellipse2D.Double rearTire = new Ellipse2D.Double(xLeft + 40, yTop + 20, 10, 10);\n    // The bottom of the front windshield\n    Point2D.Double r1 = new Point2D.Double(xLeft + 10, yTop + 10);\n    // The front of the roof\n    Point2D.Double r2 = new Point2D.Double(xLeft + 20, yTop);\n    // The rear of the roof\n    Point2D.Double r3 = new Point2D.Double(xLeft + 40, yTop);\n    // The bottom of the rear windshield\n    Point2D.Double r4 = new Point2D.Double(xLeft + 50, yTop + 10);\n    Line2D.Double frontWindshield = new Line2D.Double(r1, r2);\n    Line2D.Double roofTop = new Line2D.Double(r2, r3);\n    Line2D.Double rearWindshield = new Line2D.Double(r3, r4);\n    g2.draw(body);\n    g2.draw(frontTire);\n    g2.draw(rearTire);\n    g2.draw(frontWindshield);\n    g2.draw(roofTop);\n    g2.draw(rearWindshield);\n}\n","name":"draw","className":"Car","variables":{"xLeft":7,"r2":3,"r3":3,"r4":2,"rearTire":1,"yTop":7,"rearWindshield":1,"g2":7,"body":1,"frontTire":1,"frontWindshield":1,"roofTop":1,"r1":2},"javaDoc":"Draws the car g2 the graphics context","comments":"The bottom of the front windshield The front of the roof The rear of the roof The bottom of the rear windshield \n      Draws the car.\n      @param g2 the graphics context\n   ","isEmpty":false,"lineCount":16,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getHeight":1,"getWidth":1,"draw":2},"constants":{"60":1,"30":1},"annotations":[],"types":{"Car":2,"int":2,"Graphics2D":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","CastExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    Car car1 = new Car(0, 0);\n    int x = getWidth() - 60;\n    int y = getHeight() - 30;\n    Car car2 = new Car(x, y);\n    car1.draw(g2);\n    car2.draw(g2);\n}\n","name":"paintComponent","className":"CarComponent","variables":{"car2":2,"car1":2,"g2":1},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1,"withdraw":1,"System.out.println":2},"constants":{"500":1,"2000":1,"\"Expected: 1500\"":1},"annotations":[],"types":{"BankAccount":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tests the methods of the BankAccount class.\n      @param args not used\n   */\npublic static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount();\n    harrysChecking.deposit(2000);\n    harrysChecking.withdraw(500);\n    System.out.println(harrysChecking.getBalance());\n    System.out.println(\"Expected: 1500\");\n}\n","name":"main","className":"BankAccountTester","variables":{"args":1,"harrysChecking":4},"javaDoc":"Tests the methods of the BankAccount class args not used","comments":"\n      Tests the methods of the BankAccount class.\n      @param args not used\n   ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"isPalindrome":2,"System.out.println":4},"constants":{"\"Madam, I'm Adam!\"":1,"\"Palindrome: \"":2,"\"Sir, I'm Eve!\"":1},"annotations":[],"types":{"String":2},"expressions":["VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String sentence1 = \"Madam, I'm Adam!\";\n    System.out.println(sentence1);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence1));\n    String sentence2 = \"Sir, I'm Eve!\";\n    System.out.println(sentence2);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence2));\n}\n","name":"main","className":"Palindromes","variables":{"args":1,"sentence1":1,"sentence2":1},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"isPalindrome":1,"length":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   */\npublic static boolean isPalindrome(String text) {\n    return isPalindrome(text, 0, text.length() - 1);\n}\n","name":"isPalindrome","className":"Palindromes","variables":{"text":2},"javaDoc":"Tests whether a text is a palindrome text a string that is being checked true if text is a palindrome false otherwise","comments":"\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String","int","int"],"returnType":"boolean","methodCalls":{"isPalindrome":3,"toLowerCase":2,"charAt":2,"isLetter":3},"constants":{"true":1,"false":1},"annotations":[],"types":{"char":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Tests whether a substring is a palindrome.\n      @param text a string that is being checked\n      @param start the index of the first character of the substring\n      @param end the index of the last character of the substring\n      @return true if the substring is a palindrome\n   */\npublic static boolean isPalindrome(String text, int start, int end) {\n    // Separate case for substrings of length 0 and 1.\n    if (start >= end) {\n        return true;\n    } else {\n        // Get first and last characters, converted to lowercase.\n        char first = Character.toLowerCase(text.charAt(start));\n        char last = Character.toLowerCase(text.charAt(end));\n        if (Character.isLetter(first) && Character.isLetter(last)) {\n            if (first == last) {\n                // Test substring that doesnt contain the matching letters.\n                return isPalindrome(text, start + 1, end - 1);\n            } else {\n                return false;\n            }\n        } else if (!Character.isLetter(last)) {\n            // Test substring that doesnt contain the last character.\n            return isPalindrome(text, start, end - 1);\n        } else {\n            // Test substring that doesnt contain the first character.\n            return isPalindrome(text, start + 1, end);\n        }\n    }\n}\n","name":"isPalindrome","className":"Palindromes","variables":{"Character":5,"last":2,"start":4,"end":4,"text":3,"first":2},"javaDoc":"Tests whether a substring is a palindrome text a string that is being checked start the index of the first character of the substring end the index of the last character of the substring true if the substring is a palindrome","comments":"Separate case for substrings of length 0 and 1 Get first and last characters converted to lowercase Test substring that doesnt contain the matching letters Test substring that doesnt contain the last character Test substring that doesnt contain the first character \n      Tests whether a substring is a palindrome.\n      @param text a string that is being checked\n      @param start the index of the first character of the substring\n      @param end the index of the last character of the substring\n      @return true if the substring is a palindrome\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"Evaluator","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an evaluator.\n      @param anExpression a string containing the expression\n      to be evaluated\n   */\npublic Evaluator(String anExpression) {\n    tokenizer = new ExpressionTokenizer(anExpression);\n}\n","name":"Evaluator","className":"Evaluator","variables":{"anExpression":2,"tokenizer":1},"javaDoc":"Constructs an evaluator anExpression a string containing the expression to be evaluated","comments":"\n      Constructs an evaluator.\n      @param anExpression a string containing the expression\n      to be evaluated\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"nextToken":1,"peekToken":1,"getTermValue":2},"constants":{"\"-\"":1,"false":1,"true":1,"\"+\"":2},"annotations":[],"types":{"boolean":1,"String":1,"int":2},"expressions":["VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Evaluates the expression.\n      @return the value of the expression.\n   */\npublic int getExpressionValue() {\n    int value = getTermValue();\n    boolean done = false;\n    while (!done) {\n        String next = tokenizer.peekToken();\n        if (\"+\".equals(next) || \"-\".equals(next)) {\n            // Discard \"+\" or \"-\"\n            tokenizer.nextToken();\n            int value2 = getTermValue();\n            if (\"+\".equals(next)) {\n                value = value + value2;\n            } else {\n                value = value - value2;\n            }\n        } else {\n            done = true;\n        }\n    }\n    return value;\n}\n","name":"getExpressionValue","className":"Evaluator","variables":{"next":1,"value2":3,"value":6,"done":3,"tokenizer":2},"javaDoc":"Evaluates the expression the value of the expression","comments":"Discard \"+\" or \"-\" \n      Evaluates the expression.\n      @return the value of the expression.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getFactorValue":2,"nextToken":1,"peekToken":1},"constants":{"\"/\"":1,"false":1,"true":1,"\"*\"":2},"annotations":[],"types":{"boolean":1,"String":1,"int":2},"expressions":["VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Evaluates the next term found in the expression.\n      @return the value of the term\n   */\npublic int getTermValue() {\n    int value = getFactorValue();\n    boolean done = false;\n    while (!done) {\n        String next = tokenizer.peekToken();\n        if (\"*\".equals(next) || \"/\".equals(next)) {\n            tokenizer.nextToken();\n            int value2 = getFactorValue();\n            if (\"*\".equals(next)) {\n                value = value * value2;\n            } else {\n                value = value / value2;\n            }\n        } else {\n            done = true;\n        }\n    }\n    return value;\n}\n","name":"getTermValue","className":"Evaluator","variables":{"next":1,"value2":3,"value":6,"done":3,"tokenizer":2},"javaDoc":"Evaluates the next term found in the expression the value of the term","comments":"\n      Evaluates the next term found in the expression.\n      @return the value of the term\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"parseInt":1,"nextToken":3,"peekToken":1,"getExpressionValue":1},"constants":{"\"(\"":1},"annotations":[],"types":{"String":1,"int":1},"expressions":["VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Evaluates the next factor found in the expression.\n      @return the value of the factor\n   */\npublic int getFactorValue() {\n    int value;\n    String next = tokenizer.peekToken();\n    if (\"(\".equals(next)) {\n        // Discard \"(\"\n        tokenizer.nextToken();\n        value = getExpressionValue();\n        // Discard \")\"\n        tokenizer.nextToken();\n    } else {\n        value = Integer.parseInt(tokenizer.nextToken());\n    }\n    return value;\n}\n","name":"getFactorValue","className":"Evaluator","variables":{"next":1,"Integer":1,"value":4,"tokenizer":4},"javaDoc":"Evaluates the next factor found in the expression the value of the factor","comments":"Discard \"(\" Discard \")\" \n      Evaluates the next factor found in the expression.\n      @return the value of the factor\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String"],"returnType":"ExpressionTokenizer","methodCalls":{"nextToken":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a tokenizer.\n      @param anInput the string to tokenize\n   */\npublic ExpressionTokenizer(String anInput) {\n    input = anInput;\n    start = 0;\n    end = 0;\n    // Find the first token\n    nextToken();\n}\n","name":"ExpressionTokenizer","className":"ExpressionTokenizer","variables":{"input":1,"anInput":2,"start":1,"end":1},"javaDoc":"Constructs a tokenizer anInput the string to tokenize","comments":"Find the first token \n      Constructs a tokenizer.\n      @param anInput the string to tokenize\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"length":1,"substring":1},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Peeks at the next token without consuming it.\n      @return the next token or null if there are no more tokens\n   */\npublic String peekToken() {\n    if (start >= input.length()) {\n        return null;\n    } else {\n        return input.substring(start, end);\n    }\n}\n","name":"peekToken","className":"ExpressionTokenizer","variables":{"input":2,"start":1},"javaDoc":"Peeks at the next token without consuming it the next token or null if there are no more tokens","comments":"\n      Peeks at the next token without consuming it.\n      @return the next token or null if there are no more tokens\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"peekToken":1,"length":2,"isDigit":2,"charAt":2},"constants":{},"annotations":[],"types":{"String":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the next token and moves the tokenizer to the following token.\n      @return the next token or null if there are no more tokens\n   */\npublic String nextToken() {\n    String r = peekToken();\n    start = end;\n    if (start >= input.length()) {\n        return r;\n    }\n    if (Character.isDigit(input.charAt(start))) {\n        end = start + 1;\n        while (end < input.length() && Character.isDigit(input.charAt(end))) {\n            end++;\n        }\n    } else {\n        end = start + 1;\n    }\n    return r;\n}\n","name":"nextToken","className":"ExpressionTokenizer","variables":{"input":4,"Character":2,"start":4,"end":5},"javaDoc":"Gets the next token and moves the tokenizer to the following token the next token or null if there are no more tokens","comments":"\n      Gets the next token and moves the tokenizer to the following token.\n      @return the next token or null if there are no more tokens\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"getExpressionValue":1,"System.out.print":1,"System.out.println":1},"constants":{"\"Enter an expression: \"":1,"\"=\"":1},"annotations":[],"types":{"Scanner":1,"String":1,"Evaluator":1,"int":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter an expression: \");\n    String input = in.nextLine();\n    Evaluator e = new Evaluator(input);\n    int value = e.getExpressionValue();\n    System.out.println(input + \"=\" + value);\n}\n","name":"main","className":"ExpressionCalculator","variables":{"args":1,"input":3,"in":2,"value":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"solve":1},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    solve(new PartialSolution(0));\n}\n","name":"main","className":"EightQueens","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["PartialSolution"],"returnType":"void","methodCalls":{"extend":1,"examine":1,"solve":1,"System.out.println":1},"constants":{},"annotations":[],"types":{"PartialSolution":1,"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Prints all solutions to the problem that can be extended from \n      a given partial solution.\n      @param sol the partial solution\n   */\npublic static void solve(PartialSolution sol) {\n    int exam = sol.examine();\n    if (exam == PartialSolution.ACCEPT) {\n        System.out.println(sol);\n    } else if (exam == PartialSolution.CONTINUE) {\n        for (PartialSolution p : sol.extend()) {\n            solve(p);\n        }\n    }\n}\n","name":"solve","className":"EightQueens","variables":{"exam":3,"sol":3},"javaDoc":"Prints all solutions to the problem that can be extended from a given partial solution sol the partial solution","comments":"\n      Prints all solutions to the problem that can be extended from \n      a given partial solution.\n      @param sol the partial solution\n   ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["int"],"returnType":"PartialSolution","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a partial solution of a given size.\n      @param size the size\n   */\npublic PartialSolution(int size) {\n    queens = new Queen[size];\n}\n","name":"PartialSolution","className":"PartialSolution","variables":{"size":2,"queens":1},"javaDoc":"Constructs a partial solution of a given size size the size","comments":"\n      Constructs a partial solution of a given size.\n      @param size the size\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Examines a partial solution.\n      @return one of ACCEPT, ABANDON, CONTINUE\n   */\npublic int examine() {\n    for (int i = 0; i < queens.length; i++) {\n        for (int j = i + 1; j < queens.length; j++) {\n            if (queens[i].attacks(queens[j])) {\n                return ABANDON;\n            }\n        }\n    }\n    if (queens.length == NQUEENS) {\n        return ACCEPT;\n    } else {\n        return CONTINUE;\n    }\n}\n","name":"examine","className":"PartialSolution","variables":{"CONTINUE":1,"ACCEPT":1,"ABANDON":1,"queens":2,"NQUEENS":1},"javaDoc":"Examines a partial solution one of ACCEPT ABANDON CONTINUE","comments":"\n      Examines a partial solution.\n      @return one of ACCEPT, ABANDON, CONTINUE\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"PartialSolution[]","methodCalls":{},"constants":{},"annotations":[],"types":{"PartialSolution[]":1,"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Yields all extensions of this partial solution.\n      @return an array of partial solutions that extend this solution.\n   */\npublic PartialSolution[] extend() {\n    // Generate a new solution for each column\n    PartialSolution[] result = new PartialSolution[NQUEENS];\n    for (int i = 0; i < result.length; i++) {\n        int size = queens.length;\n        // The new solution has one more row than this one\n        result[i] = new PartialSolution(size + 1);\n        // Copy this solution into the new one\n        for (int j = 0; j < size; j++) {\n            result[i].queens[j] = queens[j];\n        }\n        // Append the new queen into the ith column\n        result[i].queens[size] = new Queen(size, i);\n    }\n    return result;\n}\n","name":"extend","className":"PartialSolution","variables":{"result":5,"size":5,"queens":1,"NQUEENS":1},"javaDoc":"Yields all extensions of this partial solution an array of partial solutions that extend this solution","comments":"Generate a new solution for each column The new solution has one more row than this one Copy this solution into the new one Append the new queen into the ith column \n      Yields all extensions of this partial solution.\n      @return an array of partial solutions that extend this solution.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return Arrays.toString(queens);\n}\n","name":"toString","className":"PartialSolution","variables":{"Arrays":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Queen","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a queen at a given position.\n      @param r the row \n      @param c the column\n   */\npublic Queen(int r, int c) {\n    row = r;\n    column = c;\n}\n","name":"Queen","className":"Queen","variables":{"column":1,"row":1},"javaDoc":"Constructs a queen at a given position r the row c the column","comments":"\n      Constructs a queen at a given position.\n      @param r the row \n      @param c the column\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Queen"],"returnType":"boolean","methodCalls":{"abs":2},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether this queen attacks another.\n      @param other the other queen\n      @return true if this and the other queen are in the same\n      row, column, or diagonal.\n   */\npublic boolean attacks(Queen other) {\n    return row == other.row || column == other.column || Math.abs(row - other.row) == Math.abs(column - other.column);\n}\n","name":"attacks","className":"Queen","variables":{"other":1,"column":2,"row":2,"Math":2},"javaDoc":"Checks whether this queen attacks another other the other queen true if this and the other queen are in the same row column or diagonal","comments":"\n      Checks whether this queen attacks another.\n      @param other the other queen\n      @return true if this and the other queen are in the same\n      row, column, or diagonal.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"\"":1,"\"abcdefgh\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","StringLiteralExpr","NameExpr","EnclosedExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"\" + \"abcdefgh\".charAt(column) + (row + 1);\n}\n","name":"toString","className":"Queen","variables":{"row":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"fib":1,"System.out.println":1},"constants":{"\") = \"":1,"\"fib(\"":1,"\"Enter n: \"":1},"annotations":[],"types":{"Scanner":1,"int":2,"long":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter n: \");\n    int n = in.nextInt();\n    for (int i = 1; i <= n; i++) {\n        long f = fib(i);\n        System.out.println(\"fib(\" + i + \") = \" + f);\n    }\n}\n","name":"main","className":"RecursiveFib","variables":{"args":1,"in":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int"],"returnType":"long","methodCalls":{"fib":2},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   */\npublic static long fib(int n) {\n    if (n <= 2) {\n        return 1;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n","name":"fib","className":"RecursiveFib","variables":{},"javaDoc":"Computes a Fibonacci number n an integer the nth Fibonacci number","comments":"\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"isPalindrome":2,"System.out.println":4},"constants":{"\"Madam, I'm Adam!\"":1,"\"Palindrome: \"":2,"\"Sir, I'm Eve!\"":1},"annotations":[],"types":{"String":2},"expressions":["VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String sentence1 = \"Madam, I'm Adam!\";\n    System.out.println(sentence1);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence1));\n    String sentence2 = \"Sir, I'm Eve!\";\n    System.out.println(sentence2);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence2));\n}\n","name":"main","className":"LoopPalindromes","variables":{"args":1,"sentence1":1,"sentence2":1},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"toLowerCase":2,"length":1,"charAt":2,"isLetter":4},"constants":{"false":1,"true":1},"annotations":[],"types":{"char":2,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   */\npublic static boolean isPalindrome(String text) {\n    int start = 0;\n    int end = text.length() - 1;\n    while (start < end) {\n        char first = Character.toLowerCase(text.charAt(start));\n        char last = Character.toLowerCase(text.charAt(end));\n        if (Character.isLetter(first) && Character.isLetter(last)) {\n            // Both are letters.\n            if (first == last) {\n                start++;\n                end--;\n            } else {\n                return false;\n            }\n        }\n        if (!Character.isLetter(last)) {\n            end--;\n        }\n        if (!Character.isLetter(first)) {\n            start++;\n        }\n    }\n    return true;\n}\n","name":"isPalindrome","className":"LoopPalindromes","variables":{"Character":6,"last":2,"start":4,"end":4,"text":4,"first":2},"javaDoc":"Tests whether a text is a palindrome text a string that is being checked true if text is a palindrome false otherwise","comments":"Both are letters \n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   ","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"fib":1,"System.out.println":1},"constants":{"\") = \"":1,"\"fib(\"":1,"\"Enter n: \"":1},"annotations":[],"types":{"Scanner":1,"int":2,"long":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter n: \");\n    int n = in.nextInt();\n    for (int i = 1; i <= n; i++) {\n        long f = fib(i);\n        System.out.println(\"fib(\" + i + \") = \" + f);\n    }\n}\n","name":"main","className":"LoopFib","variables":{"args":1,"in":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int"],"returnType":"long","methodCalls":{},"constants":{},"annotations":[],"types":{"long":3,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   */\npublic static long fib(int n) {\n    if (n <= 2) {\n        return 1;\n    } else {\n        long olderValue = 1;\n        long oldValue = 1;\n        long newValue = 1;\n        for (int i = 3; i <= n; i++) {\n            newValue = oldValue + olderValue;\n            olderValue = oldValue;\n            oldValue = newValue;\n        }\n        return newValue;\n    }\n}\n","name":"fib","className":"LoopFib","variables":{"newValue":4,"oldValue":4,"olderValue":3},"javaDoc":"Computes a Fibonacci number n an integer the nth Fibonacci number","comments":"\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"fib":1,"System.out.println":1},"constants":{"\") = \"":1,"\"fib(\"":1,"\"Enter n: \"":1},"annotations":[],"types":{"Scanner":1,"int":1,"long":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter n: \");\n    int n = in.nextInt();\n    long f = fib(n);\n    System.out.println(\"fib(\" + n + \") = \" + f);\n}\n","name":"main","className":"RecursiveFibTracer","variables":{"args":1,"in":2},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int"],"returnType":"long","methodCalls":{"fib":2,"System.out.println":2},"constants":{"\"Exiting fib: n = \"":1,"\" return value = \"":1,"\"Entering fib: n = \"":1},"annotations":[],"types":{"long":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   */\npublic static long fib(int n) {\n    System.out.println(\"Entering fib: n = \" + n);\n    long f;\n    if (n <= 2) {\n        f = 1;\n    } else {\n        f = fib(n - 1) + fib(n - 2);\n    }\n    System.out.println(\"Exiting fib: n = \" + n + \" return value = \" + f);\n    return f;\n}\n","name":"fib","className":"RecursiveFibTracer","variables":{},"javaDoc":"Computes a Fibonacci number n an integer the nth Fibonacci number","comments":"\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"isPalindrome":2,"System.out.println":4},"constants":{"\"Madam, I'm Adam!\"":1,"\"Palindrome: \"":2,"\"Sir, I'm Eve!\"":1},"annotations":[],"types":{"String":2},"expressions":["VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String sentence1 = \"Madam, I'm Adam!\";\n    System.out.println(sentence1);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence1));\n    String sentence2 = \"Sir, I'm Eve!\";\n    System.out.println(sentence2);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence2));\n}\n","name":"main","className":"Palindromes","variables":{"args":1,"sentence1":1,"sentence2":1},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"isPalindrome":3,"toLowerCase":2,"length":1,"charAt":2,"isLetter":3,"substring":3},"constants":{"true":1,"false":1},"annotations":[],"types":{"char":2,"String":3,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   */\npublic static boolean isPalindrome(String text) {\n    int length = text.length();\n    // Separate case for shortest strings. \n    if (length <= 1) {\n        return true;\n    } else {\n        // Get first and last characters, converted to lowercase. \n        char first = Character.toLowerCase(text.charAt(0));\n        char last = Character.toLowerCase(text.charAt(length - 1));\n        if (Character.isLetter(first) && Character.isLetter(last)) {\n            // Both are letters. \n            if (first == last) {\n                // Remove both first and last character. \n                String shorter = text.substring(1, length - 1);\n                return isPalindrome(shorter);\n            } else {\n                return false;\n            }\n        } else if (!Character.isLetter(last)) {\n            // Remove last character. \n            String shorter = text.substring(0, length - 1);\n            return isPalindrome(shorter);\n        } else {\n            // Remove first character. \n            String shorter = text.substring(1);\n            return isPalindrome(shorter);\n        }\n    }\n}\n","name":"isPalindrome","className":"Palindromes","variables":{"Character":5,"last":2,"length":5,"text":7,"first":2,"shorter":3},"javaDoc":"Tests whether a text is a palindrome text a string that is being checked true if text is a palindrome false otherwise","comments":"Separate case for shortest strings Get first and last characters converted to lowercase Both are letters Remove both first and last character Remove last character Remove first character \n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"find":1},"constants":{"\".java\"":1,"\"/home/myname\"":1},"annotations":[],"types":{"File":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    File startingDirectory = new File(\"/home/myname\");\n    find(startingDirectory, \".java\");\n}\n","name":"main","className":"FileFinder2","variables":{"args":1,"startingDirectory":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["File","String"],"returnType":"void","methodCalls":{"find":1,"endsWith":1,"toString":1,"listFiles":1,"isDirectory":1,"System.out.println":1},"constants":{},"annotations":[],"types":{"String":1,"File":1},"expressions":["VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Prints all files whose names end in a given extension.\n      @param aFile a file or directory\n      @param extension a file extension (such as \".java\")\n   */\npublic static void find(File aFile, String extension) {\n    if (aFile.isDirectory()) {\n        for (File child : aFile.listFiles()) {\n            find(child, extension);\n        }\n    } else {\n        String fileName = aFile.toString();\n        if (fileName.endsWith(extension)) {\n            System.out.println(fileName);\n        }\n    }\n}\n","name":"find","className":"FileFinder2","variables":{"extension":1,"fileName":2,"aFile":4,"child":1},"javaDoc":"Prints all files whose names end in a given extension aFile a file or directory extension a file extension (such as \" java\")","comments":"\n      Prints all files whose names end in a given extension.\n      @param aFile a file or directory\n      @param extension a file extension (such as \".java\")\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["File"],"returnType":"FileFinder","methodCalls":{"listFiles":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a file finder for a given directory tree.\n      @param startingDirectory the starting directory of the tree\n   */\npublic FileFinder(File startingDirectory) {\n    children = startingDirectory.listFiles();\n}\n","name":"FileFinder","className":"FileFinder","variables":{"startingDirectory":2,"children":1},"javaDoc":"Constructs a file finder for a given directory tree startingDirectory the starting directory of the tree","comments":"\n      Constructs a file finder for a given directory tree.\n      @param startingDirectory the starting directory of the tree\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"find":1,"endsWith":1,"toString":1,"isDirectory":1,"System.out.println":1},"constants":{},"annotations":[],"types":{"String":1,"FileFinder":1,"File":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Prints all files whose names end in a given extension.\n      @param extension a file extension (such as \".java\")\n   */\npublic void find(String extension) {\n    for (File child : children) {\n        String fileName = child.toString();\n        if (child.isDirectory()) {\n            FileFinder finder = new FileFinder(child);\n            finder.find(extension);\n        } else if (fileName.endsWith(extension)) {\n            System.out.println(fileName);\n        }\n    }\n}\n","name":"find","className":"FileFinder","variables":{"extension":1,"fileName":2,"children":1,"child":4,"finder":2},"javaDoc":"Prints all files whose names end in a given extension extension a file extension (such as \" java\")","comments":"\n      Prints all files whose names end in a given extension.\n      @param extension a file extension (such as \".java\")\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"find":1},"constants":{"\".java\"":1,"\"/home/myname\"":1},"annotations":[],"types":{"FileFinder":1,"File":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    File startingDirectory = new File(\"/home/myname\");\n    FileFinder finder = new FileFinder(startingDirectory);\n    finder.find(\".java\");\n}\n","name":"main","className":"FileFinderDemo","variables":{"args":1,"startingDirectory":2,"finder":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int"],"returnType":"Tower","methodCalls":{"add":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a tower holding a given number of disks of decreasing size.\n      @param ndisks the number of disks\n   */\npublic Tower(int ndisks) {\n    disks = new ArrayList<Integer>();\n    for (int d = ndisks; d >= 1; d--) {\n        disks.add(d);\n    }\n}\n","name":"Tower","className":"Tower","variables":{"disks":2,"ndisks":2},"javaDoc":"Constructs a tower holding a given number of disks of decreasing size ndisks the number of disks","comments":"\n      Constructs a tower holding a given number of disks of decreasing size.\n      @param ndisks the number of disks\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1,"remove":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes the top disk from this tower.\n      @return the size of the removed disk\n   */\npublic int remove() {\n    return disks.remove(disks.size() - 1);\n}\n","name":"remove","className":"Tower","variables":{"disks":2},"javaDoc":"Removes the top disk from this tower the size of the removed disk","comments":"\n      Removes the top disk from this tower.\n      @return the size of the removed disk\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"add":1,"size":2,"get":1},"constants":{"\"Disk is too large\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a disk to this tower.\n      @param size the size of the disk to add\n   */\npublic void add(int size) {\n    if (disks.size() > 0 && disks.get(disks.size() - 1) < size) {\n        throw new IllegalStateException(\"Disk is too large\");\n    }\n    disks.add(size);\n}\n","name":"add","className":"Tower","variables":{"size":2,"disks":4},"javaDoc":"Adds a disk to this tower size the size of the disk to add","comments":"\n      Adds a disk to this tower.\n      @param size the size of the disk to add\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return disks.toString();\n}\n","name":"toString","className":"Tower","variables":{"disks":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    move(5, 1, 3);\n}\n","name":"main","className":"TowersOfHanoiInstructions","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["int","int","int"],"returnType":"void","methodCalls":{"move":2,"System.out.println":1},"constants":{"\"Move disk from peg \"":1,"\" to \"":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Print instructions for moving a pile of disks from one peg to another.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   */\npublic static void move(int disks, int from, int to) {\n    if (disks > 0) {\n        int other = 6 - from - to;\n        move(disks - 1, from, other);\n        System.out.println(\"Move disk from peg \" + from + \" to \" + to);\n        move(disks - 1, other, to);\n    }\n}\n","name":"move","className":"TowersOfHanoiInstructions","variables":{"other":1,"disks":4,"from":3,"to":3},"javaDoc":"Print instructions for moving a pile of disks from one peg to another disks the number of disks to move from the peg from which to move the disks to the peg to which to move the disks","comments":"\n      Print instructions for moving a pile of disks from one peg to another.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1},"constants":{},"annotations":[],"types":{"TowersOfHanoi":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int NDISKS = 5;\n    TowersOfHanoi towers = new TowersOfHanoi(NDISKS);\n    towers.move(NDISKS, 0, 2);\n}\n","name":"main","className":"TowersOfHanoiDemo","variables":{"args":1,"NDISKS":2,"towers":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int"],"returnType":"TowersOfHanoi","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","ArrayAccessExpr","NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a puzzle in which the first tower has a given number of disks.\n      @param ndisks the number of disks\n   */\npublic TowersOfHanoi(int ndisks) {\n    towers = new Tower[3];\n    towers[0] = new Tower(ndisks);\n    towers[1] = new Tower(0);\n    towers[2] = new Tower(0);\n}\n","name":"TowersOfHanoi","className":"TowersOfHanoi","variables":{"ndisks":2,"towers":4},"javaDoc":"Constructs a puzzle in which the first tower has a given number of disks ndisks the number of disks","comments":"\n      Constructs a puzzle in which the first tower has a given number of disks.\n      @param ndisks the number of disks\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"void","methodCalls":{"move":2,"toString":1,"System.out.println":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Moves a pile of disks from one peg to another and displays the movement.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   */\npublic void move(int disks, int from, int to) {\n    if (disks > 0) {\n        int other = 3 - from - to;\n        move(disks - 1, from, other);\n        towers[to].add(towers[from].remove());\n        System.out.println(Arrays.toString(towers));\n        move(disks - 1, other, to);\n    }\n}\n","name":"move","className":"TowersOfHanoi","variables":{"other":1,"disks":4,"from":3,"to":3,"Arrays":1,"towers":2},"javaDoc":"Moves a pile of disks from one peg to another and displays the movement disks the number of disks to move from the peg from which to move the disks to the peg to which to move the disks","comments":"\n      Moves a pile of disks from one peg to another and displays the movement.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Triangle","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a triangular shape.\n      @param aWidth the width (and height) of the triangle\n   */\npublic Triangle(int aWidth) {\n    width = aWidth;\n}\n","name":"Triangle","className":"Triangle","variables":{"aWidth":2,"width":1},"javaDoc":"Constructs a triangular shape aWidth the width (and height) of the triangle","comments":"\n      Constructs a triangular shape.\n      @param aWidth the width (and height) of the triangle\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getArea":1},"constants":{},"annotations":[],"types":{"Triangle":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the area of the triangle.\n      @return the area\n   */\npublic int getArea() {\n    if (width <= 0) {\n        return 0;\n    } else if (width == 1) {\n        return 1;\n    } else {\n        Triangle smallerTriangle = new Triangle(width - 1);\n        int smallerArea = smallerTriangle.getArea();\n        return smallerArea + width;\n    }\n}\n","name":"getArea","className":"Triangle","variables":{"width":4,"smallerTriangle":2,"smallerArea":2},"javaDoc":"Computes the area of the triangle the area","comments":"\n      Computes the area of the triangle.\n      @return the area\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getArea":1,"System.out.println":2},"constants":{"\"Area: \"":1,"\"Expected: 55\"":1,"10":1},"annotations":[],"types":{"Triangle":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Triangle t = new Triangle(10);\n    int area = t.getArea();\n    System.out.println(\"Area: \" + area);\n    System.out.println(\"Expected: 55\");\n}\n","name":"main","className":"TriangleTester","variables":{"args":1,"area":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"permutations":1,"System.out.println":1},"constants":{"\"eat\"":1},"annotations":[],"types":{"String":1},"expressions":["VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    for (String s : permutations(\"eat\")) {\n        System.out.println(s);\n    }\n}\n","name":"main","className":"Permutations","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"ArrayList<String>","methodCalls":{"add":2,"length":2,"permutations":1,"substring":2,"charAt":1},"constants":{},"annotations":[],"types":{"ArrayList<String>":2,"String":2,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt","ForStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Gets all permutations of a given word.\n      @param word the string to permute\n      @return a list of all permutations\n   */\npublic static ArrayList<String> permutations(String word) {\n    ArrayList<String> result = new ArrayList<String>();\n    // The empty string has a single permutation: itself\n    if (word.length() == 0) {\n        result.add(word);\n        return result;\n    } else {\n        // Loop through all character positions\n        for (int i = 0; i < word.length(); i++) {\n            // Form a shorter word by removing the ith character\n            String shorter = word.substring(0, i) + word.substring(i + 1);\n            // Generate all permutations of the simpler word\n            ArrayList<String> shorterPermutations = permutations(shorter);\n            // each permutation of the simpler word, \n            for (String s : shorterPermutations) {\n                result.add(word.charAt(i) + s);\n            }\n        }\n        // Return all permutations\n        return result;\n    }\n}\n","name":"permutations","className":"Permutations","variables":{"result":5,"word":6,"shorterPermutations":2,"shorter":1},"javaDoc":"Gets all permutations of a given word word the string to permute a list of all permutations","comments":"The empty string has a single permutation: itself Loop through all character positions Add the removed character to the front of Form a shorter word by removing the ith character Generate all permutations of the simpler word each permutation of the simpler word Return all permutations \n      Gets all permutations of a given word.\n      @param word the string to permute\n      @return a list of all permutations\n   ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"countOdd":1,"countNegativeOne":1,"computeSumAtEvenIndexes":1,"nextInt":1,"findMin":1,"System.out.println":4},"constants":{"100":1,"\"The sum of numbers at even indexes is \"":1,"\"The total number of odd integers is \"":1,"\"The minimum number is \"":1,"\"The total number of -1 is \"":1},"annotations":[],"types":{"Scanner":1,"int":3},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ExpressionStmt","DoStmt"],"concepts":[],"exceptions":["IOException"],"text":"/******************************************************************************\n\t ***Complete the main() method. See above program description for details.\n\t ******************************************************************************/\npublic static void main(String[] args) throws IOException {\n    Scanner input = new Scanner(System.in);\n    int temp[] = new int[100];\n    int i = 0;\n    int number;\n    do {\n        number = input.nextInt();\n        temp[i] = number;\n        i++;\n    } while (number != 0);\n    System.out.println(\"The minimum number is \" + findMin(temp, 0, i));\n    System.out.println(\"The total number of odd integers is \" + countOdd(temp, 0, i));\n    System.out.println(\"The total number of -1 is \" + countNegativeOne(temp, i - 1));\n    System.out.println(\"The sum of numbers at even indexes is \" + computeSumAtEvenIndexes(temp, i - 1));\n}\n","name":"main","className":"Assignment9","variables":{"args":1,"input":2,"number":4,"temp":2},"javaDoc":"Complete the main() method See above program description for details","comments":"****************************************************************************\n\t ***Complete the main() method. See above program description for details.\n\t *****************************************************************************","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"int","methodCalls":{"findMin":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/*************************************************************************************\n\t ***(1)Complete the method. The method finds the minimum number in the partial array\n\t ***range from startIndex to endIndex\n\t *************************************************************************************/\npublic static int findMin(int[] numbers, int startIndex, int endIndex) {\n    if (startIndex == endIndex)\n        return numbers[startIndex];\n    else {\n        int previousMin = findMin(numbers, startIndex, endIndex - 1);\n        if (previousMin < numbers[endIndex]) {\n            return previousMin;\n        } else {\n            return numbers[endIndex];\n        }\n    }\n}\n","name":"findMin","className":"Assignment9","variables":{"previousMin":3,"startIndex":3,"endIndex":5,"numbers":4},"javaDoc":"(1)Complete the method The method finds the minimum number in the partial array range from startIndex to endIndex","comments":"***********************************************************************************\n\t ***(1)Complete the method. The method finds the minimum number in the partial array\n\t ***range from startIndex to endIndex\n\t ************************************************************************************","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"int","methodCalls":{"countOdd":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**************************************************************************************\n\t ***(2)Complete the method. The method counts the number of odd integers in the partial\n\t ***array range from startIndex to endIndex\n\t *************************************************************************************/\npublic static int countOdd(int[] numbers, int startIndex, int endIndex) {\n    int num = 0;\n    if (startIndex <= endIndex) {\n        num += countOdd(numbers, startIndex + 1, endIndex);\n        if (numbers[startIndex] % 2 != 0) {\n            num++;\n        }\n    }\n    return num;\n}\n","name":"countOdd","className":"Assignment9","variables":{"startIndex":4,"endIndex":2,"num":4,"numbers":2},"javaDoc":"(2)Complete the method The method counts the number of odd integers in the partial array range from startIndex to endIndex","comments":"************************************************************************************\n\t ***(2)Complete the method. The method counts the number of odd integers in the partial\n\t ***array range from startIndex to endIndex\n\t ************************************************************************************","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{"countNegativeOne":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/*************************************************************************************\n\t ***(3)Complete the method. The method counts the number of -1 inside an array with\n\t ***   \"count\" numbers, index ranges from 0 to count-1\n\t *************************************************************************************/\npublic static int countNegativeOne(int[] numbers, int count) {\n    int num = 0;\n    if (count >= 0) {\n        num += countNegativeOne(numbers, count - 1);\n        if (numbers[count] == -1)\n            num++;\n    }\n    return num;\n}\n","name":"countNegativeOne","className":"Assignment9","variables":{"num":4,"numbers":2,"count":4},"javaDoc":"(3)Complete the method The method counts the number of -1 inside an array with \"count\" numbers index ranges from 0 to count-1","comments":"***********************************************************************************\n\t ***(3)Complete the method. The method counts the number of -1 inside an array with\n\t ***   \"count\" numbers, index ranges from 0 to count-1\n\t ************************************************************************************","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{"computeSumAtEvenIndexes":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**************************************************************************************\n\t ***(4)Complete the method. The method computes the sum of numbers at index 0, 2, 4, ...\n\t ***  inside a partial array with \"count\" numbers inside, index ranges from 0 to count-1\n\t ***************************************************************************************/\npublic static int computeSumAtEvenIndexes(int[] numbers, int count) {\n    int num = 0;\n    //execute the recursion process if we are still in the array limits\n    if (count >= 0) {\n        //add 0 to num\n        num += computeSumAtEvenIndexes(numbers, count - 1);\n        //add array number to num if it's an even integer\n        if (count % 2 == 0) {\n            num += numbers[count];\n        }\n    }\n    return num;\n}\n","name":"computeSumAtEvenIndexes","className":"Assignment9","variables":{"num":4,"numbers":2,"count":5},"javaDoc":"(4)Complete the method The method computes the sum of numbers at index 0 2 4 inside a partial array with \"count\" numbers inside index ranges from 0 to count-1","comments":"execute the recursion process if we are still in the array limits add 0 to num add array number to num if it's an even integer ************************************************************************************\n\t ***(4)Complete the method. The method computes the sum of numbers at index 0, 2, 4, ...\n\t ***  inside a partial array with \"count\" numbers inside, index ranges from 0 to count-1\n\t **************************************************************************************","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"void move();\n","name":"move","className":"Living","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"void eat();\n","name":"eat","className":"Living","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"void sleep();\n","name":"sleep","className":"Living","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public abstract void eat();\n","name":"eat","className":"Animal","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1025}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"Animal moves\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void move() {\n    System.out.println(\"Animal moves\");\n}\n","name":"move","className":"Animal","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"Animal Sleeps\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void sleep() {\n    System.out.println(\"Animal Sleeps\");\n}\n","name":"sleep","className":"Animal","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"Mammals are some herbivores and some carnivores\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void eat() {\n    System.out.println(\"Mammals are some herbivores and some carnivores\");\n}\n","name":"eat","className":"Mammal","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void regulateTemperature() {\n}\n","name":"regulateTemperature","className":"Mammal","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public void think() {\n}\n","name":"think","className":"Human","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"Human who walks on two legs\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void move() {\n    System.out.println(\"Human who walks on two legs\");\n}\n","name":"move","className":"Human","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"eat":1,"System.out.println":2},"constants":{"\"Hello \"":1,"\" is an instance of Animal\"":1,"\"John\"":1},"annotations":[],"types":{"Mammal":1,"Living":1,"Object":1,"String":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","CastExpr","FieldAccessExpr","InstanceOfExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["Casting","PolyMorphism"],"exceptions":[],"text":"/* Polymorphism Examples\n     */\npublic static void main(String args[]) {\n    // Example of Polymorphism\n    Living m = new Mammal();\n    m.eat();\n    // Example of Casting\n    Object obj = \"John\";\n    String str = (String) obj;\n    System.out.println(\"Hello \" + str);\n    // Example of instanceOf\n    if (m instanceof Animal) {\n        System.out.println(m + \" is an instance of Animal\");\n    }\n}\n","name":"main","className":"Human","variables":{"args":1,"str":2,"obj":2},"javaDoc":"","comments":"Example of Polymorphism Example of Casting Example of instanceOf  Polymorphism Examples\n     ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["double","String"],"returnType":"Coin","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a coin.\n      @param aValue the monetary value of the coin\n      @param aName the name of the coin\n   */\npublic Coin(double aValue, String aName) {\n    value = aValue;\n    name = aName;\n}\n","name":"Coin","className":"Coin","variables":{"aName":2,"name":1,"value":1,"aValue":2},"javaDoc":"Constructs a coin aValue the monetary value of the coin aName the name of the coin","comments":"\n      Constructs a coin.\n      @param aValue the monetary value of the coin\n      @param aName the name of the coin\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the coin value.\n      @return the value\n   */\npublic double getValue() {\n    return value;\n}\n","name":"getValue","className":"Coin","variables":{"value":1},"javaDoc":"Gets the coin value the value","comments":"\n      Gets the coin value.\n      @return the value\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the coin name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Coin","variables":{"name":1},"javaDoc":"Gets the coin name the name","comments":"\n      Gets the coin name.\n      @return the name\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":2,"purchase":2},"javaDoc":"Records the purchase price of an item amount the price of the purchased item","comments":"\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","Coin"],"returnType":"void","methodCalls":{"getValue":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Enters the payment received from the customer.\n      @param coinCount the number of coins received\n      @param coinType the type of coin that was received\n   */\npublic void receivePayment(int coinCount, Coin coinType) {\n    payment = payment + coinCount * coinType.getValue();\n}\n","name":"receivePayment","className":"CashRegister","variables":{"coinType":2,"payment":2,"coinCount":2},"javaDoc":"Enters the payment received from the customer coinCount the number of coins received coinType the type of coin that was received","comments":"\n      Enters the payment received from the customer.\n      @param coinCount the number of coins received\n      @param coinType the type of coin that was received\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":2,"receivePayment":2,"giveChange":1,"System.out.println":2},"constants":{"1.0":1,"0.25":1,"\"Quarter\"":1,"\"Dollar\"":1,"\"Expected: 0.15\"":1,"1.95":1,"1.40":1},"annotations":[],"types":{"Coin":2,"CashRegister":1,"double":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final Coin DOLLAR = new Coin(1.0, \"Dollar\");\n    final Coin QUARTER = new Coin(0.25, \"Quarter\");\n    CashRegister register = new CashRegister();\n    register.recordPurchase(1.95);\n    register.recordPurchase(1.40);\n    register.receivePayment(3, DOLLAR);\n    register.receivePayment(2, QUARTER);\n    double change = register.giveChange();\n    System.out.println(change);\n    System.out.println(\"Expected: 0.15\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"args":1,"QUARTER":1,"change":1,"DOLLAR":1,"register":6},"javaDoc":"","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"constants":{"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"annotations":[],"types":{"Picture":1,"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","StringLiteralExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n}\n","name":"main","className":"Gallery1","variables":{"args":1,"PICTURES":1,"MAX_WIDTH":1,"GAP":1,"pic":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"getMaxX":1,"getBounds":1},"constants":{"\"picture2.jpg\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"annotations":[],"types":{"Picture":2,"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    Picture pic2 = new Picture(\"picture2.jpg\");\n    pic2.move(pic.getBounds().getMaxX(), 0);\n}\n","name":"main","className":"Gallery2","variables":{"args":1,"PICTURES":1,"MAX_WIDTH":1,"GAP":1,"pic":2,"pic2":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"getMaxX":1,"getBounds":1},"constants":{"\".jpg\"":1,"\"picture\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"annotations":[],"types":{"Picture":2,"double":1,"int":4},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    for (int i = 2; i <= PICTURES; i++) {\n        Picture previous = pic;\n        pic = new Picture(\"picture\" + i + \".jpg\");\n        double x = previous.getBounds().getMaxX() + GAP;\n        pic.move(x, 0);\n    }\n}\n","name":"main","className":"Gallery4","variables":{"args":1,"PICTURES":2,"previous":2,"MAX_WIDTH":1,"GAP":2,"pic":4},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"getMaxX":1,"getBounds":1},"constants":{"\"picture2.jpg\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"annotations":[],"types":{"Picture":2,"double":1,"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    Picture pic2 = new Picture(\"picture2.jpg\");\n    double x = pic.getBounds().getMaxX() + GAP;\n    pic2.move(x, 0);\n}\n","name":"main","className":"Gallery3","variables":{"args":1,"PICTURES":1,"MAX_WIDTH":1,"GAP":2,"pic":2,"pic2":2},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["String"],"returnType":"Picture","methodCalls":{"setIcon":2,"read":2,"printStackTrace":1,"getPreferredSize":1,"show":1,"getInstance":1,"setBounds":1,"startsWith":1,"setText":1},"constants":{"\"\"":1,"null":1,"\"http://\"":1},"annotations":[],"types":{"Dimension":1,"BufferedImage":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"/**\n      Constructs a picture from a given file or URL.\n      @param source the filename or URL\n   */\npublic Picture(String source) {\n    try {\n        this.source = source;\n        BufferedImage image;\n        if (source.startsWith(\"http://\")) {\n            image = ImageIO.read(new URL(source).openStream());\n        } else {\n            image = ImageIO.read(new File(source));\n        }\n        label.setIcon(new ImageIcon(image));\n        label.setText(\"\");\n        Dimension dim = label.getPreferredSize();\n        label.setBounds(0, 0, dim.width, dim.height);\n    } catch (Exception ex) {\n        label.setIcon(null);\n        ex.printStackTrace();\n    }\n    Canvas.getInstance().show(this);\n}\n","name":"Picture","className":"Picture","variables":{"image":4,"ex":2,"Canvas":1,"dim":1,"source":5,"label":5,"ImageIO":2},"javaDoc":"Constructs a picture from a given file or URL source the filename or URL","comments":"\n      Constructs a picture from a given file or URL.\n      @param source the filename or URL\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Rectangle","methodCalls":{"round":2,"getBounds":1,"translate":1},"constants":{},"annotations":[],"types":{"Rectangle":1},"expressions":["VariableDeclarationExpr","NameExpr","CastExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the bounds of this picture\n      @return the rectangle that contains the picture\n   */\npublic Rectangle getBounds() {\n    Rectangle r = label.getBounds();\n    r.translate((int) Math.round(x), (int) Math.round(y));\n    return r;\n}\n","name":"getBounds","className":"Picture","variables":{"label":1,"Math":2},"javaDoc":"Returns the bounds of this picture the rectangle that contains the picture","comments":"\n      Returns the bounds of this picture\n      @return the rectangle that contains the picture\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{"getInstance":1,"repaint":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Moves this picture by a given amount.\n      @param dx the amount by which to move in x-direction\n      @param dy the amount by which to move in y-direction\n   */\npublic void move(double dx, double dy) {\n    x += dx;\n    y += dy;\n    Canvas.getInstance().repaint();\n}\n","name":"move","className":"Picture","variables":{"dx":2,"dy":2,"Canvas":1},"javaDoc":"Moves this picture by a given amount dx the amount by which to move in x-direction dy the amount by which to move in y-direction","comments":"\n      Moves this picture by a given amount.\n      @param dx the amount by which to move in x-direction\n      @param dy the amount by which to move in y-direction\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getBounds":1},"constants":{"\"]\"":1,"\",bounds=\"":1,"\"Picture[source=\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"Picture[source=\" + source + \",bounds=\" + getBounds() + \"]\";\n}\n","name":"toString","className":"Picture","variables":{"source":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics2D"],"returnType":"void","methodCalls":{"paint":1,"translate":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void paintShape(Graphics2D g2) {\n    g2.translate(x, y);\n    label.paint(g2);\n}\n","name":"paintShape","className":"Picture","variables":{"g2":2,"label":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getHeight":1,"setColor":1,"create":1,"dispose":1,"getWidth":1,"fillRect":1,"paintShape":1},"constants":{},"annotations":[],"types":{"Picture":1,"Graphics2D":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","CastExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public void paintComponent(Graphics g) {\n    g.setColor(java.awt.Color.WHITE);\n    g.fillRect(0, 0, getWidth(), getHeight());\n    for (Picture s : pictures) {\n        Graphics2D g2 = (Graphics2D) g.create();\n        s.paintShape(g2);\n        g2.dispose();\n    }\n}\n","name":"paintComponent","className":"CanvasComponent","variables":{"g2":2,"pictures":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"getX":1,"getHeight":1,"getY":1,"max":2,"getWidth":1,"getBounds":1},"constants":{},"annotations":[],"types":{"Picture":1,"Rectangle":1,"int":2},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","CastExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Dimension getPreferredSize() {\n    int maxx = MIN_SIZE;\n    int maxy = MIN_SIZE;\n    for (Picture s : pictures) {\n        Rectangle r = s.getBounds();\n        maxx = (int) Math.max(maxx, r.getX() + r.getWidth());\n        maxy = (int) Math.max(maxy, r.getY() + r.getHeight());\n    }\n    return new Dimension(maxx, maxy);\n}\n","name":"getPreferredSize","className":"CanvasComponent","variables":{"MIN_SIZE":2,"maxy":3,"maxx":3,"Math":2,"pictures":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"getState":1,"printStackTrace":1,"saveToDisk":1},"constants":{"10":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":["Exception"],"text":"public void run() {\n    try {\n        final int DELAY = 10;\n        while (currentThread.getState() != Thread.State.TERMINATED) {\n            Thread.sleep(DELAY);\n        }\n        saveToDisk(SAVEFILE);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"run","className":"","variables":{"currentThread":1,"ex":2,"DELAY":1,"Thread":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Canvas","methodCalls":{"add":1,"setVisible":1,"currentThread":1,"getProperty":2,"printStackTrace":1,"start":1,"saveToDisk":1,"pack":1,"sleep":1,"contains":1,"getState":1,"setLocation":1,"setDefaultCloseOperation":1},"constants":{"\"com.horstmann.codecheck\"":1,"\"bluej\"":1,"null":1,"\"java.class.path\"":1,"true":1,"\"canvas.png\"":1,"10":1},"annotations":[],"types":{"String":1,"int":1,"Thread":2},"expressions":["NullLiteralExpr","ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","TryStmt","ExpressionStmt"],"concepts":["InnerMethod","FinalVariables"],"exceptions":["Exception"],"text":"private Canvas() {\n    if (System.getProperty(\"com.horstmann.codecheck\") == null) {\n        frame = new JFrame();\n        if (!System.getProperty(\"java.class.path\").contains(\"bluej\")) {\n            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        }\n        frame.add(component);\n        frame.pack();\n        frame.setLocation(LOCATION_OFFSET, LOCATION_OFFSET);\n        frame.setVisible(true);\n    } else {\n        final String SAVEFILE = \"canvas.png\";\n        final Thread currentThread = Thread.currentThread();\n        Thread watcherThread = new Thread() {\n\n            public void run() {\n                try {\n                    final int DELAY = 10;\n                    while (currentThread.getState() != Thread.State.TERMINATED) {\n                        Thread.sleep(DELAY);\n                    }\n                    saveToDisk(SAVEFILE);\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        };\n        watcherThread.start();\n    }\n}\n","name":"Canvas","className":"Canvas","variables":{"currentThread":2,"ex":2,"watcherThread":2,"run":1,"SAVEFILE":1,"DELAY":1,"System":2,"frame":6,"Thread":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":[],"returnType":"Canvas","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public static Canvas getInstance() {\n    return canvas;\n}\n","name":"getInstance","className":"Canvas","variables":{"canvas":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["Picture"],"returnType":"void","methodCalls":{"add":1,"contains":1,"repaint":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void show(Picture s) {\n    if (!pictures.contains(s)) {\n        pictures.add(s);\n    }\n    repaint();\n}\n","name":"show","className":"Canvas","variables":{"pictures":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getHeight":2,"getPreferredSize":1,"getWidth":2,"repaint":1,"pack":1},"constants":{"null":1},"annotations":[],"types":{"Dimension":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void repaint() {\n    if (frame == null) {\n        return;\n    }\n    Dimension dim = component.getPreferredSize();\n    if (dim.getWidth() > component.getWidth() || dim.getHeight() > component.getHeight()) {\n        frame.pack();\n    } else {\n        frame.repaint();\n    }\n}\n","name":"repaint","className":"Canvas","variables":{"component":3,"dim":3,"frame":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"lastIndexOf":1,"setColor":2,"getPreferredSize":1,"paintComponent":1,"javax.swing.JOptionPane.showMessageDialog":1,"getMessage":1,"dispose":1,"getGraphics":1,"fill":1,"System.err.println":1,"write":1,"substring":1},"constants":{"'.'":1,"\"Was unable to save the image to \"":1,"null":1},"annotations":[],"types":{"java.awt.Rectangle":1,"Dimension":1,"String":1,"BufferedImage":1,"Graphics2D":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","CastExpr","StringLiteralExpr","FieldAccessExpr","CharLiteralExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":["Throwable"],"text":"public void saveToDisk(String fileName) {\n    try {\n        Dimension dim = component.getPreferredSize();\n        java.awt.Rectangle rect = new java.awt.Rectangle(0, 0, dim.width, dim.height);\n        BufferedImage image = new BufferedImage(rect.width, rect.height, BufferedImage.TYPE_INT_RGB);\n        Graphics2D g = (Graphics2D) image.getGraphics();\n        g.setColor(java.awt.Color.WHITE);\n        g.fill(rect);\n        g.setColor(java.awt.Color.BLACK);\n        component.paintComponent(g);\n        String extension = fileName.substring(fileName.lastIndexOf('.') + 1);\n        ImageIO.write(image, extension, new File(fileName));\n        g.dispose();\n    } catch (Throwable e) {\n        javax.swing.JOptionPane.showMessageDialog(null, e.getMessage());\n        System.err.println(\"Was unable to save the image to \" + fileName);\n    }\n}\n","name":"saveToDisk","className":"Canvas","variables":{"rect":1,"image":2,"fileName":5,"component":2,"extension":1,"dim":1,"ImageIO":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":2,"getY":1,"max":1,"getMaxX":1,"getMaxY":1,"getWidth":1,"getBounds":4},"constants":{"\".jpg\"":1,"\"picture\"":1,"720":1,"\"picture1.jpg\"":1,"20":2,"10":1},"annotations":[],"types":{"Picture":2,"double":2,"int":4},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    double maxY = 0;\n    for (int i = 2; i <= 20; i++) {\n        maxY = Math.max(maxY, pic.getBounds().getMaxY());\n        Picture previous = pic;\n        pic = new Picture(\"picture\" + i + \".jpg\");\n        double x = previous.getBounds().getMaxX() + GAP;\n        if (x + pic.getBounds().getWidth() < MAX_WIDTH) {\n            pic.move(x, previous.getBounds().getY());\n        } else {\n            pic.move(0, maxY + GAP);\n        }\n    }\n}\n","name":"main","className":"Gallery6","variables":{"args":1,"PICTURES":1,"previous":3,"MAX_WIDTH":2,"maxY":3,"GAP":3,"pic":7,"Math":1},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":2,"getY":1,"max":1,"getMaxX":1,"getMaxY":1,"getWidth":1,"getBounds":4},"constants":{"\".jpg\"":1,"\"picture\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"annotations":[],"types":{"Picture":2,"double":2,"int":4},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    double maxY = 0;\n    for (int i = 2; i <= PICTURES; i++) {\n        maxY = Math.max(maxY, pic.getBounds().getMaxY());\n        Picture previous = pic;\n        pic = new Picture(\"picture\" + i + \".jpg\");\n        double x = previous.getBounds().getMaxX() + GAP;\n        if (x + pic.getBounds().getWidth() < MAX_WIDTH) {\n            pic.move(x, previous.getBounds().getY());\n        } else {\n            pic.move(0, maxY + GAP);\n            return;\n        }\n    }\n}\n","name":"main","className":"Gallery5","variables":{"args":1,"PICTURES":2,"previous":3,"MAX_WIDTH":2,"maxY":3,"GAP":3,"pic":7,"Math":1},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Transfers money from this account and tries to add it\n      @param amount the amount of money to transfer\n      @param otherBalance balance to add the amount to\n   */\nvoid transfer(double amount, double otherBalance) {\n    balance = balance - amount;\n    otherBalance = otherBalance + amount;\n// Wont update the argument\n}\n","name":"transfer","className":"BankAccount","variables":{"amount":3,"balance":2,"otherBalance":3},"javaDoc":"Transfers money from this account and tries to add it amount the amount of money to transfer otherBalance balance to add the amount to","comments":"Wont update the argument \n      Transfers money from this account and tries to add it\n      @param amount the amount of money to transfer\n      @param otherBalance balance to add the amount to\n   ","isEmpty":false,"lineCount":3,"modifier":0}
{"paramTypes":["double","BankAccount"],"returnType":"void","methodCalls":{"deposit":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Transfers money from this account to another.\n      @param amount the amount of money to transfer\n      @param otherAccount account to add the amount to\n   */\npublic void transfer(double amount, BankAccount otherAccount) {\n    balance = balance - amount;\n    otherAccount.deposit(amount);\n}\n","name":"transfer","className":"BankAccount","variables":{"amount":2,"otherAccount":2,"balance":2},"javaDoc":"Transfers money from this account to another amount the amount of money to transfer otherAccount account to add the amount to","comments":"\n      Transfers money from this account to another.\n      @param amount the amount of money to transfer\n      @param otherAccount account to add the amount to\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double","BankAccount"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void transfer2(double amount, BankAccount otherAccount) {\n    balance = balance - amount;\n    double newBalance = otherAccount.balance + amount;\n    // Wont work\n    otherAccount = new BankAccount(newBalance);\n}\n","name":"transfer2","className":"BankAccount","variables":{"amount":3,"otherAccount":2,"balance":2,"newBalance":2},"javaDoc":"","comments":"Wont work ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"transfer":2,"getBalance":4,"transfer2":1,"System.out.println":6},"constants":{"2500":1,"500":3,"\"After: \"":3,"1000":3,"\"Before: \"":3},"annotations":[],"types":{"double":1,"BankAccount":3},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount(2500);\n    double savingsBalance = 1000;\n    System.out.println(\"Before: \" + savingsBalance);\n    harrysChecking.transfer(500, savingsBalance);\n    System.out.println(\"After: \" + savingsBalance);\n    BankAccount harrysSavings = new BankAccount(1000);\n    System.out.println(\"Before: \" + harrysSavings.getBalance());\n    harrysChecking.transfer(500, harrysSavings);\n    System.out.println(\"After: \" + harrysSavings.getBalance());\n    BankAccount savingsAccount = new BankAccount(1000);\n    System.out.println(\"Before: \" + savingsAccount.getBalance());\n    harrysChecking.transfer2(500, savingsAccount);\n    System.out.println(\"After: \" + savingsAccount.getBalance());\n}\n","name":"main","className":"CallByValueDemo","variables":{"args":1,"harrysChecking":4,"savingsBalance":3,"savingsAccount":3,"harrysSavings":3},"javaDoc":"","isEmpty":false,"lineCount":13,"modifier":9}
{"paramTypes":["double","double"],"returnType":"double","methodCalls":{},"constants":{"100":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","EnclosedExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   */\npublic static double percentOf(double percentage, double amount) {\n    return (percentage / 100) * amount;\n}\n","name":"percentOf","className":"Financial","variables":{"amount":2,"percentage":2},"javaDoc":"Computes a percentage of an amount percentage the percentage to apply amount the amount to which the percentage is applied the requested percentage of the amount","comments":"\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["double","double"],"returnType":"double","methodCalls":{},"constants":{"100":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","EnclosedExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a percentage to an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the sum of the amount and the requested percentage\n   */\npublic static double addPercentTo(double percentage, double amount) {\n    return (1 + percentage / 100) * amount;\n}\n","name":"addPercentTo","className":"Financial","variables":{"amount":2,"percentage":2},"javaDoc":"Adds a percentage to an amount percentage the percentage to apply amount the amount to which the percentage is applied the sum of the amount and the requested percentage","comments":"\n      Adds a percentage to an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the sum of the amount and the requested percentage\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":1,"percentOf":1},"constants":{"8.25":1,"\"Tax: %.2f\\n\"":1,"9.95":1},"annotations":[],"types":{"double":3},"expressions":["VariableDeclarationExpr","DoubleLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    double price = 9.95;\n    double taxRate = 8.25;\n    double tax = Financial.percentOf(price, taxRate);\n    System.out.printf(\"Tax: %.2f\\n\", tax);\n}\n","name":"main","className":"PackageDemo","variables":{"args":1,"taxRate":1,"price":1,"Financial":1,"tax":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"Yum!\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void eat() {\n    System.out.println(\"Yum!\");\n    hungry = NOT_HUNGRY;\n}\n","name":"eat","className":"Fish","variables":{"hungry":1,"NOT_HUNGRY":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"constants":{"\"Looking for love\"":1,"\"Looking for food\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void move() {\n    if (hungry == VERY_HUNGRY) {\n        System.out.println(\"Looking for food\");\n    } else {\n        System.out.println(\"Looking for love\");\n        hungry++;\n    }\n}\n","name":"move","className":"Fish","variables":{"hungry":2,"VERY_HUNGRY":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Student(int anId) {\n    id = anId;\n}\n","name":"Student","className":"Student","variables":{"anId":2,"id":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getId() {\n    return id;\n}\n","name":"getId","className":"Student","variables":{"id":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"// No setId method\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Student","variables":{"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"length":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setName(String newName) {\n    if (newName.length() > 0) {\n        name = newName;\n    }\n}\n","name":"setName","className":"Student","variables":{"newName":3,"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":4},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public void moveOneUnit() {\n    final int NORTH = 0;\n    final int EAST = 1;\n    final int SOUTH = 2;\n    final int WEST = 3;\n    if (direction == NORTH) {\n        row--;\n    } else if (direction == EAST) {\n        column++;\n    } else if (direction == SOUTH) {\n        row++;\n    } else if (direction == WEST) {\n        column--;\n    }\n}\n","name":"moveOneUnit","className":"Bug","variables":{"NORTH":2,"WEST":2,"column":2,"SOUTH":2,"row":2,"EAST":2,"direction":4},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void turnRight() {\n    int DIRECTIONS = 4;\n    direction++;\n    if (direction == DIRECTIONS) {\n        direction = 0;\n    }\n}\n","name":"turnRight","className":"Bug","variables":{"DIRECTIONS":2,"direction":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getRow() {\n    return row;\n}\n","name":"getRow","className":"Bug","variables":{"row":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getColumn() {\n    return column;\n}\n","name":"getColumn","className":"Bug","variables":{"column":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void move(double distanceMoved) {\n    distanceFromTerminus = distanceFromTerminus + distanceMoved;\n}\n","name":"move","className":"Train","variables":{"distanceFromTerminus":2,"distanceMoved":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getPosition() {\n    return distanceFromTerminus;\n}\n","name":"getPosition","className":"Train","variables":{"distanceFromTerminus":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"recordPurchase":2,"assertEquals":1,"receivePayment":1,"giveChange":1},"constants":{"0.25":1,"0.75":1,"1.50":1},"annotations":["Test"],"types":{"CashRegister":1,"double":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"@Test\npublic void twoPurchases() {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(0.75);\n    register.recordPurchase(1.50);\n    register.receivePayment(2, 0, 5, 0, 0);\n    double expected = 0.25;\n    Assert.assertEquals(expected, register.giveChange(), EPSILON);\n}\n","name":"twoPurchases","className":"CashRegisterTest","variables":{"Assert":1,"expected":1,"register":5},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"recordPurchase":2,"assertEquals":1,"receivePayment":1,"giveChange":1},"constants":{"19.25":1,"2.25":1,"21":1},"annotations":["Test"],"types":{"CashRegister":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"@Test\npublic void testZeroBalance() {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(2.25);\n    register.recordPurchase(19.25);\n    register.receivePayment(21, 2, 0, 0, 0);\n    Assert.assertEquals(0, register.giveChange(), EPSILON);\n}\n","name":"testZeroBalance","className":"CashRegisterTest","variables":{"Assert":1,"register":5},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":2,"purchase":2},"javaDoc":"Records the purchase price of an item amount the price of the purchased item","comments":"\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Enters the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   */\npublic void receivePayment(int dollars, int quarters, int dimes, int nickels, int pennies) {\n    payment = dollars + quarters * QUARTER_VALUE + dimes * DIME_VALUE + nickels * NICKEL_VALUE + pennies * PENNY_VALUE;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"NICKEL_VALUE":1,"dimes":2,"nickels":2,"quarters":2,"pennies":2,"dollars":2,"payment":1,"QUARTER_VALUE":1,"DIME_VALUE":1,"PENNY_VALUE":1},"javaDoc":"Enters the payment received from the customer dollars the number of dollars in the payment quarters the number of quarters in the payment dimes the number of dimes in the payment nickels the number of nickels in the payment pennies the number of pennies in the payment","comments":"\n      Enters the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    lastAssignedNumber++;\n    accountNumber = lastAssignedNumber;\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"lastAssignedNumber":2,"balance":1,"accountNumber":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into this account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into this account amount the amount to deposit","comments":"\n      Deposits money into this account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   */\npublic void withdraw(double amount) {\n    if (amount > balance) {\n        balance = balance - OVERDRAFT_FEE;\n    } else {\n        balance = balance - amount;\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":3,"balance":5,"OVERDRAFT_FEE":1},"javaDoc":"Makes a withdrawal from this account or charges a penalty if sufficient funds are not available amount the amount of the withdrawal","comments":"\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"percentOf":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds interest to this account.\n      @param rate the interest rate in percent\n   */\npublic void addInterest(double rate) {\n    balance = balance + Financial.percentOf(rate, balance);\n}\n","name":"addInterest","className":"BankAccount","variables":{"balance":2,"rate":1,"Financial":1},"javaDoc":"Adds interest to this account rate the interest rate in percent","comments":"\n      Adds interest to this account.\n      @param rate the interest rate in percent\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of this account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of this account the current balance","comments":"\n      Gets the current balance of this account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double","double"],"returnType":"double","methodCalls":{},"constants":{"100":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","EnclosedExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   */\npublic static double percentOf(double percentage, double amount) {\n    return (percentage / 100) * amount;\n}\n","name":"percentOf","className":"Financial","variables":{"amount":2,"percentage":2},"javaDoc":"Computes a percentage of an amount percentage the percentage to apply amount the amount to which the percentage is applied the requested percentage of the amount","comments":"\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String","int","double"],"returnType":"Product","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Product(String productId, int quantity, double unitPrice) {\n    this.productId = productId;\n    this.quantity = quantity;\n    this.unitPrice = unitPrice;\n}\n","name":"Product","className":"Product","variables":{"unitPrice":2,"quantity":2,"productId":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getProductId() {\n    return productId;\n}\n","name":"getProductId","className":"Product","variables":{"productId":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"public abstract void computeTotalCost();\n","name":"computeTotalCost","className":"Product","variables":{},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":1025}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":2,"getPercentInstance":2},"constants":{"\"Product ID:\\t\\t\"":1,"\"Total Cost:\\t\\t\"":1,"\"\\n\"":4,"\"Quantity:\\t\\t\"":1,"\"Unit Price:\\t\\t\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"Product ID:\\t\\t\" + productId + \"\\n\" + \"Quantity:\\t\\t\" + quantity + \"\\n\" + \"Unit Price:\\t\\t\" + NumberFormat.getPercentInstance().format(unitPrice) + \"\\n\" + \"Total Cost:\\t\\t\" + NumberFormat.getPercentInstance().format(totalCost) + \"\\n\";\n}\n","name":"toString","className":"Product","variables":{"quantity":1,"productId":1,"NumberFormat":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.println":3},"constants":{"\"Error: Don't divide a number by zero\"":1,"\"I'm out of try-catch block in Java.\"":1,"\"Try block message\"":1,"62":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["ArithmeticException"],"text":"public static void main(String args[]) {\n    int num1, num2;\n    try {\n        // Try block to handle code that may cause exception\n        num1 = 0;\n        num2 = 62 / num1;\n        System.out.println(\"Try block message\");\n    } catch (ArithmeticException e) {\n        System.out.println(\"Error: Don't divide a number by zero\");\n    }\n    System.out.println(\"I'm out of try-catch block in Java.\");\n}\n","name":"main","className":"TryCatchExample1","variables":{"args":1,"num1":3,"num2":2},"javaDoc":"","comments":"Try block to handle code that may cause exception This block is to catch divide-by-zero error ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"CityTime","methodCalls":{},"constants":{"\"?\"":3},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n Constructor method to initialize intance variables.\n ************************************************************************/\npublic CityTime() {\n    city = new String(\"?\");\n    time = new String(\"?\");\n    date = new String(\"?\");\n}\n","name":"CityTime","className":"CityTime","variables":{"date":1,"city":1,"time":1},"javaDoc":"Constructor method to initialize intance variables","comments":"**********************************************************************\n Constructor method to initialize intance variables.\n ***********************************************************************","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n Accessor method:\n This method returns a city of departure or arrival.\n ************************************************************************/\npublic String getCity() {\n    return city;\n}\n","name":"getCity","className":"CityTime","variables":{"city":1},"javaDoc":"Accessor method: This method returns a city of departure or arrival","comments":"**********************************************************************\n Accessor method:\n This method returns a city of departure or arrival.\n ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n Accessor method:\n This method returns time of departure or arrival.\n ************************************************************************/\npublic String getTime() {\n    return time;\n}\n","name":"getTime","className":"CityTime","variables":{"time":1},"javaDoc":"Accessor method: This method returns time of departure or arrival","comments":"**********************************************************************\n Accessor method:\n This method returns time of departure or arrival.\n ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n Accessor method:\n This method returns a date of departure or arrival.\n ************************************************************************/\npublic String getDate() {\n    return date;\n}\n","name":"getDate","className":"CityTime","variables":{"date":1},"javaDoc":"Accessor method: This method returns a date of departure or arrival","comments":"**********************************************************************\n Accessor method:\n This method returns a date of departure or arrival.\n ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  Modifier method:\n  This method sets the city of departure or arrival.\n ************************************************************************/\npublic void setCity(String place) {\n    city = place;\n}\n","name":"setCity","className":"CityTime","variables":{"city":1,"place":2},"javaDoc":"Modifier method: This method sets the city of departure or arrival","comments":"**********************************************************************\n  Modifier method:\n  This method sets the city of departure or arrival.\n ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  Modifier method:\n  This method sets the time of departure or arrival.\n ************************************************************************/\npublic void setTime(String tt) {\n    time = tt;\n}\n","name":"setTime","className":"CityTime","variables":{"tt":2,"time":1},"javaDoc":"Modifier method: This method sets the time of departure or arrival","comments":"**********************************************************************\n  Modifier method:\n  This method sets the time of departure or arrival.\n ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  Modifier method:\n  This method sets the date of departure or arrival.\n ************************************************************************/\npublic void setDate(String dd) {\n    date = dd;\n}\n","name":"setDate","className":"CityTime","variables":{"dd":2,"date":1},"javaDoc":"Modifier method: This method sets the date of departure or arrival","comments":"**********************************************************************\n  Modifier method:\n  This method sets the date of departure or arrival.\n ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\",\"":2},"annotations":[],"types":{"String":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/*****************************************************************************\n This method return a string containing the attribute information in  departure or arrival.\n *****************************************************************************/\npublic String toString() {\n    String result;\n    result = city + \",\" + date + \",\" + time;\n    return result;\n}\n","name":"toString","className":"CityTime","variables":{"result":3,"date":1,"city":1,"time":1},"javaDoc":"This method return a string containing the attribute information in departure or arrival","comments":"***************************************************************************\n This method return a string containing the attribute information in  departure or arrival.\n ****************************************************************************","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"compareTo":5},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","CastExpr","FieldAccessExpr","EnclosedExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/***************************************************************************\n  This method defines how two objects of CityTime are compared.\n  If their cities are same, it compares their date.\n  If theri cities are different, their order is determined by the order\n  of their cities' lexical order.\n  If their dates are same, it compares time. You can use simple string\n  comparison for this.\n  ***************************************************************************/\npublic int compareTo(Object other) {\n    if (city.compareTo(((CityTime) other).city) == 0) {\n        if (date.compareTo(((CityTime) other).date) == 0)\n            return (time.compareTo(((CityTime) other).time));\n        else\n            return (date.compareTo(((CityTime) other).date));\n    } else\n        return (city.compareTo(((CityTime) other).city));\n}\n","name":"compareTo","className":"CityTime","variables":{"date":2,"other":6,"city":2,"time":1},"javaDoc":"This method defines how two objects of CityTime are compared If their cities are same it compares their date If theri cities are different their order is determined by the order of their cities' lexical order If their dates are same it compares time You can use simple string comparison for this","comments":"*************************************************************************\n  This method defines how two objects of CityTime are compared.\n  If their cities are same, it compares their date.\n  If theri cities are different, their order is determined by the order\n  of their cities' lexical order.\n  If their dates are same, it compares time. You can use simple string\n  comparison for this.\n  **************************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"// Move Moves the iterator past the next element.\nObject next();\n","name":"next","className":"ListIterator","variables":{},"javaDoc":"","comments":" Move Moves the iterator past the next element.","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"// Tests if there is an element after the iterator position.\nboolean hasNext();\n","name":"hasNext","className":"ListIterator","variables":{},"javaDoc":"","comments":" Tests if there is an element after the iterator position.","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"// Adds an element before the iterator position\n// and moves the iterator past the inserted element.\nvoid add(Object element);\n","name":"add","className":"ListIterator","variables":{"element":1},"javaDoc":"","comments":" and moves the iterator past the inserted element.","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"// Removes the last traversed element. This method may\n// only be called after a call to the next() method.\nvoid remove();\n","name":"remove","className":"ListIterator","variables":{},"javaDoc":"","comments":" only be called after a call to the next() method.","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"// Sets the last traversed element to a different value.\nvoid set(Object element);\n","name":"set","className":"ListIterator","variables":{"element":1},"javaDoc":"","comments":" Sets the last traversed element to a different value.","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["String"],"returnType":"Passenger","methodCalls":{"parseInt":1,"setLastName":1,"split":2,"trim":5,"setFirstName":1,"setBookingNum":1,"setPassengerID":1,"System.out.print":1},"constants":{"\",\"":1,"\":\"":1,"\"Invalid String\\n\"":1},"annotations":[],"types":{"String":5,"Passenger":1,"String[]":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","TryStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["NumberFormatException"],"text":"public static Passenger parseStringToPassenger(String lineToParse) {\n    String temp1 = new String();\n    String temp2 = new String();\n    String temp3 = new String();\n    String temp4 = new String();\n    String name = new String();\n    Passenger passenger = new Passenger();\n    try {\n        String[] tokens = lineToParse.split(\":\");\n        if (tokens[0].length() > 0)\n            name = tokens[0];\n        if (tokens[1].length() > 0) {\n            temp3 = tokens[1];\n            passenger.setPassengerID(temp3.trim());\n        }\n        if (tokens.length == 3 && tokens[2].length() > 0) {\n            temp4 = tokens[2];\n            passenger.setBookingNum(Integer.parseInt(temp4.trim()));\n        }\n        name = name.trim();\n        String[] tokens2 = name.split(\",\");\n        if (tokens2[0].length() > 0) {\n            temp1 = tokens2[0];\n            passenger.setLastName(temp1.trim());\n        }\n        if (tokens2.length == 2 && tokens2[1].length() > 0) {\n            temp2 = tokens2[1];\n            passenger.setFirstName(temp2.trim());\n        }\n        return passenger;\n    } catch (NumberFormatException exception) {\n        System.out.print(\"Invalid String\\n\");\n        return passenger;\n    }\n}\n","name":"parseStringToPassenger","className":"PassengerParser","variables":{"Integer":1,"exception":1,"temp4":3,"passenger":7,"lineToParse":2,"name":5,"tokens2":5,"tokens":7,"temp2":3,"temp3":3,"temp1":3},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"TimeBean","methodCalls":{"getTimeInstance":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Initializes the formatter.\n   */\npublic TimeBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n}\n","name":"TimeBean","className":"TimeBean","variables":{"DateFormat":1,"timeFormatter":1},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1},"constants":{},"annotations":[],"types":{"String":1,"Date":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Read-only time property.\n      @return the formatted time\n   */\npublic String getTime() {\n    Date time = new Date();\n    String timeString = timeFormatter.format(time);\n    return timeString;\n}\n","name":"getTime","className":"TimeBean","variables":{"timeString":2,"time":1,"timeFormatter":1},"javaDoc":"Read-only time property the formatted time","comments":"\n      Read-only time property.\n      @return the formatted time\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"TimeZoneBean","methodCalls":{"getTimeInstance":1},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Initializes the formatter.\n   */\npublic TimeZoneBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n    cities = new ArrayList<>();\n}\n","name":"TimeZoneBean","className":"TimeZoneBean","variables":{"cities":1,"DateFormat":1,"timeFormatter":1},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   */\npublic void setCityToAdd(String city) {\n    cityToAdd = city;\n}\n","name":"setCityToAdd","className":"TimeZoneBean","variables":{"city":2,"cityToAdd":1},"javaDoc":"Setter for cityToAdd property city the city to add to the list of cities","comments":"\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   */\npublic String getCityToAdd() {\n    return cityToAdd;\n}\n","name":"getCityToAdd","className":"TimeZoneBean","variables":{"cityToAdd":1},"javaDoc":"Getter for cityToAdd property the city to add to the list of cities","comments":"\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   */\npublic void setCityToRemove(String city) {\n    cityToRemove = city;\n}\n","name":"setCityToRemove","className":"TimeZoneBean","variables":{"city":2,"cityToRemove":1},"javaDoc":"Setter for the cityToRemove property city the city to remove from the list of cities","comments":"\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   */\npublic String getCityToRemove() {\n    return cityToRemove;\n}\n","name":"getCityToRemove","className":"TimeZoneBean","variables":{"cityToRemove":1},"javaDoc":"Getter for the cityToRemove property the city to remove from the list of cities","comments":"\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Map<String, String>","methodCalls":{"size":1,"getTimeZone":1,"get":1,"setTimeZone":1,"format":1,"put":1},"constants":{"null":1,"\"unavailable\"":1,"\": \"":1},"annotations":[],"types":{"Map<String, String>":1,"TimeZone":1,"String":3,"TreeMap":1,"Date":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   */\npublic Map<String, String> getCitiesAndTimes() {\n    Date time = new Date();\n    Map<String, String> result = new TreeMap<>();\n    for (int i = 0; i < cities.size(); i++) {\n        String city = cities.get(i);\n        String label = city + \": \";\n        TimeZone zone = getTimeZone(city);\n        if (zone != null) {\n            timeFormatter.setTimeZone(zone);\n            String timeString = timeFormatter.format(time);\n            label = label + timeString;\n        } else {\n            label = label + \"unavailable\";\n        }\n        result.put(label, city);\n    }\n    return result;\n}\n","name":"getCitiesAndTimes","className":"TimeZoneBean","variables":{"result":3,"cities":2,"city":2,"zone":2,"timeString":2,"time":1,"label":5,"timeFormatter":2},"javaDoc":"Read-only citiesAndTimes property a map containing the cities and formatted times","comments":"\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"add":1,"getTimeZone":1},"constants":{"\"\"":1,"null":1,"\"error\"":1,"\"next\"":1},"annotations":[],"types":{"TimeZone":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Action for adding a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   */\npublic String addCity() {\n    TimeZone zone = getTimeZone(cityToAdd);\n    if (zone == null) {\n        return \"error\";\n    }\n    cities.add(cityToAdd);\n    cityToRemove = cityToAdd;\n    cityToAdd = \"\";\n    return \"next\";\n}\n","name":"addCity","className":"TimeZoneBean","variables":{"cities":1,"zone":2,"cityToAdd":2,"cityToRemove":1},"javaDoc":"Action for adding a city \"next\" if time zone information is available for the city \"error\" otherwise","comments":"\n      Action for adding a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"size":1,"remove":1},"constants":{"null":1,"\"index\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NullLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Action for removing a city.\n      @return null if there are more cities to remove, \"index\" otherwise\n   */\npublic String removeCity() {\n    cities.remove(cityToRemove);\n    if (cities.size() > 0) {\n        return null;\n    } else {\n        return \"index\";\n    }\n}\n","name":"removeCity","className":"TimeZoneBean","variables":{"cities":2},"javaDoc":"Action for removing a city null if there are more cities to remove \"index\" otherwise","comments":"\n      Action for removing a city.\n      @return null if there are more cities to remove, \"index\" otherwise\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"TimeZone","methodCalls":{"getTimeZone":2,"Logger.global.info":1,"getAvailableIDs":1,"timeZoneIDmatch":1,"getZoneNameFromDB":1},"constants":{"null":2,"\"Caught in TimeZone.getTimeZone: \"":1},"annotations":[],"types":{"String[]":1,"String":1,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"/**\n      Looks up the time zone for a city\n      @param city the city for which to find the time zone\n      @return the time zone or null if no match is found\n   */\nprivate TimeZone getTimeZone(String city) {\n    String[] ids = TimeZone.getAvailableIDs();\n    for (int i = 0; i < ids.length; i++) {\n        if (timeZoneIDmatch(ids[i], city)) {\n            return TimeZone.getTimeZone(ids[i]);\n        }\n    }\n    try {\n        String id = getZoneNameFromDB(city);\n        if (id != null) {\n            return TimeZone.getTimeZone(id);\n        }\n    } catch (Exception ex) {\n        Logger.global.info(\"Caught in TimeZone.getTimeZone: \" + ex);\n    }\n    return null;\n}\n","name":"getTimeZone","className":"TimeZoneBean","variables":{"TimeZone":3,"ex":2,"city":1,"ids":3,"id":2},"javaDoc":"Looks up the time zone for a city city the city for which to find the time zone the time zone or null if no match is found","comments":"\n      Looks up the time zone for a city\n      @param city the city for which to find the time zone\n      @return the time zone or null if no match is found\n   ","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"next":1,"getConnection":1,"setString":1,"Logger.global.info":1,"prepareStatement":1,"getString":1,"executeQuery":1},"constants":{"null":3,"\"No database connection\"":1,"\"SELECT Zone FROM CityZone WHERE City=?\"":1},"annotations":[],"types":{"Connection":1,"ResultSet":1,"PreparedStatement":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"private String getZoneNameFromDB(String city) throws SQLException {\n    if (source == null) {\n        Logger.global.info(\"No database connection\");\n        return null;\n    }\n    try (Connection conn = source.getConnection()) {\n        PreparedStatement stat = conn.prepareStatement(\"SELECT Zone FROM CityZone WHERE City=?\");\n        stat.setString(1, city);\n        ResultSet result = stat.executeQuery();\n        if (result.next()) {\n            return result.getString(1);\n        } else {\n            return null;\n        }\n    }\n}\n","name":"getZoneNameFromDB","className":"TimeZoneBean","variables":{"result":3,"conn":2,"stat":3,"city":1,"source":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":["String","String"],"returnType":"boolean","methodCalls":{"equals":1,"replace":1,"indexOf":1,"substring":1},"constants":{"' '":1,"'/'":1,"'_'":1},"annotations":[],"types":{"String":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","CharLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether a time zone ID matches a city\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param city the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   */\nprivate static boolean timeZoneIDmatch(String id, String city) {\n    String idCity = id.substring(id.indexOf('/') + 1);\n    return idCity.replace('_', ' ').equals(city);\n}\n","name":"timeZoneIDmatch","className":"TimeZoneBean","variables":{"city":1,"idCity":2,"id":3},"javaDoc":"Checks whether a time zone ID matches a city id the time zone ID (e g \"America/Los_Angeles\") city the city to match (e g \"Los Angeles\") true if the ID and city match","comments":"\n      Checks whether a time zone ID matches a city\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param city the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   ","isEmpty":false,"lineCount":2,"modifier":10}
{"paramTypes":[],"returnType":"TimeZoneBean","methodCalls":{"getTimeInstance":1},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Initializes the formatter.\n   */\npublic TimeZoneBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n    cities = new ArrayList<>();\n}\n","name":"TimeZoneBean","className":"TimeZoneBean","variables":{"cities":1,"DateFormat":1,"timeFormatter":1},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   */\npublic void setCityToAdd(String city) {\n    cityToAdd = city;\n}\n","name":"setCityToAdd","className":"TimeZoneBean","variables":{"city":2,"cityToAdd":1},"javaDoc":"Setter for cityToAdd property city the city to add to the list of cities","comments":"\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   */\npublic String getCityToAdd() {\n    return cityToAdd;\n}\n","name":"getCityToAdd","className":"TimeZoneBean","variables":{"cityToAdd":1},"javaDoc":"Getter for cityToAdd property the city to add to the list of cities","comments":"\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   */\npublic void setCityToRemove(String city) {\n    cityToRemove = city;\n}\n","name":"setCityToRemove","className":"TimeZoneBean","variables":{"city":2,"cityToRemove":1},"javaDoc":"Setter for the cityToRemove property city the city to remove from the list of cities","comments":"\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   */\npublic String getCityToRemove() {\n    return cityToRemove;\n}\n","name":"getCityToRemove","className":"TimeZoneBean","variables":{"cityToRemove":1},"javaDoc":"Getter for the cityToRemove property the city to remove from the list of cities","comments":"\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Map<String, String>","methodCalls":{"size":1,"getTimeZone":1,"get":1,"setTimeZone":1,"format":1,"put":1},"constants":{"null":1,"\"unavailable\"":1,"\": \"":1},"annotations":[],"types":{"Map<String, String>":1,"TimeZone":1,"String":3,"TreeMap":1,"Date":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"/**\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   */\npublic Map<String, String> getCitiesAndTimes() {\n    Date time = new Date();\n    Map<String, String> result = new TreeMap<>();\n    for (int i = 0; i < cities.size(); i++) {\n        String city = cities.get(i);\n        String label = city + \": \";\n        TimeZone zone = getTimeZone(city);\n        if (zone != null) {\n            timeFormatter.setTimeZone(zone);\n            String timeString = timeFormatter.format(time);\n            label = label + timeString;\n        } else {\n            label = label + \"unavailable\";\n        }\n        result.put(label, city);\n    }\n    return result;\n}\n","name":"getCitiesAndTimes","className":"TimeZoneBean","variables":{"result":3,"cities":2,"city":2,"zone":2,"timeString":2,"time":1,"label":5,"timeFormatter":2},"javaDoc":"Read-only citiesAndTimes property a map containing the cities and formatted times","comments":"\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"add":1,"getTimeZone":1},"constants":{"\"\"":1,"null":3},"annotations":[],"types":{"TimeZone":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Action for adding a city.\n      @return null\n   */\npublic String addCity() {\n    TimeZone zone = getTimeZone(cityToAdd);\n    if (zone == null) {\n        return null;\n    }\n    cities.add(cityToAdd);\n    cityToRemove = cityToAdd;\n    cityToAdd = \"\";\n    return null;\n}\n","name":"addCity","className":"TimeZoneBean","variables":{"cities":1,"zone":2,"cityToAdd":2,"cityToRemove":1},"javaDoc":"Action for adding a city null","comments":"\n      Action for adding a city.\n      @return null\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"remove":1},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Action for removing a city.\n      @return null\n   */\npublic String removeCity() {\n    cities.remove(cityToRemove);\n    return null;\n}\n","name":"removeCity","className":"TimeZoneBean","variables":{"cities":1},"javaDoc":"Action for removing a city null","comments":"\n      Action for removing a city.\n      @return null\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"TimeZone","methodCalls":{"getTimeZone":1,"getAvailableIDs":1,"timeZoneIDmatch":1},"constants":{"null":1},"annotations":[],"types":{"String[]":1,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   */\nprivate static TimeZone getTimeZone(String aCity) {\n    String[] ids = TimeZone.getAvailableIDs();\n    for (int i = 0; i < ids.length; i++) {\n        if (timeZoneIDmatch(ids[i], aCity)) {\n            return TimeZone.getTimeZone(ids[i]);\n        }\n    }\n    return null;\n}\n","name":"getTimeZone","className":"TimeZoneBean","variables":{"TimeZone":2,"ids":3,"aCity":1},"javaDoc":"Looks up the time zone for a city aCity the city for which to find the time zone the time zone or null if no match is found","comments":"\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["String","String"],"returnType":"boolean","methodCalls":{"equals":1,"replace":1,"indexOf":1,"substring":1},"constants":{"' '":1,"'/'":1,"'_'":1},"annotations":[],"types":{"String":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","CharLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   */\nprivate static boolean timeZoneIDmatch(String id, String aCity) {\n    String idCity = id.substring(id.indexOf('/') + 1);\n    return idCity.replace('_', ' ').equals(aCity);\n}\n","name":"timeZoneIDmatch","className":"TimeZoneBean","variables":{"idCity":2,"aCity":1,"id":3},"javaDoc":"Checks whether a time zone ID matches a city id the time zone ID (e g \"America/Los_Angeles\") aCity the city to match (e g \"Los Angeles\") true if the ID and city match","comments":"\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   ","isEmpty":false,"lineCount":2,"modifier":10}
{"paramTypes":[],"returnType":"TimeZoneBean","methodCalls":{"getTimeInstance":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Initializes the formatter.\n   */\npublic TimeZoneBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n}\n","name":"TimeZoneBean","className":"TimeZoneBean","variables":{"DateFormat":1,"timeFormatter":1},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Setter for city property.\n      @param aCity the city for which to report the local time\n   */\npublic void setCity(String aCity) {\n    city = aCity;\n}\n","name":"setCity","className":"TimeZoneBean","variables":{"city":1,"aCity":2},"javaDoc":"Setter for city property aCity the city for which to report the local time","comments":"\n      Setter for city property.\n      @param aCity the city for which to report the local time\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Getter for city property.\n      @return the city for which to report the local time\n   */\npublic String getCity() {\n    return city;\n}\n","name":"getCity","className":"TimeZoneBean","variables":{"city":1},"javaDoc":"Getter for city property the city for which to report the local time","comments":"\n      Getter for city property.\n      @return the city for which to report the local time\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"setTimeZone":1,"format":1},"constants":{"null":1,"\"not available\"":1},"annotations":[],"types":{"String":1,"Date":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Read-only time property.\n      @return the formatted time\n   */\npublic String getTime() {\n    if (zone == null) {\n        return \"not available\";\n    }\n    timeFormatter.setTimeZone(zone);\n    Date time = new Date();\n    String timeString = timeFormatter.format(time);\n    return timeString;\n}\n","name":"getTime","className":"TimeZoneBean","variables":{"zone":1,"timeString":2,"time":1,"timeFormatter":2},"javaDoc":"Read-only time property the formatted time","comments":"\n      Read-only time property.\n      @return the formatted time\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getTimeZone":1},"constants":{"null":1,"\"error\"":1,"\"next\"":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Action for checking a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   */\npublic String checkCity() {\n    zone = getTimeZone(city);\n    if (zone == null) {\n        return \"error\";\n    }\n    return \"next\";\n}\n","name":"checkCity","className":"TimeZoneBean","variables":{"zone":2},"javaDoc":"Action for checking a city \"next\" if time zone information is available for the city \"error\" otherwise","comments":"\n      Action for checking a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String"],"returnType":"TimeZone","methodCalls":{"getTimeZone":1,"getAvailableIDs":1,"timeZoneIDmatch":1},"constants":{"null":1},"annotations":[],"types":{"String[]":1,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   */\nprivate static TimeZone getTimeZone(String aCity) {\n    String[] ids = TimeZone.getAvailableIDs();\n    for (int i = 0; i < ids.length; i++) {\n        if (timeZoneIDmatch(ids[i], aCity)) {\n            return TimeZone.getTimeZone(ids[i]);\n        }\n    }\n    return null;\n}\n","name":"getTimeZone","className":"TimeZoneBean","variables":{"TimeZone":2,"ids":3,"aCity":1},"javaDoc":"Looks up the time zone for a city aCity the city for which to find the time zone the time zone or null if no match is found","comments":"\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["String","String"],"returnType":"boolean","methodCalls":{"equals":1,"replace":1,"indexOf":1,"substring":1},"constants":{"' '":1,"'/'":1,"'_'":1},"annotations":[],"types":{"String":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","CharLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   */\nprivate static boolean timeZoneIDmatch(String id, String aCity) {\n    String idCity = id.substring(id.indexOf('/') + 1);\n    return idCity.replace('_', ' ').equals(aCity);\n}\n","name":"timeZoneIDmatch","className":"TimeZoneBean","variables":{"idCity":2,"aCity":1,"id":3},"javaDoc":"Checks whether a time zone ID matches a city id the time zone ID (e g \"America/Los_Angeles\") aCity the city to match (e g \"Los Angeles\") true if the ID and city match","comments":"\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   ","isEmpty":false,"lineCount":2,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"search":1,"assertTrue":1,"assertEquals":1,"toString":1,"System.out.println":2},"constants":{"\"\"":1,"\"Testing empty list\"":1,"\"0\"":1,"\"testEmpty Passed\"":1},"annotations":["Test"],"types":{"StringList":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//method that tests whether search will return an empty string if the list is empty.\n@Test\npublic void testEmpty() {\n    System.out.println(\"Testing empty list\");\n    StringList list = new StringList();\n    assertEquals(-1, list.search(\"0\"));\n    assertTrue(\"\".equals(list.toString()));\n    System.out.println(\"testEmpty Passed\");\n}\n","name":"testEmpty","className":"StringListTest","variables":{"list":3},"javaDoc":"","comments":"method that tests whether search will return an empty string if the list is empty.","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"search":2,"insert":1,"toString":1,"assertEquals":2,"System.out.println":3},"constants":{"\"List: \"":1,"\"0\"":1,"\"Testing insert method\"":1,"\"testInsert Passed\"":1,"\"woohoo\"":2},"annotations":["Test"],"types":{"StringList":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//method that tests the insert method to make sure it works\n@Test\npublic void testInsert() {\n    System.out.println(\"Testing insert method\");\n    StringList list = new StringList();\n    list.insert(\"woohoo\");\n    System.out.println(\"List: \" + list.toString());\n    assertEquals(0, list.search(\"woohoo\"));\n    assertEquals(-1, list.search(\"0\"));\n    System.out.println(\"testInsert Passed\");\n}\n","name":"testInsert","className":"StringListTest","variables":{"list":5},"javaDoc":"","comments":"method that tests the insert method to make sure it works","isEmpty":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"assertTrue":1,"insert":8,"toString":2,"replaceAll":2,"System.out.println":2},"constants":{"\"d\"":1,"\"\"":2,"\"c\"":1,"\"b\"":1,"\"a\"":1,"\"Testing insert method for duplicates\"":1,"\"\\\\s+\"":2,"\"testDuplicate Passed\"":1,"\"\\\"\"":2,"\"abcde\"":2,"\"e\"":4},"annotations":["Test"],"types":{"StringList":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","EnclosedExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//method that makes sure duplicates aren't added to the list\n@Test\npublic void testDuplicate() {\n    System.out.println(\"Testing insert method for duplicates\");\n    StringList list = new StringList();\n    list.insert(\"a\");\n    list.insert(\"d\");\n    list.insert(\"b\");\n    list.insert(\"c\");\n    list.insert(\"e\");\n    list.insert(\"e\");\n    list.insert(\"e\");\n    list.insert(\"e\");\n    assertTrue(\"abcde\".equals(list.toString().replaceAll(\"\\\\s+\", \"\")) || (\"\\\"\" + \"abcde\" + \"\\\"\").equals(list.toString().replaceAll(\"\\\\s+\", \"\")));\n    System.out.println(\"testDuplicate Passed\");\n}\n","name":"testDuplicate","className":"StringListTest","variables":{"list":11},"javaDoc":"","comments":"method that makes sure duplicates aren't added to the list","isEmpty":false,"lineCount":12,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"get":2,"insert":1,"assertEquals":2,"System.out.println":2},"constants":{"\"\"":1,"\"yay\"":2,"\"Testing get method\"":1,"\"testGet Passed\"":1},"annotations":["Test"],"types":{"StringListExt":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//method that tests the get method to make sure it returns the correct string\n@Test\npublic void testGet() {\n    System.out.println(\"Testing get method\");\n    StringListExt list = new StringListExt();\n    assertEquals(\"\", list.get(0));\n    list.insert(\"yay\");\n    assertEquals(\"yay\", list.get(0));\n    System.out.println(\"testGet Passed\");\n}\n","name":"testGet","className":"StringListTest","variables":{"list":4},"javaDoc":"","comments":"method that tests the get method to make sure it returns the correct string","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"get":2,"assertEquals":2,"System.out.println":2},"constants":{"\"Testing add method\"":1,"\"grape\"":2,"\"testAdd Passed\"":1,"\"orange\"":2},"annotations":["Test"],"types":{"StringListExt":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//method that tests the add method to make sure it adds the strings at the end of the list.\n@Test\npublic void testAdd() {\n    System.out.println(\"Testing add method\");\n    StringListExt list = new StringListExt();\n    list.add(\"orange\");\n    assertEquals(\"orange\", list.get(0));\n    list.add(\"grape\");\n    assertEquals(\"grape\", list.get(1));\n    System.out.println(\"testAdd Passed\");\n}\n","name":"testAdd","className":"StringListTest","variables":{"list":5},"javaDoc":"","comments":"method that tests the add method to make sure it adds the strings at the end of the list.","isEmpty":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":6,"length":2,"assertEquals":2,"System.out.println":2},"constants":{"\"apple\"":6,"\"Testing length method\"":1,"\"testLength Passed\"":1},"annotations":["Test"],"types":{"StringListExt":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//method that tests the length method to make sure it returns the correct length\n@Test\npublic void testLength() {\n    System.out.println(\"Testing length method\");\n    StringListExt list = new StringListExt();\n    assertEquals(0, list.length());\n    list.add(\"apple\");\n    list.add(\"apple\");\n    list.add(\"apple\");\n    list.add(\"apple\");\n    list.add(\"apple\");\n    list.add(\"apple\");\n    assertEquals(6, list.length());\n    System.out.println(\"testLength Passed\");\n}\n","name":"testLength","className":"StringListTest","variables":{"list":9},"javaDoc":"","comments":"method that tests the length method to make sure it returns the correct length","isEmpty":false,"lineCount":11,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":9,"assertEquals":3,"getLast":3,"System.out.println":2},"constants":{"\"\"":1,"\"a\"":2,"\"getLast Passed\"":1,"\"z\"":1,"\"y\"":2,"\"x\"":6,"\"Testing getLast method\"":1},"annotations":["Test"],"types":{"StringListExt":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//method that tests the getLast method to make sure it returns the last string. \n@Test\npublic void testGetLast() {\n    System.out.println(\"Testing getLast method\");\n    StringListExt list = new StringListExt();\n    assertEquals(\"\", list.getLast());\n    list.add(\"x\");\n    list.add(\"x\");\n    list.add(\"x\");\n    list.add(\"x\");\n    list.add(\"x\");\n    list.add(\"x\");\n    list.add(\"y\");\n    assertEquals(\"y\", list.getLast());\n    list.add(\"z\");\n    list.add(\"a\");\n    assertEquals(\"a\", list.getLast());\n    System.out.println(\"getLast Passed\");\n}\n","name":"testGetLast","className":"StringListTest","variables":{"list":13},"javaDoc":"","comments":"method that tests the getLast method to make sure it returns the last string. ","isEmpty":false,"lineCount":15,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":4,"get":1,"assertEquals":1,"remove":1,"System.out.println":2},"constants":{"\"remove Passed\"":1,"\"apple\"":1,"\"grape\"":2,"\"banana\"":1,"\"Testing remove method\"":1,"\"orange\"":2},"annotations":["Test"],"types":{"StringListExt":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//method that tests the remove method to make sure it removes the correct string. \n@Test\npublic void testRemove() {\n    System.out.println(\"Testing remove method\");\n    StringListExt list = new StringListExt();\n    list.add(\"apple\");\n    list.add(\"orange\");\n    list.add(\"grape\");\n    list.add(\"banana\");\n    list.remove(\"orange\");\n    assertEquals(\"grape\", list.get(1));\n    System.out.println(\"remove Passed\");\n}\n","name":"testRemove","className":"StringListTest","variables":{"list":7},"javaDoc":"","comments":"method that tests the remove method to make sure it removes the correct string. ","isEmpty":false,"lineCount":9,"modifier":1}
{"paramTypes":["String","int","double","String","String"],"returnType":"Clothing","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExplicitConstructorInvocationStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Clothing(String id, int quantity, double unitPrice, String size, String color) {\n    super(id, quantity, unitPrice);\n    this.size = size;\n    this.color = color;\n}\n","name":"Clothing","className":"Clothing","variables":{"unitPrice":2,"quantity":2,"size":2,"color":2,"id":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["SuperExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void computeTotalCost() {\n    super.totalCost = unitPrice * quantity;\n}\n","name":"computeTotalCost","className":"Clothing","variables":{"unitPrice":1,"quantity":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"Size:\\t\\t\\t\"":1,"\"\\nClothing:\\n\"":1,"\"Color:\\t\\t\\t\"":1,"\"\\n\"":2},"annotations":[],"types":{},"expressions":["SuperExpr","BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"\\nClothing:\\n\" + super.toString() + \"Size:\\t\\t\\t\" + size + \"\\n\" + \"Color:\\t\\t\\t\" + color + \"\\n\";\n}\n","name":"toString","className":"Clothing","variables":{"size":1,"color":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setAnswer":1,"addChoice":4,"addQuestion":2,"presentQuestions":1,"setText":2},"constants":{"\"Who was the inventor of Java?\"":1,"\"In which country was the inventor of Java born?\"":1,"\"Denmark\"":1,"\"United States\"":1,"\"James Gosling\"":1,"false":3,"true":1,"\"Canada\"":1,"\"Australia\"":1},"annotations":[],"types":{"Quiz":1,"Question":1,"ChoiceQuestion":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Question first = new Question();\n    first.setText(\"Who was the inventor of Java?\");\n    first.setAnswer(\"James Gosling\");\n    ChoiceQuestion second = new ChoiceQuestion();\n    second.setText(\"In which country was the inventor of Java born?\");\n    second.addChoice(\"Australia\", false);\n    second.addChoice(\"Canada\", true);\n    second.addChoice(\"Denmark\", false);\n    second.addChoice(\"United States\", false);\n    Quiz q = new Quiz();\n    q.addQuestion(first);\n    q.addQuestion(second);\n    q.presentQuestions();\n}\n","name":"main","className":"QuizDemo","variables":{"args":1,"first":3,"second":6},"javaDoc":"","isEmpty":false,"lineCount":13,"modifier":9}
{"paramTypes":[],"returnType":"Quiz","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a quiz with no questions.\n   */\npublic Quiz() {\n    questions = new ArrayList<Question>();\n}\n","name":"Quiz","className":"Quiz","variables":{"questions":1},"javaDoc":"Constructs a quiz with no questions","comments":"\n      Constructs a quiz with no questions.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Question"],"returnType":"void","methodCalls":{"add":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a question to this quiz.\n      @param q the question\n   */\npublic void addQuestion(Question q) {\n    questions.add(q);\n}\n","name":"addQuestion","className":"Quiz","variables":{"questions":1},"javaDoc":"Adds a question to this quiz q the question","comments":"\n      Adds a question to this quiz.\n      @param q the question\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"display":1,"System.out.print":1,"System.out.println":1},"constants":{"\"Your answer: \"":1},"annotations":[],"types":{"Scanner":1,"Question":1,"String":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Presents the questions to the user and checks the response.\n   */\npublic void presentQuestions() {\n    Scanner in = new Scanner(System.in);\n    for (Question q : questions) {\n        q.display();\n        System.out.print(\"Your answer: \");\n        String response = in.nextLine();\n        System.out.println(q.checkAnswer(response));\n    }\n}\n","name":"presentQuestions","className":"Quiz","variables":{"in":2,"response":1,"questions":1},"javaDoc":"Presents the questions to the user and checks the response","comments":"\n      Presents the questions to the user and checks the response.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"constants":{"\"\"":2},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":2},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":2},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":2},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ChoiceQuestion","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a choice question with no choices.\n   */\npublic ChoiceQuestion() {\n    choices = new ArrayList<String>();\n}\n","name":"ChoiceQuestion","className":"ChoiceQuestion","variables":{"choices":1},"javaDoc":"Constructs a choice question with no choices","comments":"\n      Constructs a choice question with no choices.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","boolean"],"returnType":"void","methodCalls":{"add":1,"size":1,"setAnswer":1},"constants":{"\"\"":1},"annotations":[],"types":{"String":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   */\npublic void addChoice(String choice, boolean correct) {\n    choices.add(choice);\n    if (correct) {\n        // Convert choices.size() to string\n        String choiceString = \"\" + choices.size();\n        setAnswer(choiceString);\n    }\n}\n","name":"addChoice","className":"ChoiceQuestion","variables":{"correct":2,"choiceString":1,"choice":1,"choices":2},"javaDoc":"Adds an answer choice to this question choice the choice to add correct true if this is the correct choice false otherwise","comments":"Convert choices size() to string \n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"constants":{"\": \"":1},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","SuperExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void display() {\n    // Display the question text\n    super.display();\n    // Display the answer choices\n    for (int i = 0; i < choices.size(); i++) {\n        int choiceNumber = i + 1;\n        System.out.println(choiceNumber + \": \" + choices.get(i));\n    }\n}\n","name":"display","className":"ChoiceQuestion","variables":{"choiceNumber":2,"choices":2},"javaDoc":"","comments":"Display the question text Display the answer choices ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Address"],"returnType":"Invoice","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an invoice.\n      @param anAddress the billing address\n   */\npublic Invoice(Address anAddress) {\n    items = new ArrayList<LineItem>();\n    billingAddress = anAddress;\n}\n","name":"Invoice","className":"Invoice","variables":{"anAddress":2,"billingAddress":1,"items":1},"javaDoc":"Constructs an invoice anAddress the billing address","comments":"\n      Constructs an invoice.\n      @param anAddress the billing address\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Product","int"],"returnType":"void","methodCalls":{"add":1},"constants":{},"annotations":[],"types":{"LineItem":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a charge for a product to this invoice.\n      @param aProduct the product that the customer ordered\n      @param quantity the quantity of the product\n   */\npublic void add(Product aProduct, int quantity) {\n    LineItem anItem = new LineItem(aProduct, quantity);\n    items.add(anItem);\n}\n","name":"add","className":"Invoice","variables":{"quantity":2,"aProduct":2,"anItem":1,"items":1},"javaDoc":"Adds a charge for a product to this invoice aProduct the product that the customer ordered quantity the quantity of the product","comments":"\n      Adds a charge for a product to this invoice.\n      @param aProduct the product that the customer ordered\n      @param quantity the quantity of the product\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":4,"getAmountDue":1},"constants":{"\"Price\"":1,"\"Description\"":1,"\"\\nAMOUNT DUE: $%8.2f\"":1,"\"                     I N V O I C E\\n\\n\"":1,"\"Qty\"":1,"\"\\n\\n%-30s%8s%5s%8s\\n\"":1,"\"Total\"":1,"\"\\n\"":1},"annotations":[],"types":{"LineItem":1,"String":1},"expressions":["VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Formats the invoice.\n      @return the formatted invoice\n   */\npublic String format() {\n    String r = \"                     I N V O I C E\\n\\n\" + billingAddress.format() + String.format(\"\\n\\n%-30s%8s%5s%8s\\n\", \"Description\", \"Price\", \"Qty\", \"Total\");\n    for (LineItem item : items) {\n        r = r + item.format() + \"\\n\";\n    }\n    r = r + String.format(\"\\nAMOUNT DUE: $%8.2f\", getAmountDue());\n    return r;\n}\n","name":"format","className":"Invoice","variables":{"item":2,"billingAddress":1,"String":2,"items":1},"javaDoc":"Formats the invoice the formatted invoice","comments":"\n      Formats the invoice.\n      @return the formatted invoice\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getTotalPrice":1},"constants":{},"annotations":[],"types":{"double":1,"LineItem":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the total amount due.\n      @return the amount due\n   */\nprivate double getAmountDue() {\n    double amountDue = 0;\n    for (LineItem item : items) {\n        amountDue = amountDue + item.getTotalPrice();\n    }\n    return amountDue;\n}\n","name":"getAmountDue","className":"Invoice","variables":{"amountDue":4,"item":2,"items":1},"javaDoc":"Computes the total amount due the amount due","comments":"\n      Computes the total amount due.\n      @return the amount due\n   ","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"format":1,"System.out.println":1},"constants":{"24.95":1,"\"CA\"":1,"\"Hair dryer\"":1,"\"Anytown\"":1,"29.95":1,"\"Sam's Small Appliances\"":1,"\"98765\"":1,"\"Car vacuum\"":1,"19.99":1,"\"100 Main Street\"":1,"\"Toaster\"":1},"annotations":[],"types":{"Invoice":1,"Address":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Address samsAddress = new Address(\"Sam's Small Appliances\", \"100 Main Street\", \"Anytown\", \"CA\", \"98765\");\n    Invoice samsInvoice = new Invoice(samsAddress);\n    samsInvoice.add(new Product(\"Toaster\", 29.95), 3);\n    samsInvoice.add(new Product(\"Hair dryer\", 24.95), 1);\n    samsInvoice.add(new Product(\"Car vacuum\", 19.99), 2);\n    System.out.println(samsInvoice.format());\n}\n","name":"main","className":"InvoicePrinter","variables":{"args":1,"samsInvoice":5,"samsAddress":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Product","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   */\npublic Product(String aDescription, double aPrice) {\n    description = aDescription;\n    price = aPrice;\n}\n","name":"Product","className":"Product","variables":{"aDescription":2,"price":1,"description":1,"aPrice":2},"javaDoc":"Constructs a product from a description and a price aDescription the product description aPrice the product price","comments":"\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the product description.\n      @return the description\n   */\npublic String getDescription() {\n    return description;\n}\n","name":"getDescription","className":"Product","variables":{"description":1},"javaDoc":"Gets the product description the description","comments":"\n      Gets the product description.\n      @return the description\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the product price.\n      @return the unit price\n   */\npublic double getPrice() {\n    return price;\n}\n","name":"getPrice","className":"Product","variables":{"price":1},"javaDoc":"Gets the product price the unit price","comments":"\n      Gets the product price.\n      @return the unit price\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","String","String","String","String"],"returnType":"Address","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a mailing address. \n      @param aName the recipient name\n      @param aStreet the street\n      @param aCity the city\n      @param aState the two-letter state code\n      @param aZip the ZIP postal code\n   */\npublic Address(String aName, String aStreet, String aCity, String aState, String aZip) {\n    name = aName;\n    street = aStreet;\n    city = aCity;\n    state = aState;\n    zip = aZip;\n}\n","name":"Address","className":"Address","variables":{"zip":1,"aStreet":2,"city":1,"street":1,"aName":2,"name":1,"aCity":2,"state":1,"aState":2,"aZip":2},"javaDoc":"Constructs a mailing address aName the recipient name aStreet the street aCity the city aState the two-letter state code aZip the ZIP postal code","comments":"\n      Constructs a mailing address. \n      @param aName the recipient name\n      @param aStreet the street\n      @param aCity the city\n      @param aState the two-letter state code\n      @param aZip the ZIP postal code\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\" \"":1,"\", \"":1,"\"\\n\"":2},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Formats the address.\n      @return the address as a string with three lines\n   */\npublic String format() {\n    return name + \"\\n\" + street + \"\\n\" + city + \", \" + state + \" \" + zip;\n}\n","name":"format","className":"Address","variables":{"zip":1,"city":1,"street":1,"name":1,"state":1},"javaDoc":"Formats the address the address as a string with three lines","comments":"\n      Formats the address.\n      @return the address as a string with three lines\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Product","int"],"returnType":"LineItem","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   */\npublic LineItem(Product aProduct, int aQuantity) {\n    theProduct = aProduct;\n    quantity = aQuantity;\n}\n","name":"LineItem","className":"LineItem","variables":{"quantity":1,"aProduct":2,"aQuantity":2,"theProduct":1},"javaDoc":"Constructs an item from the product and quantity aProduct the product aQuantity the item quantity","comments":"\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getPrice":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the total cost of this line item.\n      @return the total price\n   */\npublic double getTotalPrice() {\n    return theProduct.getPrice() * quantity;\n}\n","name":"getTotalPrice","className":"LineItem","variables":{"quantity":1,"theProduct":1},"javaDoc":"Computes the total cost of this line item the total price","comments":"\n      Computes the total cost of this line item.\n      @return the total price\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1,"getTotalPrice":1,"getDescription":1,"getPrice":1},"constants":{"\"%-30s%8.2f%5d%8.2f\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Formats this item.\n      @return a formatted string of this item\n   */\npublic String format() {\n    return String.format(\"%-30s%8.2f%5d%8.2f\", theProduct.getDescription(), theProduct.getPrice(), quantity, getTotalPrice());\n}\n","name":"format","className":"LineItem","variables":{"String":1,"theProduct":2},"javaDoc":"Formats this item a formatted string of this item","comments":"\n      Formats this item.\n      @return a formatted string of this item\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Deposits money into the account.\n      @param amount the amount of money to withdraw\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Deposits money into the account amount the amount of money to withdraw","comments":" \n      Deposits money into the account.\n      @param amount the amount of money to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Withdraws money from the account.\n      @param amount the amount of money to deposit\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Withdraws money from the account amount the amount of money to deposit","comments":" \n      Withdraws money from the account.\n      @param amount the amount of money to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Gets the account balance.\n      @return the account balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the account balance the account balance","comments":" \n      Gets the account balance.\n      @return the account balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"showMessageDialog":1,"readCustomers":1,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"\"customers.txt\"":1,"\"Error opening accounts file.\"":1,"null":1,"true":1,"\"First National Bank of Java\"":1},"annotations":[],"types":{"Bank":1,"JFrame":1,"ATM":1,"ATMFrame":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["TryStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["IOException"],"text":"public static void main(String[] args) {\n    ATM theATM;\n    try {\n        Bank theBank = new Bank();\n        theBank.readCustomers(\"customers.txt\");\n        theATM = new ATM(theBank);\n    } catch (IOException e) {\n        JOptionPane.showMessageDialog(null, \"Error opening accounts file.\");\n        return;\n    }\n    JFrame frame = new ATMFrame(theATM);\n    frame.setTitle(\"First National Bank of Java\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ATMViewer","variables":{"args":1,"theATM":3,"theBank":3,"JOptionPane":1,"frame":4},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"selectAccount":2,"back":3,"nextInt":2,"nextDouble":2,"setCustomerNumber":1,"getState":1,"getBalance":1,"readCustomers":1,"reset":1,"deposit":1,"equalsIgnoreCase":6,"System.out.print":6,"selectCustomer":1,"System.out.println":4,"withdraw":1},"constants":{"\"customers.txt\"":1,"\"Error opening accounts file.\"":1,"\"Enter customer number: \"":1,"\"Illegal input!\"":2,"\"C\"":2,"\"B\"":2,"\"A\"":2,"\"A=Checking, B=Savings, C=Quit: \"":1,"\"Balance=\"":1,"\"A=Deposit, B=Withdrawal, C=Cancel: \"":1,"true":1,"\"Amount: \"":2,"\"Enter PIN: \"":1},"annotations":[],"types":{"Scanner":1,"Bank":1,"double":2,"ATM":1,"String":2,"int":3},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","TryStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) {\n    ATM theATM;\n    try {\n        Bank theBank = new Bank();\n        theBank.readCustomers(\"customers.txt\");\n        theATM = new ATM(theBank);\n    } catch (IOException e) {\n        System.out.println(\"Error opening accounts file.\");\n        return;\n    }\n    Scanner in = new Scanner(System.in);\n    while (true) {\n        int state = theATM.getState();\n        if (state == ATM.START) {\n            System.out.print(\"Enter customer number: \");\n            int number = in.nextInt();\n            theATM.setCustomerNumber(number);\n        } else if (state == ATM.PIN) {\n            System.out.print(\"Enter PIN: \");\n            int pin = in.nextInt();\n            theATM.selectCustomer(pin);\n        } else if (state == ATM.ACCOUNT) {\n            System.out.print(\"A=Checking, B=Savings, C=Quit: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                theATM.selectAccount(ATM.CHECKING);\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                theATM.selectAccount(ATM.SAVINGS);\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.reset();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        } else if (state == ATM.TRANSACT) {\n            System.out.println(\"Balance=\" + theATM.getBalance());\n            System.out.print(\"A=Deposit, B=Withdrawal, C=Cancel: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.deposit(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.withdraw(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.back();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        }\n    }\n}\n","name":"main","className":"ATMSimulator","variables":{"args":1,"number":1,"amount":2,"theATM":14,"theBank":3,"pin":1,"in":7,"state":5,"command":8},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int","int"],"returnType":"Customer","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a customer with a given number and PIN.\n      @param aNumber the customer number\n      @param aPin the personal identification number\n   */\npublic Customer(int aNumber, int aPin) {\n    customerNumber = aNumber;\n    pin = aPin;\n    checkingAccount = new BankAccount();\n    savingsAccount = new BankAccount();\n}\n","name":"Customer","className":"Customer","variables":{"aNumber":2,"pin":1,"savingsAccount":1,"checkingAccount":1,"aPin":2,"customerNumber":1},"javaDoc":"Constructs a customer with a given number and PIN aNumber the customer number aPin the personal identification number","comments":"\n      Constructs a customer with a given number and PIN.\n      @param aNumber the customer number\n      @param aPin the personal identification number\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Tests if this customer matches a customer number \n      and PIN.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return true if the customer number and PIN match\n   */\npublic boolean match(int aNumber, int aPin) {\n    return customerNumber == aNumber && pin == aPin;\n}\n","name":"match","className":"Customer","variables":{"aNumber":2,"pin":1,"aPin":2,"customerNumber":1},"javaDoc":"Tests if this customer matches a customer number and PIN aNumber a customer number aPin a personal identification number true if the customer number and PIN match","comments":" \n      Tests if this customer matches a customer number \n      and PIN.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return true if the customer number and PIN match\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Gets the checking account of this customer.\n      @return the checking account\n   */\npublic BankAccount getCheckingAccount() {\n    return checkingAccount;\n}\n","name":"getCheckingAccount","className":"Customer","variables":{"checkingAccount":1},"javaDoc":"Gets the checking account of this customer the checking account","comments":" \n      Gets the checking account of this customer.\n      @return the checking account\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Gets the savings account of this customer.\n      @return the checking account\n   */\npublic BankAccount getSavingsAccount() {\n    return savingsAccount;\n}\n","name":"getSavingsAccount","className":"Customer","variables":{"savingsAccount":1},"javaDoc":"Gets the savings account of this customer the checking account","comments":" \n      Gets the savings account of this customer.\n      @return the checking account\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Bank","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank with no customers.\n   */\npublic Bank() {\n    customers = new ArrayList<Customer>();\n}\n","name":"Bank","className":"Bank","variables":{"customers":1},"javaDoc":"Constructs a bank with no customers","comments":"\n      Constructs a bank with no customers.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"addCustomer":1,"hasNext":1,"nextInt":2,"close":1},"constants":{},"annotations":[],"types":{"Scanner":1,"Customer":1,"int":2},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"/**\n      Reads the customer numbers and pins.\n      @param filename the name of the customer file\n   */\npublic void readCustomers(String filename) throws IOException {\n    Scanner in = new Scanner(new File(filename));\n    while (in.hasNext()) {\n        int number = in.nextInt();\n        int pin = in.nextInt();\n        Customer c = new Customer(number, pin);\n        addCustomer(c);\n    }\n    in.close();\n}\n","name":"readCustomers","className":"Bank","variables":{"number":2,"filename":2,"pin":2,"in":5},"javaDoc":"Reads the customer numbers and pins filename the name of the customer file","comments":"\n      Reads the customer numbers and pins.\n      @param filename the name of the customer file\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Customer"],"returnType":"void","methodCalls":{"add":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds a customer to the bank.\n      @param c the customer to add\n   */\npublic void addCustomer(Customer c) {\n    customers.add(c);\n}\n","name":"addCustomer","className":"Bank","variables":{"customers":1},"javaDoc":"Adds a customer to the bank c the customer to add","comments":"\n      Adds a customer to the bank.\n      @param c the customer to add\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Customer","methodCalls":{"match":1},"constants":{"null":1},"annotations":[],"types":{"Customer":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Finds a customer in the bank.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return the matching customer, or null if no customer \n      matches\n   */\npublic Customer findCustomer(int aNumber, int aPin) {\n    for (Customer c : customers) {\n        if (c.match(aNumber, aPin)) {\n            return c;\n        }\n    }\n    return null;\n}\n","name":"findCustomer","className":"Bank","variables":{"aNumber":1,"aPin":1,"customers":1},"javaDoc":"Finds a customer in the bank aNumber a customer number aPin a personal identification number the matching customer or null if no customer matches","comments":" \n      Finds a customer in the bank.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return the matching customer, or null if no customer \n      matches\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Bank"],"returnType":"ATM","methodCalls":{"reset":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   */\npublic ATM(Bank aBank) {\n    theBank = aBank;\n    reset();\n}\n","name":"ATM","className":"ATM","variables":{"theBank":1,"aBank":2},"javaDoc":"Constructs an ATM for a given bank aBank the bank to which this ATM connects","comments":"\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NullLiteralExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Resets the ATM to the initial state.\n   */\npublic void reset() {\n    customerNumber = -1;\n    currentAccount = null;\n    state = START;\n}\n","name":"reset","className":"ATM","variables":{"START":1,"currentAccount":1,"state":1,"customerNumber":1},"javaDoc":"Resets the ATM to the initial state","comments":"\n      Resets the ATM to the initial state.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   */\npublic void setCustomerNumber(int number) {\n    customerNumber = number;\n    state = PIN;\n}\n","name":"setCustomerNumber","className":"ATM","variables":{"number":2,"PIN":1,"state":1,"customerNumber":1},"javaDoc":"Sets the current customer number and sets state to PIN (Precondition: state is START) number the customer number","comments":" \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"findCustomer":1},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   */\npublic void selectCustomer(int pin) {\n    currentCustomer = theBank.findCustomer(customerNumber, pin);\n    if (currentCustomer == null) {\n        state = START;\n    } else {\n        state = ACCOUNT;\n    }\n}\n","name":"selectCustomer","className":"ATM","variables":{"ACCOUNT":1,"pin":1,"currentCustomer":2,"theBank":1,"START":1,"state":2},"javaDoc":"Finds customer in bank If found sets state to ACCOUNT else to START (Precondition: state is PIN) pin the PIN of the current customer","comments":" \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getCheckingAccount":1,"getSavingsAccount":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   */\npublic void selectAccount(int account) {\n    if (account == CHECKING) {\n        currentAccount = currentCustomer.getCheckingAccount();\n    } else {\n        currentAccount = currentCustomer.getSavingsAccount();\n    }\n    state = TRANSACT;\n}\n","name":"selectAccount","className":"ATM","variables":{"currentCustomer":2,"TRANSACT":1,"CHECKING":1,"currentAccount":2,"state":1,"account":2},"javaDoc":"Sets current account to checking or savings Sets state to TRANSACT (Precondition: state is ACCOUNT or TRANSACT) account one of CHECKING or SAVINGS","comments":" \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"withdraw":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   */\npublic void withdraw(double value) {\n    currentAccount.withdraw(value);\n}\n","name":"withdraw","className":"ATM","variables":{"currentAccount":1,"value":1},"javaDoc":"Withdraws amount from current account (Precondition: state is TRANSACT) value the amount to withdraw","comments":" \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"deposit":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   */\npublic void deposit(double value) {\n    currentAccount.deposit(value);\n}\n","name":"deposit","className":"ATM","variables":{"currentAccount":1,"value":1},"javaDoc":"Deposits amount to current account (Precondition: state is TRANSACT) value the amount to deposit","comments":" \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getBalance":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   */\npublic double getBalance() {\n    return currentAccount.getBalance();\n}\n","name":"getBalance","className":"ATM","variables":{"currentAccount":1},"javaDoc":"Gets the balance of the current account (Precondition: state is TRANSACT) the balance","comments":" \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Moves back to the previous state.\n   */\npublic void back() {\n    if (state == TRANSACT) {\n        state = ACCOUNT;\n    } else if (state == ACCOUNT) {\n        state = PIN;\n    } else if (state == PIN) {\n        state = START;\n    }\n}\n","name":"back","className":"ATM","variables":{"ACCOUNT":2,"TRANSACT":1,"PIN":2,"START":1,"state":6},"javaDoc":"Moves back to the previous state","comments":"\n      Moves back to the previous state.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current state of this ATM.\n      @return the current state\n   */\npublic int getState() {\n    return state;\n}\n","name":"getState","className":"ATM","variables":{"state":1},"javaDoc":"Gets the current state of this ATM the current state","comments":"\n      Gets the current state of this ATM.\n      @return the current state\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setText":1},"constants":{"\"\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    display.setText(\"\");\n}\n","name":"actionPerformed","className":"ClearButtonListener","variables":{"display":1,"event":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"KeyPad","methodCalls":{"add":3,"addActionListener":1,"addButton":11,"setLayout":2,"setText":1},"constants":{"\"North\"":1,"\"\"":1,"\"9\"":1,"\"8\"":1,"\"Center\"":1,"\"7\"":1,"\"6\"":1,"\"CE\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"\"1\"":1,"\"0\"":1,"\".\"":1},"annotations":[],"types":{"ActionListener":1,"ClearButtonListener":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["TypeDeclarationStmt","BlockStmt","ExpressionStmt"],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"exceptions":[],"text":"/**\n      Constructs the keypad panel.\n   */\npublic KeyPad() {\n    setLayout(new BorderLayout());\n    // Add display field\n    display = new JTextField();\n    add(display, \"North\");\n    // Make button panel\n    buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 3));\n    // Add digit buttons\n    addButton(\"7\");\n    addButton(\"8\");\n    addButton(\"9\");\n    addButton(\"4\");\n    addButton(\"5\");\n    addButton(\"6\");\n    addButton(\"1\");\n    addButton(\"2\");\n    addButton(\"3\");\n    addButton(\"0\");\n    addButton(\".\");\n    // Add clear entry button\n    clearButton = new JButton(\"CE\");\n    buttonPanel.add(clearButton);\n    class ClearButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            display.setText(\"\");\n        }\n    }\n    ActionListener listener = new ClearButtonListener();\n    clearButton.addActionListener(new ClearButtonListener());\n    add(buttonPanel, \"Center\");\n}\n","name":"KeyPad","className":"KeyPad","variables":{"actionPerformed":1,"clearButton":2,"display":2,"buttonPanel":3,"listener":1,"ClearButtonListener":1,"event":1},"javaDoc":"Constructs the keypad panel","comments":"Add display field Make button panel Add digit buttons Add clear entry button \n      Constructs the keypad panel.\n   ","isEmpty":false,"lineCount":26,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":2,"equals":1,"indexOf":1,"setText":1},"constants":{"\".\"":2},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    // Don't add two decimal points\n    if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n        return;\n    }\n    // Append label text to button\n    display.setText(display.getText() + label);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"display":3,"label":2,"event":1},"javaDoc":"","comments":"Don't add two decimal points Append label text to button ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"getText":2,"equals":1,"addActionListener":1,"indexOf":1,"setText":1},"constants":{"\".\"":2},"annotations":[],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","TypeDeclarationStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"exceptions":[],"text":"/**\n      Adds a button to the button panel \n      @param label the button label\n   */\nprivate void addButton(final String label) {\n    class DigitButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            // Don't add two decimal points\n            if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n                return;\n            }\n            // Append label text to button\n            display.setText(display.getText() + label);\n        }\n    }\n    JButton button = new JButton(label);\n    buttonPanel.add(button);\n    ActionListener listener = new DigitButtonListener();\n    button.addActionListener(listener);\n}\n","name":"addButton","className":"KeyPad","variables":{"button":2,"actionPerformed":1,"DigitButtonListener":1,"display":3,"buttonPanel":1,"listener":1,"label":4,"event":1},"javaDoc":"Adds a button to the button panel label the button label","comments":"Don't add two decimal points Append label text to button \n      Adds a button to the button panel \n      @param label the button label\n   ","isEmpty":false,"lineCount":5,"modifier":2}
{"paramTypes":[],"returnType":"double","methodCalls":{"parseDouble":1,"getText":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   */\npublic double getValue() {\n    return Double.parseDouble(display.getText());\n}\n","name":"getValue","className":"KeyPad","variables":{"display":1,"Double":1},"javaDoc":"Gets the value that the user entered the value in the text field of the keypad","comments":" \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"constants":{"\"\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Clears the display. \n   */\npublic void clear() {\n    display.setText(\"\");\n}\n","name":"clear","className":"KeyPad","variables":{"display":1},"javaDoc":"Clears the display","comments":" \n      Clears the display. \n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["ATM"],"returnType":"ATMFrame","methodCalls":{"add":6,"showState":1,"setSize":1,"addActionListener":3,"setLayout":1},"constants":{"\"  C  \"":1,"\"  B  \"":1,"\"  A  \"":1,"20":1},"annotations":[],"types":{"JPanel":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs the user interface of the ATM frame.\n   */\npublic ATMFrame(ATM anATM) {\n    theATM = anATM;\n    // Construct components\n    pad = new KeyPad();\n    display = new JTextArea(4, 20);\n    aButton = new JButton(\"  A  \");\n    aButton.addActionListener(new AButtonListener());\n    bButton = new JButton(\"  B  \");\n    bButton.addActionListener(new BButtonListener());\n    cButton = new JButton(\"  C  \");\n    cButton.addActionListener(new CButtonListener());\n    // Add components\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.add(aButton);\n    buttonPanel.add(bButton);\n    buttonPanel.add(cButton);\n    setLayout(new FlowLayout());\n    add(pad);\n    add(display);\n    add(buttonPanel);\n    showState();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"ATMFrame","className":"ATMFrame","variables":{"aButton":2,"pad":1,"theATM":1,"anATM":2,"display":1,"buttonPanel":4,"cButton":2,"bButton":2},"javaDoc":"Constructs the user interface of the ATM frame","comments":"Add components Construct components \n      Constructs the user interface of the ATM frame.\n   ","isEmpty":false,"lineCount":20,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getState":1,"getBalance":1,"clear":1,"setText":4},"constants":{"\"Select Account\\n\"":1,"\"Balance = \"":1,"\"A = Withdraw\\nB = Deposit\\nC = Cancel\"":1,"\"Enter PIN\\nA = OK\"":1,"\"A = Checking\\nB = Savings\\nC = Exit\"":1,"\"\\nEnter amount and select transaction\\n\"":1,"\"Enter customer number\\nA = OK\"":1},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Updates display message.\n   */\npublic void showState() {\n    int state = theATM.getState();\n    pad.clear();\n    if (state == ATM.START) {\n        display.setText(\"Enter customer number\\nA = OK\");\n    } else if (state == ATM.PIN) {\n        display.setText(\"Enter PIN\\nA = OK\");\n    } else if (state == ATM.ACCOUNT) {\n        display.setText(\"Select Account\\n\" + \"A = Checking\\nB = Savings\\nC = Exit\");\n    } else if (state == ATM.TRANSACT) {\n        display.setText(\"Balance = \" + theATM.getBalance() + \"\\nEnter amount and select transaction\\n\" + \"A = Withdraw\\nB = Deposit\\nC = Cancel\");\n    }\n}\n","name":"showState","className":"ATMFrame","variables":{"pad":1,"theATM":2,"display":4,"state":5},"javaDoc":"Updates display message","comments":" \n      Updates display message.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setCustomerNumber":1,"showState":1,"getValue":3,"getState":1,"selectAccount":1,"back":1,"selectCustomer":1,"withdraw":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","CastExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.START) {\n        theATM.setCustomerNumber((int) pad.getValue());\n    } else if (state == ATM.PIN) {\n        theATM.selectCustomer((int) pad.getValue());\n    } else if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.CHECKING);\n    } else if (state == ATM.TRANSACT) {\n        theATM.withdraw(pad.getValue());\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"AButtonListener","variables":{"pad":3,"theATM":6,"state":5,"event":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getValue":1,"getState":1,"selectAccount":1,"deposit":1,"back":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.SAVINGS);\n    } else if (state == ATM.TRANSACT) {\n        theATM.deposit(pad.getValue());\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"BButtonListener","variables":{"pad":1,"theATM":4,"state":3,"event":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getState":1,"reset":1,"back":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.reset();\n    } else if (state == ATM.TRANSACT) {\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"CButtonListener","variables":{"theATM":3,"state":3,"event":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String","int","double","String","double","String"],"returnType":"Food","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExplicitConstructorInvocationStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Food(String id, int quantity, double unitPrice, String name, double damageRate, String expirationDate) {\n    super(id, quantity, unitPrice);\n    this.name = name;\n    this.damageRate = damageRate;\n    this.expirationDate = expirationDate;\n}\n","name":"Food","className":"Food","variables":{"unitPrice":2,"quantity":2,"name":2,"id":2,"damageRate":2,"expirationDate":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","SuperExpr","BinaryExpr","NameExpr","FieldAccessExpr","EnclosedExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void computeTotalCost() {\n    super.totalCost = (super.unitPrice * super.quantity) * (1 + this.damageRate);\n}\n","name":"computeTotalCost","className":"Food","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1,"getPercentInstance":1},"constants":{"\"\\nFood:\\n\"":1,"100":1,"\"Food Name:\\t\\t\"":1,"\"Damage Rate:\\t\\t\"":1,"\"0.00\"":1,"\"%\\n\"":1,"\"Expiration date:\\t\"":1,"\"\\n\"":2},"annotations":[],"types":{"DecimalFormat":1,"NumberFormat":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","SuperExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","ThisExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    DecimalFormat fmt = new DecimalFormat(\"0.00\");\n    NumberFormat percentFormat = NumberFormat.getPercentInstance();\n    return \"\\nFood:\\n\" + super.toString() + \"Food Name:\\t\\t\" + name + \"\\n\" + \"Damage Rate:\\t\\t\" + fmt.format(this.damageRate * 100) + \"%\\n\" + \"Expiration date:\\t\" + expirationDate + \"\\n\";\n}\n","name":"toString","className":"Food","variables":{"name":1,"fmt":2,"percentFormat":1,"NumberFormat":1,"expirationDate":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"openConnection":1,"hasNextLine":1,"getResponseCode":1,"getResponseMessage":1,"getInputStream":1,"System.out.println":3},"constants":{"\" \"":1,"\"Using \"":1,"\"http://horstmann.com/\"":1},"annotations":[],"types":{"Scanner":1,"HttpURLConnection":1,"InputStream":1,"String":3,"URL":1,"URLConnection":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","CastExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    // Get command line arguments\n    String urlString;\n    if (args.length == 1) {\n        urlString = args[0];\n    } else {\n        urlString = \"http://horstmann.com/\";\n        System.out.println(\"Using \" + urlString);\n    }\n    // Open connection\n    URL u = new URL(urlString);\n    URLConnection connection = u.openConnection();\n    // Check if response code is HTTP_OK (200)\n    HttpURLConnection httpConnection = (HttpURLConnection) connection;\n    int code = httpConnection.getResponseCode();\n    String message = httpConnection.getResponseMessage();\n    System.out.println(code + \" \" + message);\n    if (code != HttpURLConnection.HTTP_OK) {\n        return;\n    }\n    // Read server response\n    InputStream instream = connection.getInputStream();\n    Scanner in = new Scanner(instream);\n    while (in.hasNextLine()) {\n        String input = in.nextLine();\n        System.out.println(input);\n    }\n}\n","name":"main","className":"URLGet","variables":{"args":2,"input":1,"code":3,"in":3,"urlString":5,"connection":3,"httpConnection":3,"instream":2,"message":2},"javaDoc":"","comments":"Get command line arguments Open connection Check if response code is HTTP_OK (200) Read server response ","isEmpty":false,"lineCount":16,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":1,"flush":1,"nextLine":1,"hasNextLine":1,"getOutputStream":1,"getInputStream":1,"System.out.println":2},"constants":{"\"\\n\\n\"":1,"\"/\"":1,"80":1,"\"Getting / from horstmann.com\"":1,"\"horstmann.com\"":1,"\"GET \"":1,"\" HTTP/1.1\\n\"":1,"\"Host: \"":1},"annotations":[],"types":{"Scanner":1,"InputStream":1,"OutputStream":1,"String":4,"int":1,"Socket":1,"PrintWriter":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","TryStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    // Get command-line arguments\n    String host;\n    String resource;\n    if (args.length == 2) {\n        host = args[0];\n        resource = args[1];\n    } else {\n        System.out.println(\"Getting / from horstmann.com\");\n        host = \"horstmann.com\";\n        resource = \"/\";\n    }\n    // Open socket\n    final int HTTP_PORT = 80;\n    try (Socket s = new Socket(host, HTTP_PORT)) {\n        // Get streams\n        InputStream instream = s.getInputStream();\n        OutputStream outstream = s.getOutputStream();\n        // Turn streams into scanners and writers\n        Scanner in = new Scanner(instream);\n        PrintWriter out = new PrintWriter(outstream);\n        // Send command\n        String command = \"GET \" + resource + \" HTTP/1.1\\n\" + \"Host: \" + host + \"\\n\\n\";\n        out.print(command);\n        out.flush();\n        while (in.hasNextLine()) {\n            String input = in.nextLine();\n            System.out.println(input);\n        }\n    }\n// The try-with-resources statement closes the socket\n}\n","name":"main","className":"WebGet","variables":{"args":3,"input":1,"outstream":2,"resource":4,"in":3,"host":5,"HTTP_PORT":2,"instream":2,"command":1,"out":3},"javaDoc":"","comments":"Get command-line arguments Open socket The try-with-resources statement closes the socket Get streams Turn streams into scanners and writers Send command Read server response ","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":1,"System.out.println":2,"accept":1},"constants":{"\"Waiting for clients to connect...\"":1,"true":1,"8888":1,"\"Client connected.\"":1,"10":1},"annotations":[],"types":{"BankService":1,"Bank":1,"ServerSocket":1,"int":2,"Socket":1,"Thread":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    final int ACCOUNTS_LENGTH = 10;\n    Bank bank = new Bank(ACCOUNTS_LENGTH);\n    final int SBAP_PORT = 8888;\n    ServerSocket server = new ServerSocket(SBAP_PORT);\n    System.out.println(\"Waiting for clients to connect...\");\n    while (true) {\n        Socket s = server.accept();\n        System.out.println(\"Client connected.\");\n        BankService service = new BankService(s, bank);\n        Thread t = new Thread(service);\n        t.start();\n    }\n}\n","name":"main","className":"BankServer","variables":{"args":1,"server":2,"bank":2,"SBAP_PORT":2,"service":2,"ACCOUNTS_LENGTH":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n    balanceChangeLock = new ReentrantLock();\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"balanceChangeLock":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":2},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"unlock":1,"lock":1},"constants":{},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balanceChangeLock.lock();\n    try {\n        double newBalance = balance + amount;\n        balance = newBalance;\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":2,"balanceChangeLock":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"unlock":1,"lock":1},"constants":{},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balanceChangeLock.lock();\n    try {\n        double newBalance = balance - amount;\n        balance = newBalance;\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":2,"balanceChangeLock":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Bank","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given number of accounts.\n      @param size the number of accounts\n   */\npublic Bank(int size) {\n    accounts = new BankAccount[size];\n    for (int i = 0; i < accounts.length; i++) {\n        accounts[i] = new BankAccount();\n    }\n}\n","name":"Bank","className":"Bank","variables":{"size":2,"accounts":2},"javaDoc":"Constructs a bank account with a given number of accounts size the number of accounts","comments":"\n      Constructs a bank account with a given number of accounts.\n      @param size the number of accounts\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{"deposit":1},"constants":{},"annotations":[],"types":{"BankAccount":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into a bank account.\n      @param accountNumber the account number\n      @param amount the amount to deposit\n   */\npublic void deposit(int accountNumber, double amount) {\n    BankAccount account = accounts[accountNumber];\n    account.deposit(amount);\n}\n","name":"deposit","className":"Bank","variables":{"amount":1,"accounts":1,"accountNumber":2,"account":2},"javaDoc":"Deposits money into a bank account accountNumber the account number amount the amount to deposit","comments":"\n      Deposits money into a bank account.\n      @param accountNumber the account number\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{"withdraw":1},"constants":{},"annotations":[],"types":{"BankAccount":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from a bank account.\n      @param accountNumber the account number\n      @param amount the amount to withdraw\n   */\npublic void withdraw(int accountNumber, double amount) {\n    BankAccount account = accounts[accountNumber];\n    account.withdraw(amount);\n}\n","name":"withdraw","className":"Bank","variables":{"amount":1,"accounts":1,"accountNumber":2,"account":2},"javaDoc":"Withdraws money from a bank account accountNumber the account number amount the amount to withdraw","comments":"\n      Withdraws money from a bank account.\n      @param accountNumber the account number\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{"getBalance":1},"constants":{},"annotations":[],"types":{"BankAccount":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the balance of a bank account.\n      @param accountNumber the account number\n      @return the account balance\n   */\npublic double getBalance(int accountNumber) {\n    BankAccount account = accounts[accountNumber];\n    return account.getBalance();\n}\n","name":"getBalance","className":"Bank","variables":{"accounts":1,"accountNumber":2,"account":2},"javaDoc":"Gets the balance of a bank account accountNumber the account number the account balance","comments":"\n      Gets the balance of a bank account.\n      @param accountNumber the account number\n      @return the account balance\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":3,"flush":3,"nextLine":2,"getOutputStream":1,"getInputStream":1,"System.out.println":5},"constants":{"\"localhost\"":1,"\"QUIT\"":1,"\"DEPOSIT 3 1000\"":1,"\"WITHDRAW 3 500\"":1,"8888":1,"\"Receiving: \"":2,"\"Sending: \"":3,"\"\\n\"":3},"annotations":[],"types":{"Scanner":1,"InputStream":1,"OutputStream":1,"String":2,"int":1,"Socket":1,"PrintWriter":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":["IOException"],"text":"public static void main(String[] args) throws IOException {\n    final int SBAP_PORT = 8888;\n    try (Socket s = new Socket(\"localhost\", SBAP_PORT)) {\n        InputStream instream = s.getInputStream();\n        OutputStream outstream = s.getOutputStream();\n        Scanner in = new Scanner(instream);\n        PrintWriter out = new PrintWriter(outstream);\n        String command = \"DEPOSIT 3 1000\";\n        System.out.println(\"Sending: \" + command);\n        out.print(command + \"\\n\");\n        out.flush();\n        String response = in.nextLine();\n        System.out.println(\"Receiving: \" + response);\n        command = \"WITHDRAW 3 500\";\n        System.out.println(\"Sending: \" + command);\n        out.print(command + \"\\n\");\n        out.flush();\n        response = in.nextLine();\n        System.out.println(\"Receiving: \" + response);\n        command = \"QUIT\";\n        System.out.println(\"Sending: \" + command);\n        out.print(command + \"\\n\");\n        out.flush();\n    }\n}\n","name":"main","className":"BankClient","variables":{"args":1,"outstream":2,"SBAP_PORT":2,"in":3,"response":4,"instream":2,"command":9,"out":7},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["Socket","Bank"],"returnType":"BankService","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a service object that processes commands\n      from a socket for a bank.\n      @param aSocket the socket\n      @param aBank the bank\n   */\npublic BankService(Socket aSocket, Bank aBank) {\n    s = aSocket;\n    bank = aBank;\n}\n","name":"BankService","className":"BankService","variables":{"bank":1,"aBank":2,"aSocket":2},"javaDoc":"Constructs a service object that processes commands from a socket for a bank aSocket the socket aBank the bank","comments":"\n      Constructs a service object that processes commands\n      from a socket for a bank.\n      @param aSocket the socket\n      @param aBank the bank\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"doService":1,"printStackTrace":1,"getOutputStream":1,"getInputStream":1,"close":1},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public void run() {\n    try {\n        try {\n            in = new Scanner(s.getInputStream());\n            out = new PrintWriter(s.getOutputStream());\n            doService();\n        } finally {\n            s.close();\n        }\n    } catch (IOException exception) {\n        exception.printStackTrace();\n    }\n}\n","name":"run","className":"BankService","variables":{"exception":2,"in":1,"out":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"next":1,"equals":1,"hasNext":1,"executeCommand":1},"constants":{"\"QUIT\"":1,"true":1},"annotations":[],"types":{"String":1},"expressions":["VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"/**\n      Executes all commands until the QUIT command or the\n      end of input.\n   */\npublic void doService() throws IOException {\n    while (true) {\n        if (!in.hasNext()) {\n            return;\n        }\n        String command = in.next();\n        if (command.equals(\"QUIT\")) {\n            return;\n        } else {\n            executeCommand(command);\n        }\n    }\n}\n","name":"doService","className":"BankService","variables":{"in":2,"command":2},"javaDoc":"Executes all commands until the QUIT command or the end of input","comments":"\n      Executes all commands until the QUIT command or the\n      end of input.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":2,"getBalance":1,"flush":2,"equals":3,"deposit":1,"nextInt":1,"nextDouble":2,"withdraw":1},"constants":{"\"Invalid command\"":1,"\"WITHDRAW\"":1,"\" \"":1,"\"BALANCE\"":1,"\"DEPOSIT\"":1},"annotations":[],"types":{"double":2,"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Executes a single command.\n      @param command the command to execute\n   */\npublic void executeCommand(String command) {\n    int account = in.nextInt();\n    if (command.equals(\"DEPOSIT\")) {\n        double amount = in.nextDouble();\n        bank.deposit(account, amount);\n    } else if (command.equals(\"WITHDRAW\")) {\n        double amount = in.nextDouble();\n        bank.withdraw(account, amount);\n    } else if (!command.equals(\"BALANCE\")) {\n        out.println(\"Invalid command\");\n        out.flush();\n        return;\n    }\n    out.println(account + \" \" + bank.getBalance(account));\n    out.flush();\n}\n","name":"executeCommand","className":"BankService","variables":{"amount":2,"bank":3,"in":3,"command":4,"account":2,"out":4},"javaDoc":"Executes a single command command the command to execute","comments":"\n      Executes a single command.\n      @param command the command to execute\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["ArrayList<Comparable>"],"returnType":"Sorts","methodCalls":{"sort":1},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Constructs a sort object, and carries out operations\n\t * @param unsortedList\n\t */\npublic Sorts(ArrayList<Comparable> unsortedList) {\n    sortedList = new ArrayList<Comparable>();\n    //assigns unsorted values to list\n    sortedList = unsortedList;\n    //sorts\n    sort();\n}\n","name":"Sorts","className":"Sorts","variables":{"unsortedList":2,"sortedList":2},"javaDoc":"Constructs a sort object and carries out operations unsortedList","comments":"assigns unsorted values to list sorts \n\t * Constructs a sort object, and carries out operations\n\t * @param unsortedList\n\t ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"ArrayList<Comparable>","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Returns the sorted list.\n\t * @return the sorted List with Comparables\n\t */\npublic ArrayList<Comparable> getSortedList() {\n    return sortedList;\n}\n","name":"getSortedList","className":"Sorts","variables":{"sortedList":1},"javaDoc":"Returns the sorted list the sorted List with Comparables","comments":"\n\t * Returns the sorted list.\n\t * @return the sorted List with Comparables\n\t ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":2,"swap":1,"get":2,"compareTo":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Sorts the ArrayList with a strange insertion sort. I think it's closer to bubble sort\n\t */\nprivate void sort() {\n    for (int i = 0; i < sortedList.size() - 1; i++) {\n        //iterates through array\n        for (int j = i + 1; j < sortedList.size(); j++) {\n            //compares numbers\n            if (sortedList.get(i).compareTo(sortedList.get(j)) > 0) {\n                swap(i, j);\n            }\n        }\n    }\n}\n","name":"sort","className":"Sorts","variables":{"sortedList":4},"javaDoc":"Sorts the ArrayList with a strange insertion sort I think it's closer to bubble sort","comments":"iterates through array compares numbers \n\t * Sorts the ArrayList with a strange insertion sort. I think it's closer to bubble sort\n\t ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"set":2,"get":2},"constants":{},"annotations":[],"types":{"Comparable":1},"expressions":["VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * Swaps two entries\n\t * @param from, the first entry\n\t * @param to, the second entry\n\t */\nprivate void swap(int from, int to) {\n    Comparable temp = sortedList.get(to);\n    sortedList.set(to, sortedList.get(from));\n    sortedList.set(from, temp);\n}\n","name":"swap","className":"Sorts","variables":{"temp":1,"from":1,"sortedList":4,"to":1},"javaDoc":"Swaps two entries from the first entry to the second entry","comments":"\n\t * Swaps two entries\n\t * @param from, the first entry\n\t * @param to, the second entry\n\t ","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"Inside throwMethod\"":1,"\"Demo\"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":["NullPointerException"],"text":"static void throwMethod() throws NullPointerException {\n    System.out.println(\"Inside throwMethod\");\n    throw new NullPointerException(\"Demo\");\n}\n","name":"throwMethod","className":"ThrowsExample1","variables":{},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":8}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"throwMethod":1,"System.out.println":1},"constants":{"\"The exception get caught\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["NullPointerException"],"text":"public static void main(String args[]) {\n    try {\n        throwMethod();\n    } catch (NullPointerException exp) {\n        System.out.println(\"The exception get caught\" + exp);\n    }\n}\n","name":"main","className":"ThrowsExample1","variables":{"args":1,"exp":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"computeTotalCost":1,"parseStringToProduct":1,"length":1,"readLine":3,"printMenu":2,"getProductId":1,"trim":3,"size":1,"toUpperCase":1,"toString":1,"equalsIgnoreCase":1,"System.out.print":9,"charAt":1,"System.out.println":2},"constants":{"\"\"":1,"\"no product\\n\"":1,"false":1,"\"Please enter a productId to search:\\n\"":1,"\"product not found\\n\"":1,"\"What action would you like to perform?\\n\"":1,"\"total costs computed\"":1,"\"product found\\n\"":1,"\"Please enter a product information to add:\\n\"":1,"true":1,"\"Unknown action\\n\"":2,"'Q'":1,"\"IO Exception\"":1,"\"\\n\"":1},"annotations":[],"types":{"boolean":1,"InputStreamReader":1,"ArrayList<Product>":1,"char":1,"BufferedReader":1,"Product":3,"String":3},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","CharLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["SwitchStmt","IfStmt","BreakStmt","TryStmt","BlockStmt","SwitchEntryStmt","ForeachStmt","ExpressionStmt","DoStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) {\n    char input1;\n    String inputInfo = new String();\n    String line = new String();\n    boolean found;\n    // ArrayList object is used to store drink objects\n    ArrayList<Product> productList = new ArrayList<Product>();\n    try {\n        // print out menu\n        printMenu();\n        // create a BufferedReader object to read input from a keyboard\n        InputStreamReader isr = new InputStreamReader(System.in);\n        BufferedReader stdin = new BufferedReader(isr);\n        do {\n            System.out.print(\"What action would you like to perform?\\n\");\n            line = stdin.readLine().trim();\n            input1 = line.charAt(0);\n            input1 = Character.toUpperCase(input1);\n            if (line.length() == 1) {\n                switch(input1) {\n                    case //Add Product\n                    'A':\n                        System.out.print(\"Please enter a product information to add:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        /***********************************************************************************\n                  ***  ADD your code here to create an object of one of child classes of Product class\n                  ***  and add it to the productList\n                  ***********************************************************************************/\n                        productList.add(ProductParser.parseStringToProduct(inputInfo));\n                        break;\n                    case //Compute Total Costs\n                    'C':\n                        /***********************************************************************************\n                  ***  ADD your code here to compute the total cost for all products in the productList.\n                  ***********************************************************************************/\n                        for (Product p : productList) {\n                            p.computeTotalCost();\n                        }\n                        System.out.println(\"total costs computed\");\n                        break;\n                    case //Search for a product\n                    'S':\n                        System.out.print(\"Please enter a productId to search:\\n\");\n                        inputInfo = stdin.readLine().trim();\n                        /***********************************************************************************\n                  ***  ADD your code here to search a given productId. If found, set \"found\" true,\n                  ***  and set \"found\" false otherwise.\n                  ***********************************************************************************/\n                        found = false;\n                        for (Product p : productList) {\n                            if (p.getProductId().equalsIgnoreCase(inputInfo)) {\n                                found = true;\n                            }\n                        }\n                        if (found) {\n                            System.out.print(\"product found\\n\");\n                        } else\n                            System.out.print(\"product not found\\n\");\n                        break;\n                    case //List Products\n                    'L':\n                        /***********************************************************************************\n                  ***  ADD your code here to print out all Product objects in the productList.\n                  ***  If there is no product in the list, print \"no product\\n\"\n                  ***********************************************************************************/\n                        if (productList.size() > 0) {\n                            String output = \"\";\n                            for (Product p : productList) {\n                                output += p.toString() + \"\\n\";\n                            }\n                            System.out.print(output);\n                        } else {\n                            System.out.print(\"no product\\n\");\n                        }\n                        break;\n                    case //Quit\n                    'Q':\n                        break;\n                    case //Display Menu\n                    '?':\n                        printMenu();\n                        break;\n                    default:\n                        System.out.print(\"Unknown action\\n\");\n                        break;\n                }\n            } else {\n                System.out.print(\"Unknown action\\n\");\n            }\n        } while (// stop the loop when Q is read\n        input1 != 'Q');\n    } catch (IOException exception) {\n        System.out.println(\"IO Exception\");\n    }\n}\n","name":"main","className":"Assignment5","variables":{"args":1,"output":2,"exception":1,"inputInfo":3,"stdin":4,"found":4,"Character":1,"line":4,"input1":5,"isr":2,"ProductParser":1,"productList":6},"javaDoc":"","comments":"ArrayList object is used to store drink objects print out menu create a BufferedReader object to read input from a keyboard Add Product ADD your code here to create an object of one of child classes of Product class and add it to the productList Compute Total Costs ADD your code here to compute the total cost for all products in the productList Search for a product ADD your code here to search a given productId If found set \"found\" true and set \"found\" false otherwise List Products ADD your code here to print out all Product objects in the productList If there is no product in the list print \"no product\\n\" Quit Display Menu stop the loop when Q is read ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.print":1},"constants":{"\"C\\t\\tCompute Total Costs\\n\"":1,"\"S\\t\\tSearch for Product\\n\"":1,"\"Q\\t\\tQuit\\n\"":1,"\"?\\t\\tDisplay Help\\n\\n\"":1,"\"Choice\\t\\tAction\\n\"":1,"\"A\\t\\tAdd Product\\n\"":1,"\"L\\t\\tList Products\\n\"":1,"\"------\\t\\t------\\n\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** The method printMenu displays the menu to a use **/\npublic static void printMenu() {\n    System.out.print(\"Choice\\t\\tAction\\n\" + \"------\\t\\t------\\n\" + \"A\\t\\tAdd Product\\n\" + \"C\\t\\tCompute Total Costs\\n\" + \"S\\t\\tSearch for Product\\n\" + \"L\\t\\tList Products\\n\" + \"Q\\t\\tQuit\\n\" + \"?\\t\\tDisplay Help\\n\\n\");\n}\n","name":"printMenu","className":"Assignment5","variables":{},"javaDoc":"The method printMenu displays the menu to a use","comments":" The method printMenu displays the menu to a use *","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"Flight","methodCalls":{},"constants":{"\"?\"":2},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n   Constructor method to initialize each variable.\n  ************************************************************************/\npublic Flight() {\n    airlines = new String(\"?\");\n    flightNum = new String(\"?\");\n    departure = new CityTime();\n    arrival = new CityTime();\n}\n","name":"Flight","className":"Flight","variables":{"flightNum":1,"arrival":1,"airlines":1,"departure":1},"javaDoc":"Constructor method to initialize each variable","comments":"**********************************************************************\n   Constructor method to initialize each variable.\n  ***********************************************************************","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  Accessor method:\n  This method returns the airlines name of a flight\n  ************************************************************************/\npublic String getAirlines() {\n    return airlines;\n}\n","name":"getAirlines","className":"Flight","variables":{"airlines":1},"javaDoc":"Accessor method: This method returns the airlines name of a flight","comments":"**********************************************************************\n  Accessor method:\n  This method returns the airlines name of a flight\n  ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  Accessor method:\n  This method returns the flight number of a flight\n  ************************************************************************/\npublic String getFlightNum() {\n    return flightNum;\n}\n","name":"getFlightNum","className":"Flight","variables":{"flightNum":1},"javaDoc":"Accessor method: This method returns the flight number of a flight","comments":"**********************************************************************\n  Accessor method:\n  This method returns the flight number of a flight\n  ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"CityTime","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  Accessor method:\n  This method returns the departure schedule of a flight\n  ************************************************************************/\npublic CityTime getDeparture() {\n    return departure;\n}\n","name":"getDeparture","className":"Flight","variables":{"departure":1},"javaDoc":"Accessor method: This method returns the departure schedule of a flight","comments":"**********************************************************************\n  Accessor method:\n  This method returns the departure schedule of a flight\n  ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"CityTime","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  Accessor method:\n  This method returns the arrival schedule of a flight\n  ************************************************************************/\npublic CityTime getArrival() {\n    return arrival;\n}\n","name":"getArrival","className":"Flight","variables":{"arrival":1},"javaDoc":"Accessor method: This method returns the arrival schedule of a flight","comments":"**********************************************************************\n  Accessor method:\n  This method returns the arrival schedule of a flight\n  ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  Mutator method:\n  This method sets the airlines name of a flight\n  ************************************************************************/\npublic void setAirlines(String aname) {\n    airlines = aname;\n}\n","name":"setAirlines","className":"Flight","variables":{"aname":2,"airlines":1},"javaDoc":"Mutator method: This method sets the airlines name of a flight","comments":"**********************************************************************\n  Mutator method:\n  This method sets the airlines name of a flight\n  ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  Mutator method:\n  This method sets the flight number of a flight\n  ************************************************************************/\npublic void setFlightNum(String fNum) {\n    flightNum = fNum;\n}\n","name":"setFlightNum","className":"Flight","variables":{"flightNum":1,"fNum":2},"javaDoc":"Mutator method: This method sets the flight number of a flight","comments":"**********************************************************************\n  Mutator method:\n  This method sets the flight number of a flight\n  ***********************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","String","String"],"returnType":"void","methodCalls":{"setCity":1,"setDate":1,"setTime":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  Mutator method:\n  This method sets the departure schedule of a flight\n  ************************************************************************/\npublic void setDeparture(String city, String time, String date) {\n    departure.setCity(city);\n    departure.setDate(date);\n    departure.setTime(time);\n}\n","name":"setDeparture","className":"Flight","variables":{"date":1,"city":1,"time":1,"departure":3},"javaDoc":"Mutator method: This method sets the departure schedule of a flight","comments":"**********************************************************************\n  Mutator method:\n  This method sets the departure schedule of a flight\n  ***********************************************************************","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String","String","String"],"returnType":"void","methodCalls":{"setCity":1,"setDate":1,"setTime":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  Mutator method:\n  This method sets the arrival schedule of a flight\n  ************************************************************************/\npublic void setArrival(String city, String time, String date) {\n    arrival.setCity(city);\n    arrival.setDate(date);\n    arrival.setTime(time);\n}\n","name":"setArrival","className":"Flight","variables":{"date":1,"city":1,"arrival":3,"time":1},"javaDoc":"Mutator method: This method sets the arrival schedule of a flight","comments":"**********************************************************************\n  Mutator method:\n  This method sets the arrival schedule of a flight\n  ***********************************************************************","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"Arrival:\\t\"":1,"\"\\nAirlines:\\t\"":1,"\"Departure:\\t\"":1,"\"Flight number:\\t\"":1,"\"\\n\"":5},"annotations":[],"types":{"String":1},"expressions":["VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/************************************************************************\n  This method returns a String containing attribute(variable) values\n  of a flight.\n  ************************************************************************/\npublic String toString() {\n    String result = \"\\nAirlines:\\t\" + airlines + \"\\n\" + \"Flight number:\\t\" + flightNum + \"\\n\" + \"Departure:\\t\" + departure + \"\\n\" + \"Arrival:\\t\" + arrival + \"\\n\";\n    result += \"\\n\";\n    return result;\n}\n","name":"toString","className":"Flight","variables":{"result":3,"flightNum":1,"arrival":1,"airlines":1,"departure":1},"javaDoc":"This method returns a String containing attribute(variable) values of a flight","comments":"**********************************************************************\n  This method returns a String containing attribute(variable) values\n  of a flight.\n  ***********************************************************************","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"compareTo":7},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","CastExpr","FieldAccessExpr","EnclosedExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/********************************************************************\n  This method defines how two objects of Flight should be compared.\n  If their airlines names are same, it compares their flight number.\n  If their airlines names are different, their order is determined\n  by their course names alphabetical order.\n  If their flight numbers are same, it compares their departure schedule.\n  If their departure schedules are same, it compare their arrival\n  schedule.\n  ********************************************************************/\npublic int compareTo(Object other) {\n    int result;\n    if (airlines.compareTo(((Flight) other).airlines) == 0)\n        if (flightNum.compareTo(((Flight) other).flightNum) == 0) {\n            if (departure.compareTo(((Flight) other).departure) == 0) {\n                result = arrival.compareTo(((Flight) other).arrival);\n            } else {\n                result = departure.compareTo(((Flight) other).departure);\n            }\n        } else {\n            result = flightNum.compareTo(((Flight) other).flightNum);\n        }\n    else\n        result = airlines.compareTo(((Flight) other).airlines);\n    return result;\n}\n","name":"compareTo","className":"Flight","variables":{"result":6,"other":8,"flightNum":2,"arrival":1,"airlines":2,"departure":2},"javaDoc":"This method defines how two objects of Flight should be compared If their airlines names are same it compares their flight number If their airlines names are different their order is determined by their course names alphabetical order If their flight numbers are same it compares their departure schedule If their departure schedules are same it compare their arrival schedule","comments":"******************************************************************\n  This method defines how two objects of Flight should be compared.\n  If their airlines names are same, it compares their flight number.\n  If their airlines names are different, their order is determined\n  by their course names alphabetical order.\n  If their flight numbers are same, it compares their departure schedule.\n  If their departure schedules are same, it compare their arrival\n  schedule.\n  *******************************************************************","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getX":1,"translate":1,"System.out.print":1},"constants":{"25":1,"30":1,"20":1,"10":2},"annotations":[],"types":{"Rectangle":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    box.translate(10, 25);\n    System.out.print(box.getX());\n}\n","name":"main","className":"RectTester","variables":{"args":1,"box":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"showMessageDialog":1,"getNumInputs":1},"constants":{"\"JOptionPane showMessageDialog example\"":1,"\"/Users/al/backups\"":1,"\"Problem writing to backup directory: '\"":1,"\"'.\"":1},"annotations":[],"types":{"JFrame":1,"String":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String backupDir = \"/Users/al/backups\";\n    // create a jframe\n    JFrame frame = new JFrame(\"JOptionPane showMessageDialog example\");\n    // show a joptionpane dialog using showMessageDialog\n    JOptionPane.showMessageDialog(frame, \"Problem writing to backup directory: '\" + backupDir + \"'.\");\n    getNumInputs();\n    System.exit(0);\n}\n","name":"main","className":"ShowMessageDialogExample1","variables":{"args":1,"backupDir":2,"JOptionPane":1,"System":1,"frame":1},"javaDoc":"","comments":"create a jframe show a joptionpane dialog using showMessageDialog ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"parseDouble":1,"showInputDialog":1,"equalsIgnoreCase":2,"System.out.println":1},"constants":{"\"\"":1,"\"Q\"":2,"\"Enter some number (Q for exit)\"":1},"annotations":[],"types":{"double":1,"String":2},"expressions":["VariableDeclarationExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// LoopsWhile ; Strings BooleanExpressions ; Strings ; LoopsWhile ; BooleanExpressions\npublic static void getNumInputs() {\n    String input = \"\";\n    String msg = \"Enter some number (Q for exit)\";\n    while (!input.equalsIgnoreCase(\"Q\")) {\n        input = JOptionPane.showInputDialog(msg);\n        if (!input.equalsIgnoreCase(\"Q\")) {\n            double aNumber = Double.parseDouble(input);\n            System.out.println(aNumber);\n        }\n    }\n}\n","name":"getNumInputs","className":"ShowMessageDialogExample1","variables":{"msg":1,"aNumber":1,"input":4,"JOptionPane":1,"Double":1},"javaDoc":"","comments":" LoopsWhile ; Strings BooleanExpressions ; Strings ; LoopsWhile ; BooleanExpressions","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"LinkedList","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Constructs an empty linked list.\npublic LinkedList() {\n    first = null;\n}\n","name":"LinkedList","className":"LinkedList","variables":{"first":1},"javaDoc":"","comments":" Constructs an empty linked list.","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["IfStmt","ThrowStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"// Returns the first element in the linked list.\npublic Object getFirst() {\n    if (first == null)\n        throw new NoSuchElementException();\n    return first.data;\n}\n","name":"getFirst","className":"LinkedList","variables":{"first":1},"javaDoc":"","comments":" Returns the first element in the linked list.","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{"Object":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["IfStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Removes the first element in the linked list.\npublic Object removeFirst() {\n    if (first == null)\n        throw new NoSuchElementException();\n    Object element = first.data;\n    first = first.next;\n    return element;\n}\n","name":"removeFirst","className":"LinkedList","variables":{"first":2,"element":2},"javaDoc":"","comments":" Removes the first element in the linked list.","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"Node":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Adds an element to the front of the linked list.\npublic void addFirst(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    first = newNode;\n}\n","name":"addFirst","className":"LinkedList","variables":{"newNode":2,"first":2,"element":2},"javaDoc":"","comments":" Adds an element to the front of the linked list.","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"next":1,"listIterator":1,"hasNext":1},"constants":{"\" \"":1,"\"{ \"":1,"\"}\\n\"":1},"annotations":[],"types":{"String":1,"ListIterator":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// toString() method prints the elements out from front to tail\npublic String toString() {\n    ListIterator iterator = listIterator();\n    String result = \"{ \";\n    while (iterator.hasNext()) {\n        result += iterator.next() + \" \";\n    }\n    result += \"}\\n\";\n    return result;\n}\n","name":"toString","className":"LinkedList","variables":{"result":4,"iterator":3},"javaDoc":"","comments":" toString() method prints the elements out from front to tail","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"next":1,"listIterator":1,"hasNext":1},"constants":{"null":1},"annotations":[],"types":{"ListIterator":1,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// *************** Below is where you should add the new methods ***********\n// *****************************************************************\n// size() method returns the number of nodes inside this LinkedList\n// *****************************************************************\npublic int size() {\n    ListIterator iterator = listIterator();\n    int ret = 0;\n    if (first != null) {\n        while (iterator.hasNext()) {\n            iterator.next();\n            ret++;\n        }\n    }\n    return ret;\n}\n","name":"size","className":"LinkedList","variables":{"ret":3,"iterator":3,"first":1},"javaDoc":"","comments":" *****************************************************************","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"next":1,"equals":1,"listIterator":1,"hasNext":1},"constants":{},"annotations":[],"types":{"Object":1,"ListIterator":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// ***********************************************************************************\n// searchElement() method returns the index of the first occurrence of the\n// parameter object in the linked list if it exists. It returns -1 if it\n// does not exit.\n// ***********************************************************************************\npublic int searchElement(Object element) {\n    ListIterator iterator = listIterator();\n    int ind = 0;\n    Object n;\n    while (iterator.hasNext()) {\n        if (iterator.next().equals(element)) {\n            return ind;\n        }\n        ind++;\n    }\n    return -1;\n}\n","name":"searchElement","className":"LinkedList","variables":{"iterator":3,"ind":3,"element":1},"javaDoc":"","comments":" ***********************************************************************************","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"next":1,"size":1,"listIterator":1},"constants":{"null":2},"annotations":[],"types":{"Object":1,"ListIterator":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","EnclosedExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// *****************************************************************\n// getElement() method returns the element at the parameter index\n// If the index is out of bounds, throw an IndexOutOfBoundException.\n// *****************************************************************\npublic Object getElement(int index) {\n    if (index < 0 || index >= size()) {\n        throw new IndexOutOfBoundsException();\n    }\n    ListIterator iterator = listIterator();\n    int cnt = 0;\n    Object n;\n    while ((n = iterator.next()) != null) {\n        if (cnt == index) {\n            return n;\n        }\n        cnt++;\n    }\n    return null;\n}\n","name":"getElement","className":"LinkedList","variables":{"iterator":2,"cnt":3,"index":4},"javaDoc":"","comments":" *****************************************************************","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"next":1,"set":1,"size":1,"listIterator":1},"constants":{"null":1},"annotations":[],"types":{"ListIterator":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// ****************************************************************************\n// setElement() method sets the parameter object at the parameter index in\n// the\n// linked list. If the index is out of bounds, throws an\n// IndexOutOfBoundException\n// ****************************************************************************\npublic void setElement(int index, Object element) {\n    if (index < 0 || index >= size()) {\n        throw new IndexOutOfBoundsException();\n    }\n    ListIterator iterator = listIterator();\n    int cnt = 0;\n    while (iterator.next() != null) {\n        if (cnt == index) {\n            iterator.set(element);\n            return;\n        }\n        cnt++;\n    }\n}\n","name":"setElement","className":"LinkedList","variables":{"iterator":3,"cnt":3,"index":4,"element":1},"javaDoc":"","comments":" ****************************************************************************","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"next":2,"add":1,"size":2,"listIterator":1,"hasNext":1,"addFirst":1,"System.out.println":2},"constants":{"\":\"":1},"annotations":[],"types":{"ListIterator":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// ***********************************************************************************\n// insertElement() method inserts the parameter object at the parameter\n// index.\n// If the index is out of bounds, throws an IndexOutOfBoundException\n// Note: the element can be inserted at the end, i.e. inserted at size()\n// index/position\n// ************************************************************************************\npublic void insertElement(int index, Object element) {\n    ListIterator iterator = listIterator();\n    if (index < 0 || index > size()) {\n        System.out.println(index + \":\" + size());\n        System.out.println(iterator.next());\n        throw new IndexOutOfBoundsException();\n    } else if (index == 0) {\n        addFirst(element);\n        return;\n    }\n    int cnt = 1;\n    while (iterator.hasNext()) {\n        iterator.next();\n        if (cnt == index) {\n            iterator.add(element);\n        }\n        cnt++;\n    }\n}\n","name":"insertElement","className":"LinkedList","variables":{"iterator":5,"cnt":3,"index":6,"element":1},"javaDoc":"","comments":" ************************************************************************************","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"next":1,"size":1,"getFirst":1,"removeFirst":1,"listIterator":1,"hasNext":1,"remove":1},"constants":{"null":1},"annotations":[],"types":{"Object":2,"ListIterator":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// *******************************************************************\n// removeElement()method removes and returns element at parameter index\n// and throw an IndexOutOfBoundException if the index is out of bounds\n// *******************************************************************\npublic Object removeElement(int index) {\n    if (index < 0 || index >= size()) {\n        throw new IndexOutOfBoundsException();\n    } else if (index == 0) {\n        Object ret = getFirst();\n        removeFirst();\n        return ret;\n    }\n    ListIterator iterator = listIterator();\n    int cnt = 0;\n    Object n;\n    while (iterator.hasNext()) {\n        n = iterator.next();\n        if (cnt == index) {\n            iterator.remove();\n            return n;\n        }\n        cnt++;\n    }\n    return null;\n}\n","name":"removeElement","className":"LinkedList","variables":{"ret":2,"iterator":4,"cnt":3,"index":5},"javaDoc":"","comments":" *******************************************************************","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"next":1,"equals":1,"listIterator":1,"hasNext":1},"constants":{},"annotations":[],"types":{"ListIterator":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// *****************************************************************\n// countHowMany(Object) method returns the number of occurences of\n// the parameter object in the LinkedList\n// *****************************************************************\npublic int countHowMany(Object searchedObject) {\n    ListIterator iterator = listIterator();\n    int cnt = 0;\n    while (iterator.hasNext()) {\n        if (iterator.next().equals(searchedObject)) {\n            cnt++;\n        }\n    }\n    return cnt;\n}\n","name":"countHowMany","className":"LinkedList","variables":{"iterator":3,"cnt":3,"searchedObject":1},"javaDoc":"","comments":" *****************************************************************","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"next":1,"equals":1,"listIterator":1,"hasNext":1,"remove":1},"constants":{},"annotations":[],"types":{"Object":1,"ListIterator":1},"expressions":["VariableDeclarationExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// *****************************************************************\n// removeDuplicate() method removes all occurences of the parameter\n// objects from the LinkedList\n// *****************************************************************\npublic void removeDuplicate(Object removedObject) {\n    ListIterator iterator = listIterator();\n    Object n;\n    while (iterator.hasNext()) {\n        n = iterator.next();\n        if (n.equals(removedObject)) {\n            iterator.remove();\n        }\n    }\n}\n","name":"removeDuplicate","className":"LinkedList","variables":{"removedObject":1,"iterator":4},"javaDoc":"","comments":" *****************************************************************","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object","int"],"returnType":"void","methodCalls":{"next":1,"add":1,"listIterator":1,"hasNext":1},"constants":{},"annotations":[],"types":{"ListIterator":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// *******************************************************************************\n// appendAtEnd(Object, int) method appends the parameter object number of\n// times at the end of the linked list. For example, a call of\n// appendAtEnd(\"A\", 3)\n// will append string \"A\" three times at the end of the linked list.\n// *******************************************************************************\npublic void appendAtEnd(Object element, int howManyTimes) {\n    ListIterator iterator = listIterator();\n    while (iterator.hasNext()) {\n        iterator.next();\n    }\n    for (int i = 0; i < howManyTimes; i++) {\n        iterator.add(element);\n    }\n}\n","name":"appendAtEnd","className":"LinkedList","variables":{"iterator":4,"element":1,"howManyTimes":2},"javaDoc":"","comments":" *******************************************************************************","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"void","methodCalls":{"next":1,"add":1,"equals":1,"listIterator":1,"hasNext":1,"addFirst":1},"constants":{},"annotations":[],"types":{"Object":1,"ListIterator":1},"expressions":["VariableDeclarationExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// ********************************************************************************\n// appendAfter(Object element1, Object element2) method appends the second\n// parameter\n// object, i.e. element2 right after the first occurence of first parameter\n// object,\n// i.e. element1. If element1 is not inside the linked list, then append\n// element2\n// at the front/head of the linked list.\n// ********************************************************************************\npublic void appendAfter(Object element1, Object element2) {\n    ListIterator iterator = listIterator();\n    Object n;\n    while (iterator.hasNext()) {\n        n = iterator.next();\n        if (n.equals(element1)) {\n            iterator.add(element2);\n            return;\n        }\n    }\n    addFirst(element2);\n}\n","name":"appendAfter","className":"LinkedList","variables":{"iterator":4,"element1":1,"element2":1},"javaDoc":"","comments":" ********************************************************************************","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"next":1,"size":1,"listIterator":1,"hasNext":1,"removeElement":1,"addFirst":1},"constants":{},"annotations":[],"types":{"Object":1,"ListIterator":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// **************************************************************************************\n// reverseFistFew(int howMany) reverse the first parameter number of\n// elements inside the\n// linked list. For example, if the original linked list is { A B C D E }, a\n// call of\n// reverseFirstFew(3) will change the linked list to { C B A D E }. Note:\n// (1)you need to\n// consider the boundary value, i.e.cases where howMany <= 0 or howMany >\n// size()\n// (2)list.reverseFirstFew(list.size()) should reverse the whole linked list\n// **************************************************************************************\npublic void reverseFirstFew(int howMany) {\n    if (howMany <= 0) {\n        return;\n    } else if (howMany > size()) {\n        return;\n    }\n    ListIterator iterator = listIterator();\n    int cnt = 1;\n    Object n;\n    while (iterator.hasNext()) {\n        n = iterator.next();\n        if (cnt <= howMany) {\n            addFirst(n);\n            removeElement(cnt);\n        } else {\n            return;\n        }\n        cnt++;\n    }\n}\n","name":"reverseFirstFew","className":"LinkedList","variables":{"iterator":3,"cnt":3,"howMany":4},"javaDoc":"","comments":" **************************************************************************************","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"ListIterator","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"// ***************************************************************\n// Method creates an iterator on the current LinkedList\n// ***************************************************************\npublic ListIterator listIterator() {\n    return new LinkedListIterator();\n}\n","name":"listIterator","className":"LinkedList","variables":{},"javaDoc":"","comments":" ***************************************************************","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"LinkedListIterator","methodCalls":{},"constants":{"null":2},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// of the linked list. of the linked list.\npublic LinkedListIterator() {\n    position = null;\n    previous = null;\n}\n","name":"LinkedListIterator","className":"LinkedListIterator","variables":{"previous":1,"position":1},"javaDoc":"","comments":" of the linked list. of the linked list.","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1},"constants":{"null":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Moves the iterator past the next element, and returns\n// the traversed element's data.\npublic Object next() {\n    if (!hasNext())\n        throw new NoSuchElementException();\n    // Remember for remove\n    previous = position;\n    if (position == null)\n        position = first;\n    else\n        position = position.next;\n    return position.data;\n}\n","name":"next","className":"LinkedListIterator","variables":{"previous":1,"position":4,"first":1},"javaDoc":"","comments":"Remember for remove  the traversed element's data.","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{"null":3},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["IfStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"// Tests if there is an element after the iterator position position\npublic boolean hasNext() {\n    if (position == null)\n        return first != null;\n    else\n        return position.next != null;\n}\n","name":"hasNext","className":"LinkedListIterator","variables":{"position":1,"first":1},"javaDoc":"","comments":" Tests if there is an element after the iterator position position","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"addFirst":1},"constants":{"null":1},"annotations":[],"types":{"Node":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Adds an element after the iterator position\n// and moves the iterator to the inserted element.\npublic void add(Object element) {\n    if (position == null) {\n        addFirst(element);\n        position = first;\n    } else {\n        Node newNode = new Node();\n        newNode.data = element;\n        newNode.next = position.next;\n        position.next = newNode;\n        position = newNode;\n    }\n    previous = position;\n}\n","name":"add","className":"LinkedListIterator","variables":{"previous":1,"newNode":3,"position":4,"first":1,"element":2},"javaDoc":"","comments":" and moves the iterator to the inserted element.","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeFirst":1},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Removes the last traversed element. This method may\n// only be called after a call to the next() method.\npublic void remove() {\n    if (previous == position)\n        throw new IllegalStateException();\n    if (position == first) {\n        removeFirst();\n    } else {\n        previous.next = position.next;\n    }\n    position = previous;\n}\n","name":"remove","className":"LinkedListIterator","variables":{"previous":2,"position":3,"first":1},"javaDoc":"","comments":" only be called after a call to the next() method.","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["IfStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Sets the last traversed element to a different value\npublic void set(Object element) {\n    if (position == null)\n        throw new NoSuchElementException();\n    position.data = element;\n}\n","name":"set","className":"LinkedListIterator","variables":{"position":1,"element":2},"javaDoc":"","comments":" Sets the last traversed element to a different value","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"IntListVer1","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic IntListVer1() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"IntListVer1","className":"IntListVer1","variables":{"DEFAULT_CAP":1},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"IntListVer1","methodCalls":{},"constants":{"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","ArrayCreationExpr","AssignExpr"],"statements":["AssertStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic IntListVer1(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new int[initialCap];\n    iSize = 0;\n}\n","name":"IntListVer1","className":"IntListVer1","variables":{"iValues":1,"iSize":1,"initialCap":4},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["boolean[][]"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"\"":1,"\".\"":1,"\"*\"":1,"\"\\n\"":1},"annotations":[],"types":{"boolean":1,"String":1,"boolean[]":1},"expressions":["VariableDeclarationExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void show(boolean[][] grid) {\n    String s = \"\";\n    for (boolean[] row : grid) {\n        for (boolean val : row) if (val)\n            s += \"*\";\n        else\n            s += \".\";\n        s += \"\\n\";\n    }\n    System.out.println(s);\n}\n","name":"show","className":"Life","variables":{"val":2,"grid":2,"row":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"boolean[][]","methodCalls":{"random":1},"constants":{"true":1,"0.7":1,"10":4},"annotations":[],"types":{"int":2,"boolean[][]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","ArrayCreationExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static boolean[][] gen() {\n    boolean[][] grid = new boolean[10][10];\n    for (int r = 0; r < 10; r++) for (int c = 0; c < 10; c++) if (Math.random() > 0.7)\n        grid[r][c] = true;\n    return grid;\n}\n","name":"gen","className":"Life","variables":{"grid":3,"Math":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"gen":1,"nextLine":1,"show":3,"length":1,"nextGen":2,"System.out.println":2},"constants":{},"annotations":[],"types":{"Scanner":1,"boolean[][]":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    boolean[][] world = gen();\n    show(world);\n    System.out.println();\n    world = nextGen(world);\n    show(world);\n    Scanner s = new Scanner(System.in);\n    while (s.nextLine().length() == 0) {\n        System.out.println();\n        world = nextGen(world);\n        show(world);\n    }\n}\n","name":"main","className":"Life","variables":{"args":1,"world":3},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["boolean[][]"],"returnType":"boolean[][]","methodCalls":{"numNeighbors":1,"occupiedNext":1},"constants":{"true":1},"annotations":[],"types":{"int":3,"boolean[][]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static boolean[][] nextGen(boolean[][] world) {\n    boolean[][] newWorld = new boolean[world.length][world[0].length];\n    int num;\n    for (int r = 0; r < world.length; r++) {\n        for (int c = 0; c < world[0].length; c++) {\n            num = numNeighbors(world, r, c);\n            if (occupiedNext(num, world[r][c]))\n                newWorld[r][c] = true;\n        }\n    }\n    return newWorld;\n}\n","name":"nextGen","className":"Life","variables":{"world":4,"newWorld":3,"num":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int","boolean"],"returnType":"boolean","methodCalls":{},"constants":{"true":2,"false":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","EnclosedExpr","UnaryExpr"],"statements":["IfStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"public static boolean occupiedNext(int numNeighbors, boolean occupied) {\n    if (occupied && (numNeighbors == 2 || numNeighbors == 3))\n        return true;\n    else if (!occupied && numNeighbors == 3)\n        return true;\n    else\n        return false;\n}\n","name":"occupiedNext","className":"Life","variables":{"numNeighbors":4,"occupied":3},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["boolean[][]","int","int"],"returnType":"int","methodCalls":{"inbounds":1},"constants":{},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","ConditionalExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private static int numNeighbors(boolean[][] world, int row, int col) {\n    int num = world[row][col] ? -1 : 0;\n    for (int r = row - 1; r <= row + 1; r++) for (int c = col - 1; c <= col + 1; c++) if (inbounds(world, r, c) && world[r][c])\n        num++;\n    return num;\n}\n","name":"numNeighbors","className":"Life","variables":{"col":4,"world":3,"num":3,"row":4},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["boolean[][]","int","int"],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"private static boolean inbounds(boolean[][] world, int r, int c) {\n    return r >= 0 && r < world.length && c >= 0 && c < world[0].length;\n}\n","name":"inbounds","className":"Life","variables":{"world":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"inBounds":1,"cellPicked":1},"constants":{"true":1},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"public void cellPicked(int row, int col) {\n    if (inBounds(row, col) && !myShow[row][col]) {\n        myShow[row][col] = true;\n        if (myTruth[row][col] == 0) {\n            for (int r = -1; r <= 1; r++) for (int c = -1; c <= 1; c++) cellPicked(row + r, col + c);\n        }\n    }\n}\n","name":"cellPicked","className":"MineSweeper","variables":{"col":5,"myShow":2,"myTruth":1,"row":5},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public boolean inBounds(int row, int col) {\n    return 0 <= row && row < myTruth.length && 0 <= col && col < myTruth[0].length;\n}\n","name":"inBounds","className":"MineSweeper","variables":{"col":3,"myTruth":1,"row":3},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"nanoTime":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t start the stop watch.\n\t*/\npublic void start() {\n    startTime = System.nanoTime();\n}\n","name":"start","className":"Stopwatch","variables":{"startTime":1,"System":1},"javaDoc":"start the stop watch","comments":"\n\t start the stop watch.\n\t","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"nanoTime":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t stop the stop watch.\n\t*/\npublic void stop() {\n    stopTime = System.nanoTime();\n}\n","name":"stop","className":"Stopwatch","variables":{"stopTime":1,"System":1},"javaDoc":"stop the stop watch","comments":"\n\t stop the stop watch.\n\t","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","EnclosedExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n\telapsed time in seconds.\n\t@return the time recorded on the stopwatch in seconds\n\t*/\npublic double time() {\n    return (stopTime - startTime) / NANOS_PER_SEC;\n}\n","name":"time","className":"Stopwatch","variables":{"NANOS_PER_SEC":1,"stopTime":1,"startTime":1},"javaDoc":"elapsed time in seconds the time recorded on the stopwatch in seconds","comments":"\n\telapsed time in seconds.\n\t@return the time recorded on the stopwatch in seconds\n\t","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"time":1},"constants":{"\" seconds.\"":1,"\"elapsed time: \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"elapsed time: \" + time() + \" seconds.\";\n}\n","name":"toString","className":"Stopwatch","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","EnclosedExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n\telapsed time in nanoseconds.\n\t@return the time recorded on the stopwatch in nanoseconds\n\t*/\npublic long timeInNanoseconds() {\n    return (stopTime - startTime);\n}\n","name":"timeInNanoseconds","className":"Stopwatch","variables":{"stopTime":1,"startTime":1},"javaDoc":"elapsed time in nanoseconds the time recorded on the stopwatch in nanoseconds","comments":"\n\telapsed time in nanoseconds.\n\t@return the time recorded on the stopwatch in nanoseconds\n\t","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Directory"],"returnType":"int","methodCalls":{"getSize":1,"getSubs":1,"getFiles":1},"constants":{},"annotations":[],"types":{"File[]":1,"Directory[]":1,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["ForStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"public int getSize(Directory dir) {\n    int total = 0;\n    //check files\n    File[] files = dir.getFiles();\n    for (int i = 0; i < files.length; i++) total += files[i].getSize();\n    //get sub directories and check them\n    Directory[] subs = dir.getSubs();\n    for (int i = 0; i < subs.length; i++) total += getSize(subs[i]);\n    return total;\n}\n","name":"getSize","className":"RecursionExampleDirectory","variables":{"total":4,"subs":2,"files":2,"dir":3},"javaDoc":"","comments":"check files get sub directories and check them ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getSize":1,"System.out.println":1},"constants":{},"annotations":[],"types":{"RecursionExampleDirectory":1,"Directory":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    RecursionExampleDirectory r = new RecursionExampleDirectory();\n    Directory d = new Directory();\n    System.out.println(r.getSize(d));\n}\n","name":"main","className":"RecursionExampleDirectory","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"fact":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"//pre: n >= 0\npublic static int fact(int n) {\n    int result = 0;\n    if (n == 0)\n        result = 1;\n    else\n        result = n * fact(n - 1);\n    return result;\n}\n","name":"fact","className":"RecursionExampleDirectory","variables":{"result":4},"javaDoc":"","comments":"pre: n >= 0","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"pow":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"//pre: exp >= 0\npublic static int pow(int base, int exp) {\n    int result = 0;\n    if (exp == 0)\n        result = 1;\n    else\n        result = base * pow(base, exp - 1);\n    return result;\n}\n","name":"pow","className":"RecursionExampleDirectory","variables":{"result":4,"exp":3,"base":2},"javaDoc":"","comments":"pre: exp >= 0","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"fib":2},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"//slow fib\n//pre: n >= 1\npublic static int fib(int n) {\n    int result = 0;\n    if (n == 1 || n == 2)\n        result = 1;\n    else\n        result = fib(n - 1) + fib(n - 2);\n    return result;\n}\n","name":"fib","className":"RecursionExampleDirectory","variables":{"result":4},"javaDoc":"","comments":"pre: n >= 1","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"int","methodCalls":{"minWasted":2,"min":1},"constants":{},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"public static int minWasted(int[] items, int itemNum, int capLeft) {\n    int result = 0;\n    if (itemNum >= items.length)\n        result = capLeft;\n    else if (capLeft == 0)\n        result = 0;\n    else {\n        int minWithout = minWasted(items, itemNum + 1, capLeft);\n        if (capLeft <= items[itemNum]) {\n            int minWith = minWasted(items, itemNum + 1, capLeft - items[itemNum]);\n            result = Math.min(minWith, minWithout);\n        } else\n            result = minWithout;\n    }\n    return result;\n}\n","name":"minWasted","className":"RecursionExampleDirectory","variables":{"result":6,"minWithout":2,"itemNum":6,"minWith":1,"capLeft":5,"Math":1,"items":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"Directory","methodCalls":{"random":3},"constants":{"1000":1,"10":1},"annotations":[],"types":{"int":4},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","CastExpr","FieldAccessExpr","EnclosedExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["ForStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public Directory() {\n    int numSubs = (int) (Math.random() * 3);\n    mySubs = new Directory[numSubs];\n    int numFiles = (int) (Math.random() * 10);\n    myFiles = new File[numFiles];\n    for (int i = 0; i < myFiles.length; i++) myFiles[i] = new File((int) (Math.random() * 1000));\n    for (int i = 0; i < mySubs.length; i++) mySubs[i] = new Directory();\n}\n","name":"Directory","className":"Directory","variables":{"numSubs":2,"myFiles":2,"numFiles":2,"Math":3,"mySubs":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"Directory[]","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public Directory[] getSubs() {\n    return mySubs;\n}\n","name":"getSubs","className":"Directory","variables":{"mySubs":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"File[]","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public File[] getFiles() {\n    return myFiles;\n}\n","name":"getFiles","className":"Directory","variables":{"myFiles":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"File","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public File(int size) {\n    iMySize = size;\n}\n","name":"File","className":"File","variables":{"size":2,"iMySize":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getSize() {\n    return iMySize;\n}\n","name":"getSize","className":"File","variables":{"iMySize":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"stop":2,"getPrimes":1,"start":2,"printTest":5,"isPrime":4,"System.out.println":6},"constants":{"\" expect true\"":2,"54161329":2,"\" expect false\"":1,"36":1,"1882341361":2,"\" \"":2,"1024":1,"10000000":2,"10":2},"annotations":[],"types":{"boolean":1,"Stopwatch":1,"boolean[]":1,"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * @param args\n\t */\npublic static void main(String[] args) {\n    printTest(10, 4);\n    printTest(2, 2);\n    printTest(54161329, 4);\n    printTest(1882341361, 2);\n    printTest(36, 9);\n    System.out.println(isPrime(54161329) + \" expect false\");\n    System.out.println(isPrime(1882341361) + \" expect true\");\n    System.out.println(isPrime(2) + \" expect true\");\n    int numPrimes = 0;\n    Stopwatch s = new Stopwatch();\n    s.start();\n    for (int i = 2; i < 10000000; i++) {\n        if (isPrime(i)) {\n            numPrimes++;\n        }\n    }\n    s.stop();\n    System.out.println(numPrimes + \" \" + s);\n    s.start();\n    boolean[] primes = getPrimes(10000000);\n    int np = 0;\n    for (boolean b : primes) if (b)\n        np++;\n    s.stop();\n    System.out.println(np + \" \" + s);\n    System.out.println(new BigInteger(1024, 10, new Random()));\n}\n","name":"main","className":"PrimeEx","variables":{"args":1,"primes":2,"np":3,"numPrimes":3},"javaDoc":"args","comments":"\n\t * @param args\n\t ","isEmpty":false,"lineCount":21,"modifier":9}
{"paramTypes":["int"],"returnType":"boolean[]","methodCalls":{"sqrt":1},"constants":{"true":1,"false":1},"annotations":[],"types":{"double":1,"boolean[]":1,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static boolean[] getPrimes(int max) {\n    boolean[] result = new boolean[max + 1];\n    for (int i = 2; i < result.length; i++) result[i] = true;\n    final double LIMIT = Math.sqrt(max);\n    for (int i = 2; i <= LIMIT; i++) {\n        if (result[i]) {\n            // cross out all multiples;\n            int index = 2 * i;\n            while (index < result.length) {\n                result[index] = false;\n                index += i;\n            }\n        }\n    }\n    return result;\n}\n","name":"getPrimes","className":"PrimeEx","variables":{"result":5,"max":2,"index":4,"LIMIT":2,"Math":1},"javaDoc":"","comments":"cross out all multiples; ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"stop":1,"numFactors":1,"start":1,"time":1,"System.out.println":4},"constants":{"\"actual \"":1,"\"Testing \"":1,"\" expect \"":1,"\", \"":1,"\"FAILED\"":1,"\"PASSED\"":1},"annotations":[],"types":{"Stopwatch":1,"int":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void printTest(int num, int expectedFactors) {\n    Stopwatch st = new Stopwatch();\n    st.start();\n    int actualFactors = numFactors(num);\n    st.stop();\n    System.out.println(\"Testing \" + num + \" expect \" + expectedFactors + \", \" + \"actual \" + actualFactors);\n    if (actualFactors == expectedFactors)\n        System.out.println(\"PASSED\");\n    else\n        System.out.println(\"FAILED\");\n    System.out.println(st.time());\n}\n","name":"printTest","className":"PrimeEx","variables":{"st":4,"num":2,"actualFactors":3,"expectedFactors":3},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["int"],"returnType":"boolean","methodCalls":{"sqrt":1},"constants":{"true":1,"\"failed precondition. num must be >= 2. num: \"":1},"annotations":[],"types":{"boolean":1,"double":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","ConditionalExpr","EnclosedExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","AssertStmt","ReturnStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"// pre: num >= 2\npublic static boolean isPrime(int num) {\n    assert num >= 2 : \"failed precondition. num must be >= 2. num: \" + num;\n    final double LIMIT = Math.sqrt(num);\n    boolean isPrime = (num == 2) ? true : num % 2 != 0;\n    int div = 3;\n    while (div <= LIMIT && isPrime) {\n        isPrime = num % div != 0;\n        div += 2;\n    }\n    return isPrime;\n}\n","name":"isPrime","className":"PrimeEx","variables":{"div":4,"num":6,"LIMIT":2,"Math":1,"isPrime":4},"javaDoc":"","comments":" pre: num >= 2","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"sqrt":1},"constants":{"\"failed precondition. num must be >= 2. num: \"":1},"annotations":[],"types":{"double":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","AssertStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"// pre: num >= 2\npublic static int numFactors(int num) {\n    assert num >= 2 : \"failed precondition. num must be >= 2. num: \" + num;\n    int result = 0;\n    final double SQRT = Math.sqrt(num);\n    for (int i = 1; i < SQRT; i++) {\n        if (num % i == 0) {\n            result += 2;\n        }\n    }\n    if (num % SQRT == 0)\n        result++;\n    return result;\n}\n","name":"numFactors","className":"PrimeEx","variables":{"result":4,"SQRT":3,"num":5,"Math":1},"javaDoc":"","comments":" pre: num >= 2","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createFreqTableURL":1,"createTable":1,"sum":2,"System.out.println":8},"constants":{"\"Problem while reading from file. Unable to create freq table\"":1,"\" ,frequency: \"":2,"\"File not found. Unable to create freq table\"":1,"\"No frequency table created due to problems when reading from file\"":2,"\"ciaFactBook2008.txt\"":1,"\"http://www.utexas.edu/\"":1,"\"charcater code: \"":2,"\"Total characters in file: \"":2,"\" ,character: \"":2},"annotations":[],"types":{"int[]":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","AssignExpr","ArrayInitializerExpr","CastExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["FileNotFoundException","IOException"],"text":"// program to create a frequency table.\n// Example of simple try catch blocks to deal with checked exceptions\npublic static void main(String[] args) {\n    int[] freqs = createFreqTableURL(\"http://www.utexas.edu/\");\n    if (freqs.length == 0)\n        System.out.println(\"No frequency table created due to problems when reading from file\");\n    else {\n        for (int i = 0; i < NUM_ASCII_CHAR; i++) {\n            System.out.println(\"charcater code: \" + i + \" ,character: \" + (char) i + \" ,frequency: \" + freqs[i]);\n        }\n        System.out.println(\"Total characters in file: \" + sum(freqs));\n    }\n    freqs = new int[] {};\n    try {\n        freqs = createTable(\"ciaFactBook2008.txt\");\n    } catch (FileNotFoundException e) {\n        System.out.println(\"File not found. Unable to create freq table\" + e);\n    } catch (IOException e) {\n        System.out.println(\"Problem while reading from file. Unable to create freq table\" + e);\n    }\n    if (freqs.length == 0)\n        System.out.println(\"No frequency table created due to problems when reading from file\");\n    else {\n        for (int i = 0; i < freqs.length; i++) {\n            System.out.println(\"charcater code: \" + i + \" ,character: \" + (char) i + \" ,frequency: \" + freqs[i]);\n        }\n        System.out.println(\"Total characters in file: \" + sum(freqs));\n    }\n}\n","name":"main","className":"FreqTableExampleOriginal","variables":{"args":1,"NUM_ASCII_CHAR":1,"freqs":5},"javaDoc":"","comments":" Example of simple try catch blocks to deal with checked exceptions","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"constants":{"\" may not be null.\"":1,"null":1,"\"Failed precondition, sum: parameter list\"":1},"annotations":[],"types":{"int":2},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["BlockStmt","AssertStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// return sum of ints in list\n// list may not be null\nprivate static int sum(int[] list) {\n    assert list != null : \"Failed precondition, sum: parameter list\" + \" may not be null.\";\n    int total = 0;\n    for (int x : list) {\n        total += x;\n    }\n    return total;\n}\n","name":"sum","className":"FreqTableExampleOriginal","variables":{"total":3,"list":3},"javaDoc":"","comments":" list may not be null","isEmpty":false,"lineCount":4,"modifier":10}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"read":1,"ready":1,"openStream":1,"close":1,"System.out.println":3},"constants":{"\"Bad URL.\"":1,"\"Non ASCII char: \"":1,"null":1,"\" \"":1,"\"Violation of precondition. parameter url must not be null.\"":1,"\"Unable to read from resource.\"":1},"annotations":[],"types":{"InputStreamReader":1,"int[]":1,"URL":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","AssignExpr","NullLiteralExpr","CastExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","TryStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["MalformedURLException","IOException"],"text":"// pre: url != null\n// Connect to the URL specified by the String url.\n// Map characters to index in array.\n// All non ASCII character dumped into one element of array\n// If IOException occurs message printed and array of\n// length 0 returned.\npublic static int[] createFreqTableURL(String url) {\n    if (url == null)\n        throw new IllegalArgumentException(\"Violation of precondition. parameter url must not be null.\");\n    int[] freqs = new int[NUM_ASCII_CHAR];\n    try {\n        URL inputURL = new URL(url);\n        InputStreamReader in = new InputStreamReader(inputURL.openStream());\n        while (in.ready()) {\n            int c = in.read();\n            if (0 <= c && c < freqs.length)\n                freqs[c]++;\n            else\n                System.out.println(\"Non ASCII char: \" + c + \" \" + (char) c);\n        }\n        in.close();\n    } catch (MalformedURLException e) {\n        System.out.println(\"Bad URL.\");\n        freqs = new int[0];\n    } catch (IOException e) {\n        System.out.println(\"Unable to read from resource.\" + e);\n        freqs = new int[0];\n    }\n    return freqs;\n}\n","name":"createFreqTableURL","className":"FreqTableExampleOriginal","variables":{"NUM_ASCII_CHAR":1,"in":4,"freqs":5,"inputURL":2,"url":3},"javaDoc":"","comments":" length 0 returned.","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"read":1,"ready":1,"close":1,"System.out.println":1},"constants":{},"annotations":[],"types":{"int[]":1,"FileReader":1,"File":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","CastExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["FileNotFoundException","IOException"],"text":"// Connect to the file specified by the String fileName.\n// Assumes it is in same directory as compiled code.\n// Map characters to index in array.\npublic static int[] createTable(String fileName) throws FileNotFoundException, IOException {\n    int[] freqs = new int[NUM_ASCII_CHAR];\n    File f = new File(fileName);\n    FileReader r = new FileReader(f);\n    while (r.ready()) {\n        int ch = r.read();\n        //                freqs[INDEX_NON_ASCII]++;\n        if (0 <= ch && ch < freqs.length)\n            freqs[ch]++;\n        else\n            System.out.println((char) ch);\n    }\n    r.close();\n    return freqs;\n}\n","name":"createTable","className":"FreqTableExampleOriginal","variables":{"fileName":2,"NUM_ASCII_CHAR":1,"ch":5,"freqs":3},"javaDoc":"","comments":"if( 0 <= ch && ch <= NUM_ASCII_CHAR) freqs[ch]++; else freqs[INDEX_NON_ASCII]++;  Map characters to index in array.","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["int"],"returnType":"SortedIntList","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"public SortedIntList(int initialCap) {\n    //call IntList constructor\n    super(initialCap);\n}\n","name":"SortedIntList","className":"SortedIntList","variables":{"initialCap":2},"javaDoc":"","comments":"call IntList constructor ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"SortedIntList","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"public SortedIntList() {\n    super();\n}\n","name":"SortedIntList","className":"SortedIntList","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"size":1,"get":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","SuperExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//override add\npublic void add(int value) {\n    //search for location to insert value\n    int pos = 0;\n    while (pos < size() && value > get(pos)) {\n        pos++;\n    }\n    super.insert(pos, value);\n}\n","name":"add","className":"SortedIntList","variables":{"pos":3,"value":2},"javaDoc":"","comments":"search for location to insert value override add","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"size":1,"containsKey":1,"get":2,"hasNext":1,"keySet":1,"put":2,"System.out.println":3},"constants":{"\" \"":1,"\"Unable to read from file.\"":1,"\"ciaFactBook2008.txt\"":1},"annotations":[],"types":{"Scanner":1,"Map<String, Integer>":1,"String":2,"TreeMap":1,"File":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","TryStmt","BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["IOException"],"text":"public static void main(String[] args) {\n    try {\n        File f = new File(\"ciaFactBook2008.txt\");\n        Scanner sc;\n        sc = new Scanner(f);\n        // sc.useDelimiter(\"[^a-zA-Z']+\");\n        Map<String, Integer> wordCount = new TreeMap<String, Integer>();\n        while (sc.hasNext()) {\n            String word = sc.next();\n            if (!wordCount.containsKey(word))\n                wordCount.put(word, 1);\n            else\n                wordCount.put(word, wordCount.get(word) + 1);\n        }\n        // show results\n        for (String word : wordCount.keySet()) System.out.println(word + \" \" + wordCount.get(word));\n        System.out.println(wordCount.size());\n    } catch (IOException e) {\n        System.out.println(\"Unable to read from file.\");\n    }\n}\n","name":"main","className":"SimpleWordCounter","variables":{"args":1,"sc":4,"wordCount":8,"word":3},"javaDoc":"","comments":"sc useDelimiter(\"[^a-zA-Z']+\"); show results ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"printStackTrace":1,"openConnection":1,"hasNext":1,"getInputStream":1,"close":1,"System.out.println":2},"constants":{"\"http://www.cs.utexas.edu/~scottm\"":1,"\"Number of tokens: \"":1},"annotations":[],"types":{"Scanner":1,"URL":1,"URLConnection":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"public static void main(String[] args) {\n    try {\n        URL mySite = new URL(\"http://www.cs.utexas.edu/~scottm\");\n        URLConnection yc = mySite.openConnection();\n        Scanner in = new Scanner(new InputStreamReader(yc.getInputStream()));\n        int count = 0;\n        while (in.hasNext()) {\n            System.out.println(in.next());\n            count++;\n        }\n        System.out.println(\"Number of tokens: \" + count);\n        in.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"main","className":"URLExpSimple","variables":{"args":1,"mySite":2,"in":4,"count":3,"yc":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"DemoClass","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public DemoClass() {\n    // assign default value\n    x = 0;\n}\n","name":"DemoClass","className":"DemoClass","variables":{},"javaDoc":"","comments":"assign default value ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"DemoClass","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public DemoClass(int x) {\n    // use this.x to refer to the instance variable x\n    // use x to refer to a local variable x (more specifically,\n    // method parameter x)\n    this.x = x;\n}\n","name":"DemoClass","className":"DemoClass","variables":{},"javaDoc":"","comments":"use this x to refer to the instance variable x use x to refer to a local variable x (more specifically method parameter x) ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["DemoClass"],"returnType":"DemoClass","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public DemoClass(DemoClass otherDemo) {\n    // copy the value from the otherDemo\n    this.x = otherDemo.x;\n}\n","name":"DemoClass","className":"DemoClass","variables":{"otherDemo":1},"javaDoc":"","comments":"copy the value from the otherDemo ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"// static method (aka class method)\npublic static void s1() {\n    return;\n}\n","name":"s1","className":"DemoClass","variables":{},"javaDoc":"","comments":" static method (aka class method)","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"// instance method\npublic void i1() {\n    return;\n}\n","name":"i1","className":"DemoClass","variables":{},"javaDoc":"","comments":" instance method","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"s1":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// static calling static OK\n// static calling instance is a compile-time error\npublic static void s2() {\n    //        i1();     // compile-time error\n    // DemoClass.s1\n    s1();\n    return;\n}\n","name":"s2","className":"DemoClass","variables":{},"javaDoc":"","comments":"i1(); // compile-time error DemoClass s1  static calling instance is a compile-time error","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"i1":1,"s1":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// instance calling static OK\n// instance calling instance OK\npublic void i2() {\n    // DemoClass.s1();\n    s1();\n    // this.i1();\n    i1();\n    return;\n}\n","name":"i2","className":"DemoClass","variables":{},"javaDoc":"","comments":"DemoClass s1(); this i1();  instance calling instance OK","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"overload":8,"System.out.println":1},"constants":{"1.0":1,"\"overloadTester:\\n\"":1,"1.0f":1,"true":1,"1L":1,"'1'":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","DoubleLiteralExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","CastExpr","LongLiteralExpr","FieldAccessExpr","CharLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// call various versions of overload() based on their \n// list of parameters (aka function signatures)\npublic void overloadTester() {\n    System.out.println(\"overloadTester:\\n\");\n    overload((byte) 1);\n    overload((short) 1);\n    overload(1);\n    overload(1L);\n    overload(1.0f);\n    overload(1.0);\n    overload('1');\n    overload(true);\n}\n","name":"overloadTester","className":"DemoClass","variables":{},"javaDoc":"","comments":" list of parameters (aka function signatures)","isEmpty":false,"lineCount":9,"modifier":1}
{"paramTypes":["byte"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"byte\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void overload(byte b) {\n    System.out.println(\"byte\");\n}\n","name":"overload","className":"DemoClass","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["short"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"short\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void overload(short s) {\n    System.out.println(\"short\");\n}\n","name":"overload","className":"DemoClass","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"int\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void overload(int i) {\n    System.out.println(\"int\");\n}\n","name":"overload","className":"DemoClass","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["long"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"long\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void overload(long l) {\n    System.out.println(\"long\");\n}\n","name":"overload","className":"DemoClass","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"float\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void overload(float f) {\n    System.out.println(\"float\");\n}\n","name":"overload","className":"DemoClass","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"double\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void overload(double d) {\n    System.out.println(\"double\");\n}\n","name":"overload","className":"DemoClass","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["char"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"char\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void overload(char c) {\n    System.out.println(\"char\");\n}\n","name":"overload","className":"DemoClass","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\"boolean\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void overload(boolean b) {\n    System.out.println(\"boolean\");\n}\n","name":"overload","className":"DemoClass","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"overloadTester":1},"constants":{},"annotations":[],"types":{"DemoClass":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    DemoClass dc = new DemoClass();\n    dc.overloadTester();\n}\n","name":"main","className":"DemoClass","variables":{"args":1,"dc":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toBinaryString":1,"toBinary":1,"System.out.println":3},"constants":{"33":1,"\": \"":2},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    for (int i = -5; i < 33; i++) {\n        System.out.println(i + \": \" + toBinary(i));\n        System.out.println(i);\n        //always another way\n        System.out.println(i + \": \" + Integer.toBinaryString(i));\n    }\n}\n","name":"main","className":"BinaryConverter","variables":{"args":1,"Integer":1},"javaDoc":"","comments":"always another way ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["int"],"returnType":"String","methodCalls":{"abs":1,"all0sAnd1s":1},"constants":{"\"\"":1,"\"-\"":1,"\"value is not <= 1: \"":1},"annotations":[],"types":{"boolean":1,"String":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","EnclosedExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","AssertStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/*\n     * pre: none\n     * post: returns a String with base10Num in base 2\n     */\npublic static String toBinary(int base10Num) {\n    boolean isNeg = base10Num < 0;\n    base10Num = Math.abs(base10Num);\n    String result = \"\";\n    while (base10Num > 1) {\n        result = (base10Num % 2) + result;\n        base10Num /= 2;\n    }\n    assert base10Num == 0 || base10Num == 1 : \"value is not <= 1: \" + base10Num;\n    result = base10Num + result;\n    assert all0sAnd1s(result);\n    if (isNeg)\n        result = \"-\" + result;\n    return result;\n}\n","name":"toBinary","className":"BinaryConverter","variables":{"result":8,"base10Num":10,"isNeg":2,"Math":1},"javaDoc":"","comments":"\n     * pre: none\n     * post: returns a String with base10Num in base 2\n     ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"length":1,"charAt":1},"constants":{"null":1,"\"Failed precondition all0sAnd1s. parameter cannot be null\"":1,"true":1,"'1'":1,"'0'":1},"annotations":[],"types":{"boolean":1,"char":1,"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","CharLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","AssertStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/*\n     * pre: cal != null\n     * post: return true if val consists only of characters 1 and 0, false otherwise\n     */\npublic static boolean all0sAnd1s(String val) {\n    assert val != null : \"Failed precondition all0sAnd1s. parameter cannot be null\";\n    boolean all = true;\n    int i = 0;\n    char c;\n    while (all && i < val.length()) {\n        c = val.charAt(i);\n        all = c == '0' || c == '1';\n        i++;\n    }\n    return all;\n}\n","name":"all0sAnd1s","className":"BinaryConverter","variables":{"val":4,"all":4},"javaDoc":"","comments":"\n     * pre: cal != null\n     * post: return true if val consists only of characters 1 and 0, false otherwise\n     ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"factorial":1,"System.out.println":1},"constants":{"100":1,"\"! is \"":1},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    final int NUM_FACTS = 100;\n    for (int i = 0; i < NUM_FACTS; i++) System.out.println(i + \"! is \" + factorial(i));\n}\n","name":"main","className":"Factorial","variables":{"args":1,"NUM_FACTS":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static int factorial(int n) {\n    int result = 1;\n    for (int i = 2; i <= n; i++) result *= i;\n    return result;\n}\n","name":"factorial","className":"Factorial","variables":{"result":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"bubblesort":4,"showList":4,"findAndPrintPairs":1},"constants":{"11":2,"10":2},"annotations":[],"types":{"int[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","NameExpr","ArrayCreationExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] list = { 1, 2, 3, 4, 1, 2, 3 };\n    findAndPrintPairs(list, 5);\n    bubblesort(list);\n    showList(list);\n    list = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };\n    bubblesort(list);\n    showList(list);\n    list = new int[] { 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2 };\n    bubblesort(list);\n    showList(list);\n    list = new int[] { 1 };\n    bubblesort(list);\n    showList(list);\n}\n","name":"main","className":"ArrayExamples","variables":{"args":1,"list":4},"javaDoc":"","isEmpty":false,"lineCount":13,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"constants":{"null":1,"\"failed precondition\"":1},"annotations":[],"types":{"int":2},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","AssertStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// pre: list != null, list.length > 0\n// post: return index of minimum element of array\npublic static int findMin(int[] list) {\n    assert list != null && list.length > 0 : \"failed precondition\";\n    int indexOfMin = 0;\n    for (int i = 1; i < list.length; i++) {\n        if (list[i] < list[indexOfMin]) {\n            indexOfMin = i;\n        }\n    }\n    return indexOfMin;\n}\n","name":"findMin","className":"ArrayExamples","variables":{"indexOfMin":4,"list":4},"javaDoc":"","comments":" post: return index of minimum element of array","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"void","methodCalls":{"min":1},"constants":{"null":1,"\"failed precondition\"":1},"annotations":[],"types":{"int[]":1,"int":2},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","AssertStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/*\n\t *pre: list != null, newSize >= 0\n\t *post: nothing. the method does not succeed it resizing the\n\t * argument\n\t */\npublic static void badResize(int[] list, int newSize) {\n    assert list != null && newSize >= 0 : \"failed precondition\";\n    int[] temp = new int[newSize];\n    int limit = Math.min(list.length, newSize);\n    for (int i = 0; i < limit; i++) {\n        temp[i] = list[i];\n    }\n    // uh oh!! Changing pointer, not pointee. This breaks the\n    // relationship between the parameter and argument\n    list = temp;\n}\n","name":"badResize","className":"ArrayExamples","variables":{"temp":3,"limit":2,"newSize":3,"list":4,"Math":1},"javaDoc":"","comments":"uh oh!! Changing pointer not pointee This breaks the relationship between the parameter and argument \n\t *pre: list != null, newSize >= 0\n\t *post: nothing. the method does not succeed it resizing the\n\t * argument\n\t ","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int[]","methodCalls":{"min":1},"constants":{"null":1,"\"failed precondition\"":1},"annotations":[],"types":{"int[]":1,"int":2},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","AssertStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/*\n\t *pre: list != null, newSize >= 0\n\t *post: returns an array of size newSize. Elements from 0 to newSize - 1\n\t *\twill be copied into the new array\n\t */\npublic static int[] goodResize(int[] list, int newSize) {\n    assert list != null && newSize >= 0 : \"failed precondition\";\n    int[] result = new int[newSize];\n    int limit = Math.min(list.length, newSize);\n    for (int i = 0; i < limit; i++) {\n        result[i] = list[i];\n    }\n    return result;\n}\n","name":"goodResize","className":"ArrayExamples","variables":{"result":3,"limit":2,"newSize":3,"list":3,"Math":1},"javaDoc":"","comments":"\n\t *pre: list != null, newSize >= 0\n\t *post: returns an array of size newSize. Elements from 0 to newSize - 1\n\t *\twill be copied into the new array\n\t ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{"\" add up to \"":1,"\"The two elements at indices \"":1,"\" and \"":2,"\" are \"":1,"null":1,"\"failed precondition\"":1},"annotations":[],"types":{"int":2},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","AssertStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/*\n\t *pre: list != null\n\t *post: prints out the indices and values of all pairs of numbers\n\t *in list such that list[a] + list[b] = target\n\t */\npublic static void findAndPrintPairs(int[] list, int target) {\n    assert list != null : \"failed precondition\";\n    for (int i = 0; i < list.length; i++) {\n        for (int j = i + 1; j < list.length; j++) {\n            if (list[i] + list[j] == target) {\n                System.out.println(\"The two elements at indices \" + i + \" and \" + j + \" are \" + list[i] + \" and \" + list[j] + \" add up to \" + target);\n            }\n        }\n    }\n}\n","name":"findAndPrintPairs","className":"ArrayExamples","variables":{"list":6,"target":3},"javaDoc":"","comments":"\n\t *pre: list != null\n\t *post: prints out the indices and values of all pairs of numbers\n\t *in list such that list[a] + list[b] = target\n\t ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"isAscending":1},"constants":{"null":1,"\"is out of bounds.\"":1,"true":2,"false":1,"\"failed precondition\"":1,"\"loop counter j \"":1},"annotations":[],"types":{"boolean":1,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","AssignExpr","NullLiteralExpr","BooleanLiteralExpr","FieldAccessExpr","EnclosedExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","AssertStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/*\n\t *pre: list != null;\n\t *post: sort the elements of list so that they are in ascending order\n\t */\npublic static void bubblesort(int[] list) {\n    assert list != null : \"failed precondition\";\n    int temp;\n    boolean changed = true;\n    for (int i = 0; i < list.length && changed; i++) {\n        changed = false;\n        for (int j = 0; j < list.length - i - 1; j++) {\n            assert (j > 0) && (j + 1 < list.length) : \"loop counter j \" + j + \"is out of bounds.\";\n            if (list[j] > list[j + 1]) {\n                changed = true;\n                temp = list[j + 1];\n                list[j + 1] = list[j];\n                list[j] = temp;\n            }\n        }\n    }\n    assert isAscending(list);\n}\n","name":"bubblesort","className":"ArrayExamples","variables":{"temp":3,"list":8,"changed":4},"javaDoc":"","comments":"\n\t *pre: list != null;\n\t *post: sort the elements of list so that they are in ascending order\n\t ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"constants":{"\" \"":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void showList(int[] list) {\n    for (int i = 0; i < list.length; i++) System.out.print(list[i] + \" \");\n    System.out.println();\n}\n","name":"showList","className":"ArrayExamples","variables":{"list":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["int[]"],"returnType":"boolean","methodCalls":{},"constants":{"true":1},"annotations":[],"types":{"boolean":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","EnclosedExpr","UnaryExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","AssertStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/* \tpre: list != null\n\t\tpost: return true if list is sorted in ascedning order, false otherwise\n\t*/\npublic static boolean isAscending(int[] list) {\n    boolean ascending = true;\n    int index = 1;\n    while (ascending && index < list.length) {\n        assert index >= 0 && index < list.length;\n        ascending = (list[index - 1] <= list[index]);\n        index++;\n    }\n    return ascending;\n}\n","name":"isAscending","className":"ArrayExamples","variables":{"index":7,"list":3,"ascending":4},"javaDoc":"","comments":" \tpre: list != null\n\t\tpost: return true if list is sorted in ascedning order, false otherwise\n\t","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addOne":1,"printList":3,"addOneError":1,"sumListEnhanced":1,"System.out.println":6},"constants":{"\"Calling addOneError\"":1,"\"Sum of elements in list: \"":1,"\"Original List\"":1,"\"List after call to addOneError. Note elements of list did not change.\"":1,"\"List after call to addOne\"":1,"10":1,"\"Calling addOne\"":1},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] list = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int sum = sumListEnhanced(list);\n    System.out.println(\"Sum of elements in list: \" + sum);\n    System.out.println(\"Original List\");\n    printList(list);\n    System.out.println(\"Calling addOne\");\n    addOne(list);\n    System.out.println(\"List after call to addOne\");\n    printList(list);\n    System.out.println(\"Calling addOneError\");\n    addOneError(list);\n    System.out.println(\"List after call to addOneError. Note elements of list did not change.\");\n    printList(list);\n}\n","name":"main","className":"EnhancedFor","variables":{"args":1,"sum":2,"list":1},"javaDoc":"","isEmpty":false,"lineCount":13,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","AssignExpr"],"statements":["BlockStmt","ForeachStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// pre: list != null\n// post: return sum of elements\n// uses enhanced for loop\npublic static int sumListEnhanced(int[] list) {\n    int total = 0;\n    for (int val : list) {\n        total += val;\n    }\n    return total;\n}\n","name":"sumListEnhanced","className":"EnhancedFor","variables":{"val":2,"total":3,"list":2},"javaDoc":"","comments":" uses enhanced for loop","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{"System.out.println":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// pre: list != null\n// post: return sum of elements\n// use traditional for loop\npublic static int sumListOld(int[] list) {\n    int total = 0;\n    for (int i = 0; i < list.length; i++) {\n        total += list[i];\n        System.out.println(list[i]);\n    }\n    return total;\n}\n","name":"sumListOld","className":"EnhancedFor","variables":{"total":3,"list":3},"javaDoc":"","comments":" use traditional for loop","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","AssignExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// pre: list != null\n// post: none.\n// The code appears to add one to every element in the list, but does not\npublic static void addOneError(int[] list) {\n    for (int val : list) {\n        val = val + 1;\n    }\n}\n","name":"addOneError","className":"EnhancedFor","variables":{"val":3,"list":2},"javaDoc":"","comments":" The code appears to add one to every element in the list, but does not","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// pre: list != null\n// post: adds one to every element of list\npublic static void addOne(int[] list) {\n    for (int i = 0; i < list.length; i++) {\n        list[i]++;\n    }\n}\n","name":"addOne","className":"EnhancedFor","variables":{"list":2},"javaDoc":"","comments":" post: adds one to every element of list","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"System.out.println":2},"constants":{"\", \"":1,"\"index, value\"":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void printList(int[] list) {\n    System.out.println(\"index, value\");\n    for (int i = 0; i < list.length; i++) {\n        System.out.println(i + \", \" + list[i]);\n    }\n}\n","name":"printList","className":"EnhancedFor","variables":{"list":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"UnsortedHashSet","methodCalls":{},"constants":{"10":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","CastExpr","EnclosedExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public UnsortedHashSet() {\n    con = (LinkedList<E>[]) (new LinkedList[10]);\n}\n","name":"UnsortedHashSet","className":"UnsortedHashSet","variables":{"con":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{"abs":1,"hashCode":1,"resize":1},"constants":{"1.0":1,"null":1},"annotations":[],"types":{"int":2},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","DoubleLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public boolean add(E obj) {\n    int oldSize = size;\n    int index = Math.abs(obj.hashCode()) % con.length;\n    if (con[index] == null)\n        con[index] = new LinkedList<E>();\n    if (!con[index].contains(obj)) {\n        con[index].add(obj);\n        size++;\n    }\n    if (1.0 * size / con.length > LOAD_FACTOR_LIMIT)\n        resize();\n    return oldSize != size;\n}\n","name":"add","className":"UnsortedHashSet","variables":{"con":4,"size":4,"obj":2,"index":5,"Math":1,"oldSize":2,"LOAD_FACTOR_LIMIT":1},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1},"constants":{"null":1},"annotations":[],"types":{"UnsortedHashSet<E>":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","NullLiteralExpr","CastExpr","FieldAccessExpr","EnclosedExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForeachStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void resize() {\n    UnsortedHashSet<E> temp = new UnsortedHashSet<E>();\n    temp.con = (LinkedList<E>[]) (new LinkedList[con.length * 2 + 1]);\n    for (int i = 0; i < con.length; i++) {\n        if (con[i] != null)\n            for (E e : con[i]) temp.add(e);\n    }\n    con = temp.con;\n}\n","name":"resize","className":"UnsortedHashSet","variables":{"temp":2,"con":3},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int size() {\n    return size;\n}\n","name":"size","className":"UnsortedHashSet","variables":{"size":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t * Add an item to the end of this list.\n\t * <br>pre: none\n\t * <br>post: size() = old size() + 1, get(size() - 1) = item\n\t * @param item the data to be added to the end of this list\n\t */\nvoid add(E item);\n","name":"add","className":"IList","variables":{"item":1},"javaDoc":"Add an item to the end of this list <br>pre: none <br>post: size() = old size() + 1 get(size() - 1) = item item the data to be added to the end of this list","comments":"\n\t * Add an item to the end of this list.\n\t * <br>pre: none\n\t * <br>post: size() = old size() + 1, get(size() - 1) = item\n\t * @param item the data to be added to the end of this list\n\t ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["int","E"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t * Insert an item at a specified position in the list.\n\t * <br>pre: 0 <= pos <= size()\n\t * <br>post: size() = old size() + 1, get(pos) = item, all elements in\n\t * the list with a positon >= pos have a position = old position + 1\n\t * @param pos the position to insert the data at in the list\n\t * @param item the data to add to the list\n\t*/\nvoid insert(int pos, E item);\n","name":"insert","className":"IList","variables":{"item":1,"pos":1},"javaDoc":"Insert an item at a specified position in the list <br>pre: 0 <= pos <= size() <br>post: size() = old size() + 1 get(pos) = item all elements in the list with a positon >= pos have a position = old position + 1 pos the position to insert the data at in the list item the data to add to the list","comments":"\n\t * Insert an item at a specified position in the list.\n\t * <br>pre: 0 <= pos <= size()\n\t * <br>post: size() = old size() + 1, get(pos) = item, all elements in\n\t * the list with a positon >= pos have a position = old position + 1\n\t * @param pos the position to insert the data at in the list\n\t * @param item the data to add to the list\n\t","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["int","E"],"returnType":"E","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t * Change the data at the specified position in the list.\n\t * the old data at that position is returned.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: get(pos) = item, return the\n\t * old get(pos)\n     * @param pos the position in the list to overwrite\t \n\t * @param item the new item that will overwrite the old item\n\t * @return the old data at the specified position\n\t */\nE set(int pos, E item);\n","name":"set","className":"IList","variables":{"item":1,"pos":1},"javaDoc":"Change the data at the specified position in the list the old data at that position is returned <br>pre: 0 <= pos < size() <br>post: get(pos) = item return the old get(pos) pos the position in the list to overwrite item the new item that will overwrite the old item the old data at the specified position","comments":"\n\t * Change the data at the specified position in the list.\n\t * the old data at that position is returned.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: get(pos) = item, return the\n\t * old get(pos)\n     * @param pos the position in the list to overwrite\t \n\t * @param item the new item that will overwrite the old item\n\t * @return the old data at the specified position\n\t ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["int"],"returnType":"E","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t * Get an element from the list.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the item at pos\n\t * @param pos specifies which element to get\n\t * @return the element at the specified position in the list\n\t */\nE get(int pos);\n","name":"get","className":"IList","variables":{"pos":1},"javaDoc":"Get an element from the list <br>pre: 0 <= pos < size() <br>post: return the item at pos pos specifies which element to get the element at the specified position in the list","comments":"\n\t * Get an element from the list.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the item at pos\n\t * @param pos specifies which element to get\n\t * @return the element at the specified position in the list\n\t ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["int"],"returnType":"E","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t * Remove an element in the list based on position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: size() = old size() - 1, all elements of\n\t * list with a positon > pos have a position = old position - 1\n\t * @param pos the position of the element to remove from the list\n\t * @return the data at position pos\n\t */\nE remove(int pos);\n","name":"remove","className":"IList","variables":{"pos":1},"javaDoc":"Remove an element in the list based on position <br>pre: 0 <= pos < size() <br>post: size() = old size() - 1 all elements of list with a positon > pos have a position = old position - 1 pos the position of the element to remove from the list the data at position pos","comments":"\n\t * Remove an element in the list based on position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: size() = old size() - 1, all elements of\n\t * list with a positon > pos have a position = old position - 1\n\t * @param pos the position of the element to remove from the list\n\t * @return the data at position pos\n\t ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t * Remove the first occurrence of obj in this list.\n\t * Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t * <br>pre: none\n\t * <br>post: if obj is in this list the first occurence has been removed and size() = old size() - 1. \n\t * If obj is not present the list is not altered in any way.\n\t * @param obj The item to remove from this list.\n\t * @return Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t */\nboolean remove(E obj);\n","name":"remove","className":"IList","variables":{"obj":1},"javaDoc":"Remove the first occurrence of obj in this list Return <tt>true</tt> if this list changed as a result of this call <tt>false</tt> otherwise <br>pre: none <br>post: if obj is in this list the first occurence has been removed and size() = old size() - 1 If obj is not present the list is not altered in any way obj The item to remove from this list Return <tt>true</tt> if this list changed as a result of this call <tt>false</tt> otherwise","comments":"\n\t * Remove the first occurrence of obj in this list.\n\t * Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t * <br>pre: none\n\t * <br>post: if obj is in this list the first occurence has been removed and size() = old size() - 1. \n\t * If obj is not present the list is not altered in any way.\n\t * @param obj The item to remove from this list.\n\t * @return Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["int","int"],"returnType":"IList<E>","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t * Return a sublist of elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n\t * This list is not changed as a result of this call.\n\t * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n\t * <br>post: return a list whose size is stop - start and contains the elements at positions start through stop - 1 in this list.\n\t * @param start index of the first element of the sublist.\n\t * @param stop stop - 1 is the index of the last element of the sublist.\n\t * @return a list with <tt>stop - start</tt> elements, The elements are from positions <tt>start</tt> inclusive to\n\t * <tt>stop</tt> exclusive in this list.\n\t */\nIList<E> getSubList(int start, int stop);\n","name":"getSubList","className":"IList","variables":{"stop":1,"start":1},"javaDoc":"Return a sublist of elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive This list is not changed as a result of this call <br>pre: <tt>0 <= start < size() start <= stop <= size()</tt> <br>post: return a list whose size is stop - start and contains the elements at positions start through stop - 1 in this list start index of the first element of the sublist stop stop - 1 is the index of the last element of the sublist a list with <tt>stop - start</tt> elements The elements are from positions <tt>start</tt> inclusive to <tt>stop</tt> exclusive in this list","comments":"\n\t * Return a sublist of elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n\t * This list is not changed as a result of this call.\n\t * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n\t * <br>post: return a list whose size is stop - start and contains the elements at positions start through stop - 1 in this list.\n\t * @param start index of the first element of the sublist.\n\t * @param stop stop - 1 is the index of the last element of the sublist.\n\t * @return a list with <tt>stop - start</tt> elements, The elements are from positions <tt>start</tt> inclusive to\n\t * <tt>stop</tt> exclusive in this list.\n\t ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t * Return the size of this list. In other words the number of elements in this list.\n\t * <br>pre: none\n\t * <br>post: return the number of items in this list\n\t * @return the number of items in this list\n\t */\nint size();\n","name":"size","className":"IList","variables":{},"javaDoc":"Return the size of this list In other words the number of elements in this list <br>pre: none <br>post: return the number of items in this list the number of items in this list","comments":"\n\t * Return the size of this list. In other words the number of elements in this list.\n\t * <br>pre: none\n\t * <br>post: return the number of items in this list\n\t * @return the number of items in this list\n\t ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["E"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t * Find the position of an element in the list.\n\t * <br>pre: none\n\t * <br>post: return the index of the first element equal to item\n\t * or -1 if item is not present\n\t * @param item the element to search for in the list\n\t * @return return the index of the first element equal to item or a -1 if item is not present\n\t */\nint indexOf(E item);\n","name":"indexOf","className":"IList","variables":{"item":1},"javaDoc":"Find the position of an element in the list <br>pre: none <br>post: return the index of the first element equal to item or -1 if item is not present item the element to search for in the list return the index of the first element equal to item or a -1 if item is not present","comments":"\n\t * Find the position of an element in the list.\n\t * <br>pre: none\n\t * <br>post: return the index of the first element equal to item\n\t * or -1 if item is not present\n\t * @param item the element to search for in the list\n\t * @return return the index of the first element equal to item or a -1 if item is not present\n\t ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["E","int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t * find the position of an element in the list starting at a specified position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the index of the first element equal to item starting at pos\n\t * or -1 if item is not present from position pos onward\n\t * @param item the element to search for in the list\n\t * @param pos the position in the list to start searching from\n\t * @return starting from the specified position return the index of the first element equal to item or a -1 if item is not present between pos and the end of the list\n\t */\nint indexOf(E item, int pos);\n","name":"indexOf","className":"IList","variables":{"item":1,"pos":1},"javaDoc":"find the position of an element in the list starting at a specified position <br>pre: 0 <= pos < size() <br>post: return the index of the first element equal to item starting at pos or -1 if item is not present from position pos onward item the element to search for in the list pos the position in the list to start searching from starting from the specified position return the index of the first element equal to item or a -1 if item is not present between pos and the end of the list","comments":"\n\t * find the position of an element in the list starting at a specified position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the index of the first element equal to item starting at pos\n\t * or -1 if item is not present from position pos onward\n\t * @param item the element to search for in the list\n\t * @param pos the position in the list to start searching from\n\t * @return starting from the specified position return the index of the first element equal to item or a -1 if item is not present between pos and the end of the list\n\t ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t * return the list to an empty state.\n\t * <br>pre: none\n\t * <br>post: size() = 0\n\t */\nvoid makeEmpty();\n","name":"makeEmpty","className":"IList","variables":{},"javaDoc":"return the list to an empty state <br>pre: none <br>post: size() = 0","comments":"\n\t * return the list to an empty state.\n\t * <br>pre: none\n\t * <br>post: size() = 0\n\t ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"Iterator<E>","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n\t* return an Iterator for this list.\n\t* <br>pre: none\n\t* <br>post: return an Iterator object for this List\n\t*/\nIterator<E> iterator();\n","name":"iterator","className":"IList","variables":{},"javaDoc":"return an Iterator for this list <br>pre: none <br>post: return an Iterator object for this List","comments":"\n\t* return an Iterator for this list.\n\t* <br>pre: none\n\t* <br>post: return an Iterator object for this List\n\t","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n     * Remove all elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n     * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n     * <br>post: <tt>size() = old size() - (stop - start)</tt>\n     * @param start position at beginning of range of elements to be removed\n     * @param stop stop - 1 is the position at the end of the range of elements to be removed\n     */\nvoid removeRange(int start, int stop);\n","name":"removeRange","className":"IList","variables":{"stop":1,"start":1},"javaDoc":"Remove all elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive <br>pre: <tt>0 <= start < size() start <= stop <= size()</tt> <br>post: <tt>size() = old size() - (stop - start)</tt> start position at beginning of range of elements to be removed stop stop - 1 is the position at the end of the range of elements to be removed","comments":"\n     * Remove all elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n     * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n     * <br>post: <tt>size() = old size() - (stop - start)</tt>\n     * @param start position at beginning of range of elements to be removed\n     * @param stop stop - 1 is the position at the end of the range of elements to be removed\n     ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n     * Return a String version of this list enclosed in\n     * square brackets, []. Elements are in\n     * are in order based on position in the \n     * list with the first element\n     * first. Adjacent elements are seperated by comma's\n     * @return a String representation of this IList\n     */\npublic String toString();\n","name":"toString","className":"IList","variables":{},"javaDoc":"Return a String version of this list enclosed in square brackets [] Elements are in are in order based on position in the list with the first element first Adjacent elements are seperated by comma's a String representation of this IList","comments":"\n     * Return a String version of this list enclosed in\n     * square brackets, []. Elements are in\n     * are in order based on position in the \n     * list with the first element\n     * first. Adjacent elements are seperated by comma's\n     * @return a String representation of this IList\n     ","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n     * Determine if this IList is equal to other. Two\n     * ILists are equal if they contain the same elements\n     * in the same order.\n     * @return true if this IList is equal to other, false otherwise\n     */\npublic boolean equals(Object other);\n","name":"equals","className":"IList","variables":{"other":1},"javaDoc":"Determine if this IList is equal to other Two ILists are equal if they contain the same elements in the same order true if this IList is equal to other false otherwise","comments":"\n     * Determine if this IList is equal to other. Two\n     * ILists are equal if they contain the same elements\n     * in the same order.\n     * @return true if this IList is equal to other, false otherwise\n     ","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"insert":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(Object x) {\n    insert(iSize, x);\n}\n","name":"add","className":"GenericList","variables":{},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ArrayAccessExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public Object get(int pos) {\n    return iValues[pos];\n}\n","name":"get","className":"GenericList","variables":{"iValues":1,"pos":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"ensureCapcity":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     */\npublic void insert(int pos, Object obj) {\n    ensureCapcity();\n    for (int i = iSize; i > pos; i--) {\n        iValues[i] = iValues[i - 1];\n    }\n    iValues[pos] = obj;\n    iSize++;\n}\n","name":"insert","className":"GenericList","variables":{"iValues":3,"iSize":2,"pos":3,"obj":2},"javaDoc":"Insert obj at position pos post: get(pos) = x size() = old size() + 1 pos 0 <= pos <= size() obj The element to add","comments":"\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{"Object":1,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Object remove(int pos) {\n    Object removedValue = iValues[pos];\n    for (int i = pos; i < iSize - 1; i++) iValues[i] = iValues[i + 1];\n    iValues[iSize - 1] = null;\n    iSize--;\n    return removedValue;\n}\n","name":"remove","className":"GenericList","variables":{"iValues":4,"removedValue":2,"iSize":3,"pos":3},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"resize":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void ensureCapcity() {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n}\n","name":"ensureCapcity","className":"GenericList","variables":{"iSize":1},"javaDoc":"","comments":"is there extra capacity available? if not resize ","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int size() {\n    return iSize;\n}\n","name":"size","className":"GenericList","variables":{"iSize":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"constants":{},"annotations":[],"types":{"Object[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    Object[] temp = new Object[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"GenericList","variables":{"temp":2,"iValues":1,"System":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"annotations":[],"types":{"String":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","StringLiteralExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i].toString() + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"GenericList","variables":{"result":5,"iValues":2,"iSize":4},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"constants":{"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"annotations":[],"types":{"StringBuffer":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"GenericList","variables":{"result":9,"iValues":2,"iSize":3},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"GenericList","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic GenericList() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"GenericList","className":"GenericList","variables":{"DEFAULT_CAP":1},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"GenericList","methodCalls":{},"constants":{"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","ArrayCreationExpr","AssignExpr"],"statements":["AssertStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic GenericList(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new Object[initialCap];\n    iSize = 0;\n}\n","name":"GenericList","className":"GenericList","variables":{"iValues":1,"iSize":1,"initialCap":4},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1,"size":1},"constants":{"null":1,"false":2,"true":1},"annotations":[],"types":{"boolean":1,"GenericList":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","NullLiteralExpr","BooleanLiteralExpr","CastExpr","FieldAccessExpr","ThisExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other is not null and refers to an IntList\n        GenericList otherList = (GenericList) other;\n        result = this.size() == otherList.size();\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i].equals(otherList.iValues[i]);\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"GenericList","variables":{"result":8,"other":5,"iSize":1,"otherList":2},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other is not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"substring":1,"System.out.println":8},"constants":{"\"Computer Science\"":1,"\" \"":2,"\"s6: \"":1,"\"s7: \"":1,"17":1,"\"s8: \"":1,"\"s4: \"":1,"\"s5: \"":1,"\"s2: \"":1,"\"s3: \"":1,"\"s1: \"":1,"\"is fun\"":1,"\"total \"":1,"\"total\"":2,"307":1,"10":1},"annotations":[],"types":{"String":8,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String s1 = \"Computer Science\";\n    int x = 307;\n    String s2 = s1 + \" \" + x;\n    String s3 = s2.substring(10, 17);\n    String s4 = \"is fun\";\n    String s5 = s2 + s4;\n    System.out.println(\"s1: \" + s1);\n    System.out.println(\"s2: \" + s2);\n    System.out.println(\"s3: \" + s3);\n    System.out.println(\"s4: \" + s4);\n    System.out.println(\"s5: \" + s5);\n    //showing effect of precedence\n    x = 3;\n    int y = 5;\n    String s6 = x + y + \"total\";\n    String s7 = \"total \" + x + y;\n    String s8 = \" \" + x + y + \"total\";\n    System.out.println(\"s6: \" + s6);\n    System.out.println(\"s7: \" + s7);\n    System.out.println(\"s8: \" + s8);\n}\n","name":"main","className":"StringExample","variables":{"args":1,"s3":2,"s4":3,"s5":2,"s6":2,"s7":2,"s8":2,"s1":3,"s2":4},"javaDoc":"","comments":"showing effect of precedence ","isEmpty":false,"lineCount":20,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    go();\n}\n","name":"main","className":"ObjectVarsAsParameters","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setSize":1,"alterPointee":1,"alterPointer":1,"System.out.println":4},"constants":{"\"In method go. r1 \"":4,"15":1,"\"\\n\"":4,"10":1},"annotations":[],"types":{"Rectangle":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void go() {\n    Rectangle r1 = new Rectangle(0, 0, 5, 5);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n    // could have been \n    //System.out.prinltn(\"r1\" + r1.toString());\n    r1.setSize(10, 15);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n    alterPointee(r1);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n    alterPointer(r1);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n}\n","name":"go","className":"ObjectVarsAsParameters","variables":{"r1":6},"javaDoc":"","comments":"could have been System out prinltn(\"r1\" + r1 toString()); ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["Rectangle"],"returnType":"void","methodCalls":{"setSize":1,"System.out.println":2},"constants":{"\"In method alterPointee. r \"":2,"30":1,"\"\\n\"":2,"20":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void alterPointee(Rectangle r) {\n    System.out.println(\"In method alterPointee. r \" + r + \"\\n\");\n    r.setSize(20, 30);\n    System.out.println(\"In method alterPointee. r \" + r + \"\\n\");\n}\n","name":"alterPointee","className":"ObjectVarsAsParameters","variables":{},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["Rectangle"],"returnType":"void","methodCalls":{"System.out.println":2},"constants":{"35":1,"\"In method alterPointer. r \"":2,"30":1,"\"\\n\"":2,"10":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void alterPointer(Rectangle r) {\n    System.out.println(\"In method alterPointer. r \" + r + \"\\n\");\n    r = new Rectangle(5, 10, 30, 35);\n    System.out.println(\"In method alterPointer. r \" + r + \"\\n\");\n}\n","name":"alterPointer","className":"ObjectVarsAsParameters","variables":{},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"equals":1,"System.out.println":3},"constants":{"\"list1: \"":1,"100":1,"\"list2: \"":1,"\"list1.equals(list2): \"":1},"annotations":[],"types":{"IntListVer1":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    IntListVer1 list1 = new IntListVer1();\n    IntListVer1 list2 = new IntListVer1(100);\n    //equal when empty?\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n}\n","name":"main","className":"IntListTesterVer1","variables":{"args":1,"list1":3,"list2":2},"javaDoc":"","comments":"equal when empty? ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"countWords":1,"countWordsOurBinarySearchTree":1,"countWordsCollection":2,"countWordsOurUnsortedSet":1,"countWordsOurHash":1,"System.out.println":4},"constants":{"\"huckfinn.txt\"":2,"\" total words.\"":1,"\"hounds.txt\"":2,"\"ciaFactBook2008.txt\"":1,"\"oz.txt\"":2,"\"war.txt\"":2,"\" distinct words.\"":1},"annotations":[],"types":{"int[]":1,"String[]":2,"String":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","ArrayAccessExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"public static void main(String[] args) throws Exception {\n    String[] allFileNames = { \"hounds.txt\", \"huckfinn.txt\", \"oz.txt\", \"war.txt\", \"ciaFactBook2008.txt\" };\n    String[] noCIA = { \"hounds.txt\", \"huckfinn.txt\", \"oz.txt\", \"war.txt\" };\n    countWords(new BinarySearchTree<String>(), allFileNames[0]);\n    for (String s : allFileNames) {\n        System.out.println(s);\n        countWordsOurUnsortedSet(s);\n        countWordsOurBinarySearchTree(s);\n        countWordsOurHash(s);\n        countWordsCollection(new TreeSet<String>(), s);\n        int[] result = countWordsCollection(new HashSet<String>(), s);\n        System.out.println(result[0] + \" total words.\");\n        System.out.println(result[1] + \" distinct words.\");\n        System.out.println();\n    }\n}\n","name":"main","className":"UnsortedSetTest","variables":{"args":1,"allFileNames":3,"result":3,"noCIA":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["Collection<String>","String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"getClass":1,"stop":1,"size":2,"clear":1,"start":1,"hasNext":1,"System.out.println":2},"constants":{"\"Time for \"":1,"\" : \\n\"":1},"annotations":[],"types":{"Scanner":1,"Stopwatch":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","AssertStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"// return total num words, and num distinct words\npublic static int[] countWordsCollection(Collection<String> c, String fileName) throws Exception {\n    c.clear();\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for \" + c.getClass() + \" : \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n","name":"countWordsCollection","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":2,"total":4},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \");  return total num words, and num distinct words","isEmpty":false,"lineCount":12,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"stop":1,"size":2,"start":1,"hasNext":1,"System.out.println":2},"constants":{"\"Time for our hashtable (closed address hashing): \\n\"":1},"annotations":[],"types":{"Scanner":1,"Stopwatch":1,"UnsortedHashSet<String>":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","AssertStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"// GACKY GACKY GACKY repition. Look into removing repetition with reflection\n// we assume there will be add and size methods\npublic static int[] countWordsOurHash(String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    UnsortedHashSet<String> c = new UnsortedHashSet<String>();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for our hashtable (closed address hashing): \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n","name":"countWordsOurHash","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":2,"total":4},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \");  we assume there will be add and size methods","isEmpty":false,"lineCount":12,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"stop":1,"size":2,"start":1,"hasNext":1,"System.out.println":2},"constants":{"\"Time for our unsorted set based on ArrayList: \\n\"":1},"annotations":[],"types":{"Scanner":1,"Stopwatch":1,"int":1,"UnsortedSet<String>":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","AssertStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"public static int[] countWordsOurUnsortedSet(String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    UnsortedSet<String> c = new UnsortedSet<String>();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for our unsorted set based on ArrayList: \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n","name":"countWordsOurUnsortedSet","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":2,"total":4},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \"); ","isEmpty":false,"lineCount":12,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"stop":1,"size":2,"start":1,"hasNext":1,"System.out.println":2},"constants":{"\"Time for our binary search tree: \\n\"":1},"annotations":[],"types":{"Scanner":1,"BinarySearchTree<String>":1,"Stopwatch":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","AssertStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"public static int[] countWordsOurBinarySearchTree(String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    BinarySearchTree<String> c = new BinarySearchTree<String>();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for our binary search tree: \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n","name":"countWordsOurBinarySearchTree","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":2,"total":4},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \"); ","isEmpty":false,"lineCount":12,"modifier":9}
{"paramTypes":["Object","String"],"returnType":"int[]","methodCalls":{"next":1,"getClass":4,"stop":1,"start":1,"toString":1,"hasNext":1,"invoke":2,"getMethod":2,"getMethods":1,"System.out.println":3},"constants":{"\"size\"":1,"\"Time for \"":1,"\": \"":1,"\"add\"":1},"annotations":[],"types":{"Scanner":1,"Stopwatch":1,"Method":2,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","ArrayInitializerExpr","CastExpr","FieldAccessExpr","ClassExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":["Exception"],"text":"// a try at reflection. Not working on Binary Search tree from class. \n// Hunch. Due to add method taking in Comparable, not Object!\n// Alterantives: search list of methods for name?\npublic static int[] countWords(Object c, String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    System.out.println(Arrays.toString(c.getClass().getMethods()));\n    Method addMethod = c.getClass().getMethod(\"add\", Object.class);\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        addMethod.invoke(c, fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for \" + c.getClass() + \": \" + st);\n    Method sizeMethod = c.getClass().getMethod(\"size\");\n    int distictWords = (Integer) sizeMethod.invoke(c);\n    //        System.out.println(distictWords + \" distinct words\");\n    //        System.out.println(total + \" total words including duplicates: \");\n    System.out.println();\n    return new int[] { total, distictWords };\n}\n","name":"countWords","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":2,"total":3,"distictWords":2,"Arrays":1,"sizeMethod":2,"addMethod":2},"javaDoc":"","comments":"System out println(distictWords + \" distinct words\"); System out println(total + \" total words including duplicates: \");  Alterantives: search list of methods for name?","isEmpty":false,"lineCount":14,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"System.out.print":1,"System.out.println":1},"constants":{"\"!\"":1,"\"Hello \"":1,"\"Enter your name: \"":1},"annotations":[],"types":{"Scanner":1,"String":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    System.out.print(\"Enter your name: \");\n    String name = s.nextLine();\n    System.out.println(\"Hello \" + name + \"!\");\n}\n","name":"main","className":"ScannerAndKeyboard","variables":{"args":1,"name":2},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"Die","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Default constructor.<p>\n     * pre: none<br>\n     * post: getNumSides() = DEFAULT_SIDES, getResult() = 1\n     */\npublic Die() {\n    this(DEFAULT_SIDES);\n}\n","name":"Die","className":"Die","variables":{"DEFAULT_SIDES":1},"javaDoc":"Default constructor <p> pre: none<br> post: getNumSides() = DEFAULT_SIDES getResult() = 1","comments":"\n     * Default constructor.<p>\n     * pre: none<br>\n     * post: getNumSides() = DEFAULT_SIDES, getResult() = 1\n     ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Die","methodCalls":{"getResult":1,"getNumSides":1},"constants":{"\"Violation of precondition: numSides = \"":1,"\"numSides must be greater than 1\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["AssertStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Create a Die with numSides sides<p>\n     * pre: numSides > 1<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     */\npublic Die(int numSides) {\n    assert numSides > 1 : \"Violation of precondition: numSides = \" + numSides + \"numSides must be greater than 1\";\n    iMyNumSides = numSides;\n    iMyResult = 1;\n    assert getResult() == 1 && getNumSides() == numSides;\n}\n","name":"Die","className":"Die","variables":{"iMyResult":1,"numSides":5,"iMyNumSides":1},"javaDoc":"Create a Die with numSides sides<p> pre: numSides > 1<br> post: getNumSides() = numSides getResult() = 1<br> An exception will be generated if the preconditions are not met","comments":"\n     * Create a Die with numSides sides<p>\n     * pre: numSides > 1<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Die","methodCalls":{},"constants":{"\"Violation of precondition\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["AssertStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Create a Die with numSides and top side and result set to result<p>\n     * pre: numSides > 1, 1 <= result <= numSides<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     */\npublic Die(int numSides, int result) {\n    assert numSides > 1 && 1 <= result && result <= numSides : \"Violation of precondition\";\n    iMyNumSides = numSides;\n    iMyResult = result;\n}\n","name":"Die","className":"Die","variables":{"result":4,"iMyResult":1,"numSides":4,"iMyNumSides":1},"javaDoc":"Create a Die with numSides and top side and result set to result<p> pre: numSides > 1 1 <= result <= numSides<br> post: getNumSides() = numSides getResult() = 1<br> An exception will be generated if the preconditions are not met","comments":"\n     * Create a Die with numSides and top side and result set to result<p>\n     * pre: numSides > 1, 1 <= result <= numSides<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getResult":2,"nextInt":1,"getNumSides":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","EnclosedExpr","AssignExpr","MethodCallExpr"],"statements":["AssertStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * roll this Die. Every side has an equal chance of being the new result<p>\n     * pre: none<br>\n     * post: 1 <= getResult() <= getNumSides()\n     * @return the result of the Die after the roll\n     */\npublic int roll() {\n    iMyResult = ourRandNumGen.nextInt(iMyNumSides) + 1;\n    assert (1 <= getResult()) && (getResult() <= getNumSides());\n    return iMyResult;\n}\n","name":"roll","className":"Die","variables":{"ourRandNumGen":1,"iMyResult":2},"javaDoc":"roll this Die Every side has an equal chance of being the new result<p> pre: none<br> post: 1 <= getResult() <= getNumSides() the result of the Die after the roll","comments":"\n     * roll this Die. Every side has an equal chance of being the new result<p>\n     * pre: none<br>\n     * post: 1 <= getResult() <= getNumSides()\n     * @return the result of the Die after the roll\n     ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * return how many sides this Die has<p>\n     * pre: none<br>\n     * post: return how many sides this Die has\n     * @return the number of sides on this Die\n     */\npublic int getNumSides() {\n    return iMyNumSides;\n}\n","name":"getNumSides","className":"Die","variables":{"iMyNumSides":1},"javaDoc":"return how many sides this Die has<p> pre: none<br> post: return how many sides this Die has the number of sides on this Die","comments":"\n     * return how many sides this Die has<p>\n     * pre: none<br>\n     * post: return how many sides this Die has\n     * @return the number of sides on this Die\n     ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * get the current result or top number of this Die<p>\n     * pre: none<br>\n     * post: return the number on top of this Die\n     * @return the current result of this Die\n     */\npublic int getResult() {\n    return iMyResult;\n}\n","name":"getResult","className":"Die","variables":{"iMyResult":1},"javaDoc":"get the current result or top number of this Die<p> pre: none<br> post: return the number on top of this Die the current result of this Die","comments":"\n     * get the current result or top number of this Die<p>\n     * pre: none<br>\n     * post: return the number on top of this Die\n     * @return the current result of this Die\n     ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1},"constants":{"null":1,"true":2,"false":2},"annotations":[],"types":{"Die":1,"boolean":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","CastExpr","FieldAccessExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"/**\n     * returns true if this Die and the parameter otherObj are equal<p>\n     * pre: none<br>\n     * post: return true if the parameter is a Die object with the same number of sides as this Die and currently has the same result.\n     * @return true if the the two Dice are equal, false otherwise\n     */\npublic boolean equals(Object otherObj) {\n    boolean result = true;\n    if (otherObj == null)\n        result = false;\n    else if (this == otherObj)\n        result = true;\n    else if (this.getClass() != otherObj.getClass())\n        result = false;\n    else {\n        Die otherDie = (Die) otherObj;\n        result = this.iMyResult == otherDie.iMyResult && this.iMyNumSides == otherDie.iMyNumSides;\n    }\n    return result;\n}\n","name":"equals","className":"Die","variables":{"result":6,"otherDie":1,"otherObj":5},"javaDoc":"returns true if this Die and the parameter otherObj are equal<p> pre: none<br> post: return true if the parameter is a Die object with the same number of sides as this Die and currently has the same result true if the the two Dice are equal false otherwise","comments":"\n     * returns true if this Die and the parameter otherObj are equal<p>\n     * pre: none<br>\n     * post: return true if the parameter is a Die object with the same number of sides as this Die and currently has the same result.\n     * @return true if the the two Dice are equal, false otherwise\n     ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getResult":1,"getNumSides":1},"constants":{"\" result \"":1,"\"Num sides \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * returns a String containing information about this Die<p>\n     * pre: none<br>\n     * post: return a String with information about the current state of this Die\n     * @return: A String with the number of sides and current result of this Die\n     */\npublic String toString() {\n    return \"Num sides \" + getNumSides() + \" result \" + getResult();\n}\n","name":"toString","className":"Die","variables":{},"javaDoc":"returns a String containing information about this Die<p> pre: none<br> post: return a String with information about the current state of this Die : A String with the number of sides and current result of this Die","comments":"\n     * returns a String containing information about this Die<p>\n     * pre: none<br>\n     * post: return a String with information about the current state of this Die\n     * @return: A String with the number of sides and current result of this Die\n     ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"hasNextInt":1,"nextInt":1,"System.out.println":2},"constants":{"\"scores.dat\"":1},"annotations":[],"types":{"Scanner":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) {\n    try {\n        Scanner s = new Scanner(new File(\"scores.dat\"));\n        while (s.hasNextInt()) {\n            System.out.println(s.nextInt());\n        }\n    } catch (IOException e) {\n        System.out.println(e);\n    }\n}\n","name":"main","className":"ReadAndPrintScores","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"makeSet":3,"toString":6,"System.out.println":6},"constants":{"\"D\"":2,"\"C\"":2,"\"B\"":3,"\"A\"":5,"\"as a set: \"":3,"\"original: \"":3},"annotations":[],"types":{"Rectangle[]":1,"String[]":1,"Object[]":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String[] words = { \"A\", \"B\", \"B\", \"D\", \"C\", \"A\" };\n    System.out.println(\"original: \" + Arrays.toString(words));\n    System.out.println(\"as a set: \" + Arrays.toString(makeSet(words)));\n    Rectangle[] rectList = { new Rectangle(), new Rectangle(), new Rectangle(0, 1, 2, 3), new Rectangle(0, 1, 2, 3) };\n    System.out.println(\"original: \" + Arrays.toString(rectList));\n    System.out.println(\"as a set: \" + Arrays.toString(makeSet(rectList)));\n    Object[] mixed = { \"A\", \"C\", \"A\", \"B\", new Rectangle(), new Rectangle(), \"A\", new Rectangle(0, 1, 2, 3), \"D\" };\n    System.out.println(\"original: \" + Arrays.toString(mixed));\n    System.out.println(\"as a set: \" + Arrays.toString(makeSet(mixed)));\n}\n","name":"main","className":"CreateASet","variables":{"args":1,"rectList":1,"words":1,"mixed":1,"Arrays":6},"javaDoc":"","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":["Object[]"],"returnType":"Object[]","methodCalls":{"noNulls":1,"arraycopy":1},"constants":{"null":1,"\"Failed precondition makeSet. parameter cannot be null\"":1,"\"Failed precondition makeSet. no elements of parameter can be null\"":1,"false":1},"annotations":[],"types":{"boolean":1,"Object[]":2,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","AssignExpr","NullLiteralExpr","BooleanLiteralExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","AssertStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * An example of polymorphism in action. The method relies\n     * on Java's inheritance requirement and polymorhphism to call\n     * the correct equals method.\n     * @param data != null, no elements of data are null\n     * @return a Set (no duplicates) of the elements in data.\n     */\npublic static Object[] makeSet(Object[] data) {\n    assert data != null : \"Failed precondition makeSet. parameter cannot be null\";\n    assert noNulls(data) : \"Failed precondition makeSet. no elements of parameter can be null\";\n    Object[] result = new Object[data.length];\n    int numUnique = 0;\n    boolean found;\n    int indexInResult;\n    for (int i = 0; i < data.length; i++) {\n        // maybe should break this out into another method\n        indexInResult = 0;\n        found = false;\n        while (!found && indexInResult < numUnique) {\n            found = data[i].equals(result[indexInResult]);\n            indexInResult++;\n        }\n        if (!found) {\n            result[numUnique] = data[i];\n            numUnique++;\n        }\n    }\n    Object[] result2 = new Object[numUnique];\n    System.arraycopy(result, 0, result2, 0, numUnique);\n    return result2;\n}\n","name":"makeSet","className":"CreateASet","variables":{"result":3,"found":5,"data":4,"numUnique":5,"indexInResult":5,"result2":2,"System":1},"javaDoc":"An example of polymorphism in action The method relies on Java's inheritance requirement and polymorhphism to call the correct equals method data != null no elements of data are null a Set (no duplicates) of the elements in data","comments":"maybe should break this out into another method \n     * An example of polymorphism in action. The method relies\n     * on Java's inheritance requirement and polymorhphism to call\n     * the correct equals method.\n     * @param data != null, no elements of data are null\n     * @return a Set (no duplicates) of the elements in data.\n     ","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":["Object[]"],"returnType":"boolean","methodCalls":{},"constants":{"null":2,"\"Failed precondition makeSet. parameter cannot be null\"":1,"true":1},"annotations":[],"types":{"boolean":1,"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","AssertStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// pre: data != null\n// return true if all elements of data are non null,\n// false otherwise\nprivate static boolean noNulls(Object[] data) {\n    assert data != null : \"Failed precondition makeSet. parameter cannot be null\";\n    boolean good = true;\n    int i = 0;\n    while (good && i < data.length) {\n        good = data[i] != null;\n        i++;\n    }\n    return good;\n}\n","name":"noNulls","className":"CreateASet","variables":{"data":3,"good":4},"javaDoc":"","comments":" false otherwise","isEmpty":false,"lineCount":5,"modifier":10}
{"paramTypes":[],"returnType":"ListNode","methodCalls":{},"constants":{"null":2},"annotations":[],"types":{},"expressions":["NullLiteralExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * default constructor\n\t * pre: none<br>\n\t * post: getData() = null, getNext() = null\n\t */\npublic ListNode() {\n    this(null, null);\n}\n","name":"ListNode","className":"ListNode","variables":{},"javaDoc":"default constructor pre: none<br> post: getData() = null getNext() = null","comments":"\n\t * default constructor\n\t * pre: none<br>\n\t * post: getData() = null, getNext() = null\n\t ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object","ListNode"],"returnType":"ListNode","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * create a ListNode that holds the specified data and refers to the specified next element\n\t * pre: none<br>\n\t * post: getData() = item, getNext() = next\n\t * @param item the  data this ListNode should hold\n\t * @param next the next node in the list\n\t */\npublic ListNode(Object data, ListNode next) {\n    myData = data;\n    myNext = next;\n}\n","name":"ListNode","className":"ListNode","variables":{"next":2,"myNext":1,"data":2,"myData":1},"javaDoc":"create a ListNode that holds the specified data and refers to the specified next element pre: none<br> post: getData() = item getNext() = next item the data this ListNode should hold next the next node in the list","comments":"\n\t * create a ListNode that holds the specified data and refers to the specified next element\n\t * pre: none<br>\n\t * post: getData() = item, getNext() = next\n\t * @param item the  data this ListNode should hold\n\t * @param next the next node in the list\n\t ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * return the data in this node\n\t * pre: none<br>\n\t * @return the data this ListNode holds\n\t */\npublic Object getData() {\n    return myData;\n}\n","name":"getData","className":"ListNode","variables":{"myData":1},"javaDoc":"return the data in this node pre: none<br> the data this ListNode holds","comments":"\n\t * return the data in this node\n\t * pre: none<br>\n\t * @return the data this ListNode holds\n\t ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ListNode","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * return the ListNode this ListNode refers to\n\t * pre: none<br>\n\t * @return the ListNode this ListNode refers to (normally the next one in a list)\n\t */\npublic ListNode getNext() {\n    return myNext;\n}\n","name":"getNext","className":"ListNode","variables":{"myNext":1},"javaDoc":"return the ListNode this ListNode refers to pre: none<br> the ListNode this ListNode refers to (normally the next one in a list)","comments":"\n\t * return the ListNode this ListNode refers to\n\t * pre: none<br>\n\t * @return the ListNode this ListNode refers to (normally the next one in a list)\n\t ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * set the data in this node\n\t * The old data is over written.<br>\n\t * pre: none<br>\n\t * @param data the new data for this ListNode to hold\n\t */\npublic void setData(Object data) {\n    myData = data;\n}\n","name":"setData","className":"ListNode","variables":{"data":2,"myData":1},"javaDoc":"set the data in this node The old data is over written <br> pre: none<br> data the new data for this ListNode to hold","comments":"\n\t * set the data in this node\n\t * The old data is over written.<br>\n\t * pre: none<br>\n\t * @param data the new data for this ListNode to hold\n\t ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["ListNode"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n\t * set the next node this ListNode refers to\n\t * pre: none<br>\n\t * @param next the next node this ListNode should refer to\n\t */\npublic void setNext(ListNode next) {\n    myNext = next;\n}\n","name":"setNext","className":"ListNode","variables":{"next":2,"myNext":1},"javaDoc":"set the next node this ListNode refers to pre: none<br> next the next node this ListNode should refer to","comments":"\n\t * set the next node this ListNode refers to\n\t * pre: none<br>\n\t * @param next the next node this ListNode should refer to\n\t ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"stop":2,"equals":3,"start":2,"toString":3,"System.out.println":14,"toStringUsingStringBuffer":1},"constants":{"\"list1: \"":3,"100":2,"\"list2: \"":3,"200":1,"\"Increasing list1 size to 10000.\"":1,"\"Added 200 to list2.\"":1,"\"Testing efficieny of StringBuffer versus using String.\"":1,"\"Time to build String using StringBuffer class: \"":1,"10000":1,"\"Time to build String using String class: \"":1,"\"list1.equals(list2): \"":3},"annotations":[],"types":{"IntListVer2":2,"Stopwatch":1,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    IntListVer2 list1 = new IntListVer2();\n    IntListVer2 list2 = new IntListVer2(100);\n    //equal when empty?\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n    //add elements\n    for (int i = 0; i < 100; i += 5) {\n        list1.add(i);\n        list2.add(i);\n    }\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n    list2.add(200);\n    System.out.println(\"Added 200 to list2.\");\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n    System.out.println(\"Testing efficieny of StringBuffer versus using String.\");\n    System.out.println(\"Increasing list1 size to 10000.\");\n    Stopwatch s = new Stopwatch();\n    list1 = new IntListVer2();\n    for (int i = 0; i < 10000; i++) list1.add(i);\n    s.start();\n    list1.toString();\n    s.stop();\n    System.out.println(\"Time to build String using String class: \" + s.toString());\n    s.start();\n    list1.toStringUsingStringBuffer();\n    s.stop();\n    System.out.println(\"Time to build String using StringBuffer class: \" + s.toString());\n}\n","name":"main","className":"IntListTesterVer2","variables":{"args":1,"list1":12,"list2":6},"javaDoc":"","comments":"equal when empty? add elements ","isEmpty":false,"lineCount":27,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    go();\n}\n","name":"main","className":"PrimitiveParameters","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"moreParameters":1,"falseSwap":1,"System.out.println":3},"constants":{"\"in method go. x: \"":2,"\"In method go. x: \"":1,"\" y: \"":3},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void go() {\n    int x = 3;\n    int y = 2;\n    System.out.println(\"In method go. x: \" + x + \" y: \" + y);\n    falseSwap(x, y);\n    System.out.println(\"in method go. x: \" + x + \" y: \" + y);\n    moreParameters(x, y);\n    System.out.println(\"in method go. x: \" + x + \" y: \" + y);\n}\n","name":"go","className":"PrimitiveParameters","variables":{},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"System.out.println":2},"constants":{"\"in method falseSwap. x: \"":2,"\" y: \"":2},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void falseSwap(int x, int y) {\n    System.out.println(\"in method falseSwap. x: \" + x + \" y: \" + y);\n    int temp = x;\n    x = y;\n    y = temp;\n    System.out.println(\"in method falseSwap. x: \" + x + \" y: \" + y);\n}\n","name":"falseSwap","className":"PrimitiveParameters","variables":{"temp":2},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"falseSwap":1,"System.out.println":3},"constants":{"\"in method moreParameters. a: \"":3,"12":1,"\" b: \"":3},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void moreParameters(int a, int b) {\n    System.out.println(\"in method moreParameters. a: \" + a + \" b: \" + b);\n    a = a * b;\n    b = 12;\n    System.out.println(\"in method moreParameters. a: \" + a + \" b: \" + b);\n    falseSwap(b, a);\n    System.out.println(\"in method moreParameters. a: \" + a + \" b: \" + b);\n}\n","name":"moreParameters","className":"PrimitiveParameters","variables":{},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"GenericListIterator","methodCalls":{},"constants":{"false":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BooleanLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private GenericListIterator() {\n    position = 0;\n    removeOK = false;\n}\n","name":"GenericListIterator","className":"GenericListIterator","variables":{"position":1,"removeOK":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public boolean hasNext() {\n    return position < iSize;\n}\n","name":"hasNext","className":"GenericListIterator","variables":{"iSize":1,"position":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"true":1},"annotations":[],"types":{"Object":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","BooleanLiteralExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Object next() {\n    Object result = iValues[position];\n    position++;\n    removeOK = true;\n    return result;\n}\n","name":"next","className":"GenericListIterator","variables":{"result":2,"iValues":1,"position":2,"removeOK":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{"false":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","UnaryExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void remove() {\n    if (!removeOK)\n        throw new IllegalStateException();\n    // which element should be removed??\n    removeOK = false;\n    GenericListVersion2.this.remove(position - 1);\n    position--;\n}\n","name":"remove","className":"GenericListIterator","variables":{"GenericListVersion2":1,"position":2,"removeOK":2},"javaDoc":"","comments":"which element should be removed?? ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public Iterator iterator() {\n    return new GenericListIterator();\n}\n","name":"iterator","className":"GenericListVersion2","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Collection"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"Object":1},"expressions":["VariableDeclarationExpr","NameExpr","ThisExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void addAll(Collection c) {\n    // for each loop\n    for (Object obj : c) {\n        this.add(obj);\n    }\n}\n","name":"addAll","className":"GenericListVersion2","variables":{"obj":1},"javaDoc":"","comments":"for each loop ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"insert":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(Object x) {\n    insert(iSize, x);\n}\n","name":"add","className":"GenericListVersion2","variables":{},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ArrayAccessExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public Object get(int pos) {\n    return iValues[pos];\n}\n","name":"get","className":"GenericListVersion2","variables":{"iValues":1,"pos":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"ensureCapcity":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     */\npublic void insert(int pos, Object obj) {\n    ensureCapcity();\n    for (int i = iSize; i > pos; i--) {\n        iValues[i] = iValues[i - 1];\n    }\n    iValues[pos] = obj;\n    iSize++;\n}\n","name":"insert","className":"GenericListVersion2","variables":{"iValues":3,"iSize":2,"pos":3,"obj":2},"javaDoc":"Insert obj at position pos post: get(pos) = x size() = old size() + 1 pos 0 <= pos <= size() obj The element to add","comments":"\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{"Object":1,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Object remove(int pos) {\n    Object removedValue = iValues[pos];\n    for (int i = pos; i < iSize - 1; i++) iValues[i] = iValues[i + 1];\n    iValues[iSize - 1] = null;\n    iSize--;\n    return removedValue;\n}\n","name":"remove","className":"GenericListVersion2","variables":{"iValues":4,"removedValue":2,"iSize":3,"pos":3},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"resize":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void ensureCapcity() {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n}\n","name":"ensureCapcity","className":"GenericListVersion2","variables":{"iSize":1},"javaDoc":"","comments":"is there extra capacity available? if not resize ","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int size() {\n    return iSize;\n}\n","name":"size","className":"GenericListVersion2","variables":{"iSize":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"constants":{},"annotations":[],"types":{"Object[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    Object[] temp = new Object[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"GenericListVersion2","variables":{"temp":2,"iValues":1,"System":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"annotations":[],"types":{"String":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","StringLiteralExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i].toString() + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"GenericListVersion2","variables":{"result":5,"iValues":2,"iSize":4},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"constants":{"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"annotations":[],"types":{"StringBuffer":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"GenericListVersion2","variables":{"result":9,"iValues":2,"iSize":3},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"GenericListVersion2","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic GenericListVersion2() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"GenericListVersion2","className":"GenericListVersion2","variables":{"DEFAULT_CAP":1},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"GenericListVersion2","methodCalls":{},"constants":{"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","ArrayCreationExpr","AssignExpr"],"statements":["AssertStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic GenericListVersion2(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new Object[initialCap];\n    iSize = 0;\n}\n","name":"GenericListVersion2","className":"GenericListVersion2","variables":{"iValues":1,"iSize":1,"initialCap":4},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1,"size":1},"constants":{"null":1,"false":2,"true":1},"annotations":[],"types":{"boolean":1,"GenericListVersion2":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","NullLiteralExpr","BooleanLiteralExpr","CastExpr","FieldAccessExpr","ThisExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other is not null and refers to an IntList\n        GenericListVersion2 otherList = (GenericListVersion2) other;\n        result = this.size() == otherList.size();\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i].equals(otherList.iValues[i]);\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"GenericListVersion2","variables":{"result":8,"other":5,"iSize":1,"otherList":2},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other is not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"exit":1,"split":1,"nextLine":3,"hasNext":1,"System.out.print":2,"canRedeem":1,"System.out.println":4},"constants":{"\"Could not connect to file airlines.txt.\"":1,"\"Enter goal airline: \"":1,"null":2,"\" to \"":1,"\".\"":1,"\"airlines.txt\"":1,"\",\"":1,"\"Path to redeem miles: \"":1,"\"Cannot convert miles from \"":1,"\"Enter airline miles are on: \"":1},"annotations":[],"types":{"Scanner":2,"Airline":1,"ArrayList<Airline>":1,"String":3,"String[]":1,"ArrayList<String>":2},"expressions":["NullLiteralExpr","ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException"],"text":"public static void main(String[] args) {\n    Scanner scannerToReadAirlines = null;\n    try {\n        scannerToReadAirlines = new Scanner(new File(\"airlines.txt\"));\n    } catch (IOException e) {\n        System.out.println(\"Could not connect to file airlines.txt.\");\n        System.exit(0);\n    }\n    if (scannerToReadAirlines != null) {\n        ArrayList<Airline> airlinesPartnersNetwork = new ArrayList<Airline>();\n        Airline newAirline;\n        String lineFromFile;\n        String[] airlineNames;\n        while (scannerToReadAirlines.hasNext()) {\n            lineFromFile = scannerToReadAirlines.nextLine();\n            airlineNames = lineFromFile.split(\",\");\n            newAirline = new Airline(airlineNames);\n            airlinesPartnersNetwork.add(newAirline);\n        }\n        System.out.println(airlinesPartnersNetwork);\n        Scanner keyboard = new Scanner(System.in);\n        System.out.print(\"Enter airline miles are on: \");\n        String start = keyboard.nextLine();\n        System.out.print(\"Enter goal airline: \");\n        String goal = keyboard.nextLine();\n        ArrayList<String> pathForMiles = new ArrayList<String>();\n        ArrayList<String> airlinesVisited = new ArrayList<String>();\n        if (canRedeem(start, goal, pathForMiles, airlinesVisited, airlinesPartnersNetwork))\n            System.out.println(\"Path to redeem miles: \" + pathForMiles);\n        else\n            System.out.println(\"Cannot convert miles from \" + start + \" to \" + goal + \".\");\n    }\n}\n","name":"main","className":"AirlineProblem","variables":{"args":1,"airlineNames":3,"keyboard":3,"scannerToReadAirlines":5,"goal":2,"airlinesVisited":1,"start":2,"newAirline":2,"lineFromFile":3,"pathForMiles":2,"System":1,"airlinesPartnersNetwork":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String","String","ArrayList<String>","ArrayList<String>","ArrayList<Airline>"],"returnType":"boolean","methodCalls":{"add":3,"contains":1,"getName":1,"size":2,"equals":2,"get":2,"getPartners":1,"canRedeem":1,"remove":1},"constants":{"true":1,"false":3},"annotations":[],"types":{"boolean":1,"String[]":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"private static boolean canRedeem(String current, String goal, ArrayList<String> pathForMiles, ArrayList<String> airlinesVisited, ArrayList<Airline> network) {\n    if (current.equals(goal)) {\n        //base case 1, I have found a path!\n        pathForMiles.add(current);\n        return true;\n    } else if (airlinesVisited.contains(current))\n        // don't go into a cycle\n        return false;\n    else {\n        // I have not been here and it isn't\n        // the goal so check its partners\n        // now I have been here\n        airlinesVisited.add(current);\n        // add this to the path\n        pathForMiles.add(current);\n        // find this airline in the network\n        int pos = -1;\n        int index = 0;\n        while (pos == -1 && index < network.size()) {\n            if (network.get(index).getName().equals(current))\n                pos = index;\n            index++;\n        }\n        //if not in the network, no partners\n        if (pos == -1)\n            return false;\n        // loop through partners\n        index = 0;\n        String[] partners = network.get(pos).getPartners();\n        boolean foundPath = false;\n        while (!foundPath && index < partners.length) {\n            foundPath = canRedeem(partners[index], goal, pathForMiles, airlinesVisited, network);\n            index++;\n        }\n        if (!foundPath)\n            pathForMiles.remove(pathForMiles.size() - 1);\n        return foundPath;\n    }\n}\n","name":"canRedeem","className":"AirlineProblem","variables":{"current":2,"goal":1,"pos":4,"partners":2,"airlinesVisited":3,"index":8,"pathForMiles":5,"foundPath":5,"network":4},"javaDoc":"","comments":"base case 1 I have found a path! base case 2 I have already been here don't go into a cycle I have not been here and it isn't the goal so check its partners now I have been here add this to the path find this airline in the network if not in the network no partners loop through partners ","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["String[]"],"returnType":"Airline","methodCalls":{"add":1},"constants":{"\"Failed precondition\"":1,"null":1},"annotations":[],"types":{"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["AssertStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"//pre: data != null, data.length > 0\npublic Airline(String[] data) {\n    assert data != null && data.length > 0 : \"Failed precondition\";\n    name = data[0];\n    partners = new ArrayList<String>();\n    for (int i = 1; i < data.length; i++) partners.add(data[i]);\n}\n","name":"Airline","className":"Airline","variables":{"data":4,"partners":2,"name":1},"javaDoc":"","comments":"pre: data != null, data.length > 0","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String[]","methodCalls":{"size":1,"toArray":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String[] getPartners() {\n    return partners.toArray(new String[partners.size()]);\n}\n","name":"getPartners","className":"Airline","variables":{"partners":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"contains":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public boolean isPartner(String name) {\n    return partners.contains(name);\n}\n","name":"isPartner","className":"Airline","variables":{"partners":1,"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Airline","variables":{"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\", partners: \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return name + \", partners: \" + partners;\n}\n","name":"toString","className":"Airline","variables":{"partners":1,"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Color[][]","int"],"returnType":"Color[][]","methodCalls":{"rectangularMatrix":1,"aveOfNeighbors":1},"constants":{"null":1,"\"Violation of precondition: smooth\"":1},"annotations":[],"types":{"Color[][]":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","AssignExpr","NullLiteralExpr","FieldAccessExpr","EnclosedExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["BlockStmt","AssertStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/*\n\t *pre: image != null, image.length > 1, image[0].length > 1\n\t *\timage is a rectangular matrix, neighberhoodSize > 0\n\t *post: return a smoothed version of image\n\t */\npublic Color[][] smooth(Color[][] image, int neighberhoodSize) {\n    //check precondition\n    assert image != null && image.length > 1 && image[0].length > 1 && (neighberhoodSize > 0) && rectangularMatrix(image) : \"Violation of precondition: smooth\";\n    Color[][] result = new Color[image.length][image[0].length];\n    for (int row = 0; row < image.length; row++) {\n        for (int col = 0; col < image[0].length; col++) {\n            result[row][col] = aveOfNeighbors(image, row, col, neighberhoodSize);\n        }\n    }\n    return result;\n}\n","name":"smooth","className":"FilterExample","variables":{"result":3,"image":5,"neighberhoodSize":2,"col":4,"row":4},"javaDoc":"","comments":"check precondition \n\t *pre: image != null, image.length > 1, image[0].length > 1\n\t *\timage is a rectangular matrix, neighberhoodSize > 0\n\t *post: return a smoothed version of image\n\t ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Color[][]","int","int","int"],"returnType":"Color","methodCalls":{"inBounds":1},"constants":{},"annotations":[],"types":{"int":6},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","AssertStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// helper method that determines the average color of a neighberhood\n// around a particular cell.\nprivate Color aveOfNeighbors(Color[][] image, int row, int col, int neighberhoodSize) {\n    int numNeighbors = 0;\n    int red = 0;\n    int green = 0;\n    int blue = 0;\n    for (int r = row - neighberhoodSize; r <= row + neighberhoodSize; r++) {\n        for (int c = col - neighberhoodSize; c <= col + neighberhoodSize; c++) {\n            if (inBounds(image, r, c)) {\n                numNeighbors++;\n                red += image[r][c].getRed();\n                green += image[r][c].getGreen();\n                blue += image[r][c].getBlue();\n            }\n        }\n    }\n    assert numNeighbors > 0;\n    return new Color(red / numNeighbors, green / numNeighbors, blue / numNeighbors);\n}\n","name":"aveOfNeighbors","className":"FilterExample","variables":{"red":3,"image":4,"col":3,"neighberhoodSize":5,"numNeighbors":6,"green":3,"blue":3,"row":3},"javaDoc":"","comments":" around a particular cell.","isEmpty":false,"lineCount":7,"modifier":2}
{"paramTypes":["Color[][]","int","int"],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","EnclosedExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"//helper method to determine if given coordinates are in bounds\nprivate boolean inBounds(Color[][] image, int row, int col) {\n    return (row >= 0) && (row <= image.length) && (col >= 0) && (col < image[0].length);\n}\n","name":"inBounds","className":"FilterExample","variables":{"image":2,"col":3,"row":3},"javaDoc":"","comments":"helper method to determine if given coordinates are in bounds","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["Color[][]"],"returnType":"boolean","methodCalls":{},"constants":{"true":1},"annotations":[],"types":{"boolean":1,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","EnclosedExpr","UnaryExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"//private method to ensure mat is rectangular\nprivate boolean rectangularMatrix(Color[][] mat) {\n    boolean isRectangular = true;\n    int row = 1;\n    final int COLUMNS = mat[0].length;\n    while (isRectangular && row < mat.length) {\n        isRectangular = (mat[row].length == COLUMNS);\n        row++;\n    }\n    return isRectangular;\n}\n","name":"rectangularMatrix","className":"FilterExample","variables":{"mat":3,"COLUMNS":2,"row":4,"isRectangular":4},"javaDoc":"","comments":"private method to ensure mat is rectangular","isEmpty":false,"lineCount":5,"modifier":2}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public Iterator iterator() {\n    return new LLIterator();\n}\n","name":"iterator","className":"LinkedList","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"LLIterator","methodCalls":{},"constants":{"false":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BooleanLiteralExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private LLIterator() {\n    nextNode = head;\n    removeOK = false;\n    posToRemove = -1;\n}\n","name":"LLIterator","className":"LLIterator","variables":{"head":1,"nextNode":1,"posToRemove":1,"removeOK":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public boolean hasNext() {\n    return nextNode != null;\n}\n","name":"hasNext","className":"LLIterator","variables":{"nextNode":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1,"getNext":1,"getData":1},"constants":{"true":1},"annotations":[],"types":{"Object":1},"expressions":["VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["AssertStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Object next() {\n    assert hasNext();\n    Object result = nextNode.getData();\n    nextNode = nextNode.getNext();\n    removeOK = true;\n    posToRemove++;\n    return result;\n}\n","name":"next","className":"LLIterator","variables":{"result":2,"nextNode":3,"posToRemove":1,"removeOK":1},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{"false":1},"annotations":[],"types":{},"expressions":["BooleanLiteralExpr","NameExpr","UnaryExpr","ThisExpr","AssignExpr","MethodCallExpr"],"statements":["AssertStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void remove() {\n    assert removeOK;\n    removeOK = false;\n    LinkedList.this.remove(posToRemove);\n    posToRemove--;\n}\n","name":"remove","className":"LLIterator","variables":{"posToRemove":1,"removeOK":2,"LinkedList":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void makeEmpty() {\n    // let GC do its job!!!!!!!\n    head = tail = null;\n    size = 0;\n}\n","name":"makeEmpty","className":"LinkedList","variables":{"head":1,"size":1,"tail":1},"javaDoc":"","comments":"let GC do its job!!!!!!! ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"setNext":1,"getNext":5,"getData":2},"constants":{"null":1},"annotations":[],"types":{"Node":1,"Object":1,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","AssertStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Object remove(int pos) {\n    assert pos >= 0 && pos < size;\n    Object result;\n    if (pos == 0) {\n        result = head.getData();\n        head = head.getNext();\n        if (size == 1)\n            tail = null;\n    } else {\n        Node temp = head;\n        for (int i = 1; i < pos; i++) temp = temp.getNext();\n        result = temp.getNext().getData();\n        temp.setNext(temp.getNext().getNext());\n        if (pos == size - 1)\n            tail = temp;\n    }\n    size--;\n    return result;\n}\n","name":"remove","className":"LinkedList","variables":{"result":4,"head":4,"temp":7,"size":4,"pos":6,"tail":2},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"getNext":1,"getData":2},"constants":{},"annotations":[],"types":{"Node":1,"Object":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","AssertStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Object get(int pos) {\n    assert pos >= 0 && pos < size;\n    // array based list\n    // return myCon[pos]\n    Object result;\n    if (pos == size - 1)\n        //O(1)\n        result = tail.getData();\n    else {\n        Node temp = head;\n        for (int i = 0; i < pos; i++) temp = temp.getNext();\n        result = temp.getData();\n    // average case O(N) :((((\n    }\n    return result;\n}\n","name":"get","className":"LinkedList","variables":{"result":4,"head":1,"temp":4,"size":2,"pos":5,"tail":1},"javaDoc":"","comments":"array based list return myCon[pos] O(1) average case O(N) :(((( ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"add":1,"setNext":1,"getNext":2,"addFirst":1},"constants":{},"annotations":[],"types":{"Node":2,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","AssertStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void insert(int pos, Object obj) {\n    assert pos >= 0 && pos <= size;\n    // addFirst?\n    if (pos == 0)\n        // O(1)\n        addFirst(obj);\n    else // add last?\n    if (pos == size)\n        //at end O(1)\n        add(obj);\n    else {\n        // general case\n        Node temp = head;\n        for (int i = 1; i < pos; i++) temp = temp.getNext();\n        // I know temp is pointing at the\n        // node at position pos - 1\n        Node newNode = new Node(obj, temp.getNext());\n        temp.setNext(newNode);\n        size++;\n    }\n}\n","name":"insert","className":"LinkedList","variables":{"head":1,"temp":5,"size":3,"pos":6,"obj":2,"newNode":1},"javaDoc":"","comments":"addFirst? O(1) add last? at end O(1) I know temp is pointing at the general case node at position pos - 1 ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"setNext":1},"constants":{"null":1},"annotations":[],"types":{"Node":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void add(Object obj) {\n    Node newNode = new Node(obj, null);\n    if (size == 0)\n        head = newNode;\n    else\n        tail.setNext(newNode);\n    tail = newNode;\n    size++;\n}\n","name":"add","className":"LinkedList","variables":{"head":1,"size":2,"obj":2,"tail":2,"newNode":3},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"add":1},"constants":{},"annotations":[],"types":{"Node":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void addFirst(Object obj) {\n    if (size == 0)\n        add(obj);\n    else {\n        Node newNode = new Node(obj, head);\n        head = newNode;\n        size++;\n    }\n}\n","name":"addFirst","className":"LinkedList","variables":{"head":2,"size":2,"obj":2,"newNode":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getNext":1,"getData":1},"constants":{"\"\"":1,"\" \"":1},"annotations":[],"types":{"Node":1,"String":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    String result = \"\";\n    Node temp = head;\n    for (int i = 0; i < size; i++) {\n        result += temp.getData() + \" \";\n        temp = temp.getNext();\n    }\n    return result;\n}\n","name":"toString","className":"LinkedList","variables":{"result":3,"head":1,"temp":4,"size":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"resize":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","AssertStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(int x) {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n    assert 0 <= iSize && iSize < iValues.length;\n    iValues[iSize] = x;\n    iSize++;\n}\n","name":"add","className":"IntListVer2","variables":{"iValues":1,"iSize":5},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"is there extra capacity available? if not resize \n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"constants":{},"annotations":[],"types":{"int[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    int[] temp = new int[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"IntListVer2","variables":{"temp":2,"iValues":1,"System":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"annotations":[],"types":{"String":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","StringLiteralExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i] + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"IntListVer2","variables":{"result":5,"iValues":2,"iSize":4},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"constants":{"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"annotations":[],"types":{"StringBuffer":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"IntListVer2","variables":{"result":9,"iValues":2,"iSize":3},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"IntListVer2","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic IntListVer2() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"IntListVer2","className":"IntListVer2","variables":{"DEFAULT_CAP":1},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"IntListVer2","methodCalls":{},"constants":{"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","ArrayCreationExpr","AssignExpr"],"statements":["AssertStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic IntListVer2(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new int[initialCap];\n    iSize = 0;\n}\n","name":"IntListVer2","className":"IntListVer2","variables":{"iValues":1,"iSize":1,"initialCap":4},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1},"constants":{"null":1,"false":2,"true":1},"annotations":[],"types":{"boolean":1,"IntListVer2":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","NullLiteralExpr","BooleanLiteralExpr","CastExpr","FieldAccessExpr","ThisExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other ris not null and refers to an IntList\n        IntListVer2 otherIntList = (IntListVer2) other;\n        result = this.iSize == otherIntList.iSize;\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i] == otherIntList.iValues[i];\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"IntListVer2","variables":{"result":8,"other":5,"iSize":1,"otherIntList":1},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other ris not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"IntListVer3","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ExplicitConstructorInvocationStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic IntListVer3() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"IntListVer3","className":"IntListVer3","variables":{"DEFAULT_CAP":1},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"IntListVer3","methodCalls":{},"constants":{"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","ArrayCreationExpr","AssignExpr"],"statements":["AssertStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic IntListVer3(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new int[initialCap];\n    iSize = 0;\n}\n","name":"IntListVer3","className":"IntListVer3","variables":{"iValues":1,"iSize":1,"initialCap":4},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"insert":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(int x) {\n    //example of loose coupling\n    insert(iSize, x);\n}\n","name":"add","className":"IntListVer3","variables":{},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"example of loose coupling \n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"size":1},"constants":{"\"Failed precondition get. \"":1,"\"pos it out of bounds. Value of pos: \"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["AssertStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Retrieve an element from the list based on position.\n     * @param pos 0 <= pos < size()\n     * @return The element at the given position.\n     */\npublic int get(int pos) {\n    assert 0 <= pos && pos < size() : \"Failed precondition get. \" + \"pos it out of bounds. Value of pos: \" + pos;\n    return iValues[pos];\n}\n","name":"get","className":"IntListVer3","variables":{"iValues":1,"pos":5},"javaDoc":"Retrieve an element from the list based on position pos 0 <= pos < size() The element at the given position","comments":"\n     * Retrieve an element from the list based on position.\n     * @param pos 0 <= pos < size()\n     * @return The element at the given position.\n     ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"size":1,"ensureCapcity":1},"constants":{"\"Failed precondition insert. \"":1,"\"pos is invalid. Value of pos: \"":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","AssertStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Insert x at position pos. Elements with a position equal\n     * to pos or more are shifted to the right. (One added to their\n     * position.)\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param x\n     */\npublic void insert(int pos, int x) {\n    assert 0 <= pos && pos <= size() : \"Failed precondition insert. \" + \"pos is invalid. Value of pos: \" + pos;\n    ensureCapcity();\n    for (int i = iSize; i > pos; i--) {\n        iValues[i] = iValues[i - 1];\n    }\n    iValues[pos] = x;\n    iSize++;\n}\n","name":"insert","className":"IntListVer3","variables":{"iValues":3,"iSize":2,"pos":6},"javaDoc":"Insert x at position pos Elements with a position equal to pos or more are shifted to the right (One added to their position ) post: get(pos) = x size() = old size() + 1 pos 0 <= pos <= size() x","comments":"\n     * Insert x at position pos. Elements with a position equal\n     * to pos or more are shifted to the right. (One added to their\n     * position.)\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param x\n     ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"size":1},"constants":{"\"Failed precondition remove. \"":1,"\"pos it out of bounds. Value of pos: \"":1},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["AssertStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Remove an element from the list based on position.\n     * Elements with a position greater than pos\n     * are shifted to the left. (One subtracted from their\n     * position.)\n     * @param pos 0 <= pos < size()\n     * @return The element that is removed.\n     */\npublic int remove(int pos) {\n    assert 0 <= pos && pos < size() : \"Failed precondition remove. \" + \"pos it out of bounds. Value of pos: \" + pos;\n    int removedValue = iValues[pos];\n    for (int i = pos; i < iSize - 1; i++) iValues[i] = iValues[i + 1];\n    iSize--;\n    return removedValue;\n}\n","name":"remove","className":"IntListVer3","variables":{"iValues":3,"removedValue":2,"iSize":2,"pos":6},"javaDoc":"Remove an element from the list based on position Elements with a position greater than pos are shifted to the left (One subtracted from their position ) pos 0 <= pos < size() The element that is removed","comments":"\n     * Remove an element from the list based on position.\n     * Elements with a position greater than pos\n     * are shifted to the left. (One subtracted from their\n     * position.)\n     * @param pos 0 <= pos < size()\n     * @return The element that is removed.\n     ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"resize":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private void ensureCapcity() {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n}\n","name":"ensureCapcity","className":"IntListVer3","variables":{"iSize":1},"javaDoc":"","comments":"is there extra capacity available? if not resize ","isEmpty":false,"lineCount":2,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Returns the size of the list.\n     * @return The size of the list.\n     */\npublic int size() {\n    return iSize;\n}\n","name":"size","className":"IntListVer3","variables":{"iSize":1},"javaDoc":"Returns the size of the list The size of the list","comments":"\n     * Returns the size of the list.\n     * @return The size of the list.\n     ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"constants":{},"annotations":[],"types":{"int[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    int[] temp = new int[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"IntListVer3","variables":{"temp":2,"iValues":1,"System":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"annotations":[],"types":{"String":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","StringLiteralExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i] + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"IntListVer3","variables":{"result":5,"iValues":2,"iSize":4},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"constants":{"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"annotations":[],"types":{"StringBuffer":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"IntListVer3","variables":{"result":9,"iValues":2,"iSize":3},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"lineCount":8,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1,"size":1},"constants":{"null":1,"false":2,"true":1},"annotations":[],"types":{"boolean":1,"IntListVer3":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","NullLiteralExpr","BooleanLiteralExpr","CastExpr","FieldAccessExpr","ThisExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other is not null and refers to an IntList\n        IntListVer3 otherIntList = (IntListVer3) other;\n        result = this.size() == otherIntList.size();\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i] == otherIntList.iValues[i];\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"IntListVer3","variables":{"result":8,"other":5,"iSize":1,"otherIntList":2},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other is not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"println":1,"nextInt":1,"close":1,"System.out.println":1},"constants":{"100":1,"\"randInts.txt\"":1,"\"An error occured while trying to write to the file\"":1},"annotations":[],"types":{"PrintStream":1,"Random":1,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":["IOException"],"text":"public static void main(String[] args) {\n    try {\n        PrintStream writer = new PrintStream(new File(\"randInts.txt\"));\n        Random r = new Random();\n        final int LIMIT = 100;\n        for (int i = 0; i < LIMIT; i++) {\n            writer.println(r.nextInt());\n        }\n        writer.close();\n    } catch (IOException e) {\n        System.out.println(\"An error occured while trying to write to the file\");\n    }\n}\n","name":"main","className":"WriteToFile","variables":{"args":1,"LIMIT":2,"writer":3},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"countWordsViaGUI":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    countWordsViaGUI();\n}\n","name":"main","className":"WordCount","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"countWordsWithArrayList":1,"nextLine":2,"toLowerCase":1,"start":1,"getFile":1,"parseInt":1,"stop":1,"showWords":1,"setLookAndFeel":1,"close":2,"System.out.print":2,"charAt":1,"System.out.println":3},"constants":{"\"time to count: \"":1,"'y'":1,"\"Problem reading the data file. Exiting the program.\"":1,"\"Enter number of words to display: \"":1,"\"Opening GUI to choose file.\"":1,"\"Perform another count? \"":1},"annotations":[],"types":{"Scanner":2,"Stopwatch":1,"ArrayList<String>":1,"int":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","CharLiteralExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt","DoStmt"],"concepts":[],"exceptions":["FileNotFoundException"],"text":"// allow user to pick file to exam via GUI.\n// allow multiple picks\npublic static void countWordsViaGUI() {\n    setLookAndFeel();\n    try {\n        Scanner key = new Scanner(System.in);\n        do {\n            System.out.println(\"Opening GUI to choose file.\");\n            Scanner fileScanner = new Scanner(getFile());\n            Stopwatch st = new Stopwatch();\n            st.start();\n            ArrayList<String> words = countWordsWithArrayList(fileScanner);\n            st.stop();\n            System.out.println(\"time to count: \" + st);\n            System.out.print(\"Enter number of words to display: \");\n            int numWordsToShow = Integer.parseInt(key.nextLine());\n            showWords(words, numWordsToShow);\n            fileScanner.close();\n            System.out.print(\"Perform another count? \");\n        } while (key.nextLine().toLowerCase().charAt(0) == 'y');\n        key.close();\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Problem reading the data file. Exiting the program.\" + e);\n    }\n}\n","name":"countWordsViaGUI","className":"WordCount","variables":{"Integer":1,"fileScanner":2,"st":4,"numWordsToShow":1,"words":1,"key":4},"javaDoc":"","comments":" allow multiple picks","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["Scanner"],"returnType":"ArrayList<String>","methodCalls":{"size":1,"System.out.println":2},"constants":{"\"Total number of words: \"":1,"\"number of distincy words: \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// determine distinct words in a file using an array list\nprivate static ArrayList<String> countWordsWithArrayList(Scanner fileScanner) {\n    System.out.println(\"Total number of words: \" + numWords);\n    System.out.println(\"number of distincy words: \" + result.size());\n    return result;\n}\n","name":"countWordsWithArrayList","className":"WordCount","variables":{"result":2,"fileScanner":1,"numWords":1},"javaDoc":"","comments":" determine distinct words in a file using an array list","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["Scanner"],"returnType":"Map<String, Integer>","methodCalls":{"size":1,"System.out.println":2},"constants":{"\"Total number of words: \"":1,"\"number of distincy words: \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// determine distinct words in a file and frequency of each word with a Map\nprivate static Map<String, Integer> countWordsWithMap(Scanner fileScanner) {\n    System.out.println(\"Total number of words: \" + numWords);\n    System.out.println(\"number of distincy words: \" + result.size());\n    return result;\n}\n","name":"countWordsWithMap","className":"WordCount","variables":{"result":2,"fileScanner":1,"numWords":1},"javaDoc":"","comments":" determine distinct words in a file and frequency of each word with a Map","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["ArrayList<String>","int"],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"private static void showWords(ArrayList<String> words, int numWordsToShow) {\n    for (int i = 0; i < words.size() && i < numWordsToShow; i++) System.out.println(words.get(i));\n}\n","name":"showWords","className":"WordCount","variables":{"numWordsToShow":2,"words":3},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["Map<String, Integer>","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"private static void showWords(Map<String, Integer> words, int numWordsToShow) {\n}\n","name":"showWords","className":"WordCount","variables":{"numWordsToShow":1,"words":1},"javaDoc":"","isEmpty":true,"lineCount":0,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"timingExpWithArrayList":2,"timingExpWithMap":2},"constants":{"\"SherlockHolmes.txt\"":1,"\"Alice.txt\"":1,"\"ciaFactBook2008.txt\"":1,"\"smallWords.txt\"":1,"50":2,"\"2BR02B.txt\"":1},"annotations":[],"types":{"String[]":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayInitializerExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["EmptyStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// perform a series of experiments on files. Determine average time to\n// count words in files of various sizes\nprivate static void performExp() {\n    String[] smallerWorks = { \"smallWords.txt\", \"2BR02B.txt\", \"Alice.txt\", \"SherlockHolmes.txt\" };\n    ;\n    String[] bigFile = { \"ciaFactBook2008.txt\" };\n    timingExpWithArrayList(smallerWorks, 50);\n    timingExpWithArrayList(bigFile, 3);\n    timingExpWithMap(smallerWorks, 50);\n    timingExpWithMap(bigFile, 3);\n}\n","name":"performExp","className":"WordCount","variables":{"bigFile":1,"smallerWorks":1},"javaDoc":"","comments":" count words in files of various sizes","isEmpty":false,"lineCount":7,"modifier":10}
{"paramTypes":["String[]","int"],"returnType":"void","methodCalls":{"stop":1,"size":1,"start":1,"time":1,"countWordsWithMap":1,"close":1,"System.out.println":3},"constants":{"\"Problem reading the data file. Exiting the program.\"":1,"50":1},"annotations":[],"types":{"Scanner":1,"double[]":1,"Map<String, Integer>":1,"double":1,"Stopwatch":1,"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["TryStmt","BlockStmt","ForeachStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":["FileNotFoundException"],"text":"// pre: titles != null, elements of titles refer to files in the\n// same path as this program, numExp >= 0\n// read words from files and print average time to cound words.\nprivate static void timingExpWithMap(String[] titles, int numExp) {\n    try {\n        double[] times = new double[titles.length];\n        final int NUM_EXP = 50;\n        for (int i = 0; i < NUM_EXP; i++) {\n            for (int j = 0; j < titles.length; j++) {\n                Scanner fileScanner = new Scanner(new File(titles[j]));\n                Stopwatch st = new Stopwatch();\n                st.start();\n                Map<String, Integer> words = countWordsWithMap(fileScanner);\n                st.stop();\n                System.out.println(words.size());\n                times[j] += st.time();\n                fileScanner.close();\n            }\n        }\n        for (double a : times) System.out.println(a / NUM_EXP);\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Problem reading the data file. Exiting the program.\" + e);\n    }\n}\n","name":"timingExpWithMap","className":"WordCount","variables":{"fileScanner":2,"st":4,"times":3,"words":2,"titles":2,"numExp":1,"NUM_EXP":3},"javaDoc":"","comments":" read words from files and print average time to cound words.","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["String[]","int"],"returnType":"void","methodCalls":{"stop":1,"countWordsWithArrayList":1,"start":1,"time":1,"close":1,"System.out.println":2},"constants":{"\"Problem reading the data file. Exiting the program.\"":1,"\": \"":1,"\"Average time for \"":1},"annotations":[],"types":{"Scanner":1,"double[]":1,"Stopwatch":1,"ArrayList<String>":1,"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","AssignExpr","FieldAccessExpr","EnclosedExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["FileNotFoundException"],"text":"// pre: titles != null, elements of titles refer to files in the\n// same path as this program, numExp >= 0\n// read words from files and print average time to cound words.\nprivate static void timingExpWithArrayList(String[] titles, int numExp) {\n    try {\n        double[] times = new double[titles.length];\n        for (int i = 0; i < numExp; i++) {\n            for (int j = 0; j < titles.length; j++) {\n                Scanner fileScanner = new Scanner(new File(titles[j]));\n                Stopwatch st = new Stopwatch();\n                st.start();\n                ArrayList<String> words = countWordsWithArrayList(fileScanner);\n                st.stop();\n                times[j] += st.time();\n                fileScanner.close();\n            }\n        }\n        for (int i = 0; i < titles.length; i++) System.out.println(\"Average time for \" + titles[i] + \": \" + (times[i] / numExp));\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Problem reading the data file. Exiting the program.\" + e);\n    }\n}\n","name":"timingExpWithArrayList","className":"WordCount","variables":{"fileScanner":2,"st":4,"times":3,"words":1,"titles":3,"numExp":3},"javaDoc":"","comments":" read words from files and print average time to cound words.","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSystemLookAndFeelClassName":1,"setLookAndFeel":1,"System.out.println":1},"constants":{"\"Unable to set look at feel to local settings. \"":1,"\"Continuing with default Java look and feel.\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"// try to set look and feel to same as system\nprivate static void setLookAndFeel() {\n    try {\n        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n    } catch (Exception e) {\n        System.out.println(\"Unable to set look at feel to local settings. \" + \"Continuing with default Java look and feel.\");\n    }\n}\n","name":"setLookAndFeel","className":"WordCount","variables":{"UIManager":2},"javaDoc":"","comments":" try to set look and feel to same as system","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":[],"returnType":"File","methodCalls":{"showOpenDialog":1,"getSelectedFile":1,"grabFocus":1,"setDialogTitle":1},"constants":{"\"Select File To Count Words:\"":1,"null":2,"\".\"":1},"annotations":[],"types":{"JFileChooser":1,"File":1,"int":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","StringLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** Method to choose a file using a window.\n     * @return the file chosen by the user. Returns null if no file picked.\n     */\nprivate static File getFile() {\n    // create a GUI window to pick the text to evaluate\n    JFileChooser chooser = new JFileChooser(\".\");\n    chooser.setDialogTitle(\"Select File To Count Words:\");\n    int retval = chooser.showOpenDialog(null);\n    File f = null;\n    chooser.grabFocus();\n    if (retval == JFileChooser.APPROVE_OPTION)\n        f = chooser.getSelectedFile();\n    return f;\n}\n","name":"getFile","className":"WordCount","variables":{"chooser":5,"retval":2},"javaDoc":"Method to choose a file using a window the file chosen by the user Returns null if no file picked","comments":"create a GUI window to pick the text to evaluate  Method to choose a file using a window.\n     * @return the file chosen by the user. Returns null if no file picked.\n     ","isEmpty":false,"lineCount":7,"modifier":10}
{"paramTypes":["String","String","String","int","double","boolean","double"],"returnType":"FullTime","methodCalls":{},"constants":{"12":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExplicitConstructorInvocationStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public FullTime(String firstname, String lastname, String id, int credits, double rate, boolean resident, double programFee) {\n    super(firstname, lastname, id, credits, rate);\n    this.resident = resident;\n    if (resident) {\n        creditUpperbound = 7;\n    } else {\n        creditUpperbound = 12;\n    }\n    studentProgramFee = programFee;\n}\n","name":"FullTime","className":"FullTime","variables":{"studentProgramFee":1,"firstname":2,"programFee":2,"credits":2,"rate":2,"id":2,"creditUpperbound":2,"lastname":2,"resident":3},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":["Override"],"types":{},"expressions":["BinaryExpr","NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"@Override\npublic void computeTuition() {\n    this.tuition = rate * creditUpperbound + studentProgramFee;\n}\n","name":"computeTuition","className":"FullTime","variables":{"studentProgramFee":1,"rate":1,"creditUpperbound":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":2,"getCurrencyInstance":1},"constants":{"\"\\nOnCampus Student:\"":2,"\"\\nNonResident Status\"":1,"\"Student Program Fee:\\t\"":2,"\"\\nResident Status\"":1,"\"\\n\"":4},"annotations":[],"types":{"NumberFormat":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","ThisExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    NumberFormat format = NumberFormat.getCurrencyInstance();\n    if (resident) {\n        return \"\\nOnCampus Student:\" + \"\\nResident Status\" + this.toString() + \"Student Program Fee:\\t\" + format.format(studentProgramFee) + \"\\n\" + \"\\n\";\n    } else {\n        return \"\\nOnCampus Student:\" + \"\\nNonResident Status\" + this.toString() + \"Student Program Fee:\\t\" + format.format(studentProgramFee) + \"\\n\" + \"\\n\";\n    }\n}\n","name":"toString","className":"FullTime","variables":{"format":3,"NumberFormat":1,"resident":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"length":2,"generator":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"temp":2},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int","int"],"returnType":"int","methodCalls":{"search":2},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","EnclosedExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Finds a value in a range of a sorted array, using the binary\n      search algorithm.\n      @param a the array in which to search\n      @param low the low index of the range\n      @param high the high index of the range\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   */\npublic static int search(int[] a, int low, int high, int value) {\n    if (low <= high) {\n        int mid = (low + high) / 2;\n        if (a[mid] == value) {\n            return mid;\n        } else if (a[mid] < value) {\n            return search(a, mid + 1, high, value);\n        } else {\n            return search(a, low, mid - 1, value);\n        }\n    } else {\n        return -1;\n    }\n}\n","name":"search","className":"BinarySearcher","variables":{"high":3,"low":3,"mid":6,"value":3},"javaDoc":"Finds a value in a range of a sorted array using the binary search algorithm a the array in which to search low the low index of the range high the high index of the range value the value to find the index at which the value occurs or -1 if it does not occur in the array","comments":"\n      Finds a value in a range of a sorted array, using the binary\n      search algorithm.\n      @param a the array in which to search\n      @param low the low index of the range\n      @param high the high index of the range\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"search":1,"randomIntArray":1,"toString":1,"sort":1,"nextInt":1,"System.out.print":1,"System.out.println":2},"constants":{"100":1,"\"Enter number to search for, -1 to quit: \"":1,"false":1,"true":1,"\"Found in position \"":1,"20":1},"annotations":[],"types":{"Scanner":1,"boolean":1,"int[]":1,"int":2},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    Arrays.sort(a);\n    System.out.println(Arrays.toString(a));\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"Enter number to search for, -1 to quit: \");\n        int n = in.nextInt();\n        if (n == -1) {\n            done = true;\n        } else {\n            int pos = BinarySearcher.search(a, 0, a.length - 1, n);\n            System.out.println(\"Found in position \" + pos);\n        }\n    }\n}\n","name":"main","className":"BinarySearchDemo","variables":{"args":1,"BinarySearcher":1,"in":2,"pos":2,"Arrays":2,"done":3,"ArrayUtil":1},"javaDoc":"","comments":"Construct random array ","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"constants":{"true":1},"annotations":[],"types":{},"expressions":["BooleanLiteralExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"constants":{"false":1},"annotations":[],"types":{"long":1},"expressions":["VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"constants":{},"annotations":[],"types":{"long":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{"false":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BooleanLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"length":2,"generator":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"temp":2},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"stop":1,"start":1,"nextInt":1,"sort":1,"System.out.print":1,"getElapsedTime":1,"System.out.println":1},"constants":{"100":1,"\" milliseconds\"":1,"\"Enter array size: \"":1,"\"Elapsed time: \"":1},"annotations":[],"types":{"Scanner":1,"int[]":1,"int":1,"StopWatch":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter array size: \");\n    int n = in.nextInt();\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(n, 100);\n    // Use stopwatch to time selection sort\n    StopWatch timer = new StopWatch();\n    timer.start();\n    SelectionSorter.sort(a);\n    timer.stop();\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"SelectionSortTimer","variables":{"args":1,"timer":4,"in":2,"SelectionSorter":1,"ArrayUtil":1},"javaDoc":"","comments":"Construct random array Use stopwatch to time selection sort ","isEmpty":false,"lineCount":11,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"swap":1,"minimumPosition":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        int minPos = minimumPosition(a, i);\n        ArrayUtil.swap(a, minPos, i);\n    }\n}\n","name":"sort","className":"SelectionSorter","variables":{"minPos":1,"ArrayUtil":1},"javaDoc":"Sorts an array using selection sort a the array to sort","comments":"\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   */\nprivate static int minimumPosition(int[] a, int from) {\n    int minPos = from;\n    for (int i = from + 1; i < a.length; i++) {\n        if (a[i] < a[minPos]) {\n            minPos = i;\n        }\n    }\n    return minPos;\n}\n","name":"minimumPosition","className":"SelectionSorter","variables":{"minPos":4,"from":3},"javaDoc":"Finds the smallest element in a tail range of the array a the array to sort from the first position in a to compare the position of the smallest element in the range a[from] a[a length - 1]","comments":"\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":3,"comparing":2,"toString":3,"sort":3,"getArea":1,"System.out.println":3},"constants":{"\"Thailand\"":1,"\"a\"":1,"513120":1,"\"Belgium\"":1,"\"little\"":1,"\"Mary\"":1,"\"Uruguay\"":1,"\"was\"":1,"\"snow\"":1,"\"lamb\"":1,"30510":1,"\"white\"":1,"\"fleece\"":1,"\"had\"":1,"176220":1,"\"Its\"":1,"\"as\"":1},"annotations":[],"types":{"Country[]":1,"String[]":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","LambdaExpr","BinaryExpr","StringLiteralExpr","NameExpr","AssignExpr","ArrayInitializerExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    String[] words = { \"Mary\", \"had\", \"a\", \"little\", \"lamb\" };\n    Arrays.sort(words, ( v,  w) -> v.length() - w.length());\n    System.out.println(Arrays.toString(words));\n    words = new String[] { \"Its\", \"fleece\", \"was\", \"white\", \"as\", \"snow\" };\n    Arrays.sort(words, Comparator.comparing( w -> w.length()));\n    System.out.println(Arrays.toString(words));\n    Country[] countries = new Country[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    Arrays.sort(countries, Comparator.comparing( c -> c.getArea()));\n    System.out.println(Arrays.toString(countries));\n}\n","name":"main","className":"ComparatorDemo","variables":{"args":1,"words":2,"countries":4,"Arrays":6,"Comparator":2},"javaDoc":"","isEmpty":false,"lineCount":12,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":2,"name":1,"anArea":2},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"]\"":1,"\",area=\"":1,"\"Country[name=\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"Country[name=\" + name + \",area=\" + area + \"]\";\n}\n","name":"toString","className":"Country","variables":{"area":1,"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"merge":1,"sort":2},"constants":{},"annotations":[],"types":{"int[]":2,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ForStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Sorts an array, using merge sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    if (a.length <= 1) {\n        return;\n    }\n    int[] first = new int[a.length / 2];\n    int[] second = new int[a.length - first.length];\n    // Copy the first half of a into first, the second half into second\n    for (int i = 0; i < first.length; i++) {\n        first[i] = a[i];\n    }\n    for (int i = 0; i < second.length; i++) {\n        second[i] = a[first.length + i];\n    }\n    sort(first);\n    sort(second);\n    merge(first, second, a);\n}\n","name":"sort","className":"MergeSorter","variables":{"first":2,"second":2},"javaDoc":"Sorts an array using merge sort a the array to sort","comments":"Copy the first half of a into first the second half into second \n      Sorts an array, using merge sort.\n      @param a the array to sort\n   ","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["int[]","int[]","int[]"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   */\nprivate static void merge(int[] first, int[] second, int[] a) {\n    // Next element to consider in the first array\n    int iFirst = 0;\n    // Next element to consider in the second array\n    int iSecond = 0;\n    // Next open position in a\n    int j = 0;\n    // the smaller element into a\n    while (iFirst < first.length && iSecond < second.length) {\n        if (first[iFirst] < second[iSecond]) {\n            a[j] = first[iFirst];\n            iFirst++;\n        } else {\n            a[j] = second[iSecond];\n            iSecond++;\n        }\n        j++;\n    }\n    // Copy any remaining entries of the first array\n    while (iFirst < first.length) {\n        a[j] = first[iFirst];\n        iFirst++;\n        j++;\n    }\n    // Copy any remaining entries of the second half\n    while (iSecond < second.length) {\n        a[j] = second[iSecond];\n        iSecond++;\n        j++;\n    }\n}\n","name":"merge","className":"MergeSorter","variables":{"iSecond":8,"first":4,"second":4,"iFirst":8},"javaDoc":"Merges two sorted arrays into an array first the first sorted array second the second sorted array a the array into which to merge first and second","comments":"As long as neither iFirst nor iSecond is past the end move Note that only one of the two loops below copies entries Next element to consider in the first array Next element to consider in the second array Next open position in a the smaller element into a Copy any remaining entries of the first array Copy any remaining entries of the second half \n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   ","isEmpty":false,"lineCount":8,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"stop":1,"start":1,"nextInt":1,"sort":1,"System.out.print":1,"getElapsedTime":1,"System.out.println":1},"constants":{"100":1,"\" milliseconds\"":1,"\"Enter array size: \"":1,"\"Elapsed time: \"":1},"annotations":[],"types":{"Scanner":1,"int[]":1,"int":1,"StopWatch":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter array size: \");\n    int n = in.nextInt();\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(n, 100);\n    // Use stopwatch to time merge sort\n    StopWatch timer = new StopWatch();\n    timer.start();\n    MergeSorter.sort(a);\n    timer.stop();\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"MergeSortTimer","variables":{"args":1,"timer":4,"in":2,"MergeSorter":1,"ArrayUtil":1},"javaDoc":"","comments":"Construct random array Use stopwatch to time merge sort ","isEmpty":false,"lineCount":11,"modifier":9}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"constants":{"true":1},"annotations":[],"types":{},"expressions":["BooleanLiteralExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"constants":{"false":1},"annotations":[],"types":{"long":1},"expressions":["VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"constants":{},"annotations":[],"types":{"long":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{"false":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BooleanLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"length":2,"generator":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"temp":2},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"search":1,"randomIntArray":1,"toString":1,"nextInt":1,"System.out.print":1,"System.out.println":2},"constants":{"100":1,"\"Enter number to search for, -1 to quit: \"":1,"false":1,"true":1,"\"Found in position \"":1,"20":1},"annotations":[],"types":{"Scanner":1,"boolean":1,"int[]":1,"int":2},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"Enter number to search for, -1 to quit: \");\n        int n = in.nextInt();\n        if (n == -1) {\n            done = true;\n        } else {\n            int pos = LinearSearcher.search(a, n);\n            System.out.println(\"Found in position \" + pos);\n        }\n    }\n}\n","name":"main","className":"LinearSearchDemo","variables":{"args":1,"in":2,"pos":2,"Arrays":1,"done":3,"LinearSearcher":1,"ArrayUtil":1},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"length":2,"generator":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"temp":2},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   */\npublic static int search(int[] a, int value) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] == value) {\n            return i;\n        }\n    }\n    return -1;\n}\n","name":"search","className":"LinearSearcher","variables":{"value":2},"javaDoc":"Finds a value in an array using the linear search algorithm a the array to search value the value to find the index at which the value occurs or -1 if it does not occur in the array","comments":"\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"length":2,"generator":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"temp":2},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"constants":{"100":1,"20":1},"annotations":[],"types":{"int[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    QuickSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"QuickSortDemo","variables":{"args":1,"QuickSorter":1,"Arrays":2,"ArrayUtil":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"sort":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Sorts an array, using quick sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    sort(a, 0, a.length - 1);\n}\n","name":"sort","className":"QuickSorter","variables":{},"javaDoc":"Sorts an array using quick sort a the array to sort","comments":"\n      Sorts an array, using quick sort.\n      @param a the array to sort\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{"partition":1,"sort":2},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Sorts a portion of an array, using quick sort.\n      @param a the array to sort\n      @param from the first index of the portion to be sorted\n      @param to the last index of the portion to be sorted\n   */\npublic static void sort(int[] a, int from, int to) {\n    if (from >= to) {\n        return;\n    }\n    int p = partition(a, from, to);\n    sort(a, from, p);\n    sort(a, p + 1, to);\n}\n","name":"sort","className":"QuickSorter","variables":{"from":2,"to":2},"javaDoc":"Sorts a portion of an array using quick sort a the array to sort from the first index of the portion to be sorted to the last index of the portion to be sorted","comments":"\n      Sorts a portion of an array, using quick sort.\n      @param a the array to sort\n      @param from the first index of the portion to be sorted\n      @param to the last index of the portion to be sorted\n   ","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"int","methodCalls":{"swap":1},"constants":{},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Partitions a portion of an array.\n      @param a the array to partition\n      @param from the first index of the portion to be partitioned\n      @param to the last index of the portion to be partitioned\n      @return the last index of the first partition\n   */\nprivate static int partition(int[] a, int from, int to) {\n    int pivot = a[from];\n    int i = from - 1;\n    int j = to + 1;\n    while (i < j) {\n        i++;\n        while (a[i] < pivot) {\n            i++;\n        }\n        j--;\n        while (a[j] > pivot) {\n            j--;\n        }\n        if (i < j) {\n            ArrayUtil.swap(a, i, j);\n        }\n    }\n    return j;\n}\n","name":"partition","className":"QuickSorter","variables":{"pivot":3,"from":3,"to":2,"ArrayUtil":1},"javaDoc":"Partitions a portion of an array a the array to partition from the first index of the portion to be partitioned to the last index of the portion to be partitioned the last index of the first partition","comments":"\n      Partitions a portion of an array.\n      @param a the array to partition\n      @param from the first index of the portion to be partitioned\n      @param to the last index of the portion to be partitioned\n      @return the last index of the first partition\n   ","isEmpty":false,"lineCount":5,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"stop":3,"equals":1,"start":3,"reset":2,"nextInt":1,"sort":3,"copyOf":2,"System.out.print":1,"getElapsedTime":3,"System.out.println":3},"constants":{"100":1,"\"Elapsed time with insertion sort: \"":1,"\"Incorrect sort result\"":1,"\" milliseconds\"":3,"\"Elapsed time with Shell sort: \"":1,"\"Enter array size: \"":1,"\"Elapsed time with Arrays.sort: \"":1},"annotations":[],"types":{"Scanner":1,"int[]":3,"int":1,"StopWatch":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter array size: \");\n    int n = in.nextInt();\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(n, 100);\n    int[] a2 = Arrays.copyOf(a, a.length);\n    int[] a3 = Arrays.copyOf(a, a.length);\n    // Use stopwatch to time selection sort\n    StopWatch timer = new StopWatch();\n    timer.start();\n    ShellSorter.sort(a);\n    timer.stop();\n    System.out.println(\"Elapsed time with Shell sort: \" + timer.getElapsedTime() + \" milliseconds\");\n    timer.reset();\n    timer.start();\n    Arrays.sort(a2);\n    timer.stop();\n    System.out.println(\"Elapsed time with Arrays.sort: \" + timer.getElapsedTime() + \" milliseconds\");\n    if (!Arrays.equals(a, a2)) {\n        throw new IllegalStateException(\"Incorrect sort result\");\n    }\n    timer.reset();\n    timer.start();\n    InsertionSorter.sort(a3);\n    timer.stop();\n    System.out.println(\"Elapsed time with insertion sort: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"ShellSortTimer","variables":{"args":1,"a2":1,"timer":12,"a3":1,"ShellSorter":1,"in":2,"Arrays":4,"InsertionSorter":1,"ArrayUtil":1},"javaDoc":"","comments":"Construct random array Use stopwatch to time selection sort ","isEmpty":false,"lineCount":24,"modifier":9}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"constants":{"true":1},"annotations":[],"types":{},"expressions":["BooleanLiteralExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"constants":{"false":1},"annotations":[],"types":{"long":1},"expressions":["VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"constants":{},"annotations":[],"types":{"long":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{"false":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BooleanLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"length":2,"generator":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"temp":2},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"constants":{"100":1,"20":1},"annotations":[],"types":{"int[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    ShellSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"ShellSortDemo","variables":{"args":1,"ShellSorter":1,"Arrays":2,"ArrayUtil":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 1; i < a.length; i++) {\n        int next = a[i];\n        // Move all larger elements up\n        int j = i;\n        while (j > 0 && a[j - 1] > next) {\n            a[j] = a[j - 1];\n            j--;\n        }\n        // Insert the element\n        a[j] = next;\n    }\n}\n","name":"sort","className":"InsertionSorter","variables":{"next":3},"javaDoc":"Sorts an array using insertion sort a the array to sort","comments":"Move all larger elements up Insert the element \n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"add":1,"size":1,"insertionSort":1,"get":1},"constants":{},"annotations":[],"types":{"ArrayList<Integer>":1,"int":3},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sorts an array, using Shell sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    // Generate the sequence values\n    ArrayList<Integer> columns = new ArrayList<Integer>();\n    int c = 1;\n    while (c < a.length) {\n        columns.add(c);\n        c = 3 * c + 1;\n    }\n    // For each column count, sort all columns\n    for (int s = columns.size() - 1; s >= 0; s--) {\n        c = columns.get(s);\n        for (int k = 0; k < c; k++) {\n            insertionSort(a, k, c);\n        }\n    }\n}\n","name":"sort","className":"ShellSorter","variables":{"columns":4},"javaDoc":"Sorts an array using Shell sort a the array to sort","comments":"Generate the sequence values For each column count sort all columns \n      Sorts an array, using Shell sort.\n      @param a the array to sort\n   ","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":3},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sorts a column, using insertion sort.\n      @param a the array to sort\n      @param k the index of the first element in the column\n      @param c the gap between elements in the column\n   */\npublic static void insertionSort(int[] a, int k, int c) {\n    for (int i = k + c; i < a.length; i = i + c) {\n        int next = a[i];\n        // Move all larger elements up\n        int j = i;\n        while (j >= c && a[j - c] > next) {\n            a[j] = a[j - c];\n            j = j - c;\n        }\n        // Insert the element\n        a[j] = next;\n    }\n}\n","name":"insertionSort","className":"ShellSorter","variables":{"next":3},"javaDoc":"Sorts a column using insertion sort a the array to sort k the index of the first element in the column c the gap between elements in the column","comments":"Move all larger elements up Insert the element \n      Sorts a column, using insertion sort.\n      @param a the array to sort\n      @param k the index of the first element in the column\n      @param c the gap between elements in the column\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"length":2,"generator":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"temp":2},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"constants":{"100":1,"20":1},"annotations":[],"types":{"int[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    InsertionSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"InsertionSortDemo","variables":{"args":1,"Arrays":2,"InsertionSorter":1,"ArrayUtil":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 1; i < a.length; i++) {\n        int next = a[i];\n        // Move all larger elements up\n        int j = i;\n        while (j > 0 && a[j - 1] > next) {\n            a[j] = a[j - 1];\n            j--;\n        }\n        // Insert the element\n        a[j] = next;\n    }\n}\n","name":"sort","className":"InsertionSorter","variables":{"next":3},"javaDoc":"Sorts an array using insertion sort a the array to sort","comments":"Move all larger elements up Insert the element \n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"constants":{"100":1,"20":1},"annotations":[],"types":{"int[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    SelectionSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"SelectionSortDemo","variables":{"args":1,"SelectionSorter":1,"Arrays":2,"ArrayUtil":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"length":2,"generator":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"temp":2},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"swap":1,"minimumPosition":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        int minPos = minimumPosition(a, i);\n        ArrayUtil.swap(a, minPos, i);\n    }\n}\n","name":"sort","className":"SelectionSorter","variables":{"minPos":1,"ArrayUtil":1},"javaDoc":"Sorts an array using selection sort a the array to sort","comments":"\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   */\nprivate static int minimumPosition(int[] a, int from) {\n    int minPos = from;\n    for (int i = from + 1; i < a.length; i++) {\n        if (a[i] < a[minPos]) {\n            minPos = i;\n        }\n    }\n    return minPos;\n}\n","name":"minimumPosition","className":"SelectionSorter","variables":{"minPos":4,"from":3},"javaDoc":"Finds the smallest element in a tail range of the array a the array to sort from the first position in a to compare the position of the smallest element in the range a[from] a[a length - 1]","comments":"\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"constants":{"true":1},"annotations":[],"types":{},"expressions":["BooleanLiteralExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"constants":{"false":1},"annotations":[],"types":{"long":1},"expressions":["VariableDeclarationExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"constants":{},"annotations":[],"types":{"long":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{"false":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BooleanLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"size":1,"stop":2,"get":2,"start":2,"mostFrequent2":1,"mostFrequent1":1,"reset":1,"shuffle":1,"getElapsedTime":2,"System.out.println":6},"constants":{"300":1,"\" milliseconds\"":2,"\"Expected: \"":2,"\"Elapsed time: \"":2},"annotations":[],"types":{"ArrayList<Integer>":1,"int[]":1,"int":6,"StopWatch":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","ArrayCreationExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    ArrayList<Integer> values = new ArrayList<Integer>();\n    int k = 300;\n    // Adds one times 1, two times 2, three times 3, ... , k times k\n    for (int i = 1; i <= k; i++) {\n        for (int j = 1; j <= i; j++) {\n            values.add(i);\n        }\n    }\n    // This method shuffles the array list randomly\n    Collections.shuffle(values);\n    StopWatch timer = new StopWatch();\n    int[] a = new int[values.size()];\n    // of the algorithm\n    for (int i = 0; i < a.length; i++) {\n        a[i] = values.get(i);\n    }\n    timer.start();\n    int result = mostFrequent1(a);\n    timer.stop();\n    System.out.println(result);\n    System.out.println(\"Expected: \" + k);\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n    // Copies the same values and runs the second version     \n    for (int i = 0; i < a.length; i++) {\n        a[i] = values.get(i);\n    }\n    timer.reset();\n    timer.start();\n    result = mostFrequent2(a);\n    timer.stop();\n    System.out.println(result);\n    System.out.println(\"Expected: \" + k);\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"MostFrequent","variables":{"args":1,"result":2,"timer":8,"values":5,"Collections":1},"javaDoc":"","comments":"Copies the values into an array and runs the first version Adds one times 1 two times 2 three times 3 k times k This method shuffles the array list randomly of the algorithm Copies the same values and runs the second version ","isEmpty":false,"lineCount":22,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{"search":1,"max":1,"count":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   */\npublic static int mostFrequent1(int[] a) {\n    int[] counts = new int[a.length];\n    for (// O(n*n)\n    int i = 0; // O(n*n)\n    i < a.length; // O(n*n)\n    i++) {\n        // O(n) in each iteration\n        counts[i] = count(a, a[i]);\n    }\n    // O(n)\n    int highestFrequency = max(counts);\n    // O(n)\n    int highestFrequencyIndex = search(counts, highestFrequency);\n    return a[highestFrequencyIndex];\n}\n","name":"mostFrequent1","className":"MostFrequent","variables":{"counts":2,"highestFrequencyIndex":2,"highestFrequency":1},"javaDoc":"Returns the most frequently occurring value in an array a an array the most frequently occurring value in a","comments":"O(n n) O(n n) O(n n) O(n) in each iteration O(n) O(n) \n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{"search":1,"max":1,"sort":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":4},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   */\npublic static int mostFrequent2(int[] a) {\n    // O(n log(n))\n    Arrays.sort(a);\n    int[] counts = new int[a.length];\n    int count = 0;\n    for (// O(n)\n    int i = 0; // O(n)\n    i < a.length; // O(n)\n    i++) {\n        count++;\n        if (i == a.length - 1 || a[i] != a[i + 1]) {\n            counts[i] = count;\n            count = 0;\n        }\n    }\n    // O(n)\n    int highestFrequency = max(counts);\n    // O(n)\n    int highestFrequencyIndex = search(counts, highestFrequency);\n    return a[highestFrequencyIndex];\n}\n","name":"mostFrequent2","className":"MostFrequent","variables":{"counts":2,"count":4,"highestFrequencyIndex":2,"Arrays":1,"highestFrequency":1},"javaDoc":"Returns the most frequently occurring value in an array a an array the most frequently occurring value in a","comments":"O(n log(n)) O(n) O(n) O(n) O(n) O(n) \n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   ","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Counts how often a value occurs in an array.\n      @param a the array\n      @param value the value to count\n      @return the number of occurrences of value in a\n   */\npublic static int count(int[] a, int value) {\n    int count = 0;\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] == value) {\n            count++;\n        }\n    }\n    return count;\n}\n","name":"count","className":"MostFrequent","variables":{"count":3,"value":2},"javaDoc":"Counts how often a value occurs in an array a the array value the value to count the number of occurrences of value in a","comments":"\n      Counts how often a value occurs in an array.\n      @param a the array\n      @param value the value to count\n      @return the number of occurrences of value in a\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the largest value of an array.\n      @param a the array\n      @return the largest value in a\n   */\npublic static int max(int[] values) {\n    int largest = values[0];\n    for (int i = 1; i < values.length; i++) {\n        if (values[i] > largest) {\n            largest = values[i];\n        }\n    }\n    return largest;\n}\n","name":"max","className":"MostFrequent","variables":{"largest":4,"values":4},"javaDoc":"Computes the largest value of an array a the array the largest value in a","comments":"\n      Computes the largest value of an array.\n      @param a the array\n      @return the largest value in a\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   */\npublic static int search(int[] a, int value) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] == value) {\n            return i;\n        }\n    }\n    return -1;\n}\n","name":"search","className":"MostFrequent","variables":{"value":2},"javaDoc":"Finds a value in an array using the linear search algorithm a the array to search value the value to find the index at which the value occurs or -1 if it does not occur in the array","comments":"\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":2,"name":1,"anArea":2},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{"Country":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","CastExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public int compareTo(Object otherObject) {\n    Country other = (Country) otherObject;\n    if (area < other.area) {\n        return -1;\n    } else if (area == other.area) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n","name":"compareTo","className":"Country","variables":{"area":2,"other":1,"otherObject":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"constants":{"\"[name=\"":1,"\"]\"":1,"\",area=\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \",area=\" + area + \"]\";\n}\n","name":"toString","className":"Country","variables":{"area":1,"name":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"toString":1,"sort":2,"binarySearch":2,"System.out.println":4},"constants":{"\"Thailand\"":1,"\"Position for inserting 7: \"":1,"30510":1,"\"Belgium\"":1,"514000":1,"\"Position of 4: \"":1,"\"Uruguay\"":1,"176220":1},"annotations":[],"types":{"ArrayList<Country>":1,"Country":3,"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayInitializerExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","EnclosedExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] values = { 1, 4, 9, 1, 6, 2, 5, 3, 6, 4, 9, 6, 4, 8, 1 };\n    Arrays.sort(values);\n    System.out.println(Arrays.toString(values));\n    int pos = Arrays.binarySearch(values, 4);\n    System.out.println(\"Position of 4: \" + pos);\n    pos = Arrays.binarySearch(values, 7);\n    System.out.println(\"Position for inserting 7: \" + (-pos - 1));\n    Country country1 = new Country(\"Belgium\", 30510);\n    Country country2 = new Country(\"Thailand\", 514000);\n    Country country3 = new Country(\"Uruguay\", 176220);\n    ArrayList<Country> countries = new ArrayList<Country>();\n    countries.add(country1);\n    countries.add(country2);\n    countries.add(country3);\n    Collections.sort(countries);\n    System.out.println(countries);\n}\n","name":"main","className":"JavaLibraryDemo","variables":{"args":1,"pos":4,"values":1,"country1":1,"countries":4,"Arrays":4,"Collections":1,"country3":1,"country2":1},"javaDoc":"","isEmpty":false,"lineCount":16,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"merge":1,"sort":2},"constants":{},"annotations":[],"types":{"int[]":2,"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ForStmt","ExpressionStmt"],"concepts":["Recursion"],"exceptions":[],"text":"/**\n      Sorts an array, using merge sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    if (a.length <= 1) {\n        return;\n    }\n    int[] first = new int[a.length / 2];\n    int[] second = new int[a.length - first.length];\n    // Copy the first half of a into first, the second half into second\n    for (int i = 0; i < first.length; i++) {\n        first[i] = a[i];\n    }\n    for (int i = 0; i < second.length; i++) {\n        second[i] = a[first.length + i];\n    }\n    sort(first);\n    sort(second);\n    merge(first, second, a);\n}\n","name":"sort","className":"MergeSorter","variables":{"first":2,"second":2},"javaDoc":"Sorts an array using merge sort a the array to sort","comments":"Copy the first half of a into first the second half into second \n      Sorts an array, using merge sort.\n      @param a the array to sort\n   ","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["int[]","int[]","int[]"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   */\nprivate static void merge(int[] first, int[] second, int[] a) {\n    // Next element to consider in the first array\n    int iFirst = 0;\n    // Next element to consider in the second array\n    int iSecond = 0;\n    // Next open position in a\n    int j = 0;\n    // the smaller element into a\n    while (iFirst < first.length && iSecond < second.length) {\n        if (first[iFirst] < second[iSecond]) {\n            a[j] = first[iFirst];\n            iFirst++;\n        } else {\n            a[j] = second[iSecond];\n            iSecond++;\n        }\n        j++;\n    }\n    // Copy any remaining entries of the first array\n    while (iFirst < first.length) {\n        a[j] = first[iFirst];\n        iFirst++;\n        j++;\n    }\n    // Copy any remaining entries of the second half\n    while (iSecond < second.length) {\n        a[j] = second[iSecond];\n        iSecond++;\n        j++;\n    }\n}\n","name":"merge","className":"MergeSorter","variables":{"iSecond":8,"first":4,"second":4,"iFirst":8},"javaDoc":"Merges two sorted arrays into an array first the first sorted array second the second sorted array a the array into which to merge first and second","comments":"As long as neither iFirst nor iSecond is past the end move Note that only one of the two loops below copies entries Next element to consider in the first array Next element to consider in the second array Next open position in a the smaller element into a Copy any remaining entries of the first array Copy any remaining entries of the second half \n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   ","isEmpty":false,"lineCount":8,"modifier":10}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"length":2,"generator":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"temp":2},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"constants":{"100":1,"20":1},"annotations":[],"types":{"int[]":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    MergeSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"MergeSortDemo","variables":{"args":1,"Arrays":2,"MergeSorter":1,"ArrayUtil":1},"javaDoc":"","isEmpty":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createStatement":1,"init":1,"getConnection":1,"nextLine":1,"hasNextLine":1,"getResultSet":1,"showResultSet":1,"execute":1,"System.out.println":2},"constants":{"\"Usage: java -classpath driver_class_path\"":1,"\". ExecSQL propertiesFile [SQLcommandFile]\"":1},"annotations":[],"types":{"Scanner":1,"boolean":1,"Statement":1,"Connection":1,"ResultSet":1,"String":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","TryStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"text":"public static void main(String[] args) throws SQLException, IOException, ClassNotFoundException {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". ExecSQL propertiesFile [SQLcommandFile]\");\n        return;\n    }\n    SimpleDataSource.init(args[0]);\n    Scanner in;\n    if (args.length > 1) {\n        in = new Scanner(new File(args[1]));\n    } else {\n        in = new Scanner(System.in);\n    }\n    try (Connection conn = SimpleDataSource.getConnection();\n        Statement stat = conn.createStatement()) {\n        while (in.hasNextLine()) {\n            String line = in.nextLine();\n            try {\n                boolean hasResultSet = stat.execute(line);\n                if (hasResultSet) {\n                    try (ResultSet result = stat.getResultSet()) {\n                        showResultSet(result);\n                    }\n                }\n            } catch (SQLException ex) {\n                System.out.println(ex);\n            }\n        }\n    }\n}\n","name":"main","className":"ExecSQL","variables":{"args":3,"result":1,"conn":2,"stat":3,"ex":1,"in":5,"hasResultSet":2,"SimpleDataSource":2,"line":1},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["ResultSet"],"returnType":"void","methodCalls":{"next":1,"getColumnLabel":1,"getColumnCount":1,"getString":1,"getMetaData":1,"System.out.print":4,"System.out.println":2},"constants":{"\", \"":2},"annotations":[],"types":{"ResultSetMetaData":1,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Prints a result set.\n      @param result the result set\n   */\npublic static void showResultSet(ResultSet result) throws SQLException {\n    ResultSetMetaData metaData = result.getMetaData();\n    int columnCount = metaData.getColumnCount();\n    for (int i = 1; i <= columnCount; i++) {\n        if (i > 1) {\n            System.out.print(\", \");\n        }\n        System.out.print(metaData.getColumnLabel(i));\n    }\n    System.out.println();\n    while (result.next()) {\n        for (int i = 1; i <= columnCount; i++) {\n            if (i > 1) {\n                System.out.print(\", \");\n            }\n            System.out.print(result.getString(i));\n        }\n        System.out.println();\n    }\n}\n","name":"showResultSet","className":"ExecSQL","variables":{"result":4,"metaData":3,"columnCount":3},"javaDoc":"Prints a result set result the result set","comments":"\n      Prints a result set.\n      @param result the result set\n   ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"annotations":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException","ClassNotFoundException"],"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":2,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"init":1,"getConnection":1,"printStackTrace":3,"System.out.println":4,"addInvoice":1},"constants":{"\"Usage: java -classpath driver_class_path\"":1,"\". InvoiceEntry propertiesFile\"":1,"\"Error loading database driver\"":1,"\"Database error\"":1,"\"Error loading database properties\"":1},"annotations":[],"types":{"Scanner":1,"Connection":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"text":"public static void main(String args[]) {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". InvoiceEntry propertiesFile\");\n        return;\n    }\n    try {\n        SimpleDataSource.init(args[0]);\n        try (Connection conn = SimpleDataSource.getConnection();\n            Scanner in = new Scanner(System.in)) {\n            addInvoice(in, conn);\n        }\n    } catch (SQLException ex) {\n        System.out.println(\"Database error\");\n        ex.printStackTrace();\n    } catch (ClassNotFoundException ex) {\n        System.out.println(\"Error loading database driver\");\n        ex.printStackTrace();\n    } catch (IOException ex) {\n        System.out.println(\"Error loading database properties\");\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"InvoiceEntry","variables":{"args":2,"conn":1,"ex":6,"in":1,"SimpleDataSource":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["Scanner","Connection"],"returnType":"void","methodCalls":{"nextLine":1,"listProducts":1,"showInvoice":1,"addLineItem":1,"prepareStatement":1,"nextInt":1,"setInt":2,"findProduct":1,"newCustomer":1,"equals":2,"getNewId":1,"executeUpdate":1,"System.out.println":1},"constants":{"\"D\"":1,"\"Quantity\"":1,"\"Invoice\"":1,"\"Product code (D=Done, L=List)\"":1,"\"Invalid product code.\"":1,"false":1,"true":1,"\"L\"":1,"\"INSERT INTO Invoice VALUES (?, ?, 0)\"":1},"annotations":[],"types":{"boolean":1,"PreparedStatement":1,"String":1,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"public static void addInvoice(Scanner in, Connection conn) throws SQLException {\n    int customerNumber = newCustomer(conn, in);\n    int id = getNewId(conn, \"Invoice\");\n    try (PreparedStatement stat = conn.prepareStatement(\"INSERT INTO Invoice VALUES (?, ?, 0)\")) {\n        stat.setInt(1, id);\n        stat.setInt(2, customerNumber);\n        stat.executeUpdate();\n    }\n    boolean done = false;\n    while (!done) {\n        String productCode = nextLine(in, \"Product code (D=Done, L=List)\");\n        if (productCode.equals(\"D\")) {\n            done = true;\n        } else if (productCode.equals(\"L\")) {\n            listProducts(conn);\n        } else if (findProduct(conn, productCode)) {\n            int quantity = nextInt(in, \"Quantity\");\n            addLineItem(conn, id, productCode, quantity);\n        } else {\n            System.out.println(\"Invalid product code.\");\n        }\n    }\n    showInvoice(conn, id);\n}\n","name":"addInvoice","className":"InvoiceEntry","variables":{"conn":2,"stat":4,"productCode":3,"quantity":1,"in":1,"id":1,"customerNumber":1,"done":3},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["Connection","Scanner"],"returnType":"int","methodCalls":{"setString":5,"nextLine":5,"prepareStatement":1,"getNewId":1,"setInt":1,"executeUpdate":1},"constants":{"\"City\"":1,"\"Customer\"":1,"\"INSERT INTO Customer VALUES (?, ?, ?, ?, ?, ?)\"":1,"\"Street address\"":1,"\"State\"":1,"\"Name\"":1,"\"Zip\"":1},"annotations":[],"types":{"PreparedStatement":1,"String":5,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Prompts the user for the customer information and creates a new customer.\n      @param conn the database connection\n      @param in the scanner\n      @return the ID of the new customer\n   */\nprivate static int newCustomer(Connection conn, Scanner in) throws SQLException {\n    String name = nextLine(in, \"Name\");\n    String address = nextLine(in, \"Street address\");\n    String city = nextLine(in, \"City\");\n    String state = nextLine(in, \"State\");\n    String zip = nextLine(in, \"Zip\");\n    int id = getNewId(conn, \"Customer\");\n    try (PreparedStatement stat = conn.prepareStatement(\"INSERT INTO Customer VALUES (?, ?, ?, ?, ?, ?)\")) {\n        stat.setInt(1, id);\n        stat.setString(2, name);\n        stat.setString(3, address);\n        stat.setString(4, city);\n        stat.setString(5, state);\n        stat.setString(6, zip);\n        stat.executeUpdate();\n    }\n    return id;\n}\n","name":"newCustomer","className":"InvoiceEntry","variables":{"zip":1,"conn":2,"stat":8,"address":1,"in":1,"city":1,"name":1,"state":1,"id":2},"javaDoc":"Prompts the user for the customer information and creates a new customer conn the database connection in the scanner the ID of the new customer","comments":"\n      Prompts the user for the customer information and creates a new customer.\n      @param conn the database connection\n      @param in the scanner\n      @return the ID of the new customer\n   ","isEmpty":false,"lineCount":8,"modifier":10}
{"paramTypes":["Connection","String"],"returnType":"boolean","methodCalls":{"next":1,"setString":1,"prepareStatement":1,"executeQuery":1},"constants":{"\"SELECT * FROM Product WHERE Product_Code = ?\"":1,"false":1},"annotations":[],"types":{"boolean":1,"ResultSet":1,"PreparedStatement":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["TryStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Finds a product in the database.\n      @param conn the database connection\n      @param code the product code to search\n      @return true if there is a product with the given code\n   */\nprivate static boolean findProduct(Connection conn, String code) throws SQLException {\n    boolean found = false;\n    try (PreparedStatement stat = conn.prepareStatement(\"SELECT * FROM Product WHERE Product_Code = ?\")) {\n        stat.setString(1, code);\n        ResultSet result = stat.executeQuery();\n        found = result.next();\n    }\n    return found;\n}\n","name":"findProduct","className":"InvoiceEntry","variables":{"result":2,"conn":2,"stat":3,"code":1,"found":3},"javaDoc":"Finds a product in the database conn the database connection code the product code to search true if there is a product with the given code","comments":"\n      Finds a product in the database.\n      @param conn the database connection\n      @param code the product code to search\n      @return true if there is a product with the given code\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["Connection","int","String","int"],"returnType":"void","methodCalls":{"setString":1,"prepareStatement":1,"setInt":2,"executeUpdate":1},"constants":{"\"INSERT INTO LineItem VALUES (?, ?, ?)\"":1},"annotations":[],"types":{"PreparedStatement":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Adds a line item to the database\n      @param conn the database connection\n      @param id the invoice ID\n      @param code the product code\n      @param quantity the quantity to order\n   */\nprivate static void addLineItem(Connection conn, int id, String code, int quantity) throws SQLException {\n    try (PreparedStatement stat = conn.prepareStatement(\"INSERT INTO LineItem VALUES (?, ?, ?)\")) {\n        stat.setInt(1, id);\n        stat.setString(2, code);\n        stat.setInt(3, quantity);\n        stat.executeUpdate();\n    }\n}\n","name":"addLineItem","className":"InvoiceEntry","variables":{"conn":2,"stat":5,"code":1,"quantity":1,"id":1},"javaDoc":"Adds a line item to the database conn the database connection id the invoice ID code the product code quantity the quantity to order","comments":"\n      Adds a line item to the database\n      @param conn the database connection\n      @param id the invoice ID\n      @param code the product code\n      @param quantity the quantity to order\n   ","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["Connection"],"returnType":"void","methodCalls":{"createStatement":1,"next":1,"getString":2,"executeQuery":1,"System.out.println":1},"constants":{"\" \"":1,"\"SELECT Product_Code, Description FROM Product\"":1},"annotations":[],"types":{"Statement":1,"ResultSet":1,"String":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Lists all products in the database.\n      @param conn the database connection\n   */\nprivate static void listProducts(Connection conn) throws SQLException {\n    try (Statement stat = conn.createStatement()) {\n        ResultSet result = stat.executeQuery(\"SELECT Product_Code, Description FROM Product\");\n        while (result.next()) {\n            String code = result.getString(1);\n            String description = result.getString(2);\n            System.out.println(code + \" \" + description);\n        }\n    }\n}\n","name":"listProducts","className":"InvoiceEntry","variables":{"result":4,"conn":2,"stat":2,"code":2,"description":2},"javaDoc":"Lists all products in the database conn the database connection","comments":"\n      Lists all products in the database.\n      @param conn the database connection\n   ","isEmpty":false,"lineCount":1,"modifier":10}
{"paramTypes":["Connection","String"],"returnType":"int","methodCalls":{"createStatement":1,"next":1,"getInt":1,"executeQuery":1},"constants":{"\"SELECT max(\"":1,"\"_Number) FROM \"":1},"annotations":[],"types":{"Statement":1,"ResultSet":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["TryStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Gets a new ID for a table. This method should be called from\n      inside a transaction that also creates the new row with this ID.\n      The ID field should have name table_Number and type INTEGER.\n      @param table the table name\n      @return a new ID that has not yet been used.\n   */\nprivate static int getNewId(Connection conn, String table) throws SQLException {\n    int max = -1;\n    try (Statement stat = conn.createStatement()) {\n        ResultSet result = stat.executeQuery(\"SELECT max(\" + table + \"_Number) FROM \" + table);\n        result.next();\n        max = result.getInt(1) + 1;\n    }\n    return max;\n}\n","name":"getNewId","className":"InvoiceEntry","variables":{"result":3,"conn":2,"stat":2,"max":3,"table":3},"javaDoc":"Gets a new ID for a table This method should be called from inside a transaction that also creates the new row with this ID The ID field should have name table_Number and type INTEGER table the table name a new ID that has not yet been used","comments":"\n      Gets a new ID for a table. This method should be called from\n      inside a transaction that also creates the new row with this ID.\n      The ID field should have name table_Number and type INTEGER.\n      @param table the table name\n      @return a new ID that has not yet been used.\n   ","isEmpty":false,"lineCount":3,"modifier":10}
{"paramTypes":["Connection","int"],"returnType":"void","methodCalls":{"next":2,"getInt":1,"trim":2,"prepareStatement":2,"getString":7,"setInt":2,"executeQuery":2,"System.out.println":4},"constants":{"\" x \"":1,"\"SELECT Customer.Name, Customer.Address, \"":1,"\" \"":2,"\"AND Invoice.Invoice_Number = ?\"":1,"\"WHERE Product.Product_Code = LineItem.Product_Code \"":1,"\"SELECT Product.Product_Code, Product.Description, LineItem.Quantity \"":1,"\"WHERE Customer.Customer_Number = Invoice.Customer_Number \"":1,"\"AND LineItem.Invoice_Number = ?\"":1,"\"Customer.City, Customer.State, Customer.Zip \"":1,"\", \"":1,"\"FROM Customer, Invoice \"":1,"\"FROM Product, LineItem \"":1},"annotations":[],"types":{"ResultSet":2,"PreparedStatement":2,"String":2,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Shows an invoice.\n      @param conn the database connection\n      @param id the invoice ID\n   */\nprivate static void showInvoice(Connection conn, int id) throws SQLException {\n    try (PreparedStatement stat = conn.prepareStatement(\"SELECT Customer.Name, Customer.Address, \" + \"Customer.City, Customer.State, Customer.Zip \" + \"FROM Customer, Invoice \" + \"WHERE Customer.Customer_Number = Invoice.Customer_Number \" + \"AND Invoice.Invoice_Number = ?\")) {\n        stat.setInt(1, id);\n        ResultSet result = stat.executeQuery();\n        result.next();\n        System.out.println(result.getString(1));\n        System.out.println(result.getString(2));\n        System.out.println(result.getString(3).trim() + \", \" + result.getString(4) + \" \" + result.getString(5));\n    }\n    try (PreparedStatement stat = conn.prepareStatement(\"SELECT Product.Product_Code, Product.Description, LineItem.Quantity \" + \"FROM Product, LineItem \" + \"WHERE Product.Product_Code = LineItem.Product_Code \" + \"AND LineItem.Invoice_Number = ?\")) {\n        stat.setInt(1, id);\n        ResultSet result = stat.executeQuery();\n        while (result.next()) {\n            String code = result.getString(1);\n            String description = result.getString(2).trim();\n            int qty = result.getInt(3);\n            System.out.println(qty + \" x \" + code + \" \" + description);\n        }\n    }\n}\n","name":"showInvoice","className":"InvoiceEntry","variables":{"result":12,"conn":3,"stat":6,"code":2,"qty":2,"description":2,"id":1},"javaDoc":"Shows an invoice conn the database connection id the invoice ID","comments":"\n      Shows an invoice.\n      @param conn the database connection\n      @param id the invoice ID\n   ","isEmpty":false,"lineCount":2,"modifier":10}
{"paramTypes":["Scanner","String"],"returnType":"String","methodCalls":{"nextLine":1,"System.out.print":1},"constants":{"\": \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Prompts the user and reads a line from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the string that the user entered\n   */\nprivate static String nextLine(Scanner in, String prompt) {\n    System.out.print(prompt + \": \");\n    return in.nextLine();\n}\n","name":"nextLine","className":"InvoiceEntry","variables":{"in":2,"prompt":2},"javaDoc":"Prompts the user and reads a line from a scanner in the scanner prompt the prompt the string that the user entered","comments":"\n      Prompts the user and reads a line from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the string that the user entered\n   ","isEmpty":false,"lineCount":2,"modifier":10}
{"paramTypes":["Scanner","String"],"returnType":"int","methodCalls":{"nextLine":1,"nextInt":1,"System.out.print":1},"constants":{"\": \"":1},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Prompts the user and reads an integer from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the integer that the user entered\n   */\nprivate static int nextInt(Scanner in, String prompt) {\n    System.out.print(prompt + \": \");\n    int result = in.nextInt();\n    // Consume newline\n    in.nextLine();\n    return result;\n}\n","name":"nextInt","className":"InvoiceEntry","variables":{"result":2,"in":3,"prompt":2},"javaDoc":"Prompts the user and reads an integer from a scanner in the scanner prompt the prompt the integer that the user entered","comments":"Consume newline \n      Prompts the user and reads an integer from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the integer that the user entered\n   ","isEmpty":false,"lineCount":4,"modifier":10}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"annotations":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException","ClassNotFoundException"],"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":2,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createStatement":1,"next":1,"init":1,"getConnection":1,"getString":1,"execute":3,"System.out.println":2,"executeQuery":1},"constants":{"\"Usage: java -classpath driver_class_path\"":1,"\"SELECT * FROM Test\"":1,"\". TestDB propertiesFile\"":1,"\"INSERT INTO Test VALUES ('Romeo')\"":1,"\"Name\"":1,"\"CREATE TABLE Test (Name VARCHAR(20))\"":1,"\"DROP TABLE Test\"":1},"annotations":[],"types":{"Statement":1,"Connection":1,"ResultSet":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["Exception"],"text":"public static void main(String[] args) throws Exception {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". TestDB propertiesFile\");\n        return;\n    }\n    SimpleDataSource.init(args[0]);\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        Statement stat = conn.createStatement();\n        stat.execute(\"CREATE TABLE Test (Name VARCHAR(20))\");\n        stat.execute(\"INSERT INTO Test VALUES ('Romeo')\");\n        ResultSet result = stat.executeQuery(\"SELECT * FROM Test\");\n        result.next();\n        System.out.println(result.getString(\"Name\"));\n        stat.execute(\"DROP TABLE Test\");\n    }\n}\n","name":"main","className":"TestDB","variables":{"args":2,"result":3,"conn":2,"stat":5,"SimpleDataSource":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number\n   */\npublic BankAccount(int anAccountNumber) {\n    accountNumber = anAccountNumber;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":2,"accountNumber":1},"javaDoc":"Constructs a bank account with a given balance anAccountNumber the account number","comments":"\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"setDouble":1,"getConnection":1,"prepareStatement":1,"setInt":1,"executeUpdate":1},"constants":{"\" WHERE Account_Number = ?\"":1,"\"UPDATE Account\"":1,"\" SET Balance = Balance + ?\"":1},"annotations":[],"types":{"Connection":1,"PreparedStatement":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Deposits money into a bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        PreparedStatement stat = conn.prepareStatement(\"UPDATE Account\" + \" SET Balance = Balance + ?\" + \" WHERE Account_Number = ?\");\n        stat.setDouble(1, amount);\n        stat.setInt(2, accountNumber);\n        stat.executeUpdate();\n    }\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"conn":2,"stat":4,"SimpleDataSource":1},"javaDoc":"Deposits money into a bank account amount the amount to deposit","comments":"\n      Deposits money into a bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"setDouble":1,"getConnection":1,"prepareStatement":1,"setInt":1,"executeUpdate":1},"constants":{"\" WHERE Account_Number = ?\"":1,"\"UPDATE Account\"":1,"\" SET Balance = Balance - ?\"":1},"annotations":[],"types":{"Connection":1,"PreparedStatement":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Withdraws money from a bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        PreparedStatement stat = conn.prepareStatement(\"UPDATE Account\" + \" SET Balance = Balance - ?\" + \" WHERE Account_Number = ?\");\n        stat.setDouble(1, amount);\n        stat.setInt(2, accountNumber);\n        stat.executeUpdate();\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"conn":2,"stat":4,"SimpleDataSource":1},"javaDoc":"Withdraws money from a bank account amount the amount to withdraw","comments":"\n      Withdraws money from a bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"next":1,"getConnection":1,"getDouble":1,"prepareStatement":1,"setInt":1,"executeQuery":1},"constants":{"\"SELECT Balance FROM Account WHERE Account_Number = ?\"":1},"annotations":[],"types":{"double":1,"Connection":1,"ResultSet":1,"PreparedStatement":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","TryStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Gets the balance of a bank account.\n      @return the account balance\n   */\npublic double getBalance() throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        double balance = 0;\n        PreparedStatement stat = conn.prepareStatement(\"SELECT Balance FROM Account WHERE Account_Number = ?\");\n        stat.setInt(1, accountNumber);\n        ResultSet result = stat.executeQuery();\n        if (result.next()) {\n            balance = result.getDouble(1);\n        }\n        return balance;\n    }\n}\n","name":"getBalance","className":"BankAccount","variables":{"result":3,"conn":2,"stat":3,"balance":3,"SimpleDataSource":1},"javaDoc":"Gets the balance of a bank account the account balance","comments":"\n      Gets the balance of a bank account.\n      @return the account balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"init":1,"showMessageDialog":3,"setTitle":1,"setDefaultCloseOperation":1},"constants":{"\"Can't connect to database\"":2,"null":3,"\"Usage: ATMViewer propertiesFile\"":1,"true":1,"\"First National Bank of Java\"":1},"annotations":[],"types":{"Bank":1,"JFrame":1,"ATM":1,"ATMFrame":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ReturnStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":["IOException","ClassNotFoundException"],"text":"public static void main(String[] args) throws IOException, ClassNotFoundException {\n    if (args.length == 0) {\n        JOptionPane.showMessageDialog(null, \"Usage: ATMViewer propertiesFile\");\n        return;\n    } else {\n        try {\n            SimpleDataSource.init(args[0]);\n        } catch (IOException exception) {\n            JOptionPane.showMessageDialog(null, \"Can't connect to database\");\n            return;\n        } catch (ClassNotFoundException exception) {\n            JOptionPane.showMessageDialog(null, \"Can't connect to database\");\n            return;\n        }\n    }\n    ATM theATM;\n    Bank theBank = new Bank();\n    theATM = new ATM(theBank);\n    JFrame frame = new ATMFrame(theATM);\n    frame.setTitle(\"First National Bank of Java\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ATMViewer","variables":{"args":2,"exception":2,"theATM":3,"theBank":2,"SimpleDataSource":1,"JOptionPane":3,"frame":4},"javaDoc":"","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"init":1,"selectAccount":2,"back":3,"nextInt":2,"nextDouble":2,"setCustomerNumber":1,"getState":1,"getBalance":1,"reset":1,"deposit":1,"equalsIgnoreCase":6,"System.out.print":6,"selectCustomer":1,"System.out.println":4,"withdraw":1},"constants":{"\"Usage: ATMTester propertiesFile\"":1,"\"Enter account number: \"":1,"\"Illegal input!\"":2,"\"C\"":2,"\"B\"":2,"\"A\"":2,"\"A=Deposit, B=Withdrawal, C=Cancel: \"":1,"\"A=Checking, B=Savings, C=Quit: \"":1,"\"Balance=\"":1,"true":1,"\"Amount: \"":2,"\"Enter PIN: \"":1},"annotations":[],"types":{"Scanner":1,"Bank":1,"double":2,"ATM":1,"String":2,"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"text":"public static void main(String[] args) throws IOException, SQLException, ClassNotFoundException {\n    if (args.length == 0) {\n        System.out.println(\"Usage: ATMTester propertiesFile\");\n        return;\n    } else {\n        SimpleDataSource.init(args[0]);\n    }\n    Bank theBank = new Bank();\n    ATM theATM = new ATM(theBank);\n    Scanner in = new Scanner(System.in);\n    while (true) {\n        int state = theATM.getState();\n        if (state == ATM.START) {\n            System.out.print(\"Enter account number: \");\n            int number = in.nextInt();\n            theATM.setCustomerNumber(number);\n        } else if (state == ATM.PIN) {\n            System.out.print(\"Enter PIN: \");\n            int pin = in.nextInt();\n            theATM.selectCustomer(pin);\n        } else if (state == ATM.ACCOUNT) {\n            System.out.print(\"A=Checking, B=Savings, C=Quit: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                theATM.selectAccount(ATM.CHECKING);\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                theATM.selectAccount(ATM.SAVINGS);\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.reset();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        } else if (state == ATM.TRANSACT) {\n            System.out.println(\"Balance=\" + theATM.getBalance());\n            System.out.print(\"A=Deposit, B=Withdrawal, C=Cancel: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.deposit(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.withdraw(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.back();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        }\n    }\n}\n","name":"main","className":"ATMSimulator","variables":{"args":2,"number":1,"amount":2,"theATM":13,"theBank":2,"pin":1,"in":7,"SimpleDataSource":1,"state":5,"command":8},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["int","int","int"],"returnType":"Customer","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a customer with a given number and PIN.\n      @param aCustomerNumber the customer number\n      @param checkingAccountNumber the checking account number\n      @param savingsAccountNumber the savings account number\n   */\npublic Customer(int aCustomerNumber, int checkingAccountNumber, int savingsAccountNumber) {\n    customerNumber = aCustomerNumber;\n    checkingAccount = new BankAccount(checkingAccountNumber);\n    savingsAccount = new BankAccount(savingsAccountNumber);\n}\n","name":"Customer","className":"Customer","variables":{"savingsAccountNumber":2,"savingsAccount":1,"checkingAccountNumber":2,"checkingAccount":1,"customerNumber":1,"aCustomerNumber":2},"javaDoc":"Constructs a customer with a given number and PIN aCustomerNumber the customer number checkingAccountNumber the checking account number savingsAccountNumber the savings account number","comments":"\n      Constructs a customer with a given number and PIN.\n      @param aCustomerNumber the customer number\n      @param checkingAccountNumber the checking account number\n      @param savingsAccountNumber the savings account number\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Gets the checking account of this customer.\n      @return the checking account\n   */\npublic BankAccount getCheckingAccount() {\n    return checkingAccount;\n}\n","name":"getCheckingAccount","className":"Customer","variables":{"checkingAccount":1},"javaDoc":"Gets the checking account of this customer the checking account","comments":" \n      Gets the checking account of this customer.\n      @return the checking account\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Gets the savings account of this customer.\n      @return the savings account\n   */\npublic BankAccount getSavingsAccount() {\n    return savingsAccount;\n}\n","name":"getSavingsAccount","className":"Customer","variables":{"savingsAccount":1},"javaDoc":"Gets the savings account of this customer the savings account","comments":" \n      Gets the savings account of this customer.\n      @return the savings account\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Customer","methodCalls":{"next":1,"getConnection":1,"getInt":3,"prepareStatement":1,"setInt":1,"executeQuery":1},"constants":{"\"Savings_Account_Number\"":1,"null":1,"\"Checking_Account_Number\"":1,"\"SELECT * FROM BankCustomer WHERE Customer_Number = ?\"":1,"\"PIN\"":1},"annotations":[],"types":{"Customer":1,"Connection":1,"ResultSet":1,"PreparedStatement":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","TryStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Finds a customer with a given number and PIN.\n      @param customerNumber the customer number\n      @param pin the personal identification number\n      @return the matching customer, or null if none found\n   */\npublic Customer findCustomer(int customerNumber, int pin) throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        Customer c = null;\n        PreparedStatement stat = conn.prepareStatement(\"SELECT * FROM BankCustomer WHERE Customer_Number = ?\");\n        stat.setInt(1, customerNumber);\n        ResultSet result = stat.executeQuery();\n        if (result.next() && pin == result.getInt(\"PIN\")) {\n            c = new Customer(customerNumber, result.getInt(\"Checking_Account_Number\"), result.getInt(\"Savings_Account_Number\"));\n        }\n        return c;\n    }\n}\n","name":"findCustomer","className":"Bank","variables":{"result":5,"conn":2,"stat":3,"pin":2,"SimpleDataSource":1,"customerNumber":2},"javaDoc":"Finds a customer with a given number and PIN customerNumber the customer number pin the personal identification number the matching customer or null if none found","comments":"\n      Finds a customer with a given number and PIN.\n      @param customerNumber the customer number\n      @param pin the personal identification number\n      @return the matching customer, or null if none found\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Bank"],"returnType":"ATM","methodCalls":{"reset":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   */\npublic ATM(Bank aBank) {\n    theBank = aBank;\n    reset();\n}\n","name":"ATM","className":"ATM","variables":{"theBank":1,"aBank":2},"javaDoc":"Constructs an ATM for a given bank aBank the bank to which this ATM connects","comments":"\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NullLiteralExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Resets the ATM to the initial state.\n   */\npublic void reset() {\n    customerNumber = -1;\n    currentAccount = null;\n    state = START;\n}\n","name":"reset","className":"ATM","variables":{"START":1,"currentAccount":1,"state":1,"customerNumber":1},"javaDoc":"Resets the ATM to the initial state","comments":"\n      Resets the ATM to the initial state.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   */\npublic void setCustomerNumber(int number) {\n    customerNumber = number;\n    state = PIN;\n}\n","name":"setCustomerNumber","className":"ATM","variables":{"number":2,"PIN":1,"state":1,"customerNumber":1},"javaDoc":"Sets the current customer number and sets state to PIN (Precondition: state is START) number the customer number","comments":" \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"findCustomer":1},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/** \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   */\npublic void selectCustomer(int pin) throws SQLException {\n    currentCustomer = theBank.findCustomer(customerNumber, pin);\n    if (currentCustomer == null) {\n        state = START;\n    } else {\n        state = ACCOUNT;\n    }\n}\n","name":"selectCustomer","className":"ATM","variables":{"ACCOUNT":1,"pin":1,"currentCustomer":2,"theBank":1,"START":1,"state":2},"javaDoc":"Finds customer in bank If found sets state to ACCOUNT else to START (Precondition: state is PIN) pin the PIN of the current customer","comments":" \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getCheckingAccount":1,"getSavingsAccount":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   */\npublic void selectAccount(int account) {\n    if (account == CHECKING) {\n        currentAccount = currentCustomer.getCheckingAccount();\n    } else {\n        currentAccount = currentCustomer.getSavingsAccount();\n    }\n    state = TRANSACT;\n}\n","name":"selectAccount","className":"ATM","variables":{"currentCustomer":2,"TRANSACT":1,"CHECKING":1,"currentAccount":2,"state":1,"account":2},"javaDoc":"Sets current account to checking or savings Sets state to TRANSACT (Precondition: state is ACCOUNT or TRANSACT) account one of CHECKING or SAVINGS","comments":" \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"withdraw":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/** \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   */\npublic void withdraw(double value) throws SQLException {\n    currentAccount.withdraw(value);\n}\n","name":"withdraw","className":"ATM","variables":{"currentAccount":1,"value":1},"javaDoc":"Withdraws amount from current account (Precondition: state is TRANSACT) value the amount to withdraw","comments":" \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"deposit":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/** \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   */\npublic void deposit(double value) throws SQLException {\n    currentAccount.deposit(value);\n}\n","name":"deposit","className":"ATM","variables":{"currentAccount":1,"value":1},"javaDoc":"Deposits amount to current account (Precondition: state is TRANSACT) value the amount to deposit","comments":" \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getBalance":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/** \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   */\npublic double getBalance() throws SQLException {\n    return currentAccount.getBalance();\n}\n","name":"getBalance","className":"ATM","variables":{"currentAccount":1},"javaDoc":"Gets the balance of the current account (Precondition: state is TRANSACT) the balance","comments":" \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Moves back to the previous state.\n   */\npublic void back() {\n    if (state == TRANSACT) {\n        state = ACCOUNT;\n    } else if (state == ACCOUNT) {\n        state = PIN;\n    } else if (state == PIN) {\n        state = START;\n    }\n}\n","name":"back","className":"ATM","variables":{"ACCOUNT":2,"TRANSACT":1,"PIN":2,"START":1,"state":6},"javaDoc":"Moves back to the previous state","comments":"\n      Moves back to the previous state.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current state of this ATM.\n      @return the current state\n   */\npublic int getState() {\n    return state;\n}\n","name":"getState","className":"ATM","variables":{"state":1},"javaDoc":"Gets the current state of this ATM the current state","comments":"\n      Gets the current state of this ATM.\n      @return the current state\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setText":1},"constants":{"\"\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    display.setText(\"\");\n}\n","name":"actionPerformed","className":"ClearButtonListener","variables":{"display":1,"event":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"KeyPad","methodCalls":{"add":3,"addActionListener":1,"addButton":11,"setLayout":2,"setText":1},"constants":{"\"North\"":1,"\"\"":1,"\"9\"":1,"\"8\"":1,"\"Center\"":1,"\"7\"":1,"\"6\"":1,"\"CE\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"\"1\"":1,"\"0\"":1,"\".\"":1},"annotations":[],"types":{"ActionListener":1,"ClearButtonListener":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["TypeDeclarationStmt","BlockStmt","ExpressionStmt"],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"exceptions":[],"text":"/**\n      Constructs the keypad panel.\n   */\npublic KeyPad() {\n    setLayout(new BorderLayout());\n    // Add display field\n    display = new JTextField();\n    add(display, \"North\");\n    // Make button panel\n    buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 3));\n    // Add digit buttons\n    addButton(\"7\");\n    addButton(\"8\");\n    addButton(\"9\");\n    addButton(\"4\");\n    addButton(\"5\");\n    addButton(\"6\");\n    addButton(\"1\");\n    addButton(\"2\");\n    addButton(\"3\");\n    addButton(\"0\");\n    addButton(\".\");\n    // Add clear entry button\n    clearButton = new JButton(\"CE\");\n    buttonPanel.add(clearButton);\n    class ClearButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            display.setText(\"\");\n        }\n    }\n    ActionListener listener = new ClearButtonListener();\n    clearButton.addActionListener(new ClearButtonListener());\n    add(buttonPanel, \"Center\");\n}\n","name":"KeyPad","className":"KeyPad","variables":{"actionPerformed":1,"clearButton":2,"display":2,"buttonPanel":3,"listener":1,"ClearButtonListener":1,"event":1},"javaDoc":"Constructs the keypad panel","comments":"Add display field Make button panel Add digit buttons Add clear entry button \n      Constructs the keypad panel.\n   ","isEmpty":false,"lineCount":26,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":2,"equals":1,"indexOf":1,"setText":1},"constants":{"\".\"":2},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    // Don't add two decimal points\n    if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n        return;\n    }\n    // Append label text to button\n    display.setText(display.getText() + label);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"display":3,"label":2,"event":1},"javaDoc":"","comments":"Don't add two decimal points Append label text to button ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"getText":2,"equals":1,"addActionListener":1,"indexOf":1,"setText":1},"constants":{"\".\"":2},"annotations":[],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","TypeDeclarationStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"exceptions":[],"text":"/**\n      Adds a button to the button panel.\n      @param label the button label\n   */\nprivate void addButton(final String label) {\n    class DigitButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            // Don't add two decimal points\n            if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n                return;\n            }\n            // Append label text to button\n            display.setText(display.getText() + label);\n        }\n    }\n    JButton button = new JButton(label);\n    buttonPanel.add(button);\n    ActionListener listener = new DigitButtonListener();\n    button.addActionListener(listener);\n}\n","name":"addButton","className":"KeyPad","variables":{"button":2,"actionPerformed":1,"DigitButtonListener":1,"display":3,"buttonPanel":1,"listener":1,"label":4,"event":1},"javaDoc":"Adds a button to the button panel label the button label","comments":"Don't add two decimal points Append label text to button \n      Adds a button to the button panel.\n      @param label the button label\n   ","isEmpty":false,"lineCount":5,"modifier":2}
{"paramTypes":[],"returnType":"double","methodCalls":{"parseDouble":1,"getText":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   */\npublic double getValue() {\n    return Double.parseDouble(display.getText());\n}\n","name":"getValue","className":"KeyPad","variables":{"display":1,"Double":1},"javaDoc":"Gets the value that the user entered the value in the text field of the keypad","comments":" \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"constants":{"\"\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Clears the dislay. \n   */\npublic void clear() {\n    display.setText(\"\");\n}\n","name":"clear","className":"KeyPad","variables":{"display":1},"javaDoc":"Clears the dislay","comments":" \n      Clears the dislay. \n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"annotations":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException","ClassNotFoundException"],"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":2,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["ATM"],"returnType":"ATMFrame","methodCalls":{"add":6,"showState":1,"setSize":1,"addActionListener":3,"setLayout":1},"constants":{"\"  C  \"":1,"\"  B  \"":1,"\"  A  \"":1,"20":1},"annotations":[],"types":{"JPanel":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs the user interface of the ATM frame.\n   */\npublic ATMFrame(ATM anATM) {\n    theATM = anATM;\n    // Construct components\n    pad = new KeyPad();\n    display = new JTextArea(4, 20);\n    aButton = new JButton(\"  A  \");\n    aButton.addActionListener(new AButtonListener());\n    bButton = new JButton(\"  B  \");\n    bButton.addActionListener(new BButtonListener());\n    cButton = new JButton(\"  C  \");\n    cButton.addActionListener(new CButtonListener());\n    // Add components\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.add(aButton);\n    buttonPanel.add(bButton);\n    buttonPanel.add(cButton);\n    setLayout(new FlowLayout());\n    add(pad);\n    add(display);\n    add(buttonPanel);\n    showState();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"ATMFrame","className":"ATMFrame","variables":{"aButton":2,"pad":1,"theATM":1,"anATM":2,"display":1,"buttonPanel":4,"cButton":2,"bButton":2},"javaDoc":"Constructs the user interface of the ATM frame","comments":"Construct components Add components \n      Constructs the user interface of the ATM frame.\n   ","isEmpty":false,"lineCount":21,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getState":1,"getBalance":1,"showMessageDialog":1,"clear":1,"setText":4},"constants":{"\"Select Account\\n\"":1,"null":1,"\"Balance = \"":1,"\"A = Withdraw\\nB = Deposit\\nC = Cancel\"":1,"\"Enter PIN\\nA = OK\"":1,"\"A = Checking\\nB = Savings\\nC = Exit\"":1,"\"\\nEnter amount and select transaction\\n\"":1,"\"Enter customer number\\nA = OK\"":1,"\"Database error\"":1},"annotations":[],"types":{"int":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/** \n      Updates display message.\n   */\npublic void showState() {\n    int state = theATM.getState();\n    pad.clear();\n    if (state == ATM.START) {\n        display.setText(\"Enter customer number\\nA = OK\");\n    } else if (state == ATM.PIN) {\n        display.setText(\"Enter PIN\\nA = OK\");\n    } else if (state == ATM.ACCOUNT) {\n        display.setText(\"Select Account\\n\" + \"A = Checking\\nB = Savings\\nC = Exit\");\n    } else if (state == ATM.TRANSACT) {\n        try {\n            display.setText(\"Balance = \" + theATM.getBalance() + \"\\nEnter amount and select transaction\\n\" + \"A = Withdraw\\nB = Deposit\\nC = Cancel\");\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n    }\n}\n","name":"showState","className":"ATMFrame","variables":{"exception":1,"pad":1,"theATM":2,"display":4,"state":5,"JOptionPane":1},"javaDoc":"Updates display message","comments":" \n      Updates display message.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setCustomerNumber":1,"showState":1,"getValue":3,"getState":1,"showMessageDialog":2,"selectAccount":1,"back":1,"selectCustomer":1,"withdraw":1},"constants":{"null":2,"\"Database error\"":2},"annotations":[],"types":{"int":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","CastExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.START) {\n        theATM.setCustomerNumber((int) pad.getValue());\n    } else if (state == ATM.PIN) {\n        try {\n            theATM.selectCustomer((int) pad.getValue());\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n    } else if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.CHECKING);\n    } else if (state == ATM.TRANSACT) {\n        try {\n            theATM.withdraw(pad.getValue());\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"AButtonListener","variables":{"exception":2,"pad":3,"theATM":6,"state":5,"event":1,"JOptionPane":2},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getValue":1,"getState":1,"selectAccount":1,"showMessageDialog":1,"deposit":1,"back":1},"constants":{"null":1,"\"Database error\"":1},"annotations":[],"types":{"int":1},"expressions":["NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.SAVINGS);\n    } else if (state == ATM.TRANSACT) {\n        try {\n            theATM.deposit(pad.getValue());\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"BButtonListener","variables":{"exception":1,"pad":1,"theATM":4,"state":3,"event":1,"JOptionPane":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getState":1,"reset":1,"back":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.reset();\n    } else if (state == ATM.TRANSACT) {\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"CButtonListener","variables":{"theATM":3,"state":3,"event":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createStatement":1,"init":1,"getConnection":1,"nextLine":1,"hasNextLine":1,"getResultSet":1,"showResultSet":1,"execute":1,"System.out.println":2},"constants":{"\"Usage: java -classpath driver_class_path\"":1,"\". ExecSQL propertiesFile [SQLcommandFile]\"":1},"annotations":[],"types":{"Scanner":1,"boolean":1,"Statement":1,"Connection":1,"ResultSet":1,"String":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","TryStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"text":"public static void main(String[] args) throws SQLException, IOException, ClassNotFoundException {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". ExecSQL propertiesFile [SQLcommandFile]\");\n        return;\n    }\n    SimpleDataSource.init(args[0]);\n    Scanner in;\n    if (args.length > 1) {\n        in = new Scanner(new File(args[1]));\n    } else {\n        in = new Scanner(System.in);\n    }\n    try (Connection conn = SimpleDataSource.getConnection();\n        Statement stat = conn.createStatement()) {\n        while (in.hasNextLine()) {\n            String line = in.nextLine();\n            try {\n                boolean hasResultSet = stat.execute(line);\n                if (hasResultSet) {\n                    try (ResultSet result = stat.getResultSet()) {\n                        showResultSet(result);\n                    }\n                }\n            } catch (SQLException ex) {\n                System.out.println(ex);\n            }\n        }\n    }\n}\n","name":"main","className":"ExecSQL","variables":{"args":3,"result":1,"conn":2,"stat":3,"ex":1,"in":5,"hasResultSet":2,"SimpleDataSource":2,"line":1},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["ResultSet"],"returnType":"void","methodCalls":{"next":1,"getColumnLabel":1,"getColumnCount":1,"getString":1,"getMetaData":1,"System.out.print":4,"System.out.println":2},"constants":{"\", \"":2},"annotations":[],"types":{"ResultSetMetaData":1,"int":3},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Prints a result set.\n      @param result the result set\n   */\npublic static void showResultSet(ResultSet result) throws SQLException {\n    ResultSetMetaData metaData = result.getMetaData();\n    int columnCount = metaData.getColumnCount();\n    for (int i = 1; i <= columnCount; i++) {\n        if (i > 1) {\n            System.out.print(\", \");\n        }\n        System.out.print(metaData.getColumnLabel(i));\n    }\n    System.out.println();\n    while (result.next()) {\n        for (int i = 1; i <= columnCount; i++) {\n            if (i > 1) {\n                System.out.print(\", \");\n            }\n            System.out.print(result.getString(i));\n        }\n        System.out.println();\n    }\n}\n","name":"showResultSet","className":"ExecSQL","variables":{"result":4,"metaData":3,"columnCount":3},"javaDoc":"Prints a result set result the result set","comments":"\n      Prints a result set.\n      @param result the result set\n   ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"annotations":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["IOException","ClassNotFoundException"],"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":2,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":["SQLException"],"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"next":1,"iterator":1,"hasNext":1,"System.out.println":1},"constants":{"\"Amy\"":1,"\"Sharon\"":1,"\"Mary\"":1,"\"George\"":1},"annotations":[],"types":{"Set":1,"Iterator":1,"HashSet":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Set names = new HashSet();\n    names.add(\"Sharon\");\n    names.add(\"Amy\");\n    names.add(\"George\");\n    names.add(\"Mary\");\n    Iterator iter = names.iterator();\n    while (iter.hasNext()) {\n        System.out.println(iter.next());\n    }\n/*//TreeSet \n\t\tSystem.out.println();\n\t\tSet names2 = new TreeSet();\n\t\tnames2.add(\"Sharon\");\n\t\tnames2.add(\"Amy\");\n\t\tnames2.add(\"George\");\n\t\tnames2.add(\"Mary\");\n\t\tIterator iter2 = names2.iterator();\n\t\twhile (iter2.hasNext()){\n\t\t          System.out.println(iter2.next());\n\t\t }\n\n\t\t*/\n}\n","name":"main","className":"SetTester","variables":{"args":1,"names":6,"iter":3},"javaDoc":"","comments":"//TreeSet System out println(); Set names2 = new TreeSet(); names2 add(\"Sharon\"); names2 add(\"Amy\"); names2 add(\"George\"); names2 add(\"Mary\"); Iterator iter2 = names2 iterator(); while (iter2 hasNext()){ System out println(iter2 next()); } ","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"get":1,"keySet":1,"put":4,"System.out.println":1},"constants":{"\"Eve\"":1,"\"Juliet\"":1,"\"Romeo\"":1,"\"Sharon\"":1,"\"->\"":1},"annotations":[],"types":{"Map<String, Color>":1,"Set<String>":1,"HashMap":1,"Color":1,"String":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Map<String, Color> favoriteColors = new HashMap<String, Color>();\n    favoriteColors.put(\"Juliet\", Color.pink);\n    favoriteColors.put(\"Romeo\", Color.green);\n    favoriteColors.put(\"Sharon\", Color.blue);\n    favoriteColors.put(\"Eve\", Color.pink);\n    Set<String> keySet = favoriteColors.keySet();\n    for (String key : keySet) {\n        Color value = favoriteColors.get(key);\n        System.out.println(key + \"->\" + value);\n    }\n/*\n\t\t System.out.println();\n\t\t \n\t\t //TreeMap\n\t\t Map<String, Color> fColorTreMap = new TreeMap<String, Color>();\n\t\t fColorTreMap.put(\"Juliet\", Color.pink);\n\t\t fColorTreMap.put(\"Romeo\", Color.green);\n\t\t fColorTreMap.put(\"Sharon\", Color.blue);\n\t\t fColorTreMap.put(\"Eve\", Color.pink);\n\t\t \n\t\t Set<String> keySet2 = fColorTreMap.keySet();\n\t\t System.out.println(\"sorted!\");\n\t\t for (String key : keySet2)\n\t\t {\n\t\t\t Color value = fColorTreMap.get(key);\n\t\t\t System.out.println(key + \"->\" + value);\n\t\t }\n\t\t \n\t\t */\n}\n","name":"main","className":"MapTester","variables":{"args":1,"favoriteColors":7,"keySet":2,"value":2,"key":2},"javaDoc":"","comments":"System out println(); //TreeMap Map<String Color> fColorTreMap = new TreeMap<String Color>(); fColorTreMap put(\"Juliet\" Color pink); fColorTreMap put(\"Romeo\" Color green); fColorTreMap put(\"Sharon\" Color blue); fColorTreMap put(\"Eve\" Color pink); Set<String> keySet2 = fColorTreMap keySet(); System out println(\"sorted!\"); for (String key : keySet2) { Color value = fColorTreMap get(key); System out println(key + \"->\" + value); } ","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":["String"],"returnType":"Product","methodCalls":{"parseInt":1,"parseDouble":2,"split":1,"equalsIgnoreCase":1},"constants":{"\"Food\"":1,"\"/\"":1},"annotations":[],"types":{"double":2,"Product":1,"String[]":1,"String":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static Product parseStringToProduct(String lineToParse) {\n    Product product;\n    String[] inputToken = lineToParse.split(\"/\");\n    // food or clothing\n    String type = inputToken[0];\n    int quantity = Integer.parseInt(inputToken[2]);\n    double unitPrice = Double.parseDouble(inputToken[3]);\n    if (type.equalsIgnoreCase(\"Food\")) {\n        double damageRate = Double.parseDouble(inputToken[5]);\n        product = new Food(inputToken[1], quantity, unitPrice, inputToken[4], damageRate, inputToken[6]);\n    } else {\n        product = new Clothing(inputToken[1], quantity, unitPrice, inputToken[4], inputToken[5]);\n    }\n    return product;\n}\n","name":"parseStringToProduct","className":"ProductParser","variables":{"Integer":1,"unitPrice":3,"product":4,"quantity":3,"inputToken":11,"lineToParse":2,"type":2,"damageRate":2,"Double":2},"javaDoc":"","comments":"food or clothing ","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{"newCondition":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","NameExpr","AssignExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n    balanceChangeLock = new ReentrantLock();\n    sufficientFundsCondition = balanceChangeLock.newCondition();\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"sufficientFundsCondition":1,"balanceChangeLock":2},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"signalAll":1,"unlock":1,"lock":1,"System.out.print":1,"System.out.println":1},"constants":{"\", new balance is \"":1,"\"Depositing \"":1},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balanceChangeLock.lock();\n    try {\n        System.out.print(\"Depositing \" + amount);\n        double newBalance = balance + amount;\n        System.out.println(\", new balance is \" + newBalance);\n        balance = newBalance;\n        sufficientFundsCondition.signalAll();\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":3,"balance":2,"newBalance":3,"sufficientFundsCondition":1,"balanceChangeLock":2},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"unlock":1,"await":1,"lock":1,"System.out.print":1,"System.out.println":1},"constants":{"\"Withdrawing \"":1,"\", new balance is \"":1},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) throws InterruptedException {\n    balanceChangeLock.lock();\n    try {\n        while (balance < amount) {\n            sufficientFundsCondition.await();\n        }\n        System.out.print(\"Withdrawing \" + amount);\n        double newBalance = balance - amount;\n        System.out.println(\", new balance is \" + newBalance);\n        balance = newBalance;\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":4,"balance":3,"sufficientFundsCondition":1,"newBalance":3,"balanceChangeLock":2},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["BankAccount","double","int"],"returnType":"WithdrawRunnable","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   */\npublic WithdrawRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"WithdrawRunnable","className":"WithdrawRunnable","variables":{"amount":1,"aCount":2,"count":1,"anAccount":2,"anAmount":2,"account":1},"javaDoc":"Constructs a withdraw runnable anAccount the account from which to withdraw money anAmount the amount to withdraw in each repetition aCount the number of repetitions","comments":"\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"withdraw":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.withdraw(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"WithdrawRunnable","variables":{"exception":1,"count":1,"account":1,"Thread":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":2},"constants":{"100":3},"annotations":[],"types":{"DepositRunnable":1,"WithdrawRunnable":1,"double":1,"BankAccount":1,"int":3,"Thread":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    BankAccount account = new BankAccount();\n    final double AMOUNT = 100;\n    final int REPETITIONS = 100;\n    final int THREADS = 100;\n    for (int i = 1; i <= THREADS; i++) {\n        DepositRunnable d = new DepositRunnable(account, AMOUNT, REPETITIONS);\n        WithdrawRunnable w = new WithdrawRunnable(account, AMOUNT, REPETITIONS);\n        Thread dt = new Thread(d);\n        Thread wt = new Thread(w);\n        dt.start();\n        wt.start();\n    }\n}\n","name":"main","className":"BankAccountThreadRunner","variables":{"args":1,"dt":2,"AMOUNT":3,"THREADS":2,"REPETITIONS":3,"wt":2,"account":3},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["BankAccount","double","int"],"returnType":"DepositRunnable","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   */\npublic DepositRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"DepositRunnable","className":"DepositRunnable","variables":{"amount":1,"aCount":2,"count":1,"anAccount":2,"anAmount":2,"account":1},"javaDoc":"Constructs a deposit runnable anAccount the account into which to deposit money anAmount the amount to deposit in each repetition aCount the number of repetitions","comments":"\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"deposit":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.deposit(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"DepositRunnable","variables":{"exception":1,"count":1,"account":1,"Thread":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"constants":{},"annotations":[],"types":{"int[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"length":2,"generator":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":1},"expressions":["VariableDeclarationExpr","ArrayAccessExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"temp":2},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"SelectionSortComponent","methodCalls":{"randomIntArray":1},"constants":{"300":1,"30":1},"annotations":[],"types":{"int[]":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","NameExpr","ThisExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs the component.\n   */\npublic SelectionSortComponent() {\n    int[] values = ArrayUtil.randomIntArray(30, 300);\n    sorter = new SelectionSorter(values, this);\n}\n","name":"SelectionSortComponent","className":"SelectionSortComponent","variables":{"sorter":1,"values":2,"ArrayUtil":1},"javaDoc":"Constructs the component","comments":"\n      Constructs the component.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void paintComponent(Graphics g) {\n    sorter.draw(g);\n}\n","name":"paintComponent","className":"SelectionSortComponent","variables":{"sorter":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sort":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"public void run() {\n    try {\n        sorter.sort();\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"AnimationRunnable","variables":{"exception":1,"sorter":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"start":1,"sort":1},"constants":{},"annotations":[],"types":{"AnimationRunnable":1,"Runnable":1,"Thread":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","MethodCallExpr"],"statements":["TypeDeclarationStmt","BlockStmt","TryStmt","ExpressionStmt"],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"exceptions":["InterruptedException"],"text":"/**\n      Starts a new animation thread.\n   */\npublic void startAnimation() {\n    class AnimationRunnable implements Runnable {\n\n        public void run() {\n            try {\n                sorter.sort();\n            } catch (InterruptedException exception) {\n            }\n        }\n    }\n    Runnable r = new AnimationRunnable();\n    Thread t = new Thread(r);\n    t.start();\n}\n","name":"startAnimation","className":"SelectionSortComponent","variables":{"exception":1,"sorter":1,"AnimationRunnable":1,"run":1},"javaDoc":"Starts a new animation thread","comments":"\n      Starts a new animation thread.\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["int[]","JComponent"],"returnType":"SelectionSorter","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a selection sorter.\n      @param anArray the array to sort\n      @param aComponent the component to be repainted when the animation \n      pauses\n   */\npublic SelectionSorter(int[] anArray, JComponent aComponent) {\n    a = anArray;\n    sortStateLock = new ReentrantLock();\n    component = aComponent;\n}\n","name":"SelectionSorter","className":"SelectionSorter","variables":{"component":1,"sortStateLock":1,"anArray":2,"aComponent":2},"javaDoc":"Constructs a selection sorter anArray the array to sort aComponent the component to be repainted when the animation pauses","comments":"\n      Constructs a selection sorter.\n      @param anArray the array to sort\n      @param aComponent the component to be repainted when the animation \n      pauses\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"unlock":1,"swap":1,"minimumPosition":1,"lock":1,"pause":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","TryStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"/**\n      Sorts the array managed by this selection sorter.\n   */\npublic void sort() throws InterruptedException {\n    for (int i = 0; i < a.length - 1; i++) {\n        int minPos = minimumPosition(i);\n        sortStateLock.lock();\n        try {\n            ArrayUtil.swap(a, minPos, i);\n            // For animation\n            alreadySorted = i;\n        } finally {\n            sortStateLock.unlock();\n        }\n        pause(2);\n    }\n}\n","name":"sort","className":"SelectionSorter","variables":{"sortStateLock":2,"alreadySorted":1,"minPos":1,"ArrayUtil":1},"javaDoc":"Sorts the array managed by this selection sorter","comments":"For animation \n      Sorts the array managed by this selection sorter.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"unlock":1,"lock":1,"pause":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"/**\n      Finds the smallest element in a tail range of the array\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from]...a[a.length - 1]\n   */\nprivate int minimumPosition(int from) throws InterruptedException {\n    int minPos = from;\n    for (int i = from + 1; i < a.length; i++) {\n        sortStateLock.lock();\n        try {\n            if (a[i] < a[minPos]) {\n                minPos = i;\n            }\n            // For animation\n            markedPosition = i;\n        } finally {\n            sortStateLock.unlock();\n        }\n        pause(2);\n    }\n    return minPos;\n}\n","name":"minimumPosition","className":"SelectionSorter","variables":{"sortStateLock":2,"minPos":4,"from":3,"markedPosition":1},"javaDoc":"Finds the smallest element in a tail range of the array from the first position in a to compare the position of the smallest element in the range a[from] a[a length - 1]","comments":"For animation \n      Finds the smallest element in a tail range of the array\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from]...a[a.length - 1]\n   ","isEmpty":false,"lineCount":3,"modifier":2}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":3,"unlock":1,"lock":1,"getWidth":1,"drawLine":1},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","TryStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Draws the current state of the sorting algorithm.\n      @param g the graphics context\n   */\npublic void draw(Graphics g) {\n    sortStateLock.lock();\n    try {\n        int deltaX = component.getWidth() / a.length;\n        for (int i = 0; i < a.length; i++) {\n            if (i == markedPosition) {\n                g.setColor(Color.RED);\n            } else if (i <= alreadySorted) {\n                g.setColor(Color.BLUE);\n            } else {\n                g.setColor(Color.BLACK);\n            }\n            g.drawLine(i * deltaX, 0, i * deltaX, a[i]);\n        }\n    } finally {\n        sortStateLock.unlock();\n    }\n}\n","name":"draw","className":"SelectionSorter","variables":{"component":1,"sortStateLock":2,"deltaX":3,"alreadySorted":1,"markedPosition":1},"javaDoc":"Draws the current state of the sorting algorithm g the graphics context","comments":"\n      Draws the current state of the sorting algorithm.\n      @param g the graphics context\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"sleep":1,"repaint":1},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"/**\n      Pauses the animation.\n      @param steps the number of steps to pause\n   */\npublic void pause(int steps) throws InterruptedException {\n    component.repaint();\n    Thread.sleep(steps * DELAY);\n}\n","name":"pause","className":"SelectionSorter","variables":{"component":1,"steps":2,"DELAY":1,"Thread":1},"javaDoc":"Pauses the animation steps the number of steps to pause","comments":"\n      Pauses the animation.\n      @param steps the number of steps to pause\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setDefaultCloseOperation":1,"startAnimation":1},"constants":{"300":1,"400":1,"true":1},"annotations":[],"types":{"JFrame":1,"int":2,"SelectionSortComponent":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    final int FRAME_WIDTH = 300;\n    final int FRAME_HEIGHT = 400;\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    final SelectionSortComponent component = new SelectionSortComponent();\n    frame.add(component, BorderLayout.CENTER);\n    frame.setVisible(true);\n    component.startAnimation();\n}\n","name":"main","className":"SelectionSortViewer","variables":{"args":1,"component":2,"FRAME_WIDTH":1,"FRAME_HEIGHT":1,"frame":5},"javaDoc":"","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"constants":{"\", new balance is \"":1,"\"Depositing \"":1},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    System.out.print(\"Depositing \" + amount);\n    double newBalance = balance + amount;\n    System.out.println(\", new balance is \" + newBalance);\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":3,"balance":2,"newBalance":3},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"constants":{"\"Withdrawing \"":1,"\", new balance is \"":1},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    System.out.print(\"Withdrawing \" + amount);\n    double newBalance = balance - amount;\n    System.out.println(\", new balance is \" + newBalance);\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":3,"balance":2,"newBalance":3},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["BankAccount","double","int"],"returnType":"WithdrawRunnable","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   */\npublic WithdrawRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"WithdrawRunnable","className":"WithdrawRunnable","variables":{"amount":1,"aCount":2,"count":1,"anAccount":2,"anAmount":2,"account":1},"javaDoc":"Constructs a withdraw runnable anAccount the account from which to withdraw money anAmount the amount to withdraw in each repetition aCount the number of repetitions","comments":"\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"withdraw":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.withdraw(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"WithdrawRunnable","variables":{"exception":1,"count":1,"account":1,"Thread":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":2},"constants":{"100":3},"annotations":[],"types":{"DepositRunnable":1,"WithdrawRunnable":1,"double":1,"BankAccount":1,"int":3,"Thread":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    BankAccount account = new BankAccount();\n    final double AMOUNT = 100;\n    final int REPETITIONS = 100;\n    final int THREADS = 100;\n    for (int i = 1; i <= THREADS; i++) {\n        DepositRunnable d = new DepositRunnable(account, AMOUNT, REPETITIONS);\n        WithdrawRunnable w = new WithdrawRunnable(account, AMOUNT, REPETITIONS);\n        Thread dt = new Thread(d);\n        Thread wt = new Thread(w);\n        dt.start();\n        wt.start();\n    }\n}\n","name":"main","className":"BankAccountThreadRunner","variables":{"args":1,"dt":2,"AMOUNT":3,"THREADS":2,"REPETITIONS":3,"wt":2,"account":3},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["BankAccount","double","int"],"returnType":"DepositRunnable","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   */\npublic DepositRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"DepositRunnable","className":"DepositRunnable","variables":{"amount":1,"aCount":2,"count":1,"anAccount":2,"anAmount":2,"account":1},"javaDoc":"Constructs a deposit runnable anAccount the account into which to deposit money anAmount the amount to deposit in each repetition aCount the number of repetitions","comments":"\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"deposit":1},"constants":{},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.deposit(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"DepositRunnable","variables":{"exception":1,"count":1,"account":1,"Thread":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"GreetingRunnable","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs the runnable object.\n      @param aGreeting the greeting to display\n   */\npublic GreetingRunnable(String aGreeting) {\n    greeting = aGreeting;\n}\n","name":"GreetingRunnable","className":"GreetingRunnable","variables":{"greeting":1,"aGreeting":2},"javaDoc":"Constructs the runnable object aGreeting the greeting to display","comments":"\n      Constructs the runnable object.\n      @param aGreeting the greeting to display\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":1},"constants":{"\" \"":1},"annotations":[],"types":{"int":1,"Date":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["TryStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":["InterruptedException"],"text":"public void run() {\n    try {\n        for (int i = 1; i <= REPETITIONS; i++) {\n            Date now = new Date();\n            System.out.println(now + \" \" + greeting);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"GreetingRunnable","variables":{"exception":1,"now":2,"greeting":1,"REPETITIONS":1,"Thread":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":2},"constants":{"\"Hello\"":1,"\"Goodbye\"":1},"annotations":[],"types":{"GreetingRunnable":2,"Thread":2},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    GreetingRunnable r1 = new GreetingRunnable(\"Hello\");\n    GreetingRunnable r2 = new GreetingRunnable(\"Goodbye\");\n    Thread t1 = new Thread(r1);\n    Thread t2 = new Thread(r2);\n    t1.start();\n    t2.start();\n}\n","name":"main","className":"GreetingThreadRunner","variables":{"args":1,"r2":2,"t1":2,"t2":2,"r1":2},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"Computer","methodCalls":{},"constants":{"\"?\"":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Computer() {\n    //all strings to \"?\", all integers to 0, and all double to 0.0 and instantiates a CPU object. .\n    brandName = \"?\";\n    cpu = new CPU();\n    memory = 0;\n    price = 0;\n}\n","name":"Computer","className":"Computer","variables":{"brandName":1,"memory":1,"price":1,"cpu":1},"javaDoc":"","comments":"all strings to \"?\" all integers to 0 and all double to 0 0 and instantiates a CPU object ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getBrandName() {\n    return brandName;\n}\n","name":"getBrandName","className":"Computer","variables":{"brandName":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"CPU","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public CPU getCPU() {\n    return cpu;\n}\n","name":"getCPU","className":"Computer","variables":{"cpu":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getMemory() {\n    return memory;\n}\n","name":"getMemory","className":"Computer","variables":{"memory":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double getPrice() {\n    return price;\n}\n","name":"getPrice","className":"Computer","variables":{"price":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setBrandName(String BrandName) {\n    brandName = BrandName;\n}\n","name":"setBrandName","className":"Computer","variables":{"BrandName":2,"brandName":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","int"],"returnType":"void","methodCalls":{"setSpeed":1,"setType":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setCPU(String cpuType, int cpuSpeed) {\n    cpu.setType(cpuType);\n    cpu.setSpeed(cpuSpeed);\n}\n","name":"setCPU","className":"Computer","variables":{"cpuType":1,"cpuSpeed":1,"cpu":2},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setMemory(int memoryAmount) {\n    memory = memoryAmount;\n}\n","name":"setMemory","className":"Computer","variables":{"memory":1,"memoryAmount":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","ThisExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setPrice(double price) {\n    this.price = price;\n}\n","name":"setPrice","className":"Computer","variables":{"price":2},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getBrandName":1,"toString":1,"getMemory":1,"getPrice":1},"constants":{"\"\\nBrandName:\\t\"":1,"\"Price:\\t\\t\"":1,"\"Memory:\\t\\t\"":1,"\"\\n\\n\"":1,"\"CPU:\\t\\t\"":1,"\"\\n\"":3},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return \"\\nBrandName:\\t\" + getBrandName() + \"\\n\" + \"CPU:\\t\\t\" + cpu.toString() + \"\\n\" + \"Memory:\\t\\t\" + getMemory() + \"\\n\" + \"Price:\\t\\t\" + getPrice() + \"\\n\\n\";\n}\n","name":"toString","className":"Computer","variables":{"cpu":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getNumberOfTires() {\n    return numberOfTires;\n}\n","name":"getNumberOfTires","className":"Vehicle","variables":{"numberOfTires":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setNumberOfTires(int newValue) {\n    numberOfTires = newValue;\n}\n","name":"setNumberOfTires","className":"Vehicle","variables":{"newValue":2,"numberOfTires":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"A vehicle with \"":1,"\" tires\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String getDescription() {\n    return \"A vehicle with \" + numberOfTires + \" tires\";\n}\n","name":"getDescription","className":"Vehicle","variables":{"numberOfTires":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Car","methodCalls":{"setNumberOfTires":1},"constants":{"\"??????\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Car() {\n    // Use the public interface to access the instance variable of the superclass\n    // same as this.setNumberOfTires(4)\n    setNumberOfTires(4);\n    licensePlateNumber = \"??????\";\n}\n","name":"Car","className":"Car","variables":{"licensePlateNumber":1},"javaDoc":"","comments":"Use the public interface to access the instance variable of the superclass same as this setNumberOfTires(4) ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"// This method is added to the subclass\npublic void setLicensePlateNumber(String newValue) {\n    licensePlateNumber = newValue;\n}\n","name":"setLicensePlateNumber","className":"Car","variables":{"newValue":2,"licensePlateNumber":1},"javaDoc":"","comments":" This method is added to the subclass","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"A car with license plate \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","StringLiteralExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"// This method overrides a method from the superclass\npublic String getDescription() {\n    return \"A car with license plate \" + licensePlateNumber;\n}\n","name":"getDescription","className":"Car","variables":{"licensePlateNumber":1},"javaDoc":"","comments":" This method overrides a method from the superclass","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Car"],"returnType":"void","methodCalls":{"getNumberOfTires":1,"getDescription":1,"System.out.println":2},"constants":{"\"Tires: \"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void print(Car c) {\n    System.out.println(c.getDescription());\n    System.out.println(\"Tires: \" + c.getNumberOfTires());\n}\n","name":"print","className":"CarDemo","variables":{},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":2,"setLicensePlateNumber":1,"setNumberOfTires":1},"constants":{"\"W00H00\"":1},"annotations":[],"types":{"Car":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Car aPlainCar = new Car();\n    print(aPlainCar);\n    Car aLimo = new Car();\n    aLimo.setLicensePlateNumber(\"W00H00\");\n    aLimo.setNumberOfTires(8);\n    print(aLimo);\n}\n","name":"main","className":"CarDemo","variables":{"args":1,"aPlainCar":1,"aLimo":3},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public int getNumberOfTires() {\n    return numberOfTires;\n}\n","name":"getNumberOfTires","className":"Vehicle","variables":{"numberOfTires":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setNumberOfTires(int newValue) {\n    numberOfTires = newValue;\n}\n","name":"setNumberOfTires","className":"Vehicle","variables":{"newValue":2,"numberOfTires":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"constants":{"\"]\"":1,"\"[numberOfTires=\"":1},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return getClass().getName() + \"[numberOfTires=\" + numberOfTires + \"]\";\n// This is a good way of implementing toString in a superclass--see Special Topic 9.6\n}\n","name":"toString","className":"Vehicle","variables":{"numberOfTires":1},"javaDoc":"","comments":"This is a good way of implementing toString in a superclass--see Special Topic 9 6 ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Car","methodCalls":{"setNumberOfTires":1},"constants":{"\"??????\"":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Car() {\n    setNumberOfTires(4);\n    licensePlateNumber = \"??????\";\n}\n","name":"Car","className":"Car","variables":{"licensePlateNumber":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void setLicensePlateNumber(String newValue) {\n    licensePlateNumber = newValue;\n}\n","name":"setLicensePlateNumber","className":"Car","variables":{"newValue":2,"licensePlateNumber":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{"\"]\"":1,"\"[licensePlateNumber=\"":1},"annotations":[],"types":{},"expressions":["SuperExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public String toString() {\n    return super.toString() + \"[licensePlateNumber=\" + licensePlateNumber + \"]\";\n// This is a good way of implementing toString in a subclass--see Special Topic 9.6\n}\n","name":"toString","className":"Car","variables":{"licensePlateNumber":1},"javaDoc":"","comments":"This is a good way of implementing toString in a subclass--see Special Topic 9 6 ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Vehicle","String"],"returnType":"void","methodCalls":{"setLicensePlateNumber":1,"System.out.println":1},"constants":{},"annotations":[],"types":{"Car":1},"expressions":["VariableDeclarationExpr","NameExpr","CastExpr","FieldAccessExpr","InstanceOfExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["Casting"],"exceptions":[],"text":"public static void process(Vehicle v, String plateNumber) {\n    // This example shows the syntax of instanceof and casting\n    if (v instanceof Car) {\n        // Vehicle has no setLicensePlateNumber method--must cast\n        Car c = (Car) v;\n        c.setLicensePlateNumber(plateNumber);\n    }\n    // calls v.toString()\n    System.out.println(v);\n}\n","name":"process","className":"VehicleDemo","variables":{"plateNumber":1},"javaDoc":"","comments":"This example shows the syntax of instanceof and casting Vehicle has no setLicensePlateNumber method--must cast calls v toString() ","isEmpty":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":3,"setNumberOfTires":1},"constants":{"\"MT1729\"":1,"\"W00H00\"":1,"\"XYX123\"":1},"annotations":[],"types":{"Vehicle":2,"Car":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":["PolyMorphism"],"exceptions":[],"text":"public static void main(String[] args) {\n    Vehicle aCar = new Car();\n    process(aCar, \"XYX123\");\n    Vehicle aLimo = new Car();\n    aLimo.setNumberOfTires(8);\n    process(aLimo, \"W00H00\");\n    process(new Motorcycle(), \"MT1729\");\n}\n","name":"main","className":"VehicleDemo","variables":{"args":1,"aLimo":2,"aCar":1},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"Motorcycle","methodCalls":{"setNumberOfTires":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public Motorcycle() {\n    setNumberOfTires(2);\n}\n","name":"Motorcycle","className":"Motorcycle","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addChoice":8,"presentQuestion":2,"setText":2},"constants":{"\"In which country was the inventor of Java born?\"":1,"\"*7\"":1,"\"Denmark\"":1,"\"United States\"":1,"\"What was the original name of the Java language?\"":1,"false":6,"true":2,"\"Canada\"":1,"\"Duke\"":1,"\"Australia\"":1,"\"Gosling\"":1,"\"Oak\"":1},"annotations":[],"types":{"ChoiceQuestion":2},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    ChoiceQuestion first = new ChoiceQuestion();\n    first.setText(\"What was the original name of the Java language?\");\n    first.addChoice(\"*7\", false);\n    first.addChoice(\"Duke\", false);\n    first.addChoice(\"Oak\", true);\n    first.addChoice(\"Gosling\", false);\n    ChoiceQuestion second = new ChoiceQuestion();\n    second.setText(\"In which country was the inventor of Java born?\");\n    second.addChoice(\"Australia\", false);\n    second.addChoice(\"Canada\", true);\n    second.addChoice(\"Denmark\", false);\n    second.addChoice(\"United States\", false);\n    presentQuestion(first);\n    presentQuestion(second);\n}\n","name":"main","className":"QuestionDemo2","variables":{"args":1,"first":6,"second":6},"javaDoc":"","isEmpty":false,"lineCount":14,"modifier":9}
{"paramTypes":["ChoiceQuestion"],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"display":1,"System.out.print":1,"System.out.println":1},"constants":{"\"Your answer: \"":1},"annotations":[],"types":{"Scanner":1,"String":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Presents a question to the user and checks the response.\n      @param q the question\n   */\npublic static void presentQuestion(ChoiceQuestion q) {\n    q.display();\n    System.out.print(\"Your answer: \");\n    Scanner in = new Scanner(System.in);\n    String response = in.nextLine();\n    System.out.println(q.checkAnswer(response));\n}\n","name":"presentQuestion","className":"QuestionDemo2","variables":{"in":2,"response":1},"javaDoc":"Presents a question to the user and checks the response q the question","comments":"\n      Presents a question to the user and checks the response.\n      @param q the question\n   ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"constants":{"\"\"":2},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":2},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":2},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":2},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ChoiceQuestion","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a choice question with no choices.\n   */\npublic ChoiceQuestion() {\n    choices = new ArrayList<String>();\n}\n","name":"ChoiceQuestion","className":"ChoiceQuestion","variables":{"choices":1},"javaDoc":"Constructs a choice question with no choices","comments":"\n      Constructs a choice question with no choices.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","boolean"],"returnType":"void","methodCalls":{"add":1,"size":1,"setAnswer":1},"constants":{"\"\"":1},"annotations":[],"types":{"String":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   */\npublic void addChoice(String choice, boolean correct) {\n    choices.add(choice);\n    if (correct) {\n        // Convert choices.size() to string\n        String choiceString = \"\" + choices.size();\n        setAnswer(choiceString);\n    }\n}\n","name":"addChoice","className":"ChoiceQuestion","variables":{"correct":2,"choiceString":1,"choice":1,"choices":2},"javaDoc":"Adds an answer choice to this question choice the choice to add correct true if this is the correct choice false otherwise","comments":"Convert choices size() to string \n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"constants":{"\": \"":1},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","SuperExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void display() {\n    // Display the question text\n    super.display();\n    // Display the answer choices\n    for (int i = 0; i < choices.size(); i++) {\n        int choiceNumber = i + 1;\n        System.out.println(choiceNumber + \": \" + choices.get(i));\n    }\n}\n","name":"display","className":"ChoiceQuestion","variables":{"choiceNumber":2,"choices":2},"javaDoc":"","comments":"Display the question text Display the answer choices ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a bank account with zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"javaDoc":"Constructs a bank account with zero balance","comments":"\n      Constructs a bank account with zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Makes a deposit into this account.\n      @param amount the amount of the deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Makes a deposit into this account amount the amount of the deposit","comments":"\n      Makes a deposit into this account.\n      @param amount the amount of the deposit\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["BinaryExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2},"javaDoc":"Makes a withdrawal from this account or charges a penalty if sufficient funds are not available amount the amount of the withdrawal","comments":"\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Carries out the end of month processing that is appropriate\n      for this account.\n   */\npublic void monthEnd() {\n}\n","name":"monthEnd","className":"BankAccount","variables":{},"javaDoc":"Carries out the end of month processing that is appropriate for this account","comments":"\n      Carries out the end of month processing that is appropriate\n      for this account.\n   ","isEmpty":true,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the current balance of this bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"javaDoc":"Gets the current balance of this bank account the current balance","comments":"\n      Gets the current balance of this bank account.\n      @return the current balance\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"SavingsAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a savings account with a zero balance.\n   */\npublic SavingsAccount() {\n    interestRate = 0;\n    minBalance = 0;\n}\n","name":"SavingsAccount","className":"SavingsAccount","variables":{"interestRate":1,"minBalance":1},"javaDoc":"Constructs a savings account with a zero balance","comments":"\n      Constructs a savings account with a zero balance.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the interest rate for this account.\n      @param rate the monthly interest rate in percent\n   */\npublic void setInterestRate(double rate) {\n    interestRate = rate;\n}\n","name":"setInterestRate","className":"SavingsAccount","variables":{"interestRate":1,"rate":2},"javaDoc":"Sets the interest rate for this account rate the monthly interest rate in percent","comments":"\n      Sets the interest rate for this account.\n      @param rate the monthly interest rate in percent\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"getBalance":1},"constants":{},"annotations":[],"types":{"double":1},"expressions":["VariableDeclarationExpr","SuperExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void withdraw(double amount) {\n    super.withdraw(amount);\n    double balance = getBalance();\n    if (balance < minBalance) {\n        minBalance = balance;\n    }\n}\n","name":"withdraw","className":"SavingsAccount","variables":{"amount":1,"minBalance":2,"balance":3},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1},"constants":{"100":1},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void monthEnd() {\n    double interest = minBalance * interestRate / 100;\n    deposit(interest);\n    minBalance = getBalance();\n}\n","name":"monthEnd","className":"SavingsAccount","variables":{"interestRate":1,"minBalance":2,"interest":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"equals":5,"setInterestRate":1,"nextInt":1,"System.out.print":2,"nextDouble":1,"System.out.println":2},"constants":{"\"D\"":2,"\"Q\"":1,"\" \"":1,"\"D)eposit  W)ithdraw  M)onth end  Q)uit: \"":1,"\"M\"":1,"false":1,"true":1,"0.75":1,"\"Enter account number and amount: \"":1,"\"W\"":1,"\"Balance: \"":1,"10":1},"annotations":[],"types":{"Scanner":1,"SavingsAccount":1,"boolean":1,"double":1,"BankAccount[]":1,"String":1,"int":5},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","AssignExpr","DoubleLiteralExpr","BooleanLiteralExpr","FieldAccessExpr","ArrayCreationExpr","MethodCallExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public static void main(String[] args) {\n    // Create accounts\n    final int ACCOUNTS_SIZE = 10;\n    BankAccount[] accounts = new BankAccount[ACCOUNTS_SIZE];\n    for (int i = 0; i < accounts.length / 2; i++) {\n        accounts[i] = new CheckingAccount();\n    }\n    for (int i = accounts.length / 2; i < accounts.length; i++) {\n        SavingsAccount account = new SavingsAccount();\n        account.setInterestRate(0.75);\n        accounts[i] = account;\n    }\n    // Execute commands\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"D)eposit  W)ithdraw  M)onth end  Q)uit: \");\n        String input = in.next();\n        if (// Deposit or withdrawal\n        input.equals(\"D\") || input.equals(\"W\")) {\n            System.out.print(\"Enter account number and amount: \");\n            int num = in.nextInt();\n            double amount = in.nextDouble();\n            if (input.equals(\"D\")) {\n                accounts[num].deposit(amount);\n            } else {\n                accounts[num].withdraw(amount);\n            }\n            System.out.println(\"Balance: \" + accounts[num].getBalance());\n        } else if (// Month end processing\n        input.equals(\"M\")) {\n            for (int n = 0; n < accounts.length; n++) {\n                accounts[n].monthEnd();\n                System.out.println(n + \" \" + accounts[n].getBalance());\n            }\n        } else if (input.equals(\"Q\")) {\n            done = true;\n        }\n    }\n}\n","name":"main","className":"AccountDemo","variables":{"args":1,"ACCOUNTS_SIZE":2,"input":6,"amount":1,"in":4,"num":4,"accounts":8,"done":3,"account":3},"javaDoc":"","comments":"Create accounts Execute commands Deposit or withdrawal Month end processing ","isEmpty":false,"lineCount":9,"modifier":9}
{"paramTypes":[],"returnType":"CheckingAccount","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a checking account with a zero balance.\n   */\npublic CheckingAccount() {\n    withdrawals = 0;\n}\n","name":"CheckingAccount","className":"CheckingAccount","variables":{"withdrawals":1},"javaDoc":"Constructs a checking account with a zero balance","comments":"\n      Constructs a checking account with a zero balance.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","SuperExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public void withdraw(double amount) {\n    final int FREE_WITHDRAWALS = 3;\n    final int WITHDRAWAL_FEE = 1;\n    super.withdraw(amount);\n    withdrawals++;\n    if (withdrawals > FREE_WITHDRAWALS) {\n        super.withdraw(WITHDRAWAL_FEE);\n    }\n}\n","name":"withdraw","className":"CheckingAccount","variables":{"amount":1,"FREE_WITHDRAWALS":2,"WITHDRAWAL_FEE":1,"withdrawals":2},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void monthEnd() {\n    withdrawals = 0;\n}\n","name":"monthEnd","className":"CheckingAccount","variables":{"withdrawals":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getName":1,"nextInt":1,"weeklyPay":1,"System.out.print":1,"System.out.println":1},"constants":{"\"Lin, Sally\"":1,"52000":1,"\"Smith, Mary\"":1,"104000":1,"\"Morgan, Harry\"":1,"\"Salary: \"":1,"\": \"":1,"50":1,"30":1,"\"Hours worked by \"":1},"annotations":[],"types":{"Scanner":1,"Employee":1,"Employee[]":1,"int":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","ArrayCreationExpr","AssignExpr","MethodCallExpr"],"statements":["BlockStmt","ForeachStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Employee[] staff = new Employee[3];\n    staff[0] = new HourlyEmployee(\"Morgan, Harry\", 30);\n    staff[1] = new SalariedEmployee(\"Lin, Sally\", 52000);\n    staff[2] = new Manager(\"Smith, Mary\", 104000, 50);\n    Scanner in = new Scanner(System.in);\n    for (Employee e : staff) {\n        System.out.print(\"Hours worked by \" + e.getName() + \": \");\n        int hours = in.nextInt();\n        System.out.println(\"Salary: \" + e.weeklyPay(hours));\n    }\n}\n","name":"main","className":"SalaryDemo","variables":{"args":1,"hours":1,"in":2,"staff":5},"javaDoc":"","isEmpty":false,"lineCount":6,"modifier":9}
{"paramTypes":["String","double","double"],"returnType":"Manager","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExplicitConstructorInvocationStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a manager with a given name, annual salary and weekly bonus.\n      @param name the name of this employee\n      @param salary the annual salary\n      @param bonus the weekly bonus\n    */\npublic Manager(String name, double salary, double bonus) {\n    super(name, salary);\n    weeklyBonus = bonus;\n}\n","name":"Manager","className":"Manager","variables":{"bonus":2,"name":2,"weeklyBonus":1,"salary":2},"javaDoc":"Constructs a manager with a given name annual salary and weekly bonus name the name of this employee salary the annual salary bonus the weekly bonus","comments":"\n      Constructs a manager with a given name, annual salary and weekly bonus.\n      @param name the name of this employee\n      @param salary the annual salary\n      @param bonus the weekly bonus\n    ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["SuperExpr","BinaryExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"public double weeklyPay(int hoursWorked) {\n    return super.weeklyPay(hoursWorked) + weeklyBonus;\n}\n","name":"weeklyPay","className":"Manager","variables":{"weeklyBonus":1,"hoursWorked":1},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Employee","methodCalls":{},"constants":{"\"\"":1},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an employee with an empty name.\n   */\npublic Employee() {\n    name = \"\";\n}\n","name":"Employee","className":"Employee","variables":{"name":1},"javaDoc":"Constructs an employee with an empty name","comments":"\n      Constructs an employee with an empty name.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the name of this employee.\n      @param employeeName the new name \n   */\npublic void setName(String employeeName) {\n    name = employeeName;\n}\n","name":"setName","className":"Employee","variables":{"employeeName":2,"name":1},"javaDoc":"Sets the name of this employee employeeName the new name","comments":"\n      Sets the name of this employee.\n      @param employeeName the new name \n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the name of this employee.\n      @return the name \n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Employee","variables":{"name":1},"javaDoc":"Gets the name of this employee the name","comments":"\n      Gets the name of this employee.\n      @return the name \n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Computes the pay for one week of work.\n      @param hoursWorked the number of hours worked in the week\n      @return the pay for the given number of hours\n   */\npublic double weeklyPay(int hoursWorked) {\n    return 0;\n}\n","name":"weeklyPay","className":"Employee","variables":{"hoursWorked":1},"javaDoc":"Computes the pay for one week of work hoursWorked the number of hours worked in the week the pay for the given number of hours","comments":"\n      Computes the pay for one week of work.\n      @param hoursWorked the number of hours worked in the week\n      @return the pay for the given number of hours\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","double"],"returnType":"SalariedEmployee","methodCalls":{"setName":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a salaried employee with a given name and annual salary.\n      @param name the name of this employee\n      @param salary the annual salary\n    */\npublic SalariedEmployee(String name, double salary) {\n    setName(name);\n    annualSalary = salary;\n}\n","name":"SalariedEmployee","className":"SalariedEmployee","variables":{"annualSalary":1,"name":1,"salary":2},"javaDoc":"Constructs a salaried employee with a given name and annual salary name the name of this employee salary the annual salary","comments":"\n      Constructs a salaried employee with a given name and annual salary.\n      @param name the name of this employee\n      @param salary the annual salary\n    ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"constants":{"52":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"public double weeklyPay(int hoursWorked) {\n    final int WEEKS_PER_YEAR = 52;\n    return annualSalary / WEEKS_PER_YEAR;\n}\n","name":"weeklyPay","className":"SalariedEmployee","variables":{"annualSalary":1,"WEEKS_PER_YEAR":2,"hoursWorked":1},"javaDoc":"","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String","double"],"returnType":"HourlyEmployee","methodCalls":{"setName":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs an hourly employee with a given name and weekly wage.\n      @param name the name of this employee\n      @param wage the hourly wage \n   */\npublic HourlyEmployee(String name, double wage) {\n    setName(name);\n    hourlyWage = wage;\n}\n","name":"HourlyEmployee","className":"HourlyEmployee","variables":{"hourlyWage":1,"name":1,"wage":2},"javaDoc":"Constructs an hourly employee with a given name and weekly wage name the name of this employee wage the hourly wage","comments":"\n      Constructs an hourly employee with a given name and weekly wage.\n      @param name the name of this employee\n      @param wage the hourly wage \n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"constants":{"0.5":1,"40":2},"annotations":[],"types":{"double":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","DoubleLiteralExpr","BinaryExpr","NameExpr","EnclosedExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public double weeklyPay(int hoursWorked) {\n    double pay = hoursWorked * hourlyWage;\n    if (hoursWorked > 40) {\n        // Add overtime\n        pay = pay + ((hoursWorked - 40) * 0.5) * hourlyWage;\n    }\n    return pay;\n}\n","name":"weeklyPay","className":"HourlyEmployee","variables":{"hourlyWage":2,"pay":4,"hoursWorked":4},"javaDoc":"","comments":"Add overtime ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"setAnswer":1,"display":1,"System.out.print":1,"setText":1,"System.out.println":1},"constants":{"\"Who was the inventor of Java?\"":1,"\"Your answer: \"":1,"\"James Gosling\"":1},"annotations":[],"types":{"Scanner":1,"Question":1,"String":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    Question q = new Question();\n    q.setText(\"Who was the inventor of Java?\");\n    q.setAnswer(\"James Gosling\");\n    q.display();\n    System.out.print(\"Your answer: \");\n    String response = in.nextLine();\n    System.out.println(q.checkAnswer(response));\n}\n","name":"main","className":"QuestionDemo1","variables":{"args":1,"in":2,"response":1},"javaDoc":"","isEmpty":false,"lineCount":8,"modifier":9}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"constants":{"\"\"":2},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":2},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":2},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":2},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setAnswer":1,"addChoice":4,"presentQuestion":2,"setText":2},"constants":{"\"Who was the inventor of Java?\"":1,"\"In which country was the inventor of Java born?\"":1,"\"Denmark\"":1,"\"United States\"":1,"\"James Gosling\"":1,"false":3,"true":1,"\"Canada\"":1,"\"Australia\"":1},"annotations":[],"types":{"Question":1,"ChoiceQuestion":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    Question first = new Question();\n    first.setText(\"Who was the inventor of Java?\");\n    first.setAnswer(\"James Gosling\");\n    ChoiceQuestion second = new ChoiceQuestion();\n    second.setText(\"In which country was the inventor of Java born?\");\n    second.addChoice(\"Australia\", false);\n    second.addChoice(\"Canada\", true);\n    second.addChoice(\"Denmark\", false);\n    second.addChoice(\"United States\", false);\n    presentQuestion(first);\n    presentQuestion(second);\n}\n","name":"main","className":"QuestionDemo3","variables":{"args":1,"first":3,"second":6},"javaDoc":"","isEmpty":false,"lineCount":11,"modifier":9}
{"paramTypes":["Question"],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"display":1,"System.out.print":1,"System.out.println":1},"constants":{"\"Your answer: \"":1},"annotations":[],"types":{"Scanner":1,"String":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Presents a question to the user and checks the response.\n      @param q the question\n   */\npublic static void presentQuestion(Question q) {\n    q.display();\n    System.out.print(\"Your answer: \");\n    Scanner in = new Scanner(System.in);\n    String response = in.nextLine();\n    System.out.println(q.checkAnswer(response));\n}\n","name":"presentQuestion","className":"QuestionDemo3","variables":{"in":2,"response":1},"javaDoc":"Presents a question to the user and checks the response q the question","comments":"\n      Presents a question to the user and checks the response.\n      @param q the question\n   ","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"constants":{"\"\"":2},"annotations":[],"types":{},"expressions":["NameExpr","StringLiteralExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":2},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":2},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","MethodCallExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":2},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr","FieldAccessExpr","MethodCallExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ChoiceQuestion","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a choice question with no choices.\n   */\npublic ChoiceQuestion() {\n    choices = new ArrayList<String>();\n}\n","name":"ChoiceQuestion","className":"ChoiceQuestion","variables":{"choices":1},"javaDoc":"Constructs a choice question with no choices","comments":"\n      Constructs a choice question with no choices.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","boolean"],"returnType":"void","methodCalls":{"add":1,"size":1,"setAnswer":1},"constants":{"\"\"":1},"annotations":[],"types":{"String":1},"expressions":["VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   */\npublic void addChoice(String choice, boolean correct) {\n    choices.add(choice);\n    if (correct) {\n        // Convert choices.size() to string\n        String choiceString = \"\" + choices.size();\n        setAnswer(choiceString);\n    }\n}\n","name":"addChoice","className":"ChoiceQuestion","variables":{"correct":2,"choiceString":1,"choice":1,"choices":2},"javaDoc":"Adds an answer choice to this question choice the choice to add correct true if this is the correct choice false otherwise","comments":"Convert choices size() to string \n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"constants":{"\": \"":1},"annotations":[],"types":{"int":2},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","SuperExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public void display() {\n    // Display the question text\n    super.display();\n    // Display the answer choices\n    for (int i = 0; i < choices.size(); i++) {\n        int choiceNumber = i + 1;\n        System.out.println(choiceNumber + \": \" + choices.get(i));\n    }\n}\n","name":"display","className":"ChoiceQuestion","variables":{"choiceNumber":2,"choices":2},"javaDoc":"","comments":"Display the question text Display the answer choices ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"ArrayList","methodCalls":{},"constants":{"10":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"/**\n      Constructs an empty array list.\n   */\npublic ArrayList() {\n    final int INITIAL_SIZE = 10;\n    elements = new Object[INITIAL_SIZE];\n    currentSize = 0;\n}\n","name":"ArrayList","className":"ArrayList","variables":{"INITIAL_SIZE":2,"elements":1,"currentSize":1},"javaDoc":"Constructs an empty array list","comments":"\n      Constructs an empty array list.\n   ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the size of this array list.\n      @return the size\n   */\npublic int size() {\n    return currentSize;\n}\n","name":"size","className":"ArrayList","variables":{"currentSize":1},"javaDoc":"Gets the size of this array list the size","comments":"\n      Gets the size of this array list.\n      @return the size\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Throws an IndexOutOfBoundsException if the checked index is out of bounds\n      @param n the index to check\n   */\nprivate void checkBounds(int n) {\n    if (n < 0 || n >= currentSize) {\n        throw new IndexOutOfBoundsException();\n    }\n}\n","name":"checkBounds","className":"ArrayList","variables":{"currentSize":1},"javaDoc":"Throws an IndexOutOfBoundsException if the checked index is out of bounds n the index to check","comments":"\n      Throws an IndexOutOfBoundsException if the checked index is out of bounds\n      @param n the index to check\n   ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"checkBounds":1},"constants":{},"annotations":[],"types":{},"expressions":["ArrayAccessExpr","NameExpr","MethodCallExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the element at a given position.\n      @param pos the position\n      @return the element at pos\n   */\npublic Object get(int pos) {\n    checkBounds(pos);\n    return elements[pos];\n}\n","name":"get","className":"ArrayList","variables":{"pos":2,"elements":1},"javaDoc":"Gets the element at a given position pos the position the element at pos","comments":"\n      Gets the element at a given position.\n      @param pos the position\n      @return the element at pos\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"checkBounds":1},"constants":{},"annotations":[],"types":{},"expressions":["ArrayAccessExpr","NameExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Sets the element at a given position.\n      @param pos the position\n      @param element the new value\n   */\npublic void set(int pos, Object element) {\n    checkBounds(pos);\n    elements[pos] = element;\n}\n","name":"set","className":"ArrayList","variables":{"pos":2,"elements":1,"element":2},"javaDoc":"Sets the element at a given position pos the position element the new value","comments":"\n      Sets the element at a given position.\n      @param pos the position\n      @param element the new value\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"checkBounds":1},"constants":{},"annotations":[],"types":{"Object":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes the element at a given position.\n      @param pos the position\n      @return the removed element\n   */\npublic Object remove(int pos) {\n    checkBounds(pos);\n    Object removed = elements[pos];\n    for (int i = pos + 1; i < currentSize; i++) {\n        elements[i - 1] = elements[i];\n    }\n    currentSize--;\n    return removed;\n}\n","name":"remove","className":"ArrayList","variables":{"removed":2,"pos":3,"elements":3,"currentSize":2},"javaDoc":"Removes the element at a given position pos the position the removed element","comments":"\n      Removes the element at a given position.\n      @param pos the position\n      @return the removed element\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"boolean","methodCalls":{"checkBounds":1,"growIfNecessary":1},"constants":{"true":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["BlockStmt","ForStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element after a given position.\n      @param pos the position\n      @param newElement the element to add\n   */\npublic boolean add(int pos, Object newElement) {\n    growIfNecessary();\n    currentSize++;\n    checkBounds(pos);\n    for (int i = currentSize - 1; i > pos; i--) {\n        elements[i] = elements[i - 1];\n    }\n    elements[pos] = newElement;\n    return true;\n}\n","name":"add","className":"ArrayList","variables":{"pos":3,"elements":3,"newElement":2,"currentSize":2},"javaDoc":"Adds an element after a given position pos the position newElement the element to add","comments":"\n      Adds an element after a given position.\n      @param pos the position\n      @param newElement the element to add\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"growIfNecessary":1},"constants":{"true":1},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element after the end of the array list\n      @param newElement the element to add\n   */\npublic boolean addLast(Object newElement) {\n    growIfNecessary();\n    currentSize++;\n    elements[currentSize - 1] = newElement;\n    return true;\n}\n","name":"addLast","className":"ArrayList","variables":{"elements":1,"newElement":2,"currentSize":2},"javaDoc":"Adds an element after the end of the array list newElement the element to add","comments":"\n      Adds an element after the end of the array list\n      @param newElement the element to add\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"Object[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","ArrayCreationExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Grows the elements array if the current size equals the capacity.\n   */\nprivate void growIfNecessary() {\n    if (currentSize == elements.length) {\n        Object[] newElements = new Object[2 * elements.length];\n        for (int i = 0; i < elements.length; i++) {\n            newElements[i] = elements[i];\n        }\n        elements = newElements;\n    }\n}\n","name":"growIfNecessary","className":"ArrayList","variables":{"elements":2,"newElements":3,"currentSize":1},"javaDoc":"Grows the elements array if the current size equals the capacity","comments":"\n      Grows the elements array if the current size equals the capacity.\n   ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"addLast":3,"size":1,"get":1,"remove":1,"System.out.println":1},"constants":{"\"Tom\"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"10":1},"annotations":[],"types":{"ArrayList":1,"int":2},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    ArrayList staff = new ArrayList();\n    staff.addLast(\"Diana\");\n    staff.addLast(\"Harry\");\n    for (int i = 1; i <= 10; i++) {\n        staff.addLast(\"Tom\" + i);\n    }\n    staff.add(0, \"Juliet\");\n    staff.remove(1);\n    for (int i = 0; i < staff.size(); i++) {\n        System.out.println(staff.get(i));\n    }\n}\n","name":"main","className":"ArrayListDemo","variables":{"args":1,"staff":8},"javaDoc":"","isEmpty":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"CircularArrayQueue","methodCalls":{},"constants":{"10":1},"annotations":[],"types":{"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":["FinalVariables"],"exceptions":[],"text":"/**\n      Constructs an empty queue.\n   */\npublic CircularArrayQueue() {\n    final int INITIAL_SIZE = 10;\n    elements = new Object[INITIAL_SIZE];\n    currentSize = 0;\n    head = 0;\n    tail = 0;\n}\n","name":"CircularArrayQueue","className":"CircularArrayQueue","variables":{"head":1,"INITIAL_SIZE":2,"tail":1,"elements":1,"currentSize":1},"javaDoc":"Constructs an empty queue","comments":"\n      Constructs an empty queue.\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether this queue is empty.\n      @return true if this queue is empty\n   */\npublic boolean empty() {\n    return currentSize == 0;\n}\n","name":"empty","className":"CircularArrayQueue","variables":{"currentSize":1},"javaDoc":"Checks whether this queue is empty true if this queue is empty","comments":"\n      Checks whether this queue is empty.\n      @return true if this queue is empty\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"growIfNecessary":1},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","EnclosedExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element to the tail of this queue.\n      @param newElement the element to add\n   */\npublic void add(Object newElement) {\n    growIfNecessary();\n    currentSize++;\n    elements[tail] = newElement;\n    tail = (tail + 1) % elements.length;\n}\n","name":"add","className":"CircularArrayQueue","variables":{"tail":3,"elements":1,"newElement":2,"currentSize":1},"javaDoc":"Adds an element to the tail of this queue newElement the element to add","comments":"\n      Adds an element to the tail of this queue.\n      @param newElement the element to add\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{},"annotations":[],"types":{"Object":1},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","EnclosedExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes an element from the head of this queue.\n      @return the removed element\n   */\npublic Object remove() {\n    if (currentSize == 0) {\n        throw new NoSuchElementException();\n    }\n    Object removed = elements[head];\n    head = (head + 1) % elements.length;\n    currentSize--;\n    return removed;\n}\n","name":"remove","className":"CircularArrayQueue","variables":{"head":3,"removed":2,"elements":1,"currentSize":2},"javaDoc":"Removes an element from the head of this queue the removed element","comments":"\n      Removes an element from the head of this queue.\n      @return the removed element\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"Object[]":1,"int":1},"expressions":["IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","EnclosedExpr","ArrayCreationExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ForStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Grows the element array if the current size equals the capacity.\n   */\nprivate void growIfNecessary() {\n    if (currentSize == elements.length) {\n        Object[] newElements = new Object[2 * elements.length];\n        for (int i = 0; i < elements.length; i++) {\n            newElements[i] = elements[(head + i) % elements.length];\n        }\n        elements = newElements;\n        head = 0;\n        tail = currentSize;\n    }\n}\n","name":"growIfNecessary","className":"CircularArrayQueue","variables":{"head":2,"tail":1,"elements":2,"newElements":3,"currentSize":2},"javaDoc":"Grows the element array if the current size equals the capacity","comments":"\n      Grows the element array if the current size equals the capacity.\n   ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"remove":1,"empty":1,"System.out.println":1},"constants":{"\"Tom\"":1,"\"Diana\"":1,"\"Harry\"":1},"annotations":[],"types":{"CircularArrayQueue":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    CircularArrayQueue q = new CircularArrayQueue();\n    q.add(\"Tom\");\n    q.add(\"Diana\");\n    q.add(\"Harry\");\n    while (!q.empty()) {\n        System.out.println(q.remove());\n    }\n}\n","name":"main","className":"QueueDemo","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":4,"add":2,"addLast":4,"previous":1,"listIterator":2,"hasNext":1,"remove":1,"System.out.print":1,"System.out.println":3},"constants":{"\"Nina\"":1,"\"Tom\"":1,"\" \"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Romeo\"":1},"annotations":[],"types":{"ListIterator":1,"LinkedList":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    LinkedList staff = new LinkedList();\n    staff.addLast(\"Diana\");\n    staff.addLast(\"Harry\");\n    staff.addLast(\"Romeo\");\n    staff.addLast(\"Tom\");\n    // | in the comments indicates the iterator position\n    // |DHRT\n    ListIterator iterator = staff.listIterator();\n    // D|HRT\n    iterator.next();\n    // DH|RT\n    iterator.next();\n    // Add more elements after second element\n    // DHJ|RT\n    iterator.add(\"Juliet\");\n    // DHJN|RT\n    iterator.add(\"Nina\");\n    // DHJNR|T\n    System.out.println(iterator.next());\n    // DHJN|RT\n    System.out.println(iterator.previous());\n    // Remove last traversed element \n    // DHJN|T\n    iterator.remove();\n    // Print all elements\n    iterator = staff.listIterator();\n    while (iterator.hasNext()) {\n        System.out.print(iterator.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"ListDemo","variables":{"args":1,"iterator":11,"staff":7},"javaDoc":"","comments":"| in the comments indicates the iterator position Add more elements after second element Remove last traversed element Print all elements |DHRT D|HRT DH|RT DHJ|RT DHJN|RT DHJNR|T DHJN|RT DHJN|T ","isEmpty":false,"lineCount":20,"modifier":9}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Moves the iterator past the next element.\n      @return the traversed element\n   */\nObject next();\n","name":"next","className":"ListIterator","variables":{},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n      Moves the iterator past the next element.\n      @return the traversed element\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   */\nboolean hasNext();\n","name":"hasNext","className":"ListIterator","variables":{},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Moves the iterator after the previous element.\n      @return the traversed element\n   */\nObject previous();\n","name":"previous","className":"ListIterator","variables":{},"javaDoc":"Moves the iterator after the previous element the traversed element","comments":"\n      Moves the iterator after the previous element.\n      @return the traversed element\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Tests if there is an element before the iterator position.\n      @return true if there is an element before the iterator position\n   */\nboolean hasPrevious();\n","name":"hasPrevious","className":"ListIterator","variables":{},"javaDoc":"Tests if there is an element before the iterator position true if there is an element before the iterator position","comments":"\n      Tests if there is an element before the iterator position.\n      @return true if there is an element before the iterator position\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   */\nvoid add(Object element);\n","name":"add","className":"ListIterator","variables":{"element":1},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   */\nvoid remove();\n","name":"remove","className":"ListIterator","variables":{},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   */\nvoid set(Object element);\n","name":"set","className":"ListIterator","variables":{"element":1},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"LinkedList","methodCalls":{},"constants":{"null":2},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Constructs an empty linked list.\n   */\npublic LinkedList() {\n    first = null;\n    last = null;\n}\n","name":"LinkedList","className":"LinkedList","variables":{"last":1,"first":1},"javaDoc":"Constructs an empty linked list","comments":" \n      Constructs an empty linked list.\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   */\npublic Object getFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    return first.data;\n}\n","name":"getFirst","className":"LinkedList","variables":{"first":1},"javaDoc":"Returns the first element in the linked list the first element in the linked list","comments":"\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":4},"annotations":[],"types":{"Object":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes the first element in the linked list.\n      @return the removed element\n   */\npublic Object removeFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    if (// List is now empty\n    first == null) // List is now empty\n    {\n        last = null;\n    } else {\n        first.previous = null;\n    }\n    return element;\n}\n","name":"removeFirst","className":"LinkedList","variables":{"last":1,"first":3,"element":2},"javaDoc":"Removes the first element in the linked list the removed element","comments":"List is now empty List is now empty \n      Removes the first element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{"null":2},"annotations":[],"types":{"Node":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   */\npublic void addFirst(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    newNode.previous = null;\n    if (first == null) {\n        last = newNode;\n    } else {\n        first.previous = newNode;\n    }\n    first = newNode;\n}\n","name":"addFirst","className":"LinkedList","variables":{"last":1,"newNode":4,"first":3,"element":2},"javaDoc":"Adds an element to the front of the linked list element the element to add","comments":"\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the last element in the linked list.\n      @return the last element in the linked list\n   */\npublic Object getLast() {\n    if (last == null) {\n        throw new NoSuchElementException();\n    }\n    return last.data;\n}\n","name":"getLast","className":"LinkedList","variables":{"last":1},"javaDoc":"Returns the last element in the linked list the last element in the linked list","comments":"\n      Returns the last element in the linked list.\n      @return the last element in the linked list\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":4},"annotations":[],"types":{"Object":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes the last element in the linked list.\n      @return the removed element\n   */\npublic Object removeLast() {\n    if (last == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = last.data;\n    last = last.previous;\n    if (// List is now empty\n    last == null) // List is now empty\n    {\n        first = null;\n    } else {\n        last.next = null;\n    }\n    return element;\n}\n","name":"removeLast","className":"LinkedList","variables":{"last":3,"first":1,"element":2},"javaDoc":"Removes the last element in the linked list the removed element","comments":"List is now empty List is now empty \n      Removes the last element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{"null":2},"annotations":[],"types":{"Node":1},"expressions":["ObjectCreationExpr","NullLiteralExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element to the back of the linked list.\n      @param element the element to add\n   */\npublic void addLast(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = null;\n    newNode.previous = last;\n    if (last == null) {\n        first = newNode;\n    } else {\n        last.next = newNode;\n    }\n    last = newNode;\n}\n","name":"addLast","className":"LinkedList","variables":{"last":3,"newNode":4,"first":1,"element":2},"javaDoc":"Adds an element to the back of the linked list element the element to add","comments":"\n      Adds an element to the back of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"ListIterator","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   */\npublic ListIterator listIterator() {\n    return new LinkedListIterator();\n}\n","name":"listIterator","className":"LinkedList","variables":{},"javaDoc":"Returns an iterator for iterating through this list an iterator for iterating through this list","comments":"\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"LinkedListIterator","methodCalls":{},"constants":{"null":1,"false":2},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BooleanLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Constructs an iterator that points to the front\n         of the linked list.\n      */\npublic LinkedListIterator() {\n    position = null;\n    isAfterNext = false;\n    isAfterPrevious = false;\n}\n","name":"LinkedListIterator","className":"LinkedListIterator","variables":{"isAfterPrevious":1,"position":1,"isAfterNext":1},"javaDoc":"Constructs an iterator that points to the front of the linked list","comments":"\n         Constructs an iterator that points to the front\n         of the linked list.\n      ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1},"constants":{"null":1,"true":1,"false":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NullLiteralExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Moves the iterator past the next element.\n         @return the traversed element\n      */\npublic Object next() {\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    isAfterNext = true;\n    isAfterPrevious = false;\n    if (position == null) {\n        position = first;\n    } else {\n        position = position.next;\n    }\n    return position.data;\n}\n","name":"next","className":"LinkedListIterator","variables":{"isAfterPrevious":1,"position":3,"first":1,"isAfterNext":1},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n         Moves the iterator past the next element.\n         @return the traversed element\n      ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{"null":3},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      */\npublic boolean hasNext() {\n    if (position == null) {\n        return first != null;\n    } else {\n        return position.next != null;\n    }\n}\n","name":"hasNext","className":"LinkedListIterator","variables":{"position":1,"first":1},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasPrevious":1},"constants":{"false":1,"true":1},"annotations":[],"types":{"Object":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Moves the iterator before the previous element.\n         @return the traversed element\n      */\npublic Object previous() {\n    if (!hasPrevious()) {\n        throw new NoSuchElementException();\n    }\n    isAfterNext = false;\n    isAfterPrevious = true;\n    Object result = position.data;\n    position = position.previous;\n    return result;\n}\n","name":"previous","className":"LinkedListIterator","variables":{"result":2,"isAfterPrevious":1,"position":1,"isAfterNext":1},"javaDoc":"Moves the iterator before the previous element the traversed element","comments":"\n         Moves the iterator before the previous element.\n         @return the traversed element\n      ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Tests if there is an element before the iterator position.\n         @return true if there is an element before the iterator position\n      */\npublic boolean hasPrevious() {\n    return position != null;\n}\n","name":"hasPrevious","className":"LinkedListIterator","variables":{"position":1},"javaDoc":"Tests if there is an element before the iterator position true if there is an element before the iterator position","comments":"\n         Tests if there is an element before the iterator position.\n         @return true if there is an element before the iterator position\n      ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"addLast":1,"addFirst":1},"constants":{"null":1,"false":2},"annotations":[],"types":{"Node":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      */\npublic void add(Object element) {\n    if (position == null) {\n        addFirst(element);\n        position = first;\n    } else if (position == last) {\n        addLast(element);\n        position = last;\n    } else {\n        Node newNode = new Node();\n        newNode.data = element;\n        newNode.next = position.next;\n        newNode.next.previous = newNode;\n        position.next = newNode;\n        newNode.previous = position;\n        position = newNode;\n    }\n    isAfterNext = false;\n    isAfterPrevious = false;\n}\n","name":"add","className":"LinkedListIterator","variables":{"last":2,"isAfterPrevious":1,"newNode":4,"position":6,"first":1,"element":2,"isAfterNext":1},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeFirst":1,"lastPosition":1,"removeLast":1},"constants":{"false":2},"annotations":[],"types":{"Node":1},"expressions":["VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      */\npublic void remove() {\n    Node positionToRemove = lastPosition();\n    if (positionToRemove == first) {\n        removeFirst();\n    } else if (positionToRemove == last) {\n        removeLast();\n    } else {\n        positionToRemove.previous.next = positionToRemove.next;\n        positionToRemove.next.previous = positionToRemove.previous;\n    }\n    if (isAfterNext) {\n        position = position.previous;\n    }\n    isAfterNext = false;\n    isAfterPrevious = false;\n}\n","name":"remove","className":"LinkedListIterator","variables":{"last":1,"isAfterPrevious":1,"position":1,"positionToRemove":3,"first":1,"isAfterNext":2},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"lastPosition":1},"constants":{},"annotations":[],"types":{"Node":1},"expressions":["VariableDeclarationExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      */\npublic void set(Object element) {\n    Node positionToSet = lastPosition();\n    positionToSet.data = element;\n}\n","name":"set","className":"LinkedListIterator","variables":{"positionToSet":1,"element":2},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Node","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ThrowStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Returns the last node traversed by this iterator, or\n         throws an IllegalStateException if there wasn't an immediately\n         preceding call to next or previous.\n         @return the last traversed node\n      */\nprivate Node lastPosition() {\n    if (isAfterNext) {\n        return position;\n    } else if (isAfterPrevious) {\n        if (position == null) {\n            return first;\n        } else {\n            return position.next;\n        }\n    } else {\n        throw new IllegalStateException();\n    }\n}\n","name":"lastPosition","className":"LinkedListIterator","variables":{"isAfterPrevious":1,"position":2,"first":1,"isAfterNext":1},"javaDoc":"Returns the last node traversed by this iterator or throws an IllegalStateException if there wasn't an immediately preceding call to next or previous the last traversed node","comments":"\n         Returns the last node traversed by this iterator, or\n         throws an IllegalStateException if there wasn't an immediately\n         preceding call to next or previous.\n         @return the last traversed node\n      ","isEmpty":false,"lineCount":1,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":17,"add":3,"addLast":19,"set":4,"previous":8,"removeFirst":2,"listIterator":4,"assertEquals":29,"check":27,"removeLast":2,"addFirst":2,"remove":6},"constants":{"\"\"":8,"\"D\"":8,"\"Add first element\"":1,"\"EBC\"":1,"\"EFG\"":1,"\"B\"":15,"\"Adding first to non-empty list\"":1,"\"Adding last to non-empty list\"":1,"\"ABCD\"":1,"\"Removing last, yielding non-empty list\"":1,"\"BC\"":1,"\"Adding last to empty list\"":1,"\"Set second element after previous\"":1,"\"Removing first, yielding non-empty list\"":1,"\"Constructing empty list\"":1,"\"Removing first, yielding empty list\"":1,"\"ABDC\"":1,"\"Remove last element after next\"":1,"\"ABD\"":1,"\"G\"":1,"\"Add middle element\"":1,"\"E\"":8,"\"BDE\"":1,"\"DBC\"":1,"\"Remove middle element after previous\"":1,"\"C\"":10,"\"ABCDE\"":2,"\"A\"":17,"\"Removing last, yielding empty list\"":1,"\"Adding first to empty list\"":1,"\"Set element after next\"":1,"\"Set last element after previous\"":1,"\"Remove last element after previous\"":1,"\"BD\"":2,"\"AB\"":2,"\"Set first element after previous\"":1,"\"BA\"":1,"\"Remove first element after next\"":1,"\"BCDE\"":1,"\"Remove middle element after next\"":1,"\"Remove first element after previous\"":1,"\"Add last element\"":1,"\"EFC\"":1,"\"F\"":2,"\"ABC\"":2,"\"ABDCE\"":1},"annotations":[],"types":{"ListIterator":1,"LinkedList":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","MethodCallExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    LinkedList lst = new LinkedList();\n    check(\"\", lst, \"Constructing empty list\");\n    lst.addLast(\"A\");\n    check(\"A\", lst, \"Adding last to empty list\");\n    lst.addLast(\"B\");\n    check(\"AB\", lst, \"Adding last to non-empty list\");\n    lst = new LinkedList();\n    lst.addFirst(\"A\");\n    check(\"A\", lst, \"Adding first to empty list\");\n    lst.addFirst(\"B\");\n    check(\"BA\", lst, \"Adding first to non-empty list\");\n    assertEquals(\"B\", lst.removeFirst());\n    check(\"A\", lst, \"Removing first, yielding non-empty list\");\n    assertEquals(\"A\", lst.removeFirst());\n    check(\"\", lst, \"Removing first, yielding empty list\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    check(\"AB\", lst, \"\");\n    assertEquals(\"B\", lst.removeLast());\n    check(\"A\", lst, \"Removing last, yielding non-empty list\");\n    assertEquals(\"A\", lst.removeLast());\n    check(\"\", lst, \"Removing last, yielding empty list\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    check(\"ABC\", lst, \"\");\n    ListIterator iter = lst.listIterator();\n    assertEquals(\"A\", iter.next());\n    iter.set(\"D\");\n    check(\"DBC\", lst, \"Set element after next\");\n    assertEquals(\"D\", iter.previous());\n    iter.set(\"E\");\n    check(\"EBC\", lst, \"Set first element after previous\");\n    assertEquals(\"E\", iter.next());\n    assertEquals(\"B\", iter.next());\n    assertEquals(\"B\", iter.previous());\n    iter.set(\"F\");\n    check(\"EFC\", lst, \"Set second element after previous\");\n    assertEquals(\"F\", iter.next());\n    assertEquals(\"C\", iter.next());\n    assertEquals(\"C\", iter.previous());\n    iter.set(\"G\");\n    check(\"EFG\", lst, \"Set last element after previous\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    lst.addLast(\"D\");\n    lst.addLast(\"E\");\n    check(\"ABCDE\", lst, \"\");\n    iter = lst.listIterator();\n    assertEquals(\"A\", iter.next());\n    iter.remove();\n    check(\"BCDE\", lst, \"Remove first element after next\");\n    assertEquals(\"B\", iter.next());\n    assertEquals(\"C\", iter.next());\n    iter.remove();\n    check(\"BDE\", lst, \"Remove middle element after next\");\n    assertEquals(\"D\", iter.next());\n    assertEquals(\"E\", iter.next());\n    iter.remove();\n    check(\"BD\", lst, \"Remove last element after next\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    lst.addLast(\"D\");\n    lst.addLast(\"E\");\n    check(\"ABCDE\", lst, \"\");\n    iter = lst.listIterator();\n    assertEquals(\"A\", iter.next());\n    assertEquals(\"B\", iter.next());\n    assertEquals(\"C\", iter.next());\n    assertEquals(\"D\", iter.next());\n    assertEquals(\"E\", iter.next());\n    assertEquals(\"E\", iter.previous());\n    iter.remove();\n    check(\"ABCD\", lst, \"Remove last element after previous\");\n    assertEquals(\"D\", iter.previous());\n    assertEquals(\"C\", iter.previous());\n    iter.remove();\n    check(\"ABD\", lst, \"Remove middle element after previous\");\n    assertEquals(\"B\", iter.previous());\n    assertEquals(\"A\", iter.previous());\n    iter.remove();\n    check(\"BD\", lst, \"Remove first element after previous\");\n    lst = new LinkedList();\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    check(\"BC\", lst, \"\");\n    iter = lst.listIterator();\n    iter.add(\"A\");\n    check(\"ABC\", lst, \"Add first element\");\n    assertEquals(\"B\", iter.next());\n    iter.add(\"D\");\n    check(\"ABDC\", lst, \"Add middle element\");\n    assertEquals(\"C\", iter.next());\n    iter.add(\"E\");\n    check(\"ABDCE\", lst, \"Add last element\");\n}\n","name":"main","className":"LinkedListTest","variables":{"args":1,"iter":42,"lst":36},"javaDoc":"","isEmpty":false,"lineCount":101,"modifier":9}
{"paramTypes":["Object","Object"],"returnType":"void","methodCalls":{"equals":1},"constants":{"null":2,"\"Expected \"":1,"\" but found \"":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr","StringLiteralExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether two objects are equal and throws an exception if not.\n      @param expected the expected value\n      @param actual the actual value\n   */\npublic static void assertEquals(Object expected, Object actual) {\n    if (expected == null && actual != null || !expected.equals(actual)) {\n        throw new AssertionError(\"Expected \" + expected + \" but found \" + actual);\n    }\n}\n","name":"assertEquals","className":"LinkedListTest","variables":{"actual":3,"expected":4},"javaDoc":"Checks whether two objects are equal and throws an exception if not expected the expected value actual the actual value","comments":"\n      Checks whether two objects are equal and throws an exception if not.\n      @param expected the expected value\n      @param actual the actual value\n   ","isEmpty":false,"lineCount":1,"modifier":9}
{"paramTypes":["String","LinkedList","String"],"returnType":"void","methodCalls":{"next":1,"previous":1,"getFirst":2,"length":2,"listIterator":1,"hasPrevious":2,"assertEquals":8,"hasNext":2,"getLast":2,"substring":4,"System.out.println":1},"constants":{"\"Passed \\\"\"":1,"\"last not null\"":1,"\"\\\".\"":1,"true":2,"false":2,"\"first not null\"":1},"annotations":[],"types":{"ListIterator":1,"int":3},"expressions":["IntegerLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["IfStmt","BlockStmt","TryStmt","ForStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":["NoSuchElementException"],"text":"/**\n      Checks whether a linked list has the expected contents, and throws\n      an exception if not.\n      @param expected the letters that are expected in each node\n      @param actual the linked list\n      @param what a string explaining what has been tested. It is \n      included in the message that is displayed when the test passes.\n   */\npublic static void check(String expected, LinkedList actual, String what) {\n    int n = expected.length();\n    if (n > 0) {\n        // Check first and last reference       \n        assertEquals(expected.substring(0, 1), actual.getFirst());\n        assertEquals(expected.substring(n - 1), actual.getLast());\n        // Check next references\n        ListIterator iter = actual.listIterator();\n        for (int i = 0; i < n; i++) {\n            assertEquals(true, iter.hasNext());\n            assertEquals(expected.substring(i, i + 1), iter.next());\n        }\n        assertEquals(false, iter.hasNext());\n        // Check previous references\n        for (int i = n - 1; i >= 0; i--) {\n            assertEquals(true, iter.hasPrevious());\n            assertEquals(expected.substring(i, i + 1), iter.previous());\n        }\n        assertEquals(false, iter.hasPrevious());\n    } else {\n        // Check that first and last are null\n        try {\n            actual.getFirst();\n            throw new IllegalStateException(\"first not null\");\n        } catch (NoSuchElementException ex) {\n        }\n        try {\n            actual.getLast();\n            throw new IllegalStateException(\"last not null\");\n        } catch (NoSuchElementException ex) {\n        }\n    }\n    if (what.length() > 0) {\n        System.out.println(\"Passed \\\"\" + what + \"\\\".\");\n    }\n}\n","name":"check","className":"LinkedListTest","variables":{"actual":6,"what":3,"ex":2,"expected":6,"iter":7},"javaDoc":"Checks whether a linked list has the expected contents and throws an exception if not expected the letters that are expected in each node actual the linked list what a string explaining what has been tested It is included in the message that is displayed when the test passes","comments":"Check first and last reference Check next references Check previous references Check that first and last are null \n      Checks whether a linked list has the expected contents, and throws\n      an exception if not.\n      @param expected the letters that are expected in each node\n      @param actual the linked list\n      @param what a string explaining what has been tested. It is \n      included in the message that is displayed when the test passes.\n   ","isEmpty":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":4,"add":2,"listIterator":2,"hasNext":1,"addFirst":4,"remove":1,"System.out.print":1,"System.out.println":1},"constants":{"\"Nina\"":1,"\"Tom\"":1,"\" \"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Romeo\"":1},"annotations":[],"types":{"ListIterator":1,"LinkedList":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    LinkedList staff = new LinkedList();\n    staff.addFirst(\"Tom\");\n    staff.addFirst(\"Romeo\");\n    staff.addFirst(\"Harry\");\n    staff.addFirst(\"Diana\");\n    // | in the comments indicates the iterator position\n    // |DHRT\n    ListIterator iterator = staff.listIterator();\n    // D|HRT\n    iterator.next();\n    // DH|RT\n    iterator.next();\n    // Add more elements after second element\n    // DHJ|RT\n    iterator.add(\"Juliet\");\n    // DHJN|RT\n    iterator.add(\"Nina\");\n    // DHJNR|T\n    iterator.next();\n    // Remove last traversed element \n    // DHJN|T\n    iterator.remove();\n    // Print all elements\n    iterator = staff.listIterator();\n    while (iterator.hasNext()) {\n        System.out.print(iterator.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"ListDemo","variables":{"args":1,"iterator":10,"staff":7},"javaDoc":"","comments":"| in the comments indicates the iterator position Add more elements after second element Remove last traversed element Print all elements |DHRT D|HRT DH|RT DHJ|RT DHJN|RT DHJNR|T DHJN|T ","isEmpty":false,"lineCount":19,"modifier":9}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Moves the iterator past the next element.\n      @return the traversed element\n   */\nObject next();\n","name":"next","className":"ListIterator","variables":{},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n      Moves the iterator past the next element.\n      @return the traversed element\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   */\nboolean hasNext();\n","name":"hasNext","className":"ListIterator","variables":{},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   */\nvoid add(Object element);\n","name":"add","className":"ListIterator","variables":{"element":1},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   */\nvoid remove();\n","name":"remove","className":"ListIterator","variables":{},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":[],"statements":[],"concepts":[],"exceptions":[],"text":"/**\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   */\nvoid set(Object element);\n","name":"set","className":"ListIterator","variables":{"element":1},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   ","isEmpty":true,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"LinkedList","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Constructs an empty linked list.\n   */\npublic LinkedList() {\n    first = null;\n}\n","name":"LinkedList","className":"LinkedList","variables":{"first":1},"javaDoc":"Constructs an empty linked list","comments":" \n      Constructs an empty linked list.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","ObjectCreationExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   */\npublic Object getFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    return first.data;\n}\n","name":"getFirst","className":"LinkedList","variables":{"first":1},"javaDoc":"Returns the first element in the linked list the first element in the linked list","comments":"\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{"Object":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes the first element in the linked list.\n      @return the removed element\n   */\npublic Object removeFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    return element;\n}\n","name":"removeFirst","className":"LinkedList","variables":{"first":2,"element":2},"javaDoc":"Removes the first element in the linked list the removed element","comments":"\n      Removes the first element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"Node":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   */\npublic void addFirst(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    first = newNode;\n}\n","name":"addFirst","className":"LinkedList","variables":{"newNode":2,"first":2,"element":2},"javaDoc":"Adds an element to the front of the linked list element the element to add","comments":"\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"ListIterator","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   */\npublic ListIterator listIterator() {\n    return new LinkedListIterator();\n}\n","name":"listIterator","className":"LinkedList","variables":{},"javaDoc":"Returns an iterator for iterating through this list an iterator for iterating through this list","comments":"\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"LinkedListIterator","methodCalls":{},"constants":{"null":2,"false":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BooleanLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Constructs an iterator that points to the front\n         of the linked list.\n      */\npublic LinkedListIterator() {\n    position = null;\n    previous = null;\n    isAfterNext = false;\n}\n","name":"LinkedListIterator","className":"LinkedListIterator","variables":{"previous":1,"position":1,"isAfterNext":1},"javaDoc":"Constructs an iterator that points to the front of the linked list","comments":"\n         Constructs an iterator that points to the front\n         of the linked list.\n      ","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1},"constants":{"null":1,"true":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NullLiteralExpr","BooleanLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Moves the iterator past the next element.\n         @return the traversed element\n      */\npublic Object next() {\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    // Remember for remove\n    previous = position;\n    isAfterNext = true;\n    if (position == null) {\n        position = first;\n    } else {\n        position = position.next;\n    }\n    return position.data;\n}\n","name":"next","className":"LinkedListIterator","variables":{"previous":1,"position":4,"first":1,"isAfterNext":1},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"Remember for remove \n         Moves the iterator past the next element.\n         @return the traversed element\n      ","isEmpty":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{"null":3},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr","FieldAccessExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      */\npublic boolean hasNext() {\n    if (position == null) {\n        return first != null;\n    } else {\n        return position.next != null;\n    }\n}\n","name":"hasNext","className":"LinkedListIterator","variables":{"position":1,"first":1},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"addFirst":1},"constants":{"null":1,"false":1},"annotations":[],"types":{"Node":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      */\npublic void add(Object element) {\n    if (position == null) {\n        addFirst(element);\n        position = first;\n    } else {\n        Node newNode = new Node();\n        newNode.data = element;\n        newNode.next = position.next;\n        position.next = newNode;\n        position = newNode;\n    }\n    isAfterNext = false;\n}\n","name":"add","className":"LinkedListIterator","variables":{"newNode":3,"position":3,"first":1,"element":2,"isAfterNext":1},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeFirst":1},"constants":{"false":1},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      */\npublic void remove() {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    if (position == first) {\n        removeFirst();\n    } else {\n        previous.next = position.next;\n    }\n    position = previous;\n    isAfterNext = false;\n}\n","name":"remove","className":"LinkedListIterator","variables":{"previous":1,"position":2,"first":1,"isAfterNext":2},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      */\npublic void set(Object element) {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    position.data = element;\n}\n","name":"set","className":"LinkedListIterator","variables":{"element":2,"isAfterNext":1},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"HashSet","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["IntegerLiteralExpr","NameExpr","ArrayCreationExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Constructs a hash table.\n      @param bucketsLength the length of the buckets array\n   */\npublic HashSet(int bucketsLength) {\n    buckets = new Node[bucketsLength];\n    currentSize = 0;\n}\n","name":"HashSet","className":"HashSet","variables":{"buckets":1,"bucketsLength":2,"currentSize":1},"javaDoc":"Constructs a hash table bucketsLength the length of the buckets array","comments":"\n      Constructs a hash table.\n      @param bucketsLength the length of the buckets array\n   ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"hashCode":1,"current.data.equals":1},"constants":{"null":1,"true":1,"false":1},"annotations":[],"types":{"Node":1,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Tests for set membership.\n      @param x an object\n      @return true if x is an element of this set\n   */\npublic boolean contains(Object x) {\n    int h = x.hashCode();\n    h = h % buckets.length;\n    if (h < 0) {\n        h = -h;\n    }\n    Node current = buckets[h];\n    while (current != null) {\n        if (current.data.equals(x)) {\n            return true;\n        }\n        current = current.next;\n    }\n    return false;\n}\n","name":"contains","className":"HashSet","variables":{"current":3,"buckets":1},"javaDoc":"Tests for set membership x an object true if x is an element of this set","comments":"\n      Tests for set membership.\n      @param x an object\n      @return true if x is an element of this set\n   ","isEmpty":false,"lineCount":6,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"hashCode":1,"current.data.equals":1},"constants":{"null":1,"false":1,"true":1},"annotations":[],"types":{"Node":2,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element to this set.\n      @param x an object\n      @return true if x is a new object, false if x was\n      already in the set\n   */\npublic boolean add(Object x) {\n    int h = x.hashCode();\n    h = h % buckets.length;\n    if (h < 0) {\n        h = -h;\n    }\n    Node current = buckets[h];\n    while (current != null) {\n        if (current.data.equals(x)) {\n            return false;\n        }\n        // Already in the set\n        current = current.next;\n    }\n    Node newNode = new Node();\n    newNode.data = x;\n    newNode.next = buckets[h];\n    buckets[h] = newNode;\n    currentSize++;\n    return true;\n}\n","name":"add","className":"HashSet","variables":{"current":3,"buckets":3,"newNode":2,"currentSize":1},"javaDoc":"Adds an element to this set x an object true if x is a new object false if x was already in the set","comments":"Already in the set \n      Adds an element to this set.\n      @param x an object\n      @return true if x is a new object, false if x was\n      already in the set\n   ","isEmpty":false,"lineCount":11,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"hashCode":1,"current.data.equals":1},"constants":{"null":3,"true":1,"false":1},"annotations":[],"types":{"Node":2,"int":1},"expressions":["IntegerLiteralExpr","NullLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr","AssignExpr"],"statements":["IfStmt","WhileStmt","BlockStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes an object from this set.\n      @param x an object\n      @return true if x was removed from this set, false\n      if x was not an element of this set\n   */\npublic boolean remove(Object x) {\n    int h = x.hashCode();\n    h = h % buckets.length;\n    if (h < 0) {\n        h = -h;\n    }\n    Node current = buckets[h];\n    Node previous = null;\n    while (current != null) {\n        if (current.data.equals(x)) {\n            if (previous == null) {\n                buckets[h] = current.next;\n            } else {\n                previous.next = current.next;\n            }\n            currentSize--;\n            return true;\n        }\n        previous = current;\n        current = current.next;\n    }\n    return false;\n}\n","name":"remove","className":"HashSet","variables":{"current":4,"previous":3,"buckets":2,"currentSize":1},"javaDoc":"Removes an object from this set x an object true if x was removed from this set false if x was not an element of this set","comments":"\n      Removes an object from this set.\n      @param x an object\n      @return true if x was removed from this set, false\n      if x was not an element of this set\n   ","isEmpty":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Returns an iterator that traverses the elements of this set.\n      @return a hash set iterator\n   */\npublic Iterator iterator() {\n    return new HashSetIterator();\n}\n","name":"iterator","className":"HashSet","variables":{},"javaDoc":"Returns an iterator that traverses the elements of this set a hash set iterator","comments":"\n      Returns an iterator that traverses the elements of this set.\n      @return a hash set iterator\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Gets the number of elements in this set.\n      @return the number of elements\n   */\npublic int size() {\n    return currentSize;\n}\n","name":"size","className":"HashSet","variables":{"currentSize":1},"javaDoc":"Gets the number of elements in this set the number of elements","comments":"\n      Gets the number of elements in this set.\n      @return the number of elements\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"HashSetIterator","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","IntegerLiteralExpr","NameExpr","UnaryExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n         Constructs a hash set iterator that points to the\n         first element of the hash set.\n      */\npublic HashSetIterator() {\n    current = null;\n    bucketIndex = -1;\n}\n","name":"HashSetIterator","className":"HashSetIterator","variables":{"current":1,"bucketIndex":1},"javaDoc":"Constructs a hash set iterator that points to the first element of the hash set","comments":"\n         Constructs a hash set iterator that points to the\n         first element of the hash set.\n      ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{"null":3,"true":2,"false":1},"annotations":[],"types":{"int":1},"expressions":["NullLiteralExpr","IntegerLiteralExpr","VariableDeclarationExpr","ArrayAccessExpr","BinaryExpr","BooleanLiteralExpr","NameExpr","FieldAccessExpr","UnaryExpr"],"statements":["IfStmt","BlockStmt","ReturnStmt","ForStmt"],"concepts":[],"exceptions":[],"text":"public boolean hasNext() {\n    if (current != null && current.next != null) {\n        return true;\n    }\n    for (int b = bucketIndex + 1; b < buckets.length; b++) {\n        if (buckets[b] != null) {\n            return true;\n        }\n    }\n    return false;\n}\n","name":"hasNext","className":"HashSetIterator","variables":{"current":1,"buckets":1,"bucketIndex":1},"javaDoc":"","isEmpty":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":3},"annotations":[],"types":{},"expressions":["NullLiteralExpr","ObjectCreationExpr","ArrayAccessExpr","BinaryExpr","NameExpr","FieldAccessExpr","UnaryExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt","DoStmt"],"concepts":[],"exceptions":[],"text":"public Object next() {\n    if (current != null && current.next != null) {\n        // Move to next element in bucket\n        current = current.next;\n    } else // Move to next bucket\n    {\n        do {\n            bucketIndex++;\n            if (bucketIndex == buckets.length) {\n                throw new NoSuchElementException();\n            }\n            current = buckets[bucketIndex];\n        } while (current == null);\n    }\n    return current.data;\n}\n","name":"next","className":"HashSetIterator","variables":{"current":4,"buckets":1,"bucketIndex":3},"javaDoc":"","comments":"Move to next element in bucket Move to next bucket ","isEmpty":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{},"expressions":["ObjectCreationExpr"],"statements":["ThrowStmt"],"concepts":[],"exceptions":[],"text":"public void remove() {\n    throw new UnsupportedOperationException();\n}\n","name":"remove","className":"HashSetIterator","variables":{},"javaDoc":"","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":12,"next":1,"iterator":1,"hasNext":1,"remove":2,"System.out.println":1},"constants":{"\"Tony\"":1,"\"Sue\"":1,"\"Susannah\"":1,"\"Katherine\"":1,"\"George\"":1,"\"Larry\"":1,"\"Eve\"":1,"101":1,"\"Nina\"":1,"\"Adam\"":1,"\"Juliet\"":1,"\"Harry\"":1,"\"Romeo\"":2,"\"Sarah\"":1},"annotations":[],"types":{"Iterator":1,"HashSet":1},"expressions":["ObjectCreationExpr","IntegerLiteralExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    HashSet names = new HashSet(101);\n    names.add(\"Harry\");\n    names.add(\"Sue\");\n    names.add(\"Nina\");\n    names.add(\"Susannah\");\n    names.add(\"Larry\");\n    names.add(\"Eve\");\n    names.add(\"Sarah\");\n    names.add(\"Adam\");\n    names.add(\"Tony\");\n    names.add(\"Katherine\");\n    names.add(\"Juliet\");\n    names.add(\"Romeo\");\n    names.remove(\"Romeo\");\n    names.remove(\"George\");\n    Iterator iter = names.iterator();\n    while (iter.hasNext()) {\n        System.out.println(iter.next());\n    }\n}\n","name":"main","className":"HashSetDemo","variables":{"args":1,"names":16,"iter":3},"javaDoc":"","isEmpty":false,"lineCount":17,"modifier":9}
{"paramTypes":[],"returnType":"LinkedListStack","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","NameExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/** \n      Constructs an empty stack.\n   */\npublic LinkedListStack() {\n    first = null;\n}\n","name":"LinkedListStack","className":"LinkedListStack","variables":{"first":1},"javaDoc":"Constructs an empty stack","comments":" \n      Constructs an empty stack.\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"constants":{},"annotations":[],"types":{"Node":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Adds an element to the top of the stack.\n      @param element the element to add\n   */\npublic void push(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    first = newNode;\n}\n","name":"push","className":"LinkedListStack","variables":{"newNode":2,"first":2,"element":2},"javaDoc":"Adds an element to the top of the stack element the element to add","comments":"\n      Adds an element to the top of the stack.\n      @param element the element to add\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{"Object":1},"expressions":["NullLiteralExpr","ObjectCreationExpr","VariableDeclarationExpr","BinaryExpr","NameExpr","FieldAccessExpr","AssignExpr"],"statements":["IfStmt","BlockStmt","ThrowStmt","ReturnStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Removes the element from the top of the stack.\n      @return the removed element\n   */\npublic Object pop() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    return element;\n}\n","name":"pop","className":"LinkedListStack","variables":{"first":2,"element":2},"javaDoc":"Removes the element from the top of the stack the removed element","comments":"\n      Removes the element from the top of the stack.\n      @return the removed element\n   ","isEmpty":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"constants":{"null":1},"annotations":[],"types":{},"expressions":["NullLiteralExpr","BinaryExpr","NameExpr"],"statements":["ReturnStmt"],"concepts":[],"exceptions":[],"text":"/**\n      Checks whether this stack is empty.\n      @return true if the stack is empty\n   */\npublic boolean empty() {\n    return first == null;\n}\n","name":"empty","className":"LinkedListStack","variables":{"first":1},"javaDoc":"Checks whether this stack is empty true if the stack is empty","comments":"\n      Checks whether this stack is empty.\n      @return true if the stack is empty\n   ","isEmpty":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"push":3,"empty":1,"System.out.println":1},"constants":{"\"Tom\"":1,"\"Diana\"":1,"\"Harry\"":1},"annotations":[],"types":{"LinkedListStack":1},"expressions":["ObjectCreationExpr","VariableDeclarationExpr","NameExpr","StringLiteralExpr","FieldAccessExpr","UnaryExpr","MethodCallExpr"],"statements":["WhileStmt","BlockStmt","ExpressionStmt"],"concepts":[],"exceptions":[],"text":"public static void main(String[] args) {\n    LinkedListStack s = new LinkedListStack();\n    s.push(\"Tom\");\n    s.push(\"Diana\");\n    s.push(\"Harry\");\n    while (!s.empty()) {\n        System.out.println(s.pop());\n    }\n}\n","name":"main","className":"StackDemo","variables":{"args":1},"javaDoc":"","isEmpty":false,"lineCount":5,"modifier":9}
