{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Nose[]":1,"int":1},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":5,"BinaryExpr":3,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Nose[] i = new Nose[3];\n    i[0] = new Acts();\n    i[1] = new Clowns();\n    i[2] = new Of76();\n    for (int x = 0; x < 3; x++) {\n        System.out.println(i[x].iMethod() + \" \" + i[x].getClass());\n    }\n}\n","name":"main","className":"Of76","variables":{"x":5,"i":6},"constants":{"0":2,"1":1,"2":1,"3":2,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public int iMethod();\n","name":"iMethod","className":"Nose","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public int iMethod() {\n    return 7;\n}\n","name":"iMethod","className":"Picasso","variables":{},"constants":{"7":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public int iMethod() {\n    return 5;\n}\n","name":"iMethod","className":"Acts","variables":{},"constants":{"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setName":3,"add":3,"placeDotCom":1,"setLocationCells":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"DotCom":4,"ArrayList<String>":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"NameExpr":44,"StringLiteralExpr":6,"FieldAccessExpr":3,"MethodCallExpr":11},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":14},"text":"private void setUpGame() {\n    DotCom one = new DotCom();\n    one.setName(\"Pets.com\");\n    DotCom two = new DotCom();\n    two.setName(\"eToys.com\");\n    DotCom three = new DotCom();\n    three.setName(\"Go2.com\");\n    dotComsList.add(one);\n    dotComsList.add(two);\n    dotComsList.add(three);\n    System.out.println(\"Your goal is to sink three dot coms.\");\n    System.out.println(\"Pets.com, eToys.com, Go2.com\");\n    System.out.println(\"Try to sink them all in the fewest number of guesses\");\n    for (DotCom dotComSet : dotComsList) {\n        ArrayList<String> newLocation = helper.placeDotCom(3);\n        dotComSet.setLocationCells(newLocation);\n    }\n}\n","name":"setUpGame","className":"DotComBust","variables":{"dotComsList":4,"helper":1,"one":2,"two":2,"three":2,"newLocation":1,"dotComSet":2},"constants":{"\"Go2.com\"":1,"\"eToys.com\"":1,"\"Try to sink them all in the fewest number of guesses\"":1,"3":1,"\"Pets.com\"":1,"\"Pets.com, eToys.com, Go2.com\"":1,"\"Your goal is to sink three dot coms.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"checkUserGuess":1,"isEmpty":1,"getUserInput":1,"finishGame":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":11,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"private void startPlaying() {\n    while (!dotComsList.isEmpty()) {\n        String userGuess = helper.getUserInput(\"Enter a guess\");\n        checkUserGuess(userGuess);\n    }\n    finishGame();\n}\n","name":"startPlaying","className":"DotComBust","variables":{"dotComsList":1,"helper":1,"userGuess":1},"constants":{"\"Enter a guess\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"checkYourself":1,"equals":2,"remove":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"DotCom":1,"String":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":23,"StringLiteralExpr":3,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":2,"BreakStmt":2,"BlockStmt":3,"ForeachStmt":1,"ExpressionStmt":5},"text":"private void checkUserGuess(String userGuess) {\n    numOfGuesses++;\n    String result = \"miss\";\n    for (DotCom dotComToTest : dotComsList) {\n        result = dotComToTest.checkYourself(userGuess);\n        if (result.equals(\"hit\")) {\n            break;\n        }\n        if (result.equals(\"kill\")) {\n            dotComsList.remove(dotComToTest);\n            break;\n        }\n    }\n    System.out.println(result);\n}\n","name":"checkUserGuess","className":"DotComBust","variables":{"result":4,"dotComsList":2,"numOfGuesses":1,"dotComToTest":2},"constants":{"\"miss\"":1,"\"kill\"":1,"\"hit\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":5,"NameExpr":28,"StringLiteralExpr":7,"FieldAccessExpr":5,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"private void finishGame() {\n    System.out.println(\"All Dot Coms are dead!  Your stock is now worthless\");\n    if (numOfGuesses <= 18) {\n        System.out.println(\"It only took you \" + numOfGuesses + \" guesses\");\n        System.out.println(\"You got out before your options sank.\");\n    } else {\n        System.out.println(\"Took you long enough. \" + numOfGuesses + \" guesses.\");\n        System.out.println(\"Fish are dancing with your options.\");\n    }\n}\n","name":"finishGame","className":"DotComBust","variables":{"numOfGuesses":3},"constants":{"\"It only took you \"":1,"18":1,"\"All Dot Coms are dead!  Your stock is now worthless\"":1,"\"Took you long enough. \"":1,"\"You got out before your options sank.\"":1,"\"Fish are dancing with your options.\"":1,"\" guesses.\"":1,"\" guesses\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setUpGame":1,"startPlaying":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"DotComBust":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    DotComBust game = new DotComBust();\n    game.setUpGame();\n    game.startPlaying();\n}\n","name":"main","className":"DotComBust","variables":{"game":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["ArrayList<String>"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setLocationCells(ArrayList<String> loc) {\n    locationCells = loc;\n}\n","name":"setLocationCells","className":"DotCom","variables":{"loc":1,"locationCells":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"isEmpty":1,"indexOf":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"StringLiteralExpr":3,"NameExpr":15,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":1,"ExpressionStmt":5},"text":"public String checkYourself(String userInput) {\n    String result = \"miss\";\n    int index = locationCells.indexOf(userInput);\n    if (index >= 0) {\n        locationCells.remove(index);\n        if (locationCells.isEmpty()) {\n            result = \"kill\";\n        } else {\n            result = \"hit\";\n        }\n    }\n    return result;\n}\n","name":"checkYourself","className":"DotCom","variables":{"result":4,"locationCells":3,"index":2},"constants":{"0":1,"\"miss\"":1,"\"kill\"":1,"\"hit\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setName(String string) {\n    name = string;\n}\n","name":"setName","className":"DotCom","variables":{"string":1,"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getSize":2,"setSize":2,"bark":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"GoodDog":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":28,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":8},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    GoodDog one = new GoodDog();\n    one.setSize(70);\n    GoodDog two = new GoodDog();\n    two.setSize(8);\n    System.out.println(\"Dog one: \" + one.getSize());\n    System.out.println(\"Dog two: \" + two.getSize());\n    one.bark();\n    two.bark();\n}\n","name":"main","className":"GoodDogTestDrive","variables":{"one":4,"two":4},"constants":{"\"Dog two: \"":1,"8":1,"70":1,"\"Dog one: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getSize() {\n    return size;\n}\n","name":"getSize","className":"GoodDog","variables":{"size":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setSize(int s) {\n    size = s;\n}\n","name":"setSize","className":"GoodDog","variables":{"s":1,"size":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ExpressionStmt":3},"text":"void bark() {\n    if (size > 60) {\n        System.out.println(\"Wooof! Wooof!\");\n    } else if (size > 60) {\n        System.out.println(\"Ruff! Ruff!\");\n    } else {\n        System.out.println(\"Yip! Yip!\");\n    }\n}\n","name":"bark","className":"GoodDog","variables":{"size":2},"constants":{"\"Wooof! Wooof!\"":1,"\"Yip! Yip!\"":1,"60":2,"\"Ruff! Ruff!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":1},"statements":{"ExpressionStmt":2},"text":"public void go() {\n    //added initialization after verified that it doesn't compile\n    int x = 0;\n    // without it -Tyler Boone\n    int z = x + 3;\n}\n","name":"go","className":"Foo","variables":{"x":2,"z":1},"constants":{"0":1,"3":1},"javaDoc":"","comments":"added initialization after verified that it doesn't compile without it -Tyler Boone ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getSize":1,"getName":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"PoorDog":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    PoorDog one = new PoorDog();\n    System.out.println(\"Dog size is \" + one.getSize());\n    System.out.println(\"Dog name is \" + one.getName());\n}\n","name":"main","className":"PoorDogTestDrive","variables":{"one":3},"constants":{"\"Dog name is \"":1,"\"Dog size is \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getSize() {\n    return size;\n}\n","name":"getSize","className":"PoorDog","variables":{"size":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"PoorDog","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["HttpServletRequest","HttpServletResponse"],"returnType":"void","methodCalls":{"println":7,"getWriter":1,"setContentType":1,"close":1,"makePhrase":1},"annotations":[],"exceptions":["ServletException","IOException"],"concepts":[],"types":{"String":1,"PrintWriter":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":3,"StringLiteralExpr":10,"NameExpr":35,"MethodCallExpr":11,"AssignExpr":1},"statements":{"ExpressionStmt":12},"text":"public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    PrintWriter out;\n    String title = \"PhraseOMatic has generated the following phrase.\";\n    response.setContentType(\"text/html\");\n    out = response.getWriter();\n    out.println(\"<HTML><HEAD><TITLE>\");\n    out.println(\"PhraseOmatic\");\n    out.println(\"</TITLE></HEAD><BODY>\");\n    out.println(\"<H1>\" + title + \"</H1>\");\n    out.println(\"<P>\" + PhraseOMatic2.makePhrase());\n    out.println(\"<P><a href=\\\"KathyServlet\\\">make another phrase</a></p>\");\n    out.println(\"</BODY></HTML>\");\n    out.close();\n}\n","name":"doGet","className":"KathyServlet","variables":{"PhraseOMatic2":1,"response":2,"title":2,"out":10},"constants":{"\"</TITLE></HEAD><BODY>\"":1,"\"<P>\"":1,"\"<H1>\"":1,"\"PhraseOMatic has generated the following phrase.\"":1,"\"<P><a href=\\\"KathyServlet\\\">make another phrase</a></p>\"":1,"\"PhraseOmatic\"":1,"\"</H1>\"":1,"\"text/html\"":1,"\"</BODY></HTML>\"":1,"\"<HTML><HEAD><TITLE>\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":12,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"setVisible":1,"getServicesList":1,"setSize":1,"addActionListener":1,"getContentPane":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"Object[]":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":32,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"public void buildGUI() {\n    JFrame frame = new JFrame(\"RMI Browser\");\n    mainPanel = new JPanel();\n    frame.getContentPane().add(BorderLayout.CENTER, mainPanel);\n    Object[] services = getServicesList();\n    serviceList = new JComboBox(services);\n    frame.getContentPane().add(BorderLayout.NORTH, serviceList);\n    serviceList.addActionListener(new MyListListener());\n    frame.setSize(500, 500);\n    frame.setVisible(true);\n}\n","name":"buildGUI","className":"ServiceBrowser","variables":{"mainPanel":1,"serviceList":2,"services":2,"frame":5},"constants":{"500":2,"true":1,"\"RMI Browser\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"add":1,"getGuiPanel":1,"removeAll":1,"printStackTrace":1,"repaint":1,"getService":1,"validate":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Service":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":22,"MethodCallExpr":7},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"void loadService(Object serviceSelection) {\n    try {\n        Service svc = server.getService(serviceSelection);\n        mainPanel.removeAll();\n        mainPanel.add(svc.getGuiPanel());\n        mainPanel.validate();\n        mainPanel.repaint();\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"loadService","className":"ServiceBrowser","variables":{"svc":2,"server":1,"ex":2,"mainPanel":4},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":[],"returnType":"Object[]","methodCalls":{"lookup":1,"printStackTrace":2,"getServiceList":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Object":1,"Object[]":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":2,"NameExpr":17,"StringLiteralExpr":1,"CastExpr":1,"AssignExpr":3,"MethodCallExpr":4},"statements":{"TryStmt":2,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":7},"text":"Object[] getServicesList() {\n    Object obj = null;\n    Object[] services = null;\n    try {\n        obj = Naming.lookup(\"rmi://127.0.0.1/ServiceServer\");\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    server = (ServiceServer) obj;\n    try {\n        services = server.getServiceList();\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    return services;\n}\n","name":"getServicesList","className":"ServiceBrowser","variables":{"server":2,"ex":4,"obj":3,"services":3,"Naming":1},"constants":{"\"rmi://127.0.0.1/ServiceServer\"":1,"null":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":0}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"loadService":1,"getSelectedItem":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent ev) {\n    // do things to get the selected service\n    Object selection = serviceList.getSelectedItem();\n    loadService(selection);\n}\n","name":"actionPerformed","className":"MyListListener","variables":{"selection":1,"serviceList":1},"constants":{},"javaDoc":"","comments":"do things to get the selected service ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new ServiceBrowser().buildGUI();\n}\n","name":"main","className":"ServiceBrowser","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{"random":3},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"String[]":3,"String":1,"int":6},"expressions":{"VariableDeclarationExpr":10,"ArrayInitializerExpr":3,"ArrayAccessExpr":3,"BinaryExpr":8,"StringLiteralExpr":45,"NameExpr":28,"CastExpr":3,"FieldAccessExpr":3,"EnclosedExpr":4,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":10},"text":"public static String makePhrase() {\n    // make three sets of words to choose from\n    String[] wordListOne = { \"24/7\", \"multi-Tier\", \"30,000 foot\", \"B-to-B\", \"win-win\", \"front-end\", \"web-based\", \"pervasive\", \"smart\", \"six-sigma\", \"critical-path\", \"dynamic\" };\n    String[] wordListTwo = { \"empowered\", \"sticky\", \"valued-added\", \"oriented\", \"centric\", \"distributed\", \"clustered\", \"branded\", \"outside-the-box\", \"positioned\", \"networked\", \"focused\", \"leveraged\", \"aligned\", \"targeted\", \"shared\", \"cooperative\", \"accelerated\" };\n    String[] wordListThree = { \"process\", \"tipping point\", \"solution\", \"architecture\", \"core competency\", \"strategy\", \"mindshare\", \"portal\", \"space\", \"vision\", \"paradigm\", \"mission\" };\n    // find out how many words are in each list\n    int oneLength = wordListOne.length;\n    int twoLength = wordListTwo.length;\n    int threeLength = wordListThree.length;\n    // generate three random numbers, to pull random words from each list\n    int rand1 = (int) (Math.random() * oneLength);\n    int rand2 = (int) (Math.random() * twoLength);\n    int rand3 = (int) (Math.random() * threeLength);\n    // now build a phrase\n    String phrase = wordListOne[rand1] + \" \" + wordListTwo[rand2] + \" \" + wordListThree[rand3];\n    // now return it\n    return (\"What we need is a \" + phrase);\n}\n","name":"makePhrase","className":"PhraseOMatic2","variables":{"wordListTwo":2,"wordListThree":2,"phrase":2,"twoLength":2,"rand1":2,"wordListOne":2,"oneLength":2,"rand2":2,"rand3":2,"threeLength":2,"Math":3},"constants":{"\"accelerated\"":1,"\"strategy\"":1,"\"networked\"":1,"\"sticky\"":1,"\"24/7\"":1,"\"branded\"":1,"\"mission\"":1,"\"multi-Tier\"":1,"\"focused\"":1,"\"space\"":1,"\"paradigm\"":1,"\"process\"":1,"\"cooperative\"":1,"\"solution\"":1,"\"tipping point\"":1,"\"mindshare\"":1,"\"portal\"":1,"\"positioned\"":1,"\"leveraged\"":1,"\"empowered\"":1,"\"vision\"":1,"\"six-sigma\"":1,"\"valued-added\"":1,"\"oriented\"":1,"\"shared\"":1,"\"smart\"":1,"\" \"":2,"\"front-end\"":1,"\"pervasive\"":1,"\"B-to-B\"":1,"\"30,000 foot\"":1,"\"What we need is a \"":1,"\"outside-the-box\"":1,"\"centric\"":1,"\"win-win\"":1,"\"distributed\"":1,"\"targeted\"":1,"\"aligned\"":1,"\"dynamic\"":1,"\"architecture\"":1,"\"clustered\"":1,"\"core competency\"":1,"\"critical-path\"":1,"\"web-based\"":1},"javaDoc":"","comments":"make three sets of words to choose from find out how many words are in each list generate three random numbers to pull random words from each list now build a phrase now return it ","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":9}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":3,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"JButton":1,"String[]":1},"expressions":{"ObjectCreationExpr":5,"VariableDeclarationExpr":3,"ArrayInitializerExpr":1,"StringLiteralExpr":7,"NameExpr":19,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":9},"text":"public JPanel getGuiPanel() {\n    JPanel panel = new JPanel();\n    JButton button = new JButton(\"Roll 'em!\");\n    String[] choices = { \"1\", \"2\", \"3\", \"4\", \"5\" };\n    numOfDice = new JComboBox(choices);\n    label = new JLabel(\"dice values here\");\n    button.addActionListener(new RollEmListener());\n    panel.add(numOfDice);\n    panel.add(button);\n    panel.add(label);\n    return panel;\n}\n","name":"getGuiPanel","className":"DiceService","variables":{"button":2,"numOfDice":1,"label":1,"panel":5,"choices":2},"constants":{"\"4\"":1,"\"3\"":1,"\"2\"":1,"\"1\"":1,"\"dice values here\"":1,"\"Roll 'em!\"":1,"\"5\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseInt":1,"random":1,"getSelectedItem":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"String":2,"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":4,"StringLiteralExpr":2,"CastExpr":2,"NameExpr":19,"EnclosedExpr":3,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public void actionPerformed(ActionEvent ev) {\n    // roll the dice\n    String diceOutput = \"\";\n    String selection = (String) numOfDice.getSelectedItem();\n    int numOfDiceToRoll = Integer.parseInt(selection);\n    for (int i = 0; i < numOfDiceToRoll; i++) {\n        int r = (int) ((Math.random() * 6) + 1);\n        diceOutput += (\" \" + r);\n    }\n    label.setText(diceOutput);\n}\n","name":"actionPerformed","className":"RollEmListener","variables":{"Integer":1,"numOfDice":1,"r":2,"selection":1,"diceOutput":2,"i":3,"numOfDiceToRoll":2,"label":1,"Math":1},"constants":{"\"\"":1,"0":1,"1":1,"\" \"":1,"6":1},"javaDoc":"","comments":"roll the dice ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"Object[]","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"Object[] getServiceList() throws RemoteException;\n","name":"getServiceList","className":"ServiceServer","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"Service","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"Service getService(Object serviceKey) throws RemoteException;\n","name":"getService","className":"ServiceServer","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"ServiceServerImpl","methodCalls":{"setUpServices":1},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public ServiceServerImpl() throws RemoteException {\n    // start and set up services \n    setUpServices();\n}\n","name":"ServiceServerImpl","className":"ServiceServerImpl","variables":{},"constants":{},"javaDoc":"","comments":"start and set up services ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"put":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":4,"NameExpr":10,"StringLiteralExpr":3,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"private void setUpServices() {\n    serviceList = new HashMap<String, Service>();\n    serviceList.put(\"Dice Rolling Service\", new DiceService());\n    serviceList.put(\"Day of the Week Service\", new DayOfTheWeekService());\n    serviceList.put(\"Visual Music Service\", new MiniMusicService());\n}\n","name":"setUpServices","className":"ServiceServerImpl","variables":{"serviceList":4},"constants":{"\"Visual Music Service\"":1,"\"Dice Rolling Service\"":1,"\"Day of the Week Service\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":[],"returnType":"Object[]","methodCalls":{"toArray":1,"keySet":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public Object[] getServiceList() {\n    System.out.println(\"in remote\");\n    return serviceList.keySet().toArray();\n}\n","name":"getServiceList","className":"ServiceServerImpl","variables":{"serviceList":1},"constants":{"\"in remote\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Object"],"returnType":"Service","methodCalls":{"get":1},"annotations":[],"exceptions":["RemoteException"],"concepts":["Casting"],"types":{"Service":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public Service getService(Object serviceKey) throws RemoteException {\n    Service theService = (Service) serviceList.get(serviceKey);\n    return theService;\n}\n","name":"getService","className":"ServiceServerImpl","variables":{"theService":2,"serviceList":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"rebind":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":8,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    try {\n        Naming.rebind(\"ServiceServer\", new ServiceServerImpl());\n    } catch (Exception ex) {\n    }\n    System.out.println(\"Remote service is running\");\n}\n","name":"main","className":"ServiceServerImpl","variables":{"ex":1,"Naming":1},"constants":{"\"Remote service is running\"":1,"\"ServiceServer\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":2,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"JButton":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":2,"NameExpr":13,"StringLiteralExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":6},"text":"public JPanel getGuiPanel() {\n    JPanel mainPanel = new JPanel();\n    myPanel = new MyDrawPanel();\n    JButton playItButton = new JButton(\"Play it\");\n    playItButton.addActionListener(new PlayItListener());\n    mainPanel.add(myPanel);\n    mainPanel.add(playItButton);\n    return mainPanel;\n}\n","name":"getGuiPanel","className":"MiniMusicService","variables":{"mainPanel":4,"myPanel":1,"playItButton":2},"constants":{"\"Play it\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSequencer":1,"add":3,"setSequence":1,"random":1,"makeEvent":3,"printStackTrace":1,"setTempoInBPM":1,"addControllerEventListener":1,"createTrack":1,"start":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"Sequencer":1,"Sequence":1,"Track":1,"int":2},"expressions":{"IntegerLiteralExpr":20,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayInitializerExpr":1,"BinaryExpr":5,"NameExpr":55,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":15,"AssignExpr":1},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":13},"text":"public void actionPerformed(ActionEvent ev) {\n    try {\n        // make (and open) a sequencer, make a sequence and track\n        Sequencer sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        sequencer.addControllerEventListener(myPanel, new int[] { 127 });\n        Sequence seq = new Sequence(Sequence.PPQ, 4);\n        Track track = seq.createTrack();\n        for (int i = 0; i < 100; i += 4) {\n            int rNum = (int) ((Math.random() * 50) + 1);\n            if (rNum < 38) {\n                // so now only do it if num <38 (75% of the time)\n                track.add(makeEvent(144, 1, rNum, 100, i));\n                track.add(makeEvent(176, 1, 127, 0, i));\n                track.add(makeEvent(128, 1, rNum, 100, i + 2));\n            }\n        }\n        // end loop\n        // add the events to the track            \n        // add the sequence to the sequencer, set timing, and start\n        sequencer.setSequence(seq);\n        sequencer.start();\n        sequencer.setTempoInBPM(220);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"actionPerformed","className":"PlayItListener","variables":{"rNum":2,"ex":2,"i":4,"track":4,"Math":1,"MidiSystem":1,"seq":2,"sequencer":6},"constants":{"0":2,"176":1,"220":1,"100":3,"1":4,"144":1,"2":1,"4":2,"38":1,"127":2,"128":1,"50":1},"javaDoc":"","comments":"make (and open) a sequencer make a sequence and track now make two midi events (containing a midi message) end loop add the events to the track add the sequence to the sequencer set timing and start so now only do it if num <38 (75% of the time) ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"MidiEvent","methodCalls":{"setMessage":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"ShortMessage":1,"MidiEvent":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":1,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"// close inner class\npublic MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {\n    MidiEvent event = null;\n    try {\n        ShortMessage a = new ShortMessage();\n        a.setMessage(comd, chan, one, two);\n        event = new MidiEvent(a, tick);\n    } catch (Exception e) {\n    }\n    return event;\n}\n","name":"makeEvent","className":"MiniMusicService","variables":{"a":3,"e":1,"tick":1,"event":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ShortMessage"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":3,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void controlChange(ShortMessage event) {\n    msg = true;\n    repaint();\n}\n","name":"controlChange","className":"MyDrawPanel","variables":{"msg":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"public Dimension getPreferredSize() {\n    return new Dimension(300, 300);\n}\n","name":"getPreferredSize","className":"MyDrawPanel","variables":{},"constants":{"300":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"random":7,"setColor":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":7,"Graphics2D":1},"expressions":{"IntegerLiteralExpr":11,"ObjectCreationExpr":1,"VariableDeclarationExpr":8,"BinaryExpr":11,"BooleanLiteralExpr":1,"NameExpr":37,"CastExpr":8,"EnclosedExpr":11,"MethodCallExpr":9,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":11},"text":"public void paintComponent(Graphics g) {\n    if (msg) {\n        Graphics2D g2 = (Graphics2D) g;\n        int r = (int) (Math.random() * 250);\n        int gr = (int) (Math.random() * 250);\n        int b = (int) (Math.random() * 250);\n        g.setColor(new Color(r, gr, b));\n        int ht = (int) ((Math.random() * 120) + 10);\n        int width = (int) ((Math.random() * 120) + 10);\n        int x = (int) ((Math.random() * 40) + 10);\n        int y = (int) ((Math.random() * 40) + 10);\n        g.fillRect(x, y, ht, width);\n        msg = false;\n    }\n// close if\n}\n","name":"paintComponent","className":"MyDrawPanel","variables":{"msg":2,"r":2,"b":2,"g":3,"width":1,"x":1,"y":1,"g2":1,"gr":2,"Math":7,"ht":1},"constants":{"false":1,"40":2,"250":3,"120":2,"10":4},"javaDoc":"","comments":"close if ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public JPanel getGuiPanel();\n","name":"getGuiPanel","className":"Service","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":9,"addActionListener":1,"getMonths":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":2,"JButton":1,"DateFormatSymbols":1},"expressions":{"ObjectCreationExpr":13,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"StringLiteralExpr":5,"NameExpr":44,"MethodCallExpr":11,"AssignExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":18},"text":"public JPanel getGuiPanel() {\n    JPanel panel = new JPanel();\n    JButton button = new JButton(\"Do it!\");\n    button.addActionListener(new DoItListener());\n    outputLabel = new JLabel(\"date appears here\");\n    DateFormatSymbols dateStuff = new DateFormatSymbols();\n    month = new JComboBox(dateStuff.getMonths());\n    day = new JTextField(8);\n    year = new JTextField(8);\n    JPanel inputPanel = new JPanel(new GridLayout(3, 2));\n    inputPanel.add(new JLabel(\"Month\"));\n    inputPanel.add(month);\n    inputPanel.add(new JLabel(\"Day\"));\n    inputPanel.add(day);\n    inputPanel.add(new JLabel(\"Year\"));\n    inputPanel.add(year);\n    panel.add(inputPanel);\n    panel.add(button);\n    panel.add(outputLabel);\n    return panel;\n}\n","name":"getGuiPanel","className":"DayOfTheWeekService","variables":{"button":2,"inputPanel":7,"outputLabel":1,"month":1,"year":1,"dateStuff":2,"panel":5,"day":1},"constants":{"\"Do it!\"":1,"2":1,"3":1,"\"date appears here\"":1,"\"Day\"":1,"8":2,"\"Year\"":1,"\"Month\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":19,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseInt":2,"set":3,"getText":2,"getTime":1,"getSelectedIndex":1,"getInstance":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Calendar":1,"String":1,"int":3,"Date":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":6,"NameExpr":49,"StringLiteralExpr":1,"FieldAccessExpr":3,"EnclosedExpr":1,"MethodCallExpr":12},"statements":{"ExpressionStmt":10},"text":"public void actionPerformed(ActionEvent ev) {\n    int monthNum = month.getSelectedIndex();\n    int dayNum = Integer.parseInt(day.getText());\n    int yearNum = Integer.parseInt(year.getText());\n    Calendar c = Calendar.getInstance();\n    c.set(Calendar.MONTH, monthNum);\n    c.set(Calendar.DAY_OF_MONTH, dayNum);\n    c.set(Calendar.YEAR, yearNum);\n    Date date = c.getTime();\n    String dayOfWeek = (new SimpleDateFormat(\"EEEE\")).format(date);\n    outputLabel.setText(dayOfWeek);\n}\n","name":"actionPerformed","className":"DoItListener","variables":{"Integer":2,"date":1,"c":5,"dayOfWeek":1,"month":1,"outputLabel":1,"year":1,"Calendar":1,"dayNum":1,"monthNum":1,"day":1,"yearNum":1},"constants":{"\"EEEE\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"SimpleAnimation":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    SimpleAnimation gui = new SimpleAnimation();\n    gui.go();\n}\n","name":"main","className":"SimpleAnimation","variables":{"gui":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"sleep":1,"setSize":1,"getContentPane":1,"setDefaultCloseOperation":1,"repaint":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"MyDrawPanel":1,"JFrame":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":28,"FieldAccessExpr":1,"UnaryExpr":3,"MethodCallExpr":7},"statements":{"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public void go() {\n    JFrame frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    MyDrawPanel drawPanel = new MyDrawPanel();\n    frame.getContentPane().add(drawPanel);\n    frame.setSize(300, 300);\n    frame.setVisible(true);\n    for (int i = 0; i < 130; i++) {\n        x++;\n        y++;\n        drawPanel.repaint();\n        try {\n            Thread.sleep(50);\n        } catch (Exception ex) {\n        }\n    }\n}\n","name":"go","className":"SimpleAnimation","variables":{"drawPanel":2,"ex":1,"x":1,"i":3,"y":1,"frame":5,"Thread":1},"constants":{"0":1,"300":2,"true":1,"50":1,"130":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":2,"fillOval":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"NameExpr":24,"FieldAccessExpr":2,"ThisExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public void paintComponent(Graphics g) {\n    g.setColor(Color.white);\n    g.fillRect(0, 0, this.getWidth(), this.getHeight());\n    g.setColor(Color.green);\n    g.fillOval(x, y, 40, 40);\n}\n","name":"paintComponent","className":"MyDrawPanel","variables":{"g":4},"constants":{"0":2,"40":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MiniMusicPlayer3":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    MiniMusicPlayer3 mini = new MiniMusicPlayer3();\n    mini.go();\n}\n","name":"main","className":"MiniMusicPlayer3","variables":{"mini":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":1,"setContentPane":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"BooleanLiteralExpr":1,"NameExpr":11,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public void setUpGui() {\n    ml = new MyDrawPanel();\n    f.setContentPane(ml);\n    f.setBounds(30, 30, 300, 300);\n    f.setVisible(true);\n}\n","name":"setUpGui","className":"MiniMusicPlayer3","variables":{"f":3,"ml":1},"constants":{"300":2,"true":1,"30":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSequencer":1,"add":3,"setSequence":1,"random":1,"makeEvent":3,"printStackTrace":1,"setTempoInBPM":1,"addControllerEventListener":1,"createTrack":1,"start":1,"setUpGui":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Sequencer":1,"Sequence":1,"Track":1,"int":2},"expressions":{"IntegerLiteralExpr":20,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayInitializerExpr":1,"BinaryExpr":4,"NameExpr":57,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":16,"AssignExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":15},"text":"public void go() {\n    setUpGui();\n    try {\n        // make (and open) a sequencer, make a sequence and track\n        Sequencer sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        sequencer.addControllerEventListener(ml, new int[] { 127 });\n        Sequence seq = new Sequence(Sequence.PPQ, 4);\n        Track track = seq.createTrack();\n        // now make two midi events (containing a midi message)\n        int r = 0;\n        for (int i = 0; i < 60; i += 4) {\n            r = (int) ((Math.random() * 50) + 1);\n            track.add(makeEvent(144, 1, r, 100, i));\n            track.add(makeEvent(176, 1, 127, 0, i));\n            track.add(makeEvent(128, 1, r, 100, i + 2));\n        }\n        // end loop\n        // add the events to the track            \n        // add the sequence to the sequencer, set timing, and start\n        sequencer.setSequence(seq);\n        sequencer.start();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"go","className":"MiniMusicPlayer3","variables":{"r":2,"ex":2,"i":4,"track":4,"Math":1,"MidiSystem":1,"seq":2,"sequencer":6},"constants":{"0":3,"176":1,"1":4,"144":1,"100":2,"2":1,"4":2,"127":2,"128":1,"60":1,"50":1,"120":1},"javaDoc":"","comments":"make (and open) a sequencer make a sequence and track now make two midi events (containing a midi message) end loop add the events to the track add the sequence to the sequencer set timing and start ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"MidiEvent","methodCalls":{"setMessage":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"ShortMessage":1,"MidiEvent":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":1,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"// close go\npublic MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {\n    MidiEvent event = null;\n    try {\n        ShortMessage a = new ShortMessage();\n        a.setMessage(comd, chan, one, two);\n        event = new MidiEvent(a, tick);\n    } catch (Exception e) {\n    }\n    return event;\n}\n","name":"makeEvent","className":"MiniMusicPlayer3","variables":{"a":3,"e":1,"tick":1,"event":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ShortMessage"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":3,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void controlChange(ShortMessage event) {\n    msg = true;\n    repaint();\n}\n","name":"controlChange","className":"MyDrawPanel","variables":{"msg":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"random":7,"setColor":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":7,"Graphics2D":1},"expressions":{"IntegerLiteralExpr":11,"ObjectCreationExpr":1,"VariableDeclarationExpr":8,"BinaryExpr":11,"BooleanLiteralExpr":1,"NameExpr":37,"CastExpr":8,"EnclosedExpr":11,"MethodCallExpr":9,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":11},"text":"public void paintComponent(Graphics g) {\n    if (msg) {\n        Graphics2D g2 = (Graphics2D) g;\n        int r = (int) (Math.random() * 250);\n        int gr = (int) (Math.random() * 250);\n        int b = (int) (Math.random() * 250);\n        g.setColor(new Color(r, gr, b));\n        int ht = (int) ((Math.random() * 120) + 10);\n        int width = (int) ((Math.random() * 120) + 10);\n        int x = (int) ((Math.random() * 40) + 10);\n        int y = (int) ((Math.random() * 40) + 10);\n        g.fillRect(x, y, ht, width);\n        msg = false;\n    }\n// close if\n}\n","name":"paintComponent","className":"MyDrawPanel","variables":{"msg":2,"r":2,"b":2,"g":3,"width":1,"x":1,"y":1,"g2":1,"gr":2,"Math":7,"ht":1},"constants":{"false":1,"40":2,"250":3,"120":2,"10":4},"javaDoc":"","comments":"close if ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"TwoButtons":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    TwoButtons gui = new TwoButtons();\n    gui.go();\n}\n","name":"main","className":"TwoButtons","variables":{"gui":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":4,"setVisible":1,"setSize":1,"addActionListener":2,"getContentPane":4,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MyDrawPanel":1,"JButton":2},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"NameExpr":56,"StringLiteralExpr":3,"FieldAccessExpr":5,"AssignExpr":2,"MethodCallExpr":13},"statements":{"ExpressionStmt":14},"text":"public void go() {\n    frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    JButton labelButton = new JButton(\"Change Label\");\n    labelButton.addActionListener(new LabelButtonListener());\n    JButton colorButton = new JButton(\"Change Circle\");\n    colorButton.addActionListener(new ColorButtonListener());\n    label = new JLabel(\"I'm a label\");\n    MyDrawPanel drawPanel = new MyDrawPanel();\n    frame.getContentPane().add(BorderLayout.SOUTH, colorButton);\n    frame.getContentPane().add(BorderLayout.CENTER, drawPanel);\n    frame.getContentPane().add(BorderLayout.EAST, labelButton);\n    frame.getContentPane().add(BorderLayout.WEST, label);\n    frame.setSize(420, 300);\n    frame.setVisible(true);\n}\n","name":"go","className":"TwoButtons","variables":{"colorButton":2,"drawPanel":1,"labelButton":2,"label":1,"frame":8},"constants":{"\"Change Circle\"":1,"\"Change Label\"":1,"420":1,"\"I'm a label\"":1,"300":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":14,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    label.setText(\"Ouch!\");\n}\n","name":"actionPerformed","className":"LabelButtonListener","variables":{"label":1},"constants":{"\"Ouch!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    frame.repaint();\n}\n","name":"actionPerformed","className":"ColorButtonListener","variables":{"frame":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"random":3,"setColor":1,"fillOval":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Color":1,"int":3},"expressions":{"IntegerLiteralExpr":9,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":26,"CastExpr":3,"EnclosedExpr":3,"ThisExpr":2,"MethodCallExpr":8},"statements":{"ExpressionStmt":7},"text":"public void paintComponent(Graphics g) {\n    g.fillRect(0, 0, this.getWidth(), this.getHeight());\n    // make random colors to fill with\n    int red = (int) (Math.random() * 255);\n    int green = (int) (Math.random() * 255);\n    int blue = (int) (Math.random() * 255);\n    Color randomColor = new Color(red, green, blue);\n    g.setColor(randomColor);\n    g.fillOval(70, 70, 100, 100);\n}\n","name":"paintComponent","className":"MyDrawPanel","variables":{"red":2,"randomColor":1,"green":2,"blue":2,"g":3,"Math":3},"constants":{"0":2,"100":2,"255":3,"70":2},"javaDoc":"","comments":"make random colors to fill with ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Animate":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Animate gui = new Animate();\n    gui.go();\n}\n","name":"main","className":"Animate","variables":{"gui":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"sleep":1,"setSize":1,"getContentPane":1,"setDefaultCloseOperation":1,"repaint":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"JFrame":1,"MyDrawP":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":29,"FieldAccessExpr":1,"UnaryExpr":4,"MethodCallExpr":7},"statements":{"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":9},"text":"public void go() {\n    JFrame frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    MyDrawP drawP = new MyDrawP();\n    frame.getContentPane().add(drawP);\n    frame.setSize(500, 270);\n    frame.setVisible(true);\n    for (int i = 0; i < 124; i++, x++, y++) {\n        x++;\n        drawP.repaint();\n        try {\n            Thread.sleep(50);\n        } catch (Exception ex) {\n        }\n    }\n}\n","name":"go","className":"Animate","variables":{"ex":1,"x":2,"i":3,"y":1,"drawP":2,"frame":5,"Thread":1},"constants":{"0":1,"124":1,"500":1,"true":1,"270":1,"50":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":2,"fillRect":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":8,"BinaryExpr":4,"NameExpr":22,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void paintComponent(Graphics g) {\n    g.setColor(Color.white);\n    g.fillRect(0, 0, 500, 250);\n    g.setColor(Color.blue);\n    g.fillRect(x, y, 500 - x * 2, 250 - y * 2);\n}\n","name":"paintComponent","className":"MyDrawP","variables":{"g":4,"x":1,"y":1},"constants":{"0":2,"2":2,"500":2,"250":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getX":2,"getY":2,"getZ":2,"printStackTrace":1,"writeObject":1,"close":2,"System.out.println":2,"readObject":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"FileOutputStream":1,"DungeonGame":1,"ObjectOutputStream":1,"FileInputStream":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":5,"VariableDeclarationExpr":5,"BinaryExpr":4,"NameExpr":47,"StringLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":2,"MethodCallExpr":13,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    DungeonGame d = new DungeonGame();\n    System.out.println(d.getX() + d.getY() + d.getZ());\n    try {\n        FileOutputStream fos = new FileOutputStream(\"dg.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(d);\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"dg.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        d = (DungeonGame) ois.readObject();\n        ois.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    System.out.println(d.getX() + d.getY() + d.getZ());\n}\n","name":"main","className":"DungeonTest","variables":{"fis":2,"oos":3,"d":8,"e":2,"ois":3,"fos":2},"constants":{"\"dg.ser\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"int getX() {\n    return x;\n}\n","name":"getX","className":"DungeonGame","variables":{"x":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":[],"returnType":"long","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"long getY() {\n    return y;\n}\n","name":"getY","className":"DungeonGame","variables":{"y":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":[],"returnType":"short","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"short getZ() {\n    return z;\n}\n","name":"getZ","className":"DungeonGame","variables":{"z":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new BeatBoxSaveOnly().buildGUI();\n}\n","name":"main","className":"BeatBoxSaveOnly","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":13,"setVisible":1,"setSelected":1,"createEmptyBorder":1,"addActionListener":6,"getContentPane":1,"setBounds":1,"pack":1,"setVgap":1,"setBorder":1,"setDefaultCloseOperation":1,"setHgap":1,"setUpMidi":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JCheckBox":1,"JPanel":1,"GridLayout":1,"BorderLayout":1,"JButton":6,"Box":2,"int":2},"expressions":{"ObjectCreationExpr":22,"IntegerLiteralExpr":16,"VariableDeclarationExpr":14,"ArrayAccessExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":129,"StringLiteralExpr":7,"FieldAccessExpr":6,"UnaryExpr":2,"AssignExpr":3,"MethodCallExpr":30},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":43},"text":"public void buildGUI() {\n    theFrame = new JFrame(\"Cyber BeatBox\");\n    theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    BorderLayout layout = new BorderLayout();\n    JPanel background = new JPanel(layout);\n    background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n    checkboxList = new ArrayList<JCheckBox>();\n    Box buttonBox = new Box(BoxLayout.Y_AXIS);\n    JButton start = new JButton(\"Start\");\n    start.addActionListener(new MyStartListener());\n    buttonBox.add(start);\n    JButton stop = new JButton(\"Stop\");\n    stop.addActionListener(new MyStopListener());\n    buttonBox.add(stop);\n    JButton upTempo = new JButton(\"Tempo Up\");\n    upTempo.addActionListener(new MyUpTempoListener());\n    buttonBox.add(upTempo);\n    JButton downTempo = new JButton(\"Tempo Down\");\n    downTempo.addActionListener(new MyDownTempoListener());\n    buttonBox.add(downTempo);\n    // new button\n    JButton saveIt = new JButton(\"Serialize It\");\n    saveIt.addActionListener(new MySendListener());\n    buttonBox.add(saveIt);\n    // new button\n    JButton restore = new JButton(\"Restore\");\n    restore.addActionListener(new MyReadInListener());\n    buttonBox.add(restore);\n    Box nameBox = new Box(BoxLayout.Y_AXIS);\n    for (int i = 0; i < 16; i++) {\n        nameBox.add(new Label(instrumentNames[i]));\n    }\n    background.add(BorderLayout.EAST, buttonBox);\n    background.add(BorderLayout.WEST, nameBox);\n    theFrame.getContentPane().add(background);\n    GridLayout grid = new GridLayout(16, 16);\n    grid.setVgap(1);\n    grid.setHgap(2);\n    mainPanel = new JPanel(grid);\n    background.add(BorderLayout.CENTER, mainPanel);\n    for (int i = 0; i < 256; i++) {\n        JCheckBox c = new JCheckBox();\n        c.setSelected(false);\n        checkboxList.add(c);\n        mainPanel.add(c);\n    }\n    // end loop\n    setUpMidi();\n    theFrame.setBounds(50, 50, 300, 300);\n    theFrame.pack();\n    theFrame.setVisible(true);\n}\n","name":"buildGUI","className":"BeatBoxSaveOnly","variables":{"BorderFactory":1,"instrumentNames":1,"nameBox":2,"saveIt":2,"c":2,"restore":2,"theFrame":6,"mainPanel":2,"upTempo":2,"start":2,"buttonBox":7,"i":7,"layout":2,"checkboxList":2,"stop":2,"background":5,"grid":4,"downTempo":2},"constants":{"\"Start\"":1,"16":3,"false":1,"0":2,"\"Cyber BeatBox\"":1,"1":1,"\"Stop\"":1,"2":1,"\"Serialize It\"":1,"256":1,"300":2,"\"Restore\"":1,"true":1,"50":2,"\"Tempo Down\"":1,"\"Tempo Up\"":1,"10":4},"javaDoc":"","comments":"end loop new button new button ","isEmpty":false,"hasInnerClass":false,"lineCount":41,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSequencer":1,"printStackTrace":1,"setTempoInBPM":1,"createTrack":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"NameExpr":21,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"// close method\npublic void setUpMidi() {\n    try {\n        sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        // sequencer.addMetaEventListener(this);\n        sequence = new Sequence(Sequence.PPQ, 4);\n        track = sequence.createTrack();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"setUpMidi","className":"BeatBoxSaveOnly","variables":{"sequence":2,"e":2,"track":1,"MidiSystem":1,"sequencer":3},"constants":{"4":1,"120":1},"javaDoc":"","comments":"sequencer addMetaEventListener(this); ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"setSequence":1,"setLoopCount":1,"makeEvent":1,"printStackTrace":1,"deleteTrack":1,"setTempoInBPM":1,"createTrack":1,"get":1,"makeTracks":1,"isSelected":1,"start":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"JCheckBox":1,"int[]":1,"int":3},"expressions":{"IntegerLiteralExpr":13,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":4,"NameExpr":55,"UnaryExpr":2,"AssignExpr":4,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":1,"ForStmt":2,"ExpressionStmt":15},"text":"// close method\n/*\n     public class MyCheckBoxListener implements ItemListener {\n        public void itemStateChanged(ItemEvent ev) {      \n           // might add real-time removal or addition, probably not because of timing\n        }\n     } // close inner class\n*/\npublic void buildTrackAndStart() {\n    // this will hold the instruments for each vertical column,\n    // in other words, each tick (may have multiple instruments)\n    int[] trackList = null;\n    sequence.deleteTrack(track);\n    track = sequence.createTrack();\n    for (int i = 0; i < 16; i++) {\n        trackList = new int[16];\n        int key = instruments[i];\n        for (int j = 0; j < 16; j++) {\n            JCheckBox jc = (JCheckBox) checkboxList.get(j + (16 * i));\n            if (jc.isSelected()) {\n                trackList[j] = key;\n            } else {\n                trackList[j] = 0;\n            }\n        }\n        // close inner\n        makeTracks(trackList);\n    }\n    // close outer\n    // - so we always go to full 16 beats \n    track.add(makeEvent(192, 9, 1, 0, 15));\n    try {\n        sequencer.setSequence(sequence);\n        sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);\n        sequencer.start();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"buildTrackAndStart","className":"BeatBoxSaveOnly","variables":{"sequence":2,"instruments":1,"checkboxList":1,"trackList":4,"e":2,"i":5,"jc":2,"j":6,"track":2,"key":2,"sequencer":4},"constants":{"0":4,"1":1,"null":1,"15":1,"16":4,"9":1,"192":1,"120":1},"javaDoc":"","comments":"this will hold the instruments for each vertical column close outer in other words each tick (may have multiple instruments) close inner - so we always go to full 16 beats ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"buildTrackAndStart":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    buildTrackAndStart();\n}\n","name":"actionPerformed","className":"MyStartListener","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"stop":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    sequencer.stop();\n}\n","name":"actionPerformed","className":"MyStopListener","variables":{"sequencer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * 1.03));\n}\n","name":"actionPerformed","className":"MyUpTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{"1.03":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * .97));\n}\n","name":"actionPerformed","className":"MyDownTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{".97":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"printStackTrace":1,"writeObject":1,"get":1,"isSelected":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"JCheckBox":1,"FileOutputStream":1,"boolean[]":1,"ObjectOutputStream":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":3,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":1,"UnaryExpr":1,"AssignExpr":1,"BooleanLiteralExpr":1,"CastExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public void actionPerformed(ActionEvent a) {\n    // make an arraylist of just the STATE of the checkboxes\n    boolean[] checkboxState = new boolean[256];\n    for (int i = 0; i < 256; i++) {\n        JCheckBox check = (JCheckBox) checkboxList.get(i);\n        if (check.isSelected()) {\n            checkboxState[i] = true;\n        }\n    }\n    try {\n        FileOutputStream fileStream = new FileOutputStream(new File(\"Checkbox.ser\"));\n        ObjectOutputStream os = new ObjectOutputStream(fileStream);\n        os.writeObject(checkboxState);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"actionPerformed","className":"MySendListener","variables":{"ex":2,"checkboxList":1,"os":2,"checkboxState":2,"i":4,"check":2,"fileStream":2},"constants":{"0":1,"256":2,"true":1,"\"Checkbox.ser\"":1},"javaDoc":"","comments":"make an arraylist of just the STATE of the checkboxes ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"buildTrackAndStart":1,"printStackTrace":1,"stop":1,"setSelected":2,"get":1,"readObject":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"JCheckBox":1,"boolean[]":1,"FileInputStream":1,"int":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":27,"UnaryExpr":1,"AssignExpr":1,"NullLiteralExpr":1,"BooleanLiteralExpr":2,"CastExpr":2,"MethodCallExpr":7},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":5,"ForStmt":1,"ExpressionStmt":10},"text":"public void actionPerformed(ActionEvent a) {\n    // read in the thing\n    boolean[] checkboxState = null;\n    try {\n        FileInputStream fileIn = new FileInputStream(new File(\"Checkbox.ser\"));\n        ObjectInputStream is = new ObjectInputStream(fileIn);\n        checkboxState = (boolean[]) is.readObject();\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    // now reset the sequence to be this\n    for (int i = 0; i < 256; i++) {\n        JCheckBox check = (JCheckBox) checkboxList.get(i);\n        if (checkboxState[i]) {\n            check.setSelected(true);\n        } else {\n            check.setSelected(false);\n        }\n    }\n    // now stop sequence and restart\n    sequencer.stop();\n    buildTrackAndStart();\n}\n","name":"actionPerformed","className":"MyReadInListener","variables":{"ex":2,"checkboxList":1,"checkboxState":3,"fileIn":2,"i":4,"is":2,"check":3,"sequencer":1},"constants":{"0":1,"256":1,"null":1,"true":1,"false":1,"\"Checkbox.ser\"":1},"javaDoc":"","comments":"read in the thing now reset the sequence to be this now stop sequence and restart ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"add":2,"makeEvent":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":19,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"// close inner class\n//==============================================================       \npublic void makeTracks(int[] list) {\n    for (int i = 0; i < 16; i++) {\n        int key = list[i];\n        if (key != 0) {\n            track.add(makeEvent(144, 9, key, 100, i));\n            track.add(makeEvent(128, 9, key, 100, i + 1));\n        }\n    }\n}\n","name":"makeTracks","className":"BeatBoxSaveOnly","variables":{"i":5,"list":1,"track":2,"key":2},"constants":{"0":2,"144":1,"100":2,"1":1,"16":1,"128":1,"9":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"MidiEvent","methodCalls":{"setMessage":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"ShortMessage":1,"MidiEvent":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":1,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {\n    MidiEvent event = null;\n    try {\n        ShortMessage a = new ShortMessage();\n        a.setMessage(comd, chan, one, two);\n        event = new MidiEvent(a, tick);\n    } catch (Exception e) {\n    }\n    return event;\n}\n","name":"makeEvent","className":"BeatBoxSaveOnly","variables":{"a":3,"e":1,"tick":1,"event":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"QuizCardBuilder":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"// additional, bonus method not found in any book!\npublic static void main(String[] args) {\n    QuizCardBuilder builder = new QuizCardBuilder();\n    builder.go();\n}\n","name":"main","className":"QuizCardBuilder","variables":{"builder":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":9,"setJMenuBar":1,"setVisible":1,"setSize":1,"setVerticalScrollBarPolicy":2,"setHorizontalScrollBarPolicy":2,"addActionListener":3,"getContentPane":1,"setDefaultCloseOperation":1,"setFont":2,"setLineWrap":2,"setWrapStyleWord":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"JScrollPane":2,"JPanel":1,"JButton":1,"JLabel":2,"JMenuItem":2,"Font":1,"JMenuBar":1,"JMenu":1},"expressions":{"ObjectCreationExpr":18,"IntegerLiteralExpr":7,"VariableDeclarationExpr":11,"BooleanLiteralExpr":5,"NameExpr":119,"StringLiteralExpr":8,"FieldAccessExpr":7,"AssignExpr":4,"MethodCallExpr":27},"statements":{"ExpressionStmt":41},"text":"public void go() {\n    // build gui\n    frame = new JFrame(\"Quiz Card Builder\");\n    // title bar\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    JPanel mainPanel = new JPanel();\n    Font bigFont = new Font(\"sanserif\", Font.BOLD, 24);\n    question = new JTextArea(6, 20);\n    question.setLineWrap(true);\n    question.setWrapStyleWord(true);\n    question.setFont(bigFont);\n    JScrollPane qScroller = new JScrollPane(question);\n    qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    answer = new JTextArea(6, 20);\n    answer.setLineWrap(true);\n    answer.setWrapStyleWord(true);\n    answer.setFont(bigFont);\n    JScrollPane aScroller = new JScrollPane(answer);\n    aScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    aScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    JButton nextButton = new JButton(\"Next Card\");\n    cardList = new ArrayList();\n    JLabel qLabel = new JLabel(\"Question:\");\n    JLabel aLabel = new JLabel(\"Answer:\");\n    mainPanel.add(qLabel);\n    mainPanel.add(qScroller);\n    mainPanel.add(aLabel);\n    mainPanel.add(aScroller);\n    mainPanel.add(nextButton);\n    nextButton.addActionListener(new NextCardListener());\n    JMenuBar menuBar = new JMenuBar();\n    JMenu fileMenu = new JMenu(\"File\");\n    JMenuItem newMenuItem = new JMenuItem(\"New\");\n    JMenuItem saveMenuItem = new JMenuItem(\"Save\");\n    newMenuItem.addActionListener(new NewMenuListener());\n    saveMenuItem.addActionListener(new SaveMenuListener());\n    fileMenu.add(newMenuItem);\n    fileMenu.add(saveMenuItem);\n    menuBar.add(fileMenu);\n    frame.setJMenuBar(menuBar);\n    frame.getContentPane().add(BorderLayout.CENTER, mainPanel);\n    frame.setSize(500, 600);\n    frame.setVisible(true);\n}\n","name":"go","className":"QuizCardBuilder","variables":{"question":5,"mainPanel":6,"saveMenuItem":2,"nextButton":2,"cardList":1,"menuBar":2,"aLabel":1,"bigFont":1,"qLabel":1,"answer":5,"aScroller":3,"newMenuItem":2,"qScroller":3,"fileMenu":3,"frame":6},"constants":{"\"Quiz Card Builder\"":1,"\"New\"":1,"24":1,"\"Answer:\"":1,"\"sanserif\"":1,"\"Question:\"":1,"\"Save\"":1,"\"File\"":1,"500":1,"6":2,"600":1,"true":5,"20":2,"\"Next Card\"":1},"javaDoc":"","comments":"build gui title bar ","isEmpty":false,"hasInnerClass":false,"lineCount":41,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"add":1,"getText":2,"clearCard":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"QuizCard":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":12,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent ev) {\n    QuizCard card = new QuizCard(question.getText(), answer.getText());\n    cardList.add(card);\n    clearCard();\n}\n","name":"actionPerformed","className":"NextCardListener","variables":{"cardList":1,"question":1,"answer":1,"card":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"add":1,"getSelectedFile":1,"getText":2,"saveFile":1,"showSaveDialog":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1,"QuizCard":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":19,"MethodCallExpr":6},"statements":{"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent ev) {\n    QuizCard card = new QuizCard(question.getText(), answer.getText());\n    cardList.add(card);\n    JFileChooser fileSave = new JFileChooser();\n    fileSave.showSaveDialog(frame);\n    saveFile(fileSave.getSelectedFile());\n}\n","name":"actionPerformed","className":"SaveMenuListener","variables":{"cardList":1,"fileSave":3,"question":1,"answer":1,"card":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"clear":1,"clearCard":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent ev) {\n    cardList.clear();\n    clearCard();\n}\n","name":"actionPerformed","className":"NewMenuListener","variables":{"cardList":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"requestFocus":1,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"StringLiteralExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"private void clearCard() {\n    question.setText(\"\");\n    answer.setText(\"\");\n    question.requestFocus();\n}\n","name":"clearCard","className":"QuizCardBuilder","variables":{"question":2,"answer":1},"constants":{"\"\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":2}
{"paramTypes":["File"],"returnType":"void","methodCalls":{"next":1,"getQuestion":1,"iterator":1,"printStackTrace":1,"getAnswer":1,"hasNext":1,"write":2,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["Casting"],"types":{"Iterator":1,"QuizCard":1,"BufferedWriter":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":33,"CastExpr":1,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":10},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"private void saveFile(File file) {\n    try {\n        BufferedWriter writer = new BufferedWriter(new FileWriter(file));\n        Iterator cardIterator = cardList.iterator();\n        while (cardIterator.hasNext()) {\n            QuizCard card = (QuizCard) cardIterator.next();\n            writer.write(card.getQuestion() + \"/\");\n            writer.write(card.getAnswer() + \"\\n\");\n        }\n        writer.close();\n    } catch (IOException ex) {\n        System.out.println(\"couldn't write the cardList out\");\n        ex.printStackTrace();\n    }\n}\n","name":"saveFile","className":"QuizCardBuilder","variables":{"cardList":1,"file":1,"ex":2,"writer":4,"cardIterator":3,"card":3},"constants":{"\"/\"":1,"\"couldn't write the cardList out\"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["String","String"],"returnType":"QuizCard","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public QuizCard(String q, String a) {\n    question = q;\n    answer = a;\n}\n","name":"QuizCard","className":"QuizCard","variables":{"q":1,"a":1,"question":1,"answer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setUniqueID(String id) {\n    uniqueID = id;\n}\n","name":"setUniqueID","className":"QuizCard","variables":{"id":1,"uniqueID":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getUniqueID() {\n    return uniqueID;\n}\n","name":"getUniqueID","className":"QuizCard","variables":{"uniqueID":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setCategory(String c) {\n    category = c;\n}\n","name":"setCategory","className":"QuizCard","variables":{"c":1,"category":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getCategory() {\n    return category;\n}\n","name":"getCategory","className":"QuizCard","variables":{"category":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setQuestion(String q) {\n    question = q;\n}\n","name":"setQuestion","className":"QuizCard","variables":{"q":1,"question":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getQuestion() {\n    return question;\n}\n","name":"getQuestion","className":"QuizCard","variables":{"question":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setAnswer(String a) {\n    answer = a;\n}\n","name":"setAnswer","className":"QuizCard","variables":{"a":1,"answer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getAnswer() {\n    return answer;\n}\n","name":"getAnswer","className":"QuizCard","variables":{"answer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setHint(String h) {\n    hint = h;\n}\n","name":"setHint","className":"QuizCard","variables":{"hint":1,"h":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getHint() {\n    return hint;\n}\n","name":"getHint","className":"QuizCard","variables":{"hint":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":2,"getType":3,"writeObject":3,"close":1,"readObject":3,"System.out.println":3},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["Casting"],"types":{"GameCharacter":6,"ObjectOutputStream":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":3,"VariableDeclarationExpr":8,"BinaryExpr":3,"StringLiteralExpr":15,"NameExpr":57,"AssignExpr":3,"NullLiteralExpr":3,"ArrayInitializerExpr":3,"CastExpr":3,"FieldAccessExpr":3,"ArrayCreationExpr":3,"MethodCallExpr":15},"statements":{"TryStmt":2,"BlockStmt":4,"ExpressionStmt":20},"text":"public static void main(String[] args) {\n    GameCharacter one = new GameCharacter(50, \"Elf\", new String[] { \"bow\", \"sword\", \"dust\" });\n    GameCharacter two = new GameCharacter(200, \"Troll\", new String[] { \"bare hands\", \"big axe\" });\n    GameCharacter three = new GameCharacter(120, \"Magician\", new String[] { \"spells\", \"invisibility\" });\n    try {\n        ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"Game.ser\"));\n        os.writeObject(one);\n        os.writeObject(two);\n        os.writeObject(three);\n        os.close();\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n    one = null;\n    two = null;\n    three = null;\n    try {\n        ObjectInputStream is = new ObjectInputStream(new FileInputStream(\"Game.ser\"));\n        GameCharacter oneRestore = (GameCharacter) is.readObject();\n        GameCharacter twoRestore = (GameCharacter) is.readObject();\n        GameCharacter threeRestore = (GameCharacter) is.readObject();\n        System.out.println(\"One's type: \" + oneRestore.getType());\n        System.out.println(\"Two's type: \" + twoRestore.getType());\n        System.out.println(\"Three's type: \" + threeRestore.getType());\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"GameSaverTest","variables":{"oneRestore":2,"ex":4,"os":5,"threeRestore":2,"one":2,"is":4,"two":2,"three":2,"twoRestore":2},"constants":{"\"spells\"":1,"\"Elf\"":1,"\"Magician\"":1,"120":1,"\"Game.ser\"":2,"\"Three's type: \"":1,"\"dust\"":1,"200":1,"\"Two's type: \"":1,"\"invisibility\"":1,"null":3,"\"sword\"":1,"\"Troll\"":1,"\"bow\"":1,"\"bare hands\"":1,"\"big axe\"":1,"50":1,"\"One's type: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["int","String","String[]"],"returnType":"GameCharacter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public GameCharacter(int p, String t, String[] w) {\n    power = p;\n    type = t;\n    weapons = w;\n}\n","name":"GameCharacter","className":"GameCharacter","variables":{"p":1,"t":1,"w":1,"power":1,"type":1,"weapons":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getPower() {\n    return power;\n}\n","name":"getPower","className":"GameCharacter","variables":{"power":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getType() {\n    return type;\n}\n","name":"getType","className":"GameCharacter","variables":{"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":9,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public String getWeapons() {\n    String weaponList = \"\";\n    for (int i = 0; i < weapons.length; i++) {\n        weaponList += weapons[i] + \" \";\n    }\n    return weaponList;\n}\n","name":"getWeapons","className":"GameCharacter","variables":{"weaponList":3,"i":4,"weapons":1},"constants":{"\"\"":1,"0":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"QuizCardReader":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"// additional, bonus method not found in any book!\npublic static void main(String[] args) {\n    QuizCardReader qReader = new QuizCardReader();\n    qReader.go();\n}\n","name":"main","className":"QuizCardReader","variables":{"qReader":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5,"setJMenuBar":1,"setVisible":1,"setVerticalScrollBarPolicy":1,"addActionListener":2,"getContentPane":1,"setLineWrap":1,"setEditable":1,"setSize":1,"setHorizontalScrollBarPolicy":1,"setDefaultCloseOperation":1,"setFont":1,"setWrapStyleWord":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JScrollPane":1,"JPanel":1,"JMenuItem":1,"Font":1,"JMenuBar":1,"JMenu":1},"expressions":{"ObjectCreationExpr":11,"IntegerLiteralExpr":5,"VariableDeclarationExpr":6,"BooleanLiteralExpr":4,"NameExpr":79,"StringLiteralExpr":5,"FieldAccessExpr":5,"AssignExpr":3,"MethodCallExpr":18},"statements":{"ExpressionStmt":26},"text":"public void go() {\n    frame = new JFrame(\"Quiz Card Player\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    JPanel mainPanel = new JPanel();\n    Font bigFont = new Font(\"sanserif\", Font.BOLD, 24);\n    display = new JTextArea(9, 20);\n    display.setFont(bigFont);\n    display.setLineWrap(true);\n    display.setWrapStyleWord(true);\n    display.setEditable(false);\n    JScrollPane qScroller = new JScrollPane(display);\n    qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    nextButton = new JButton(\"Show Question\");\n    mainPanel.add(qScroller);\n    mainPanel.add(nextButton);\n    nextButton.addActionListener(new NextCardListener());\n    JMenuBar menuBar = new JMenuBar();\n    JMenu fileMenu = new JMenu(\"File\");\n    JMenuItem loadMenuItem = new JMenuItem(\"Load card set\");\n    loadMenuItem.addActionListener(new OpenMenuListener());\n    fileMenu.add(loadMenuItem);\n    menuBar.add(fileMenu);\n    frame.setJMenuBar(menuBar);\n    frame.getContentPane().add(BorderLayout.CENTER, mainPanel);\n    frame.setSize(500, 600);\n    frame.setVisible(true);\n}\n","name":"go","className":"QuizCardReader","variables":{"nextButton":2,"menuBar":2,"bigFont":1,"mainPanel":3,"display":6,"loadMenuItem":2,"qScroller":3,"fileMenu":2,"frame":6},"constants":{"24":1,"\"sanserif\"":1,"\"File\"":1,"\"Load card set\"":1,"500":1,"600":1,"true":3,"false":1,"\"Quiz Card Player\"":1,"9":1,"\"Show Question\"":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":26,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getAnswer":1,"showNextCard":1,"disable":1,"hasNext":1,"setText":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":22,"StringLiteralExpr":2,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":4,"ExpressionStmt":6},"text":"public void actionPerformed(ActionEvent ev) {\n    if (isShowAnswer) {\n        // show the answer because they've seen the question\n        display.setText(currentCard.getAnswer());\n        nextButton.setText(\"Next Card\");\n        isShowAnswer = false;\n    } else {\n        // show the next question\n        if (cardIterator.hasNext()) {\n            showNextCard();\n        } else {\n            // there are no more cards!\n            display.setText(\"That was last card\");\n            nextButton.disable();\n        }\n    }\n// close if\n}\n","name":"actionPerformed","className":"NextCardListener","variables":{"nextButton":2,"display":2,"currentCard":1,"isShowAnswer":2,"cardIterator":1},"constants":{"false":1,"\"That was last card\"":1,"\"Next Card\"":1},"javaDoc":"","comments":"close if show the answer because they've seen the question show the next question there are no more cards! ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showOpenDialog":1,"getSelectedFile":1,"loadFile":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent ev) {\n    JFileChooser fileOpen = new JFileChooser();\n    fileOpen.showOpenDialog(frame);\n    loadFile(fileOpen.getSelectedFile());\n}\n","name":"actionPerformed","className":"OpenMenuListener","variables":{"fileOpen":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["File"],"returnType":"void","methodCalls":{"iterator":1,"printStackTrace":1,"showNextCard":1,"readLine":1,"makeCard":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"BufferedReader":1,"String":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":26,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":3,"MethodCallExpr":7},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"private void loadFile(File file) {\n    cardList = new ArrayList();\n    try {\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            makeCard(line);\n        }\n        reader.close();\n    } catch (Exception ex) {\n        System.out.println(\"couldn't read the card file\");\n        ex.printStackTrace();\n    }\n    // now time to start\n    cardIterator = cardList.iterator();\n    showNextCard();\n}\n","name":"loadFile","className":"QuizCardReader","variables":{"cardList":2,"file":1,"ex":2,"reader":3,"line":2,"cardIterator":1},"constants":{"null":2,"\"couldn't read the card file\"":1},"javaDoc":"","comments":"now time to start ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"hasMoreTokens":1,"nextToken":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringTokenizer":1,"QuizCard":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":14,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"private void makeCard(String lineToParse) {\n    StringTokenizer parser = new StringTokenizer(lineToParse, \"/\");\n    if (parser.hasMoreTokens()) {\n        QuizCard card = new QuizCard(parser.nextToken(), parser.nextToken());\n        cardList.add(card);\n    }\n}\n","name":"makeCard","className":"QuizCardReader","variables":{"cardList":1,"parser":4,"lineToParse":1,"card":1},"constants":{"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"next":1,"getQuestion":1,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":14,"CastExpr":1,"StringLiteralExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"private void showNextCard() {\n    currentCard = (QuizCard) cardIterator.next();\n    display.setText(currentCard.getQuestion());\n    nextButton.setText(\"Show Answer\");\n    isShowAnswer = true;\n}\n","name":"showNextCard","className":"QuizCardReader","variables":{"nextButton":1,"currentCard":2,"display":1,"isShowAnswer":1,"cardIterator":1},"constants":{"\"Show Answer\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"getInputStream":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"InputStreamReader":1,"BufferedReader":1,"String":1,"Socket":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":19,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"public void go() {\n    try {\n        Socket s = new Socket(\"127.0.0.1\", 4242);\n        InputStreamReader streamReader = new InputStreamReader(s.getInputStream());\n        BufferedReader reader = new BufferedReader(streamReader);\n        String advice = reader.readLine();\n        System.out.println(\"Today you should: \" + advice);\n        reader.close();\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"go","className":"DailyAdviceClient","variables":{"s":2,"ex":2,"streamReader":2,"reader":3,"advice":2},"constants":{"4242":1,"\"127.0.0.1\"":1,"\"Today you should: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"DailyAdviceClient":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    DailyAdviceClient client = new DailyAdviceClient();\n    client.go();\n}\n","name":"main","className":"DailyAdviceClient","variables":{"client":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setName":2,"start":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"RunThreads":1,"Thread":2},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"NameExpr":14,"StringLiteralExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    RunThreads runner = new RunThreads();\n    Thread alpha = new Thread(runner);\n    Thread beta = new Thread(runner);\n    alpha.setName(\"Alpha thread\");\n    beta.setName(\"Beta thread\");\n    alpha.start();\n    beta.start();\n}\n","name":"main","className":"RunThreads","variables":{"alpha":3,"runner":3,"beta":3},"constants":{"\"Beta thread\"":1,"\"Alpha thread\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentThread":1,"getName":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    for (int i = 0; i < 25; i++) {\n        String threadName = Thread.currentThread().getName();\n        System.out.println(threadName + \" is running\");\n    }\n}\n","name":"run","className":"RunThreads","variables":{"i":3,"threadName":2,"Thread":1},"constants":{"0":1,"25":1,"\" is running\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"println":1,"printStackTrace":1,"getOutputStream":1,"getAdvice":1,"close":1,"accept":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"ServerSocket":1,"String":1,"Socket":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"NameExpr":24,"FieldAccessExpr":1,"MethodCallExpr":7},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public void go() {\n    try {\n        ServerSocket serverSock = new ServerSocket(4242);\n        while (true) {\n            Socket sock = serverSock.accept();\n            PrintWriter writer = new PrintWriter(sock.getOutputStream());\n            String advice = getAdvice();\n            writer.println(advice);\n            writer.close();\n            System.out.println(advice);\n        }\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"go","className":"DailyAdviceServer","variables":{"sock":2,"ex":2,"advice":1,"writer":3,"serverSock":2},"constants":{"4242":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"random":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"CastExpr":1,"NameExpr":8,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"private String getAdvice() {\n    int random = (int) (Math.random() * adviceList.length);\n    return adviceList[random];\n}\n","name":"getAdvice","className":"DailyAdviceServer","variables":{"random":2,"Math":1,"adviceList":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"DailyAdviceServer":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    DailyAdviceServer server = new DailyAdviceServer();\n    server.go();\n}\n","name":"main","className":"DailyAdviceServer","variables":{"server":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setName":2,"start":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"RyanAndMonicaJob":1,"Thread":2},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"NameExpr":14,"StringLiteralExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    RyanAndMonicaJob theJob = new RyanAndMonicaJob();\n    Thread one = new Thread(theJob);\n    Thread two = new Thread(theJob);\n    one.setName(\"Ryan\");\n    two.setName(\"Monica\");\n    one.start();\n    two.start();\n}\n","name":"main","className":"RyanAndMonicaJob","variables":{"theJob":3,"one":3,"two":3},"constants":{"\"Monica\"":1,"\"Ryan\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getBalance":1,"makeWithdrawal":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    for (int x = 0; x < 10; x++) {\n        makeWithdrawal(10);\n        if (account.getBalance() < 0) {\n            System.out.println(\"Overdrawn!\");\n        }\n    }\n}\n","name":"run","className":"RyanAndMonicaJob","variables":{"x":3,"account":1},"constants":{"0":2,"\"Overdrawn!\"":1,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"sleep":1,"currentThread":5,"getBalance":1,"getName":5,"printStackTrace":1,"System.out.println":5,"withdraw":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":6,"NameExpr":64,"StringLiteralExpr":5,"FieldAccessExpr":5,"MethodCallExpr":19},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":8},"text":"//  to demonstrate the \"overdrawn\" error remove the \"synchronized\" modifier\nprivate synchronized void makeWithdrawal(int amount) {\n    if (account.getBalance() >= amount) {\n        System.out.println(Thread.currentThread().getName() + \" is about to withdrawal\");\n        try {\n            System.out.println(Thread.currentThread().getName() + \" is going to sleep\");\n            Thread.sleep(500);\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" woke up\");\n        account.withdraw(amount);\n        System.out.println(Thread.currentThread().getName() + \" completes the withdrawal\");\n    } else {\n        System.out.println(\"Sorry, not enough for \" + Thread.currentThread().getName());\n    }\n}\n","name":"makeWithdrawal","className":"RyanAndMonicaJob","variables":{"amount":1,"ex":2,"account":2,"Thread":6},"constants":{"\" woke up\"":1,"\"Sorry, not enough for \"":1,"500":1,"\" is about to withdrawal\"":1,"\" is going to sleep\"":1,"\" completes the withdrawal\"":1},"javaDoc":"","comments":"  to demonstrate the \"overdrawn\" error remove the \"synchronized\" modifier","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":34}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void withdraw(int amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Socket"],"returnType":"ClientHandler","methodCalls":{"printStackTrace":1,"getInputStream":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"InputStreamReader":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":10,"AssignExpr":2,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public ClientHandler(Socket clientSOcket) {\n    try {\n        sock = clientSOcket;\n        InputStreamReader isReader = new InputStreamReader(sock.getInputStream());\n        reader = new BufferedReader(isReader);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"ClientHandler","className":"ClientHandler","variables":{"sock":2,"ex":2,"clientSOcket":1,"reader":1,"isReader":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"tellEveryone":1,"printStackTrace":1,"readLine":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":4},"text":"public void run() {\n    String message;\n    try {\n        while ((message = reader.readLine()) != null) {\n            System.out.println(\"read \" + message);\n            tellEveryone(message);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"run","className":"ClientHandler","variables":{"ex":2,"reader":1,"message":3},"constants":{"\"read \"":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new VerySimpleChatServer().go();\n}\n","name":"main","className":"VerySimpleChatServer","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"printStackTrace":1,"start":1,"getOutputStream":1,"accept":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"ServerSocket":1,"Socket":1,"PrintWriter":1,"Thread":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public void go() {\n    clientOutputStreams = new ArrayList();\n    try {\n        ServerSocket serverSock = new ServerSocket(5000);\n        while (true) {\n            Socket clientSocket = serverSock.accept();\n            PrintWriter writer = new PrintWriter(clientSocket.getOutputStream());\n            clientOutputStreams.add(writer);\n            Thread t = new Thread(new ClientHandler(clientSocket));\n            t.start();\n            System.out.println(\"got a connection\");\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"go","className":"VerySimpleChatServer","variables":{"clientSocket":3,"ex":2,"t":2,"clientOutputStreams":2,"writer":1,"serverSock":2},"constants":{"5000":1,"true":1,"\"got a connection\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"println":1,"flush":1,"printStackTrace":1,"hasNext":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"Iterator":1,"PrintWriter":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":19,"CastExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":5},"text":"public void tellEveryone(String message) {\n    Iterator it = clientOutputStreams.iterator();\n    while (it.hasNext()) {\n        try {\n            PrintWriter writer = (PrintWriter) it.next();\n            writer.println(message);\n            writer.flush();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n","name":"tellEveryone","className":"VerySimpleChatServer","variables":{"ex":2,"clientOutputStreams":1,"it":3,"writer":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3,"setVisible":1,"setSize":1,"addActionListener":1,"getContentPane":1,"setUpNetworking":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"JFrame":1,"JButton":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"StringLiteralExpr":2,"NameExpr":29,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":8},"statements":{"ExpressionStmt":11},"text":"public void go() {\n    JFrame frame = new JFrame(\"Ludicrously Simple Chat Client\");\n    JPanel mainPanel = new JPanel();\n    outgoing = new JTextField(20);\n    JButton sendButton = new JButton(\"Send\");\n    sendButton.addActionListener(new SendButtonListener());\n    mainPanel.add(outgoing);\n    mainPanel.add(sendButton);\n    frame.getContentPane().add(BorderLayout.CENTER, mainPanel);\n    setUpNetworking();\n    frame.setSize(400, 500);\n    frame.setVisible(true);\n}\n","name":"go","className":"SimpleChatClientA","variables":{"outgoing":1,"mainPanel":3,"frame":4,"sendButton":2},"constants":{"400":1,"500":1,"true":1,"\"Ludicrously Simple Chat Client\"":1,"\"Send\"":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"getOutputStream":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":1,"AssignExpr":2,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"private void setUpNetworking() {\n    try {\n        sock = new Socket(\"127.0.0.1\", 5000);\n        writer = new PrintWriter(sock.getOutputStream());\n        System.out.println(\"networking established\");\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"setUpNetworking","className":"SimpleChatClientA","variables":{"sock":2,"ex":2,"writer":1},"constants":{"5000":1,"\"127.0.0.1\"":1,"\"networking established\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"println":1,"requestFocus":1,"flush":1,"printStackTrace":1,"getText":1,"setText":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"NameExpr":18,"StringLiteralExpr":1,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent ev) {\n    try {\n        writer.println(outgoing.getText());\n        writer.flush();\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    outgoing.setText(\"\");\n    outgoing.requestFocus();\n}\n","name":"actionPerformed","className":"SendButtonListener","variables":{"outgoing":3,"ex":2,"writer":2},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new SimpleChatClientA().go();\n}\n","name":"main","className":"SimpleChatClientA","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":4,"setVisible":1,"setEditable":1,"setSize":1,"setVerticalScrollBarPolicy":1,"setHorizontalScrollBarPolicy":1,"addActionListener":1,"start":1,"getContentPane":1,"setUpNetworking":1,"setLineWrap":1,"setWrapStyleWord":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JScrollPane":1,"JPanel":1,"JFrame":1,"JButton":1,"Thread":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":5,"VariableDeclarationExpr":5,"BooleanLiteralExpr":4,"StringLiteralExpr":2,"NameExpr":59,"FieldAccessExpr":3,"AssignExpr":2,"MethodCallExpr":15},"statements":{"ExpressionStmt":21},"text":"public void go() {\n    JFrame frame = new JFrame(\"Ludicrously Simple Chat Client\");\n    JPanel mainPanel = new JPanel();\n    incoming = new JTextArea(15, 50);\n    incoming.setLineWrap(true);\n    incoming.setWrapStyleWord(true);\n    incoming.setEditable(false);\n    JScrollPane qScroller = new JScrollPane(incoming);\n    qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);\n    outgoing = new JTextField(20);\n    JButton sendButton = new JButton(\"Send\");\n    sendButton.addActionListener(new SendButtonListener());\n    mainPanel.add(qScroller);\n    mainPanel.add(outgoing);\n    mainPanel.add(sendButton);\n    frame.getContentPane().add(BorderLayout.CENTER, mainPanel);\n    setUpNetworking();\n    Thread readerThread = new Thread(new IncomingReader());\n    readerThread.start();\n    frame.setSize(650, 500);\n    frame.setVisible(true);\n}\n","name":"go","className":"SimpleChatClient","variables":{"incoming":5,"outgoing":1,"readerThread":2,"mainPanel":4,"qScroller":3,"frame":4,"sendButton":2},"constants":{"650":1,"15":1,"500":1,"true":3,"false":1,"\"Ludicrously Simple Chat Client\"":1,"50":1,"\"Send\"":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":21,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"getOutputStream":1,"getInputStream":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"InputStreamReader":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":18,"StringLiteralExpr":2,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"private void setUpNetworking() {\n    try {\n        sock = new Socket(\"127.0.0.1\", 5000);\n        InputStreamReader streamReader = new InputStreamReader(sock.getInputStream());\n        reader = new BufferedReader(streamReader);\n        writer = new PrintWriter(sock.getOutputStream());\n        System.out.println(\"networking established\");\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"setUpNetworking","className":"SimpleChatClient","variables":{"sock":3,"ex":2,"streamReader":2,"reader":1,"writer":1},"constants":{"5000":1,"\"127.0.0.1\"":1,"\"networking established\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"println":1,"requestFocus":1,"flush":1,"printStackTrace":1,"getText":1,"setText":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"NameExpr":18,"StringLiteralExpr":1,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent ev) {\n    try {\n        writer.println(outgoing.getText());\n        writer.flush();\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    outgoing.setText(\"\");\n    outgoing.requestFocus();\n}\n","name":"actionPerformed","className":"SendButtonListener","variables":{"outgoing":3,"ex":2,"writer":2},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new SimpleChatClient().go();\n}\n","name":"main","className":"SimpleChatClient","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"append":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":17,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":4},"text":"public void run() {\n    String message;\n    try {\n        while ((message = reader.readLine()) != null) {\n            System.out.println(\"client read \" + message);\n            incoming.append(message + \"\\n\");\n        }\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"run","className":"IncomingReader","variables":{"incoming":1,"ex":2,"reader":1,"message":4},"constants":{"null":1,"\"client read \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void run() {\n    go();\n}\n","name":"run","className":"MyRunnable","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"printStackTrace":1,"doMore":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":8,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public void go() {\n    //*\n    try {\n        Thread.sleep(2000);\n    } catch (InterruptedException ex) {\n        ex.printStackTrace();\n    }\n    //*/\n    doMore();\n}\n","name":"go","className":"MyRunnable","variables":{"ex":2,"Thread":1},"constants":{"2000":1},"javaDoc":"","comments":"/  ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void doMore() {\n    System.out.println(\"top o' the stack\");\n}\n","name":"doMore","className":"MyRunnable","variables":{},"constants":{"\"top o' the stack\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"MyRunnable":1,"Runnable":1,"Thread":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    Runnable threadJob = new MyRunnable();\n    Thread myThread = new Thread(threadJob);\n    myThread.start();\n    System.out.println(\"back in main\");\n}\n","name":"main","className":"MyRunnable","variables":{"threadJob":2,"myThread":2},"constants":{"\"back in main\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"bark":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Dog[]":1,"Dog":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":9,"VariableDeclarationExpr":3,"ArrayAccessExpr":7,"BinaryExpr":2,"NameExpr":39,"StringLiteralExpr":4,"FieldAccessExpr":7,"ArrayCreationExpr":1,"MethodCallExpr":4,"AssignExpr":7},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    Dog dog1 = new Dog();\n    dog1.bark();\n    dog1.name = \"Bart\";\n    Dog[] myDogs = new Dog[3];\n    myDogs[0] = new Dog();\n    myDogs[1] = new Dog();\n    myDogs[2] = dog1;\n    myDogs[0].name = \"Fred\";\n    myDogs[1].name = \"Marge\";\n    System.out.print(\"last don't name is \");\n    System.out.println(myDogs[2].name);\n    int x = 0;\n    while (x < myDogs.length) {\n        myDogs[x].bark();\n        x = x + 1;\n    }\n}\n","name":"main","className":"Dog","variables":{"x":5,"dog1":3,"myDogs":8},"constants":{"0":3,"1":3,"\"Fred\"":1,"2":2,"3":1,"\"last don't name is \"":1,"\"Bart\"":1,"\"Marge\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void bark() {\n    System.out.println(name + \" says Ruff!\");\n}\n","name":"bark","className":"Dog","variables":{"name":1},"constants":{"\" says Ruff!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void eat() {\n}\n","name":"eat","className":"Dog","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void chaseCat() {\n}\n","name":"chaseCat","className":"Dog","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"startGame":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"GuessGame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    GuessGame game = new GuessGame();\n    game.startGame();\n}\n","name":"main","className":"GameLauncher","variables":{"game":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"random":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":10,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void guess() {\n    number = (int) (Math.random() * 10);\n    System.out.println(\"I'm guessing \" + number);\n}\n","name":"guess","className":"Player","variables":{"number":2,"Math":1},"constants":{"\"I'm guessing \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"random":1,"guess":3,"System.out.println":11},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":3,"int":4},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":4,"VariableDeclarationExpr":7,"BooleanLiteralExpr":7,"BinaryExpr":13,"NameExpr":101,"CastExpr":1,"StringLiteralExpr":11,"FieldAccessExpr":14,"EnclosedExpr":1,"AssignExpr":9,"MethodCallExpr":15},"statements":{"IfStmt":4,"WhileStmt":1,"BreakStmt":1,"BlockStmt":6,"ExpressionStmt":30},"text":"public void startGame() {\n    p1 = new Player();\n    p2 = new Player();\n    p3 = new Player();\n    int guessp1 = 0;\n    int guessp2 = 0;\n    int guessp3 = 0;\n    boolean p1isRight = false;\n    boolean p2isRight = false;\n    boolean p3isRight = false;\n    int targetNumber = (int) (Math.random() * 10);\n    System.out.println(\"I'm thinking of a number between 0 and 9...\");\n    while (true) {\n        System.out.println(\"Number to guess is \" + targetNumber);\n        p1.guess();\n        p2.guess();\n        p3.guess();\n        guessp1 = p1.number;\n        System.out.println(\"Player one guessed \" + guessp1);\n        guessp2 = p2.number;\n        System.out.println(\"Player two guessed \" + guessp2);\n        guessp3 = p3.number;\n        System.out.println(\"Player three guessed \" + guessp3);\n        if (guessp1 == targetNumber) {\n            p1isRight = true;\n        }\n        if (guessp2 == targetNumber) {\n            p2isRight = true;\n        }\n        if (guessp3 == targetNumber) {\n            p3isRight = true;\n        }\n        if (p1isRight || p2isRight || p3isRight) {\n            System.out.println(\"We have a winner!\");\n            System.out.println(\"Player one got it right? \" + p1isRight);\n            System.out.println(\"Player two got it right? \" + p2isRight);\n            System.out.println(\"Player three got it right? \" + p3isRight);\n            System.out.println(\"Game is over\");\n            break;\n        } else {\n            System.out.println(\"Players will have to try again.\");\n        }\n    }\n}\n","name":"startGame","className":"GuessGame","variables":{"p1":2,"targetNumber":5,"p2":2,"p3":2,"p3isRight":4,"guessp3":4,"guessp1":4,"guessp2":4,"p1isRight":4,"p2isRight":4,"Math":1},"constants":{"\"Player three guessed \"":1,"\"Player three got it right? \"":1,"\"Player two guessed \"":1,"\"We have a winner!\"":1,"\"Number to guess is \"":1,"\"Player one guessed \"":1,"false":3,"0":3,"\"I'm thinking of a number between 0 and 9...\"":1,"true":4,"\"Players will have to try again.\"":1,"\"Player two got it right? \"":1,"\"Game is over\"":1,"10":1,"\"Player one got it right? \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":12,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new Jukebox6().go();\n}\n","name":"main","className":"Jukebox6","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"addAll":1,"sort":1,"getSongs":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"HashSet<SongBad>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":28,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public void go() {\n    getSongs();\n    System.out.println(songList);\n    Collections.sort(songList);\n    System.out.println(songList);\n    HashSet<SongBad> songSet = new HashSet<SongBad>();\n    songSet.addAll(songList);\n    System.out.println(songSet);\n}\n","name":"go","className":"Jukebox6","variables":{"songSet":2,"Collections":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"addSong":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"BufferedReader":1,"String":1,"File":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"void getSongs() {\n    try {\n        File file = new File(\"SongListMore.txt\");\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            addSong(line);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"getSongs","className":"Jukebox6","variables":{"file":2,"ex":2,"reader":2,"line":2},"constants":{"\"SongListMore.txt\"":1,"null":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"SongBad":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"void addSong(String lineToParse) {\n    String[] tokens = lineToParse.split(\"/\");\n    SongBad nextSong = new SongBad(tokens[0], tokens[1], tokens[2], tokens[3]);\n    songList.add(nextSong);\n}\n","name":"addSong","className":"Jukebox6","variables":{"lineToParse":1,"tokens":5,"songList":1,"nextSong":1},"constants":{"0":1,"1":1,"2":1,"3":1,"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":0}
{"paramTypes":["String","String","String","String"],"returnType":"SongBad","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public SongBad(String t, String a, String r, String b) {\n    title = t;\n    artist = a;\n    rating = r;\n    bpm = b;\n}\n","name":"SongBad","className":"SongBad","variables":{"a":1,"r":1,"b":1,"t":1,"artist":1,"rating":1,"title":1,"bpm":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getTitle":2,"equals":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"SongBad":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":8,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean equals(Object aSong) {\n    SongBad s = (SongBad) aSong;\n    return getTitle().equals(s.getTitle());\n}\n","name":"equals","className":"SongBad","variables":{"s":2,"aSong":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["SongBad"],"returnType":"int","methodCalls":{"getTitle":1,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"//leaving this out makes this a bad form of song.  Uncomment this to get rid of the duplicates\n/*public int hashCode() {\n        return title.hashCode();\n    }\n    */\npublic int compareTo(SongBad s) {\n    return title.compareTo(s.getTitle());\n}\n","name":"compareTo","className":"SongBad","variables":{"s":1,"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getArtist() {\n    return artist;\n}\n","name":"getArtist","className":"SongBad","variables":{"artist":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getBpm() {\n    return bpm;\n}\n","name":"getBpm","className":"SongBad","variables":{"bpm":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getRating() {\n    return rating;\n}\n","name":"getRating","className":"SongBad","variables":{"rating":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getTitle() {\n    return title;\n}\n","name":"getTitle","className":"SongBad","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return title;\n}\n","name":"toString","className":"SongBad","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new Jukebox3().go();\n}\n","name":"main","className":"Jukebox3","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"sort":1,"getSongs":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":18,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void go() {\n    getSongs();\n    System.out.println(songList);\n    Collections.sort(songList);\n    System.out.println(songList);\n}\n","name":"go","className":"Jukebox3","variables":{"Collections":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"addSong":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"BufferedReader":1,"String":1,"File":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"void getSongs() {\n    try {\n        File file = new File(\"SongList.txt\");\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            addSong(line);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"getSongs","className":"Jukebox3","variables":{"file":2,"ex":2,"reader":2,"line":2},"constants":{"null":2,"\"SongList.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Song":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"void addSong(String lineToParse) {\n    String[] tokens = lineToParse.split(\"/\");\n    Song nextSong = new Song(tokens[0], tokens[1], tokens[2], tokens[3]);\n    songList.add(nextSong);\n}\n","name":"addSong","className":"Jukebox3","variables":{"lineToParse":1,"tokens":5,"songList":1,"nextSong":1},"constants":{"0":1,"1":1,"2":1,"3":1,"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new Jukebox1().go();\n}\n","name":"main","className":"Jukebox1","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSongs":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void go() {\n    getSongs();\n    System.out.println(songList);\n}\n","name":"go","className":"Jukebox1","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"addSong":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"BufferedReader":1,"String":1,"File":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"void getSongs() {\n    try {\n        File file = new File(\"SongList.txt\");\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            addSong(line);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"getSongs","className":"Jukebox1","variables":{"file":2,"ex":2,"reader":2,"line":2},"constants":{"null":2,"\"SongList.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":7,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"void addSong(String lineToParse) {\n    String[] tokens = lineToParse.split(\"/\");\n    songList.add(tokens[0]);\n}\n","name":"addSong","className":"Jukebox1","variables":{"lineToParse":1,"tokens":2,"songList":1},"constants":{"0":1,"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new Jukebox8().go();\n}\n","name":"main","className":"Jukebox8","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"addAll":1,"sort":1,"getSongs":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"TreeSet<Song>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":28,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public void go() {\n    getSongs();\n    System.out.println(songList);\n    Collections.sort(songList);\n    System.out.println(songList);\n    TreeSet<Song> songSet = new TreeSet<Song>();\n    songSet.addAll(songList);\n    System.out.println(songSet);\n}\n","name":"go","className":"Jukebox8","variables":{"songSet":2,"Collections":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"addSong":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"BufferedReader":1,"String":1,"File":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"void getSongs() {\n    try {\n        File file = new File(\"SongListMore.txt\");\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            addSong(line);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"getSongs","className":"Jukebox8","variables":{"file":2,"ex":2,"reader":2,"line":2},"constants":{"\"SongListMore.txt\"":1,"null":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Song":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"void addSong(String lineToParse) {\n    String[] tokens = lineToParse.split(\"/\");\n    Song nextSong = new Song(tokens[0], tokens[1], tokens[2], tokens[3]);\n    songList.add(nextSong);\n}\n","name":"addSong","className":"Jukebox8","variables":{"lineToParse":1,"tokens":5,"songList":1,"nextSong":1},"constants":{"0":1,"1":1,"2":1,"3":1,"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new Jukebox5().go();\n}\n","name":"main","className":"Jukebox5","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["Song","Song"],"returnType":"int","methodCalls":{"getArtist":2,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"MethodCallExpr":3},"statements":{"ReturnStmt":1},"text":"public int compare(Song one, Song two) {\n    return one.getArtist().compareTo(two.getArtist());\n}\n","name":"compare","className":"ArtistCompare","variables":{"one":1,"two":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sort":2,"getSongs":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArtistCompare":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":29,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public void go() {\n    getSongs();\n    System.out.println(songList);\n    Collections.sort(songList);\n    System.out.println(songList);\n    ArtistCompare artistCompare = new ArtistCompare();\n    Collections.sort(songList, artistCompare);\n    System.out.println(songList);\n}\n","name":"go","className":"Jukebox5","variables":{"artistCompare":1,"Collections":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"addSong":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"BufferedReader":1,"String":1,"File":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"void getSongs() {\n    try {\n        File file = new File(\"SongListMore.txt\");\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            addSong(line);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"getSongs","className":"Jukebox5","variables":{"file":2,"ex":2,"reader":2,"line":2},"constants":{"\"SongListMore.txt\"":1,"null":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Song":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"void addSong(String lineToParse) {\n    String[] tokens = lineToParse.split(\"/\");\n    Song nextSong = new Song(tokens[0], tokens[1], tokens[2], tokens[3]);\n    songList.add(nextSong);\n}\n","name":"addSong","className":"Jukebox5","variables":{"lineToParse":1,"tokens":5,"songList":1,"nextSong":1},"constants":{"0":1,"1":1,"2":1,"3":1,"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":0}
{"paramTypes":["String","String","String","String"],"returnType":"Song","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public Song(String t, String a, String r, String b) {\n    title = t;\n    artist = a;\n    rating = r;\n    bpm = b;\n}\n","name":"Song","className":"Song","variables":{"a":1,"r":1,"b":1,"t":1,"artist":1,"rating":1,"title":1,"bpm":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getTitle":2,"equals":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Song":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":8,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean equals(Object aSong) {\n    Song s = (Song) aSong;\n    return getTitle().equals(s.getTitle());\n}\n","name":"equals","className":"Song","variables":{"s":2,"aSong":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"hashCode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int hashCode() {\n    return title.hashCode();\n}\n","name":"hashCode","className":"Song","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Song"],"returnType":"int","methodCalls":{"getTitle":1,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public int compareTo(Song s) {\n    return title.compareTo(s.getTitle());\n}\n","name":"compareTo","className":"Song","variables":{"s":1,"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getArtist() {\n    return artist;\n}\n","name":"getArtist","className":"Song","variables":{"artist":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getBpm() {\n    return bpm;\n}\n","name":"getBpm","className":"Song","variables":{"bpm":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getRating() {\n    return rating;\n}\n","name":"getRating","className":"Song","variables":{"rating":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getTitle() {\n    return title;\n}\n","name":"getTitle","className":"Song","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return title;\n}\n","name":"toString","className":"Song","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":1,"setLocationCells":1,"checkYourself":1,"equals":1,"getUserInput":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"GameHelper":1,"SimpleDotCom":1,"boolean":1,"int[]":1,"String":2,"int":2},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":2,"VariableDeclarationExpr":8,"BinaryExpr":6,"NameExpr":29,"StringLiteralExpr":4,"UnaryExpr":1,"AssignExpr":1,"ArrayInitializerExpr":1,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    int numOfGuesses = 0;\n    GameHelper helper = new GameHelper();\n    SimpleDotCom theDotCom = new SimpleDotCom();\n    int randomNum = (int) (Math.random() * 5);\n    int[] locations = { randomNum, randomNum + 1, randomNum + 2 };\n    theDotCom.setLocationCells(locations);\n    boolean isAlive = true;\n    while (isAlive == true) {\n        String guess = helper.getUserInput(\"enter a number\");\n        String result = theDotCom.checkYourself(guess);\n        numOfGuesses++;\n        if (result.equals(\"kill\")) {\n            isAlive = false;\n            System.out.println(\"You took \" + numOfGuesses + \" guesses\");\n        }\n    }\n}\n","name":"main","className":"Game","variables":{"result":2,"isAlive":3,"numOfGuesses":3,"helper":2,"theDotCom":3,"guess":1,"locations":1,"Math":1,"randomNum":4},"constants":{"0":1,"1":1,"2":1,"5":1,"true":2,"false":1,"\"kill\"":1,"\"You took \"":1,"\"enter a number\"":1,"\" guesses\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setLocationCells":1,"checkYourself":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"SimpleDotCom":1,"int[]":1,"String":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"NameExpr":8,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    SimpleDotCom dot = new SimpleDotCom();\n    int[] locations = { 2, 3, 4 };\n    dot.setLocationCells(locations);\n    String userGuess = \"2\";\n    String result = dot.checkYourself(userGuess);\n}\n","name":"main","className":"SimpleDotComTester","variables":{"result":1,"userGuess":1,"dot":3,"locations":1},"constants":{"2":1,"\"2\"":1,"3":1,"4":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setLocationCells(int[] locs) {\n    locationCells = locs;\n}\n","name":"setLocationCells","className":"SimpleDotCom","variables":{"locs":1,"locationCells":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"parseInt":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":2},"expressions":{"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":2},"statements":{"IfStmt":2,"BreakStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"public String checkYourself(String stringGuess) {\n    int guess = Integer.parseInt(stringGuess);\n    String result = \"miss\";\n    for (int cell : locationCells) {\n        if (guess == cell) {\n            result = \"hit\";\n            numOfHits++;\n            break;\n        }\n    }\n    if (numOfHits == locationCells.length) {\n        result = \"kill\";\n    }\n    System.out.println(result);\n    return result;\n}\n","name":"checkYourself","className":"SimpleDotCom","variables":{"Integer":1,"result":4,"locationCells":1,"guess":2,"numOfHits":2,"cell":2},"constants":{"\"miss\"":1,"\"kill\"":1,"\"hit\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"toLowerCase":1,"length":1,"readLine":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"BufferedReader":1,"String":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":25,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":5},"text":"public String getUserInput(String prompt) {\n    String inputLine = null;\n    System.out.print(prompt + \"  \");\n    try {\n        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n        inputLine = is.readLine();\n        if (inputLine.length() == 0)\n            return null;\n    } catch (IOException e) {\n        System.out.println(\"IOException: \" + e);\n    }\n    return inputLine.toLowerCase();\n}\n","name":"getUserInput","className":"GameHelper","variables":{"inputLine":4,"e":2,"is":2,"prompt":1},"constants":{"0":1,"null":2,"\"IOException: \"":1,"\"  \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"ArrayList<String>","methodCalls":{"add":1,"random":1,"valueOf":1,"toString":1,"concat":1,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int[]":1,"ArrayList<String>":1,"String[]":1,"String":1,"int":7},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":14,"VariableDeclarationExpr":12,"ArrayAccessExpr":6,"BinaryExpr":16,"NameExpr":65,"UnaryExpr":5,"AssignExpr":12,"NullLiteralExpr":1,"BooleanLiteralExpr":5,"CastExpr":2,"EnclosedExpr":4,"ArrayCreationExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":4,"WhileStmt":3,"BlockStmt":8,"ReturnStmt":1,"ExpressionStmt":27},"text":"public ArrayList<String> placeDotCom(int comSize) {\n    // line 19\n    ArrayList<String> alphaCells = new ArrayList<String>();\n    // holds 'f6' type coords\n    String[] alphacoords = new String[comSize];\n    // temporary String for concat\n    String temp = null;\n    // current candidate coords\n    int[] coords = new int[comSize];\n    // current attempts counter\n    int attempts = 0;\n    // flag = found a good location ?\n    boolean success = false;\n    // current starting location\n    int location = 0;\n    // nth dot com to place\n    comCount++;\n    // set horizontal increment\n    int incr = 1;\n    if ((comCount % 2) == 1) {\n        // if odd dot com  (place vertically)\n        // set vertical increment\n        incr = gridLength;\n    }\n    while (!success & attempts++ < 200) {\n        // main search loop  (32)\n        // get random starting point\n        location = (int) (Math.random() * gridSize);\n        //System.out.print(\" try \" + location);\n        // nth position in dotcom to place\n        int x = 0;\n        // assume success\n        success = true;\n        while (success && x < comSize) {\n            // look for adjacent unused spots\n            if (grid[location] == 0) {\n                // if not already used\n                // save location\n                coords[x++] = location;\n                // try 'next' adjacent\n                location += incr;\n                if (location >= gridSize) {\n                    // out of bounds - 'bottom'\n                    // failure\n                    success = false;\n                }\n                if (x > 0 & (location % gridLength == 0)) {\n                    // out of bounds - right edge\n                    // failure\n                    success = false;\n                }\n            } else {\n                // found already used location\n                // System.out.print(\" used \" + location);  \n                // failure\n                success = false;\n            }\n        }\n    }\n    // end while\n    // turn good location into alpha coords\n    int x = 0;\n    int row = 0;\n    int column = 0;\n    // System.out.println(\"\\n\");\n    while (x < comSize) {\n        // mark master grid pts. as 'used'\n        grid[coords[x]] = 1;\n        // get row value\n        row = (int) (coords[x] / gridLength);\n        // get numeric column value\n        column = coords[x] % gridLength;\n        // convert to alpha\n        temp = String.valueOf(alphabet.charAt(column));\n        alphaCells.add(temp.concat(Integer.toString(row)));\n        x++;\n    // System.out.print(\"  coord \"+x+\" = \" + alphaCells.get(x-1));\n    }\n    return alphaCells;\n}\n","name":"placeDotCom","className":"GameHelper","variables":{"temp":3,"comCount":2,"incr":3,"column":2,"String":1,"alphabet":1,"Math":1,"gridLength":4,"Integer":1,"gridSize":2,"alphacoords":1,"success":7,"grid":2,"alphaCells":3,"comSize":4,"x":10,"location":7,"row":2,"coords":5,"attempts":2},"constants":{"0":9,"1":3,"2":1,"200":1,"null":1,"false":4,"true":1},"javaDoc":"","comments":"end while System out println(\"\\n\"); line 19 holds 'f6' type coords temporary String for concat current candidate coords current attempts counter flag = found a good location ? current starting location nth dot com to place set horizontal increment if odd dot com (place vertically) set vertical increment main search loop (32) System out print(\" try \" + location); get random starting point nth position in dotcom to place assume success look for adjacent unused spots if not already used save location try 'next' adjacent out of bounds - 'bottom' failure out of bounds - right edge failure found already used location System out print(\" used \" + location); failure turn good location into alpha coords System out println(\"\\n\"); System out print(\" coord \"+x+\" = \" + alphaCells get(x-1)); mark master grid pts as 'used' get row value get numeric column value convert to alpha ","isEmpty":false,"hasInnerClass":false,"lineCount":18,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new BeatBox().buildGUI();\n}\n","name":"main","className":"BeatBox","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":11,"setVisible":1,"setSelected":1,"createEmptyBorder":1,"addActionListener":4,"getContentPane":1,"setBounds":1,"pack":1,"setVgap":1,"setBorder":1,"setDefaultCloseOperation":1,"setHgap":1,"setUpMidi":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JCheckBox":1,"JPanel":1,"GridLayout":1,"BorderLayout":1,"JButton":4,"Box":2,"int":2},"expressions":{"ObjectCreationExpr":18,"IntegerLiteralExpr":16,"VariableDeclarationExpr":12,"ArrayAccessExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":115,"StringLiteralExpr":5,"FieldAccessExpr":6,"UnaryExpr":2,"AssignExpr":3,"MethodCallExpr":26},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":37},"text":"public void buildGUI() {\n    theFrame = new JFrame(\"Cyber BeatBox\");\n    theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    BorderLayout layout = new BorderLayout();\n    JPanel background = new JPanel(layout);\n    background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n    checkboxList = new ArrayList<JCheckBox>();\n    Box buttonBox = new Box(BoxLayout.Y_AXIS);\n    JButton start = new JButton(\"Start\");\n    start.addActionListener(new MyStartListener());\n    buttonBox.add(start);\n    JButton stop = new JButton(\"Stop\");\n    stop.addActionListener(new MyStopListener());\n    buttonBox.add(stop);\n    JButton upTempo = new JButton(\"Tempo Up\");\n    upTempo.addActionListener(new MyUpTempoListener());\n    buttonBox.add(upTempo);\n    JButton downTempo = new JButton(\"Tempo Down\");\n    downTempo.addActionListener(new MyDownTempoListener());\n    buttonBox.add(downTempo);\n    Box nameBox = new Box(BoxLayout.Y_AXIS);\n    for (int i = 0; i < 16; i++) {\n        nameBox.add(new Label(instrumentNames[i]));\n    }\n    background.add(BorderLayout.EAST, buttonBox);\n    background.add(BorderLayout.WEST, nameBox);\n    theFrame.getContentPane().add(background);\n    GridLayout grid = new GridLayout(16, 16);\n    grid.setVgap(1);\n    grid.setHgap(2);\n    mainPanel = new JPanel(grid);\n    background.add(BorderLayout.CENTER, mainPanel);\n    for (int i = 0; i < 256; i++) {\n        JCheckBox c = new JCheckBox();\n        c.setSelected(false);\n        checkboxList.add(c);\n        mainPanel.add(c);\n    }\n    // end loop\n    setUpMidi();\n    theFrame.setBounds(50, 50, 300, 300);\n    theFrame.pack();\n    theFrame.setVisible(true);\n}\n","name":"buildGUI","className":"BeatBox","variables":{"BorderFactory":1,"instrumentNames":1,"nameBox":2,"c":2,"theFrame":6,"mainPanel":2,"upTempo":2,"start":2,"buttonBox":5,"i":7,"layout":2,"checkboxList":2,"stop":2,"background":5,"grid":4,"downTempo":2},"constants":{"\"Start\"":1,"16":3,"false":1,"0":2,"\"Cyber BeatBox\"":1,"1":1,"\"Stop\"":1,"2":1,"256":1,"300":2,"true":1,"50":2,"\"Tempo Down\"":1,"\"Tempo Up\"":1,"10":4},"javaDoc":"","comments":"end loop ","isEmpty":false,"hasInnerClass":false,"lineCount":35,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSequencer":1,"printStackTrace":1,"setTempoInBPM":1,"createTrack":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"NameExpr":21,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"// close method\npublic void setUpMidi() {\n    try {\n        sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        sequence = new Sequence(Sequence.PPQ, 4);\n        track = sequence.createTrack();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"setUpMidi","className":"BeatBox","variables":{"sequence":2,"e":2,"track":1,"MidiSystem":1,"sequencer":3},"constants":{"4":1,"120":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"setSequence":1,"setLoopCount":1,"makeEvent":2,"printStackTrace":1,"deleteTrack":1,"setTempoInBPM":1,"createTrack":1,"get":1,"makeTracks":1,"isSelected":1,"start":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"JCheckBox":1,"int[]":1,"int":3},"expressions":{"IntegerLiteralExpr":18,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":4,"NameExpr":60,"UnaryExpr":2,"AssignExpr":4,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":14},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":1,"ForStmt":2,"ExpressionStmt":16},"text":"// close method\npublic void buildTrackAndStart() {\n    int[] trackList = null;\n    sequence.deleteTrack(track);\n    track = sequence.createTrack();\n    for (int i = 0; i < 16; i++) {\n        trackList = new int[16];\n        int key = instruments[i];\n        for (int j = 0; j < 16; j++) {\n            JCheckBox jc = (JCheckBox) checkboxList.get(j + (16 * i));\n            if (jc.isSelected()) {\n                trackList[j] = key;\n            } else {\n                trackList[j] = 0;\n            }\n        }\n        // close inner loop\n        makeTracks(trackList);\n        track.add(makeEvent(176, 1, 127, 0, 16));\n    }\n    // close outer\n    track.add(makeEvent(192, 9, 1, 0, 15));\n    try {\n        sequencer.setSequence(sequence);\n        sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);\n        sequencer.start();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"buildTrackAndStart","className":"BeatBox","variables":{"sequence":2,"instruments":1,"checkboxList":1,"trackList":4,"e":2,"i":5,"jc":2,"j":6,"track":3,"key":2,"sequencer":4},"constants":{"0":5,"176":1,"1":2,"null":1,"15":1,"16":5,"127":1,"9":1,"192":1,"120":1},"javaDoc":"","comments":"close outer close inner loop ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"buildTrackAndStart":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    buildTrackAndStart();\n}\n","name":"actionPerformed","className":"MyStartListener","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"stop":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    sequencer.stop();\n}\n","name":"actionPerformed","className":"MyStopListener","variables":{"sequencer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * 1.03));\n}\n","name":"actionPerformed","className":"MyUpTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{"1.03":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * .97));\n}\n","name":"actionPerformed","className":"MyDownTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{".97":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"add":2,"makeEvent":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":19,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"// close inner class\npublic void makeTracks(int[] list) {\n    for (int i = 0; i < 16; i++) {\n        int key = list[i];\n        if (key != 0) {\n            track.add(makeEvent(144, 9, key, 100, i));\n            track.add(makeEvent(128, 9, key, 100, i + 1));\n        }\n    }\n}\n","name":"makeTracks","className":"BeatBox","variables":{"i":5,"list":1,"track":2,"key":2},"constants":{"0":2,"144":1,"100":2,"1":1,"16":1,"128":1,"9":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"MidiEvent","methodCalls":{"printStackTrace":1,"setMessage":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"ShortMessage":1,"MidiEvent":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":14,"MethodCallExpr":2,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {\n    MidiEvent event = null;\n    try {\n        ShortMessage a = new ShortMessage();\n        a.setMessage(comd, chan, one, two);\n        event = new MidiEvent(a, tick);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return event;\n}\n","name":"makeEvent","className":"BeatBox","variables":{"a":3,"e":2,"tick":1,"event":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new BeatBoxFinal().startUp(args[0]);\n}\n","name":"main","className":"BeatBoxFinal","variables":{"args":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"buildGUI":1,"start":1,"getOutputStream":1,"setUpMidi":1,"getInputStream":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Socket":1,"Thread":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":9},"text":"public void startUp(String name) {\n    userName = name;\n    try {\n        Socket sock = new Socket(\"127.0.0.1\", 4242);\n        out = new ObjectOutputStream(sock.getOutputStream());\n        in = new ObjectInputStream(sock.getInputStream());\n        Thread remote = new Thread(new RemoteReader());\n        remote.start();\n    } catch (Exception ex) {\n        System.out.println(\"couldn't connect - you'll have to play alone.\");\n    }\n    setUpMidi();\n    buildGUI();\n}\n","name":"startUp","className":"BeatBoxFinal","variables":{"sock":3,"ex":1,"in":1,"name":1,"userName":1,"remote":2,"out":1},"constants":{"4242":1,"\"127.0.0.1\"":1,"\"couldn't connect - you'll have to play alone.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":15,"addListSelectionListener":1,"setVisible":1,"setSelected":1,"createEmptyBorder":1,"addActionListener":6,"getContentPane":1,"setSelectionMode":1,"setListData":1,"setBounds":1,"pack":1,"setVgap":1,"setBorder":1,"setDefaultCloseOperation":1,"setHgap":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JScrollPane":1,"JCheckBox":1,"JPanel":1,"GridLayout":1,"BorderLayout":1,"JButton":6,"Box":2,"int":2},"expressions":{"ObjectCreationExpr":26,"IntegerLiteralExpr":16,"VariableDeclarationExpr":15,"ArrayAccessExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":151,"StringLiteralExpr":7,"FieldAccessExpr":7,"UnaryExpr":2,"AssignExpr":5,"MethodCallExpr":34},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":50},"text":"public void buildGUI() {\n    theFrame = new JFrame(\"Cyber BeatBox\");\n    theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    BorderLayout layout = new BorderLayout();\n    JPanel background = new JPanel(layout);\n    background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n    checkboxList = new ArrayList<JCheckBox>();\n    Box buttonBox = new Box(BoxLayout.Y_AXIS);\n    JButton start = new JButton(\"Start\");\n    start.addActionListener(new MyStartListener());\n    buttonBox.add(start);\n    JButton stop = new JButton(\"Stop\");\n    stop.addActionListener(new MyStopListener());\n    buttonBox.add(stop);\n    JButton upTempo = new JButton(\"Tempo Up\");\n    upTempo.addActionListener(new MyUpTempoListener());\n    buttonBox.add(upTempo);\n    JButton downTempo = new JButton(\"Tempo Down\");\n    downTempo.addActionListener(new MyDownTempoListener());\n    buttonBox.add(downTempo);\n    JButton sendIt = new JButton(\"sendIt\");\n    sendIt.addActionListener(new MySendListener());\n    buttonBox.add(sendIt);\n    // new button\n    JButton saveIt = new JButton(\"Serialize It\");\n    saveIt.addActionListener(new MySendListener());\n    buttonBox.add(saveIt);\n    userMessage = new JTextField();\n    buttonBox.add(userMessage);\n    incomingList = new JList();\n    incomingList.addListSelectionListener(new MyListSelectionListener());\n    incomingList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    JScrollPane theList = new JScrollPane(incomingList);\n    buttonBox.add(theList);\n    incomingList.setListData(listVector);\n    Box nameBox = new Box(BoxLayout.Y_AXIS);\n    for (int i = 0; i < 16; i++) {\n        nameBox.add(new Label(instrumentNames[i]));\n    }\n    background.add(BorderLayout.EAST, buttonBox);\n    background.add(BorderLayout.WEST, nameBox);\n    theFrame.getContentPane().add(background);\n    GridLayout grid = new GridLayout(16, 16);\n    grid.setVgap(1);\n    grid.setHgap(2);\n    mainPanel = new JPanel(grid);\n    background.add(BorderLayout.CENTER, mainPanel);\n    for (int i = 0; i < 256; i++) {\n        JCheckBox c = new JCheckBox();\n        c.setSelected(false);\n        checkboxList.add(c);\n        mainPanel.add(c);\n    }\n    // end loop\n    theFrame.setBounds(50, 50, 300, 300);\n    theFrame.pack();\n    theFrame.setVisible(true);\n}\n","name":"buildGUI","className":"BeatBoxFinal","variables":{"BorderFactory":1,"instrumentNames":1,"nameBox":2,"saveIt":2,"incomingList":5,"c":2,"theFrame":6,"mainPanel":2,"upTempo":2,"start":2,"buttonBox":9,"i":7,"layout":2,"userMessage":1,"theList":1,"sendIt":2,"checkboxList":2,"stop":2,"background":5,"grid":4,"downTempo":2},"constants":{"\"Start\"":1,"16":3,"\"sendIt\"":1,"false":1,"0":2,"\"Cyber BeatBox\"":1,"1":1,"\"Stop\"":1,"2":1,"\"Serialize It\"":1,"256":1,"300":2,"true":1,"50":2,"\"Tempo Down\"":1,"\"Tempo Up\"":1,"10":4},"javaDoc":"","comments":"end loop new button ","isEmpty":false,"hasInnerClass":false,"lineCount":48,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSequencer":1,"printStackTrace":1,"setTempoInBPM":1,"createTrack":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"NameExpr":21,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"// close method\npublic void setUpMidi() {\n    try {\n        sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        // sequencer.addMetaEventListener(this);\n        sequence = new Sequence(Sequence.PPQ, 4);\n        track = sequence.createTrack();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"setUpMidi","className":"BeatBoxFinal","variables":{"sequence":2,"e":2,"track":1,"MidiSystem":1,"sequencer":3},"constants":{"4":1,"120":1},"javaDoc":"","comments":"sequencer addMetaEventListener(this); ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3,"setSequence":1,"setLoopCount":1,"makeEvent":1,"printStackTrace":1,"deleteTrack":1,"setTempoInBPM":1,"createTrack":1,"get":1,"makeTracks":1,"isSelected":1,"start":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"JCheckBox":1,"ArrayList<Integer>":1,"int":3},"expressions":{"IntegerLiteralExpr":11,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":57,"UnaryExpr":2,"AssignExpr":2,"NullLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":14},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":1,"ForStmt":2,"ExpressionStmt":15},"text":"// close method\npublic void buildTrackAndStart() {\n    // this will hold the instruments for each vertical column,\n    // in other words, each tick (may have multiple instruments)\n    ArrayList<Integer> trackList = null;\n    sequence.deleteTrack(track);\n    track = sequence.createTrack();\n    for (int i = 0; i < 16; i++) {\n        trackList = new ArrayList<Integer>();\n        for (int j = 0; j < 16; j++) {\n            JCheckBox jc = (JCheckBox) checkboxList.get(j + (16 * i));\n            if (jc.isSelected()) {\n                int key = instruments[i];\n                trackList.add(key);\n            } else {\n                trackList.add(null);\n            }\n        }\n        // close inner\n        makeTracks(trackList);\n    }\n    // close outer\n    // - so we always go to full 16 beats\n    track.add(makeEvent(192, 9, 1, 0, 15));\n    try {\n        sequencer.setSequence(sequence);\n        sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);\n        sequencer.start();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"buildTrackAndStart","className":"BeatBoxFinal","variables":{"sequence":2,"instruments":1,"checkboxList":1,"trackList":4,"e":2,"i":5,"jc":2,"j":4,"track":2,"key":1,"sequencer":4},"constants":{"0":3,"1":1,"null":2,"15":1,"16":3,"9":1,"192":1,"120":1},"javaDoc":"","comments":"this will hold the instruments for each vertical column close outer in other words each tick (may have multiple instruments) close inner - so we always go to full 16 beats ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"buildTrackAndStart":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    buildTrackAndStart();\n}\n","name":"actionPerformed","className":"MyStartListener","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"stop":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    sequencer.stop();\n}\n","name":"actionPerformed","className":"MyStopListener","variables":{"sequencer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * 1.03));\n}\n","name":"actionPerformed","className":"MyUpTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{"1.03":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * .97));\n}\n","name":"actionPerformed","className":"MyDownTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{".97":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"printStackTrace":1,"writeObject":2,"getText":1,"get":1,"isSelected":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"JCheckBox":1,"boolean[]":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":31,"StringLiteralExpr":2,"UnaryExpr":2,"AssignExpr":1,"BooleanLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public void actionPerformed(ActionEvent a) {\n    // make an arraylist of just the STATE of the checkboxes\n    boolean[] checkboxState = new boolean[256];\n    for (int i = 0; i < 256; i++) {\n        JCheckBox check = (JCheckBox) checkboxList.get(i);\n        if (check.isSelected()) {\n            checkboxState[i] = true;\n        }\n    }\n    try {\n        out.writeObject(userName + nextNum++ + \": \" + userMessage.getText());\n        out.writeObject(checkboxState);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n        System.out.println(\"sorry dude. Could not send it to the server\");\n    }\n}\n","name":"actionPerformed","className":"MySendListener","variables":{"userMessage":1,"ex":2,"checkboxList":1,"nextNum":1,"checkboxState":2,"i":4,"check":2,"userName":1,"out":2},"constants":{"0":1,"256":2,"\"sorry dude. Could not send it to the server\"":1,"true":1,"\": \"":1},"javaDoc":"","comments":"make an arraylist of just the STATE of the checkboxes ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ListSelectionEvent"],"returnType":"void","methodCalls":{"buildTrackAndStart":1,"stop":1,"get":1,"getSelectedValue":1,"changeSequence":1,"getValueIsAdjusting":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"String":1,"boolean[]":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":19,"CastExpr":2,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":5},"text":"public void valueChanged(ListSelectionEvent le) {\n    if (!le.getValueIsAdjusting()) {\n        String selected = (String) incomingList.getSelectedValue();\n        if (selected != null) {\n            boolean[] selectedState = (boolean[]) otherSeqsMap.get(selected);\n            changeSequence(selectedState);\n            sequencer.stop();\n            buildTrackAndStart();\n        }\n    }\n}\n","name":"valueChanged","className":"MyListSelectionListener","variables":{"incomingList":1,"otherSeqsMap":1,"le":1,"selected":2,"selectedState":1,"sequencer":1},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"getClass":1,"printStackTrace":1,"setListData":1,"put":1,"readObject":2,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":38,"StringLiteralExpr":1,"CastExpr":2,"FieldAccessExpr":2,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":9},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public void run() {\n    try {\n        while ((obj = in.readObject()) != null) {\n            System.out.println(\"got an object from server\");\n            System.out.println(obj.getClass());\n            String nameToShow = (String) obj;\n            checkboxState = (boolean[]) in.readObject();\n            otherSeqsMap.put(nameToShow, checkboxState);\n            listVector.add(nameToShow);\n            incomingList.setListData(listVector);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"run","className":"RemoteReader","variables":{"incomingList":1,"in":2,"e":2,"obj":3,"otherSeqsMap":1,"listVector":1,"checkboxState":1,"nameToShow":1},"constants":{"null":1,"\"got an object from server\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["boolean[]"],"returnType":"void","methodCalls":{"setSelected":2,"get":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"JCheckBox":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":14,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":3},"text":"//==============================================================       \npublic void changeSequence(boolean[] checkboxState) {\n    for (int i = 0; i < 256; i++) {\n        JCheckBox check = (JCheckBox) checkboxList.get(i);\n        if (checkboxState[i]) {\n            check.setSelected(true);\n        } else {\n            check.setSelected(false);\n        }\n    }\n}\n","name":"changeSequence","className":"BeatBoxFinal","variables":{"checkboxList":1,"checkboxState":1,"i":4,"check":3},"constants":{"0":1,"256":1,"true":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ArrayList<Integer>"],"returnType":"void","methodCalls":{"next":1,"add":2,"makeEvent":2,"iterator":1,"intValue":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Integer":1,"Iterator":1,"int":2},"expressions":{"IntegerLiteralExpr":9,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":26,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"public void makeTracks(ArrayList<Integer> list) {\n    Iterator it = list.iterator();\n    for (int i = 0; i < 16; i++) {\n        Integer num = (Integer) it.next();\n        if (num != null) {\n            int numKey = num.intValue();\n            track.add(makeEvent(144, 9, numKey, 100, i));\n            track.add(makeEvent(128, 9, numKey, 100, i + 1));\n        }\n    }\n}\n","name":"makeTracks","className":"BeatBoxFinal","variables":{"numKey":1,"num":3,"i":4,"it":2,"list":1,"track":2},"constants":{"0":1,"144":1,"100":2,"1":1,"null":1,"16":1,"128":1,"9":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"MidiEvent","methodCalls":{"setMessage":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"ShortMessage":1,"MidiEvent":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":1,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {\n    MidiEvent event = null;\n    try {\n        ShortMessage a = new ShortMessage();\n        a.setMessage(comd, chan, one, two);\n        event = new MidiEvent(a, tick);\n    } catch (Exception e) {\n    }\n    return event;\n}\n","name":"makeEvent","className":"BeatBoxFinal","variables":{"a":3,"e":1,"tick":1,"event":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new MusicServer().go();\n}\n","name":"main","className":"MusicServer","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["Socket"],"returnType":"ClientHandler","methodCalls":{"printStackTrace":1,"getInputStream":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":9,"AssignExpr":2,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public ClientHandler(Socket clientSOcket) {\n    try {\n        sock = clientSOcket;\n        in = new ObjectInputStream(sock.getInputStream());\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"ClientHandler","className":"ClientHandler","variables":{"sock":2,"ex":2,"clientSOcket":1,"in":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"tellEveryone":1,"printStackTrace":1,"readObject":2,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Object":2},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":5},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":6},"text":"public void run() {\n    Object o1;\n    Object o2;\n    try {\n        while ((o1 = in.readObject()) != null) {\n            o2 = in.readObject();\n            System.out.println(\"read two objects\");\n            tellEveryone(o1, o2);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"run","className":"ClientHandler","variables":{"o1":2,"o2":2,"ex":2,"in":2},"constants":{"null":1,"\"read two objects\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"printStackTrace":1,"start":1,"getOutputStream":1,"accept":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"ServerSocket":1,"ObjectOutputStream":1,"Socket":1,"Thread":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public void go() {\n    clientOutputStreams = new ArrayList();\n    try {\n        ServerSocket serverSock = new ServerSocket(4242);\n        while (true) {\n            Socket clientSocket = serverSock.accept();\n            ObjectOutputStream out = new ObjectOutputStream(clientSocket.getOutputStream());\n            clientOutputStreams.add(out);\n            Thread t = new Thread(new ClientHandler(clientSocket));\n            t.start();\n            System.out.println(\"got a connection\");\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"go","className":"MusicServer","variables":{"clientSocket":3,"ex":2,"t":2,"clientOutputStreams":2,"serverSock":2,"out":1},"constants":{"4242":1,"true":1,"\"got a connection\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"printStackTrace":1,"writeObject":2,"hasNext":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"Iterator":1,"ObjectOutputStream":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":20,"CastExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":5},"text":"public void tellEveryone(Object one, Object two) {\n    Iterator it = clientOutputStreams.iterator();\n    while (it.hasNext()) {\n        try {\n            ObjectOutputStream out = (ObjectOutputStream) it.next();\n            out.writeObject(one);\n            out.writeObject(two);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n","name":"tellEveryone","className":"MusicServer","variables":{"ex":2,"clientOutputStreams":1,"it":3,"out":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"println":1,"set":1,"setTimeInMillis":1,"getTimeInMillis":1,"format":1,"getInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Calendar":1,"long":1,"int":1},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":3,"DoubleLiteralExpr":1,"BinaryExpr":2,"NameExpr":24,"StringLiteralExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":6,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Calendar c = Calendar.getInstance();\n    c.set(2004, 0, 7, 15, 40);\n    long day1 = c.getTimeInMillis();\n    for (int x = 0; x < 60; x++) {\n        //TODO: added this last semi-colon\n        day1 += (DAY_IM * 29.52);\n        c.setTimeInMillis(day1);\n        out.println(String.format(\"full moon on %tc\", c));\n    }\n}\n","name":"main","className":"FullMoons","variables":{"DAY_IM":1,"c":4,"Calendar":1,"x":3,"day1":2,"String":1,"out":1},"constants":{"0":2,"\"full moon on %tc\"":1,"15":1,"2004":1,"7":1,"60":1,"40":1,"29.52":1},"javaDoc":"","comments":"TODO: added this last semi-colon ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"RetentionBot":1,"V3Radiator":1,"V2Radiator":1,"ArrayList":1,"Object":1,"int":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":3,"VariableDeclarationExpr":7,"BinaryExpr":2,"NameExpr":16,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":2,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    ArrayList aList = new ArrayList();\n    V2Radiator v2 = new V2Radiator(aList);\n    V3Radiator v3 = new V3Radiator(aList);\n    for (int z = 0; z < 20; z++) {\n        RetentionBot ret = new RetentionBot(aList);\n    }\n    //adding this to make sure the power is correct:\n    int totalPower = 0;\n    for (Object o : aList) {\n        totalPower += ((SimUnit) o).powerUse();\n    }\n    System.out.println(\"Total power: \" + totalPower);\n}\n","name":"main","className":"TestLifeSupportSim","variables":{"ret":1,"aList":5,"z":3,"v2":1,"v3":1,"totalPower":3,"o":2},"constants":{"0":2,"\"Total power: \"":1,"20":1},"javaDoc":"","comments":"adding this to make sure the power is correct: ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["ArrayList"],"returnType":"V2Radiator","methodCalls":{"add":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"V2Radiator(ArrayList list) {\n    System.out.println(\"making a v2 radiator\");\n    for (int x = 0; x < 5; x++) {\n        list.add(new SimUnit(\"V2Radiator\"));\n    }\n}\n","name":"V2Radiator","className":"V2Radiator","variables":{"x":3,"list":1},"constants":{"0":1,"\"V2Radiator\"":1,"\"making a v2 radiator\"":1,"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":0}
{"paramTypes":["ArrayList"],"returnType":"V3Radiator","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"V3Radiator(ArrayList list) {\n    super(list);\n    for (int g = 0; g < 10; g++) {\n        list.add(new SimUnit(\"V3Radiator\"));\n    }\n}\n","name":"V3Radiator","className":"V3Radiator","variables":{"g":3,"list":2},"constants":{"0":1,"\"V3Radiator\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":0}
{"paramTypes":["ArrayList"],"returnType":"RetentionBot","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"RetentionBot(ArrayList rlist) {\n    rlist.add(new SimUnit(\"Retention\"));\n}\n","name":"RetentionBot","className":"RetentionBot","variables":{"rlist":1},"constants":{"\"Retention\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["String"],"returnType":"SimUnit","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"SimUnit(String type) {\n    botType = type;\n}\n","name":"SimUnit","className":"SimUnit","variables":{"botType":1,"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"StringLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"int powerUse() {\n    if (\"Retention\".equals(botType)) {\n        return 2;\n    } else {\n        return 4;\n    }\n}\n","name":"powerUse","className":"SimUnit","variables":{},"constants":{"2":1,"4":1,"\"Retention\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setLength":1,"move":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Sailboat":1,"Rowboat":1,"Boat":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":12,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Boat b1 = new Boat();\n    Sailboat b2 = new Sailboat();\n    Rowboat b3 = new Rowboat();\n    b2.setLength(32);\n    b1.move();\n    b3.move();\n    b2.move();\n}\n","name":"main","className":"TestBoat","variables":{"b2":3,"b3":2,"b1":2},"constants":{"32":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setLength(int len) {\n    length = len;\n}\n","name":"setLength","className":"Boat","variables":{"len":1,"length":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getLength() {\n    return length;\n}\n","name":"getLength","className":"Boat","variables":{"length":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void move() {\n    System.out.print(\"drift \");\n}\n","name":"move","className":"Boat","variables":{},"constants":{"\"drift \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void rowTheBoat() {\n    System.out.print(\"stroke natasha\");\n}\n","name":"rowTheBoat","className":"Rowboat","variables":{},"constants":{"\"stroke natasha\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void move() {\n    System.out.print(\"hoist sail \");\n}\n","name":"move","className":"Sailboat","variables":{},"constants":{"\"hoist sail \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"BinaryExpr":13,"StringLiteralExpr":11,"NameExpr":42,"FieldAccessExpr":6,"AssignExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    int beerNum = 99;\n    String word = \"bottles\";\n    while (beerNum > 0) {\n        if (beerNum == 1) {\n            word = \"bottle\";\n        }\n        System.out.println(beerNum + \" \" + word + \" of beer on the wall\");\n        System.out.println(beerNum + \" \" + word + \" of beer\");\n        System.out.println(\"Take one down.\");\n        System.out.println(\"Pass it around.\");\n        beerNum = beerNum - 1;\n        if (beerNum > 0) {\n            System.out.println(beerNum + \" \" + word + \" of beer on the wall\");\n        } else {\n            System.out.println(\"No more bottles of beer on the wall\");\n        }\n    }\n}\n","name":"main","className":"BeerSong","variables":{"beerNum":9,"word":5},"constants":{"99":1,"0":2,"1":2,"\"bottles\"":1,"\" \"":3,"\"No more bottles of beer on the wall\"":1,"\"bottle\"":1,"\"Take one down.\"":1,"\"Pass it around.\"":1,"\" of beer on the wall\"":2,"\" of beer\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":3,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"String[]":3,"String":1,"int":6},"expressions":{"VariableDeclarationExpr":10,"ArrayInitializerExpr":3,"ArrayAccessExpr":3,"BinaryExpr":8,"StringLiteralExpr":45,"NameExpr":33,"CastExpr":3,"FieldAccessExpr":4,"EnclosedExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    String[] wordListOne = { \"24/7\", \"multi-Tier\", \"30,000 foot\", \"B-to-B\", \"win-win\", \"front-end\", \"web-based\", \"pervasive\", \"smart\", \"six-sigma\", \"critical-path\", \"dynamic\" };\n    String[] wordListTwo = { \"empowered\", \"sticky\", \"value-added\", \"oriented\", \"centric\", \"distributed\", \"clustered\", \"branded\", \"outside-the-box\", \"positioned\", \"networked\", \"focused\", \"leveraged\", \"aligned\", \"targeted\", \"shared\", \"cooperative\", \"accelerated\" };\n    String[] wordListThree = { \"process\", \"tipping-point\", \"solution\", \"architecture\", \"core competency\", \"strategy\", \"mindshare\", \"portal\", \"space\", \"vision\", \"paradigm\", \"mission\" };\n    int oneLength = wordListOne.length;\n    int twoLength = wordListTwo.length;\n    int threeLength = wordListThree.length;\n    int rand1 = (int) (Math.random() * oneLength);\n    int rand2 = (int) (Math.random() * twoLength);\n    int rand3 = (int) (Math.random() * threeLength);\n    String phrase = wordListOne[rand1] + \" \" + wordListTwo[rand2] + \" \" + wordListThree[rand3];\n    System.out.println(\"What we need is a \" + phrase);\n}\n","name":"main","className":"PhraseOMatic","variables":{"wordListTwo":2,"wordListThree":2,"phrase":2,"twoLength":2,"rand1":2,"wordListOne":2,"oneLength":2,"rand2":2,"rand3":2,"threeLength":2,"Math":3},"constants":{"\"accelerated\"":1,"\"strategy\"":1,"\"networked\"":1,"\"sticky\"":1,"\"24/7\"":1,"\"branded\"":1,"\"mission\"":1,"\"multi-Tier\"":1,"\"focused\"":1,"\"space\"":1,"\"paradigm\"":1,"\"value-added\"":1,"\"process\"":1,"\"tipping-point\"":1,"\"cooperative\"":1,"\"solution\"":1,"\"mindshare\"":1,"\"portal\"":1,"\"positioned\"":1,"\"leveraged\"":1,"\"empowered\"":1,"\"vision\"":1,"\"six-sigma\"":1,"\"oriented\"":1,"\"shared\"":1,"\"smart\"":1,"\" \"":2,"\"front-end\"":1,"\"pervasive\"":1,"\"B-to-B\"":1,"\"30,000 foot\"":1,"\"What we need is a \"":1,"\"outside-the-box\"":1,"\"centric\"":1,"\"win-win\"":1,"\"distributed\"":1,"\"targeted\"":1,"\"aligned\"":1,"\"dynamic\"":1,"\"architecture\"":1,"\"clustered\"":1,"\"core competency\"":1,"\"critical-path\"":1,"\"web-based\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":2,"play":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MiniMiniMusicCmdLine":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":21,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    MiniMiniMusicCmdLine mini = new MiniMiniMusicCmdLine();\n    if (args.length < 2) {\n        System.out.println(\"Don't forget the instrument and note args\");\n    } else {\n        int instrument = Integer.parseInt(args[0]);\n        int note = Integer.parseInt(args[1]);\n        mini.play(instrument, note);\n    }\n}\n","name":"main","className":"MiniMiniMusicCmdLine","variables":{"Integer":2,"args":2,"note":1,"mini":2,"instrument":1},"constants":{"0":1,"1":1,"2":1,"\"Don't forget the instrument and note args\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"getSequencer":1,"add":3,"setSequence":1,"sleep":1,"exit":1,"printStackTrace":1,"createTrack":1,"start":1,"setMessage":3,"close":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Sequencer":1,"ShortMessage":3,"MidiEvent":4,"Sequence":1,"Track":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":15,"NullLiteralExpr":1,"VariableDeclarationExpr":10,"NameExpr":58,"FieldAccessExpr":1,"MethodCallExpr":15},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":23},"text":"public void play(int instrument, int note) {\n    try {\n        Sequencer player = MidiSystem.getSequencer();\n        player.open();\n        Sequence seq = new Sequence(Sequence.PPQ, 4);\n        Track track = seq.createTrack();\n        MidiEvent event = null;\n        ShortMessage first = new ShortMessage();\n        first.setMessage(192, 1, instrument, 0);\n        MidiEvent changeInstrument = new MidiEvent(first, 1);\n        track.add(changeInstrument);\n        ShortMessage a = new ShortMessage();\n        a.setMessage(144, 1, note, 100);\n        MidiEvent noteOn = new MidiEvent(a, 1);\n        track.add(noteOn);\n        ShortMessage b = new ShortMessage();\n        b.setMessage(128, 1, note, 100);\n        MidiEvent noteOff = new MidiEvent(b, 16);\n        track.add(noteOff);\n        player.setSequence(seq);\n        player.start();\n        // new\n        Thread.sleep(5000);\n        player.close();\n        System.exit(0);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"play","className":"MiniMiniMusicCmdLine","variables":{"a":3,"changeInstrument":1,"b":3,"System":1,"Thread":1,"ex":2,"noteOff":1,"noteOn":1,"track":4,"event":1,"MidiSystem":1,"seq":2,"first":3,"player":5},"constants":{"0":2,"1":5,"144":1,"100":2,"5000":1,"4":1,"null":1,"16":1,"128":1,"192":1},"javaDoc":"","comments":"new ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"play":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MiniMiniMusicApp":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    MiniMiniMusicApp mini = new MiniMiniMusicApp();\n    mini.play();\n}\n","name":"main","className":"MiniMiniMusicApp","variables":{"mini":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSequencer":1,"add":2,"setSequence":1,"sleep":1,"exit":1,"printStackTrace":1,"createTrack":1,"start":1,"setMessage":2,"close":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Sequencer":1,"ShortMessage":2,"MidiEvent":3,"Sequence":1,"Track":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":13,"NullLiteralExpr":1,"VariableDeclarationExpr":8,"NameExpr":47,"FieldAccessExpr":1,"MethodCallExpr":13},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":19},"text":"public void play() {\n    try {\n        // make (and open) a sequencer, make a sequence and track\n        Sequencer sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        Sequence seq = new Sequence(Sequence.PPQ, 4);\n        Track track = seq.createTrack();\n        // now make two midi events (containing a midi message)\n        MidiEvent event = null;\n        // first make the message\n        // then stick the message into a midi event \n        // and add the event to the track\n        ShortMessage a = new ShortMessage();\n        a.setMessage(144, 1, 44, 100);\n        // <-- means at tick one, the above event happens\n        MidiEvent noteOn = new MidiEvent(a, 1);\n        track.add(noteOn);\n        ShortMessage b = new ShortMessage();\n        b.setMessage(128, 1, 44, 100);\n        // <-- means at tick one, the above event happens\n        MidiEvent noteOff = new MidiEvent(b, 16);\n        track.add(noteOff);\n        // add the events to the track\n        // add the sequence to the sequencer, set timing, and start\n        sequencer.setSequence(seq);\n        sequencer.start();\n        // new\n        Thread.sleep(1000);\n        sequencer.close();\n        System.exit(0);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"play","className":"MiniMiniMusicApp","variables":{"a":3,"b":3,"ex":2,"noteOff":1,"noteOn":1,"track":3,"event":1,"MidiSystem":1,"seq":2,"System":1,"sequencer":5,"Thread":1},"constants":{"44":2,"0":1,"144":1,"1":3,"100":2,"4":1,"null":1,"16":1,"128":1,"1000":1},"javaDoc":"","comments":"make (and open) a sequencer make a sequence and track first make the message then stick the message into a midi event and add the event to the track add the events to the track now make two midi events (containing a midi message) <-- means at tick one the above event happens <-- means at tick one the above event happens add the sequence to the sequencer set timing and start new ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getFirst":1,"getSecond":1,"firstContaining":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"Pair<String, Integer>":1},"expressions":{"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"StringLiteralExpr":6,"NameExpr":29,"FieldAccessExpr":4,"MethodCallExpr":7},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    String[] names = { \"Tom\", \"Diana\", \"Harry\" };\n    Pair<String, Integer> result = firstContaining(names, \"a\");\n    System.out.println(result.getFirst());\n    System.out.println(\"Expected: Diana\");\n    System.out.println(result.getSecond());\n    System.out.println(\"Expected: 1\");\n}\n","name":"main","className":"PairDemo","variables":{"result":3,"names":1},"constants":{"\"a\"":1,"\"Tom\"":1,"\"Expected: Diana\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Expected: 1\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]","String"],"returnType":"Pair<String, Integer>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"UnaryExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2},"text":"/**\n      Gets the first String containing a given string, together \n      with its index.\n      @param strings an array of strings\n      @param sub a string\n      @return a pair (strings[i], i) where strings[i] is the first \n      strings[i] containing str, or a pair (null, -1) if there is no\n      match.\n   */\npublic static Pair<String, Integer> firstContaining(String[] strings, String sub) {\n    for (int i = 0; i < strings.length; i++) {\n        if (strings[i].contains(sub)) {\n            return new Pair<>(strings[i], i);\n        }\n    }\n    return new Pair<>(null, -1);\n}\n","name":"firstContaining","className":"PairDemo","variables":{"strings":2,"i":6},"constants":{"0":1,"1":1,"null":1},"javaDoc":"Gets the first String containing a given string together with its index strings an array of strings sub a string a pair (strings[i] i) where strings[i] is the first strings[i] containing str or a pair (null -1) if there is no match","comments":"\n      Gets the first String containing a given string, together \n      with its index.\n      @param strings an array of strings\n      @param sub a string\n      @return a pair (strings[i], i) where strings[i] is the first \n      strings[i] containing str, or a pair (null, -1) if there is no\n      match.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["T","S"],"returnType":"Pair","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a pair containing two given elements.\n      @param firstElement the first element\n      @param secondElement the second element\n   */\npublic Pair(T firstElement, S secondElement) {\n    first = firstElement;\n    second = secondElement;\n}\n","name":"Pair","className":"Pair","variables":{"firstElement":1,"secondElement":1,"first":1,"second":1},"constants":{},"javaDoc":"Constructs a pair containing two given elements firstElement the first element secondElement the second element","comments":"\n      Constructs a pair containing two given elements.\n      @param firstElement the first element\n      @param secondElement the second element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"T","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the first element of this pair.\n      @return the first element\n   */\npublic T getFirst() {\n    return first;\n}\n","name":"getFirst","className":"Pair","variables":{"first":1},"constants":{},"javaDoc":"Gets the first element of this pair the first element","comments":"\n      Gets the first element of this pair.\n      @return the first element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"S","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the second element of this pair.\n      @return the second element\n   */\npublic S getSecond() {\n    return second;\n}\n","name":"getSecond","className":"Pair","variables":{"second":1},"constants":{},"javaDoc":"Gets the second element of this pair the second element","comments":"\n      Gets the second element of this pair.\n      @return the second element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"(\" + first + \", \" + second + \")\";\n}\n","name":"toString","className":"Pair","variables":{"first":1,"second":1},"constants":{"\")\"":1,"\"(\"":1,"\", \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"size":1,"push":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Stack<Integer>":1,"int":1,"Stack":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":17,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    Stack<Integer> countdown = new Stack<>();\n    for (int i = 0; i <= 10; i++) {\n        countdown.push(i);\n    }\n    while (countdown.size() > 0) {\n        System.out.println(countdown.pop());\n    }\n}\n","name":"main","className":"StackDemo","variables":{"countdown":4,"i":3},"constants":{"0":2,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"Stack","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Stack() {\n    elements = new Object[INITIAL_SIZE];\n// elements = new E[INITIAL_SIZE] \n// is an error--cannot make a generic array\n}\n","name":"Stack","className":"Stack","variables":{"INITIAL_SIZE":1,"elements":1},"constants":{},"javaDoc":"","comments":"elements = new E[INITIAL_SIZE] is an error--cannot make a generic array ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"copyOf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":16,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public void push(E value) {\n    if (currentSize >= elements.length) {\n        elements = Arrays.copyOf(elements, 2 * elements.length);\n    }\n    elements[currentSize] = value;\n    currentSize++;\n}\n","name":"push","className":"Stack","variables":{"elements":2,"Arrays":1,"value":1,"currentSize":3},"constants":{"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"E","methodCalls":{},"annotations":["SuppressWarnings"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":3,"CastExpr":1,"UnaryExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"// Suppresses \"unchecked\" warnings inside this method\n@SuppressWarnings(\"unchecked\")\npublic E pop() {\n    currentSize--;\n    // Cast causes \"unchecked\" warning\n    return (E) elements[currentSize];\n}\n","name":"pop","className":"Stack","variables":{"elements":1,"currentSize":2},"constants":{},"javaDoc":"","comments":"Suppresses \"unchecked\" warnings inside this method Cast causes \"unchecked\" warning ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int size() {\n    return currentSize;\n}\n","name":"size","className":"Stack","variables":{"currentSize":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ArrayList<E>","ArrayList<? extends E>"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"E":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":1},"text":"public static <E> void addAll(ArrayList<E> lst, ArrayList<? extends E> other) // public static <E> void addAll(ArrayList<E> lst, ArrayList<E> other)\n// doesn't work with Student array list\n{\n    for (E e : other) {\n        lst.add(e);\n    }\n}\n","name":"addAll","className":"WildcardDemo","variables":{"other":1,"e":1,"lst":1},"constants":{},"javaDoc":"","comments":"public static <E> void addAll(ArrayList<E> lst ArrayList<E> other) doesn't work with Student array list ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["ArrayList<E>"],"returnType":"E","methodCalls":{"size":1,"get":3,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"E":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":21,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static <E extends Comparable<? super E>> E max(ArrayList<E> a) // public static <E extends Comparable<E>> E max(ArrayList<E> a) \n// doesn't work with Student array list\n{\n    E largest = a.get(0);\n    for (int i = 1; i < a.size(); i++) {\n        if (a.get(i).compareTo(largest) > 0) {\n            largest = a.get(i);\n        }\n    }\n    return largest;\n}\n","name":"max","className":"WildcardDemo","variables":{"largest":3,"a":4,"i":3},"constants":{"0":2,"1":1},"javaDoc":"","comments":"public static <E extends Comparable<E>> E max(ArrayList<E> a) doesn't work with Student array list ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"addAll":1,"max":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayList<Student>":1,"ArrayList":2,"ArrayList<Person>":1},"expressions":{"ObjectCreationExpr":6,"VariableDeclarationExpr":2,"NameExpr":30,"StringLiteralExpr":7,"FieldAccessExpr":2,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    ArrayList<Student> students = new ArrayList<>();\n    students.add(new Student(\"Fred\", \"CS\"));\n    students.add(new Student(\"Ann\", \"Bio\"));\n    students.add(new Student(\"Sue\", \"CS\"));\n    ArrayList<Person> people = new ArrayList<>();\n    people.add(new Person(\"Harry\"));\n    addAll(people, students);\n    System.out.println(people);\n    System.out.println(max(students));\n}\n","name":"main","className":"WildcardDemo","variables":{"students":4,"people":2},"constants":{"\"CS\"":2,"\"Fred\"":1,"\"Bio\"":1,"\"Sue\"":1,"\"Harry\"":1,"\"Ann\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["String","String"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/**\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   */\npublic Student(String aName, String aMajor) {\n    super(aName);\n    major = aMajor;\n}\n","name":"Student","className":"Student","variables":{"major":1,"aName":1,"aMajor":1},"constants":{},"javaDoc":"Constructs a Student object aName the name of the student aMajor the major of the student","comments":"\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":3,"NameExpr":3,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return super.toString() + \"[major=\" + major + \"]\";\n}\n","name":"toString","className":"Student","variables":{"major":1},"constants":{"\"]\"":1,"\"[major=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"Person","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a Person object\n      @param aName the name of the person\n   */\npublic Person(String aName) {\n    name = aName;\n}\n","name":"Person","className":"Person","variables":{"aName":1,"name":1},"constants":{},"javaDoc":"Constructs a Person object aName the name of the person","comments":"\n      Constructs a Person object\n      @param aName the name of the person\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \"]\";\n}\n","name":"toString","className":"Person","variables":{"name":1},"constants":{"\"[name=\"":1,"\"]\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Person"],"returnType":"int","methodCalls":{"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int compareTo(Person other) {\n    return name.compareTo(other.name);\n}\n","name":"compareTo","className":"Person","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["E[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"E":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"public static <E> void print(E[] a) {\n    for (E e : a) {\n        System.out.print(e + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"PrintDemo","variables":{"a":1,"e":2},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"public static void print(int[] a) {\n    for (int e : a) {\n        System.out.print(e + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"PrintDemo","variables":{"a":1,"e":2},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color[]":1,"int[]":1,"String[]":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"ArrayInitializerExpr":3,"StringLiteralExpr":5,"NameExpr":21,"FieldAccessExpr":4,"MethodCallExpr":3},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    String[] words = { \"Mary\", \"had\", \"a\", \"little\", \"lamb\" };\n    Color[] colors = { Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW };\n    int[] squares = { 1, 4, 9, 16, 25, 36 };\n    // Calls print<String>\n    print(words);\n    // Calls print<Color>\n    print(colors);\n    // Calls non-generic print      \n    print(squares);\n}\n","name":"main","className":"PrintDemo","variables":{"words":1,"squares":1,"colors":1},"constants":{"1":1,"\"lamb\"":1,"\"a\"":1,"25":1,"36":1,"\"little\"":1,"4":1,"16":1,"\"had\"":1,"9":1,"\"Mary\"":1},"javaDoc":"","comments":"Calls print<String> Calls print<Color> Calls non-generic print ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String","String"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/**\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   */\npublic Student(String aName, String aMajor) {\n    super(aName);\n    major = aMajor;\n}\n","name":"Student","className":"Student","variables":{"major":1,"aName":1,"aMajor":1},"constants":{},"javaDoc":"Constructs a Student object aName the name of the student aMajor the major of the student","comments":"\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":3,"NameExpr":3,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return super.toString() + \"[major=\" + major + \"]\";\n}\n","name":"toString","className":"Student","variables":{"major":1},"constants":{"\"]\"":1,"\"[major=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      This method is called for each visited node.\n      @param data the data of the node\n   */\nvoid visit(E data);\n","name":"visit","className":"Visitor","variables":{},"constants":{},"javaDoc":"This method is called for each visited node data the data of the node","comments":"\n      This method is called for each visited node.\n      @param data the data of the node\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void visit(String data) {\n    System.out.print(data + \" \");\n}\n","name":"visit","className":"PrintVisitor","variables":{"data":1},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":5,"inorder":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"BinarySearchTree<String>":1,"BinarySearchTree":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":38,"StringLiteralExpr":7,"FieldAccessExpr":3,"MethodCallExpr":9},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    BinarySearchTree<String> names = new BinarySearchTree<>();\n    names.add(\"Romeo\");\n    names.add(\"Juliet\");\n    names.add(\"Tom\");\n    names.add(\"Dick\");\n    names.add(\"Harry\");\n    class PrintVisitor implements Visitor<String> {\n\n        public void visit(String data) {\n            System.out.print(data + \" \");\n        }\n    }\n    names.inorder(new PrintVisitor());\n    System.out.println();\n    System.out.println(\"Expected: Dick Harry Juliet Romeo Tom\");\n}\n","name":"main","className":"TreeTester","variables":{"names":7,"data":2,"PrintVisitor":1,"visit":1},"constants":{"\"Expected: Dick Harry Juliet Romeo Tom\"":1,"\"Tom\"":1,"\" \"":1,"\"Juliet\"":1,"\"Dick\"":1,"\"Harry\"":1,"\"Romeo\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void visit(Object data) {\n    System.out.println(data);\n}\n","name":"visit","className":"PrintVisitor","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":5,"inorder":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"BinarySearchTree2":1,"BinarySearchTree2<Student>":1},"expressions":{"ObjectCreationExpr":7,"VariableDeclarationExpr":1,"NameExpr":28,"StringLiteralExpr":10,"FieldAccessExpr":1,"MethodCallExpr":7},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    BinarySearchTree2<Student> students = new BinarySearchTree2<>();\n    // Can form BinarySearchTree2<Student> even though Student\n    // implements Comparable<Person> and not Comparable<Student>\n    students.add(new Student(\"Romeo\", \"Art History\"));\n    students.add(new Student(\"Juliet\", \"CS\"));\n    students.add(new Student(\"Tom\", \"Leisure Studies\"));\n    students.add(new Student(\"Diana\", \"EE\"));\n    students.add(new Student(\"Harry\", \"Biology\"));\n    class PrintVisitor implements Visitor<Object> {\n\n        public void visit(Object data) {\n            System.out.println(data);\n        }\n    }\n    // Can pass a Visitor<Object>, not just a Visitor<Student>\n    students.inorder(new PrintVisitor());\n}\n","name":"main","className":"TreeTester2","variables":{"data":1,"PrintVisitor":1,"students":7,"visit":1},"constants":{"\"CS\"":1,"\"EE\"":1,"\"Tom\"":1,"\"Biology\"":1,"\"Juliet\"":1,"\"Leisure Studies\"":1,"\"Diana\"":1,"\"Art History\"":1,"\"Harry\"":1,"\"Romeo\"":1},"javaDoc":"","comments":"Can form BinarySearchTree2<Student> even though Student implements Comparable<Person> and not Comparable<Student> Can pass a Visitor<Object> not just a Visitor<Student> ","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"BinarySearchTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic BinarySearchTree() {\n    root = null;\n}\n","name":"BinarySearchTree","className":"BinarySearchTree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"addNode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":17,"FieldAccessExpr":3,"AssignExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(E obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n}\n","name":"add","className":"BinarySearchTree","variables":{"obj":1,"root":3,"newNode":2},"constants":{"null":3},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":3,"MethodCallExpr":1,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(E obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"BinarySearchTree","variables":{"current":4,"d":3,"root":1},"constants":{"0":2,"null":1,"true":1,"false":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"toBeRemoved.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Node":5,"int":1},"expressions":{"NullLiteralExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"BooleanLiteralExpr":2,"BinaryExpr":12,"NameExpr":88,"FieldAccessExpr":20,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":14},"statements":{"IfStmt":8,"WhileStmt":2,"BlockStmt":15,"ReturnStmt":2,"ExpressionStmt":21},"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(E obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    Node parent = null;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            parent = toBeRemoved;\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        if (// Found in root\n        parent == null) {\n            root = newChild;\n        } else if (parent.left == toBeRemoved) {\n            parent.left = newChild;\n        } else {\n            parent.right = newChild;\n        }\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallestParent = toBeRemoved;\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallestParent = smallest;\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    if (smallestParent == toBeRemoved) {\n        smallestParent.right = smallest.right;\n    } else {\n        smallestParent.left = smallest.right;\n    }\n}\n","name":"remove","className":"BinarySearchTree","variables":{"parent":3,"smallestParent":3,"toBeRemoved":8,"found":4,"d":3,"newChild":6,"smallest":3,"root":2},"constants":{"0":2,"null":7,"false":1,"true":1},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child Found in root \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":18,"modifier":1}
{"paramTypes":["Visitor<E>"],"returnType":"void","methodCalls":{"inorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Prints the contents of the tree in sorted order.\n   */\npublic void inorder(Visitor<E> v) {\n    inorder(root, v);\n}\n","name":"inorder","className":"BinarySearchTree","variables":{},"constants":{},"javaDoc":"Prints the contents of the tree in sorted order","comments":"\n      Prints the contents of the tree in sorted order.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Node","Visitor<E>"],"returnType":"void","methodCalls":{"visit":1,"inorder":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":19,"FieldAccessExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   */\nprivate void inorder(Node parent, Visitor<E> v) {\n    if (parent == null) {\n        return;\n    }\n    inorder(parent.left, v);\n    v.visit(parent.data);\n    inorder(parent.right, v);\n}\n","name":"inorder","className":"BinarySearchTree","variables":{"parent":1,"v":1},"constants":{"null":1},"javaDoc":"Prints a node and all of its descendants in sorted order parent the root of the subtree to print","comments":"\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":4,"BlockStmt":6,"ExpressionStmt":5},"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":2,"right":3},"constants":{"0":2,"null":2},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"BinarySearchTree2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic BinarySearchTree2() {\n    root = null;\n}\n","name":"BinarySearchTree2","className":"BinarySearchTree2","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"addNode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":17,"FieldAccessExpr":3,"AssignExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(E obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n}\n","name":"add","className":"BinarySearchTree2","variables":{"obj":1,"root":3,"newNode":2},"constants":{"null":3},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":3,"MethodCallExpr":1,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(E obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"BinarySearchTree2","variables":{"current":4,"d":3,"root":1},"constants":{"0":2,"null":1,"true":1,"false":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"toBeRemoved.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Node":5,"int":1},"expressions":{"NullLiteralExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"BooleanLiteralExpr":2,"BinaryExpr":12,"NameExpr":88,"FieldAccessExpr":20,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":14},"statements":{"IfStmt":8,"WhileStmt":2,"BlockStmt":15,"ReturnStmt":2,"ExpressionStmt":21},"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(E obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    Node parent = null;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            parent = toBeRemoved;\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        if (// Found in root\n        parent == null) {\n            root = newChild;\n        } else if (parent.left == toBeRemoved) {\n            parent.left = newChild;\n        } else {\n            parent.right = newChild;\n        }\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallestParent = toBeRemoved;\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallestParent = smallest;\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    if (smallestParent == toBeRemoved) {\n        smallestParent.right = smallest.right;\n    } else {\n        smallestParent.left = smallest.right;\n    }\n}\n","name":"remove","className":"BinarySearchTree2","variables":{"parent":3,"smallestParent":3,"toBeRemoved":8,"found":4,"d":3,"newChild":6,"smallest":3,"root":2},"constants":{"0":2,"null":7,"false":1,"true":1},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child Found in root \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":18,"modifier":1}
{"paramTypes":["Visitor<? super E>"],"returnType":"void","methodCalls":{"inorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Prints the contents of the tree in sorted order.\n   */\npublic void inorder(Visitor<? super E> v) {\n    inorder(root, v);\n}\n","name":"inorder","className":"BinarySearchTree2","variables":{},"constants":{},"javaDoc":"Prints the contents of the tree in sorted order","comments":"\n      Prints the contents of the tree in sorted order.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["BinarySearchTree2<T>.Node<T>","Visitor<? super T>"],"returnType":"void","methodCalls":{"visit":1,"inorder":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":19,"FieldAccessExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   */\nprivate static <T extends Comparable<? super T>> void inorder(BinarySearchTree2<T>.Node<T> parent, Visitor<? super T> v) {\n    if (parent == null) {\n        return;\n    }\n    inorder(parent.left, v);\n    v.visit(parent.data);\n    inorder(parent.right, v);\n}\n","name":"inorder","className":"BinarySearchTree2","variables":{"parent":1,"v":1},"constants":{"null":1},"javaDoc":"Prints a node and all of its descendants in sorted order parent the root of the subtree to print","comments":"\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":10}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":4,"BlockStmt":6,"ExpressionStmt":5},"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":2,"right":3},"constants":{"0":2,"null":2},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"Person","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a Person object\n      @param aName the name of the person\n   */\npublic Person(String aName) {\n    name = aName;\n}\n","name":"Person","className":"Person","variables":{"aName":1,"name":1},"constants":{},"javaDoc":"Constructs a Person object aName the name of the person","comments":"\n      Constructs a Person object\n      @param aName the name of the person\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \"]\";\n}\n","name":"toString","className":"Person","variables":{"name":1},"constants":{"\"[name=\"":1,"\"]\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Person"],"returnType":"int","methodCalls":{"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int compareTo(Person other) {\n    return name.compareTo(other.name);\n}\n","name":"compareTo","className":"Person","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":2,"sum":2,"addFirst":4,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"LinkedList":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":34,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":10},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    // Here, we use the linked list class from Chapter 16\n    LinkedList numbers = new LinkedList();\n    numbers.addFirst(1);\n    numbers.addFirst(2);\n    numbers.addFirst(3);\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n    // No error message\n    numbers.addFirst(\"4\");\n    // No error\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n// ClassCastException\n}\n","name":"main","className":"UnsafeDemo","variables":{"numbers":5},"constants":{"\"4\"":1,"1":1,"2":1,"3":1,"\"Sum: \"":2},"javaDoc":"","comments":"ClassCastException Here we use the linked list class from Chapter 16 No error message No error ","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["LinkedList"],"returnType":"void","methodCalls":{"next":1,"listIterator":1,"hasNext":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ListIterator":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public static void print(LinkedList lst) {\n    ListIterator iter = lst.listIterator();\n    while (iter.hasNext()) {\n        System.out.print(iter.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"UnsafeDemo","variables":{"iter":3,"lst":1},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["LinkedList"],"returnType":"int","methodCalls":{"next":1,"listIterator":1,"hasNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ListIterator":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":12,"CastExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public static int sum(LinkedList lst) {\n    int sum = 0;\n    ListIterator iter = lst.listIterator();\n    while (iter.hasNext()) {\n        sum = sum + (Integer) iter.next();\n    }\n    return sum;\n}\n","name":"sum","className":"UnsafeDemo","variables":{"iter":3,"sum":4,"lst":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Moves the iterator past the next element.\n      @return the traversed element\n   */\nObject next();\n","name":"next","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n      Moves the iterator past the next element.\n      @return the traversed element\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   */\nboolean hasNext();\n","name":"hasNext","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   */\nvoid add(Object element);\n","name":"add","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   */\nvoid remove();\n","name":"remove","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   */\nvoid set(Object element);\n","name":"set","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"LinkedList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Constructs an empty linked list.\n   */\npublic LinkedList() {\n    first = null;\n}\n","name":"LinkedList","className":"LinkedList","variables":{"first":1},"constants":{"null":1},"javaDoc":"Constructs an empty linked list","comments":" \n      Constructs an empty linked list.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"/**\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   */\npublic Object getFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    return first.data;\n}\n","name":"getFirst","className":"LinkedList","variables":{"first":1},"constants":{"null":1},"javaDoc":"Returns the first element in the linked list the first element in the linked list","comments":"\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Removes the first element in the linked list.\n      @return the removed element\n   */\npublic Object removeFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    return element;\n}\n","name":"removeFirst","className":"LinkedList","variables":{"first":2,"element":2},"constants":{"null":1},"javaDoc":"Removes the first element in the linked list the removed element","comments":"\n      Removes the first element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":10,"FieldAccessExpr":2,"AssignExpr":3},"statements":{"ExpressionStmt":4},"text":"/**\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   */\npublic void addFirst(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    first = newNode;\n}\n","name":"addFirst","className":"LinkedList","variables":{"newNode":2,"first":2,"element":1},"constants":{},"javaDoc":"Adds an element to the front of the linked list element the element to add","comments":"\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"ListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   */\npublic ListIterator listIterator() {\n    return new LinkedListIterator();\n}\n","name":"listIterator","className":"LinkedList","variables":{},"constants":{},"javaDoc":"Returns an iterator for iterating through this list an iterator for iterating through this list","comments":"\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"LinkedListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BooleanLiteralExpr":1,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n         Constructs an iterator that points to the front\n         of the linked list.\n      */\npublic LinkedListIterator() {\n    position = null;\n    previous = null;\n    isAfterNext = false;\n}\n","name":"LinkedListIterator","className":"LinkedListIterator","variables":{"previous":1,"position":1,"isAfterNext":1},"constants":{"null":2,"false":1},"javaDoc":"Constructs an iterator that points to the front of the linked list","comments":"\n         Constructs an iterator that points to the front\n         of the linked list.\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":15,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":4},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n         Moves the iterator past the next element.\n         @return the traversed element\n      */\npublic Object next() {\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    // Remember for remove\n    previous = position;\n    isAfterNext = true;\n    if (position == null) {\n        position = first;\n    } else {\n        position = position.next;\n    }\n    return position.data;\n}\n","name":"next","className":"LinkedListIterator","variables":{"previous":1,"position":4,"first":1,"isAfterNext":1},"constants":{"null":1,"true":1},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"Remember for remove \n         Moves the iterator past the next element.\n         @return the traversed element\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"BinaryExpr":3,"NameExpr":5,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      */\npublic boolean hasNext() {\n    if (position == null) {\n        return first != null;\n    } else {\n        return position.next != null;\n    }\n}\n","name":"hasNext","className":"LinkedListIterator","variables":{"position":1,"first":1},"constants":{"null":3},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"addFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":23,"FieldAccessExpr":4,"MethodCallExpr":1,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":8},"text":"/**\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      */\npublic void add(Object element) {\n    if (position == null) {\n        addFirst(element);\n        position = first;\n    } else {\n        Node newNode = new Node();\n        newNode.data = element;\n        newNode.next = position.next;\n        position.next = newNode;\n        position = newNode;\n    }\n    isAfterNext = false;\n}\n","name":"add","className":"LinkedListIterator","variables":{"newNode":3,"position":3,"first":1,"element":1,"isAfterNext":1},"constants":{"null":1,"false":1},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":14,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":4},"text":"/**\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      */\npublic void remove() {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    if (position == first) {\n        removeFirst();\n    } else {\n        previous.next = position.next;\n    }\n    position = previous;\n    isAfterNext = false;\n}\n","name":"remove","className":"LinkedListIterator","variables":{"previous":1,"position":2,"first":1,"isAfterNext":2},"constants":{"false":1},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      */\npublic void set(Object element) {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    position.data = element;\n}\n","name":"set","className":"LinkedListIterator","variables":{"isAfterNext":1,"element":1},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"print":2,"sum":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayList<Integer>":1,"ArrayList":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":34,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":10},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<>();\n    numbers.add(1);\n    numbers.add(2);\n    numbers.add(3);\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n    // Compiler error message\n    numbers.add(\"4\");\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n}\n","name":"main","className":"UnsafeDemo2","variables":{"numbers":5},"constants":{"\"4\"":1,"1":1,"2":1,"3":1,"\"Sum: \"":2},"javaDoc":"","comments":"Compiler error message ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["ArrayList<Integer>"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"hasNext":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Iterator<Integer>":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public static void print(ArrayList<Integer> lst) {\n    Iterator<Integer> iter = lst.iterator();\n    while (iter.hasNext()) {\n        System.out.print(iter.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"UnsafeDemo2","variables":{"iter":3,"lst":1},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["ArrayList<Integer>"],"returnType":"int","methodCalls":{"next":1,"iterator":1,"hasNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Iterator<Integer>":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":12,"MethodCallExpr":3,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public static int sum(ArrayList<Integer> lst) {\n    int sum = 0;\n    Iterator<Integer> iter = lst.iterator();\n    while (iter.hasNext()) {\n        // No cast needed\n        sum = sum + iter.next();\n    }\n    return sum;\n}\n","name":"sum","className":"UnsafeDemo2","variables":{"iter":3,"sum":4,"lst":1},"constants":{"0":1},"javaDoc":"","comments":"No cast needed ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["E[]"],"returnType":"E","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"E":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":2,"NameExpr":15,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static <E extends Comparable<E>> E max(E[] a) {\n    E largest = a[0];\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].compareTo(largest) > 0) {\n            largest = a[i];\n        }\n    }\n    return largest;\n}\n","name":"max","className":"MaxDemo","variables":{"largest":3,"a":3,"i":5},"constants":{"0":2,"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"max":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color[]":1,"String[]":1,"Integer[]":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"ArrayInitializerExpr":3,"StringLiteralExpr":5,"NameExpr":28,"FieldAccessExpr":6,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    String[] words = { \"Mary\", \"had\", \"a\", \"little\", \"lamb\" };\n    Color[] colors = { Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW };\n    Integer[] squares = { 1, 4, 9, 16, 25, 36 };\n    // Calls max<String>\n    System.out.println(max(words));\n    // System.out.println(max(colors)); // Error: Color is not Comparable\n    // Calls max<Integer>\n    System.out.println(max(squares));\n}\n","name":"main","className":"MaxDemo","variables":{"words":1,"squares":1,"colors":1},"constants":{"1":1,"\"lamb\"":1,"\"a\"":1,"25":1,"36":1,"\"little\"":1,"4":1,"16":1,"\"had\"":1,"9":1,"\"Mary\"":1},"javaDoc":"","comments":"System out println(max(colors)); // Error: Color is not Comparable Calls max<String> Calls max<Integer> ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":1,"println":1,"nextLine":1,"hasNextLine":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":1,"String":1,"File":2,"PrintWriter":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"StringLiteralExpr":2,"NameExpr":14,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public static void main(String[] args) throws FileNotFoundException {\n    File inFile = new File(\"test1.txt\");\n    File outFile = new File(\"output.txt\");\n    try (Scanner in = new Scanner(inFile);\n        PrintWriter out = new PrintWriter(outFile)) {\n        while (in.hasNextLine()) {\n            String result = process(in.nextLine());\n            out.println(result);\n        }\n    }\n// Both in.close() and out.close() are called here\n}\n","name":"main","className":"ClosingResources","variables":{"result":1,"outFile":2,"in":3,"inFile":2,"out":2},"constants":{"\"test1.txt\"":1,"\"output.txt\"":1},"javaDoc":"","comments":"Both in close() and out close() are called here ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"parseInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public static String process(String line) {\n    int value = Integer.parseInt(line);\n    value++;\n    return \"\" + value;\n}\n","name":"process","className":"ClosingResources","variables":{"Integer":1,"value":3},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readData":1,"getMessage":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    try {\n        int result = readData(\"fred.txt\");\n        System.out.println(\"result: \" + result);\n    } catch (IOException exception) {\n        System.out.println(exception.getMessage());\n    }\n}\n","name":"main","className":"CheckedExceptions","variables":{"result":2,"exception":2},"constants":{"\"fred.txt\"":1,"\"result: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"int","methodCalls":{"hasNextInt":1,"nextInt":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":1,"File":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":11,"MethodCallExpr":2,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public static int readData(String filename) throws FileNotFoundException {\n    File inFile = new File(filename);\n    Scanner in = new Scanner(inFile);\n    int sum = 0;\n    while (in.hasNextInt()) {\n        sum = sum + in.nextInt();\n    }\n    return sum;\n}\n","name":"readData","className":"CheckedExceptions","variables":{"filename":1,"in":3,"sum":4,"inFile":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"parseDouble":1,"trim":1,"nextLine":1,"hasNextLine":1,"length":1,"close":2,"System.out.print":2,"charAt":1,"substring":2,"printf":2},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":2,"boolean":1,"double":2,"char":1,"String":4,"File":1,"int":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":6,"VariableDeclarationExpr":13,"BooleanLiteralExpr":2,"BinaryExpr":6,"NameExpr":74,"StringLiteralExpr":6,"FieldAccessExpr":3,"CharLiteralExpr":1,"UnaryExpr":2,"MethodCallExpr":16,"AssignExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":22},"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Prompt for the input and output file names\n    Scanner console = new Scanner(System.in);\n    System.out.print(\"Input file: \");\n    String inputFileName = console.next();\n    System.out.print(\"Output file: \");\n    String outputFileName = console.next();\n    // Construct the Scanner and PrintWriter objects for reading and writing\n    File inputFile = new File(inputFileName);\n    Scanner in = new Scanner(inputFile);\n    PrintWriter out = new PrintWriter(outputFileName);\n    // Read the input and write the output\n    double total = 0;\n    // We read a line at a time since there may be spaces in the item names\n    while (in.hasNextLine()) {\n        String line = in.nextLine();\n        boolean found = false;\n        String item = \"\";\n        double price = 0;\n        for (int i = 0; !found && i < line.length(); i++) {\n            char ch = line.charAt(i);\n            if (ch == ':') {\n                found = true;\n                item = line.substring(0, i + 1);\n                price = Double.parseDouble(line.substring(i + 1).trim());\n                total = total + price;\n            }\n        }\n        // If no colon was found, we skip the line\n        if (found) {\n            out.printf(\"%-20s%10.2f\\n\", item, price);\n        }\n    }\n    out.printf(\"%-20s%10.2f\\n\", \"Total:\", total);\n    in.close();\n    out.close();\n}\n","name":"main","className":"Items","variables":{"console":3,"item":2,"outputFileName":2,"inputFileName":2,"in":4,"ch":2,"line":5,"i":5,"Double":1,"out":4,"inputFile":2,"total":3,"found":4,"price":3},"constants":{"0":4,"\"\"":1,"1":2,"\"%-20s%10.2f\\n\"":2,"':'":1,"\"Output file: \"":1,"\"Total:\"":1,"false":1,"true":1,"\"Input file: \"":1},"javaDoc":"","comments":"Prompt for the input and output file names Construct the Scanner and PrintWriter objects for reading and writing Read the input and write the output We read a line at a time since there may be spaces in the item names If no colon was found we skip the line ","isEmpty":false,"hasInnerClass":false,"lineCount":16,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":5,"StringLiteralExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    if (amount > balance) {\n        throw new IllegalArgumentException(\"Amount exceeds balance\");\n    }\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":3},"constants":{"\"Amount exceeds balance\"":1},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1,"withdraw":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":14,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Tests the methods of the BankAccount class.\n      @param args not used\n   */\npublic static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount();\n    harrysChecking.deposit(2000);\n    harrysChecking.withdraw(5000);\n    // The last statement is not executed since an exception has\n    // terminated the program\n    System.out.println(harrysChecking.getBalance());\n}\n","name":"main","className":"ThrowingExceptions","variables":{"harrysChecking":4},"constants":{"5000":1,"2000":1},"javaDoc":"Tests the methods of the BankAccount class args not used","comments":"The last statement is not executed since an exception has terminated the program \n      Tests the methods of the BankAccount class.\n      @param args not used\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"double[]","methodCalls":{"readData":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Scanner":1,"File":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":6,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Reads a data set.\n      @param filename the name of the file holding the data\n      @return the data in the file\n   */\npublic double[] readFile(String filename) throws IOException {\n    File inFile = new File(filename);\n    try (Scanner in = new Scanner(inFile)) {\n        readData(in);\n        return data;\n    }\n}\n","name":"readFile","className":"DataSetReader","variables":{"filename":1,"data":1,"in":1,"inFile":2},"constants":{},"javaDoc":"Reads a data set filename the name of the file holding the data the data in the file","comments":"\n      Reads a data set.\n      @param filename the name of the file holding the data\n      @return the data in the file\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Scanner"],"returnType":"void","methodCalls":{"readValue":1,"hasNextInt":1,"hasNext":1,"nextInt":1},"annotations":[],"exceptions":["BadDataException"],"concepts":[],"types":{"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":18,"StringLiteralExpr":2,"UnaryExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"/**\n      Reads all data.\n      @param in the scanner that scans the data\n   */\nprivate void readData(Scanner in) throws BadDataException {\n    if (!in.hasNextInt()) {\n        throw new BadDataException(\"Length expected\");\n    }\n    int numberOfValues = in.nextInt();\n    data = new double[numberOfValues];\n    for (int i = 0; i < numberOfValues; i++) {\n        readValue(in, i);\n    }\n    if (in.hasNext()) {\n        throw new BadDataException(\"End of file expected\");\n    }\n}\n","name":"readData","className":"DataSetReader","variables":{"data":1,"in":3,"numberOfValues":3,"i":3},"constants":{"0":1,"\"Length expected\"":1,"\"End of file expected\"":1},"javaDoc":"Reads all data in the scanner that scans the data","comments":"\n      Reads all data.\n      @param in the scanner that scans the data\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":2}
{"paramTypes":["Scanner","int"],"returnType":"void","methodCalls":{"hasNextDouble":1,"nextDouble":1},"annotations":[],"exceptions":["BadDataException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"ArrayAccessExpr":1,"NameExpr":8,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n      Reads one data value.\n      @param in the scanner that scans the data\n      @param i the position of the value to read\n   */\nprivate void readValue(Scanner in, int i) throws BadDataException {\n    if (!in.hasNextDouble()) {\n        throw new BadDataException(\"Data value expected\");\n    }\n    data[i] = in.nextDouble();\n}\n","name":"readValue","className":"DataSetReader","variables":{"data":1,"in":2,"i":1},"constants":{"\"Data value expected\"":1},"javaDoc":"Reads one data value in the scanner that scans the data i the position of the value to read","comments":"\n      Reads one data value.\n      @param in the scanner that scans the data\n      @param i the position of the value to read\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"printStackTrace":1,"readFile":1,"getMessage":1,"System.out.println":4},"annotations":[],"exceptions":["BadDataException","FileNotFoundException","IOException"],"concepts":[],"types":{"Scanner":1,"boolean":1,"double[]":1,"double":2,"String":1,"DataSetReader":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":7,"BooleanLiteralExpr":2,"BinaryExpr":3,"NameExpr":43,"StringLiteralExpr":4,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":8,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":6,"TryStmt":1,"ForeachStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    DataSetReader reader = new DataSetReader();\n    boolean done = false;\n    while (!done) {\n        try {\n            System.out.println(\"Please enter the file name: \");\n            String filename = in.next();\n            double[] data = reader.readFile(filename);\n            double sum = 0;\n            for (double d : data) {\n                sum = sum + d;\n            }\n            System.out.println(\"The sum is \" + sum);\n            done = true;\n        } catch (FileNotFoundException exception) {\n            System.out.println(\"File not found.\");\n        } catch (BadDataException exception) {\n            System.out.println(\"Bad data: \" + exception.getMessage());\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        }\n    }\n}\n","name":"main","className":"DataAnalyzer","variables":{"exception":5,"filename":1,"data":2,"d":2,"in":2,"reader":2,"sum":4,"done":3},"constants":{"0":1,"\"File not found.\"":1,"\"Bad data: \"":1,"\"The sum is \"":1,"\"Please enter the file name: \"":1,"false":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"BadDataException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public BadDataException() {\n}\n","name":"BadDataException","className":"BadDataException","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["String"],"returnType":"BadDataException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public BadDataException(String message) {\n    super(message);\n}\n","name":"BadDataException","className":"BadDataException","variables":{"message":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"lastIndexOf":1,"contains":1,"hasNext":1,"openStream":1,"indexOf":1,"substring":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Scanner":1,"String":2,"URL":1,"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":29,"FieldAccessExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"public static void main(String[] args) throws IOException {\n    String address = \"http://horstmann.com/index.html\";\n    URL pageLocation = new URL(address);\n    Scanner in = new Scanner(pageLocation.openStream());\n    while (in.hasNext()) {\n        String line = in.next();\n        if (line.contains(\"href=\\\"http://\")) {\n            int from = line.indexOf(\"\\\"\");\n            int to = line.lastIndexOf(\"\\\"\");\n            System.out.println(line.substring(from + 1, to));\n        }\n    }\n}\n","name":"main","className":"WebPageReader","variables":{"pageLocation":2,"address":2,"in":3,"line":5,"from":2,"to":1},"constants":{"1":1,"\"href=\\\"http://\"":1,"\"\\\"\"":2,"\"http://horstmann.com/index.html\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"print":1,"encrypt":1,"usage":2,"useDelimiter":1,"hasNext":1,"close":2,"charAt":3},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["FinalVariables"],"types":{"Scanner":1,"char":3,"String":3,"int":4,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":9,"ObjectCreationExpr":3,"VariableDeclarationExpr":12,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":56,"StringLiteralExpr":3,"FieldAccessExpr":1,"CharLiteralExpr":2,"UnaryExpr":3,"MethodCallExpr":12,"AssignExpr":3},"statements":{"IfStmt":5,"WhileStmt":1,"BlockStmt":9,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":21},"text":"public static void main(String[] args) throws FileNotFoundException {\n    final int DEFAULT_KEY = 3;\n    int key = DEFAULT_KEY;\n    String inFile = \"\";\n    String outFile = \"\";\n    // Number of command line arguments that are files\n    int files = 0;\n    for (int i = 0; i < args.length; i++) {\n        String arg = args[i];\n        if (arg.charAt(0) == '-') {\n            // It is a command line option\n            char option = arg.charAt(1);\n            if (option == 'd') {\n                key = -key;\n            } else {\n                usage();\n                return;\n            }\n        } else {\n            // It is a file name\n            files++;\n            if (files == 1) {\n                inFile = arg;\n            } else if (files == 2) {\n                outFile = arg;\n            }\n        }\n    }\n    if (files != 2) {\n        usage();\n        return;\n    }\n    Scanner in = new Scanner(new File(inFile));\n    // Process individual characters\n    in.useDelimiter(\"\");\n    PrintWriter out = new PrintWriter(outFile);\n    while (in.hasNext()) {\n        char from = in.next().charAt(0);\n        char to = encrypt(from, key);\n        out.print(to);\n    }\n    in.close();\n    out.close();\n}\n","name":"main","className":"CaesarCipher","variables":{"in":5,"i":4,"out":3,"args":1,"outFile":3,"arg":5,"files":5,"DEFAULT_KEY":2,"from":1,"to":1,"inFile":3,"key":3,"option":2},"constants":{"\"\"":3,"0":4,"'-'":1,"1":2,"2":2,"3":1,"'d'":1},"javaDoc":"","comments":"Number of command line arguments that are files It is a command line option It is a file name Process individual characters ","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":["char","int"],"returnType":"char","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":13,"NameExpr":21,"CastExpr":1,"CharLiteralExpr":6,"EnclosedExpr":1,"AssignExpr":4},"statements":{"IfStmt":4,"BlockStmt":5,"ReturnStmt":2,"ExpressionStmt":7},"text":"/**\n      Encrypts upper- and lowercase characters by shifting them\n      according to a key.\n      @param ch the letter to be encrypted\n      @param key the encryption key\n      @return the encrypted letter      \n   */\npublic static char encrypt(char ch, int key) {\n    int base = 0;\n    if ('A' <= ch && ch <= 'Z') {\n        base = 'A';\n    } else if ('a' <= ch && ch <= 'z') {\n        base = 'a';\n    } else // Not a letter\n    {\n        return ch;\n    }\n    int offset = ch - base + key;\n    // Number of letters in the Roman alphabet\n    final int LETTERS = 26;\n    if (offset >= LETTERS) {\n        offset = offset - LETTERS;\n    } else if (offset < 0) {\n        offset = offset + LETTERS;\n    }\n    return (char) (base + offset);\n}\n","name":"encrypt","className":"CaesarCipher","variables":{"LETTERS":4,"offset":8,"ch":6,"key":1,"base":5},"constants":{"0":2,"'Z'":1,"'z'":1,"26":1,"'A'":2,"'a'":2},"javaDoc":"Encrypts upper- and lowercase characters by shifting them according to a key ch the letter to be encrypted key the encryption key the encrypted letter","comments":"Not a letter Number of letters in the Roman alphabet \n      Encrypts upper- and lowercase characters by shifting them\n      according to a key.\n      @param ch the letter to be encrypted\n      @param key the encryption key\n      @return the encrypted letter      \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Prints a message describing proper usage.\n   */\npublic static void usage() {\n    System.out.println(\"Usage: java CaesarCipher [-d] infile outfile\");\n}\n","name":"usage","className":"CaesarCipher","variables":{},"constants":{"\"Usage: java CaesarCipher [-d] infile outfile\"":1},"javaDoc":"Prints a message describing proper usage","comments":"\n      Prints a message describing proper usage.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"CountryValue","methodCalls":{"parseDouble":1,"trim":1,"isDigit":1,"isWhitespace":1,"charAt":2,"substring":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":32,"UnaryExpr":3,"MethodCallExpr":8,"AssignExpr":2},"statements":{"WhileStmt":2,"BlockStmt":2,"ExpressionStmt":6},"text":"/**\n      Constructs a CountryValue from an input line.\n      @param line a line containing a country name, followed by a value\n   */\npublic CountryValue(String line) {\n    // Locate the start of the first digit\n    int i = 0;\n    while (!Character.isDigit(line.charAt(i))) {\n        i++;\n    }\n    // Locate the end of the preceding word\n    int j = i - 1;\n    while (Character.isWhitespace(line.charAt(j))) {\n        j--;\n    }\n    // Extract the country name\n    country = line.substring(0, j + 1);\n    // Extract the value\n    value = Double.parseDouble(line.substring(i).trim());\n}\n","name":"CountryValue","className":"CountryValue","variables":{"country":1,"Character":2,"line":4,"i":3,"j":3,"value":1,"Double":1},"constants":{"0":2,"1":2},"javaDoc":"Constructs a CountryValue from an input line line a line containing a country name followed by a value","comments":"Locate the start of the first digit Locate the end of the preceding word Extract the country name Extract the value \n      Constructs a CountryValue from an input line.\n      @param line a line containing a country name, followed by a value\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the country name\n   */\npublic String getCountry() {\n    return country;\n}\n","name":"getCountry","className":"CountryValue","variables":{"country":1},"constants":{},"javaDoc":"Gets the country name the country name","comments":"\n      Gets the country name.\n      @return the country name\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the associated value.\n      @return the value associated with the country\n   */\npublic double getValue() {\n    return value;\n}\n","name":"getValue","className":"CountryValue","variables":{"value":1},"constants":{},"javaDoc":"Gets the associated value the value associated with the country","comments":"\n      Gets the associated value.\n      @return the value associated with the country\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getValue":3,"getCountry":1,"nextLine":2,"hasNextLine":2,"close":3,"printf":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":2,"double":1,"CountryValue":2,"PrintWriter":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":6,"BinaryExpr":3,"StringLiteralExpr":4,"NameExpr":38,"MethodCallExpr":12,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":11},"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Open input files\n    Scanner in1 = new Scanner(new File(\"worldpop.txt\"));\n    Scanner in2 = new Scanner(new File(\"worldarea.txt\"));\n    // Open output file\n    PrintWriter out = new PrintWriter(\"world_pop_density.txt\");\n    // Read lines from each file\n    while (in1.hasNextLine() && in2.hasNextLine()) {\n        CountryValue population = new CountryValue(in1.nextLine());\n        CountryValue area = new CountryValue(in2.nextLine());\n        // Compute and print the population density\n        double density = 0;\n        if (// Protect against division by zero\n        area.getValue() != 0) {\n            density = population.getValue() / area.getValue();\n        }\n        out.printf(\"%-40s%15.2f\\n\", population.getCountry(), density);\n    }\n    in1.close();\n    in2.close();\n    out.close();\n}\n","name":"main","className":"PopulationDensity","variables":{"area":3,"density":2,"in2":4,"in1":4,"out":3,"population":3},"constants":{"0":2,"\"worldarea.txt\"":1,"\"worldpop.txt\"":1,"\"world_pop_density.txt\"":1,"\"%-40s%15.2f\\n\"":1},"javaDoc":"","comments":"Open input files Open output file Read lines from each file Compute and print the population density Protect against division by zero ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["double"],"returnType":"RecordReader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a RecordReader with a zero total.\n   */\npublic RecordReader(double aLimit) {\n    total = 0;\n    limit = aLimit;\n}\n","name":"RecordReader","className":"RecordReader","variables":{"total":1,"limit":1,"aLimit":1},"constants":{"0":1},"javaDoc":"Constructs a RecordReader with a zero total","comments":"\n      Constructs a RecordReader with a zero total.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Scanner"],"returnType":"void","methodCalls":{"next":1,"nextInt":1,"nextDouble":1,"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"String":1,"int":1},"expressions":{"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"/**\n      Reads an input record and prints the name if the current total is less \n      than the limit.\n      @param in the input stream\n   */\npublic void process(Scanner in) {\n    String name = in.next();\n    int count = in.nextInt();\n    double percent = in.nextDouble();\n    if (total < limit) {\n        System.out.print(name + \" \");\n    }\n    total = total + percent;\n}\n","name":"process","className":"RecordReader","variables":{"total":3,"in":3,"name":2,"count":1,"limit":1,"percent":2},"constants":{"\" \"":1},"javaDoc":"Reads an input record and prints the name if the current total is less than the limit in the input stream","comments":"\n      Reads an input record and prints the name if the current total is less \n      than the limit.\n      @param in the input stream\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether there are more inputs to process\n      @return true if the limit has not yet been reached\n   */\npublic boolean hasMore() {\n    return total < limit;\n}\n","name":"hasMore","className":"RecordReader","variables":{"total":1,"limit":1},"constants":{},"javaDoc":"Checks whether there are more inputs to process true if the limit has not yet been reached","comments":"\n      Checks whether there are more inputs to process\n      @return true if the limit has not yet been reached\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":2,"hasMore":2,"nextInt":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":1,"RecordReader":2,"int":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":30,"FieldAccessExpr":2,"MethodCallExpr":7},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"public static void main(String[] args) throws FileNotFoundException {\n    try (Scanner in = new Scanner(new File(\"babynames.txt\"))) {\n        RecordReader boys = new RecordReader(LIMIT);\n        RecordReader girls = new RecordReader(LIMIT);\n        while (boys.hasMore() || girls.hasMore()) {\n            int rank = in.nextInt();\n            System.out.print(rank + \" \");\n            boys.process(in);\n            girls.process(in);\n            System.out.println();\n        }\n    }\n}\n","name":"main","className":"BabyNames","variables":{"in":2,"boys":3,"rank":2,"LIMIT":2,"girls":3},"constants":{"\" \"":1,"\"babynames.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"showOpenDialog":1,"getSelectedFile":1,"nextLine":1,"hasNextLine":2,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables"],"types":{"Scanner":1,"JFileChooser":1,"String":1,"File":1,"int":2},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":6,"BinaryExpr":5,"NameExpr":35,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":10},"text":"public static void main(String[] args) throws IOException {\n    JFileChooser chooser = new JFileChooser();\n    Scanner in = null;\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        File selectedFile = chooser.getSelectedFile();\n        in = new Scanner(selectedFile);\n        int lineNumber = 1;\n        final int MAX_LINES = 9;\n        while (in.hasNextLine() && lineNumber <= MAX_LINES) {\n            String line = in.nextLine();\n            System.out.println(lineNumber + \": \" + line);\n            lineNumber++;\n        }\n        if (in.hasNextLine()) {\n            System.out.println(\"...\");\n        }\n    }\n}\n","name":"main","className":"FileChooserDemo","variables":{"selectedFile":2,"in":5,"line":2,"MAX_LINES":2,"chooser":3,"lineNumber":4},"constants":{"1":1,"\"...\"":1,"null":2,"9":1,"\": \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"parseInt":1,"printStackTrace":1,"getMessage":1,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["NumberFormatException","IOException"],"concepts":[],"types":{"Scanner":1,"String":2,"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":31,"FieldAccessExpr":2,"MethodCallExpr":7,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    try {\n        String filename = \"test1.txt\";\n        Scanner in = new Scanner(new File(filename));\n        int sum = 0;\n        while (in.hasNext()) {\n            String input = in.next();\n            int value = Integer.parseInt(input);\n            sum = sum + value;\n        }\n        System.out.println(\"Sum: \" + sum);\n    } catch (IOException exception) {\n        exception.printStackTrace();\n    } catch (NumberFormatException exception) {\n        System.out.println(exception.getMessage());\n    }\n}\n","name":"main","className":"CatchingExceptions","variables":{"Integer":1,"exception":4,"input":1,"filename":2,"in":3,"sum":4,"value":2},"constants":{"0":1,"\"Sum: \"":1,"\"test1.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"hasNextDouble":1,"close":2,"System.out.print":2,"nextDouble":1,"printf":2},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":2,"double":2,"String":2,"File":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":8,"BinaryExpr":1,"NameExpr":45,"StringLiteralExpr":4,"FieldAccessExpr":3,"MethodCallExpr":10,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":15},"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Prompt for the input and output file names\n    Scanner console = new Scanner(System.in);\n    System.out.print(\"Input file: \");\n    String inputFileName = console.next();\n    System.out.print(\"Output file: \");\n    String outputFileName = console.next();\n    // Construct the Scanner and PrintWriter objects for reading and writing\n    File inputFile = new File(inputFileName);\n    Scanner in = new Scanner(inputFile);\n    PrintWriter out = new PrintWriter(outputFileName);\n    // Read the input and write the output\n    double total = 0;\n    while (in.hasNextDouble()) {\n        double value = in.nextDouble();\n        out.printf(\"%15.2f\\n\", value);\n        total = total + value;\n    }\n    out.printf(\"Total: %8.2f\\n\", total);\n    in.close();\n    out.close();\n}\n","name":"main","className":"Total","variables":{"console":3,"inputFile":2,"total":3,"outputFileName":2,"inputFileName":2,"in":4,"value":2,"out":4},"constants":{"0":1,"\"Output file: \"":1,"\"Total: %8.2f\\n\"":1,"\"%15.2f\\n\"":1,"\"Input file: \"":1},"javaDoc":"","comments":"Prompt for the input and output file names Construct the Scanner and PrintWriter objects for reading and writing Read the input and write the output ","isEmpty":false,"hasInnerClass":false,"lineCount":16,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":5,"NameExpr":7,"StringLiteralExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    if (amount > balance) {\n        throw new InsufficientFundsException(\"withdrawal of \" + amount + \" exceeds balance of \" + balance);\n    }\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":3,"balance":4},"constants":{"\"withdrawal of \"":1,"\" exceeds balance of \"":1},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"InsufficientFundsException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public InsufficientFundsException() {\n}\n","name":"InsufficientFundsException","className":"InsufficientFundsException","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["String"],"returnType":"InsufficientFundsException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public InsufficientFundsException(String message) {\n    super(message);\n}\n","name":"InsufficientFundsException","className":"InsufficientFundsException","variables":{"message":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1,"withdraw":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":14,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Tests the methods of the BankAccount class.\n      @param args not used\n   */\npublic static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount();\n    harrysChecking.deposit(2000);\n    harrysChecking.withdraw(5000);\n    // The last statement is not executed since an exception has\n    // terminated the program\n    System.out.println(harrysChecking.getBalance());\n}\n","name":"main","className":"CustomExceptions","variables":{"harrysChecking":4},"constants":{"5000":1,"2000":1},"javaDoc":"Tests the methods of the BankAccount class args not used","comments":"The last statement is not executed since an exception has terminated the program \n      Tests the methods of the BankAccount class.\n      @param args not used\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"encryptStream":1,"nextInt":1,"System.out.print":3,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"InputStream":1,"FileOutputStream":1,"OutputStream":1,"String":2,"int":1,"FileInputStream":1,"CaesarCipher":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":7,"BinaryExpr":1,"NameExpr":41,"StringLiteralExpr":4,"FieldAccessExpr":5,"MethodCallExpr":8},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Input file: \");\n    String inFile = in.next();\n    System.out.print(\"Output file: \");\n    String outFile = in.next();\n    System.out.print(\"Encryption key: \");\n    int key = in.nextInt();\n    try (InputStream inStream = new FileInputStream(inFile);\n        OutputStream outStream = new FileOutputStream(outFile)) {\n        CaesarCipher cipher = new CaesarCipher(key);\n        cipher.encryptStream(inStream, outStream);\n    } catch (IOException exception) {\n        System.out.println(\"Error processing file: \" + exception);\n    }\n}\n","name":"main","className":"CaesarEncryptor","variables":{"cipher":2,"exception":2,"outFile":2,"in":4,"inStream":1,"outStream":1,"inFile":2,"key":2},"constants":{"\"Output file: \"":1,"\"Encryption key: \"":1,"\"Error processing file: \"":1,"\"Input file: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["int"],"returnType":"CaesarCipher","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a cipher object with a given key.\n      @param aKey the encryption key\n   */\npublic CaesarCipher(int aKey) {\n    key = aKey;\n}\n","name":"CaesarCipher","className":"CaesarCipher","variables":{"aKey":1,"key":1},"constants":{},"javaDoc":"Constructs a cipher object with a given key aKey the encryption key","comments":"\n      Constructs a cipher object with a given key.\n      @param aKey the encryption key\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"read":1,"encrypt":1,"write":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"boolean":1,"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":2,"BinaryExpr":1,"NameExpr":13,"UnaryExpr":2,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"/**\n      Encrypts the contents of an input stream.\n      @param in the input stream\n      @param out the output stream\n   */\npublic void encryptStream(InputStream in, OutputStream out) throws IOException {\n    boolean done = false;\n    while (!done) {\n        int next = in.read();\n        if (next == -1) {\n            done = true;\n        } else {\n            int encrypted = encrypt(next);\n            out.write(encrypted);\n        }\n    }\n}\n","name":"encryptStream","className":"CaesarCipher","variables":{"next":2,"encrypted":1,"in":1,"done":3,"out":1},"constants":{"1":1,"false":1,"true":1},"javaDoc":"Encrypts the contents of an input stream in the input stream out the output stream","comments":"\n      Encrypts the contents of an input stream.\n      @param in the input stream\n      @param out the output stream\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Encrypts a value.\n      @param b the value to encrypt (between 0 and 255)\n      @return the encrypted value\n   */\npublic int encrypt(int b) {\n    return (b + key) % 256;\n}\n","name":"encrypt","className":"CaesarCipher","variables":{"b":1,"key":1},"constants":{"256":1},"javaDoc":"Encrypts a value b the value to encrypt (between 0 and 255) the encrypted value","comments":"\n      Encrypts a value.\n      @param b the value to encrypt (between 0 and 255)\n      @return the encrypted value\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getParent":2,"resolve":2,"get":1,"toAbsolutePath":1,"replace":1,"toString":1,"getFileName":2,"System.out.print":2,"System.out.println":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"Path":7},"expressions":{"VariableDeclarationExpr":7,"BinaryExpr":7,"NameExpr":80,"StringLiteralExpr":12,"FieldAccessExpr":9,"MethodCallExpr":19},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    Path inputPath = Paths.get(\"input.txt\");\n    System.out.println(\"Relative path: \" + inputPath);\n    Path absolutePath = inputPath.toAbsolutePath();\n    System.out.println(\"Absolute path: \" + absolutePath);\n    Path parent = absolutePath.getParent();\n    System.out.println(\"Its parent: \" + parent);\n    Path sibling = parent.resolve(\"output.txt\");\n    System.out.println(\"A sibling: \" + sibling);\n    Path fileName = sibling.getFileName();\n    System.out.println(\"The sibling's file name: \" + fileName);\n    System.out.print(\"The sibling's path components: \");\n    for (Path p : sibling) {\n        System.out.print(p + \" \");\n    }\n    System.out.println();\n    Path changedExtension = sibling.getParent().resolve(sibling.getFileName().toString().replace(\".txt\", \".bak\"));\n    System.out.println(\"Changing the extension: \" + changedExtension);\n}\n","name":"main","className":"PathDemo","variables":{"p":2,"parent":3,"fileName":2,"inputPath":3,"sibling":6,"absolutePath":3,"Paths":1,"changedExtension":2},"constants":{"\"The sibling's file name: \"":1,"\" \"":1,"\"The sibling's path components: \"":1,"\"Changing the extension: \"":1,"\"Its parent: \"":1,"\".bak\"":1,"\"Relative path: \"":1,"\"input.txt\"":1,"\"A sibling: \"":1,"\".txt\"":1,"\"Absolute path: \"":1,"\"output.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":15,"modifier":9}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   */\npublic BankAccount(int anAccountNumber) {\n    accountNumber = anAccountNumber;\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":1,"balance":1,"accountNumber":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance anAccountNumber the account number for this account","comments":"\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   */\npublic BankAccount(int anAccountNumber, double initialBalance) {\n    accountNumber = anAccountNumber;\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":1,"balance":1,"initialBalance":1,"accountNumber":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance anAccountNumber the account number for this account initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the account number of this bank account.\n      @return the account number\n   */\npublic int getAccountNumber() {\n    return accountNumber;\n}\n","name":"getAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"constants":{},"javaDoc":"Gets the account number of this bank account the account number","comments":"\n      Gets the account number of this bank account.\n      @return the account number\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankData","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a BankData object that is not associated with a file.\n   */\npublic BankData() {\n    file = null;\n}\n","name":"BankData","className":"BankData","variables":{"file":1},"constants":{"null":1},"javaDoc":"Constructs a BankData object that is not associated with a file","comments":"\n      Constructs a BankData object that is not associated with a file.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Opens the data file.\n      @param filename the name of the file containing bank\n      account information\n   */\npublic void open(String filename) throws IOException {\n    if (file != null) {\n        file.close();\n    }\n    file = new RandomAccessFile(filename, \"rw\");\n}\n","name":"open","className":"BankData","variables":{"file":3,"filename":1},"constants":{"null":1,"\"rw\"":1},"javaDoc":"Opens the data file filename the name of the file containing bank account information","comments":"\n      Opens the data file.\n      @param filename the name of the file containing bank\n      account information\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"length":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"CastExpr":1,"NameExpr":4,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the number of accounts in the file.\n      @return the number of accounts\n   */\npublic int size() throws IOException {\n    return (int) (file.length() / RECORD_SIZE);\n}\n","name":"size","className":"BankData","variables":{"file":1,"RECORD_SIZE":1},"constants":{},"javaDoc":"Gets the number of accounts in the file the number of accounts","comments":"\n      Gets the number of accounts in the file.\n      @return the number of accounts\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":1,"NameExpr":5,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Closes the data file.\n   */\npublic void close() throws IOException {\n    if (file != null) {\n        file.close();\n    }\n    file = null;\n}\n","name":"close","className":"BankData","variables":{"file":3},"constants":{"null":2},"javaDoc":"Closes the data file","comments":"\n      Closes the data file.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{"readDouble":1,"readInt":1,"seek":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"double":1,"int":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":13,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Reads a bank account record.\n      @param n the index of the account in the data file\n      @return a bank account object initialized with the file data\n   */\npublic BankAccount read(int n) throws IOException {\n    file.seek(n * RECORD_SIZE);\n    int accountNumber = file.readInt();\n    double balance = file.readDouble();\n    return new BankAccount(accountNumber, balance);\n}\n","name":"read","className":"BankData","variables":{"file":3,"RECORD_SIZE":1,"balance":2,"accountNumber":2,"n":1},"constants":{},"javaDoc":"Reads a bank account record n the index of the account in the data file a bank account object initialized with the file data","comments":"\n      Reads a bank account record.\n      @param n the index of the account in the data file\n      @return a bank account object initialized with the file data\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"size":1,"readInt":1,"seek":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":15,"UnaryExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Finds the position of a bank account with a given number.\n      @param accountNumber the number to find\n      @return the position of the account with the given number, \n      or -1 if there is no such account\n   */\npublic int find(int accountNumber) throws IOException {\n    for (int i = 0; i < size(); i++) {\n        file.seek(i * RECORD_SIZE);\n        int a = file.readInt();\n        if (a == accountNumber) {\n            return i;\n        }\n    // Found a match            \n    }\n    // No match in the entire file\n    return -1;\n}\n","name":"find","className":"BankData","variables":{"a":2,"file":2,"RECORD_SIZE":1,"i":5,"accountNumber":1},"constants":{"0":1,"1":1},"javaDoc":"Finds the position of a bank account with a given number accountNumber the number to find the position of the account with the given number or -1 if there is no such account","comments":"Found a match No match in the entire file \n      Finds the position of a bank account with a given number.\n      @param accountNumber the number to find\n      @return the position of the account with the given number, \n      or -1 if there is no such account\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","BankAccount"],"returnType":"void","methodCalls":{"writeInt":1,"getBalance":1,"getAccountNumber":1,"seek":1,"writeDouble":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":17,"MethodCallExpr":5},"statements":{"ExpressionStmt":3},"text":"/**\n      Writes a bank account record to the data file.\n      @param n the index of the account in the data file\n      @param account the account to write\n   */\npublic void write(int n, BankAccount account) throws IOException {\n    file.seek(n * RECORD_SIZE);\n    file.writeInt(account.getAccountNumber());\n    file.writeDouble(account.getBalance());\n}\n","name":"write","className":"BankData","variables":{"file":3,"RECORD_SIZE":1,"n":1,"account":2},"constants":{},"javaDoc":"Writes a bank account record to the data file n the index of the account in the data file account the account to write","comments":"\n      Writes a bank account record to the data file.\n      @param n the index of the account in the data file\n      @param account the account to write\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"read":1,"nextInt":1,"nextDouble":1,"getBalance":1,"size":1,"find":1,"deposit":1,"equalsIgnoreCase":1,"write":1,"open":1,"System.out.print":3,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Scanner":1,"boolean":1,"BankData":1,"double":1,"BankAccount":1,"String":1,"int":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":8,"BooleanLiteralExpr":2,"BinaryExpr":2,"NameExpr":74,"StringLiteralExpr":7,"FieldAccessExpr":6,"UnaryExpr":1,"MethodCallExpr":16,"AssignExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":1,"BlockStmt":5,"ExpressionStmt":18},"text":"public static void main(String[] args) throws IOException {\n    try (Scanner in = new Scanner(System.in);\n        BankData data = new BankData()) {\n        data.open(\"bank.dat\");\n        boolean done = false;\n        while (!done) {\n            System.out.print(\"Account number: \");\n            int accountNumber = in.nextInt();\n            System.out.print(\"Amount to deposit: \");\n            double amount = in.nextDouble();\n            int position = data.find(accountNumber);\n            BankAccount account;\n            if (position >= 0) {\n                account = data.read(position);\n                account.deposit(amount);\n                System.out.println(\"New balance: \" + account.getBalance());\n            } else // Add account\n            {\n                account = new BankAccount(accountNumber, amount);\n                position = data.size();\n                System.out.println(\"Adding new account.\");\n            }\n            data.write(position, account);\n            System.out.print(\"Done? (Y/N) \");\n            String input = in.next();\n            if (input.equalsIgnoreCase(\"Y\")) {\n                done = true;\n            }\n        }\n    }\n}\n","name":"main","className":"BankSimulator","variables":{"input":2,"amount":2,"data":6,"in":4,"position":3,"accountNumber":2,"done":3,"account":5},"constants":{"0":1,"\"Done? (Y/N) \"":1,"\"Account number: \"":1,"\"Adding new account.\"":1,"\"New balance: \"":1,"false":1,"true":1,"\"Amount to deposit: \"":1,"\"bank.dat\"":1,"\"Y\"":1},"javaDoc":"","comments":"Add account ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"toLowerCase":1,"readAllLines":1,"sort":1,"toList":1,"copyOf":1,"delete":2,"getBytes":1,"filter":1,"contains":1,"size":1,"get":7,"readAllBytes":2,"limit":1,"exists":2,"toString":1,"copy":1,"lines":1,"write":3,"collect":1,"System.out.println":8},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables"],"types":{"Path":6,"byte[]":2,"String":2,"Stream<String>":1,"long":1,"int":2,"List<String>":2},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":16,"ArrayAccessExpr":2,"BinaryExpr":27,"LambdaExpr":1,"NameExpr":182,"StringLiteralExpr":23,"UnaryExpr":1,"AssignExpr":3,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":9,"EnclosedExpr":1,"MethodCallExpr":39},"statements":{"IfStmt":2,"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ExpressionStmt":34},"text":"public static void main(String[] args) throws IOException {\n    // Getting the size of a file\n    Path input = Paths.get(\"UsefulFileOperations.java\");\n    long size = Files.size(input);\n    System.out.println(\"Size of \" + input + \": \" + size + \" bytes\");\n    // Reading all lines\n    List<String> lines = Files.readAllLines(input);\n    System.out.println(\"Line 11: \" + lines.get(10));\n    // Reading all bytes\n    byte[] bytes = Files.readAllBytes(input);\n    byte[] firstTen = Arrays.copyOf(bytes, 10);\n    System.out.println(\"First ten bytes: \" + Arrays.toString(firstTen));\n    // Writing lines\n    Collections.sort(lines);\n    Path output1 = Paths.get(input + \".sorted\");\n    Files.write(output1, lines);\n    System.out.println(\"Sorting the lines of \" + input + \" yields \" + output1);\n    // Writing bytes\n    for (int i = 0; i < bytes.length; i++) {\n        bytes[i] = (byte) (bytes[i] + 3);\n    }\n    Path output2 = Paths.get(input + \".caesar\");\n    Files.write(output2, bytes);\n    System.out.println(\"The Caesar encryption of \" + input + \" is in \" + output2);\n    // Reading a file into a string\n    String contents = new String(Files.readAllBytes(input), \"UTF-8\");\n    // Writing a string to a file\n    Path output3 = Paths.get(input + \".lowercase\");\n    contents = contents.toLowerCase();\n    Files.write(output3, contents.getBytes(\"UTF-8\"));\n    System.out.println(\"The lowercase of \" + input + \" is in \" + output3);\n    String target = \";\";\n    final int MAX_LINES = 10;\n    List<String> result = null;\n    try (Stream<String> lineStream = Files.lines(input)) {\n        result = lineStream.filter( s -> s.contains(target)).limit(MAX_LINES).collect(Collectors.toList());\n    }\n    System.out.println(\"The first ten lines containing a semicolon: \" + result);\n    // Copying and moving\n    Path output4 = Paths.get(input + \".copied\");\n    if (Files.exists(output4)) {\n        Files.delete(output4);\n    }\n    Files.copy(input, output4);\n    Path output5 = Paths.get(output4 + \".moved\");\n    if (Files.exists(output5)) {\n        Files.delete(output5);\n    }\n    Files.move(output4, output5);\n    System.out.println(input + \" was copied to \" + output4 + \" which was moved to \" + output5);\n}\n","name":"main","className":"UsefulFileOperations","variables":{"output3":2,"Collectors":1,"output4":3,"output1":2,"output2":2,"output5":2,"i":5,"lineStream":2,"target":1,"result":3,"input":10,"s":2,"size":2,"firstTen":1,"contents":4,"bytes":3,"MAX_LINES":1,"Paths":6,"Files":14,"lines":2,"Arrays":2,"Collections":1},"constants":{"\".moved\"":1,"\"Size of \"":1,"\" is in \"":2,"\"Line 11: \"":1,"\" was copied to \"":1,"\".copied\"":1,"\": \"":1,"\" which was moved to \"":1,"\".sorted\"":1,"\".caesar\"":1,"\"The Caesar encryption of \"":1,"\" bytes\"":1,"\"The lowercase of \"":1,"10":3,"\".lowercase\"":1,"\" yields \"":1,"\";\"":1,"\"First ten bytes: \"":1,"0":1,"\"UsefulFileOperations.java\"":1,"\"UTF-8\"":2,"\"The first ten lines containing a semicolon: \"":1,"3":1,"null":1,"\"Sorting the lines of \"":1},"javaDoc":"","comments":"Getting the size of a file Reading all lines Reading all bytes Writing lines Writing bytes Reading a file into a string Writing a string to a file Copying and moving ","isEmpty":false,"hasInnerClass":false,"lineCount":33,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getParent":2,"toAbsolutePath":1,"replace":2,"toList":2,"list":2,"filter":1,"contains":1,"get":1,"toString":1,"collect":2,"map":2,"getFileName":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Path":2,"Stream<Path>":2,"List<Path>":1,"List<String>":1},"expressions":{"VariableDeclarationExpr":6,"BinaryExpr":4,"LambdaExpr":3,"NameExpr":62,"StringLiteralExpr":9,"FieldAccessExpr":2,"MethodCallExpr":20},"statements":{"TryStmt":2,"BlockStmt":2,"ExpressionStmt":9},"text":"public static void main(String[] args) throws IOException {\n    Path startingDirectory = Paths.get(\"VisitingDirectories.java\").toAbsolutePath();\n    Path grandParent = startingDirectory.getParent().getParent();\n    try (Stream<Path> entries = Files.list(grandParent)) {\n        List<Path> paths = entries.collect(Collectors.toList());\n        System.out.println(\"Entries in \" + grandParent + \": \" + paths);\n    }\n    try (Stream<Path> entries = Files.list(grandParent)) {\n        List<String> result = entries.map( p -> p.getFileName().toString()).filter( s -> s.contains(\"section_\")).map( s -> s.replace(\"section_\", \"Section \").replace(\"_\", \".\")).collect(Collectors.toList());\n        System.out.println(\"Sections with sample code: \" + result);\n    }\n}\n","name":"main","className":"VisitingDirectories","variables":{"startingDirectory":2,"grandParent":2,"result":2,"p":2,"Collectors":2,"entries":4,"s":4,"paths":2,"Paths":1,"Files":2},"constants":{"\"_\"":1,"\".\"":1,"\"Sections with sample code: \"":1,"\"VisitingDirectories.java\"":1,"\"Entries in \"":1,"\": \"":1,"\"section_\"":2,"\"Section \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getParent":1,"createTempDirectory":1,"get":3,"isRegularFile":1,"exists":2,"createDirectory":1,"createTempFile":1,"delete":2,"createFile":1,"isDirectory":1,"System.out.println":6},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Path":4},"expressions":{"VariableDeclarationExpr":4,"BinaryExpr":10,"NameExpr":84,"StringLiteralExpr":12,"FieldAccessExpr":6,"MethodCallExpr":20},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) throws IOException {\n    // Creating a directory and a file inside it\n    Files.createDirectory(Paths.get(\"subdir\"));\n    Path testPath = Paths.get(\"subdir/test.txt\");\n    Files.createFile(testPath);\n    // Checking that the file exists\n    System.out.println(testPath + \" exists: \" + Files.exists(testPath));\n    // But this one doesn't exist\n    Path badPath = Paths.get(\"subdir/bad\");\n    System.out.println(badPath + \" exists: \" + Files.exists(badPath));\n    // Confirming that it's a file and not a directory\n    System.out.println(testPath + \" is a file: \" + Files.isRegularFile(testPath));\n    System.out.println(testPath + \" is a directory: \" + Files.isDirectory(testPath));\n    // Deleting what was created\n    Files.delete(testPath);\n    Files.delete(testPath.getParent());\n    Path tempFile = Files.createTempFile(\"bigjava\", \".txt\");\n    System.out.println(\"Created a temporary file \" + tempFile);\n    Path tempDir = Files.createTempDirectory(\"bigjava\");\n    System.out.println(\"Created a temporary directory \" + tempDir);\n}\n","name":"main","className":"CreatingAndDeleting","variables":{"testPath":5,"badPath":2,"tempFile":2,"tempDir":2,"Paths":3,"Files":10},"constants":{"\" is a file: \"":1,"\"subdir/test.txt\"":1,"\"subdir/bad\"":1,"\"Created a temporary file \"":1,"\"Created a temporary directory \"":1,"\" is a directory: \"":1,"\"subdir\"":1,"\" exists: \"":2,"\"bigjava\"":2,"\".txt\"":1},"javaDoc":"","comments":"Creating a directory and a file inside it Checking that the file exists But this one doesn't exist Confirming that it's a file and not a directory Deleting what was created ","isEmpty":false,"hasInnerClass":false,"lineCount":14,"modifier":9}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   */\npublic BankAccount(int anAccountNumber) {\n    accountNumber = anAccountNumber;\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":1,"balance":1,"accountNumber":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance anAccountNumber the account number for this account","comments":"\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   */\npublic BankAccount(int anAccountNumber, double initialBalance) {\n    accountNumber = anAccountNumber;\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":1,"balance":1,"initialBalance":1,"accountNumber":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance anAccountNumber the account number for this account initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the account number of this bank account.\n      @return the account number\n   */\npublic int getAccountNumber() {\n    return accountNumber;\n}\n","name":"getAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"constants":{},"javaDoc":"Gets the account number of this bank account the account number","comments":"\n      Gets the account number of this bank account.\n      @return the account number\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Bank","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank with no bank accounts.\n   */\npublic Bank() {\n    accounts = new ArrayList<>();\n}\n","name":"Bank","className":"Bank","variables":{"accounts":1},"constants":{},"javaDoc":"Constructs a bank with no bank accounts","comments":"\n      Constructs a bank with no bank accounts.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["BankAccount"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds an account to this bank.\n      @param a the account to add\n   */\npublic void addAccount(BankAccount a) {\n    accounts.add(a);\n}\n","name":"addAccount","className":"Bank","variables":{"accounts":1},"constants":{},"javaDoc":"Adds an account to this bank a the account to add","comments":"\n      Adds an account to this bank.\n      @param a the account to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{"getAccountNumber":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ReturnStmt":2},"text":"/**\n      Finds a bank account with a given number.\n      @param accountNumber the number to find\n      @return the account with the given number, or null if there\n      is no such account\n   */\npublic BankAccount find(int accountNumber) {\n    for (BankAccount a : accounts) {\n        if (// Found a match\n        a.getAccountNumber() == accountNumber) {\n            return a;\n        }\n    }\n    // No match in the entire array list\n    return null;\n}\n","name":"find","className":"Bank","variables":{"a":3,"accounts":1,"accountNumber":1},"constants":{"null":1},"javaDoc":"Finds a bank account with a given number accountNumber the number to find the account with the given number or null if there is no such account","comments":"Found a match No match in the entire array list \n      Finds a bank account with a given number.\n      @param accountNumber the number to find\n      @return the account with the given number, or null if there\n      is no such account\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":2,"find":2,"writeObject":1,"exists":1,"deposit":1,"getAccountNumber":2,"addAccount":2,"readObject":1,"System.out.println":2},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"Bank":1,"BankAccount":1,"ObjectOutputStream":1,"File":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":7,"VariableDeclarationExpr":5,"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":52,"CastExpr":1,"FieldAccessExpr":2,"MethodCallExpr":14,"AssignExpr":3},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":2,"ExpressionStmt":12},"text":"public static void main(String[] args) throws IOException, ClassNotFoundException {\n    Bank firstBankOfJava;\n    File f = new File(\"bank.dat\");\n    if (f.exists()) {\n        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(f))) {\n            firstBankOfJava = (Bank) in.readObject();\n        }\n    } else {\n        firstBankOfJava = new Bank();\n        firstBankOfJava.addAccount(new BankAccount(1001, 20000));\n        firstBankOfJava.addAccount(new BankAccount(1015, 10000));\n    }\n    // Deposit some money\n    BankAccount a = firstBankOfJava.find(1001);\n    a.deposit(100);\n    System.out.println(a.getAccountNumber() + \": \" + a.getBalance());\n    a = firstBankOfJava.find(1015);\n    System.out.println(a.getAccountNumber() + \": \" + a.getBalance());\n    try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f))) {\n        out.writeObject(firstBankOfJava);\n    }\n}\n","name":"main","className":"SerialDemo","variables":{"a":7,"in":2,"firstBankOfJava":7,"f":4,"out":2},"constants":{"100":1,"1015":2,"20000":1,"1001":2,"10000":1,"\": \"":2,"\"bank.dat\"":1},"javaDoc":"","comments":"Deposit some money ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":8,"parseInt":1,"nextLine":1,"equals":7,"push":5,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Integer":2,"Scanner":1,"boolean":1,"String":1,"Stack<Integer>":1,"Stack":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":6,"BooleanLiteralExpr":2,"BinaryExpr":6,"NameExpr":85,"StringLiteralExpr":8,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":24,"AssignExpr":1},"statements":{"IfStmt":5,"WhileStmt":1,"BlockStmt":7,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    Stack<Integer> results = new Stack<>();\n    System.out.println(\"Enter one number or operator per line, Q to quit. \");\n    boolean done = false;\n    while (!done) {\n        String input = in.nextLine();\n        if (input.equals(\"+\")) {\n            results.push(results.pop() + results.pop());\n        } else if (input.equals(\"-\")) {\n            Integer arg2 = results.pop();\n            results.push(results.pop() - arg2);\n        } else if (input.equals(\"*\") || input.equals(\"x\")) {\n            results.push(results.pop() * results.pop());\n        } else if (input.equals(\"/\")) {\n            Integer arg2 = results.pop();\n            results.push(results.pop() / arg2);\n        } else if (input.equals(\"Q\") || input.equals(\"q\")) {\n            done = true;\n        } else {\n            // Not an operator--push the input value\n            results.push(Integer.parseInt(input));\n        }\n        System.out.println(results);\n    }\n}\n","name":"main","className":"Calculator","variables":{"Integer":1,"input":8,"arg2":4,"in":2,"results":14,"done":3},"constants":{"\"Q\"":1,"\"q\"":1,"\"/\"":1,"\"Enter one number or operator per line, Q to quit. \"":1,"\"-\"":1,"false":1,"true":1,"\"+\"":1,"\"*\"":1,"\"x\"":1},"javaDoc":"","comments":"If the command is an operator pop the arguments and push the result Not an operator--push the input value ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"Maze","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a maze from a string describing its contents.\n      @param contents strings consisting of * and spaces\n   */\npublic Maze(String[] contents) {\n    cells = contents;\n}\n","name":"Maze","className":"Maze","variables":{"cells":1,"contents":1},"constants":{},"javaDoc":"Constructs a maze from a string describing its contents contents strings consisting of and spaces","comments":"\n      Constructs a maze from a string describing its contents.\n      @param contents strings consisting of * and spaces\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"ArrayList<Path>","methodCalls":{"add":4,"extend":1,"isValid":4},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Path":1,"ArrayList":1,"ArrayList<Path>":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":53,"FieldAccessExpr":4,"MethodCallExpr":9},"statements":{"IfStmt":4,"BlockStmt":5,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n      Gets all paths emanating from a position in the maze.\n      @param row the row of the position\n      @param column the column of the position\n      @return all paths emanating from the position\n   */\npublic ArrayList<Path> pathsFrom(int row, int column) {\n    ArrayList<Path> paths = new ArrayList<>();\n    if (isValid(row - 1, column)) {\n        paths.add(new Path(row, column, Path.NORTH));\n    }\n    if (isValid(row, column + 1)) {\n        paths.add(new Path(row, column, Path.EAST));\n    }\n    if (isValid(row + 1, column)) {\n        paths.add(new Path(row, column, Path.SOUTH));\n    }\n    if (isValid(row, column - 1)) {\n        paths.add(new Path(row, column, Path.WEST));\n    }\n    for (Path p : paths) {\n        extend(p);\n    }\n    return paths;\n}\n","name":"pathsFrom","className":"Maze","variables":{"p":1,"paths":7,"column":6,"row":6},"constants":{"1":4},"javaDoc":"Gets all paths emanating from a position in the maze row the row of the position column the column of the position all paths emanating from the position","comments":"\n      Gets all paths emanating from a position in the maze.\n      @param row the row of the position\n      @param column the column of the position\n      @return all paths emanating from the position\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":["Path"],"returnType":"void","methodCalls":{"move":1,"getNextRow":2,"getEndingRow":1,"getEndingColumn":1,"isValid":2,"countNeighbors":1,"isExit":1,"turn":3,"getNextColumn":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":2,"BinaryExpr":2,"NameExpr":52,"UnaryExpr":3,"MethodCallExpr":14,"AssignExpr":5},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":5,"ExpressionStmt":12},"text":"/**\n      Extends this path to the next exit, intersection, or dead end.\n      @param p the path to extend\n   */\nprivate void extend(Path p) {\n    boolean done = false;\n    while (!done) {\n        p.move();\n        int row = p.getEndingRow();\n        int column = p.getEndingColumn();\n        if (isExit(row, column) || countNeighbors(row, column) != 2) {\n            // Either a straight path or a turn\n            done = true;\n        } else {\n            row = p.getNextRow();\n            column = p.getNextColumn();\n            if (!isValid(row, column)) {\n                p.turn();\n                row = p.getNextRow();\n                column = p.getNextColumn();\n                if (!isValid(row, column)) {\n                    p.turn();\n                    p.turn();\n                }\n            }\n        }\n    }\n}\n","name":"extend","className":"Maze","variables":{"p":10,"column":3,"row":3,"done":3},"constants":{"2":1,"false":1,"true":1},"javaDoc":"Extends this path to the next exit intersection or dead end p the path to extend","comments":"Either a straight path or a turn \n      Extends this path to the next exit, intersection, or dead end.\n      @param p the path to extend\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"ArrayAccessExpr":2,"BinaryExpr":11,"NameExpr":16,"FieldAccessExpr":1,"CharLiteralExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether a position is an exit.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is an exit\n   */\npublic boolean isExit(int row, int column) {\n    return (row == 0 || row == cells.length - 1 || column == 0 || column == cells[row].length() - 1) && cells[row].charAt(column) == ' ';\n}\n","name":"isExit","className":"Maze","variables":{"cells":2,"column":2,"row":4},"constants":{"0":2,"1":2,"' '":1},"javaDoc":"Checks whether a position is an exit row the row of the position column the column of the position true if the position is an exit","comments":"\n      Checks whether a position is an exit.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is an exit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{"countNeighbors":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether a position is a dead end.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is a dead end\n   */\npublic boolean isDeadEnd(int row, int column) {\n    return countNeighbors(row, column) == 1;\n}\n","name":"isDeadEnd","className":"Maze","variables":{},"constants":{"1":1},"javaDoc":"Checks whether a position is a dead end row the row of the position column the column of the position true if the position is a dead end","comments":"\n      Checks whether a position is a dead end.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is a dead end\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"ArrayAccessExpr":2,"BinaryExpr":9,"NameExpr":16,"FieldAccessExpr":1,"CharLiteralExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether a position is within the maze and not a wall.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is valid\n   */\nprivate boolean isValid(int row, int column) {\n    return 0 <= row && row < cells.length && 0 <= column && column < cells[row].length() && cells[row].charAt(column) == ' ';\n}\n","name":"isValid","className":"Maze","variables":{"cells":2,"column":2,"row":4},"constants":{"0":2,"' '":1},"javaDoc":"Checks whether a position is within the maze and not a wall row the row of the position column the column of the position true if the position is valid","comments":"\n      Checks whether a position is within the maze and not a wall.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is valid\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"isValid":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":21,"UnaryExpr":4,"MethodCallExpr":4},"statements":{"IfStmt":4,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Counts the neighbors of a position.\n      @param row the row of the position\n      @param column the column of the position\n      @return the number of neighbors in the four compass directions\n      that are within the maze and not walls.\n   */\nprivate int countNeighbors(int row, int column) {\n    int count = 0;\n    if (isValid(row - 1, column)) {\n        count++;\n    }\n    if (isValid(row + 1, column)) {\n        count++;\n    }\n    if (isValid(row, column - 1)) {\n        count++;\n    }\n    if (isValid(row, column + 1)) {\n        count++;\n    }\n    return count;\n}\n","name":"countNeighbors","className":"Maze","variables":{"count":6,"column":2,"row":2},"constants":{"0":1,"1":4},"javaDoc":"Counts the neighbors of a position row the row of the position column the column of the position the number of neighbors in the four compass directions that are within the maze and not walls","comments":"\n      Counts the neighbors of a position.\n      @param row the row of the position\n      @param column the column of the position\n      @return the number of neighbors in the four compass directions\n      that are within the maze and not walls.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"solve":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Maze":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayInitializerExpr":1,"StringLiteralExpr":13,"NameExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Maze maze = new Maze(new String[] { \"*****************************\", \"** ***                      *\", \"** *** * ********************\", \"** *** *         *          *\", \"** *** * *******   **** *****\", \"**     * ************** *****\", \"****** ******* *******  *****\", \"******         ******* ******\", \"*      ******* ******* ******\", \"* **** ******* **           *\", \"*    ********* ******* ******\", \"* ****         ***     ******\", \"************** **************\" });\n    solve(maze, 5, 8);\n}\n","name":"main","className":"MazeSolver","variables":{"maze":1},"constants":{"\"* ****         ***     ******\"":1,"\"******         ******* ******\"":1,"\"**     * ************** *****\"":1,"\"*      ******* ******* ******\"":1,"\"** *** * ********************\"":1,"\"* **** ******* **           *\"":1,"\"*****************************\"":1,"\"** *** *         *          *\"":1,"\"****** ******* *******  *****\"":1,"\"************** **************\"":1,"\"*    ********* ******* ******\"":1,"5":1,"\"** *** * *******   **** *****\"":1,"8":1,"\"** ***                      *\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["Maze","int","int"],"returnType":"void","methodCalls":{"pop":1,"isDeadEnd":1,"size":1,"getEndingRow":1,"getEndingColumn":1,"isOpposite":1,"isExit":1,"pathsFrom":2,"push":2,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Path":3,"Stack<Path>":1,"int":2,"Stack":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":2,"NameExpr":60,"StringLiteralExpr":3,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":14},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":7,"ForeachStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n      Traverses a maze, printing out a path to the exit.\n      @param maze the maze\n      @param param the row of the starting position\n      @param param the column of the starting position\n   */\npublic static void solve(Maze maze, int row, int column) {\n    Stack<Path> s = new Stack<>();\n    for (Path p : maze.pathsFrom(row, column)) {\n        s.push(p);\n    }\n    while (s.size() > 0) {\n        Path p = s.pop();\n        System.out.println(\"Following \" + p);\n        int r = p.getEndingRow();\n        int c = p.getEndingColumn();\n        if (maze.isExit(r, c)) {\n            System.out.println(\"Exit!\");\n            return;\n        } else if (maze.isDeadEnd(r, c)) {\n            System.out.println(\"Dead end\");\n        } else {\n            for (Path p2 : maze.pathsFrom(r, c)) {\n                if (!p2.isOpposite(p)) {\n                    s.push(p2);\n                }\n            }\n        }\n    }\n}\n","name":"solve","className":"MazeSolver","variables":{"p":5,"r":1,"p2":2,"s":5,"c":1,"maze":4},"constants":{"0":1,"\"Following \"":1,"\"Dead end\"":1,"\"Exit!\"":1},"javaDoc":"Traverses a maze printing out a path to the exit maze the maze param the row of the starting position param the column of the starting position","comments":"\n      Traverses a maze, printing out a path to the exit.\n      @param maze the maze\n      @param param the row of the starting position\n      @param param the column of the starting position\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int","int","int"],"returnType":"Path","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"AssignExpr":6},"statements":{"ExpressionStmt":6},"text":"/**\n      Constructs a path with a given position and direction\n      @param row the starting row\n      @param column the starting column\n      @param direction the starting direction\n   */\npublic Path(int row, int column, int direction) {\n    startingRow = row;\n    startingColumn = column;\n    startingDirection = direction;\n    endingRow = row;\n    endingColumn = column;\n    endingDirection = direction;\n}\n","name":"Path","className":"Path","variables":{"startingColumn":1,"startingDirection":1,"endingDirection":1,"column":2,"endingRow":1,"row":2,"endingColumn":1,"startingRow":1,"direction":2},"constants":{},"javaDoc":"Constructs a path with a given position and direction row the starting row column the starting column direction the starting direction","comments":"\n      Constructs a path with a given position and direction\n      @param row the starting row\n      @param column the starting column\n      @param direction the starting direction\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getNextRow":1,"getNextColumn":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the ending position of this path one unit in the\n      current direction.\n   */\npublic void move() {\n    endingRow = getNextRow();\n    endingColumn = getNextColumn();\n}\n","name":"move","className":"Path","variables":{"endingRow":1,"endingColumn":1},"constants":{},"javaDoc":"Moves the ending position of this path one unit in the current direction","comments":"\n      Moves the ending position of this path one unit in the\n      current direction.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":3,"EnclosedExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Turns the ending direction of this path clockwise.\n   */\npublic void turn() {\n    final int DIRECTIONS = 4;\n    endingDirection = (endingDirection + 1) % DIRECTIONS;\n}\n","name":"turn","className":"Path","variables":{"endingDirection":2,"DIRECTIONS":2},"constants":{"1":1,"4":1},"javaDoc":"Turns the ending direction of this path clockwise","comments":"\n      Turns the ending direction of this path clockwise.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the ending row of this path.\n      @return the ending row\n   */\npublic int getEndingRow() {\n    return endingRow;\n}\n","name":"getEndingRow","className":"Path","variables":{"endingRow":1},"constants":{},"javaDoc":"Gets the ending row of this path the ending row","comments":"\n      Gets the ending row of this path.\n      @return the ending row\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the ending column of this path.\n      @return the ending column\n   */\npublic int getEndingColumn() {\n    return endingColumn;\n}\n","name":"getEndingColumn","className":"Path","variables":{"endingColumn":1},"constants":{},"javaDoc":"Gets the ending column of this path the ending column","comments":"\n      Gets the ending column of this path.\n      @return the ending column\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":3},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the next row of this path if it continues in the ending\n      direction.\n      @return the next row\n   */\npublic int getNextRow() {\n    return endingRow + ROW_OFFSETS[endingDirection];\n}\n","name":"getNextRow","className":"Path","variables":{"endingDirection":1,"ROW_OFFSETS":1,"endingRow":1},"constants":{},"javaDoc":"Gets the next row of this path if it continues in the ending direction the next row","comments":"\n      Gets the next row of this path if it continues in the ending\n      direction.\n      @return the next row\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":3},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the next column of this path if it continues in the ending\n      direction.\n      @return the next row\n   */\npublic int getNextColumn() {\n    return endingColumn + COLUMN_OFFSETS[endingDirection];\n}\n","name":"getNextColumn","className":"Path","variables":{"endingDirection":1,"endingColumn":1,"COLUMN_OFFSETS":1},"constants":{},"javaDoc":"Gets the next column of this path if it continues in the ending direction the next row","comments":"\n      Gets the next column of this path if it continues in the ending\n      direction.\n      @return the next row\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":5,"NameExpr":4,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether two directions are opposites of each other.\n      @param dir1 a direction between 0 and 3\n      @param dir2 a direction between 0 and 3\n      @return true if they are opposites (i.e. 0 and 2, 1 and 3,\n      2 and 0, or 3 and 1)\n   */\nprivate static boolean isOpposite(int dir1, int dir2) {\n    return dir1 != dir2 && (dir1 + dir2) % 2 == 0;\n}\n","name":"isOpposite","className":"Path","variables":{"dir2":2,"dir1":2},"constants":{"0":1,"2":1},"javaDoc":"Checks whether two directions are opposites of each other dir1 a direction between 0 and 3 dir2 a direction between 0 and 3 true if they are opposites (i e 0 and 2 1 and 3 2 and 0 or 3 and 1)","comments":"\n      Checks whether two directions are opposites of each other.\n      @param dir1 a direction between 0 and 3\n      @param dir2 a direction between 0 and 3\n      @return true if they are opposites (i.e. 0 and 2, 1 and 3,\n      2 and 0, or 3 and 1)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["Path"],"returnType":"boolean","methodCalls":{"isOpposite":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":14,"FieldAccessExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this path is the opposite of another one.\n      @param other another path that ends where this path starts\n      @return true if other is the opposite of this path\n   */\npublic boolean isOpposite(Path other) {\n    return startingRow == other.endingRow && startingColumn == other.endingColumn && isOpposite(startingDirection, other.endingDirection);\n}\n","name":"isOpposite","className":"Path","variables":{"startingColumn":1,"startingRow":1},"constants":{},"javaDoc":"Checks whether this path is the opposite of another one other another path that ends where this path starts true if other is the opposite of this path","comments":"\n      Checks whether this path is the opposite of another one.\n      @param other another path that ends where this path starts\n      @return true if other is the opposite of this path\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":14,"StringLiteralExpr":8,"NameExpr":17,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public String toString() {\n    String result = \"(\" + startingRow + \",\" + startingColumn + \")\" + \"NESW\".charAt(startingDirection);\n    if (endingRow != startingRow || endingColumn != startingColumn) {\n        result = result + \"<->(\" + endingRow + \",\" + endingColumn + \")\" + \"NESW\".charAt(endingDirection);\n    }\n    return result;\n}\n","name":"toString","className":"Path","variables":{"result":4,"startingColumn":2,"endingRow":2,"endingColumn":2,"startingRow":2},"constants":{"\"<->(\"":1,"\"NESW\"":2,"\",\"":2,"\")\"":2,"\"(\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":3,"add":2,"addLast":4,"listIterator":1,"remove":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"LinkedList<String>":1,"ListIterator<String>":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":44,"StringLiteralExpr":7,"FieldAccessExpr":2,"MethodCallExpr":13},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    LinkedList<String> staff = new LinkedList<>();\n    staff.addLast(\"Diana\");\n    staff.addLast(\"Harry\");\n    staff.addLast(\"Romeo\");\n    staff.addLast(\"Tom\");\n    // | in the comments indicates the iterator position\n    // |DHRT\n    ListIterator<String> iterator = staff.listIterator();\n    // D|HRT\n    iterator.next();\n    // DH|RT\n    iterator.next();\n    // Add more elements after second element\n    // DHJ|RT\n    iterator.add(\"Juliet\");\n    // DHJN|RT\n    iterator.add(\"Nina\");\n    // DHJNR|T\n    iterator.next();\n    // Remove last traversed element \n    // DHJN|T\n    iterator.remove();\n    // Print all elements\n    System.out.println(staff);\n    System.out.println(\"Expected: [Diana, Harry, Juliet, Nina, Tom]\");\n}\n","name":"main","className":"ListDemo","variables":{"iterator":7,"staff":6},"constants":{"\"Nina\"":1,"\"Tom\"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Romeo\"":1,"\"Expected: [Diana, Harry, Juliet, Nina, Tom]\"":1},"javaDoc":"","comments":"| in the comments indicates the iterator position Add more elements after second element Remove last traversed element Print all elements |DHRT D|HRT DH|RT DHJ|RT DHJN|RT DHJNR|T DHJN|T ","isEmpty":false,"hasInnerClass":false,"lineCount":18,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":8,"size":1,"remove":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"PriorityQueue":1,"PriorityQueue<WorkOrder>":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":9,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":35,"StringLiteralExpr":8,"FieldAccessExpr":1,"MethodCallExpr":11},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    PriorityQueue<WorkOrder> q = new PriorityQueue<>();\n    q.add(new WorkOrder(3, \"Shampoo carpets\"));\n    q.add(new WorkOrder(7, \"Empty trash\"));\n    q.add(new WorkOrder(8, \"Water plants\"));\n    q.add(new WorkOrder(10, \"Remove pencil sharpener shavings\"));\n    q.add(new WorkOrder(6, \"Replace light bulb\"));\n    q.add(new WorkOrder(1, \"Fix broken sink\"));\n    q.add(new WorkOrder(9, \"Clean coffee maker\"));\n    q.add(new WorkOrder(2, \"Order cleaning supplies\"));\n    while (q.size() > 0) {\n        System.out.println(q.remove());\n    }\n}\n","name":"main","className":"PriorityQueueDemo","variables":{"q":11},"constants":{"\"Remove pencil sharpener shavings\"":1,"\"Order cleaning supplies\"":1,"\"Shampoo carpets\"":1,"\"Fix broken sink\"":1,"0":1,"\"Replace light bulb\"":1,"1":1,"2":1,"3":1,"6":1,"7":1,"\"Empty trash\"":1,"8":1,"9":1,"\"Water plants\"":1,"\"Clean coffee maker\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["int","String"],"returnType":"WorkOrder","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   */\npublic WorkOrder(int aPriority, String aDescription) {\n    priority = aPriority;\n    description = aDescription;\n}\n","name":"WorkOrder","className":"WorkOrder","variables":{"aPriority":1,"aDescription":1,"description":1,"priority":1},"constants":{},"javaDoc":"Constructs a work order with a given priority and description aPriority the priority of this work order aDescription the description of this work order","comments":"\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"priority=\" + priority + \", description=\" + description;\n}\n","name":"toString","className":"WorkOrder","variables":{"description":1,"priority":1},"constants":{"\", description=\"":1,"\"priority=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"WorkOrder":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":9,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    WorkOrder other = (WorkOrder) otherObject;\n    if (priority < other.priority) {\n        return -1;\n    } else if (priority > other.priority) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","name":"compareTo","className":"WorkOrder","variables":{"other":1,"priority":2,"otherObject":1},"constants":{"0":1,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"push":7,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Stack<String>":1,"String":1,"int":1,"Stack":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":32,"StringLiteralExpr":8,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Stack<String> commands = new Stack<>();\n    commands.push(\"Insert 'Hello'\");\n    commands.push(\"Insert ','\");\n    commands.push(\"Insert ' '\");\n    commands.push(\"Insert 'World'\");\n    commands.push(\"Insert '?'\");\n    commands.push(\"Delete '?'\");\n    commands.push(\"Insert '!'\");\n    // Now we undo the last four commands\n    for (int i = 1; i <= 4; i++) {\n        String command = commands.pop();\n        System.out.println(\"Undo \" + command);\n    }\n}\n","name":"main","className":"StackDemo","variables":{"i":3,"commands":9,"command":2},"constants":{"\"Insert 'World'\"":1,"1":1,"\"Insert 'Hello'\"":1,"4":1,"\"Undo \"":1,"\"Insert '!'\"":1,"\"Insert ' '\"":1,"\"Insert '?'\"":1,"\"Insert ','\"":1,"\"Delete '?'\"":1},"javaDoc":"","comments":"Now we undo the last four commands ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":6,"size":1,"remove":3,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Queue<String>":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":45,"StringLiteralExpr":9,"FieldAccessExpr":3,"MethodCallExpr":13},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Queue<String> jobs = new LinkedList<>();\n    jobs.add(\"Joe: Expense Report #1\");\n    jobs.add(\"Cathy: Meeting Memo\");\n    System.out.println(\"Printing \" + jobs.remove());\n    jobs.add(\"Cathy: Purchase Order #1\");\n    jobs.add(\"Joe: Expense Report #2\");\n    jobs.add(\"Joe: Weekly Report\");\n    System.out.println(\"Printing \" + jobs.remove());\n    jobs.add(\"Cathy: Purchase Order #2\");\n    while (jobs.size() > 0) {\n        System.out.println(\"Printing \" + jobs.remove());\n    }\n}\n","name":"main","className":"QueueDemo","variables":{"jobs":11},"constants":{"0":1,"\"Joe: Expense Report #1\"":1,"\"Joe: Expense Report #2\"":1,"\"Cathy: Purchase Order #2\"":1,"\"Cathy: Purchase Order #1\"":1,"\"Printing \"":3,"\"Cathy: Meeting Memo\"":1,"\"Joe: Weekly Report\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"add":6,"size":3,"push":3,"remove":2,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Stack<String>":1,"Queue<String>":1,"PriorityQueue":1,"LinkedList":1,"Stack":1,"PriorityQueue<String>":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":75,"StringLiteralExpr":12,"FieldAccessExpr":6,"MethodCallExpr":21},"statements":{"WhileStmt":3,"BlockStmt":3,"ExpressionStmt":18},"text":"public static void main(String[] args) {\n    System.out.println(\"Stack: \");\n    Stack<String> s = new Stack<>();\n    s.push(\"Tom\");\n    s.push(\"Diana\");\n    s.push(\"Harry\");\n    while (s.size() > 0) {\n        System.out.println(s.pop());\n    }\n    System.out.println(\"Queue: \");\n    Queue<String> q = new LinkedList<>();\n    q.add(\"Tom\");\n    q.add(\"Diana\");\n    q.add(\"Harry\");\n    while (q.size() > 0) {\n        System.out.println(q.remove());\n    }\n    System.out.println(\"Priority Queue: \");\n    PriorityQueue<String> pq = new PriorityQueue<>();\n    pq.add(\"Tom\");\n    pq.add(\"Diana\");\n    pq.add(\"Harry\");\n    while (pq.size() > 0) {\n        System.out.println(pq.remove());\n    }\n}\n","name":"main","className":"StackQueueDemo","variables":{"q":6,"pq":6,"s":6},"constants":{"0":3,"\"Stack: \"":1,"\"Tom\"":3,"\"Queue: \"":1,"\"Diana\"":3,"\"Harry\"":3,"\"Priority Queue: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":18,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"replace":1,"length":2,"error":5,"push":5,"precedence":2,"evaluateTop":3,"substring":1,"isOperator":1,"pop":4,"parseInt":1,"size":5,"isDigit":2,"System.out.print":1,"charAt":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Scanner":1,"boolean":1,"char":4,"Stack<Character>":1,"String":2,"Stack<Integer>":1,"int":2,"Stack":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":7,"VariableDeclarationExpr":12,"BinaryExpr":14,"BooleanLiteralExpr":2,"NameExpr":136,"StringLiteralExpr":8,"FieldAccessExpr":3,"CharLiteralExpr":4,"UnaryExpr":3,"MethodCallExpr":37,"AssignExpr":1},"statements":{"IfStmt":11,"WhileStmt":4,"BlockStmt":20,"ExpressionStmt":30},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter an expression: \");\n    String expression = in.nextLine().replace(\" \", \"\");\n    Stack<Integer> numstack = new Stack<>();\n    Stack<Character> opstack = new Stack<>();\n    int pos = 0;\n    while (pos < expression.length()) {\n        char ch = expression.charAt(pos);\n        pos++;\n        if (isOperator(ch)) {\n            if (opstack.size() == 0) {\n                opstack.push(ch);\n            } else {\n                char oldOp = opstack.pop();\n                if (precedence(ch) > precedence(oldOp)) {\n                    opstack.push(oldOp);\n                } else {\n                    evaluateTop(numstack, oldOp);\n                }\n                opstack.push(ch);\n            }\n        } else if (ch == '(') {\n            opstack.push(ch);\n        } else if (ch == ')') {\n            boolean done = false;\n            while (!done) {\n                if (opstack.size() == 0) {\n                    error(\"No matching (\");\n                }\n                char oldOp = opstack.pop();\n                if (oldOp == '(') {\n                    done = true;\n                } else {\n                    evaluateTop(numstack, oldOp);\n                }\n            }\n        } else if (Character.isDigit(ch)) {\n            int start = pos - 1;\n            while (pos < expression.length() && Character.isDigit(expression.charAt(pos))) {\n                pos++;\n            }\n            String num = expression.substring(start, pos);\n            numstack.push(Integer.parseInt(num));\n        } else {\n            error(\"Number, operator, or parenthesis expected.\");\n        }\n    }\n    while (opstack.size() > 0) {\n        char oldOp = opstack.pop();\n        if (oldOp == '(') {\n            error(\"No matching )\");\n        } else {\n            evaluateTop(numstack, oldOp);\n        }\n    }\n    if (numstack.size() == 0) {\n        error(\"Syntax error\");\n    }\n    System.out.println(numstack.pop());\n    if (numstack.size() > 0) {\n        error(\"Syntax error\");\n    }\n}\n","name":"main","className":"ExpressionCalculator","variables":{"Integer":1,"expression":6,"Character":2,"in":2,"pos":6,"ch":3,"oldOp":5,"numstack":5,"num":1,"start":1,"opstack":11,"done":3},"constants":{"\"\"":1,"\" \"":1,"')'":1,"'('":3,"\"No matching )\"":1,"false":1,"0":6,"\"Enter an expression: \"":1,"1":1,"\"No matching (\"":1,"true":1,"\"Number, operator, or parenthesis expected.\"":1,"\"Syntax error\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":9}
{"paramTypes":["char"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":7,"NameExpr":4,"CharLiteralExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n      Tests if a token is an operator.\n      @param s the token\n      @return true if s is one of: + - * / ^\n   */\npublic static boolean isOperator(char ch) {\n    return ch == '+' || ch == '-' || ch == '*' || ch == '/';\n}\n","name":"isOperator","className":"ExpressionCalculator","variables":{"ch":4},"constants":{"'-'":1,"'+'":1,"'*'":1,"'/'":1},"javaDoc":"Tests if a token is an operator s the token true if s is one of: + - / ^","comments":"\n      Tests if a token is an operator.\n      @param s the token\n      @return true if s is one of: + - * / ^\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"exit":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":9,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Prints an error message and exits.\n      @param message information about the error\n   */\npublic static void error(String message) {\n    System.out.println(\"ERROR: \" + message + \".\");\n    System.exit(1);\n}\n","name":"error","className":"ExpressionCalculator","variables":{"message":1,"System":1},"constants":{"1":1,"\"ERROR: \"":1,"\".\"":1},"javaDoc":"Prints an error message and exits message information about the error","comments":"\n      Prints an error message and exits.\n      @param message information about the error\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["char"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":6,"NameExpr":4,"CharLiteralExpr":4},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3},"text":"/**\n      Computes the precedence level of an operator.\n      @param s the operator\n      @return the precedence level (1 = lowest, 3 = highest)\n   */\npublic static int precedence(char ch) {\n    if (ch == '+' || ch == '-') {\n        return 1;\n    } else if (ch == '*' || ch == '/') {\n        return 2;\n    } else {\n        return 0;\n    }\n}\n","name":"precedence","className":"ExpressionCalculator","variables":{"ch":4},"constants":{"0":1,"'-'":1,"1":1,"2":1,"'+'":1,"'*'":1,"'/'":1},"javaDoc":"Computes the precedence level of an operator s the operator the precedence level (1 = lowest 3 = highest)","comments":"\n      Computes the precedence level of an operator.\n      @param s the operator\n      @return the precedence level (1 = lowest, 3 = highest)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["Stack<Integer>","char"],"returnType":"void","methodCalls":{"pop":2,"size":2,"error":4,"push":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":11,"NameExpr":41,"StringLiteralExpr":4,"CharLiteralExpr":4,"MethodCallExpr":9,"AssignExpr":4},"statements":{"IfStmt":7,"BlockStmt":9,"ExpressionStmt":12},"text":"/** \n      Computes a new value and pushes it on the stack.\n      @param num the stack for the operands and result\n      @param op the operation to use\n   */\npublic static void evaluateTop(Stack<Integer> num, char op) {\n    if (num.size() == 0) {\n        error(\"Syntax error\");\n    }\n    int y = num.pop();\n    if (num.size() == 0) {\n        error(\"Syntax error\");\n    }\n    int x = num.pop();\n    int z = 0;\n    if (op == '*') {\n        z = x * y;\n    } else if (op == '/') {\n        if (y == 0) {\n            error(\"Divide by 0\");\n        } else {\n            z = x / y;\n        }\n    } else if (op == '+') {\n        z = x + y;\n    } else if (op == '-') {\n        z = x - y;\n    } else {\n        error(\"Syntax error\");\n    }\n    num.push(z);\n}\n","name":"evaluateTop","className":"ExpressionCalculator","variables":{"op":4,"num":5,"x":5,"y":6,"z":5},"constants":{"0":4,"'-'":1,"'+'":1,"'*'":1,"\"Divide by 0\"":1,"\"Syntax error\"":3,"'/'":1},"javaDoc":"Computes a new value and pushes it on the stack num the stack for the operands and result op the operation to use","comments":" \n      Computes a new value and pushes it on the stack.\n      @param num the stack for the operands and result\n      @param op the operation to use\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"hash":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int hashCode() {\n    return Objects.hash(name, area);\n}\n","name":"hashCode","className":"Country","variables":{"Objects":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Country":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":11,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean equals(Object otherObject) {\n    Country other = (Country) otherObject;\n    return name.equals(other.name) && area == other.area;\n}\n","name":"equals","className":"Country","variables":{"area":1,"other":1,"name":1,"otherObject":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"NameExpr":6,"StringLiteralExpr":3,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \",area=\" + area + \"]\";\n}\n","name":"toString","className":"Country","variables":{"area":1,"name":1},"constants":{"\"[name=\"":1,"\"]\"":1,"\",area=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"hashCode":3,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Set<Country>":1,"Country":3,"HashSet":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":3,"StringLiteralExpr":6,"NameExpr":42,"FieldAccessExpr":4,"MethodCallExpr":10},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Country country1 = new Country(\"Belgium\", 30510);\n    Country country2 = new Country(\"Thailand\", 514000);\n    Country country3 = new Country(\"Belgium\", 30510);\n    System.out.println(\"hash code of country1=\" + country1.hashCode());\n    System.out.println(\"hash code of country2=\" + country2.hashCode());\n    System.out.println(\"hash code of country3=\" + country3.hashCode());\n    // Add the countries to the hash set. \n    Set<Country> countries = new HashSet<>();\n    countries.add(country1);\n    countries.add(country2);\n    countries.add(country3);\n    // Print the set. Note that the set has two elements.\n    System.out.println(countries);\n}\n","name":"main","className":"HashCodePrinter","variables":{"country1":2,"countries":4,"country3":2,"country2":2},"constants":{"\"hash code of country2=\"":1,"\"Thailand\"":1,"\"hash code of country1=\"":1,"30510":2,"\"Belgium\"":2,"514000":1,"\"hash code of country3=\"":1},"javaDoc":"","comments":"Add the countries to the hash set Print the set Note that the set has two elements ","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"size":2,"nextLine":1,"length":1,"System.out.print":3,"charAt":1,"push":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Scanner":1,"char":2,"Stack<Character>":1,"String":1,"int":1,"Stack":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":6,"BinaryExpr":24,"NameExpr":65,"StringLiteralExpr":5,"FieldAccessExpr":6,"CharLiteralExpr":12,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":12},"statements":{"IfStmt":5,"BlockStmt":7,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter an expression with { [ ( ) ] }: \");\n    String expression = in.nextLine();\n    Stack<Character> parens = new Stack<>();\n    for (int i = 0; i < expression.length(); i++) {\n        char ch = expression.charAt(i);\n        if (ch == '(' || ch == '[' || ch == '{') {\n            parens.push(ch);\n        } else if (ch == ')' || ch == ']' || ch == '}') {\n            if (parens.size() == 0) {\n                System.out.println(\"Not balanced.\");\n                return;\n            }\n            char open = parens.pop();\n            if (!(open == '(' && ch == ')' || open == '[' && ch == ']' || open == '{' && ch == '}')) {\n                System.out.println(\"Not balanced.\");\n                return;\n            }\n        }\n    }\n    if (parens.size() == 0) {\n        System.out.print(\"Balanced.\");\n    } else {\n        System.out.print(\"Not balanced.\");\n    }\n}\n","name":"main","className":"ParenChecker","variables":{"parens":5,"expression":3,"in":2,"ch":10,"i":3,"open":4},"constants":{"0":3,"']'":2,"'}'":2,"\"Not balanced.\"":3,"\"Balanced.\"":1,"'['":2,"'{'":2,"')'":2,"'('":2,"\"Enter an expression with { [ ( ) ] }: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"contains":1,"readWords":2,"System.out.println":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Set<String>":2,"String":1},"expressions":{"VariableDeclarationExpr":3,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Read the dictionary and the document\n    Set<String> dictionaryWords = readWords(\"words\");\n    Set<String> documentWords = readWords(\"alice30.txt\");\n    for (String word : documentWords) {\n        if (!dictionaryWords.contains(word)) {\n            System.out.println(word);\n        }\n    }\n}\n","name":"main","className":"SpellCheck","variables":{"documentWords":2,"dictionaryWords":2,"word":1},"constants":{"\"alice30.txt\"":1,"\"words\"":1},"javaDoc":"","comments":"Read the dictionary and the document Print all words that are in the document but not the dictionary ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"Set<String>","methodCalls":{"add":1,"next":1,"toLowerCase":1,"useDelimiter":1,"hasNext":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"Set<String>":1,"HashSet":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"NameExpr":16,"StringLiteralExpr":1,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Reads all words from a file.\n      @param filename the name of the file\n      @return a set with all lowercased words in the file. Here, a \n      word is a sequence of upper- and lowercase letters.\n   */\npublic static Set<String> readWords(String filename) throws FileNotFoundException {\n    Set<String> words = new HashSet<>();\n    Scanner in = new Scanner(new File(filename));\n    // Use any characters other than a-z or A-Z as delimiters\n    in.useDelimiter(\"[^a-zA-Z]+\");\n    while (in.hasNext()) {\n        words.add(in.next().toLowerCase());\n    }\n    return words;\n}\n","name":"readWords","className":"SpellCheck","variables":{"filename":1,"in":4,"words":3},"constants":{"\"[^a-zA-Z]+\"":1},"javaDoc":"Reads all words from a file filename the name of the file a set with all lowercased words in the file Here a word is a sequence of upper- and lowercase letters","comments":"Use any characters other than a-z or A-Z as delimiters \n      Reads all words from a file.\n      @param filename the name of the file\n      @return a set with all lowercased words in the file. Here, a \n      word is a sequence of upper- and lowercase letters.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"System.out.printf":1,"get":2,"hasNext":1,"clean":1,"keySet":1,"put":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["PolyMorphism"],"types":{"Integer":1,"Scanner":1,"Map<String, Integer>":1,"String":2,"TreeMap":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":34,"FieldAccessExpr":1,"MethodCallExpr":8,"AssignExpr":2},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":4,"ForeachStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) throws FileNotFoundException {\n    Map<String, Integer> frequencies = new TreeMap<>();\n    Scanner in = new Scanner(new File(\"alice30.txt\"));\n    while (in.hasNext()) {\n        String word = clean(in.next());\n        // Get the old frequency count\n        Integer count = frequencies.get(word);\n        if (count == null) {\n            count = 1;\n        } else {\n            count = count + 1;\n        }\n        frequencies.put(word, count);\n    }\n    for (String key : frequencies.keySet()) {\n        System.out.printf(\"%-20s%10d\\n\", key, frequencies.get(key));\n    }\n}\n","name":"main","className":"WordFrequency","variables":{"in":3,"count":5,"frequencies":5,"word":1,"key":1},"constants":{"\"alice30.txt\"":1,"1":2,"null":1,"\"%-20s%10d\\n\"":1},"javaDoc":"","comments":"Print all words and counts Get the old frequency count If there was none put 1; otherwise increment the count ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"toLowerCase":1,"length":1,"charAt":1,"isLetter":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"char":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"StringLiteralExpr":1,"NameExpr":19,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Removes characters from a string that are not letters.\n      @param s a string\n      @return a string with all the letters from s\n   */\npublic static String clean(String s) {\n    String r = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        if (Character.isLetter(c)) {\n            r = r + c;\n        }\n    }\n    return r.toLowerCase();\n}\n","name":"clean","className":"WordFrequency","variables":{"r":4,"s":2,"c":2,"Character":1,"i":3},"constants":{"\"\"":1,"0":1},"javaDoc":"Removes characters from a string that are not letters s a string a string with all the letters from s","comments":"\n      Removes characters from a string that are not letters.\n      @param s a string\n      @return a string with all the letters from s\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["double"],"returnType":"Event","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Event(double eventTime) {\n    time = eventTime;\n}\n","name":"Event","className":"Event","variables":{"eventTime":1,"time":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Simulation"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void process(Simulation sim) {\n}\n","name":"process","className":"Event","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getTime() {\n    return time;\n}\n","name":"getTime","className":"Event","variables":{"time":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Event"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":2,"NameExpr":8,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3},"text":"public int compareTo(Event other) {\n    if (time < other.time) {\n        return -1;\n    } else if (time > other.time) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","name":"compareTo","className":"Event","variables":{"time":2},"constants":{"0":1,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"Customer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n       Constructs a customer.\n       @param the time at which the customer entered the bank\n   */\npublic Customer(double time) {\n    arrivalTime = time;\n}\n","name":"Customer","className":"Customer","variables":{"arrivalTime":1,"time":1},"constants":{},"javaDoc":"Constructs a customer the time at which the customer entered the bank","comments":" \n       Constructs a customer.\n       @param the time at which the customer entered the bank\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the time at which the customer entered the bank.\n      @return the arrival time\n   */\ndouble getArrivalTime() {\n    return arrivalTime;\n}\n","name":"getArrivalTime","className":"Customer","variables":{"arrivalTime":1},"constants":{},"javaDoc":"Gets the time at which the customer entered the bank the arrival time","comments":"\n      Gets the time at which the customer entered the bank.\n      @return the arrival time\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["double"],"returnType":"Arrival","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n      @param time the arrival time\n   */\npublic Arrival(double time) {\n    super(time);\n}\n","name":"Arrival","className":"Arrival","variables":{"time":1},"constants":{},"javaDoc":"time the arrival time","comments":"\n      @param time the arrival time\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Simulation"],"returnType":"void","methodCalls":{"add":1,"getCurrentTime":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"BankSimulation":1,"Customer":1,"double":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":9,"CastExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public void process(Simulation sim) {\n    double now = sim.getCurrentTime();\n    BankSimulation bank = (BankSimulation) sim;\n    Customer c = new Customer(now);\n    bank.add(c);\n}\n","name":"process","className":"Arrival","variables":{"bank":2,"c":1,"sim":2,"now":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"BankSimulation","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"NameExpr":5,"ArrayCreationExpr":1,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public BankSimulation(int numberOfTellers) {\n    tellers = new Customer[numberOfTellers];\n    custQueue = new LinkedList<>();\n    totalCustomers = 0;\n    totalTime = 0;\n}\n","name":"BankSimulation","className":"BankSimulation","variables":{"totalCustomers":1,"tellers":1,"custQueue":1,"totalTime":1,"numberOfTellers":1},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Customer"],"returnType":"void","methodCalls":{"add":1,"addEvent":1,"expdist":1,"addToTeller":1,"getCurrentTime":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BooleanLiteralExpr":2,"BinaryExpr":4,"NameExpr":25,"FieldAccessExpr":1,"UnaryExpr":3,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":5},"text":"/** \n       Adds a customer to the bank.\n       @param c the customer\n   */\npublic void add(Customer c) {\n    boolean addedToTeller = false;\n    for (int i = 0; !addedToTeller && i < tellers.length; i++) {\n        if (tellers[i] == null) {\n            addToTeller(i, c);\n            addedToTeller = true;\n        }\n    }\n    if (!addedToTeller) {\n        custQueue.add(c);\n    }\n    addEvent(new Arrival(getCurrentTime() + expdist(INTERARRIVAL)));\n}\n","name":"add","className":"BankSimulation","variables":{"tellers":1,"custQueue":1,"i":4,"addedToTeller":4},"constants":{"0":1,"null":1,"false":1,"true":1},"javaDoc":"Adds a customer to the bank c the customer","comments":" \n       Adds a customer to the bank.\n       @param c the customer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","Customer"],"returnType":"void","methodCalls":{"addEvent":1,"expdist":1,"getCurrentTime":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":11,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/**\n      Adds a customer to a teller and schedules the departure event.\n      @param i the teller number\n      @param c the customer\n   */\nprivate void addToTeller(int i, Customer c) {\n    tellers[i] = c;\n    addEvent(new Departure(getCurrentTime() + expdist(PROCESSING), i));\n}\n","name":"addToTeller","className":"BankSimulation","variables":{"c":1,"tellers":1,"i":2},"constants":{},"javaDoc":"Adds a customer to a teller and schedules the departure event i the teller number c the customer","comments":"\n      Adds a customer to a teller and schedules the departure event.\n      @param i the teller number\n      @param c the customer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"size":1,"getArrivalTime":1,"addToTeller":1,"getCurrentTime":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Customer":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":21,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"/** \n       Removes a customer from a teller.\n       @param i teller position\n   */\npublic void remove(int i) {\n    Customer c = tellers[i];\n    tellers[i] = null;\n    // Update statistics\n    totalCustomers++;\n    totalTime = totalTime + getCurrentTime() - c.getArrivalTime();\n    if (custQueue.size() > 0) {\n        addToTeller(i, custQueue.remove());\n    }\n}\n","name":"remove","className":"BankSimulation","variables":{"c":2,"totalCustomers":1,"tellers":2,"custQueue":2,"totalTime":2,"i":2},"constants":{"0":1,"null":1},"javaDoc":"Removes a customer from a teller i teller position","comments":"Update statistics  \n       Removes a customer from a teller.\n       @param i teller position\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":38,"StringLiteralExpr":4,"FieldAccessExpr":6,"UnaryExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":4,"ForStmt":2,"ExpressionStmt":6},"text":"/**\n      Displays tellers and queue.\n   */\npublic void display() {\n    for (int i = 0; i < tellers.length; i++) {\n        if (tellers[i] == null) {\n            System.out.print(\".\");\n        } else {\n            System.out.print(\"C\");\n        }\n    }\n    System.out.print(\"<\");\n    int q = custQueue.size();\n    for (int j = 1; j <= q; j++) {\n        System.out.print(\"C\");\n    }\n    System.out.println();\n}\n","name":"display","className":"BankSimulation","variables":{"q":2,"tellers":1,"custQueue":1,"i":4,"j":3},"constants":{"0":1,"\"C\"":2,"1":1,"null":1,"\".\"":1,"\"<\"":1},"javaDoc":"Displays tellers and queue","comments":"\n      Displays tellers and queue.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/** \n       Displays a summary of the gathered statistics.\n   */\npublic void displaySummary() {\n    double averageTime = 0;\n    if (totalCustomers > 0) {\n        averageTime = totalTime / totalCustomers;\n    }\n    System.out.println(totalCustomers + \" customers. Average time \" + averageTime + \" minutes.\");\n}\n","name":"displaySummary","className":"BankSimulation","variables":{"totalCustomers":3,"averageTime":3,"totalTime":1},"constants":{"0":2,"\" customers. Average time \"":1,"\" minutes.\"":1},"javaDoc":"Displays a summary of the gathered statistics","comments":" \n       Displays a summary of the gathered statistics.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["double","int"],"returnType":"Departure","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/**\n      @param time the departure time\n      @param teller the teller holding the customer\n   */\npublic Departure(double time, int teller) {\n    super(time);\n    this.teller = teller;\n}\n","name":"Departure","className":"Departure","variables":{"teller":1,"time":1},"constants":{},"javaDoc":"time the departure time teller the teller holding the customer","comments":"\n      @param time the departure time\n      @param teller the teller holding the customer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Simulation"],"returnType":"void","methodCalls":{"remove":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"BankSimulation":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void process(Simulation sim) {\n    BankSimulation bank = (BankSimulation) sim;\n    bank.remove(teller);\n}\n","name":"process","className":"Departure","variables":{"bank":2,"sim":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addEvent":1,"run":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables","PolyMorphism"],"types":{"BankSimulation":1,"Simulation":1,"double":2,"int":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":10,"MethodCallExpr":2},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    // 9 a.m.\n    final double START_TIME = 9 * 60;\n    // 5 p.m.\n    final double END_TIME = 17 * 60;\n    final int NTELLERS = 5;\n    Simulation sim = new BankSimulation(NTELLERS);\n    sim.addEvent(new Arrival(START_TIME));\n    sim.run(START_TIME, END_TIME);\n}\n","name":"main","className":"BankSimulationRunner","variables":{"START_TIME":2,"END_TIME":1,"sim":3,"NTELLERS":2},"constants":{"5":1,"17":1,"9":1,"60":2},"javaDoc":"","comments":"9 a m 5 p m ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"Simulation","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a discrete event simulation.\n   */\npublic Simulation() {\n    eventQueue = new PriorityQueue<>();\n}\n","name":"Simulation","className":"Simulation","variables":{"eventQueue":1},"constants":{},"javaDoc":"Constructs a discrete event simulation","comments":"\n      Constructs a discrete event simulation.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getCurrentTime() {\n    return currentTime;\n}\n","name":"getCurrentTime","className":"Simulation","variables":{"currentTime":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"double","methodCalls":{"random":1,"log":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":7,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Compute exponentially distributed random numbers.\n      @param mean the mean of the number sequence\n      @return a random number\n   */\npublic static double expdist(double mean) {\n    return -mean * Math.log(1 - Math.random());\n}\n","name":"expdist","className":"Simulation","variables":{"mean":1,"Math":2},"constants":{"1":1},"javaDoc":"Compute exponentially distributed random numbers mean the mean of the number sequence a random number","comments":"\n      Compute exponentially distributed random numbers.\n      @param mean the mean of the number sequence\n      @return a random number\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["Event"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds an event to the event queue.\n      @param evt the event to add\n   */\npublic void addEvent(Event evt) {\n    eventQueue.add(evt);\n}\n","name":"addEvent","className":"Simulation","variables":{"eventQueue":1},"constants":{},"javaDoc":"Adds an event to the event queue evt the event to add","comments":"\n      Adds an event to the event queue.\n      @param evt the event to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Displays intermediate results after each event.\n   */\npublic void display() {\n}\n","name":"display","className":"Simulation","variables":{},"constants":{},"javaDoc":"Displays intermediate results after each event","comments":"\n      Displays intermediate results after each event.\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Displays summary results after the end of the simulation.\n   */\npublic void displaySummary() {\n}\n","name":"displaySummary","className":"Simulation","variables":{},"constants":{},"javaDoc":"Displays summary results after the end of the simulation","comments":"\n      Displays summary results after the end of the simulation.\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{"process":1,"size":1,"getTime":1,"display":1,"displaySummary":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Event":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":21,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"public void run(double startTime, double endTime) {\n    currentTime = startTime;\n    while (eventQueue.size() > 0 && currentTime <= endTime) {\n        Event event = eventQueue.remove();\n        currentTime = event.getTime();\n        event.process(this);\n        display();\n    }\n    displaySummary();\n}\n","name":"run","className":"Simulation","variables":{"currentTime":3,"eventQueue":2,"startTime":1,"endTime":1,"event":3},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"workWith":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":14,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    System.out.println(\"Working with an ArrayList\");\n    workWith(new ArrayList<>());\n    System.out.println(\"Working with a TreeSet\");\n    workWith(new TreeSet<>());\n}\n","name":"main","className":"CollectionsDemo","variables":{},"constants":{"\"Working with a TreeSet\"":1,"\"Working with an ArrayList\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["Collection<String>"],"returnType":"void","methodCalls":{"add":5,"contains":2,"System.out.print":4,"remove":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":70,"StringLiteralExpr":13,"FieldAccessExpr":8,"MethodCallExpr":17},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":13},"text":"/**\n      Shows how to work with a collection of strings.\n      @param coll a collection from the Java collections framework\n   */\npublic static void workWith(Collection<String> coll) {\n    coll.add(\"Harry\");\n    coll.add(\"Sally\");\n    coll.add(\"Fred\");\n    coll.add(\"Wilma\");\n    coll.add(\"Harry\");\n    System.out.println(coll);\n    System.out.print(\"Removing Harry and Tom: \");\n    System.out.print(coll.remove(\"Harry\") + \" \");\n    System.out.println(coll.remove(\"Tom\"));\n    System.out.print(\"Looking for Harry and Sally: \");\n    System.out.print(coll.contains(\"Harry\") + \" \");\n    System.out.println(coll.contains(\"Sally\"));\n    for (String s : coll) {\n        System.out.println(s);\n    }\n}\n","name":"workWith","className":"CollectionsDemo","variables":{"coll":10,"s":1},"constants":{"\"Fred\"":1,"\" \"":2,"\"Tom\"":1,"\"Wilma\"":1,"\"Removing Harry and Tom: \"":1,"\"Sally\"":2,"\"Harry\"":4,"\"Looking for Harry and Sally: \"":1},"javaDoc":"Shows how to work with a collection of strings coll a collection from the Java collections framework","comments":"\n      Shows how to work with a collection of strings.\n      @param coll a collection from the Java collections framework\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"get":1,"keySet":1,"put":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<String, Color>":1,"Set<String>":1,"HashMap":1,"Color":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":39,"StringLiteralExpr":5,"FieldAccessExpr":5,"MethodCallExpr":7},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Map<String, Color> favoriteColors = new HashMap<>();\n    favoriteColors.put(\"Juliet\", Color.BLUE);\n    favoriteColors.put(\"Romeo\", Color.GREEN);\n    favoriteColors.put(\"Adam\", Color.RED);\n    favoriteColors.put(\"Eve\", Color.BLUE);\n    // Print all keys and values in the map\n    Set<String> keySet = favoriteColors.keySet();\n    for (String key : keySet) {\n        Color value = favoriteColors.get(key);\n        System.out.println(key + \" : \" + value);\n    }\n}\n","name":"main","className":"MapDemo","variables":{"favoriteColors":7,"keySet":2,"value":2,"key":2},"constants":{"\"Eve\"":1,"\" : \"":1,"\"Juliet\"":1,"\"Adam\"":1,"\"Romeo\"":1},"javaDoc":"","comments":"Print all keys and values in the map ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":[],"returnType":"BinaryTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic BinaryTree() {\n    root = null;\n}\n","name":"BinaryTree","className":"BinaryTree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"BinaryTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":2,"NameExpr":11,"FieldAccessExpr":3,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   */\npublic BinaryTree(Object rootData) {\n    root = new Node();\n    root.data = rootData;\n    root.left = null;\n    root.right = null;\n}\n","name":"BinaryTree","className":"BinaryTree","variables":{"root":1,"rootData":1},"constants":{"null":2},"javaDoc":"Constructs a tree with one node and no children rootData the data for the root","comments":"\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object","BinaryTree","BinaryTree"],"returnType":"BinaryTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":17,"FieldAccessExpr":5,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a binary tree.\n      @param rootData the data for the root\n      @param left the left subtree\n      @param right the right subtree\n   */\npublic BinaryTree(Object rootData, BinaryTree left, BinaryTree right) {\n    root = new Node();\n    root.data = rootData;\n    root.left = left.root;\n    root.right = right.root;\n}\n","name":"BinaryTree","className":"BinaryTree","variables":{"root":1,"rootData":1},"constants":{},"javaDoc":"Constructs a binary tree rootData the data for the root left the left subtree right the right subtree","comments":"\n      Constructs a binary tree.\n      @param rootData the data for the root\n      @param left the left subtree\n      @param right the right subtree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Node"],"returnType":"int","methodCalls":{"max":1,"height":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":14,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Returns the height of the subtree whose root is the given node.\n      @param n a node or null\n      @return the height of the subtree, or 0 if n is null\n   */\nprivate static int height(Node n) {\n    if (n == null) {\n        return 0;\n    } else {\n        return 1 + Math.max(height(n.left), height(n.right));\n    }\n}\n","name":"height","className":"BinaryTree","variables":{"Math":1,"n":1},"constants":{"0":1,"1":1,"null":1},"javaDoc":"Returns the height of the subtree whose root is the given node n a node or null the height of the subtree or 0 if n is null","comments":"\n      Returns the height of the subtree whose root is the given node.\n      @param n a node or null\n      @return the height of the subtree, or 0 if n is null\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":[],"returnType":"int","methodCalls":{"height":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the height of this tree.\n      @return the height\n   */\npublic int height() {\n    return height(root);\n}\n","name":"height","className":"BinaryTree","variables":{},"constants":{},"javaDoc":"Returns the height of this tree the height","comments":"\n      Returns the height of this tree.\n      @return the height\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this tree is empty.\n      @return true if this tree is empty\n   */\npublic boolean isEmpty() {\n    return root == null;\n}\n","name":"isEmpty","className":"BinaryTree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Checks whether this tree is empty true if this tree is empty","comments":"\n      Checks whether this tree is empty.\n      @return true if this tree is empty\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the data at the root of this tree.\n      @return the root data\n   */\npublic Object data() {\n    return root.data;\n}\n","name":"data","className":"BinaryTree","variables":{},"constants":{},"javaDoc":"Gets the data at the root of this tree the root data","comments":"\n      Gets the data at the root of this tree.\n      @return the root data\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BinaryTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"BinaryTree":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":7,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the left subtree of this tree.\n      @return the left child of the root\n   */\npublic BinaryTree left() {\n    BinaryTree result = new BinaryTree();\n    result.root = root.left;\n    return result;\n}\n","name":"left","className":"BinaryTree","variables":{"result":2},"constants":{},"javaDoc":"Gets the left subtree of this tree the left child of the root","comments":"\n      Gets the left subtree of this tree.\n      @return the left child of the root\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"BinaryTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"BinaryTree":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":7,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the right subtree of this tree.\n      @return the right child of the root\n   */\npublic BinaryTree right() {\n    BinaryTree result = new BinaryTree();\n    result.root = root.right;\n    return result;\n}\n","name":"right","className":"BinaryTree","variables":{"result":2},"constants":{},"javaDoc":"Gets the right subtree of this tree the right child of the root","comments":"\n      Gets the right subtree of this tree.\n      @return the right child of the root\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"data":2,"left":1,"equals":3,"isEmpty":2,"toUpperCase":1,"right":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"boolean":1,"BinaryTree":3,"String":1},"expressions":{"ObjectCreationExpr":12,"VariableDeclarationExpr":6,"BooleanLiteralExpr":2,"BinaryExpr":3,"StringLiteralExpr":15,"NameExpr":52,"FieldAccessExpr":3,"UnaryExpr":3,"MethodCallExpr":13,"AssignExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":6,"ExpressionStmt":12,"DoStmt":1},"text":"public static void main(String[] args) {\n    BinaryTree questionTree = new BinaryTree(\"Is it a mammal?\", new BinaryTree(\"Does it have stripes?\", new BinaryTree(\"Is it a carnivore?\", new BinaryTree(\"It is a tiger.\"), new BinaryTree(\"It is a zebra.\")), new BinaryTree(\"It is a pig.\")), new BinaryTree(\"Does it fly?\", new BinaryTree(\"It is an eagle.\"), new BinaryTree(\"Does it swim?\", new BinaryTree(\"It is a penguin.\"), new BinaryTree(\"It is an ostrich.\"))));\n    boolean done = false;\n    Scanner in = new Scanner(System.in);\n    while (!done) {\n        BinaryTree left = questionTree.left();\n        BinaryTree right = questionTree.right();\n        if (left.isEmpty() && right.isEmpty()) {\n            System.out.println(questionTree.data());\n            done = true;\n        } else {\n            String response;\n            do {\n                System.out.print(questionTree.data() + \" (Y/N) \");\n                response = in.next().toUpperCase();\n            } while (!response.equals(\"Y\") && !response.equals(\"N\"));\n            if (response.equals(\"Y\")) {\n                questionTree = left;\n            } else {\n                questionTree = right;\n            }\n        }\n    }\n}\n","name":"main","className":"DecisionTreeDemo","variables":{"in":2,"left":3,"response":5,"questionTree":7,"right":3,"done":3},"constants":{"\"Does it swim?\"":1,"\"It is an eagle.\"":1,"\"It is an ostrich.\"":1,"false":1,"\"Y\"":2,"\"It is a zebra.\"":1,"\"Does it fly?\"":1,"\"It is a penguin.\"":1,"\"Is it a mammal?\"":1,"\" (Y/N) \"":1,"\"N\"":1,"\"It is a tiger.\"":1,"true":1,"\"Is it a carnivore?\"":1,"\"Does it have stripes?\"":1,"\"It is a pig.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"MinHeap","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an empty heap.\n   */\npublic MinHeap() {\n    elements = new ArrayList<>();\n    elements.add(null);\n}\n","name":"MinHeap","className":"MinHeap","variables":{"elements":2},"constants":{"null":1},"javaDoc":"Constructs an empty heap","comments":"\n      Constructs an empty heap.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"add":1,"getParent":2,"getParentIndex":1,"set":2,"size":1,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":29,"MethodCallExpr":8,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"/**\n      Adds a new element to this heap.\n      @param newElement the element to add\n   */\npublic void add(Comparable newElement) {\n    // Add a new leaf\n    elements.add(null);\n    int index = elements.size() - 1;\n    // Demote parents that are larger than the new element\n    while (index > 1 && getParent(index).compareTo(newElement) > 0) {\n        elements.set(index, getParent(index));\n        index = getParentIndex(index);\n    }\n    // Store the new element into the vacant slot\n    elements.set(index, newElement);\n}\n","name":"add","className":"MinHeap","variables":{"elements":4,"index":3},"constants":{"0":1,"1":2,"null":1},"javaDoc":"Adds a new element to this heap newElement the element to add","comments":"Add a new leaf Demote parents that are larger than the new element Store the new element into the vacant slot \n      Adds a new element to this heap.\n      @param newElement the element to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"Comparable","methodCalls":{"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the minimum element stored in this heap.\n      @return the minimum element\n   */\npublic Comparable peek() {\n    return elements.get(1);\n}\n","name":"peek","className":"MinHeap","variables":{"elements":1},"constants":{"1":1},"javaDoc":"Gets the minimum element stored in this heap the minimum element","comments":"\n      Gets the minimum element stored in this heap.\n      @return the minimum element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Comparable","methodCalls":{"set":1,"size":1,"fixHeap":1,"get":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Comparable":2,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":18,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Removes the minimum element from this heap.\n      @return the minimum element\n   */\npublic Comparable remove() {\n    Comparable minimum = elements.get(1);\n    // Remove last element\n    int lastIndex = elements.size() - 1;\n    Comparable last = elements.remove(lastIndex);\n    if (lastIndex > 1) {\n        elements.set(1, last);\n        fixHeap();\n    }\n    return minimum;\n}\n","name":"remove","className":"MinHeap","variables":{"last":1,"elements":4,"lastIndex":2,"minimum":2},"constants":{"1":4},"javaDoc":"Removes the minimum element from this heap the minimum element","comments":"Remove last element \n      Removes the minimum element from this heap.\n      @return the minimum element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getLeftChildIndex":1,"set":2,"size":1,"get":1,"compareTo":2,"getRightChild":2,"getRightChildIndex":2,"getLeftChild":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Comparable":2,"boolean":1,"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":6,"BinaryExpr":6,"BooleanLiteralExpr":3,"NameExpr":51,"MethodCallExpr":12,"AssignExpr":5},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":6,"ExpressionStmt":13},"text":"/**\n      Turns the tree back into a heap, provided only the root \n      node violates the heap condition.\n   */\nprivate void fixHeap() {\n    Comparable root = elements.get(1);\n    int lastIndex = elements.size() - 1;\n    // Promote children of removed root while they are smaller than root      \n    int index = 1;\n    boolean more = true;\n    while (more) {\n        int childIndex = getLeftChildIndex(index);\n        if (childIndex <= lastIndex) {\n            // Get smaller child \n            // Get left child first\n            Comparable child = getLeftChild(index);\n            // Use right child instead if it is smaller\n            if (getRightChildIndex(index) <= lastIndex && getRightChild(index).compareTo(child) < 0) {\n                childIndex = getRightChildIndex(index);\n                child = getRightChild(index);\n            }\n            // Check if smaller child is smaller than root\n            if (child.compareTo(root) < 0) {\n                // Promote child\n                elements.set(index, child);\n                index = childIndex;\n            } else {\n                // Root is smaller than both children\n                more = false;\n            }\n        } else {\n            // No children\n            more = false;\n        }\n    }\n    // Store root element in vacant slot\n    elements.set(index, root);\n}\n","name":"fixHeap","className":"MinHeap","variables":{"more":4,"root":1,"elements":4,"index":2,"lastIndex":3,"childIndex":4,"child":3},"constants":{"0":2,"1":3,"true":1,"false":2},"javaDoc":"Turns the tree back into a heap provided only the root node violates the heap condition","comments":"Promote children of removed root while they are smaller than root Get smaller child Get left child first Use right child instead if it is smaller Check if smaller child is smaller than root Promote child Root is smaller than both children No children Store root element in vacant slot \n      Turns the tree back into a heap, provided only the root \n      node violates the heap condition.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":2}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this heap is empty.\n   */\npublic boolean empty() {\n    return elements.size() == 1;\n}\n","name":"empty","className":"MinHeap","variables":{"elements":1},"constants":{"1":1},"javaDoc":"Checks whether this heap is empty","comments":"\n      Checks whether this heap is empty.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   */\nprivate static int getLeftChildIndex(int index) {\n    return 2 * index;\n}\n","name":"getLeftChildIndex","className":"MinHeap","variables":{"index":1},"constants":{"2":1},"javaDoc":"Returns the index of the left child index the index of a node in this heap the index of the left child of the given node","comments":"\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   */\nprivate static int getRightChildIndex(int index) {\n    return 2 * index + 1;\n}\n","name":"getRightChildIndex","className":"MinHeap","variables":{"index":1},"constants":{"1":1,"2":1},"javaDoc":"Returns the index of the right child index the index of a node in this heap the index of the right child of the given node","comments":"\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the index of the parent.\n      @param index the index of a node in this heap\n      @return the index of the parent of the given node\n   */\nprivate static int getParentIndex(int index) {\n    return index / 2;\n}\n","name":"getParentIndex","className":"MinHeap","variables":{"index":1},"constants":{"2":1},"javaDoc":"Returns the index of the parent index the index of a node in this heap the index of the parent of the given node","comments":"\n      Returns the index of the parent.\n      @param index the index of a node in this heap\n      @return the index of the parent of the given node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["int"],"returnType":"Comparable","methodCalls":{"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the value of the left child.\n      @param index the index of a node in this heap\n      @return the value of the left child of the given node\n   */\nprivate Comparable getLeftChild(int index) {\n    return elements.get(2 * index);\n}\n","name":"getLeftChild","className":"MinHeap","variables":{"elements":1,"index":1},"constants":{"2":1},"javaDoc":"Returns the value of the left child index the index of a node in this heap the value of the left child of the given node","comments":"\n      Returns the value of the left child.\n      @param index the index of a node in this heap\n      @return the value of the left child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["int"],"returnType":"Comparable","methodCalls":{"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the value of the right child.\n      @param index the index of a node in this heap\n      @return the value of the right child of the given node\n   */\nprivate Comparable getRightChild(int index) {\n    return elements.get(2 * index + 1);\n}\n","name":"getRightChild","className":"MinHeap","variables":{"elements":1,"index":1},"constants":{"1":1,"2":1},"javaDoc":"Returns the value of the right child index the index of a node in this heap the value of the right child of the given node","comments":"\n      Returns the value of the right child.\n      @param index the index of a node in this heap\n      @return the value of the right child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["int"],"returnType":"Comparable","methodCalls":{"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the value of the parent.\n      @param index the index of a node in this heap\n      @return the value of the parent of the given node\n   */\nprivate Comparable getParent(int index) {\n    return elements.get(index / 2);\n}\n","name":"getParent","className":"MinHeap","variables":{"elements":1,"index":1},"constants":{"2":1},"javaDoc":"Returns the value of the parent index the index of a node in this heap the value of the parent of the given node","comments":"\n      Returns the value of the parent.\n      @param index the index of a node in this heap\n      @return the value of the parent of the given node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["int","String"],"returnType":"WorkOrder","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   */\npublic WorkOrder(int aPriority, String aDescription) {\n    priority = aPriority;\n    description = aDescription;\n}\n","name":"WorkOrder","className":"WorkOrder","variables":{"aPriority":1,"aDescription":1,"description":1,"priority":1},"constants":{},"javaDoc":"Constructs a work order with a given priority and description aPriority the priority of this work order aDescription the description of this work order","comments":"\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"priority=\" + priority + \", description=\" + description;\n}\n","name":"toString","className":"WorkOrder","variables":{"description":1,"priority":1},"constants":{"\", description=\"":1,"\"priority=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"WorkOrder":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":9,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":3,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    WorkOrder other = (WorkOrder) otherObject;\n    if (priority < other.priority) {\n        return -1;\n    }\n    if (priority > other.priority) {\n        return 1;\n    }\n    return 0;\n}\n","name":"compareTo","className":"WorkOrder","variables":{"other":1,"priority":2,"otherObject":1},"constants":{"0":1,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":8,"remove":1,"empty":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MinHeap":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":8,"VariableDeclarationExpr":1,"NameExpr":35,"StringLiteralExpr":8,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":11},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    MinHeap q = new MinHeap();\n    q.add(new WorkOrder(3, \"Shampoo carpets\"));\n    q.add(new WorkOrder(7, \"Empty trash\"));\n    q.add(new WorkOrder(8, \"Water plants\"));\n    q.add(new WorkOrder(10, \"Remove pencil sharpener shavings\"));\n    q.add(new WorkOrder(6, \"Replace light bulb\"));\n    q.add(new WorkOrder(1, \"Fix broken sink\"));\n    q.add(new WorkOrder(9, \"Clean coffee maker\"));\n    q.add(new WorkOrder(2, \"Order cleaning supplies\"));\n    while (!q.empty()) {\n        System.out.println(q.remove());\n    }\n}\n","name":"main","className":"HeapDemo","variables":{"q":11},"constants":{"\"Remove pencil sharpener shavings\"":1,"\"Order cleaning supplies\"":1,"\"Shampoo carpets\"":1,"\"Fix broken sink\"":1,"\"Replace light bulb\"":1,"1":1,"2":1,"3":1,"6":1,"7":1,"\"Empty trash\"":1,"8":1,"9":1,"\"Water plants\"":1,"\"Clean coffee maker\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":10,"print":1,"remove":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BinarySearchTree":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":50,"StringLiteralExpr":15,"FieldAccessExpr":1,"MethodCallExpr":16},"statements":{"ExpressionStmt":17},"text":"public static void main(String[] args) {\n    BinarySearchTree t = new BinarySearchTree();\n    t.add(\"D\");\n    t.add(\"B\");\n    t.add(\"A\");\n    t.add(\"C\");\n    t.add(\"F\");\n    t.add(\"E\");\n    t.add(\"I\");\n    t.add(\"G\");\n    t.add(\"H\");\n    t.add(\"J\");\n    // Removing leaf\n    t.remove(\"A\");\n    // Removing element with one child\n    t.remove(\"B\");\n    // Removing element with two children\n    t.remove(\"F\");\n    // Removing root\n    t.remove(\"D\");\n    t.print();\n    System.out.println(\"Expected: C E G H I J\");\n}\n","name":"main","className":"TreeTester","variables":{"t":16},"constants":{"\"D\"":2,"\"C\"":1,"\"B\"":2,"\"A\"":2,"\"Expected: C E G H I J\"":1,"\"J\"":1,"\"I\"":1,"\"H\"":1,"\"G\"":1,"\"F\"":2,"\"E\"":1},"javaDoc":"","comments":"Removing leaf Removing element with one child Removing element with two children Removing root ","isEmpty":false,"hasInnerClass":false,"lineCount":17,"modifier":9}
{"paramTypes":[],"returnType":"BinarySearchTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic BinarySearchTree() {\n    root = null;\n}\n","name":"BinarySearchTree","className":"BinarySearchTree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"addNode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":17,"FieldAccessExpr":3,"AssignExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(Comparable obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n}\n","name":"add","className":"BinarySearchTree","variables":{"obj":1,"root":3,"newNode":2},"constants":{"null":3},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":3,"MethodCallExpr":1,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(Comparable obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"BinarySearchTree","variables":{"current":4,"d":3,"root":1},"constants":{"0":2,"null":1,"true":1,"false":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"toBeRemoved.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Node":5,"int":1},"expressions":{"NullLiteralExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"BooleanLiteralExpr":2,"BinaryExpr":12,"NameExpr":88,"FieldAccessExpr":20,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":14},"statements":{"IfStmt":8,"WhileStmt":2,"BlockStmt":15,"ReturnStmt":2,"ExpressionStmt":21},"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(Comparable obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    Node parent = null;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            parent = toBeRemoved;\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        if (// Found in root\n        parent == null) {\n            root = newChild;\n        } else if (parent.left == toBeRemoved) {\n            parent.left = newChild;\n        } else {\n            parent.right = newChild;\n        }\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallestParent = toBeRemoved;\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallestParent = smallest;\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    if (smallestParent == toBeRemoved) {\n        smallestParent.right = smallest.right;\n    } else {\n        smallestParent.left = smallest.right;\n    }\n}\n","name":"remove","className":"BinarySearchTree","variables":{"parent":3,"smallestParent":3,"toBeRemoved":8,"found":4,"d":3,"newChild":6,"smallest":3,"root":2},"constants":{"0":2,"null":7,"false":1,"true":1},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child Found in root \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":18,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Prints the contents of the tree in sorted order.\n   */\npublic void print() {\n    print(root);\n    System.out.println();\n}\n","name":"print","className":"BinarySearchTree","variables":{},"constants":{},"javaDoc":"Prints the contents of the tree in sorted order","comments":"\n      Prints the contents of the tree in sorted order.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"print":2,"System.out.print":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":2,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":4,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   */\nprivate static void print(Node parent) {\n    if (parent == null) {\n        return;\n    }\n    print(parent.left);\n    System.out.print(parent.data + \" \");\n    print(parent.right);\n}\n","name":"print","className":"BinarySearchTree","variables":{"parent":1},"constants":{"null":1,"\" \"":1},"javaDoc":"Prints a node and all of its descendants in sorted order parent the root of the subtree to print","comments":"\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":10}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":4,"BlockStmt":6,"ExpressionStmt":5},"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":2,"right":3},"constants":{"0":2,"null":2},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Map<Character, Integer>"],"returnType":"HuffmanTree","methodCalls":{"add":2,"size":1,"get":1,"keySet":1,"remove":3},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Node":4,"char":1,"PriorityQueue":1,"PriorityQueue<Node>":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":2,"NameExpr":52,"FieldAccessExpr":7,"MethodCallExpr":8,"AssignExpr":6},"statements":{"WhileStmt":1,"BlockStmt":2,"ForeachStmt":1,"ExpressionStmt":13},"text":"/**\n      Constructs a Huffman tree from given character frequencies.\n      @param frequencies a map whose keys are the characters to be encoded\n      and whose values are the frequencies of the characters\n   */\npublic HuffmanTree(Map<Character, Integer> frequencies) {\n    PriorityQueue<Node> nodes = new PriorityQueue<>();\n    for (char ch : frequencies.keySet()) {\n        Node newNode = new Node();\n        newNode.character = ch;\n        newNode.frequency = frequencies.get(ch);\n        nodes.add(newNode);\n    }\n    while (nodes.size() > 1) {\n        Node smallest = nodes.remove();\n        Node nextSmallest = nodes.remove();\n        Node newNode = new Node();\n        newNode.frequency = smallest.frequency + nextSmallest.frequency;\n        newNode.left = smallest;\n        newNode.right = nextSmallest;\n        nodes.add(newNode);\n    }\n    root = nodes.remove();\n}\n","name":"HuffmanTree","className":"HuffmanTree","variables":{"nextSmallest":2,"nodes":7,"ch":2,"smallest":2,"root":1,"newNode":2,"frequencies":2},"constants":{"1":1},"javaDoc":"Constructs a Huffman tree from given character frequencies frequencies a map whose keys are the characters to be encoded and whose values are the frequencies of the characters","comments":"\n      Constructs a Huffman tree from given character frequencies.\n      @param frequencies a map whose keys are the characters to be encoded\n      and whose values are the frequencies of the characters\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"length":1,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"char":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":4,"StringLiteralExpr":1,"NameExpr":30,"CharLiteralExpr":1,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":4},"statements":{"IfStmt":2,"BlockStmt":4,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"/**\n      Decodes an encoded string.\n      @param input a string made up of 0 and 1\n   */\npublic String decode(String input) {\n    String result = \"\";\n    Node n = root;\n    for (int i = 0; i < input.length(); i++) {\n        char ch = input.charAt(i);\n        if (ch == '0') {\n            n = n.left;\n        } else {\n            n = n.right;\n        }\n        if (// n is a leaf\n        n.left == null) {\n            result = result + n.character;\n            n = root;\n        }\n    }\n    return result;\n}\n","name":"decode","className":"HuffmanTree","variables":{"result":4,"input":2,"ch":2,"root":2,"i":3,"n":4},"constants":{"\"\"":1,"0":1,"null":1,"'0'":1},"javaDoc":"Decodes an encoded string input a string made up of 0 and 1","comments":"n is a leaf \n      Decodes an encoded string.\n      @param input a string made up of 0 and 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"Map<Character, String>","methodCalls":{"fillEncodingMap":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<Character, String>":1,"HashMap":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public Map<Character, String> getEncodingMap() {\n    Map<Character, String> map = new HashMap<>();\n    if (root != null) {\n        root.fillEncodingMap(map, \"\");\n    }\n    return map;\n}\n","name":"getEncodingMap","className":"HuffmanTree","variables":{"root":2,"map":2},"constants":{"\"\"":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["Node"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"ReturnStmt":1},"text":"public int compareTo(Node other) {\n    return frequency - other.frequency;\n}\n","name":"compareTo","className":"Node","variables":{"frequency":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Map<Character, String>","String"],"returnType":"void","methodCalls":{"fillEncodingMap":2,"put":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":3,"NameExpr":16,"StringLiteralExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public void fillEncodingMap(Map<Character, String> map, String prefix) {\n    if (// it's a leaf\n    left == null) {\n        map.put(character, prefix);\n    } else {\n        left.fillEncodingMap(map, prefix + \"0\");\n        right.fillEncodingMap(map, prefix + \"1\");\n    }\n}\n","name":"fillEncodingMap","className":"Node","variables":{"left":2,"prefix":2,"right":1,"map":1},"constants":{"\"1\"":1,"null":1,"\"0\"":1},"javaDoc":"","comments":"it's a leaf ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"encode":1,"getEncodingMap":1,"decode":1,"put":13,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<Character, String>":1,"HashMap":1,"Map<Character, Integer>":1,"HuffmanTree":1,"String":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":13,"VariableDeclarationExpr":5,"NameExpr":62,"StringLiteralExpr":1,"CharLiteralExpr":13,"FieldAccessExpr":2,"MethodCallExpr":18},"statements":{"ExpressionStmt":20},"text":"public static void main(String[] args) {\n    Map<Character, Integer> frequencyMap = new HashMap<>();\n    frequencyMap.put('A', 2089);\n    frequencyMap.put('E', 576);\n    frequencyMap.put('H', 357);\n    frequencyMap.put('I', 671);\n    frequencyMap.put('K', 849);\n    frequencyMap.put('L', 354);\n    frequencyMap.put('M', 259);\n    frequencyMap.put('N', 660);\n    frequencyMap.put('O', 844);\n    frequencyMap.put('P', 239);\n    frequencyMap.put('U', 472);\n    frequencyMap.put('W', 74);\n    frequencyMap.put('\\'', 541);\n    HuffmanTree tree = new HuffmanTree(frequencyMap);\n    Map<Character, String> encodingMap = tree.getEncodingMap();\n    String encoded = encode(\"ALOHA\", encodingMap);\n    System.out.println(encoded);\n    String decoded = tree.decode(encoded);\n    System.out.println(decoded);\n}\n","name":"main","className":"HuffmanDemo","variables":{"encodingMap":1,"tree":3,"decoded":1,"frequencyMap":15,"encoded":1},"constants":{"'N'":1,"'L'":1,"'H'":1,"472":1,"671":1,"354":1,"576":1,"357":1,"259":1,"'W'":1,"239":1,"'U'":1,"74":1,"'O'":1,"'M'":1,"'K'":1,"'I'":1,"'\\''":1,"2089":1,"'E'":1,"'A'":1,"660":1,"541":1,"\"ALOHA\"":1,"844":1,"849":1,"'P'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":20,"modifier":9}
{"paramTypes":["String","Map<Character, String>"],"returnType":"String","methodCalls":{"get":1,"length":1,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"char":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"StringLiteralExpr":1,"NameExpr":16,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public static String encode(String toEncode, Map<Character, String> encodingMap) {\n    String result = \"\";\n    for (int i = 0; i < toEncode.length(); i++) {\n        char ch = toEncode.charAt(i);\n        result = result + encodingMap.get(ch);\n    }\n    return result;\n}\n","name":"encode","className":"HuffmanDemo","variables":{"result":4,"ch":1,"encodingMap":1,"toEncode":2,"i":3},"constants":{"\"\"":1,"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"removalTestTemplate":1,"insertionTest":1,"removalTest":1,"testFromBook":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    testFromBook();\n    insertionTest(\"ABCDEFGHIJ\");\n    removalTest(removalTestTemplate());\n    System.out.println(\"All tests passed.\");\n}\n","name":"main","className":"RedBlackTreeTester","variables":{},"constants":{"\"ABCDEFGHIJ\"":1,"\"All tests passed.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":10,"assertEquals":1,"toString":1,"remove":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"RedBlackTree":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":47,"StringLiteralExpr":15,"MethodCallExpr":16},"statements":{"ExpressionStmt":16},"text":"/**\n      Runs the simple test from the textbook.\n   */\npublic static void testFromBook() {\n    RedBlackTree t = new RedBlackTree();\n    t.add(\"D\");\n    t.add(\"B\");\n    t.add(\"A\");\n    t.add(\"C\");\n    t.add(\"F\");\n    t.add(\"E\");\n    t.add(\"I\");\n    t.add(\"G\");\n    t.add(\"H\");\n    t.add(\"J\");\n    // Removing leaf\n    t.remove(\"A\");\n    // Removing element with one child\n    t.remove(\"B\");\n    // Removing element with two children\n    t.remove(\"F\");\n    // Removing root      \n    t.remove(\"D\");\n    assertEquals(\"C E G H I J \", t.toString());\n}\n","name":"testFromBook","className":"RedBlackTreeTester","variables":{"t":16},"constants":{"\"D\"":2,"\"C\"":1,"\"B\"":2,"\"A\"":2,"\"J\"":1,"\"I\"":1,"\"H\"":1,"\"C E G H I J \"":1,"\"G\"":1,"\"F\"":2,"\"E\"":1},"javaDoc":"Runs the simple test from the textbook","comments":"Removing leaf Removing element with one child Removing element with two children Removing root \n      Runs the simple test from the textbook.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":16,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getPermutations":1,"add":1,"length":1,"replace":1,"assertEquals":1,"toString":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"RedBlackTree":1,"PermutationGenerator":1,"String":2,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":2,"NameExpr":26,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"BlockStmt":2,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Inserts all permutations of a string into a red-black tree and checks that \n      it contains the strings afterwards.\n      @param letters a string of letters without repetition\n   */\npublic static void insertionTest(String letters) {\n    PermutationGenerator gen = new PermutationGenerator(letters);\n    for (String perm : gen.getPermutations()) {\n        RedBlackTree t = new RedBlackTree();\n        for (int i = 0; i < perm.length(); i++) {\n            String s = perm.substring(i, i + 1);\n            t.add(s);\n        }\n        assertEquals(letters, t.toString().replace(\" \", \"\"));\n    }\n}\n","name":"insertionTest","className":"RedBlackTreeTester","variables":{"gen":2,"s":1,"perm":3,"t":3,"i":4,"letters":1},"constants":{"0":1,"\"\"":1,"1":1,"\" \"":1},"javaDoc":"Inserts all permutations of a string into a red-black tree and checks that it contains the strings afterwards letters a string of letters without repetition","comments":"\n      Inserts all permutations of a string into a red-black tree and checks that \n      it contains the strings afterwards.\n      @param letters a string of letters without repetition\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["RedBlackTree"],"returnType":"void","methodCalls":{"mirror":1,"getNodes":1,"count":1,"costToRoot":2,"remove":1,"populate":1,"setLeftChild":1,"find":2,"checkRedBlack":2,"equals":1,"pow":1,"copy":1,"fullTree":2,"setRightChild":1},"annotations":[],"exceptions":["IllegalStateException"],"concepts":[],"types":{"RedBlackTree.Node[]":1,"Integer":1,"RedBlackTree":1,"Comparable":1,"boolean":1,"RedBlackTree.Node":3,"int":7},"expressions":{"IntegerLiteralExpr":9,"ObjectCreationExpr":3,"NullLiteralExpr":3,"VariableDeclarationExpr":15,"BinaryExpr":15,"BooleanLiteralExpr":2,"NameExpr":120,"StringLiteralExpr":2,"FieldAccessExpr":14,"UnaryExpr":5,"MethodCallExpr":18,"AssignExpr":7},"statements":{"IfStmt":8,"BlockStmt":17,"TryStmt":1,"ForeachStmt":2,"ForStmt":3,"ThrowStmt":2,"ExpressionStmt":22},"text":"/**\n      Tests removal, given a template for a tree with a black node that\n      is to be deleted. All other nodes should be given all possible combinations \n      of red and black.\n      @param t the template for the test cases\n   */\npublic static void removalTest(RedBlackTree t) {\n    for (int m = 0; m <= 1; m++) {\n        // We don't recolor the root or toDelete\n        int nodesToColor = count(t.root) - 2;\n        for (int k = 0; k < Math.pow(2, nodesToColor); k++) {\n            RedBlackTree rb = new RedBlackTree();\n            if (m == 0) {\n                rb.root = copy(t.root);\n            } else {\n                rb.root = mirror(t.root);\n            }\n            RedBlackTree.Node[] nodes = getNodes(rb);\n            RedBlackTree.Node toDelete = null;\n            // Color with the bit pattern of k\n            int bits = k;\n            for (RedBlackTree.Node n : nodes) {\n                if (n == rb.root) {\n                    n.color = RedBlackTree.BLACK;\n                } else if (n.color == RedBlackTree.BLACK) {\n                    toDelete = n;\n                } else {\n                    n.color = bits % 2;\n                    bits = bits / 2;\n                }\n            }\n            // Add children to make equal costs to null\n            int targetCost = costToRoot(toDelete);\n            for (RedBlackTree.Node n : nodes) {\n                int cost = targetCost - costToRoot(n);\n                if (n.left == null) {\n                    n.setLeftChild(fullTree(cost));\n                }\n                if (n.right == null) {\n                    n.setRightChild(fullTree(cost));\n                }\n            }\n            int filledSize = populate(rb);\n            boolean good = true;\n            try {\n                checkRedBlack(rb);\n            } catch (IllegalStateException ex) {\n                good = false;\n            }\n            if (good) {\n                Comparable d = toDelete.data;\n                rb.remove(d);\n                checkRedBlack(rb);\n                for (Integer j = 0; j < filledSize; j++) {\n                    if (!rb.find(j) && !d.equals(j)) {\n                        throw new IllegalStateException(j + \" deleted\");\n                    }\n                    if (rb.find(d)) {\n                        throw new IllegalStateException(d + \" not deleted\");\n                    }\n                }\n            }\n        }\n    }\n}\n","name":"removalTest","className":"RedBlackTreeTester","variables":{"toDelete":2,"cost":1,"d":3,"targetCost":2,"bits":4,"j":4,"k":4,"Math":1,"m":4,"good":3,"n":6,"rb":4,"nodes":3,"ex":1,"filledSize":2,"nodesToColor":1},"constants":{"0":4,"1":1,"\" not deleted\"":1,"2":4,"null":3,"true":1,"false":1,"\" deleted\"":1},"javaDoc":"Tests removal given a template for a tree with a black node that is to be deleted All other nodes should be given all possible combinations of red and black t the template for the test cases","comments":"We don't recolor the root or toDelete Color with the bit pattern of k Add children to make equal costs to null \n      Tests removal, given a template for a tree with a black node that\n      is to be deleted. All other nodes should be given all possible combinations \n      of red and black.\n      @param t the template for the test cases\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"RedBlackTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"RedBlackTree.Node[]":1,"RedBlackTree":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":20,"VariableDeclarationExpr":3,"ArrayAccessExpr":19,"BinaryExpr":1,"NameExpr":50,"FieldAccessExpr":4,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":8},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":13},"text":"/**\n      Makes a template for testing removal.\n      @return a partially complete red-black tree for the test. \n      The node to be removed is black.\n   */\nprivate static RedBlackTree removalTestTemplate() {\n    RedBlackTree template = new RedBlackTree();\n    /*\n                            n7\n                           /  \\\n                          n1   n8\n                         /  \\\n                       n0    n3\n                            /  \\\n                           n2*  n5\n                                /\\\n                              n4  n6\n      */\n    RedBlackTree.Node[] n = new RedBlackTree.Node[9];\n    for (int i = 0; i < n.length; i++) {\n        n[i] = new RedBlackTree.Node();\n    }\n    template.root = n[7];\n    n[7].setLeftChild(n[1]);\n    n[7].setRightChild(n[8]);\n    n[1].setLeftChild(n[0]);\n    n[1].setRightChild(n[3]);\n    n[3].setLeftChild(n[2]);\n    n[3].setRightChild(n[5]);\n    n[5].setLeftChild(n[4]);\n    n[5].setRightChild(n[6]);\n    n[2].color = RedBlackTree.BLACK;\n    return template;\n}\n","name":"removalTestTemplate","className":"RedBlackTreeTester","variables":{"template":2,"i":4,"n":20},"constants":{"0":2,"1":3,"2":2,"3":3,"4":1,"5":3,"6":1,"7":3,"8":1,"9":1},"javaDoc":"Makes a template for testing removal a partially complete red-black tree for the test The node to be removed is black","comments":"n7 / \\ n1 n8 / \\ n0 n3 / \\ n2 n5 /\\ n4 n6 \n      Makes a template for testing removal.\n      @return a partially complete red-black tree for the test. \n      The node to be removed is black.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":15,"modifier":10}
{"paramTypes":["RedBlackTree"],"returnType":"RedBlackTree.Node[]","methodCalls":{"getNodes":1,"count":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"RedBlackTree.Node[]":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":12,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets all nodes of this tree in sorted order.\n      @param t a red-black tree\n      @return an array of all nodes in t\n   */\nprivate static RedBlackTree.Node[] getNodes(RedBlackTree t) {\n    RedBlackTree.Node[] nodes = new RedBlackTree.Node[count(t.root)];\n    getNodes(t.root, nodes, 0);\n    return nodes;\n}\n","name":"getNodes","className":"RedBlackTreeTester","variables":{"nodes":2},"constants":{"0":1},"javaDoc":"Gets all nodes of this tree in sorted order t a red-black tree an array of all nodes in t","comments":"\n      Gets all nodes of this tree in sorted order.\n      @param t a red-black tree\n      @return an array of all nodes in t\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["RedBlackTree.Node","RedBlackTree.Node[]","int"],"returnType":"int","methodCalls":{"getNodes":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":22,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":3},"text":"/**\n      Gets all nodes of a subtree and fills them into an array.\n      @param n the root of the subtree\n      @param nodes the array into which to place the nodes\n      @param start the offset at which to start placing the nodes\n      @return the number of nodes placed\n   */\nprivate static int getNodes(RedBlackTree.Node n, RedBlackTree.Node[] nodes, int start) {\n    if (n == null) {\n        return 0;\n    }\n    int leftFilled = getNodes(n.left, nodes, start);\n    nodes[start + leftFilled] = n;\n    int rightFilled = getNodes(n.right, nodes, start + leftFilled + 1);\n    return leftFilled + 1 + rightFilled;\n}\n","name":"getNodes","className":"RedBlackTreeTester","variables":{"nodes":1,"rightFilled":2,"start":2,"leftFilled":4,"n":2},"constants":{"0":1,"1":2,"null":1},"javaDoc":"Gets all nodes of a subtree and fills them into an array n the root of the subtree nodes the array into which to place the nodes start the offset at which to start placing the nodes the number of nodes placed","comments":"\n      Gets all nodes of a subtree and fills them into an array.\n      @param n the root of the subtree\n      @param nodes the array into which to place the nodes\n      @param start the offset at which to start placing the nodes\n      @return the number of nodes placed\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":11,"FieldAccessExpr":2,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the cost from a node to a root.\n      @param n a node of a red-black tree\n      @return the number of black nodes between n and the root\n   */\nprivate static int costToRoot(RedBlackTree.Node n) {\n    int c = 0;\n    while (n != null) {\n        c = c + n.color;\n        n = n.parent;\n    }\n    return c;\n}\n","name":"costToRoot","className":"RedBlackTreeTester","variables":{"c":4,"n":2},"constants":{"0":1,"null":1},"javaDoc":"Computes the cost from a node to a root n a node of a red-black tree the number of black nodes between n and the root","comments":"\n      Computes the cost from a node to a root.\n      @param n a node of a red-black tree\n      @return the number of black nodes between n and the root\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"RedBlackTree.Node","methodCalls":{"setLeftChild":1,"copy":2,"setRightChild":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"RedBlackTree.Node":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":30,"FieldAccessExpr":6,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":5},"text":"/**\n      Copies all nodes of a red-black tree.\n      @param n the root of a red-black tree\n      @return the root node of a copy of the tree\n   */\nprivate static RedBlackTree.Node copy(RedBlackTree.Node n) {\n    if (n == null) {\n        return null;\n    }\n    RedBlackTree.Node newNode = new RedBlackTree.Node();\n    newNode.setLeftChild(copy(n.left));\n    newNode.setRightChild(copy(n.right));\n    newNode.data = n.data;\n    newNode.color = n.color;\n    return newNode;\n}\n","name":"copy","className":"RedBlackTreeTester","variables":{"newNode":4,"n":1},"constants":{"null":2},"javaDoc":"Copies all nodes of a red-black tree n the root of a red-black tree the root node of a copy of the tree","comments":"\n      Copies all nodes of a red-black tree.\n      @param n the root of a red-black tree\n      @return the root node of a copy of the tree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"RedBlackTree.Node","methodCalls":{"mirror":2,"setLeftChild":1,"setRightChild":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"RedBlackTree.Node":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":30,"FieldAccessExpr":6,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":5},"text":"/**\n      Generates the mirror image of a red-black tree\n      @param n the root of the tree to reflect\n      @return the root of the mirror image of the tree\n   */\nprivate static RedBlackTree.Node mirror(RedBlackTree.Node n) {\n    if (n == null) {\n        return null;\n    }\n    RedBlackTree.Node newNode = new RedBlackTree.Node();\n    newNode.setLeftChild(mirror(n.right));\n    newNode.setRightChild(mirror(n.left));\n    newNode.data = n.data;\n    newNode.color = n.color;\n    return newNode;\n}\n","name":"mirror","className":"RedBlackTreeTester","variables":{"newNode":4,"n":1},"constants":{"null":2},"javaDoc":"Generates the mirror image of a red-black tree n the root of the tree to reflect the root of the mirror image of the tree","comments":"\n      Generates the mirror image of a red-black tree\n      @param n the root of the tree to reflect\n      @return the root of the mirror image of the tree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":10}
{"paramTypes":["int"],"returnType":"RedBlackTree.Node","methodCalls":{"setLeftChild":1,"fullTree":2,"setRightChild":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"RedBlackTree.Node":1},"expressions":{"IntegerLiteralExpr":3,"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":20,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Makes a full tree of black nodes of a given depth.\n      @param depth the desired depth\n      @return the root node of a full black tree\n   */\nprivate static RedBlackTree.Node fullTree(int depth) {\n    if (depth <= 0) {\n        return null;\n    }\n    RedBlackTree.Node r = new RedBlackTree.Node();\n    r.color = RedBlackTree.BLACK;\n    r.setLeftChild(fullTree(depth - 1));\n    r.setRightChild(fullTree(depth - 1));\n    return r;\n}\n","name":"fullTree","className":"RedBlackTreeTester","variables":{"r":4,"depth":3},"constants":{"0":1,"1":2,"null":1},"javaDoc":"Makes a full tree of black nodes of a given depth depth the desired depth the root node of a full black tree","comments":"\n      Makes a full tree of black nodes of a given depth.\n      @param depth the desired depth\n      @return the root node of a full black tree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"int","methodCalls":{"count":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":11,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Counts the nodes in a tree\n      @param n the root of a red-black tree\n      @return the number of nodes in the tree\n   */\nprivate static int count(RedBlackTree.Node n) {\n    if (n == null) {\n        return 0;\n    } else {\n        return 1 + count(n.left) + count(n.right);\n    }\n}\n","name":"count","className":"RedBlackTreeTester","variables":{"n":1},"constants":{"0":1,"1":1,"null":1},"javaDoc":"Counts the nodes in a tree n the root of a red-black tree the number of nodes in the tree","comments":"\n      Counts the nodes in a tree\n      @param n the root of a red-black tree\n      @return the number of nodes in the tree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["RedBlackTree"],"returnType":"int","methodCalls":{"getNodes":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"RedBlackTree.Node[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":16,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Populates this tree with the values 0, 1, 2, ... .\n      @param t a red-black tree\n      @return the number of nodes in t\n   */\nprivate static int populate(RedBlackTree t) {\n    RedBlackTree.Node[] nodes = getNodes(t);\n    for (int i = 0; i < nodes.length; i++) {\n        nodes[i].data = new Integer(i);\n    }\n    return nodes.length;\n}\n","name":"populate","className":"RedBlackTreeTester","variables":{"nodes":2,"i":5},"constants":{"0":1},"javaDoc":"Populates this tree with the values 0 1 2 t a red-black tree the number of nodes in t","comments":"\n      Populates this tree with the values 0, 1, 2, ... .\n      @param t a red-black tree\n      @return the number of nodes in t\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["RedBlackTree"],"returnType":"void","methodCalls":{"nodes[i].data.compareTo":1,"getNodes":1,"checkRedBlack":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"RedBlackTree.Node[]":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BooleanLiteralExpr":1,"BinaryExpr":7,"NameExpr":31,"StringLiteralExpr":1,"FieldAccessExpr":6,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ThrowStmt":1,"ExpressionStmt":2},"text":"/**\n      Checks whether a red-black tree is valid and throws an exception if not.\n      @param t the tree to test\n   */\npublic static void checkRedBlack(RedBlackTree t) {\n    checkRedBlack(t.root, true);\n    // Check that it's a BST\n    RedBlackTree.Node[] nodes = getNodes(t);\n    for (int i = 0; i < nodes.length - 1; i++) {\n        if (nodes[i].data.compareTo(nodes[i + 1].data) > 0) {\n            throw new IllegalStateException(nodes[i].data + \" is larger than \" + nodes[i + 1].data);\n        }\n    }\n}\n","name":"checkRedBlack","className":"RedBlackTreeTester","variables":{"nodes":5,"i":7},"constants":{"0":2,"1":3,"true":1,"\" is larger than \"":1},"javaDoc":"Checks whether a red-black tree is valid and throws an exception if not t the tree to test","comments":"Check that it's a BST \n      Checks whether a red-black tree is valid and throws an exception if not.\n      @param t the tree to test\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["RedBlackTree.Node","boolean"],"returnType":"int","methodCalls":{"checkRedBlack":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":2},"expressions":{"NullLiteralExpr":4,"IntegerLiteralExpr":1,"ObjectCreationExpr":8,"VariableDeclarationExpr":2,"BinaryExpr":31,"BooleanLiteralExpr":2,"NameExpr":99,"StringLiteralExpr":13,"FieldAccessExpr":30,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":10,"BlockStmt":11,"ReturnStmt":2,"ThrowStmt":8,"ExpressionStmt":2},"text":"/**\n      Checks that the tree with the given node is a red-black tree, and throws an\n      exception if a structural error is found.\n      @param n the root of the subtree to check\n      @param isRoot true if this is the root of the tree\n      @return the black depth of this subtree \n   */\nprivate static int checkRedBlack(RedBlackTree.Node n, boolean isRoot) {\n    if (n == null) {\n        return 0;\n    }\n    int nleft = checkRedBlack(n.left, false);\n    int nright = checkRedBlack(n.right, false);\n    if (nleft != nright) {\n        throw new IllegalStateException(\"Left and right children of \" + n.data + \" have different black depths\");\n    }\n    if (n.parent == null) {\n        if (!isRoot) {\n            throw new IllegalStateException(n.data + \" is not root and has no parent\");\n        }\n        if (n.color != RedBlackTree.BLACK) {\n            throw new IllegalStateException(\"Root \" + n.data + \" is not black\");\n        }\n    } else {\n        if (isRoot) {\n            throw new IllegalStateException(n.data + \" is root and has a parent\");\n        }\n        if (n.color == RedBlackTree.RED && n.parent.color == RedBlackTree.RED) {\n            throw new IllegalStateException(\"Parent of red \" + n.data + \" is red\");\n        }\n    }\n    if (n.left != null && n.left.parent != n) {\n        throw new IllegalStateException(\"Left child of \" + n.data + \" has bad parent link\");\n    }\n    if (n.right != null && n.right.parent != n) {\n        throw new IllegalStateException(\"Right child of \" + n.data + \" has bad parent link\");\n    }\n    if (n.color != RedBlackTree.RED && n.color != RedBlackTree.BLACK) {\n        throw new IllegalStateException(n.data + \" has color \" + n.color);\n    }\n    return n.color + nleft;\n}\n","name":"checkRedBlack","className":"RedBlackTreeTester","variables":{"nright":2,"isRoot":2,"nleft":3,"n":3},"constants":{"false":2,"\" have different black depths\"":1,"\" is not root and has no parent\"":1,"\" is red\"":1,"\" has bad parent link\"":2,"\" is not black\"":1,"\"Parent of red \"":1,"\"Left child of \"":1,"0":1,"\"Left and right children of \"":1,"null":4,"\" has color \"":1,"\"Root \"":1,"\" is root and has a parent\"":1,"\"Right child of \"":1},"javaDoc":"Checks that the tree with the given node is a red-black tree and throws an exception if a structural error is found n the root of the subtree to check isRoot true if this is the root of the tree the black depth of this subtree","comments":"\n      Checks that the tree with the given node is a red-black tree, and throws an\n      exception if a structural error is found.\n      @param n the root of the subtree to check\n      @param isRoot true if this is the root of the tree\n      @return the black depth of this subtree \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":10}
{"paramTypes":["Object","Object"],"returnType":"void","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"BinaryExpr":7,"NameExpr":8,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1},"text":"public static void assertEquals(Object expected, Object actual) {\n    if (expected == null && actual != null || !expected.equals(actual)) {\n        throw new AssertionError(\"Expected \" + expected + \" but found \" + actual);\n    }\n}\n","name":"assertEquals","className":"RedBlackTreeTester","variables":{"actual":2,"expected":3},"constants":{"null":2,"\"Expected \"":1,"\" but found \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"PermutationGenerator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a permutation generator.\n      @param aWord the word to permute\n   */\npublic PermutationGenerator(String aWord) {\n    word = aWord;\n}\n","name":"PermutationGenerator","className":"PermutationGenerator","variables":{"aWord":1,"word":1},"constants":{},"javaDoc":"Constructs a permutation generator aWord the word to permute","comments":"\n      Constructs a permutation generator.\n      @param aWord the word to permute\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ArrayList<String>","methodCalls":{"add":2,"getPermutations":1,"length":2,"substring":2,"charAt":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayList":1,"ArrayList<String>":2,"String":2,"PermutationGenerator":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":6,"BinaryExpr":5,"NameExpr":35,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":6},"text":"/**\n      Gets all permutations of a given word.\n   */\npublic ArrayList<String> getPermutations() {\n    ArrayList<String> permutations = new ArrayList<>();\n    // The empty string has a single permutation: itself\n    if (word.length() == 0) {\n        permutations.add(word);\n        return permutations;\n    }\n    // Loop through all character positions\n    for (int i = 0; i < word.length(); i++) {\n        // Form a simpler word by removing the ith character\n        String shorterWord = word.substring(0, i) + word.substring(i + 1);\n        // Generate all permutations of the simpler word\n        PermutationGenerator shorterPermutationGenerator = new PermutationGenerator(shorterWord);\n        ArrayList<String> shorterWordPermutations = shorterPermutationGenerator.getPermutations();\n        // each permutation of the simpler word, \n        for (String s : shorterWordPermutations) {\n            permutations.add(word.charAt(i) + s);\n        }\n    }\n    // Return all permutations\n    return permutations;\n}\n","name":"getPermutations","className":"PermutationGenerator","variables":{"shorterPermutationGenerator":2,"shorterWord":2,"s":2,"i":4,"shorterWordPermutations":2,"permutations":5,"word":5},"constants":{"0":3,"1":1},"javaDoc":"Gets all permutations of a given word","comments":"The empty string has a single permutation: itself Loop through all character positions Add the removed character to the front of Form a simpler word by removing the ith character Generate all permutations of the simpler word each permutation of the simpler word Return all permutations \n      Gets all permutations of a given word.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"RedBlackTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic RedBlackTree() {\n    root = null;\n}\n","name":"RedBlackTree","className":"RedBlackTree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"addNode":1,"fixAfterAdd":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"FieldAccessExpr":3,"AssignExpr":4,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(Comparable obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n    fixAfterAdd(newNode);\n}\n","name":"add","className":"RedBlackTree","variables":{"obj":1,"root":3,"newNode":2},"constants":{"null":3},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":3,"MethodCallExpr":1,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(Comparable obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"RedBlackTree","variables":{"current":4,"d":3,"root":1},"constants":{"0":2,"null":1,"true":1,"false":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"fixBeforeRemove":2,"toBeRemoved.data.compareTo":1,"replaceWith":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Node":3,"int":1},"expressions":{"NullLiteralExpr":5,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BooleanLiteralExpr":2,"BinaryExpr":9,"NameExpr":70,"FieldAccessExpr":14,"UnaryExpr":2,"MethodCallExpr":5,"AssignExpr":7},"statements":{"IfStmt":5,"WhileStmt":2,"BlockStmt":10,"ReturnStmt":2,"ExpressionStmt":16},"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(Comparable obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        fixBeforeRemove(toBeRemoved);\n        replaceWith(toBeRemoved, newChild);\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    fixBeforeRemove(smallest);\n    replaceWith(smallest, smallest.right);\n}\n","name":"remove","className":"RedBlackTree","variables":{"toBeRemoved":4,"found":4,"d":3,"newChild":3,"smallest":2,"root":1},"constants":{"0":2,"null":5,"false":1,"true":1},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":17,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Yields the contents of the tree in sorted order\n      @return all data items traversed in inorder, with a space after each item\n   */\npublic String toString() {\n    return toString(root);\n}\n","name":"toString","className":"RedBlackTree","variables":{},"constants":{},"javaDoc":"Yields the contents of the tree in sorted order all data items traversed in inorder with a space after each item","comments":"\n      Yields the contents of the tree in sorted order\n      @return all data items traversed in inorder, with a space after each item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Node"],"returnType":"String","methodCalls":{"toString":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":4,"NameExpr":14,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2},"text":"/**\n      Yields the contents of the subtree with the given root in sorted order\n      @param parent the root of the subtree\n      @return all data items traversed in inorder, with a space after each item\n   */\nprivate static String toString(Node parent) {\n    if (parent == null) {\n        return \"\";\n    }\n    return toString(parent.left) + parent.data + \" \" + toString(parent.right);\n}\n","name":"toString","className":"RedBlackTree","variables":{"parent":1},"constants":{"\"\"":1,"null":1,"\" \"":1},"javaDoc":"Yields the contents of the subtree with the given root in sorted order parent the root of the subtree all data items traversed in inorder with a space after each item","comments":"\n      Yields the contents of the subtree with the given root in sorted order\n      @param parent the root of the subtree\n      @return all data items traversed in inorder, with a space after each item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":10}
{"paramTypes":[],"returnType":"Node","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n         Constructs a red node with no data.\n      */\npublic Node() {\n}\n","name":"Node","className":"Node","variables":{},"constants":{},"javaDoc":"Constructs a red node with no data","comments":"\n         Constructs a red node with no data.\n      ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n         Sets the left child and updates its parent reference.\n         @param child the new left child\n      */\npublic void setLeftChild(Node child) {\n    left = child;\n    if (child != null) {\n        child.parent = this;\n    }\n}\n","name":"setLeftChild","className":"Node","variables":{"left":1,"child":2},"constants":{"null":1},"javaDoc":"Sets the left child and updates its parent reference child the new left child","comments":"\n         Sets the left child and updates its parent reference.\n         @param child the new left child\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n         Sets the right child and updates its parent reference.\n         @param child the new right child\n      */\npublic void setRightChild(Node child) {\n    right = child;\n    if (child != null) {\n        child.parent = this;\n    }\n}\n","name":"setRightChild","className":"Node","variables":{"right":1,"child":2},"constants":{"null":1},"javaDoc":"Sets the right child and updates its parent reference child the new right child","comments":"\n         Sets the right child and updates its parent reference.\n         @param child the new right child\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":28,"FieldAccessExpr":3,"ThisExpr":2,"MethodCallExpr":3,"AssignExpr":4},"statements":{"IfStmt":4,"BlockStmt":6,"ExpressionStmt":7},"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n            left.parent = this;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n            right.parent = this;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":2,"right":3},"constants":{"0":2,"null":2},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Node","Node"],"returnType":"void","methodCalls":{"toBeReplaced.parent.setLeftChild":1,"toBeReplaced.parent.setRightChild":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":2,"NameExpr":26,"FieldAccessExpr":6,"AssignExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":2,"BlockStmt":3,"ExpressionStmt":4},"text":"/**\n      Updates the parent's and replacement node's links when this node is replaced.\n      Also updates the root reference if it is replaced.\n      @param toBeReplaced the node that is to be replaced\n      @param replacement the node that replaces that node\n   */\nprivate void replaceWith(Node toBeReplaced, Node replacement) {\n    if (toBeReplaced.parent == null) {\n        replacement.parent = null;\n        root = replacement;\n    } else if (toBeReplaced == toBeReplaced.parent.left) {\n        toBeReplaced.parent.setLeftChild(replacement);\n    } else {\n        toBeReplaced.parent.setRightChild(replacement);\n    }\n}\n","name":"replaceWith","className":"RedBlackTree","variables":{"toBeReplaced":1,"root":1,"replacement":1},"constants":{"null":2},"javaDoc":"Updates the parent's and replacement node's links when this node is replaced Also updates the root reference if it is replaced toBeReplaced the node that is to be replaced replacement the node that replaces that node","comments":"\n      Updates the parent's and replacement node's links when this node is replaced.\n      Also updates the root reference if it is replaced.\n      @param toBeReplaced the node that is to be replaced\n      @param replacement the node that replaces that node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"fixDoubleRed":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":2,"NameExpr":20,"FieldAccessExpr":5,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ExpressionStmt":3},"text":"/**\n      Restores the tree to a red-black tree after a node has been added.\n      @param newNode the node that has been added\n   */\nprivate void fixAfterAdd(Node newNode) {\n    if (newNode.parent == null) {\n        newNode.color = BLACK;\n    } else {\n        newNode.color = RED;\n        if (newNode.parent.color == RED) {\n            fixDoubleRed(newNode);\n        }\n    }\n}\n","name":"fixAfterAdd","className":"RedBlackTree","variables":{"RED":2,"BLACK":1},"constants":{"null":1},"javaDoc":"Restores the tree to a red-black tree after a node has been added newNode the node that has been added","comments":"\n      Restores the tree to a red-black tree after a node has been added.\n      @param newNode the node that has been added\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"bubbleUp":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"BinaryExpr":5,"NameExpr":30,"FieldAccessExpr":9,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":3,"BlockStmt":5,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** \t\n     Fixes the tree so that it is a red-black tree after a node has been removed.\n     @param toBeRemoved the node that is to be removed\n   */\nprivate void fixBeforeRemove(Node toBeRemoved) {\n    if (toBeRemoved.color == RED) {\n        return;\n    }\n    if (// It is not a leaf\n    toBeRemoved.left != null || toBeRemoved.right != null) {\n        // Color the child black\n        if (toBeRemoved.left == null) {\n            toBeRemoved.right.color = BLACK;\n        } else {\n            toBeRemoved.left.color = BLACK;\n        }\n    } else {\n        bubbleUp(toBeRemoved.parent);\n    }\n}\n","name":"fixBeforeRemove","className":"RedBlackTree","variables":{"RED":1,"BLACK":2},"constants":{"null":3},"javaDoc":"Fixes the tree so that it is a red-black tree after a node has been removed toBeRemoved the node that is to be removed","comments":"It is not a leaf Color the child black  \t\n     Fixes the tree so that it is a red-black tree after a node has been removed.\n     @param toBeRemoved the node that is to be removed\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"bubbleUpFix":2,"bubbleUp":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":3,"NameExpr":40,"FieldAccessExpr":11,"UnaryExpr":3,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":5,"BlockStmt":6,"ReturnStmt":3,"ExpressionStmt":5},"text":"/**\n      Move a charge from two children of a parent\n      @param parent a node with two children, or null (in which case nothing is done)\n   */\nprivate void bubbleUp(Node parent) {\n    if (parent == null) {\n        return;\n    }\n    parent.color++;\n    parent.left.color--;\n    parent.right.color--;\n    if (bubbleUpFix(parent.left)) {\n        return;\n    }\n    if (bubbleUpFix(parent.right)) {\n        return;\n    }\n    if (parent.color == DOUBLE_BLACK) {\n        if (parent.parent == null) {\n            parent.color = BLACK;\n        } else {\n            bubbleUp(parent.parent);\n        }\n    }\n}\n","name":"bubbleUp","className":"RedBlackTree","variables":{"parent":1,"DOUBLE_BLACK":1,"BLACK":1},"constants":{"null":2},"javaDoc":"Move a charge from two children of a parent parent a node with two children or null (in which case nothing is done)","comments":"\n      Move a charge from two children of a parent\n      @param parent a node with two children, or null (in which case nothing is done)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":2}
{"paramTypes":["Node"],"returnType":"boolean","methodCalls":{"fixNegativeRed":1,"fixDoubleRed":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":8,"BooleanLiteralExpr":4,"NameExpr":39,"FieldAccessExpr":10,"MethodCallExpr":3},"statements":{"IfStmt":4,"BlockStmt":4,"ReturnStmt":4,"ExpressionStmt":3},"text":"/**\n      Fixes a negative-red or double-red violation introduced by bubbling up.\n      @param child the child to check for negative-red or double-red violations\n      @return true if the tree was fixed\n   */\nprivate boolean bubbleUpFix(Node child) {\n    if (child.color == NEGATIVE_RED) {\n        fixNegativeRed(child);\n        return true;\n    } else if (child.color == RED) {\n        if (child.left != null && child.left.color == RED) {\n            fixDoubleRed(child.left);\n            return true;\n        }\n        if (child.right != null && child.right.color == RED) {\n            fixDoubleRed(child.right);\n            return true;\n        }\n    }\n    return false;\n}\n","name":"bubbleUpFix","className":"RedBlackTree","variables":{"RED":3,"NEGATIVE_RED":1},"constants":{"null":2,"true":3,"false":1},"javaDoc":"Fixes a negative-red or double-red violation introduced by bubbling up child the child to check for negative-red or double-red violations true if the tree was fixed","comments":"\n      Fixes a negative-red or double-red violation introduced by bubbling up.\n      @param child the child to check for negative-red or double-red violations\n      @return true if the tree was fixed\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"setLeftChild":3,"fixDoubleRed":1,"setRightChild":3,"replaceWith":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"Node":3},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":9,"NameExpr":160,"FieldAccessExpr":28,"AssignExpr":29,"MethodCallExpr":8},"statements":{"IfStmt":6,"BlockStmt":9,"ReturnStmt":1,"ExpressionStmt":40},"text":"/**\n      Fixes a \"double red\" violation.\n      @param child the child with a red parent\n   */\nprivate void fixDoubleRed(Node child) {\n    Node parent = child.parent;\n    Node grandParent = parent.parent;\n    if (grandParent == null) {\n        parent.color = BLACK;\n        return;\n    }\n    Node n1, n2, n3, t1, t2, t3, t4;\n    if (parent == grandParent.left) {\n        n3 = grandParent;\n        t4 = grandParent.right;\n        if (child == parent.left) {\n            n1 = child;\n            n2 = parent;\n            t1 = child.left;\n            t2 = child.right;\n            t3 = parent.right;\n        } else {\n            n1 = parent;\n            n2 = child;\n            t1 = parent.left;\n            t2 = child.left;\n            t3 = child.right;\n        }\n    } else {\n        n1 = grandParent;\n        t1 = grandParent.left;\n        if (child == parent.left) {\n            n2 = child;\n            n3 = parent;\n            t2 = child.left;\n            t3 = child.right;\n            t4 = parent.right;\n        } else {\n            n2 = parent;\n            n3 = child;\n            t2 = parent.left;\n            t3 = child.left;\n            t4 = child.right;\n        }\n    }\n    replaceWith(grandParent, n2);\n    n1.setLeftChild(t1);\n    n1.setRightChild(t2);\n    n2.setLeftChild(n1);\n    n2.setRightChild(n3);\n    n3.setLeftChild(t3);\n    n3.setRightChild(t4);\n    n2.color = grandParent.color - 1;\n    n1.color = BLACK;\n    n3.color = BLACK;\n    if (n2 == root) {\n        root.color = BLACK;\n    } else if (n2.color == RED && n2.parent.color == RED) {\n        fixDoubleRed(n2);\n    }\n}\n","name":"fixDoubleRed","className":"RedBlackTree","variables":{"t4":4,"parent":6,"n1":6,"n2":8,"n3":6,"grandParent":4,"RED":2,"root":1,"BLACK":4,"t1":4,"t2":5,"t3":5,"child":6},"constants":{"1":1,"null":1},"javaDoc":"Fixes a \"double red\" violation child the child with a red parent","comments":"\n      Fixes a \"double red\" violation.\n      @param child the child with a red parent\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":16,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"setLeftChild":6,"fixDoubleRed":2,"setRightChild":6,"replaceWith":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":16},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":16,"BinaryExpr":7,"NameExpr":153,"FieldAccessExpr":26,"AssignExpr":8,"MethodCallExpr":16},"statements":{"IfStmt":3,"BlockStmt":4,"ExpressionStmt":40},"text":"/**\n      Fixes a \"negative red\" violation.\n      @param negRed the negative red node\n   */\nprivate void fixNegativeRed(Node negRed) {\n    Node parent = negRed.parent;\n    Node child;\n    if (parent.left == negRed) {\n        Node n1 = negRed.left;\n        Node n2 = negRed;\n        Node n3 = negRed.right;\n        Node n4 = parent;\n        Node t1 = n3.left;\n        Node t2 = n3.right;\n        Node t3 = n4.right;\n        n1.color = RED;\n        n2.color = BLACK;\n        n4.color = BLACK;\n        replaceWith(n4, n3);\n        n3.setLeftChild(n2);\n        n3.setRightChild(n4);\n        n2.setLeftChild(n1);\n        n2.setRightChild(t1);\n        n4.setLeftChild(t2);\n        n4.setRightChild(t3);\n        child = n1;\n    } else // Mirror image\n    {\n        Node n4 = negRed.right;\n        Node n3 = negRed;\n        Node n2 = negRed.left;\n        Node n1 = parent;\n        Node t3 = n2.right;\n        Node t2 = n2.left;\n        Node t1 = n1.left;\n        n4.color = RED;\n        n3.color = BLACK;\n        n1.color = BLACK;\n        replaceWith(n1, n2);\n        n2.setRightChild(n3);\n        n2.setLeftChild(n1);\n        n3.setRightChild(n4);\n        n3.setLeftChild(t3);\n        n1.setRightChild(t2);\n        n1.setLeftChild(t1);\n        child = n4;\n    }\n    if (child.left != null && child.left.color == RED) {\n        fixDoubleRed(child.left);\n    } else if (child.right != null && child.right.color == RED) {\n        fixDoubleRed(child.right);\n    }\n}\n","name":"fixNegativeRed","className":"RedBlackTree","variables":{"RED":4,"parent":3,"n1":5,"n2":6,"negRed":3,"n3":6,"n4":5,"BLACK":4,"t1":2,"t2":2,"child":3,"t3":2},"constants":{"null":2},"javaDoc":"Fixes a \"negative red\" violation negRed the negative red node","comments":"Mirror image \n      Fixes a \"negative red\" violation.\n      @param negRed the negative red node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      */\npublic int size() {\n    int sum = 0;\n    for (Node child : children) {\n        sum = sum + child.size();\n    }\n    return 1 + sum;\n}\n","name":"size","className":"Node","variables":{"children":1,"sum":4,"child":2},"constants":{"0":1,"1":1},"javaDoc":"Computes the size of the subtree whose root is this node the number of nodes in the subtree","comments":"\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Tree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic Tree() {\n    root = null;\n}\n","name":"Tree","className":"Tree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"Tree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":8,"FieldAccessExpr":2,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   */\npublic Tree(Object rootData) {\n    root = new Node();\n    root.data = rootData;\n    root.children = new ArrayList<>();\n}\n","name":"Tree","className":"Tree","variables":{"root":1,"rootData":1},"constants":{},"javaDoc":"Constructs a tree with one node and no children rootData the data for the root","comments":"\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["Tree"],"returnType":"void","methodCalls":{"root.children.add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds a subtree as the last child of the root.\n   */\npublic void addSubtree(Tree subtree) {\n    root.children.add(subtree.root);\n}\n","name":"addSubtree","className":"Tree","variables":{},"constants":{},"javaDoc":"Adds a subtree as the last child of the root","comments":"\n      Adds a subtree as the last child of the root.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   */\npublic int size() {\n    if (root == null) {\n        return 0;\n    } else {\n        return root.size();\n    }\n}\n","name":"size","className":"Tree","variables":{"root":2},"constants":{"0":1,"null":1},"javaDoc":"Computes the size of this tree the number of nodes in the tree","comments":"\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addSubtree":3,"size":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Tree":4},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":1,"StringLiteralExpr":5,"NameExpr":20,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Tree t1 = new Tree(\"Anne\");\n    Tree t2 = new Tree(\"Peter\");\n    t1.addSubtree(t2);\n    Tree t3 = new Tree(\"Zara\");\n    t1.addSubtree(t3);\n    Tree t4 = new Tree(\"Savannah\");\n    t2.addSubtree(t4);\n    System.out.println(\"Size: \" + t1.size());\n}\n","name":"main","className":"TreeDemo","variables":{"t4":1,"t1":4,"t2":2,"t3":1},"constants":{"\"Anne\"":1,"\"Peter\"":1,"\"Size: \"":1,"\"Savannah\"":1,"\"Zara\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    HeapSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"HeapSortDemo","variables":{"HeapSorter":1,"a":1,"Arrays":2,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"fixHeap":2,"swap":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":22,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    int n = a.length - 1;\n    for (int i = (n - 1) / 2; i >= 0; i--) {\n        fixHeap(a, i, n);\n    }\n    while (n > 0) {\n        ArrayUtil.swap(a, 0, n);\n        n--;\n        fixHeap(a, 0, n);\n    }\n}\n","name":"sort","className":"HeapSorter","variables":{"i":3,"n":4,"ArrayUtil":1},"constants":{"0":4,"1":2,"2":1},"javaDoc":"Sorts an array using selection sort a the array to sort","comments":"\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{"getLeftChildIndex":1,"getRightChildIndex":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":4},"expressions":{"VariableDeclarationExpr":5,"ArrayAccessExpr":7,"BooleanLiteralExpr":3,"BinaryExpr":5,"NameExpr":34,"MethodCallExpr":2,"AssignExpr":6},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":6,"ExpressionStmt":11},"text":"/**\n      Ensures the heap property for a subtree, provided its\n      children already fulfill the heap property.\n      @param a the array to sort\n      @param rootIndex the index of the subtree to be fixed\n      @param lastIndex the last valid index of the tree that \n      contains the subtree to be fixed\n   */\nprivate static void fixHeap(int[] a, int rootIndex, int lastIndex) {\n    // Remove root\n    int rootValue = a[rootIndex];\n    // Promote children while they are larger than the root      \n    int index = rootIndex;\n    boolean more = true;\n    while (more) {\n        int childIndex = getLeftChildIndex(index);\n        if (childIndex <= lastIndex) {\n            // Use right child instead if it is larger\n            int rightChildIndex = getRightChildIndex(index);\n            if (rightChildIndex <= lastIndex && a[rightChildIndex] > a[childIndex]) {\n                childIndex = rightChildIndex;\n            }\n            if (a[childIndex] > rootValue) {\n                // Promote child\n                a[index] = a[childIndex];\n                index = childIndex;\n            } else {\n                // Root value is larger than both children\n                more = false;\n            }\n        } else {\n            // No children\n            more = false;\n        }\n    }\n    // Store root value in vacant slot\n    a[index] = rootValue;\n}\n","name":"fixHeap","className":"HeapSorter","variables":{"a":7,"rootValue":3,"more":4,"rootIndex":2,"index":4,"childIndex":7,"lastIndex":2,"rightChildIndex":4},"constants":{"true":1,"false":2},"javaDoc":"Ensures the heap property for a subtree provided its children already fulfill the heap property a the array to sort rootIndex the index of the subtree to be fixed lastIndex the last valid index of the tree that contains the subtree to be fixed","comments":"Promote children while they are larger than the root Remove root Use right child instead if it is larger Promote child Root value is larger than both children No children Store root value in vacant slot \n      Ensures the heap property for a subtree, provided its\n      children already fulfill the heap property.\n      @param a the array to sort\n      @param rootIndex the index of the subtree to be fixed\n      @param lastIndex the last valid index of the tree that \n      contains the subtree to be fixed\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   */\nprivate static int getLeftChildIndex(int index) {\n    return 2 * index + 1;\n}\n","name":"getLeftChildIndex","className":"HeapSorter","variables":{"index":1},"constants":{"1":1,"2":1},"javaDoc":"Returns the index of the left child index the index of a node in this heap the index of the left child of the given node","comments":"\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   */\nprivate static int getRightChildIndex(int index) {\n    return 2 * index + 2;\n}\n","name":"getRightChildIndex","className":"HeapSorter","variables":{"index":1},"constants":{"2":2},"javaDoc":"Returns the index of the right child index the index of a node in this heap the index of the right child of the given node","comments":"\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      */\npublic int size() {\n    int sum = 0;\n    for (Node child : children) {\n        sum = sum + child.size();\n    }\n    return 1 + sum;\n}\n","name":"size","className":"Node","variables":{"children":1,"sum":4,"child":2},"constants":{"0":1,"1":1},"javaDoc":"Computes the size of the subtree whose root is this node the number of nodes in the subtree","comments":"\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Tree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic Tree() {\n    root = null;\n}\n","name":"Tree","className":"Tree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"Tree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":8,"FieldAccessExpr":2,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   */\npublic Tree(Object rootData) {\n    root = new Node();\n    root.data = rootData;\n    root.children = new LinkedList<>();\n}\n","name":"Tree","className":"Tree","variables":{"root":1,"rootData":1},"constants":{},"javaDoc":"Constructs a tree with one node and no children rootData the data for the root","comments":"\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["Tree"],"returnType":"void","methodCalls":{"root.children.add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds a subtree as the last child of the root.\n   */\npublic void addSubtree(Tree subtree) {\n    root.children.add(subtree.root);\n}\n","name":"addSubtree","className":"Tree","variables":{},"constants":{},"javaDoc":"Adds a subtree as the last child of the root","comments":"\n      Adds a subtree as the last child of the root.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   */\npublic int size() {\n    if (root == null) {\n        return 0;\n    } else {\n        return root.size();\n    }\n}\n","name":"size","className":"Tree","variables":{"root":2},"constants":{"0":1,"null":1},"javaDoc":"Computes the size of this tree the number of nodes in the tree","comments":"\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n         This method is called for each visited node.\n         @param data the data of the node\n      */\nvoid visit(Object data);\n","name":"visit","className":"Visitor","variables":{},"constants":{},"javaDoc":"This method is called for each visited node data the data of the node","comments":"\n         This method is called for each visited node.\n         @param data the data of the node\n      ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Visitor"],"returnType":"void","methodCalls":{"preorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Traverses this tree in preorder.\n      @param v the visitor to be invoked at each node\n   */\npublic void preorder(Visitor v) {\n    preorder(root, v);\n}\n","name":"preorder","className":"Tree","variables":{},"constants":{},"javaDoc":"Traverses this tree in preorder v the visitor to be invoked at each node","comments":"\n      Traverses this tree in preorder.\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Node","Visitor"],"returnType":"void","methodCalls":{"visit":1,"preorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"Node":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":14,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Traverses the tree with a given root in preorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   */\nprivate static void preorder(Node n, Visitor v) {\n    if (n == null) {\n        return;\n    }\n    v.visit(n.data);\n    for (Node c : n.children) {\n        preorder(c, v);\n    }\n}\n","name":"preorder","className":"Tree","variables":{"c":1,"v":1,"n":1},"constants":{"null":1},"javaDoc":"Traverses the tree with a given root in preorder n the root of the tree v the visitor to be invoked at each node","comments":"\n      Traverses the tree with a given root in preorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["Visitor"],"returnType":"void","methodCalls":{"postorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Traverses this tree in postorder.\n      @param v the visitor to be invoked at each node\n   */\npublic void postorder(Visitor v) {\n    postorder(root, v);\n}\n","name":"postorder","className":"Tree","variables":{},"constants":{},"javaDoc":"Traverses this tree in postorder v the visitor to be invoked at each node","comments":"\n      Traverses this tree in postorder.\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Node","Visitor"],"returnType":"void","methodCalls":{"visit":1,"postorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"Node":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":14,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Traverses the tree with a given root in postorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   */\nprivate static void postorder(Node n, Visitor v) {\n    if (n == null) {\n        return;\n    }\n    for (Node c : n.children) {\n        postorder(c, v);\n    }\n    v.visit(n.data);\n}\n","name":"postorder","className":"Tree","variables":{"c":1,"v":1,"n":1},"constants":{"null":1},"javaDoc":"Traverses the tree with a given root in postorder n the root of the tree v the visitor to be invoked at each node","comments":"\n      Traverses the tree with a given root in postorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["Node"],"returnType":"BreadthFirstIterator","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n         Constructs an iterator for a given tree.\n         @param root the root of the tree\n      */\npublic BreadthFirstIterator(Node root) {\n    q = new LinkedList<>();\n    if (root != null) {\n        q.add(root);\n    }\n}\n","name":"BreadthFirstIterator","className":"BreadthFirstIterator","variables":{"q":2,"root":1},"constants":{"null":1},"javaDoc":"Constructs an iterator for a given tree root the root of the tree","comments":"\n         Constructs an iterator for a given tree.\n         @param root the root of the tree\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean hasNext() {\n    return q.size() > 0;\n}\n","name":"hasNext","className":"BreadthFirstIterator","variables":{"q":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"add":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":2},"expressions":{"VariableDeclarationExpr":2,"NameExpr":13,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public Object next() {\n    Node n = q.remove();\n    for (Node c : n.children) {\n        q.add(c);\n    }\n    return n.data;\n}\n","name":"next","className":"BreadthFirstIterator","variables":{"q":2,"c":1,"n":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ThrowStmt":1},"text":"public void remove() {\n    throw new UnsupportedOperationException();\n}\n","name":"remove","className":"BreadthFirstIterator","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Iterator iterator() {\n    return new BreadthFirstIterator(root);\n}\n","name":"iterator","className":"Tree","variables":{"root":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"length":1,"toString":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":12,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"public void visit(Object data) {\n    System.out.println(data);\n    if (data.toString().length() <= 5) {\n        counter++;\n    }\n}\n","name":"visit","className":"ShortNameCounter","variables":{"data":1,"counter":1},"constants":{"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"addSubtree":3,"iterator":1,"length":2,"toString":2,"hasNext":1,"preorder":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["InnerMethod","InnerClass"],"types":{"Iterator":1,"Tree":4,"ShortNameCounter":1,"Object":1,"int":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":8,"BinaryExpr":4,"StringLiteralExpr":6,"NameExpr":67,"FieldAccessExpr":5,"UnaryExpr":2,"MethodCallExpr":15},"statements":{"IfStmt":2,"WhileStmt":1,"TypeDeclarationStmt":1,"BlockStmt":4,"ExpressionStmt":18},"text":"public static void main(String[] args) {\n    Tree t1 = new Tree(\"Anne\");\n    Tree t2 = new Tree(\"Peter\");\n    t1.addSubtree(t2);\n    Tree t3 = new Tree(\"Zara\");\n    t1.addSubtree(t3);\n    Tree t4 = new Tree(\"Savannah\");\n    t2.addSubtree(t4);\n    // Count short names with visitor\n    class ShortNameCounter implements Tree.Visitor {\n\n        public int counter = 0;\n\n        public void visit(Object data) {\n            System.out.println(data);\n            if (data.toString().length() <= 5) {\n                counter++;\n            }\n        }\n    }\n    ShortNameCounter v = new ShortNameCounter();\n    t1.preorder(v);\n    System.out.println(\"Short names: \" + v.counter);\n    // Count short names with iterator\n    Iterator iter = t1.iterator();\n    int counter = 0;\n    while (iter.hasNext()) {\n        Object data = iter.next();\n        System.out.println(data);\n        if (data.toString().length() <= 5) {\n            counter++;\n        }\n    }\n    System.out.println(\"Short names: \" + counter);\n}\n","name":"main","className":"TraversalDemo","variables":{"t4":1,"data":4,"v":1,"ShortNameCounter":1,"iter":3,"counter":5,"visit":1,"t1":5,"t2":2,"t3":1},"constants":{"\"Anne\"":1,"0":2,"\"Peter\"":1,"5":2,"\"Short names: \"":2,"\"Savannah\"":1,"\"Zara\"":1},"javaDoc":"","comments":"Count short names with visitor Count short names with iterator ","isEmpty":false,"hasInnerClass":false,"lineCount":15,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":25,"StringLiteralExpr":1,"FieldAccessExpr":3,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":2,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    int[] values = new int[10];\n    for (int i = 0; i < values.length; i++) {\n        values[i] = i * i;\n    }\n    // In this loop, we don't need the index value. \n    // The enhanced for loop simplifies the code.\n    int total = 0;\n    for (int element : values) {\n        System.out.println(element);\n        total = total + element;\n    }\n    System.out.println(\"Sum: \" + total);\n}\n","name":"main","className":"EnhancedForLoopDemo","variables":{"total":4,"values":3,"i":6,"element":2},"constants":{"0":2,"\"Sum: \"":1,"10":1},"javaDoc":"","comments":"In this loop we need the index value so we can't use an enhanced for loop In this loop we don't need the index value The enhanced for loop simplifies the code ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":3},"expressions":{"IntegerLiteralExpr":11,"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"ArrayAccessExpr":4,"BinaryExpr":3,"NameExpr":27,"FieldAccessExpr":3,"UnaryExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    int[] values = { 9, 13, 21, 4, 11, 7, 1, 3 };\n    int i = 0;\n    int j = values.length / 2;\n    while (i < values.length / 2) {\n        // Swap values at positions i and j\n        int temp = values[i];\n        values[i] = values[j];\n        values[j] = temp;\n        i++;\n        j++;\n    }\n    System.out.println(Arrays.toString(values));\n}\n","name":"main","className":"SwapHalves","variables":{"temp":2,"values":5,"i":5,"j":4,"Arrays":1},"constants":{"11":1,"0":1,"1":1,"13":1,"2":2,"3":1,"4":1,"7":1,"9":1,"21":1},"javaDoc":"","comments":"Swap values at positions i and j ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":3,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int[][]":1,"String[]":1,"int":5},"expressions":{"IntegerLiteralExpr":29,"VariableDeclarationExpr":7,"ArrayInitializerExpr":10,"ArrayAccessExpr":5,"BinaryExpr":3,"StringLiteralExpr":12,"NameExpr":37,"FieldAccessExpr":4,"UnaryExpr":2,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    final int COUNTRIES = 8;\n    final int MEDALS = 3;\n    String[] countries = { \"Canada\", \"Italy\", \"Germany\", \"Japan\", \"Kazakhstan\", \"Russia\", \"South Korea\", \"United States\" };\n    int[][] counts = { { 0, 3, 0 }, { 0, 0, 1 }, { 0, 0, 1 }, { 1, 0, 0 }, { 0, 0, 1 }, { 3, 1, 1 }, { 0, 1, 0 }, { 1, 0, 1 } };\n    System.out.println(\"        Country    Gold  Silver  Bronze   Total\");\n    // Print countries, counts, and row totals\n    for (int i = 0; i < COUNTRIES; i++) {\n        // Process the ith row\n        System.out.printf(\"%15s\", countries[i]);\n        int total = 0;\n        // Print each row element and update the row total\n        for (int j = 0; j < MEDALS; j++) {\n            System.out.printf(\"%8d\", counts[i][j]);\n            total = total + counts[i][j];\n        }\n        // Display the row total and print a new line\n        System.out.printf(\"%8d\\n\", total);\n    }\n}\n","name":"main","className":"Medals","variables":{"total":3,"COUNTRIES":2,"counts":3,"i":6,"j":5,"countries":2,"MEDALS":2},"constants":{"\"Kazakhstan\"":1,"\"%8d\"":1,"\"Germany\"":1,"\"South Korea\"":1,"0":16,"1":9,"3":3,"\"%15s\"":1,"\"United States\"":1,"\"        Country    Gold  Silver  Bronze   Total\"":1,"\"Italy\"":1,"8":1,"\"Canada\"":1,"\"%8d\\n\"":1,"\"Japan\"":1,"\"Russia\"":1},"javaDoc":"","comments":"Print countries counts and row totals Process the ith row Print each row element and update the row total Display the row total and print a new line ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"hasNextDouble":1,"nextDouble":1,"System.out.print":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Scanner":1,"double[]":1,"double":1,"int":4},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":7,"ArrayAccessExpr":6,"BinaryExpr":6,"NameExpr":55,"StringLiteralExpr":2,"FieldAccessExpr":6,"ArrayCreationExpr":1,"UnaryExpr":3,"MethodCallExpr":6,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ForStmt":2,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    final int LENGTH = 100;\n    double[] values = new double[LENGTH];\n    int currentSize = 0;\n    // Read inputs\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble() && currentSize < values.length) {\n        values[currentSize] = in.nextDouble();\n        currentSize++;\n    }\n    // Find the largest value\n    double largest = values[0];\n    for (int i = 1; i < currentSize; i++) {\n        if (values[i] > largest) {\n            largest = values[i];\n        }\n    }\n    for (int i = 0; i < currentSize; i++) {\n        System.out.print(values[i]);\n        if (values[i] == largest) {\n            System.out.print(\" <== largest value\");\n        }\n        System.out.println();\n    }\n}\n","name":"main","className":"LargestInArray","variables":{"largest":4,"in":3,"LENGTH":2,"values":7,"i":10,"currentSize":6},"constants":{"0":3,"\"Please enter values, Q to quit:\"":1,"\" <== largest value\"":1,"100":1,"1":1},"javaDoc":"","comments":"Read inputs Find the largest value Print all values marking the largest ","isEmpty":false,"hasInnerClass":false,"lineCount":12,"modifier":9}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   */\npublic Student(int capacity) {\n    scores = new double[capacity];\n    scoresSize = 0;\n}\n","name":"Student","className":"Student","variables":{"scoresSize":1,"scores":1,"capacity":1},"constants":{"0":1},"javaDoc":"Constructs a student with no scores and a maximum number of scores @capacity the maximum number of scores for this student","comments":"\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":8,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   */\npublic boolean addScore(double score) {\n    if (scoresSize < scores.length) {\n        scores[scoresSize] = score;\n        scoresSize++;\n        return true;\n    } else {\n        return false;\n    }\n}\n","name":"addScore","className":"Student","variables":{"scoresSize":3,"score":1,"scores":1},"constants":{"true":1,"false":1},"javaDoc":"Adds a score for this student score the score to add true if the score was added false if there was no room to add the score","comments":"\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   */\npublic double sum() {\n    double total = 0;\n    for (int i = 0; i < scoresSize; i++) {\n        total = total + scores[i];\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"scoresSize":1,"total":4,"scores":1,"i":4},"constants":{"0":2},"javaDoc":"Computes the sum of the scores of this student the sum of the scores","comments":"\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":12,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   */\npublic double minimum() {\n    if (scoresSize == 0) {\n        return 0;\n    }\n    double smallest = scores[0];\n    for (int i = 1; i < scoresSize; i++) {\n        if (scores[i] < smallest) {\n            smallest = scores[i];\n        }\n    }\n    return smallest;\n}\n","name":"minimum","className":"Student","variables":{"scoresSize":2,"scores":3,"smallest":4,"i":5},"constants":{"0":3,"1":1},"javaDoc":"Gets the minimum score of this student the minimum score or 0 if there are no scores","comments":"\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sum":1,"minimum":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":5,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped.\n   */\npublic double finalScore() {\n    if (scoresSize == 0) {\n        return 0;\n    } else {\n        return sum() - minimum();\n    }\n}\n","name":"finalScore","className":"Student","variables":{"scoresSize":1},"constants":{"0":2},"javaDoc":"Gets the final score for this student the sum of the scores with the lowest score dropped","comments":"\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"finalScore":1,"addScore":1,"hasNextDouble":1,"nextDouble":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Student":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":30,"StringLiteralExpr":3,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    Student fred = new Student(100);\n    System.out.println(\"Please enter values, Q to quit:\");\n    while (in.hasNextDouble()) {\n        if (!fred.addScore(in.nextDouble())) {\n            System.out.println(\"Too many scores.\");\n            return;\n        }\n    }\n    System.out.println(\"Final score: \" + fred.finalScore());\n}\n","name":"main","className":"ScoreAnalyzer","variables":{"in":3,"fred":3},"constants":{"\"Please enter values, Q to quit:\"":1,"100":1,"\"Too many scores.\"":1,"\"Final score: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["int"],"returnType":"Dice","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":2,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Dice(int sides) {\n    // counters[0] is not used\n    counters = new int[sides + 1];\n}\n","name":"Dice","className":"Dice","variables":{"counters":1,"sides":1},"constants":{"1":1},"javaDoc":"","comments":"counters[0] is not used ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"hasNextInt":1,"nextInt":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":27,"StringLiteralExpr":2,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"public void countInputs() {\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextInt()) {\n        int value = in.nextInt();\n        if (1 <= value && value <= counters.length) {\n            counters[value]++;\n        } else {\n            System.out.println(value + \" is not a valid input.\");\n        }\n    }\n}\n","name":"countInputs","className":"Dice","variables":{"counters":1,"in":3,"value":5},"constants":{"\"Please enter values, Q to quit:\"":1,"1":1,"\" is not a valid input.\"":1},"javaDoc":"","comments":"Increment the counter for the input value ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"public void printCounters() {\n    for (int i = 1; i < counters.length; i++) {\n        System.out.printf(\"%2d: %4d\\n\", i, counters[i]);\n    }\n}\n","name":"printCounters","className":"Dice","variables":{"counters":1,"i":4},"constants":{"1":1,"\"%2d: %4d\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"countInputs":1,"printCounters":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Dice":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    final int SIDES = 6;\n    Dice dice = new Dice(SIDES);\n    dice.countInputs();\n    dice.printCounters();\n}\n","name":"main","className":"DiceAnalyzer","variables":{"dice":3,"SIDES":2},"constants":{"6":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":3,"System.out.print":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int[][]":1,"String[]":1,"int":7},"expressions":{"IntegerLiteralExpr":49,"VariableDeclarationExpr":9,"ArrayInitializerExpr":8,"ArrayAccessExpr":5,"BinaryExpr":5,"StringLiteralExpr":11,"NameExpr":58,"FieldAccessExpr":7,"UnaryExpr":4,"MethodCallExpr":7,"AssignExpr":1},"statements":{"BlockStmt":4,"ForStmt":4,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    final int ROWS = 6;\n    final int COLUMNS = 7;\n    int[][] populations = { { 106, 107, 111, 133, 221, 767, 1766 }, { 502, 635, 809, 947, 1402, 3634, 5268 }, { 2, 2, 2, 6, 13, 30, 46 }, { 163, 203, 276, 408, 547, 729, 628 }, { 2, 7, 26, 82, 172, 307, 392 }, { 16, 24, 38, 74, 167, 511, 809 } };\n    String[] continents = { \"Africa\", \"Asia\", \"Australia\", \"Europe\", \"North America\", \"South America\" };\n    System.out.println(\"                Year 1750 1800 1850 1900 1950 2000 2050\");\n    for (int i = 0; i < ROWS; i++) {\n        // Print the ith row\n        System.out.printf(\"%20s\", continents[i]);\n        for (int j = 0; j < COLUMNS; j++) {\n            System.out.printf(\"%5d\", populations[i][j]);\n        }\n        // Start a new line at the end of the row\n        System.out.println();\n    }\n    // Print column totals\n    System.out.print(\"               World\");\n    for (int j = 0; j < COLUMNS; j++) {\n        int total = 0;\n        for (int i = 0; i < ROWS; i++) {\n            total = total + populations[i][j];\n        }\n        System.out.printf(\"%5d\", total);\n    }\n    System.out.println();\n}\n","name":"main","className":"WorldPopulation","variables":{"total":3,"i":9,"COLUMNS":3,"j":8,"populations":3,"continents":2,"ROWS":3},"constants":{"46":1,"\"Africa\"":1,"5268":1,"392":1,"111":1,"276":1,"511":1,"635":1,"3634":1,"13":1,"16":1,"\"Europe\"":1,"163":1,"0":5,"2":4,"167":1,"203":1,"\"%20s\"":1,"6":2,"7":2,"767":1,"408":1,"\"Australia\"":1,"729":1,"\"South America\"":1,"809":2,"24":1,"26":1,"172":1,"133":1,"\"Asia\"":1,"30":1,"74":1,"\"North America\"":1,"\"%5d\"":2,"\"                Year 1750 1800 1850 1900 1950 2000 2050\"":1,"38":1,"\"               World\"":1,"221":1,"1766":1,"1402":1,"106":1,"502":1,"107":1,"547":1,"82":1,"307":1,"947":1,"628":1},"javaDoc":"","comments":"Print population data Print column totals Print the ith row Start a new line at the end of the row ","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":4,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Scanner":1,"boolean":1,"int[]":3,"String[]":1,"int":8},"expressions":{"IntegerLiteralExpr":12,"ObjectCreationExpr":1,"VariableDeclarationExpr":14,"ArrayAccessExpr":7,"BinaryExpr":13,"NameExpr":102,"StringLiteralExpr":10,"UnaryExpr":8,"AssignExpr":4,"ArrayInitializerExpr":1,"BooleanLiteralExpr":2,"FieldAccessExpr":15,"ArrayCreationExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":8,"ForStmt":5,"ExpressionStmt":24},"text":"public static void main(String[] args) {\n    // An array of five values, initialized in a loop\n    int[] values = new int[5];\n    for (int i = 0; i < values.length; i++) {\n        values[i] = 2 * i;\n    }\n    // An array of four strings, with initial values specified\n    String[] names = { \"Fred\", \"Amy\", \"Cindy\", \"Henry\" };\n    for (int i = 0; i < values.length; i++) {\n        System.out.print(values[i] + \" \");\n    }\n    System.out.println();\n    for (int i = 0; i < names.length; i++) {\n        System.out.print(names[i] + \" \");\n    }\n    System.out.println();\n    // When you copy an array variable, you get another reference \n    // to the same array. (See Section 7.1.2.)\n    int[] copy = values;\n    values[0] = 42;\n    for (int i = 0; i < copy.length; i++) {\n        System.out.print(copy[i] + \" \");\n    }\n    System.out.println();\n    // Here, we read numbers into a partially filled array.\n    // (See Section 7.1.4.)\n    System.out.println(\"Enter scores, -1 to quit: \");\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    int currentSize = 0;\n    final int LENGTH = 100;\n    int[] scores = new int[LENGTH];\n    while (!done && currentSize < LENGTH) {\n        int score = in.nextInt();\n        if (score == -1) {\n            done = true;\n        } else {\n            scores[currentSize] = score;\n            currentSize++;\n        }\n    }\n    System.out.println(\"You entered the following scores:\");\n    for (int i = 0; i < currentSize; i++) {\n        System.out.print(scores[i] + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"ArrayDemo","variables":{"score":3,"names":2,"in":2,"scores":3,"values":5,"LENGTH":3,"i":21,"copy":2,"done":3,"currentSize":5},"constants":{"\"You entered the following scores:\"":1,"\"Fred\"":1,"\"Enter scores, -1 to quit: \"":1,"\"Cindy\"":1,"\" \"":4,"false":1,"\"Amy\"":1,"0":7,"100":1,"1":1,"2":1,"5":1,"true":1,"42":1,"\"Henry\"":1},"javaDoc":"","comments":"An array of five values initialized in a loop An array of four strings with initial values specified These loops print the elements in both arrays When you copy an array variable you get another reference to the same array (See Section 7 1 2 ) We change values[0] which is the same as copy[0] Here we read numbers into a partially filled array (See Section 7 1 4 ) ","isEmpty":false,"hasInnerClass":false,"lineCount":29,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pick":1,"show":2,"getSampleValues":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"SoundClip":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":21,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    SoundClip clip = new SoundClip();\n    clip.pick();\n    clip.show();\n    int[] samples = clip.getSampleValues();\n    for (int i = 0; i < samples.length; i++) {\n        samples[i] = 3 * samples[i];\n    }\n    clip.show();\n}\n","name":"main","className":"SoundClipDemo","variables":{"i":5,"clip":5,"samples":3},"constants":{"0":1,"3":1},"javaDoc":"","comments":"In this example we don't need the sample rate If you do call clip getSampleRate(); ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":[],"returnType":"int[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int[] getSampleValues() {\n    return samples;\n}\n","name":"getSampleValues","className":"SoundClip","variables":{"samples":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getSampleRate() {\n    return sampleRate;\n}\n","name":"getSampleRate","className":"SoundClip","variables":{"sampleRate":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showOpenDialog":1,"load":1,"getSelectedFile":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Displays a file chooser for picking a clip.\n   */\npublic void pick() {\n    JFileChooser chooser = new JFileChooser(\".\");\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        load(chooser.getSelectedFile());\n    }\n}\n","name":"pick","className":"SoundClip","variables":{"chooser":3},"constants":{"null":1,"\".\"":1},"javaDoc":"Displays a file chooser for picking a clip","comments":"\n      Displays a file chooser for picking a clip.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"SoundClipFrame":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Shows a frame with the sample values and a Play button\n   */\npublic void show() {\n    if (samples != null) {\n        JFrame frame = new SoundClipFrame();\n        frame.setVisible(true);\n    }\n}\n","name":"show","className":"SoundClip","variables":{"samples":1,"frame":2},"constants":{"null":1,"true":1},"javaDoc":"Shows a frame with the sample values and a Play button","comments":"\n      Shows a frame with the sample values and a Play button\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["File"],"returnType":"void","methodCalls":{"getSignedInt2":1,"read":1,"getUnsignedInt2":4,"getMessage":1,"getUnsignedInt4":1,"error":5},"annotations":[],"exceptions":["Exception"],"concepts":["PolyMorphism"],"types":{"InputStream":1,"FileInputStream":1,"int":7},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":12,"VariableDeclarationExpr":8,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":48,"StringLiteralExpr":4,"CastExpr":1,"UnaryExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":13,"AssignExpr":4},"statements":{"IfStmt":4,"TryStmt":1,"BlockStmt":8,"ForStmt":2,"ExpressionStmt":15},"text":"/**\n      Loads a picture from a given source. \n      @param source the image source.\n      @return true if the file was loaded successfully\n   */\nprivate void load(File source) {\n    try {\n        InputStream in = new FileInputStream(source);\n        for (int i = 0; i < HEADER_SIZE; i++) {\n            int b = in.read();\n            if (b == -1) {\n                error(\"Premature end of file\");\n            }\n            header[i] = (byte) b;\n        }\n        int formatType = getUnsignedInt2(20);\n        if (formatType != 1) {\n            error(\"Not an uncompressed sound file.\");\n        }\n        int numChannels = getUnsignedInt2(22);\n        if (numChannels != 1) {\n            error(\"Not a mono sound file.\");\n        }\n        sampleRate = getUnsignedInt2(24);\n        int bitsPerSample = getUnsignedInt2(34);\n        if (bitsPerSample != 16) {\n            error(\"Not a 16 bit sound file.\");\n        }\n        // Read data size and allocate data array\n        // 2 bytes per data\n        int dataSize = getUnsignedInt4(40) / 2;\n        samples = new int[dataSize];\n        // Read sound data\n        for (int i = 0; i < dataSize; i++) {\n            samples[i] = getSignedInt2(in);\n        }\n    } catch (Exception ex) {\n        error(ex.getMessage());\n    }\n}\n","name":"load","className":"SoundClip","variables":{"numChannels":2,"b":3,"in":2,"i":8,"dataSize":3,"source":1,"sampleRate":1,"samples":2,"bitsPerSample":2,"ex":2,"HEADER_SIZE":1,"header":1,"formatType":2},"constants":{"22":1,"34":1,"24":1,"16":1,"\"Not a 16 bit sound file.\"":1,"\"Not a mono sound file.\"":1,"0":2,"1":3,"2":1,"\"Not an uncompressed sound file.\"":1,"40":1,"\"Premature end of file\"":1,"20":1},"javaDoc":"Loads a picture from a given source source the image source true if the file was loaded successfully","comments":"Read data size and allocate data array 2 bytes per data Read sound data \n      Loads a picture from a given source. \n      @param source the image source.\n      @return true if the file was loaded successfully\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"showMessageDialog":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"private void error(String message) {\n    JOptionPane.showMessageDialog(null, message);\n}\n","name":"error","className":"SoundClip","variables":{"JOptionPane":1},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":5},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Gets a byte from the header as an unsigned value.\n      @param offset the offset from the start of the header\n      @return the integer\n   */\nprivate int getUnsignedInt1(int offset) {\n    int result = header[offset];\n    if (result >= 0) {\n        return result;\n    } else {\n        return result + 256;\n    }\n}\n","name":"getUnsignedInt1","className":"SoundClip","variables":{"result":4,"offset":1,"header":1},"constants":{"0":1,"256":1},"javaDoc":"Gets a byte from the header as an unsigned value offset the offset from the start of the header the integer","comments":"\n      Gets a byte from the header as an unsigned value.\n      @param offset the offset from the start of the header\n      @return the integer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"getUnsignedInt1":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":12,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Gets an unsigned 4-byte integer from the header\n      @param offset the offset from the start of the header\n      @return the integer \n   */\nprivate int getUnsignedInt4(int offset) {\n    int result = 0;\n    int base = 1;\n    for (int i = 0; i < 4; i++) {\n        result = result + getUnsignedInt1(offset + i) * base;\n        base = base * 256;\n    }\n    return result;\n}\n","name":"getUnsignedInt4","className":"SoundClip","variables":{"result":4,"offset":1,"i":4,"base":4},"constants":{"0":2,"1":1,"256":1,"4":1},"javaDoc":"Gets an unsigned 4-byte integer from the header offset the offset from the start of the header the integer","comments":"\n      Gets an unsigned 4-byte integer from the header\n      @param offset the offset from the start of the header\n      @return the integer \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"getUnsignedInt1":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Gets an unsigned 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   */\nprivate int getUnsignedInt2(int offset) {\n    return getUnsignedInt1(offset) + 256 * getUnsignedInt1(offset + 1);\n}\n","name":"getUnsignedInt2","className":"SoundClip","variables":{"offset":1},"constants":{"1":1,"256":1},"javaDoc":"Gets an unsigned 2-byte integer from a random access file in the file the integer","comments":"\n      Gets an unsigned 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["InputStream"],"returnType":"int","methodCalls":{"read":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":12,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Gets a signed 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   */\nprivate static int getSignedInt2(InputStream in) throws IOException {\n    int lo = in.read();\n    int hi = in.read();\n    int result = lo + 256 * hi;\n    if (result >= 32768) {\n        result = result - 65536;\n    }\n    return result;\n}\n","name":"getSignedInt2","className":"SoundClip","variables":{"result":5,"hi":2,"lo":2,"in":2},"constants":{"256":1,"65536":1,"32768":1},"javaDoc":"Gets a signed 2-byte integer from a random access file in the file the integer","comments":"\n      Gets a signed 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":10}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":5,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"@Override\npublic void windowClosing(WindowEvent event) {\n    frames--;\n    if (frames == 0)\n        System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"frames":2,"System":1},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getHeight":1,"min":1,"max":1,"getWidth":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":7},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":7,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":41,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":5,"AssignExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public void paintComponent(Graphics graph) {\n    int increment = samples.length / getWidth();\n    final int LARGEST = 32767;\n    int x = 0;\n    for (int i = 0; i < samples.length; i = i + increment) {\n        int value = samples[i];\n        value = Math.min(LARGEST, value);\n        value = Math.max(-LARGEST, value);\n        int height = getHeight() / 2;\n        int y = height - samples[i] * height / LARGEST;\n        graph.drawLine(x, y, x, height);\n        x++;\n    }\n}\n","name":"paintComponent","className":"","variables":{"LARGEST":3,"x":2,"increment":2,"i":6,"y":1,"Math":2,"value":3,"samples":2,"graph":1,"height":3},"constants":{"0":2,"2":1,"32767":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"play":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    play();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"SoundClipFrame","methodCalls":{"add":3,"play":1,"addWindowListener":1,"exit":1,"getHeight":1,"min":1,"max":1,"addActionListener":1,"getWidth":1,"drawLine":1,"copyOf":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"JPanel":1,"JComponent":1,"JButton":1,"int":10},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":9,"VariableDeclarationExpr":13,"ArrayAccessExpr":2,"BinaryExpr":10,"NameExpr":95,"StringLiteralExpr":1,"MarkerAnnotationExpr":1,"UnaryExpr":5,"AssignExpr":4,"FieldAccessExpr":6,"ThisExpr":2,"MethodCallExpr":14},"statements":{"IfStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":28},"text":"public SoundClipFrame() {\n    frames++;\n    offsets++;\n    samples = Arrays.copyOf(SoundClip.this.samples, SoundClip.this.samples.length);\n    addWindowListener(new WindowAdapter() {\n\n        @Override\n        public void windowClosing(WindowEvent event) {\n            frames--;\n            if (frames == 0)\n                System.exit(0);\n        }\n    });\n    final int FRAME_WIDTH = 800;\n    final int FRAME_HEIGHT = 200;\n    final int OFFSET_WIDTH = 100;\n    setBounds(offsets * OFFSET_WIDTH, offsets * OFFSET_WIDTH, FRAME_WIDTH, FRAME_HEIGHT);\n    JComponent component = new JComponent() {\n\n        public void paintComponent(Graphics graph) {\n            int increment = samples.length / getWidth();\n            final int LARGEST = 32767;\n            int x = 0;\n            for (int i = 0; i < samples.length; i = i + increment) {\n                int value = samples[i];\n                value = Math.min(LARGEST, value);\n                value = Math.max(-LARGEST, value);\n                int height = getHeight() / 2;\n                int y = height - samples[i] * height / LARGEST;\n                graph.drawLine(x, y, x, height);\n                x++;\n            }\n        }\n    };\n    add(component);\n    JPanel panel = new JPanel();\n    JButton button = new JButton(\"Play\");\n    button.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent event) {\n            play();\n        }\n    });\n    panel.add(button);\n    add(panel, BorderLayout.SOUTH);\n}\n","name":"SoundClipFrame","className":"SoundClipFrame","variables":{"increment":2,"Math":2,"System":1,"button":2,"actionPerformed":1,"windowClosing":1,"LARGEST":3,"event":2,"panel":2,"Override":1,"value":3,"OFFSET_WIDTH":3,"height":3,"frames":3,"FRAME_HEIGHT":1,"paintComponent":1,"i":6,"samples":3,"graph":2,"component":1,"FRAME_WIDTH":1,"offsets":3,"x":2,"y":1,"Arrays":1,"SoundClip":2},"constants":{"0":4,"100":1,"200":1,"2":1,"\"Play\"":1,"800":1,"32767":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":15,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getAudioInputStream":1,"getClip":1,"start":1,"getMessage":1,"error":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"byte[]":1,"Clip":1,"int":3},"expressions":{"IntegerLiteralExpr":10,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayAccessExpr":5,"BinaryExpr":13,"NameExpr":47,"UnaryExpr":2,"AssignExpr":4,"CastExpr":2,"FieldAccessExpr":2,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":5,"TryStmt":1,"ForStmt":2,"ExpressionStmt":10},"text":"private void play() {\n    byte[] out = new byte[HEADER_SIZE + 2 * samples.length];\n    for (int i = 0; i < HEADER_SIZE; i++) {\n        out[i] = header[i];\n    }\n    for (int i = 0; i < samples.length; i++) {\n        int value = samples[i];\n        if (value < 0) {\n            value = value + 65536;\n        }\n        out[HEADER_SIZE + 2 * i] = (byte) (value % 256);\n        out[HEADER_SIZE + 2 * i + 1] = (byte) (value / 256);\n    }\n    try {\n        Clip clip = AudioSystem.getClip();\n        clip.open(AudioSystem.getAudioInputStream(new ByteArrayInputStream(out)));\n        clip.start();\n    } catch (Exception ex) {\n        error(ex.getMessage());\n    }\n}\n","name":"play","className":"SoundClipFrame","variables":{"ex":2,"AudioSystem":2,"HEADER_SIZE":4,"i":11,"header":1,"value":6,"samples":1,"clip":3,"out":5},"constants":{"0":3,"1":1,"2":3,"256":2,"65536":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":[],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Student() {\n    scores = new ArrayList<Double>();\n}\n","name":"Student","className":"Student","variables":{"scores":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n   */\npublic void addScore(double score) {\n    scores.add(score);\n}\n","name":"addScore","className":"Student","variables":{"scores":1},"constants":{},"javaDoc":"Adds a score for this student score the score to add","comments":"\n      Adds a score for this student.\n      @param score the score to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":2,"get":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":19,"UnaryExpr":2,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   */\npublic int minimumPosition() {\n    if (scores.size() == 0) {\n        return -1;\n    }\n    int smallestPosition = 0;\n    for (int i = 1; i < scores.size(); i++) {\n        if (scores.get(i) < scores.get(smallestPosition)) {\n            smallestPosition = i;\n        }\n    }\n    return smallestPosition;\n}\n","name":"minimumPosition","className":"Student","variables":{"smallestPosition":3,"scores":4,"i":4},"constants":{"0":2,"1":2},"javaDoc":"Gets the position of the minimum score the position of the smallest element of values or -1 if there are no scores","comments":"\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":5,"AssignExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the sum of the scores\n      @return the total score\n   */\npublic double sum() {\n    double total = 0;\n    for (double score : scores) {\n        total = total + score;\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"score":2,"total":4,"scores":1},"constants":{"0":1},"javaDoc":"Computes the sum of the scores the total score","comments":"\n      Computes the sum of the scores\n      @return the total score\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   */\npublic void removeScore(int pos) {\n    scores.remove(pos);\n/*\n        Alternatively, for a more efficient implementation,\n        follow Section 7.3.6:\n        int lastPosition = scores.size() - 1;\n        scores.set(pos, scores.get(lastPosition));\n        scores.remove(lastPosition);\n      */\n}\n","name":"removeScore","className":"Student","variables":{"scores":1},"constants":{},"javaDoc":"Removes a score at a given position pos the position of the score to remove","comments":"Alternatively for a more efficient implementation follow Section 7 3 6: int lastPosition = scores size() - 1; scores set(pos scores get(lastPosition)); scores remove(lastPosition); \n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"size":1,"get":3,"hasNextDouble":1,"nextDouble":1,"System.out.print":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":2,"ArrayList<Double>":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":3,"NameExpr":54,"StringLiteralExpr":2,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":11,"AssignExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    ArrayList<Double> values = new ArrayList<Double>();\n    // Read inputs\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble()) {\n        values.add(in.nextDouble());\n    }\n    // Find the largest value\n    double largest = values.get(0);\n    for (int i = 1; i < values.size(); i++) {\n        if (values.get(i) > largest) {\n            largest = values.get(i);\n        }\n    }\n    for (double element : values) {\n        System.out.print(element);\n        if (element == largest) {\n            System.out.print(\" <== largest value\");\n        }\n        System.out.println();\n    }\n}\n","name":"main","className":"LargestInArrayList","variables":{"largest":4,"in":3,"values":7,"i":3,"element":2},"constants":{"\"Please enter values, Q to quit:\"":1,"0":1,"\" <== largest value\"":1,"1":1},"javaDoc":"","comments":"Read inputs Find the largest value Print all values marking the largest ","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addScore":1,"minimumPosition":1,"sum":1,"hasNextDouble":1,"nextDouble":1,"removeScore":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"Student":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":39,"StringLiteralExpr":3,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Student fred = new Student();\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble()) {\n        fred.addScore(in.nextDouble());\n    }\n    int pos = fred.minimumPosition();\n    if (pos == -1) {\n        System.out.println(\"At least one score is required.\");\n    } else {\n        fred.removeScore(pos);\n        double total = fred.sum();\n        System.out.println(\"Final score: \" + total);\n    }\n}\n","name":"main","className":"ScoreAnalyzer","variables":{"total":2,"in":3,"pos":2,"fred":5},"constants":{"\"Please enter values, Q to quit:\"":1,"1":1,"\"At least one score is required.\"":1,"\"Final score: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   */\npublic Student(int capacity) {\n    scores = new double[capacity];\n    scoresSize = 0;\n}\n","name":"Student","className":"Student","variables":{"scoresSize":1,"scores":1,"capacity":1},"constants":{"0":1},"javaDoc":"Constructs a student with no scores and a maximum number of scores @capacity the maximum number of scores for this student","comments":"\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":8,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   */\npublic boolean addScore(double score) {\n    if (scoresSize < scores.length) {\n        scores[scoresSize] = score;\n        scoresSize++;\n        return true;\n    } else {\n        return false;\n    }\n}\n","name":"addScore","className":"Student","variables":{"scoresSize":3,"score":1,"scores":1},"constants":{"true":1,"false":1},"javaDoc":"Adds a score for this student score the score to add true if the score was added false if there was no room to add the score","comments":"\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   */\npublic double sum() {\n    double total = 0;\n    for (int i = 0; i < scoresSize; i++) {\n        total = total + scores[i];\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"scoresSize":1,"total":4,"scores":1,"i":4},"constants":{"0":2},"javaDoc":"Computes the sum of the scores of this student the sum of the scores","comments":"\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":12,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   */\npublic double minimum() {\n    if (scoresSize == 0) {\n        return 0;\n    }\n    double smallest = scores[0];\n    for (int i = 1; i < scoresSize; i++) {\n        if (scores[i] < smallest) {\n            smallest = scores[i];\n        }\n    }\n    return smallest;\n}\n","name":"minimum","className":"Student","variables":{"scoresSize":2,"scores":3,"smallest":4,"i":5},"constants":{"0":3,"1":1},"javaDoc":"Gets the minimum score of this student the minimum score or 0 if there are no scores","comments":"\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sum":1,"minimum":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":7,"MethodCallExpr":2},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3},"text":"/**\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped if \n      there are at least two scores, or 0 if there are no scores.\n   */\npublic double finalScore() {\n    if (scoresSize == 0) {\n        return 0;\n    } else if (scoresSize == 1) {\n        return scores[0];\n    } else {\n        return sum() - minimum();\n    }\n}\n","name":"finalScore","className":"Student","variables":{"scoresSize":2,"scores":1},"constants":{"0":3,"1":1},"javaDoc":"Gets the final score for this student the sum of the scores with the lowest score dropped if there are at least two scores or 0 if there are no scores","comments":"\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped if \n      there are at least two scores, or 0 if there are no scores.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"finalScore":1,"addScore":1,"hasNextDouble":1,"nextDouble":2,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"Student":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":34,"StringLiteralExpr":3,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    double expected = in.nextDouble();\n    Student fred = new Student(100);\n    while (in.hasNextDouble()) {\n        if (!fred.addScore(in.nextDouble())) {\n            System.out.println(\"Too many scores.\");\n            return;\n        }\n    }\n    System.out.println(\"Final score: \" + fred.finalScore());\n    System.out.println(\"Expected: \" + expected);\n}\n","name":"main","className":"ScoreTester","variables":{"in":4,"expected":2,"fred":3},"constants":{"100":1,"\"Too many scores.\"":1,"\"Final score: \"":1,"\"Expected: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"finalScore":1,"addScore":3,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Student":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Student fred = new Student(100);\n    fred.addScore(10);\n    fred.addScore(20);\n    fred.addScore(5);\n    System.out.println(\"Final score: \" + fred.finalScore());\n    System.out.println(\"Expected: 30\");\n}\n","name":"main","className":"ScoreTester1","variables":{"fred":5},"constants":{"100":1,"5":1,"\"Expected: 30\"":1,"\"Final score: \"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   */\npublic Student(int capacity) {\n    scores = new double[capacity];\n    scoresSize = 0;\n}\n","name":"Student","className":"Student","variables":{"scoresSize":1,"scores":1,"capacity":1},"constants":{"0":1},"javaDoc":"Constructs a student with no scores and a maximum number of scores @capacity the maximum number of scores for this student","comments":"\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":8,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   */\npublic boolean addScore(double score) {\n    if (scoresSize < scores.length) {\n        scores[scoresSize] = score;\n        scoresSize++;\n        return true;\n    } else {\n        return false;\n    }\n}\n","name":"addScore","className":"Student","variables":{"scoresSize":3,"score":1,"scores":1},"constants":{"true":1,"false":1},"javaDoc":"Adds a score for this student score the score to add true if the score was added false if there was no room to add the score","comments":"\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":11,"UnaryExpr":2,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   */\npublic int minimumPosition() {\n    if (scoresSize == 0) {\n        return -1;\n    }\n    int smallestPosition = 0;\n    for (int i = 1; i < scoresSize; i++) {\n        if (scores[i] < scores[smallestPosition]) {\n            smallestPosition = i;\n        }\n    }\n    return smallestPosition;\n}\n","name":"minimumPosition","className":"Student","variables":{"scoresSize":2,"smallestPosition":4,"scores":2,"i":5},"constants":{"0":2,"1":2},"javaDoc":"Gets the position of the minimum score the position of the smallest element of values or -1 if there are no scores","comments":"\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the sum of the scores\n      @return the total score\n   */\npublic double sum() {\n    double total = 0;\n    for (int i = 0; i < scoresSize; i++) {\n        total = total + scores[i];\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"scoresSize":1,"total":4,"scores":1,"i":4},"constants":{"0":2},"javaDoc":"Computes the sum of the scores the total score","comments":"\n      Computes the sum of the scores\n      @return the total score\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":5,"UnaryExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   */\npublic void removeScore(int pos) {\n    // Remove the element at this position--see Section 7.3.6\n    scores[pos] = scores[scoresSize - 1];\n    scoresSize--;\n}\n","name":"removeScore","className":"Student","variables":{"scoresSize":2,"scores":2,"pos":1},"constants":{"1":1},"javaDoc":"Removes a score at a given position pos the position of the score to remove","comments":"Remove the element at this position--see Section 7 3 6 \n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addScore":1,"minimumPosition":1,"sum":1,"hasNextDouble":1,"nextDouble":1,"removeScore":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"Student":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":44,"StringLiteralExpr":4,"FieldAccessExpr":5,"UnaryExpr":2,"MethodCallExpr":10},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Student fred = new Student(100);\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble()) {\n        if (!fred.addScore(in.nextDouble())) {\n            System.out.println(\"Too many scores.\");\n            return;\n        }\n    }\n    int pos = fred.minimumPosition();\n    if (pos == -1) {\n        System.out.println(\"At least one score is required.\");\n    } else {\n        fred.removeScore(pos);\n        double total = fred.sum();\n        System.out.println(\"Final score: \" + total);\n    }\n}\n","name":"main","className":"ScoreAnalyzer","variables":{"total":2,"in":3,"pos":2,"fred":5},"constants":{"\"Please enter values, Q to quit:\"":1,"100":1,"1":1,"\"Too many scores.\"":1,"\"At least one score is required.\"":1,"\"Final score: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextDouble":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Random":1,"double":4,"int":3},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":1,"VariableDeclarationExpr":8,"DoubleLiteralExpr":1,"BinaryExpr":12,"NameExpr":25,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":4,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    final int TRIES = 10000;\n    Random generator = new Random();\n    int hits = 0;\n    for (int i = 1; i <= TRIES; i++) {\n        // Generate two random numbers between -1 and 1\n        double r = generator.nextDouble();\n        double x = -1 + 2 * r;\n        r = generator.nextDouble();\n        double y = -1 + 2 * r;\n        if (x * x + y * y <= 1) {\n            hits++;\n        }\n    }\n    /*\n         The ratio hits / tries is approximately the same as the ratio \n         circle area / square area = pi / 4\n      */\n    double piEstimate = 4.0 * hits / TRIES;\n    System.out.println(\"Estimate for pi: \" + piEstimate);\n}\n","name":"main","className":"MonteCarlo","variables":{"hits":3,"r":4,"x":3,"generator":3,"i":3,"y":3,"piEstimate":2,"TRIES":3},"constants":{"0":1,"1":4,"\"Estimate for pi: \"":1,"2":2,"4.0":1,"10000":1},"javaDoc":"","comments":"The ratio hits / tries is approximately the same as the ratio circle area / square area = pi / 4 Generate two random numbers between -1 and 1 Check whether the point lies in the unit circle ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"countSyllables":1,"endsWith":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Word":1,"String":1,"int":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":26,"StringLiteralExpr":4,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"BlockStmt":1,"ExpressionStmt":7,"DoStmt":1},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.println(\"Enter a sentence ending in a period.\");\n    String input;\n    do {\n        input = in.next();\n        Word w = new Word(input);\n        int syllables = w.countSyllables();\n        System.out.println(\"Syllables in \" + input + \": \" + syllables);\n    } while (!input.endsWith(\".\"));\n}\n","name":"main","className":"SyllableCounter","variables":{"input":5,"in":2,"w":2,"syllables":2},"constants":{"\"Syllables in \"":1,"\".\"":1,"\"Enter a sentence ending in a period.\"":1,"\": \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String"],"returnType":"Word","methodCalls":{"length":2,"isLetter":2,"charAt":2,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":31,"UnaryExpr":4,"MethodCallExpr":7,"AssignExpr":1},"statements":{"WhileStmt":2,"BlockStmt":2,"ExpressionStmt":5},"text":"/**\n      Constructs a word by removing leading and trailing non-\n      letter characters, such as punctuation marks.\n      @param s the input string\n   */\npublic Word(String s) {\n    int i = 0;\n    while (i < s.length() && !Character.isLetter(s.charAt(i))) {\n        i++;\n    }\n    int j = s.length() - 1;\n    while (j > i && !Character.isLetter(s.charAt(j))) {\n        j--;\n    }\n    text = s.substring(i, j);\n}\n","name":"Word","className":"Word","variables":{"s":5,"Character":2,"i":4,"j":3,"text":1},"constants":{"0":1,"1":1},"javaDoc":"Constructs a word by removing leading and trailing non- letter characters such as punctuation marks s the input string","comments":"\n      Constructs a word by removing leading and trailing non-\n      letter characters, such as punctuation marks.\n      @param s the input string\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the text of the word, after removal of the\n      leading and trailing non-letter characters.\n      @return the text of the word\n   */\npublic String getText() {\n    return text;\n}\n","name":"getText","className":"Word","variables":{"text":1},"constants":{},"javaDoc":"Returns the text of the word after removal of the leading and trailing non-letter characters the text of the word","comments":"\n      Returns the text of the word, after removal of the\n      leading and trailing non-letter characters.\n      @return the text of the word\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"length":1,"indexOf":1,"charAt":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"char":1,"String":1,"int":3},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":6,"BinaryExpr":8,"BooleanLiteralExpr":2,"NameExpr":29,"StringLiteralExpr":1,"CharLiteralExpr":2,"UnaryExpr":4,"MethodCallExpr":4,"AssignExpr":3},"statements":{"IfStmt":5,"BlockStmt":6,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":10},"text":"/**\n      Counts the syllables in the word.\n      @return the syllable count\n   */\npublic int countSyllables() {\n    int count = 0;\n    int end = text.length() - 1;\n    // The empty string has no syllables\n    if (end < 0) {\n        return 0;\n    }\n    // An e at the end of the word doesn't count as a vowel\n    char ch = text.charAt(end);\n    if (ch == 'e' || ch == 'E') {\n        end--;\n    }\n    boolean insideVowelGroup = false;\n    for (int i = 0; i <= end; i++) {\n        ch = text.charAt(i);\n        String vowels = \"aeiouyAEIOUY\";\n        if (vowels.indexOf(ch) >= 0) {\n            // ch is a vowel\n            if (!insideVowelGroup) {\n                // Start of new vowel group\n                count++;\n                insideVowelGroup = true;\n            }\n        }\n    }\n    // Every word has at least one syllable\n    if (count == 0) {\n        count = 1;\n    }\n    return count;\n}\n","name":"countSyllables","className":"Word","variables":{"vowels":2,"ch":4,"count":5,"i":3,"end":4,"insideVowelGroup":3,"text":3},"constants":{"0":6,"1":2,"false":1,"true":1,"'e'":1,"'E'":1,"\"aeiouyAEIOUY\"":1},"javaDoc":"Counts the syllables in the word the syllable count","comments":"The empty string has no syllables An e at the end of the word doesn't count as a vowel ch is a vowel Start of new vowel group Every word has at least one syllable \n      Counts the syllables in the word.\n      @return the syllable count\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":1,"nextDouble":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":3,"int":1},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":6,"NameExpr":32,"StringLiteralExpr":3,"FieldAccessExpr":4,"UnaryExpr":3,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    double sum = 0;\n    int count = 0;\n    double salary = 0;\n    System.out.print(\"Enter salaries, -1 to finish: \");\n    Scanner in = new Scanner(System.in);\n    while (salary != -1) {\n        salary = in.nextDouble();\n        if (salary != -1) {\n            sum = sum + salary;\n            count++;\n        }\n    }\n    if (count > 0) {\n        double average = sum / count;\n        System.out.println(\"Average salary: \" + average);\n    } else {\n        System.out.println(\"No data\");\n    }\n}\n","name":"main","className":"SentinelDemo","variables":{"average":2,"in":2,"count":4,"sum":4,"salary":5},"constants":{"0":4,"1":2,"\"Average salary: \"":1,"\"Enter salaries, -1 to finish: \"":1,"\"No data\"":1},"javaDoc":"","comments":"Process data until the sentinel is entered Compute and print the average ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"cast":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Die":1,"int":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Die d = new Die(6);\n    final int TRIES = 10;\n    for (int i = 1; i <= TRIES; i++) {\n        int n = d.cast();\n        System.out.print(n + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"DieSimulator","variables":{"d":2,"i":3,"n":2,"TRIES":2},"constants":{"1":1,"\" \"":1,"6":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int"],"returnType":"Die","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a die with a given number of sides.\n      @param s the number of sides, e.g. 6 for a normal die\n   */\npublic Die(int s) {\n    sides = s;\n    generator = new Random();\n}\n","name":"Die","className":"Die","variables":{"s":1,"sides":1,"generator":1},"constants":{},"javaDoc":"Constructs a die with a given number of sides s the number of sides e g 6 for a normal die","comments":"\n      Constructs a die with a given number of sides.\n      @param s the number of sides, e.g. 6 for a normal die\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Simulates a throw of the die\n      @return the face of the die \n   */\npublic int cast() {\n    return 1 + generator.nextInt(sides);\n}\n","name":"cast","className":"Die","variables":{"generator":1},"constants":{"1":1},"javaDoc":"Simulates a throw of the die the face of the die","comments":"\n      Simulates a throw of the die\n      @return the face of the die \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"waitYears":1,"System.out.printf":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":3,"int":1,"Investment":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    final double INITIAL_BALANCE = 10000;\n    final double RATE = 5;\n    final int YEARS = 20;\n    Investment invest = new Investment(INITIAL_BALANCE, RATE);\n    invest.waitYears(YEARS);\n    double balance = invest.getBalance();\n    System.out.printf(\"The balance after %d years is %.2f\\n\", YEARS, balance);\n}\n","name":"main","className":"InvestmentRunner","variables":{"YEARS":1,"balance":1,"RATE":2,"invest":3,"INITIAL_BALANCE":2},"constants":{"\"The balance after %d years is %.2f\\n\"":1,"5":1,"10000":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["double","double"],"returnType":"Investment","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":5,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   */\npublic Investment(double aBalance, double aRate) {\n    balance = aBalance;\n    rate = aRate;\n    year = 0;\n}\n","name":"Investment","className":"Investment","variables":{"balance":1,"rate":1,"year":1,"aBalance":1,"aRate":1},"constants":{"0":1},"javaDoc":"Constructs an Investment object from a starting balance and interest rate aBalance the starting balance aRate the interest rate in percent","comments":"\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   */\npublic void waitForBalance(double targetBalance) {\n    while (balance < targetBalance) {\n        year++;\n        double interest = balance * rate / 100;\n        balance = balance + interest;\n    }\n}\n","name":"waitForBalance","className":"Investment","variables":{"targetBalance":1,"balance":4,"year":1,"interest":2,"rate":1},"constants":{"100":1},"javaDoc":"Keeps accumulating interest until a target balance has been reached targetBalance the desired balance","comments":"\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":11,"UnaryExpr":1,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"/**\n      Keeps accumulating interest for a given number of years.\n      @param numberOfYears the number of years to wait\n   */\npublic void waitYears(int numberOfYears) {\n    for (int i = 1; i <= numberOfYears; i++) {\n        double interest = balance * rate / 100;\n        balance = balance + interest;\n    }\n    year = year + numberOfYears;\n}\n","name":"waitYears","className":"Investment","variables":{"balance":3,"interest":2,"rate":1,"year":2,"numberOfYears":2,"i":3},"constants":{"1":1,"100":1},"javaDoc":"Keeps accumulating interest for a given number of years numberOfYears the number of years to wait","comments":"\n      Keeps accumulating interest for a given number of years.\n      @param numberOfYears the number of years to wait\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current investment balance.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"Investment","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current investment balance the current balance","comments":"\n      Gets the current investment balance.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   */\npublic int getYears() {\n    return year;\n}\n","name":"getYears","className":"Investment","variables":{"year":1},"constants":{},"javaDoc":"Gets the number of years this investment has accumulated interest the number of years since the start of the investment","comments":"\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":1,"charAt":1,"substring":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"char":1,"String":3,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":6,"StringLiteralExpr":1,"NameExpr":28,"CharLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    String creditCardNumber = \"4123-5678-9012-3450\";\n    int i = 0;\n    while (i < creditCardNumber.length()) {\n        char ch = creditCardNumber.charAt(i);\n        if (ch == ' ' || ch == '-') {\n            // Remove the character at position i\n            String before = creditCardNumber.substring(0, i);\n            String after = creditCardNumber.substring(i + 1);\n            creditCardNumber = before + after;\n        } else {\n            i++;\n        }\n    }\n    System.out.println(creditCardNumber);\n}\n","name":"main","className":"CCNumber","variables":{"ch":3,"before":2,"creditCardNumber":6,"i":4,"after":2},"constants":{"0":2,"'-'":1,"1":1,"\"4123-5678-9012-3450\"":1,"' '":1},"javaDoc":"","comments":"Remove the character at position i ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getHeight":1,"getRed":1,"getGreen":1,"setColorAt":1,"load":1,"getColorAt":1,"getWidth":1,"getBlue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Picture":1,"Color":2,"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":5,"VariableDeclarationExpr":5,"BinaryExpr":5,"NameExpr":33,"StringLiteralExpr":1,"UnaryExpr":2,"MethodCallExpr":8},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Picture pic = new Picture();\n    pic.load(\"queen-mary.png\");\n    for (int x = 0; x < pic.getWidth(); x++) {\n        for (int y = 0; y < pic.getHeight(); y++) {\n            Color original = pic.getColorAt(x, y);\n            Color negative = new Color(255 - original.getRed(), 255 - original.getGreen(), 255 - original.getBlue());\n            pic.setColorAt(x, y, negative);\n        }\n    }\n}\n","name":"main","className":"Negative","variables":{"negative":1,"original":4,"x":3,"y":3,"pic":6},"constants":{"0":2,"255":3,"\"queen-mary.png\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"Picture","methodCalls":{"add":1,"setVisible":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"BooleanLiteralExpr":1,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"/**\n      Constructs a picture with no image.\n   */\npublic Picture() {\n    frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    label = new JLabel(\"(No image)\");\n    frame.add(label);\n    frame.pack();\n    frame.setVisible(true);\n}\n","name":"Picture","className":"Picture","variables":{"label":1,"frame":5},"constants":{"\"(No image)\"":1,"true":1},"javaDoc":"Constructs a picture with no image","comments":"\n      Constructs a picture with no image.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Picture","methodCalls":{"setIcon":1,"add":1,"setVisible":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":4,"BooleanLiteralExpr":1,"NameExpr":28,"StringLiteralExpr":1,"FieldAccessExpr":2,"AssignExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":8},"text":"/**\n      Constructs a picture with a given width and height.\n      @param width the desired width\n      @param height the desired height\n   */\npublic Picture(int width, int height) {\n    frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    label = new JLabel(\"\");\n    image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n    label.setIcon(new ImageIcon(image));\n    frame.add(label);\n    frame.pack();\n    frame.setVisible(true);\n}\n","name":"Picture","className":"Picture","variables":{"image":2,"width":1,"label":2,"frame":5,"height":1},"constants":{"\"\"":1,"true":1},"javaDoc":"Constructs a picture with a given width and height width the desired width height the desired height","comments":"\n      Constructs a picture with a given width and height.\n      @param width the desired width\n      @param height the desired height\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getWidth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the width of this picture.\n      @return the width\n   */\npublic int getWidth() {\n    return image.getWidth();\n}\n","name":"getWidth","className":"Picture","variables":{"image":1},"constants":{},"javaDoc":"Gets the width of this picture the width","comments":"\n      Gets the width of this picture.\n      @return the width\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getHeight":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the height of this picture.\n      @return the height\n   */\npublic int getHeight() {\n    return image.getHeight();\n}\n","name":"getHeight","className":"Picture","variables":{"image":1},"constants":{},"javaDoc":"Gets the height of this picture the height","comments":"\n      Gets the height of this picture.\n      @return the height\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"read":2,"printStackTrace":1,"startsWith":1,"setImage":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"BufferedImage":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":26,"StringLiteralExpr":1,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":4,"MethodCallExpr":6},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n   */\npublic void load(String source) {\n    try {\n        this.source = source;\n        BufferedImage img;\n        if (source.startsWith(\"http://\"))\n            img = ImageIO.read(new URL(source).openStream());\n        else\n            img = ImageIO.read(new File(source));\n        setImage(img);\n    } catch (Exception ex) {\n        this.source = null;\n        ex.printStackTrace();\n    }\n}\n","name":"load","className":"Picture","variables":{"img":3,"ex":2,"source":4,"ImageIO":2},"constants":{"null":1,"\"http://\"":1},"javaDoc":"Loads a picture from a given source source the image source If the source starts with http:// it is a URL otherwise a filename","comments":"\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"load":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Reloads this picture, undoing any manipulations.\n   */\npublic void reload() {\n    load(source);\n}\n","name":"reload","className":"Picture","variables":{},"constants":{},"javaDoc":"Reloads this picture undoing any manipulations","comments":"\n      Reloads this picture, undoing any manipulations.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showOpenDialog":1,"load":1,"getSelectedFile":1,"getAbsolutePath":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":13,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Displays a file chooser for picking a picture.\n   */\npublic void pick() {\n    JFileChooser chooser = new JFileChooser(\".\");\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        load(chooser.getSelectedFile().getAbsolutePath());\n    }\n}\n","name":"pick","className":"Picture","variables":{"chooser":3},"constants":{"null":1,"\".\"":1},"javaDoc":"Displays a file chooser for picking a picture","comments":"\n      Displays a file chooser for picking a picture.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["BufferedImage"],"returnType":"void","methodCalls":{"setIcon":1,"pack":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"private void setImage(BufferedImage image) {\n    this.image = image;\n    label.setIcon(new ImageIcon(image));\n    label.setText(\" \");\n    frame.pack();\n}\n","name":"setImage","className":"Picture","variables":{"image":2,"label":2,"frame":1},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":["int","int"],"returnType":"Color","methodCalls":{"getColorModel":1,"getDataElements":1,"getRaster":1,"getRGB":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ColorModel":1,"Raster":1,"int":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"NameExpr":15,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   */\npublic Color getColorAt(int x, int y) {\n    Raster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    int argb = model.getRGB(raster.getDataElements(x, y, null));\n    return new Color(argb, true);\n}\n","name":"getColorAt","className":"Picture","variables":{"image":2,"argb":2,"raster":2,"model":2},"constants":{"null":1,"true":1},"javaDoc":"Gets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) the color of the pixel at position (x y)","comments":"\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int","Color"],"returnType":"void","methodCalls":{"getColorModel":1,"getDataElements":1,"setDataElements":1,"repaint":1,"getRaster":1,"getRGB":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"WritableRaster":1,"ColorModel":1,"Object":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":21,"MethodCallExpr":6},"statements":{"ExpressionStmt":5},"text":"/**\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   */\npublic void setColorAt(int x, int y, Color c) {\n    WritableRaster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    Object colorData = model.getDataElements(c.getRGB(), null);\n    raster.setDataElements(x, y, colorData);\n    label.repaint();\n}\n","name":"setColorAt","className":"Picture","variables":{"image":2,"c":1,"colorData":1,"raster":2,"model":2,"label":1},"constants":{"null":1},"javaDoc":"Sets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) c the color for the pixel at position (x y)","comments":"\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getYears":1,"waitForBalance":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":2,"int":1,"Investment":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    final double INITIAL_BALANCE = 10000;\n    final double RATE = 5;\n    Investment invest = new Investment(INITIAL_BALANCE, RATE);\n    invest.waitForBalance(2 * INITIAL_BALANCE);\n    int years = invest.getYears();\n    System.out.println(\"The investment doubled after \" + years + \" years\");\n}\n","name":"main","className":"InvestmentRunner","variables":{"RATE":2,"invest":3,"INITIAL_BALANCE":3,"years":2},"constants":{"2":1,"5":1,"10000":1,"\" years\"":1,"\"The investment doubled after \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["double","double"],"returnType":"Investment","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":5,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   */\npublic Investment(double aBalance, double aRate) {\n    balance = aBalance;\n    rate = aRate;\n    year = 0;\n}\n","name":"Investment","className":"Investment","variables":{"balance":1,"rate":1,"year":1,"aBalance":1,"aRate":1},"constants":{"0":1},"javaDoc":"Constructs an Investment object from a starting balance and interest rate aBalance the starting balance aRate the interest rate in percent","comments":"\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   */\npublic void waitForBalance(double targetBalance) {\n    while (balance < targetBalance) {\n        year++;\n        double interest = balance * rate / 100;\n        balance = balance + interest;\n    }\n}\n","name":"waitForBalance","className":"Investment","variables":{"targetBalance":1,"balance":4,"year":1,"interest":2,"rate":1},"constants":{"100":1},"javaDoc":"Keeps accumulating interest until a target balance has been reached targetBalance the desired balance","comments":"\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current investment balance.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"Investment","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current investment balance the current balance","comments":"\n      Gets the current investment balance.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   */\npublic int getYears() {\n    return year;\n}\n","name":"getYears","className":"Investment","variables":{"year":1},"constants":{},"javaDoc":"Gets the number of years this investment has accumulated interest the number of years since the start of the investment","comments":"\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":2,"System.out.print":2,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"boolean":2,"int":7},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":8,"VariableDeclarationExpr":10,"DoubleLiteralExpr":1,"BooleanLiteralExpr":5,"BinaryExpr":14,"NameExpr":87,"StringLiteralExpr":8,"FieldAccessExpr":9,"UnaryExpr":4,"MethodCallExpr":10,"AssignExpr":11},"statements":{"IfStmt":7,"WhileStmt":1,"BlockStmt":10,"ExpressionStmt":31},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter input: \");\n    int input = in.nextInt();\n    // The largest input\n    int min = input;\n    // The smallest input\n    int max = input;\n    // The number of inputs\n    int count = 1;\n    // The sum of the inputs\n    int sum = input;\n    // Set to true if we found at least one negative input\n    boolean foundNegative = false;\n    // The count of negative inputs\n    int negatives;\n    // The position of the first negative input\n    int firstNegative = 0;\n    if (input < 0) {\n        foundNegative = true;\n        firstNegative = 1;\n        negatives = 1;\n    } else {\n        negatives = 0;\n    }\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"Enter input, 0 to quit: \");\n        input = in.nextInt();\n        if (// Zero is the sentinel value\n        input == 0) {\n            done = true;\n        } else {\n            // Computing sum and average\n            sum = sum + input;\n            count++;\n            if (// Determining minimum and maximum\n            input < min) {\n                min = input;\n            } else if (input > max) {\n                max = input;\n            }\n            if (// Counting matches\n            input < 0) {\n                negatives++;\n                if (// Finding first match\n                !foundNegative) {\n                    foundNegative = true;\n                    firstNegative = count;\n                }\n            }\n        }\n    }\n    System.out.println(\"Minimum: \" + min);\n    System.out.println(\"Maximum: \" + max);\n    System.out.println(\"Sum: \" + sum);\n    System.out.println(\"Average: \" + sum * 1.0 / count);\n    System.out.println(\"Negative values: \" + negatives);\n    if (foundNegative) {\n        System.out.println(\"First negative: \" + firstNegative);\n    }\n}\n","name":"main","className":"LoopAlgorithms","variables":{"input":13,"min":4,"negatives":5,"in":3,"max":4,"count":4,"sum":5,"foundNegative":5,"done":3,"firstNegative":4},"constants":{"\"First negative: \"":1,"false":2,"\"Sum: \"":1,"\"Minimum: \"":1,"\"Negative values: \"":1,"\"Average: \"":1,"0":5,"\"Enter input, 0 to quit: \"":1,"1":3,"1.0":1,"true":3,"\"Enter input: \"":1,"\"Maximum: \"":1},"javaDoc":"","comments":"The largest input The smallest input The number of inputs The sum of the inputs Set to true if we found at least one negative input The count of negative inputs The position of the first negative input Zero is the sentinel value Computing sum and average Determining minimum and maximum Counting matches Finding first match ","isEmpty":false,"hasInnerClass":false,"lineCount":19,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":3,"pow":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":2,"int":4},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":6,"BinaryExpr":4,"NameExpr":48,"StringLiteralExpr":4,"FieldAccessExpr":6,"UnaryExpr":4,"MethodCallExpr":7},"statements":{"BlockStmt":4,"ForStmt":4,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    final int NMAX = 4;\n    final double XMAX = 10;\n    for (int n = 1; n <= NMAX; n++) {\n        System.out.printf(\"%10d\", n);\n    }\n    System.out.println();\n    for (int n = 1; n <= NMAX; n++) {\n        System.out.printf(\"%10s\", \"x \");\n    }\n    System.out.println();\n    for (double x = 1; x <= XMAX; x++) {\n        for (int n = 1; n <= NMAX; n++) {\n            System.out.printf(\"%10.0f\", Math.pow(x, n));\n        }\n        System.out.println();\n    }\n}\n","name":"main","className":"PowerTable","variables":{"NMAX":4,"XMAX":2,"x":3,"Math":1,"n":9},"constants":{"1":4,"4":1,"\"%10s\"":1,"\"%10d\"":1,"\"%10.0f\"":1,"\"x \"":1,"10":1},"javaDoc":"","comments":"Print table header Print table body Print table row ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sqrt":1,"System.out.print":1,"nextDouble":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":23,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ExpressionStmt":6,"DoStmt":1},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    double value;\n    do {\n        System.out.print(\"Enter a number >= 0: \");\n        value = in.nextDouble();\n    } while (value < 0);\n    double root = Math.sqrt(value);\n    System.out.println(\"The square root of the number is \" + root);\n}\n","name":"main","className":"DoLoop","variables":{"in":2,"root":2,"Math":1,"value":3},"constants":{"0":1,"\"The square root of the number is \"":1,"\"Enter a number >= 0: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseDouble":1,"showMessageDialog":1,"showInputDialog":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":2,"String":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"DoubleLiteralExpr":1,"BinaryExpr":4,"NameExpr":14,"StringLiteralExpr":2,"EnclosedExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    String input = JOptionPane.showInputDialog(\"Enter price:\");\n    double price = Double.parseDouble(input);\n    final double TAX_RATE = 8.5;\n    price = price * (1 + TAX_RATE / 100);\n    JOptionPane.showMessageDialog(null, \"Price after tax: \" + price);\n}\n","name":"main","className":"OptionPaneDemo","variables":{"input":1,"price":4,"TAX_RATE":2,"JOptionPane":2,"Double":1},"constants":{"1":1,"100":1,"\"Price after tax: \"":1,"null":1,"\"Enter price:\"":1,"8.5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"round":1,"System.out.print":4,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["Casting","FinalVariables"],"types":{"double":4,"int":4},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":8,"DoubleLiteralExpr":2,"BinaryExpr":4,"NameExpr":54,"StringLiteralExpr":4,"CastExpr":2,"FieldAccessExpr":8,"MethodCallExpr":9},"statements":{"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    int cansPerPack = 6;\n    // Liters in a 12-ounce can\n    final double CAN_VOLUME = 0.355;\n    double totalVolume = cansPerPack * CAN_VOLUME;\n    double pricePerPack = 2.59;\n    double pricePerLiter = pricePerPack / totalVolume;\n    System.out.print(\"Price per liter: \");\n    System.out.println(pricePerLiter);\n    // The integer part of the price gives the whole dollars.\n    int dollars = (int) pricePerLiter;\n    System.out.print(\"Dollars: \");\n    System.out.println(dollars);\n    // Multiply by 100 and round to the nearest integer to get the \n    // price in pennies.\n    int pennies = (int) Math.round(pricePerLiter * 100);\n    System.out.print(\"Pennies: \");\n    System.out.println(pennies);\n    // The cents are the last two digits of this value.\n    int cents = pennies % 100;\n    System.out.print(\"Cents: \");\n    System.out.println(cents);\n}\n","name":"main","className":"PriceDemo","variables":{"totalVolume":2,"pennies":2,"pricePerPack":2,"cents":1,"dollars":1,"CAN_VOLUME":2,"Math":1,"pricePerLiter":3,"cansPerPack":2},"constants":{"\"Price per liter: \"":1,"100":2,"\"Cents: \"":1,"6":1,"2.59":1,"\"Dollars: \"":1,"\"Pennies: \"":1,"0.355":1},"javaDoc":"","comments":"The integer part of the price gives the whole dollars Multiply by 100 and round to the nearest integer to get the price in pennies The cents are the last two digits of this value Liters in a 12-ounce can ","isEmpty":false,"hasInnerClass":false,"lineCount":20,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"System.out.print":2,"substring":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":31,"StringLiteralExpr":3,"FieldAccessExpr":4,"MethodCallExpr":7},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    // Get the names of the couple\n    System.out.print(\"Enter your first name: \");\n    String first = in.next();\n    System.out.print(\"Enter your significant other's first name: \");\n    String second = in.next();\n    // Compute and display the inscription\n    String initials = first.substring(0, 1) + \"&\" + second.substring(0, 1);\n    System.out.println(initials);\n}\n","name":"main","className":"Initials","variables":{"in":3,"initials":1,"first":2,"second":2},"constants":{"0":2,"1":2,"\"Enter your first name: \"":1,"\"Enter your significant other's first name: \"":1,"\"&\"":1},"javaDoc":"","comments":"Get the names of the couple Compute and display the inscription ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":2,"System.out.print":2,"nextDouble":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Scanner":1,"double":7},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":8,"DoubleLiteralExpr":1,"BinaryExpr":3,"NameExpr":46,"StringLiteralExpr":4,"FieldAccessExpr":7,"EnclosedExpr":1,"MethodCallExpr":8},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    // Read price per pack\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Please enter the price for a six-pack: \");\n    double packPrice = in.nextDouble();\n    // Read price per bottle\n    System.out.print(\"Please enter the price for a two-liter bottle: \");\n    double bottlePrice = in.nextDouble();\n    final double CANS_PER_PACK = 6;\n    // 12 oz. = 0.355 l \n    final double CAN_VOLUME = 0.355;\n    final double BOTTLE_VOLUME = 2;\n    // Compute and print price per liter\n    double packPricePerLiter = packPrice / (CANS_PER_PACK * CAN_VOLUME);\n    double bottlePricePerLiter = bottlePrice / BOTTLE_VOLUME;\n    System.out.printf(\"Pack price per liter:   %8.2f\", packPricePerLiter);\n    System.out.println();\n    System.out.printf(\"Bottle price per liter: %8.2f\", bottlePricePerLiter);\n    System.out.println();\n}\n","name":"main","className":"Volume","variables":{"bottlePricePerLiter":1,"in":3,"bottlePrice":2,"CANS_PER_PACK":2,"packPricePerLiter":1,"CAN_VOLUME":2,"packPrice":2,"BOTTLE_VOLUME":2},"constants":{"\"Please enter the price for a two-liter bottle: \"":1,"\"Bottle price per liter: %8.2f\"":1,"2":1,"6":1,"\"Pack price per liter:   %8.2f\"":1,"\"Please enter the price for a six-pack: \"":1,"0.355":1},"javaDoc":"","comments":"Read price per pack Read price per bottle Compute and print price per liter 12 oz = 0 355 l ","isEmpty":false,"hasInnerClass":false,"lineCount":17,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":2,"nextInt":2,"System.out.print":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Scanner":1,"int":7},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":8,"BinaryExpr":5,"NameExpr":51,"StringLiteralExpr":4,"FieldAccessExpr":7,"MethodCallExpr":8,"AssignExpr":1},"statements":{"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    final int PENNIES_PER_DOLLAR = 100;\n    final int PENNIES_PER_QUARTER = 25;\n    System.out.print(\"Enter bill value (1 = $1 bill, 5 = $5 bill, etc.): \");\n    int billValue = in.nextInt();\n    System.out.print(\"Enter item price in pennies: \");\n    int itemPrice = in.nextInt();\n    // Compute change due\n    int changeDue = PENNIES_PER_DOLLAR * billValue - itemPrice;\n    int dollarCoins = changeDue / PENNIES_PER_DOLLAR;\n    changeDue = changeDue % PENNIES_PER_DOLLAR;\n    int quarters = changeDue / PENNIES_PER_QUARTER;\n    // Print change due\n    System.out.printf(\"Dollar coins: %6d\", dollarCoins);\n    System.out.println();\n    System.out.printf(\"Quarters:     %6d\", quarters);\n    System.out.println();\n}\n","name":"main","className":"VendingMachine","variables":{"dollarCoins":1,"in":3,"PENNIES_PER_DOLLAR":4,"quarters":1,"billValue":2,"changeDue":5,"itemPrice":2,"PENNIES_PER_QUARTER":2},"constants":{"100":1,"25":1,"\"Quarters:     %6d\"":1,"\"Enter bill value (1 = $1 bill, 5 = $5 bill, etc.): \"":1,"\"Enter item price in pennies: \"":1,"\"Dollar coins: %6d\"":1},"javaDoc":"","comments":"Compute change due Print change due ","isEmpty":false,"hasInnerClass":false,"lineCount":17,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getVolume":2,"getSurfaceArea":1,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"Pyramid":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"NameExpr":39,"StringLiteralExpr":3,"FieldAccessExpr":6,"MethodCallExpr":9},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Pyramid sample = new Pyramid(10, 10);\n    System.out.println(sample.getVolume());\n    System.out.println(\"Expected: 333.33\");\n    System.out.println(sample.getSurfaceArea());\n    System.out.println(\"Expected: 224\");\n    Pyramid gizeh = new Pyramid(146, 230);\n    System.out.println(gizeh.getVolume());\n    /* \n         The following estimate is from \n         http://en.wikipedia.org/wiki/Great_Pyramid_of_Giza, citing\n         Levy, Janey (2005). The Great Pyramid of Giza: \n         Measuring Length, Area, Volume, and Angles. Rosen \n         Publishing Group. ISBN 1404260595.\n      */\n    System.out.println(\"Expected: 2500000\");\n}\n","name":"main","className":"PyramidTester","variables":{"gizeh":2,"sample":3},"constants":{"146":1,"\"Expected: 224\"":1,"\"Expected: 333.33\"":1,"\"Expected: 2500000\"":1,"10":2,"230":1},"javaDoc":"","comments":"The following estimate is from http://en wikipedia org/wiki/Great_Pyramid_of_Giza citing Levy Janey (2005) The Great Pyramid of Giza: Measuring Length Area Volume and Angles Rosen Publishing Group ISBN 1404260595 ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["double","double"],"returnType":"Pyramid","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a pyramid with a given height and baselength.\n      @param height the height\n      @param baseLength the length of one of the sides of the square base\n   */\npublic Pyramid(double height, double baseLength) {\n    this.height = height;\n    this.baseLength = baseLength;\n}\n","name":"Pyramid","className":"Pyramid","variables":{"baseLength":1,"height":1},"constants":{},"javaDoc":"Constructs a pyramid with a given height and baselength height the height baseLength the length of one of the sides of the square base","comments":"\n      Constructs a pyramid with a given height and baselength.\n      @param height the height\n      @param baseLength the length of one of the sides of the square base\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":3,"NameExpr":3},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the volume of this pyramid.\n      @return the volume\n   */\npublic double getVolume() {\n    return height * baseLength * baseLength / 3;\n}\n","name":"getVolume","className":"Pyramid","variables":{"baseLength":2,"height":1},"constants":{"3":1},"javaDoc":"Gets the volume of this pyramid the volume","comments":"\n      Gets the volume of this pyramid.\n      @return the volume\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":6,"NameExpr":9,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Gets the surface area of this pyramid.\n      @return the surface area, not including the base\n   */\npublic double getSurfaceArea() {\n    double sideLength = Math.sqrt(height * height + baseLength * baseLength / 4);\n    return 2 * baseLength * sideLength;\n}\n","name":"getSurfaceArea","className":"Pyramid","variables":{"sideLength":2,"Math":1,"baseLength":3,"height":2},"constants":{"2":1,"4":1},"javaDoc":"Gets the surface area of this pyramid the surface area not including the base","comments":"\n      Gets the surface area of this pyramid.\n      @return the surface area, not including the base\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sqrt":1,"pow":2,"System.out.print":5,"nextDouble":5,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":9},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":10,"BinaryExpr":6,"NameExpr":67,"StringLiteralExpr":6,"FieldAccessExpr":7,"MethodCallExpr":14},"statements":{"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Distance to item along x-axis: \");\n    double xDistance = in.nextDouble();\n    System.out.print(\"Distance to item along y-axis: \");\n    double yDistance = in.nextDouble();\n    System.out.print(\"Length of segment 1: \");\n    double segment1Length = in.nextDouble();\n    System.out.print(\"Speed along segment 1: \");\n    double segment1Speed = in.nextDouble();\n    System.out.print(\"Speed along segment 2: \");\n    double segment2Speed = in.nextDouble();\n    double segment1Time = segment1Length / segment1Speed;\n    double segment2Length = Math.sqrt(Math.pow(xDistance - segment1Length, 2) + Math.pow(yDistance, 2));\n    double segment2Time = segment2Length / segment2Speed;\n    double totalTime = segment1Time + segment2Time;\n    System.out.println(\"Total time: \" + totalTime);\n}\n","name":"main","className":"TravelTime","variables":{"xDistance":2,"segment1Time":2,"segment2Length":2,"in":6,"totalTime":2,"yDistance":1,"segment2Time":2,"segment1Speed":2,"Math":3,"segment1Length":3,"segment2Speed":2},"constants":{"\"Total time: \"":1,"2":2,"\"Length of segment 1: \"":1,"\"Distance to item along x-axis: \"":1,"\"Distance to item along y-axis: \"":1,"\"Speed along segment 1: \"":1,"\"Speed along segment 2: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":16,"modifier":9}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"constants":{"0":2},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":1,"purchase":2},"constants":{},"javaDoc":"Records the purchase price of an item amount the price of the purchased item","comments":"\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":8,"NameExpr":10,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Processes the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   */\npublic void receivePayment(int dollars, int quarters, int dimes, int nickels, int pennies) {\n    payment = dollars + quarters * QUARTER_VALUE + dimes * DIME_VALUE + nickels * NICKEL_VALUE + pennies * PENNY_VALUE;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"NICKEL_VALUE":1,"dimes":1,"nickels":1,"quarters":1,"pennies":1,"payment":1,"dollars":1,"QUARTER_VALUE":1,"DIME_VALUE":1,"PENNY_VALUE":1},"constants":{},"javaDoc":"Processes the payment received from the customer dollars the number of dollars in the payment quarters the number of quarters in the payment dimes the number of dimes in the payment nickels the number of nickels in the payment pennies the number of pennies in the payment","comments":"\n      Processes the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":5,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"constants":{"0":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":4,"receivePayment":2,"giveChange":2,"System.out.print":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"CashRegister":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":10,"VariableDeclarationExpr":1,"DoubleLiteralExpr":4,"NameExpr":54,"StringLiteralExpr":4,"FieldAccessExpr":6,"MethodCallExpr":14},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(0.75);\n    register.recordPurchase(1.50);\n    register.receivePayment(2, 0, 5, 0, 0);\n    System.out.print(\"Change: \");\n    System.out.println(register.giveChange());\n    System.out.println(\"Expected: 0.25\");\n    register.recordPurchase(2.25);\n    register.recordPurchase(19.25);\n    register.receivePayment(23, 2, 0, 0, 0);\n    System.out.print(\"Change: \");\n    System.out.println(register.giveChange());\n    System.out.println(\"Expected: 2.0\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"register":9},"constants":{"0":6,"23":1,"2":2,"19.25":1,"5":1,"\"Expected: 2.0\"":1,"2.25":1,"0.75":1,"\"Change: \"":2,"1.50":1,"\"Expected: 0.25\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":2,"System.out.print":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"int":4},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":6,"DoubleLiteralExpr":1,"BinaryExpr":10,"NameExpr":38,"StringLiteralExpr":4,"FieldAccessExpr":5,"EnclosedExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Total width: \");\n    int totalWidth = in.nextInt();\n    System.out.print(\"Tile width: \");\n    int tileWidth = in.nextInt();\n    int numberOfPairs = (totalWidth - tileWidth) / (2 * tileWidth);\n    int numberOfTiles = 1 + 2 * numberOfPairs;\n    double gap = (totalWidth - numberOfTiles * tileWidth) / 2.0;\n    System.out.println(\"Number of tiles: \" + numberOfTiles);\n    System.out.println(\"Gap at each end: \" + gap);\n}\n","name":"main","className":"Tiles","variables":{"in":3,"gap":2,"numberOfPairs":2,"numberOfTiles":3,"tileWidth":4,"totalWidth":3},"constants":{"1":1,"\"Tile width: \"":1,"2":2,"\"Gap at each end: \"":1,"2.0":1,"\"Number of tiles: \"":1,"\"Total width: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"abs":1,"sqrt":1,"System.out.printf":3,"equals":1,"compareTo":1,"System.out.print":3,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":3,"String":4,"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":10,"DoubleLiteralExpr":2,"BinaryExpr":12,"NameExpr":89,"StringLiteralExpr":16,"FieldAccessExpr":10,"UnaryExpr":1,"MethodCallExpr":14,"AssignExpr":3},"statements":{"IfStmt":7,"BlockStmt":9,"ExpressionStmt":23},"text":"public static void main(String[] args) {\n    // Integers \n    int m = 2;\n    int n = 4;\n    if (m * m == n) {\n        System.out.println(\"2 times 2 is four.\");\n    }\n    // Floating-point numbers\n    double x = Math.sqrt(2);\n    double y = 2.0;\n    if (x * x == y) {\n        System.out.println(\"sqrt(2) times sqrt(2) is 2\");\n    } else {\n        System.out.printf(\"sqrt(2) times sqrt(2) is not four but %.18f\\n\", x * x);\n    }\n    final double EPSILON = 1E-14;\n    if (Math.abs(x * x - y) < EPSILON) {\n        System.out.println(\"sqrt(2) times sqrt(2) is approximately 2\");\n    }\n    // Strings\n    String s = \"120\";\n    String t = \"20\";\n    int result = s.compareTo(t);\n    String comparison;\n    if (result < 0) {\n        comparison = \"comes before\";\n    } else if (result > 0) {\n        comparison = \"comes after\";\n    } else {\n        comparison = \"is the same as\";\n    }\n    System.out.printf(\"The string \\\"%s\\\" %s the string \\\"%s\\\"\\n\", s, comparison, t);\n    String u = \"1\" + t;\n    System.out.printf(\"The strings \\\"%s\\\" and \\\"%s\\\" are \", s, u);\n    if (s != u) {\n        System.out.print(\"not \");\n    }\n    System.out.print(\"identical. They are \");\n    if (!s.equals(u)) {\n        System.out.print(\"not \");\n    }\n    System.out.println(\"equal.\");\n}\n","name":"main","className":"Compare","variables":{"result":3,"s":4,"comparison":4,"t":2,"u":2,"x":7,"y":3,"Math":2,"m":3,"n":2,"EPSILON":2},"constants":{"\"comes before\"":1,"\"120\"":1,"\"comes after\"":1,"\"equal.\"":1,"\"is the same as\"":1,"\"identical. They are \"":1,"\"sqrt(2) times sqrt(2) is 2\"":1,"1E-14":1,"0":2,"\"The strings \\\"%s\\\" and \\\"%s\\\" are \"":1,"2":2,"\"20\"":1,"\"1\"":1,"4":1,"2.0":1,"\"sqrt(2) times sqrt(2) is not four but %.18f\\n\"":1,"\"not \"":2,"\"sqrt(2) times sqrt(2) is approximately 2\"":1,"\"2 times 2 is four.\"":1,"\"The string \\\"%s\\\" %s the string \\\"%s\\\"\\n\"":1},"javaDoc":"","comments":"Integers Floating-point numbers Strings ","isEmpty":false,"hasInnerClass":false,"lineCount":23,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"System.out.printf":1,"equals":3,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"String":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":39,"StringLiteralExpr":6,"FieldAccessExpr":4,"MethodCallExpr":8,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":4,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.println(\"Enter the state or province: \");\n    String state = in.next();\n    System.out.println(\"Enter the country: \");\n    String country = in.next();\n    double shippingCost;\n    if (country.equals(\"USA\")) {\n        if (// See Section 5.7 for the || (or) operator\n        state.equals(\"AK\") || state.equals(\"HI\")) {\n            shippingCost = 10;\n        } else {\n            shippingCost = 5;\n        }\n    } else {\n        shippingCost = 10;\n    }\n    System.out.printf(\"Shipping cost to %s, %s: $%.2f\\n\", state, country, shippingCost);\n}\n","name":"main","className":"Shipping","variables":{"country":2,"shippingCost":4,"in":3,"state":3},"constants":{"5":1,"\"Shipping cost to %s, %s: $%.2f\\n\"":1,"\"USA\"":1,"\"AK\"":1,"\"Enter the state or province: \"":1,"\"Enter the country: \"":1,"\"HI\"":1,"10":2},"javaDoc":"","comments":"See Section 5 7 for the || (or) operator ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["double"],"returnType":"Earthquake","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an Earthquake object.\n      @param magnitude the magnitude on the Richter scale\n   */\npublic Earthquake(double magnitude) {\n    richter = magnitude;\n}\n","name":"Earthquake","className":"Earthquake","variables":{"richter":1,"magnitude":1},"constants":{},"javaDoc":"Constructs an Earthquake object magnitude the magnitude on the Richter scale","comments":"\n      Constructs an Earthquake object.\n      @param magnitude the magnitude on the Richter scale\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":4,"BinaryExpr":4,"NameExpr":10,"StringLiteralExpr":5,"AssignExpr":5},"statements":{"IfStmt":4,"BlockStmt":5,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n      Gets a description of the effect of the earthquake.\n      @return the description of the effect\n   */\npublic String getDescription() {\n    String description;\n    if (richter >= 8.0) {\n        description = \"Most structures fall\";\n    } else if (richter >= 7.0) {\n        description = \"Many buildings destroyed\";\n    } else if (richter >= 6.0) {\n        description = \"Many buildings considerably damaged, some collapse\";\n    } else if (richter >= 4.5) {\n        description = \"Damage to poorly constructed buildings\";\n    } else {\n        description = \"No destruction of buildings\";\n    }\n    return description;\n}\n","name":"getDescription","className":"Earthquake","variables":{"richter":4,"description":7},"constants":{"\"Many buildings destroyed\"":1,"\"Damage to poorly constructed buildings\"":1,"\"Most structures fall\"":1,"\"Many buildings considerably damaged, some collapse\"":1,"\"No destruction of buildings\"":1,"6.0":1,"7.0":1,"8.0":1,"4.5":1},"javaDoc":"Gets a description of the effect of the earthquake the description of the effect","comments":"\n      Gets a description of the effect of the earthquake.\n      @return the description of the effect\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getDescription":1,"System.out.print":1,"nextDouble":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Earthquake":1,"double":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter a magnitude on the Richter scale: \");\n    double magnitude = in.nextDouble();\n    Earthquake quake = new Earthquake(magnitude);\n    System.out.println(quake.getDescription());\n}\n","name":"main","className":"EarthquakeRunner","variables":{"in":2,"quake":2,"magnitude":2},"constants":{"\"Enter a magnitude on the Richter scale: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":1,"System.out.print":1,"nextDouble":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"DoubleLiteralExpr":2,"BinaryExpr":2,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Original price before discount: \");\n    double originalPrice = in.nextDouble();\n    double discountRate;\n    if (originalPrice < 128) {\n        discountRate = 0.92;\n    } else {\n        discountRate = 0.84;\n    }\n    double discountedPrice = discountRate * originalPrice;\n    System.out.printf(\"Discounted price: %.2f\\n\", discountedPrice);\n}\n","name":"main","className":"Sale","variables":{"discountRate":4,"originalPrice":3,"discountedPrice":1,"in":2},"constants":{"0.92":1,"\"Original price before discount: \"":1,"128":1,"0.84":1,"\"Discounted price: %.2f\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"length":3,"System.out.print":1,"substring":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":2,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":7,"VariableDeclarationExpr":5,"BinaryExpr":7,"NameExpr":36,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":7,"AssignExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter a string: \");\n    String str = in.next();\n    int position;\n    int length;\n    if (str.length() % 2 == 1) {\n        position = str.length() / 2;\n        length = 1;\n    } else {\n        position = str.length() / 2 - 1;\n        length = 2;\n    }\n    String result = str.substring(position, position + length);\n    System.out.println(\"Middle: \" + result);\n}\n","name":"main","className":"Middle","variables":{"str":5,"result":2,"in":2,"length":4,"position":4},"constants":{"1":3,"2":4,"\"Middle: \"":1,"\"Enter a string: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Floor: \");\n    int floor = in.nextInt();\n    // Adjust floor if necessary\n    int actualFloor;\n    if (floor > 13) {\n        actualFloor = floor - 1;\n    } else {\n        actualFloor = floor;\n    }\n    System.out.println(\"The elevator will travel to the actual floor \" + actualFloor);\n}\n","name":"main","className":"ElevatorSimulation","variables":{"actualFloor":4,"in":2,"floor":4},"constants":{"1":1,"13":1,"\"Floor: \"":1,"\"The elevator will travel to the actual floor \"":1},"javaDoc":"","comments":"Adjust floor if necessary ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextDouble":2,"System.out.print":1,"System.out.println":8},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"DoubleLiteralExpr":2,"BinaryExpr":19,"NameExpr":70,"StringLiteralExpr":9,"FieldAccessExpr":10,"UnaryExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":5,"BlockStmt":8,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.println(\"Enter two numbers (such as 3.5 4.5): \");\n    double x = in.nextDouble();\n    double y = in.nextDouble();\n    if (x == y) {\n        System.out.println(\"They are the same.\");\n    } else {\n        System.out.print(\"The first number is \");\n        if (x > y) {\n            System.out.println(\"larger\");\n        } else {\n            System.out.println(\"smaller\");\n        }\n        if (-0.01 < x - y && x - y < 0.01) {\n            System.out.println(\"The numbers are close together\");\n        }\n        if (x == y + 1 || x == y - 1) {\n            System.out.println(\"The numbers are one apart\");\n        }\n        if (x > 0 && y > 0 || x < 0 && y < 0) {\n            System.out.println(\"The numbers have the same sign\");\n        } else {\n            System.out.println(\"The numbers have different signs\");\n        }\n    }\n}\n","name":"main","className":"Compare2","variables":{"in":3,"x":9,"y":9},"constants":{"\"The first number is \"":1,"0":4,"1":2,"\"Enter two numbers (such as 3.5 4.5): \"":1,"\"The numbers have different signs\"":1,"0.01":2,"\"larger\"":1,"\"The numbers are close together\"":1,"\"They are the same.\"":1,"\"The numbers are one apart\"":1,"\"smaller\"":1,"\"The numbers have the same sign\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"hasNextInt":1,"nextInt":1,"System.out.print":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":7,"NameExpr":42,"StringLiteralExpr":5,"FieldAccessExpr":6,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":4,"BlockStmt":6,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Floor: \");\n    if (in.hasNextInt()) {\n        // Now we know that the user entered an integer\n        int floor = in.nextInt();\n        if (floor == 13) {\n            System.out.println(\"Error: There is no thirteenth floor.\");\n        } else if (floor <= 0 || floor > 20) {\n            System.out.println(\"Error: The floor must be between 1 and 20.\");\n        } else {\n            // Now we know that the input is valid\n            int actualFloor = floor;\n            if (floor > 13) {\n                actualFloor = floor - 1;\n            }\n            System.out.println(\"The elevator will travel to the actual floor \" + actualFloor);\n        }\n    } else {\n        System.out.println(\"Error: Not an integer.\");\n    }\n}\n","name":"main","className":"ElevatorSimulation2","variables":{"actualFloor":3,"in":3,"floor":7},"constants":{"0":1,"1":1,"13":2,"\"Error: There is no thirteenth floor.\"":1,"\"Floor: \"":1,"\"Error: The floor must be between 1 and 20.\"":1,"\"Error: Not an integer.\"":1,"20":1,"\"The elevator will travel to the actual floor \"":1},"javaDoc":"","comments":"Now we know that the user entered an integer Now we know that the input is valid ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"equals":1,"getTax":1,"System.out.print":2,"nextDouble":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"String":1,"int":1,"TaxReturn":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":1,"NameExpr":40,"StringLiteralExpr":4,"FieldAccessExpr":6,"MethodCallExpr":7,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Please enter your income: \");\n    double income = in.nextDouble();\n    System.out.print(\"Are you married? (Y/N) \");\n    String input = in.next();\n    int status;\n    if (input.equals(\"Y\")) {\n        status = TaxReturn.MARRIED;\n    } else {\n        status = TaxReturn.SINGLE;\n    }\n    TaxReturn aTaxReturn = new TaxReturn(income, status);\n    System.out.println(\"Tax: \" + aTaxReturn.getTax());\n}\n","name":"main","className":"TaxCalculator","variables":{"income":2,"input":2,"aTaxReturn":2,"in":3,"status":4},"constants":{"\"Are you married? (Y/N) \"":1,"\"Please enter your income: \"":1,"\"Tax: \"":1,"\"Y\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["double","int"],"returnType":"TaxReturn","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a TaxReturn object for a given income and \n      marital status.\n      @param anIncome the taxpayer income\n      @param aStatus either SINGLE or MARRIED\n   */\npublic TaxReturn(double anIncome, int aStatus) {\n    income = anIncome;\n    status = aStatus;\n}\n","name":"TaxReturn","className":"TaxReturn","variables":{"income":1,"anIncome":1,"aStatus":1,"status":1},"constants":{},"javaDoc":"Constructs a TaxReturn object for a given income and marital status anIncome the taxpayer income aStatus either SINGLE or MARRIED","comments":"\n      Constructs a TaxReturn object for a given income and \n      marital status.\n      @param anIncome the taxpayer income\n      @param aStatus either SINGLE or MARRIED\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":12,"NameExpr":28,"EnclosedExpr":2,"AssignExpr":6},"statements":{"IfStmt":3,"BlockStmt":6,"ReturnStmt":1,"ExpressionStmt":8},"text":"public double getTax() {\n    double tax1 = 0;\n    double tax2 = 0;\n    if (status == SINGLE) {\n        if (income <= RATE1_SINGLE_LIMIT) {\n            tax1 = RATE1 * income;\n        } else {\n            tax1 = RATE1 * RATE1_SINGLE_LIMIT;\n            tax2 = RATE2 * (income - RATE1_SINGLE_LIMIT);\n        }\n    } else {\n        if (income <= RATE1_MARRIED_LIMIT) {\n            tax1 = RATE1 * income;\n        } else {\n            tax1 = RATE1 * RATE1_MARRIED_LIMIT;\n            tax2 = RATE2 * (income - RATE1_MARRIED_LIMIT);\n        }\n    }\n    return tax1 + tax2;\n}\n","name":"getTax","className":"TaxReturn","variables":{"tax1":6,"income":6,"RATE2":2,"tax2":4,"SINGLE":1,"RATE1":4,"RATE1_MARRIED_LIMIT":3,"RATE1_SINGLE_LIMIT":3,"status":1},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"BinaryExpr":2,"NameExpr":30,"StringLiteralExpr":4,"FieldAccessExpr":6,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    // Prints 7\n    System.out.println(3 + 4);\n    // Prints \"Hello World!\" in two lines\n    System.out.println(\"Hello\");\n    System.out.println(\"World!\");\n    // Prints 00 but doesn't start a new line\n    System.out.print(\"00\");\n    // Prints 7 and starts a new line\n    System.out.println(3 + 4);\n    System.out.println(\"Goodbye\");\n}\n","name":"main","className":"PrintTester","variables":{},"constants":{"\"Hello\"":1,"\"00\"":1,"3":2,"4":2,"\"Goodbye\"":1,"\"World!\"":1},"javaDoc":"","comments":"Prints 7 Prints \"Hello World!\" in two lines Prints 00 but doesn't start a new line Prints 7 and starts a new line ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":5,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    System.out.println(1 / 0);\n// A run-time exception. The program terminates.\n}\n","name":"main","className":"Error3","variables":{},"constants":{"0":1,"1":1},"javaDoc":"","comments":"A run-time exception The program terminates ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    System.out.println(\"Hello, Word!\");\n// A run-time error. The program doesn't do what it should.\n}\n","name":"main","className":"Error2","variables":{},"constants":{"\"Hello, Word!\"":1},"javaDoc":"","comments":"A run-time error The program doesn't do what it should ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.ou.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    // A compile-time error. \n    System.ou.println(\"Hello, World!\");\n}\n","name":"main","className":"Error1","variables":{},"constants":{"\"Hello, World!\"":1},"javaDoc":"","comments":"A compile-time error ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    // Display a greeting in the console window\n    System.out.println(\"Hello, World!\");\n}\n","name":"main","className":"HelloPrinter","variables":{},"constants":{"\"Hello, World!\"":1},"javaDoc":"","comments":"Display a greeting in the console window ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"CalculatorFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new CalculatorFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"Calculator\");\n    frame.setVisible(true);\n}\n","name":"main","className":"CalculatorViewer","variables":{"frame":4},"constants":{"\"Calculator\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"CalculatorFrame","methodCalls":{"add":1,"createButtonPanel":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public CalculatorFrame() {\n    display = new JLabel(\"0\");\n    add(display, BorderLayout.NORTH);\n    createButtonPanel();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"CalculatorFrame","className":"CalculatorFrame","variables":{"display":1},"constants":{"\"0\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":17,"setLayout":1,"makeDigitButton":11,"makeOperatorButton":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":89,"StringLiteralExpr":16,"FieldAccessExpr":1,"MethodCallExpr":34},"statements":{"ExpressionStmt":19},"text":"/**\n      Creates the button panel.\n   */\nprivate void createButtonPanel() {\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 4));\n    buttonPanel.add(makeDigitButton(\"7\"));\n    buttonPanel.add(makeDigitButton(\"8\"));\n    buttonPanel.add(makeDigitButton(\"9\"));\n    buttonPanel.add(makeOperatorButton(\"/\"));\n    buttonPanel.add(makeDigitButton(\"4\"));\n    buttonPanel.add(makeDigitButton(\"5\"));\n    buttonPanel.add(makeDigitButton(\"6\"));\n    buttonPanel.add(makeOperatorButton(\"*\"));\n    buttonPanel.add(makeDigitButton(\"1\"));\n    buttonPanel.add(makeDigitButton(\"2\"));\n    buttonPanel.add(makeDigitButton(\"3\"));\n    buttonPanel.add(makeOperatorButton(\"-\"));\n    buttonPanel.add(makeDigitButton(\"0\"));\n    buttonPanel.add(makeDigitButton(\".\"));\n    buttonPanel.add(makeOperatorButton(\"=\"));\n    buttonPanel.add(makeOperatorButton(\"+\"));\n    add(buttonPanel, BorderLayout.CENTER);\n}\n","name":"createButtonPanel","className":"CalculatorFrame","variables":{"buttonPanel":18},"constants":{"\"=\"":1,"\"9\"":1,"\"8\"":1,"\"7\"":1,"\"6\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"\"1\"":1,"4":2,"\"0\"":1,"\"/\"":1,"\".\"":1,"\"-\"":1,"\"+\"":1,"\"*\"":1},"javaDoc":"Creates the button panel","comments":"\n      Creates the button panel.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":19,"modifier":2}
{"paramTypes":["String"],"returnType":"DigitButtonListener","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      */\npublic DigitButtonListener(String aDigit) {\n    digit = aDigit;\n}\n","name":"DigitButtonListener","className":"DigitButtonListener","variables":{"aDigit":1,"digit":1},"constants":{},"javaDoc":"Constructs a listener whose actionPerformed method adds a digit to the display aDigit the digit to add","comments":"\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    display.setText(display.getText() + digit);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"display":2,"digit":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":7,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   */\npublic JButton makeDigitButton(String digit) {\n    JButton button = new JButton(digit);\n    ActionListener listener = new DigitButtonListener(digit);\n    button.addActionListener(listener);\n    return button;\n}\n","name":"makeDigitButton","className":"CalculatorFrame","variables":{"button":3,"listener":1,"digit":2},"constants":{},"javaDoc":"Makes a button representing a digit of a calculator digit the digit of the calculator the button of the calculator","comments":"\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"JButton":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calcalator\n   */\npublic JButton makeOperatorButton(String op) {\n    JButton button = new JButton(op);\n    return button;\n}\n","name":"makeOperatorButton","className":"CalculatorFrame","variables":{"button":2,"op":1},"constants":{},"javaDoc":"Makes a button representing an operator of a calculator op the operator of the calculator the button of the calcalator","comments":"\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calcalator\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"InvestmentFrame3":1,"JFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new InvestmentFrame3();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer3","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"InvestmentFrame3","methodCalls":{"createPanel":1,"setEditable":1,"setSize":1,"createButton":1,"setText":1,"createTextField":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":22,"StringLiteralExpr":1,"AssignExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":8},"text":"public InvestmentFrame3() {\n    balance = INITIAL_BALANCE;\n    resultArea = new JTextArea(AREA_ROWS, AREA_COLUMNS);\n    resultArea.setText(balance + \"\\n\");\n    resultArea.setEditable(false);\n    createTextField();\n    createButton();\n    createPanel();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"InvestmentFrame3","className":"InvestmentFrame3","variables":{"AREA_ROWS":1,"balance":2,"AREA_COLUMNS":1,"resultArea":3,"INITIAL_BALANCE":1},"constants":{"false":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":2,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":4},"text":"private void createTextField() {\n    rateLabel = new JLabel(\"Interest Rate: \");\n    final int FIELD_WIDTH = 10;\n    rateField = new JTextField(FIELD_WIDTH);\n    rateField.setText(\"\" + DEFAULT_RATE);\n}\n","name":"createTextField","className":"InvestmentFrame3","variables":{"rateLabel":1,"DEFAULT_RATE":1,"FIELD_WIDTH":2,"rateField":2},"constants":{"\"\"":1,"\"Interest Rate: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"getText":1,"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":15,"StringLiteralExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent event) {\n    double rate = Double.parseDouble(rateField.getText());\n    double interest = balance * rate / 100;\n    balance = balance + interest;\n    resultArea.append(balance + \"\\n\");\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"balance":4,"rate":2,"interest":2,"rateField":1,"resultArea":1,"Double":1},"constants":{"100":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"AddInterestListener":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":5,"StringLiteralExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"private void createButton() {\n    button = new JButton(\"Add Interest\");\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n}\n","name":"createButton","className":"InvestmentFrame3","variables":{"button":2,"listener":1},"constants":{"\"Add Interest\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"JScrollPane":1,"JPanel":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":20,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"private void createPanel() {\n    JPanel panel = new JPanel();\n    panel.add(rateLabel);\n    panel.add(rateField);\n    panel.add(button);\n    JScrollPane scrollPane = new JScrollPane(resultArea);\n    panel.add(scrollPane);\n    add(panel);\n}\n","name":"createPanel","className":"InvestmentFrame3","variables":{"scrollPane":1,"resultArea":1,"panel":5},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":2}
{"paramTypes":[],"returnType":"ColorFrame","methodCalls":{"add":1,"createControlPanel":1,"setSize":1,"setSampleColor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":15,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public ColorFrame() {\n    colorPanel = new JPanel();\n    add(colorPanel, BorderLayout.CENTER);\n    createControlPanel();\n    setSampleColor();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"ColorFrame","className":"ColorFrame","variables":{"colorPanel":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["ChangeEvent"],"returnType":"void","methodCalls":{"setSampleColor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void stateChanged(ChangeEvent event) {\n    setSampleColor();\n}\n","name":"stateChanged","className":"ColorListener","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":7,"setLayout":1,"addChangeListener":3},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JPanel":1,"ColorListener":1,"ChangeListener":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":11,"VariableDeclarationExpr":2,"NameExpr":45,"StringLiteralExpr":3,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":11},"statements":{"ExpressionStmt":16},"text":"public void createControlPanel() {\n    ChangeListener listener = new ColorListener();\n    redSlider = new JSlider(0, 255, 255);\n    redSlider.addChangeListener(listener);\n    greenSlider = new JSlider(0, 255, 175);\n    greenSlider.addChangeListener(listener);\n    blueSlider = new JSlider(0, 255, 175);\n    blueSlider.addChangeListener(listener);\n    JPanel controlPanel = new JPanel();\n    controlPanel.setLayout(new GridLayout(3, 2));\n    controlPanel.add(new JLabel(\"Red\"));\n    controlPanel.add(redSlider);\n    controlPanel.add(new JLabel(\"Green\"));\n    controlPanel.add(greenSlider);\n    controlPanel.add(new JLabel(\"Blue\"));\n    controlPanel.add(blueSlider);\n    add(controlPanel, BorderLayout.SOUTH);\n}\n","name":"createControlPanel","className":"ColorFrame","variables":{"controlPanel":8,"greenSlider":2,"redSlider":2,"listener":1,"blueSlider":2},"constants":{"0":3,"\"Green\"":1,"255":4,"2":1,"3":1,"\"Red\"":1,"175":2,"\"Blue\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":16,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getValue":3,"repaint":1,"setBackground":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":18,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"/**\n      Reads the slider values and sets the panel to\n      the selected color.\n   */\npublic void setSampleColor() {\n    // Read slider values\n    int red = redSlider.getValue();\n    int green = greenSlider.getValue();\n    int blue = blueSlider.getValue();\n    // Set panel background to selected color\n    colorPanel.setBackground(new Color(red, green, blue));\n    colorPanel.repaint();\n}\n","name":"setSampleColor","className":"ColorFrame","variables":{"red":2,"colorPanel":2,"green":2,"blue":2,"greenSlider":1,"redSlider":1,"blueSlider":1},"constants":{},"javaDoc":"Reads the slider values and sets the panel to the selected color","comments":"Read slider values Set panel background to selected color \n      Reads the slider values and sets the panel to\n      the selected color.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ColorFrame":1,"JFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new ColorFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ColorViewer","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"FilledFrame":1,"JFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new FilledFrame();\n    frame.setTitle(\"A frame with two components\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"FilledFrameViewer2","variables":{"frame":4},"constants":{"true":1,"\"A frame with two components\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"FilledFrame","methodCalls":{"createComponents":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public FilledFrame() {\n    createComponents();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"FilledFrame","className":"FilledFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"NameExpr":13,"StringLiteralExpr":2,"AssignExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":6},"text":"private void createComponents() {\n    button = new JButton(\"Click me!\");\n    label = new JLabel(\"Hello, World!\");\n    JPanel panel = new JPanel();\n    panel.add(button);\n    panel.add(label);\n    add(panel);\n}\n","name":"createComponents","className":"FilledFrame","variables":{"button":1,"label":1,"panel":3},"constants":{"\"Hello, World!\"":1,"\"Click me!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":2}
{"paramTypes":[],"returnType":"FontFrame","methodCalls":{"add":1,"setLabelFont":1,"createControlPanel":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"/**\n      Constructs the frame.\n   */\npublic FontFrame() {\n    // Construct text sample\n    label = new JLabel(\"Big Java\");\n    add(label, BorderLayout.CENTER);\n    // This listener is shared among all components\n    listener = new ChoiceListener();\n    createControlPanel();\n    setLabelFont();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"FontFrame","className":"FontFrame","variables":{"listener":1,"label":1},"constants":{"\"Big Java\"":1},"javaDoc":"Constructs the frame","comments":"Construct text sample This listener is shared among all components \n      Constructs the frame.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    setLabelFont();\n}\n","name":"actionPerformed","className":"ChoiceListener","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":4,"createCheckBoxes":1,"createComboBox":1,"setLayout":1,"createRadioButtons":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":4},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"NameExpr":27,"FieldAccessExpr":1,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"/**\n      Creates the control panel to change the font.\n   */\npublic void createControlPanel() {\n    JPanel facenamePanel = createComboBox();\n    JPanel sizeGroupPanel = createCheckBoxes();\n    JPanel styleGroupPanel = createRadioButtons();\n    // Line up component panels\n    JPanel controlPanel = new JPanel();\n    controlPanel.setLayout(new GridLayout(3, 1));\n    controlPanel.add(facenamePanel);\n    controlPanel.add(sizeGroupPanel);\n    controlPanel.add(styleGroupPanel);\n    // Add panels to content pane\n    add(controlPanel, BorderLayout.SOUTH);\n}\n","name":"createControlPanel","className":"FontFrame","variables":{"controlPanel":5,"facenamePanel":1,"styleGroupPanel":1,"sizeGroupPanel":1},"constants":{"1":1,"3":1},"javaDoc":"Creates the control panel to change the font","comments":"Line up component panels Add panels to content pane \n      Creates the control panel to change the font.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":1,"addItem":3,"setEditable":1,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":22,"StringLiteralExpr":3,"AssignExpr":1,"MethodCallExpr":6},"statements":{"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Creates the combo box with the font style choices.\n      @return the panel containing the combo box\n   */\npublic JPanel createComboBox() {\n    facenameCombo = new JComboBox();\n    facenameCombo.addItem(\"Serif\");\n    facenameCombo.addItem(\"SansSerif\");\n    facenameCombo.addItem(\"Monospaced\");\n    facenameCombo.setEditable(true);\n    facenameCombo.addActionListener(listener);\n    JPanel panel = new JPanel();\n    panel.add(facenameCombo);\n    return panel;\n}\n","name":"createComboBox","className":"FontFrame","variables":{"facenameCombo":6,"panel":3},"constants":{"\"SansSerif\"":1,"true":1,"\"Monospaced\"":1,"\"Serif\"":1},"javaDoc":"Creates the combo box with the font style choices the panel containing the combo box","comments":"\n      Creates the combo box with the font style choices.\n      @return the panel containing the combo box\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":2,"setBorder":1,"addActionListener":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":5,"VariableDeclarationExpr":1,"NameExpr":22,"StringLiteralExpr":3,"AssignExpr":2,"MethodCallExpr":5},"statements":{"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Creates the check boxes for selecting bold and italic styles.\n      @return the panel containing the check boxes\n   */\npublic JPanel createCheckBoxes() {\n    italicCheckBox = new JCheckBox(\"Italic\");\n    italicCheckBox.addActionListener(listener);\n    boldCheckBox = new JCheckBox(\"Bold\");\n    boldCheckBox.addActionListener(listener);\n    JPanel panel = new JPanel();\n    panel.add(italicCheckBox);\n    panel.add(boldCheckBox);\n    panel.setBorder(new TitledBorder(new EtchedBorder(), \"Style\"));\n    return panel;\n}\n","name":"createCheckBoxes","className":"FontFrame","variables":{"panel":5,"italicCheckBox":2,"boldCheckBox":2},"constants":{"\"Bold\"":1,"\"Style\"":1,"\"Italic\"":1},"javaDoc":"Creates the check boxes for selecting bold and italic styles the panel containing the check boxes","comments":"\n      Creates the check boxes for selecting bold and italic styles.\n      @return the panel containing the check boxes\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":6,"setSelected":1,"setBorder":1,"addActionListener":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"ButtonGroup":1},"expressions":{"ObjectCreationExpr":7,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":46,"StringLiteralExpr":4,"AssignExpr":3,"MethodCallExpr":11},"statements":{"ReturnStmt":1,"ExpressionStmt":16},"text":"/**\n      Creates the radio buttons to select the font size.\n      @return the panel containing the radio buttons\n   */\npublic JPanel createRadioButtons() {\n    smallButton = new JRadioButton(\"Small\");\n    smallButton.addActionListener(listener);\n    mediumButton = new JRadioButton(\"Medium\");\n    mediumButton.addActionListener(listener);\n    largeButton = new JRadioButton(\"Large\");\n    largeButton.addActionListener(listener);\n    largeButton.setSelected(true);\n    // Add radio buttons to button group\n    ButtonGroup group = new ButtonGroup();\n    group.add(smallButton);\n    group.add(mediumButton);\n    group.add(largeButton);\n    JPanel panel = new JPanel();\n    panel.add(smallButton);\n    panel.add(mediumButton);\n    panel.add(largeButton);\n    panel.setBorder(new TitledBorder(new EtchedBorder(), \"Size\"));\n    return panel;\n}\n","name":"createRadioButtons","className":"FontFrame","variables":{"mediumButton":2,"largeButton":3,"panel":6,"smallButton":2,"group":4},"constants":{"\"Medium\"":1,"true":1,"\"Size\"":1,"\"Large\"":1,"\"Small\"":1},"javaDoc":"Creates the radio buttons to select the font size the panel containing the radio buttons","comments":"Add radio buttons to button group \n      Creates the radio buttons to select the font size.\n      @return the panel containing the radio buttons\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":18,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"isSelected":5,"setFont":1,"repaint":1,"getSelectedItem":1},"annotations":[],"exceptions":[],"concepts":["Casting","FinalVariables"],"types":{"String":1,"int":5},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":2,"CastExpr":1,"NameExpr":43,"FieldAccessExpr":2,"MethodCallExpr":8,"AssignExpr":5},"statements":{"IfStmt":5,"BlockStmt":5,"ExpressionStmt":13},"text":"/**\n      Gets user choice for font name, style, and size\n      and sets the font of the text sample.\n   */\npublic void setLabelFont() {\n    // Get font name   \n    String facename = (String) facenameCombo.getSelectedItem();\n    // Get font style\n    int style = 0;\n    if (italicCheckBox.isSelected()) {\n        style = style + Font.ITALIC;\n    }\n    if (boldCheckBox.isSelected()) {\n        style = style + Font.BOLD;\n    }\n    // Get font size   \n    int size = 0;\n    final int SMALL_SIZE = 24;\n    final int MEDIUM_SIZE = 36;\n    final int LARGE_SIZE = 48;\n    if (smallButton.isSelected()) {\n        size = SMALL_SIZE;\n    } else if (mediumButton.isSelected()) {\n        size = MEDIUM_SIZE;\n    } else if (largeButton.isSelected()) {\n        size = LARGE_SIZE;\n    }\n    // Set font of text field\n    label.setFont(new Font(facename, style, size));\n    label.repaint();\n}\n","name":"setLabelFont","className":"FontFrame","variables":{"SMALL_SIZE":2,"facenameCombo":1,"label":2,"LARGE_SIZE":2,"facename":2,"smallButton":1,"mediumButton":1,"largeButton":1,"size":5,"style":6,"MEDIUM_SIZE":2,"italicCheckBox":1,"boldCheckBox":1},"constants":{"0":2,"24":1,"36":1,"48":1},"javaDoc":"Gets user choice for font name style and size and sets the font of the text sample","comments":"Get font style Get font size Set font of text field Get font name \n      Gets user choice for font name, style, and size\n      and sets the font of the text sample.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":14,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"FontFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new FontFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"FontViewer\");\n    frame.setVisible(true);\n}\n","name":"main","className":"FontViewer","variables":{"frame":4},"constants":{"true":1,"\"FontViewer\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"CalculatorFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new CalculatorFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"Calculator\");\n    frame.setVisible(true);\n}\n","name":"main","className":"CalculatorViewer","variables":{"frame":4},"constants":{"\"Calculator\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"CalculatorFrame","methodCalls":{"add":1,"createControlPanel":1,"createButtonPanel":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":18,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":8},"text":"public CalculatorFrame() {\n    createButtonPanel();\n    createControlPanel();\n    display = new JLabel(\"0\");\n    add(display, BorderLayout.NORTH);\n    lastValue = 0;\n    lastOperator = \"=\";\n    startNewValue = true;\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"CalculatorFrame","className":"CalculatorFrame","variables":{"lastValue":1,"lastOperator":1,"display":1,"startNewValue":1},"constants":{"0":1,"\"0\"":1,"\"=\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":17,"setLayout":1,"makeDigitButton":11,"makeOperatorButton":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":89,"StringLiteralExpr":16,"FieldAccessExpr":1,"MethodCallExpr":34},"statements":{"ExpressionStmt":19},"text":"/**\n      Creates the control panel with the text field \n      and buttons on the frame.\n   */\nprivate void createButtonPanel() {\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 4));\n    buttonPanel.add(makeDigitButton(\"7\"));\n    buttonPanel.add(makeDigitButton(\"8\"));\n    buttonPanel.add(makeDigitButton(\"9\"));\n    buttonPanel.add(makeOperatorButton(\"/\"));\n    buttonPanel.add(makeDigitButton(\"4\"));\n    buttonPanel.add(makeDigitButton(\"5\"));\n    buttonPanel.add(makeDigitButton(\"6\"));\n    buttonPanel.add(makeOperatorButton(\"*\"));\n    buttonPanel.add(makeDigitButton(\"1\"));\n    buttonPanel.add(makeDigitButton(\"2\"));\n    buttonPanel.add(makeDigitButton(\"3\"));\n    buttonPanel.add(makeOperatorButton(\"-\"));\n    buttonPanel.add(makeDigitButton(\"0\"));\n    buttonPanel.add(makeDigitButton(\".\"));\n    buttonPanel.add(makeOperatorButton(\"=\"));\n    buttonPanel.add(makeOperatorButton(\"+\"));\n    add(buttonPanel, BorderLayout.CENTER);\n}\n","name":"createButtonPanel","className":"CalculatorFrame","variables":{"buttonPanel":18},"constants":{"\"=\"":1,"\"9\"":1,"\"8\"":1,"\"7\"":1,"\"6\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"\"1\"":1,"4":2,"\"0\"":1,"\"/\"":1,"\".\"":1,"\"-\"":1,"\"+\"":1,"\"*\"":1},"javaDoc":"Creates the control panel with the text field and buttons on the frame","comments":"\n      Creates the control panel with the text field \n      and buttons on the frame.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":19,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"tan":1,"log":2,"getText":1,"cos":1,"equals":8,"isSelected":3,"sin":1,"pow":1,"toRadians":1,"getSelectedItem":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":1,"double":2,"String":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":88,"CastExpr":1,"StringLiteralExpr":9,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":22,"AssignExpr":9},"statements":{"IfStmt":8,"BlockStmt":8,"ExpressionStmt":14},"text":"public void actionPerformed(ActionEvent event) {\n    double value = Double.parseDouble(display.getText());\n    String mathOp = (String) mathOpCombo.getSelectedItem();\n    double base = 10;\n    if (baseeButton.isSelected()) {\n        base = Math.E;\n    } else if (base2Button.isSelected()) {\n        base = 2;\n    }\n    boolean radian = radianCheckBox.isSelected();\n    if (!radian && (mathOp.equals(\"sin\") || mathOp.equals(\"cos\") || mathOp.equals(\"tan\"))) {\n        value = Math.toRadians(value);\n    }\n    if (mathOp.equals(\"sin\")) {\n        value = Math.sin(value);\n    } else if (mathOp.equals(\"cos\")) {\n        value = Math.cos(value);\n    } else if (mathOp.equals(\"tan\")) {\n        value = Math.tan(value);\n    } else if (mathOp.equals(\"log\")) {\n        value = Math.log(value) / Math.log(base);\n    } else if (mathOp.equals(\"exp\")) {\n        value = Math.pow(base, value);\n    }\n    display.setText(\"\" + value);\n    startNewValue = true;\n}\n","name":"actionPerformed","className":"MathOpListener","variables":{"base2Button":1,"mathOp":9,"display":2,"baseeButton":1,"startNewValue":1,"mathOpCombo":1,"Math":7,"value":8,"Double":1,"base":3,"radian":2,"radianCheckBox":1},"constants":{"\"cos\"":2,"\"\"":1,"\"log\"":1,"2":1,"\"tan\"":2,"\"sin\"":2,"true":1,"\"exp\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":6,"setSelected":1,"setBorder":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"ButtonGroup":1},"expressions":{"ObjectCreationExpr":7,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":34,"StringLiteralExpr":4,"AssignExpr":3,"MethodCallExpr":8},"statements":{"ReturnStmt":1,"ExpressionStmt":13},"text":"private JPanel createBaseButtons() {\n    baseeButton = new JRadioButton(\"e\");\n    base10Button = new JRadioButton(\"10\");\n    base2Button = new JRadioButton(\"2\");\n    baseeButton.setSelected(true);\n    ButtonGroup group = new ButtonGroup();\n    group.add(baseeButton);\n    group.add(base10Button);\n    group.add(base2Button);\n    JPanel basePanel = new JPanel();\n    basePanel.add(baseeButton);\n    basePanel.add(base10Button);\n    basePanel.add(base2Button);\n    basePanel.setBorder(new TitledBorder(new EtchedBorder(), \"Base\"));\n    return basePanel;\n}\n","name":"createBaseButtons","className":"CalculatorFrame","variables":{"base10Button":1,"base2Button":1,"baseeButton":2,"basePanel":6,"group":4},"constants":{"\"10\"":1,"\"2\"":1,"true":1,"\"Base\"":1,"\"e\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":14,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5,"addItem":5,"setSelected":1,"addActionListener":1,"createBaseButtons":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":5,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":47,"StringLiteralExpr":7,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":13},"statements":{"ExpressionStmt":16},"text":"private void createControlPanel() {\n    radianCheckBox = new JCheckBox(\"Radian\");\n    radianCheckBox.setSelected(true);\n    mathOpCombo = new JComboBox();\n    mathOpCombo.addItem(\"sin\");\n    mathOpCombo.addItem(\"cos\");\n    mathOpCombo.addItem(\"tan\");\n    mathOpCombo.addItem(\"log\");\n    mathOpCombo.addItem(\"exp\");\n    mathOpButton = new JButton(\"Apply\");\n    mathOpButton.addActionListener(new MathOpListener());\n    JPanel controlPanel = new JPanel();\n    controlPanel.add(radianCheckBox);\n    controlPanel.add(createBaseButtons());\n    controlPanel.add(mathOpCombo);\n    controlPanel.add(mathOpButton);\n    add(controlPanel, BorderLayout.SOUTH);\n}\n","name":"createControlPanel","className":"CalculatorFrame","variables":{"controlPanel":5,"mathOpButton":2,"mathOpCombo":6,"radianCheckBox":2},"constants":{"\"Radian\"":1,"\"cos\"":1,"\"log\"":1,"\"tan\"":1,"true":1,"\"sin\"":1,"\"exp\"":1,"\"Apply\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":16,"modifier":2}
{"paramTypes":["double","double","String"],"returnType":"double","methodCalls":{"equals":4},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":21,"StringLiteralExpr":4,"MethodCallExpr":4},"statements":{"IfStmt":4,"BlockStmt":5,"ReturnStmt":5},"text":"/**\n      Combines two values with an operator.\n      @param value1 the first value\n      @param value2 the second value\n      @param op an operator (+, -, *, /, or =)\n   */\npublic double calculate(double value1, double value2, String op) {\n    if (op.equals(\"+\")) {\n        return value1 + value2;\n    } else if (op.equals(\"-\")) {\n        return value1 - value2;\n    } else if (op.equals(\"*\")) {\n        return value1 * value2;\n    } else if (op.equals(\"/\")) {\n        return value1 / value2;\n    } else // \"=\"\n    {\n        return value2;\n    }\n}\n","name":"calculate","className":"CalculatorFrame","variables":{"op":4,"value2":5,"value1":4},"constants":{"\"/\"":1,"\"-\"":1,"\"+\"":1,"\"*\"":1},"javaDoc":"Combines two values with an operator value1 the first value value2 the second value op an operator (+ - / or =)","comments":"\"=\" \n      Combines two values with an operator.\n      @param value1 the first value\n      @param value2 the second value\n      @param op an operator (+, -, *, /, or =)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"DigitButtonListener","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      */\npublic DigitButtonListener(String aDigit) {\n    digit = aDigit;\n}\n","name":"DigitButtonListener","className":"DigitButtonListener","variables":{"aDigit":1,"digit":1},"constants":{},"javaDoc":"Constructs a listener whose actionPerformed method adds a digit to the display aDigit the digit to add","comments":"\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":1,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent event) {\n    if (startNewValue) {\n        display.setText(\"\");\n        startNewValue = false;\n    }\n    display.setText(display.getText() + digit);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"startNewValue":2,"display":3,"digit":1},"constants":{"\"\"":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":7,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   */\npublic JButton makeDigitButton(String digit) {\n    JButton button = new JButton(digit);\n    ActionListener listener = new DigitButtonListener(digit);\n    button.addActionListener(listener);\n    return button;\n}\n","name":"makeDigitButton","className":"CalculatorFrame","variables":{"button":3,"listener":1,"digit":2},"constants":{},"javaDoc":"Makes a button representing a digit of a calculator digit the digit of the calculator the button of the calculator","comments":"\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String"],"returnType":"OperatorButtonListener","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n         Constructs a listener whose actionPerformed method\n         schedules an operator for execution.\n      */\npublic OperatorButtonListener(String anOperator) {\n    operator = anOperator;\n}\n","name":"OperatorButtonListener","className":"OperatorButtonListener","variables":{"anOperator":1,"operator":1},"constants":{},"javaDoc":"Constructs a listener whose actionPerformed method schedules an operator for execution","comments":"\n         Constructs a listener whose actionPerformed method\n         schedules an operator for execution.\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"getText":1,"calculate":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":20,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent event) {\n    if (!startNewValue) {\n        double value = Double.parseDouble(display.getText());\n        lastValue = calculate(lastValue, value, lastOperator);\n        display.setText(\"\" + lastValue);\n        startNewValue = true;\n    }\n    lastOperator = operator;\n}\n","name":"actionPerformed","className":"OperatorButtonListener","variables":{"lastValue":2,"lastOperator":1,"startNewValue":2,"display":2,"value":1,"Double":1,"operator":1},"constants":{"\"\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"JButton":1,"OperatorButtonListener":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":7,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calculator\n   */\npublic JButton makeOperatorButton(String op) {\n    JButton button = new JButton(op);\n    ActionListener listener = new OperatorButtonListener(op);\n    button.addActionListener(listener);\n    return button;\n}\n","name":"makeOperatorButton","className":"CalculatorFrame","variables":{"button":3,"op":2,"listener":1},"constants":{},"javaDoc":"Makes a button representing an operator of a calculator op the operator of the calculator the button of the calculator","comments":"\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calculator\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"InvestmentFrame2":1,"JFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new InvestmentFrame2();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer2","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"InvestmentFrame2","methodCalls":{"createPanel":1,"setSize":1,"createButton":1,"createTextField":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":14,"StringLiteralExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public InvestmentFrame2() {\n    balance = INITIAL_BALANCE;\n    resultLabel = new JLabel(\"Balance: \" + balance);\n    createTextField();\n    createButton();\n    createPanel();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"InvestmentFrame2","className":"InvestmentFrame2","variables":{"balance":2,"INITIAL_BALANCE":1,"resultLabel":1},"constants":{"\"Balance: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":2,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":4},"text":"private void createTextField() {\n    rateLabel = new JLabel(\"Interest Rate: \");\n    final int FIELD_WIDTH = 10;\n    rateField = new JTextField(FIELD_WIDTH);\n    rateField.setText(\"\" + DEFAULT_RATE);\n}\n","name":"createTextField","className":"InvestmentFrame2","variables":{"rateLabel":1,"DEFAULT_RATE":1,"FIELD_WIDTH":2,"rateField":2},"constants":{"\"\"":1,"\"Interest Rate: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"getText":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":15,"StringLiteralExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent event) {\n    double rate = Double.parseDouble(rateField.getText());\n    double interest = balance * rate / 100;\n    balance = balance + interest;\n    resultLabel.setText(\"Balance: \" + balance);\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"balance":4,"rate":2,"interest":2,"rateField":1,"Double":1,"resultLabel":1},"constants":{"100":1,"\"Balance: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"AddInterestListener":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":5,"StringLiteralExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"private void createButton() {\n    button = new JButton(\"Add Interest\");\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n}\n","name":"createButton","className":"InvestmentFrame2","variables":{"button":2,"listener":1},"constants":{"\"Add Interest\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":19,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"private void createPanel() {\n    JPanel panel = new JPanel();\n    panel.add(rateLabel);\n    panel.add(rateField);\n    panel.add(button);\n    panel.add(resultLabel);\n    add(panel);\n}\n","name":"createPanel","className":"InvestmentFrame2","variables":{"panel":5},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"FontFrame2":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new FontFrame2();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"FontViewer\");\n    frame.setVisible(true);\n}\n","name":"main","className":"FontViewer2","variables":{"frame":4},"constants":{"true":1,"\"FontViewer\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"FontFrame2","methodCalls":{"add":3,"setJMenuBar":1,"setLabelFont":1,"setSize":1,"createFileMenu":1,"createFontMenu":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JMenuBar":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":32,"StringLiteralExpr":2,"FieldAccessExpr":2,"AssignExpr":4,"MethodCallExpr":8},"statements":{"ExpressionStmt":11},"text":"/**\n      Constructs the frame.\n   */\npublic FontFrame2() {\n    // Construct text sample     \n    label = new JLabel(\"Big Java\");\n    add(label, BorderLayout.CENTER);\n    // Construct menu      \n    JMenuBar menuBar = new JMenuBar();\n    setJMenuBar(menuBar);\n    menuBar.add(createFileMenu());\n    menuBar.add(createFontMenu());\n    facename = \"Serif\";\n    fontsize = 24;\n    fontstyle = Font.PLAIN;\n    setLabelFont();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"FontFrame2","className":"FontFrame2","variables":{"menuBar":3,"fontstyle":1,"fontsize":1,"label":1,"facename":1},"constants":{"\"Big Java\"":1,"24":1,"\"Serif\"":1},"javaDoc":"Constructs the frame","comments":"Construct text sample Construct menu \n      Constructs the frame.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"ExitItemListener","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":1,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"ExitItemListener":1,"JMenuItem":1,"JMenu":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"StringLiteralExpr":2,"NameExpr":9,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Creates the File menu.\n      @return the menu\n   */\npublic JMenu createFileMenu() {\n    JMenu menu = new JMenu(\"File\");\n    JMenuItem exitItem = new JMenuItem(\"Exit\");\n    ActionListener listener = new ExitItemListener();\n    exitItem.addActionListener(listener);\n    menu.add(exitItem);\n    return menu;\n}\n","name":"createFileMenu","className":"FontFrame2","variables":{"exitItem":2,"listener":1,"menu":3},"constants":{"\"File\"":1,"\"Exit\"":1},"javaDoc":"Creates the File menu the menu","comments":"\n      Creates the File menu.\n      @return the menu\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":3,"createStyleMenu":1,"createSizeMenu":1,"createFaceMenu":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JMenu":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":16,"MethodCallExpr":6},"statements":{"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Creates the Font submenu.\n      @return the menu\n   */\npublic JMenu createFontMenu() {\n    JMenu menu = new JMenu(\"Font\");\n    menu.add(createFaceMenu());\n    menu.add(createSizeMenu());\n    menu.add(createStyleMenu());\n    return menu;\n}\n","name":"createFontMenu","className":"FontFrame2","variables":{"menu":5},"constants":{"\"Font\"":1},"javaDoc":"Creates the Font submenu the menu","comments":"\n      Creates the Font submenu.\n      @return the menu\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":3,"createFaceItem":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"JMenu":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":4,"NameExpr":16,"MethodCallExpr":6},"statements":{"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Creates the Face submenu.\n      @return the menu\n   */\npublic JMenu createFaceMenu() {\n    JMenu menu = new JMenu(\"Face\");\n    menu.add(createFaceItem(\"Serif\"));\n    menu.add(createFaceItem(\"SansSerif\"));\n    menu.add(createFaceItem(\"Monospaced\"));\n    return menu;\n}\n","name":"createFaceMenu","className":"FontFrame2","variables":{"menu":5},"constants":{"\"SansSerif\"":1,"\"Monospaced\"":1,"\"Serif\"":1,"\"Face\"":1},"javaDoc":"Creates the Face submenu the menu","comments":"\n      Creates the Face submenu.\n      @return the menu\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":2,"createSizeItem":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"JMenu":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"StringLiteralExpr":3,"NameExpr":11,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Creates the Size submenu.\n      @return the menu\n   */\npublic JMenu createSizeMenu() {\n    JMenu menu = new JMenu(\"Size\");\n    menu.add(createSizeItem(\"Smaller\", -1));\n    menu.add(createSizeItem(\"Larger\", 1));\n    return menu;\n}\n","name":"createSizeMenu","className":"FontFrame2","variables":{"menu":4},"constants":{"1":2,"\"Larger\"":1,"\"Size\"":1,"\"Smaller\"":1},"javaDoc":"Creates the Size submenu the menu","comments":"\n      Creates the Size submenu.\n      @return the menu\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":4,"createStyleItem":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"JMenu":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":5,"NameExpr":36,"FieldAccessExpr":5,"MethodCallExpr":8},"statements":{"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Creates the Style submenu.\n      @return the menu\n   */\npublic JMenu createStyleMenu() {\n    JMenu menu = new JMenu(\"Style\");\n    menu.add(createStyleItem(\"Plain\", Font.PLAIN));\n    menu.add(createStyleItem(\"Bold\", Font.BOLD));\n    menu.add(createStyleItem(\"Italic\", Font.ITALIC));\n    menu.add(createStyleItem(\"Bold Italic\", Font.BOLD + Font.ITALIC));\n    return menu;\n}\n","name":"createStyleMenu","className":"FontFrame2","variables":{"menu":6},"constants":{"\"Bold\"":1,"\"Style\"":1,"\"Bold Italic\"":1,"\"Italic\"":1,"\"Plain\"":1},"javaDoc":"Creates the Style submenu the menu","comments":"\n      Creates the Style submenu.\n      @return the menu\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent event) {\n    facename = name;\n    setLabelFont();\n}\n","name":"actionPerformed","className":"FaceItemListener","variables":{"name":1,"facename":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"JMenuItem","methodCalls":{"setLabelFont":1,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"JMenuItem":1,"FaceItemListener":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":14,"AssignExpr":1,"MethodCallExpr":2},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Creates a menu item to change the font face and set its action listener.\n      @param name the name of the font face\n      @return the menu item\n   */\npublic JMenuItem createFaceItem(final String name) {\n    class FaceItemListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            facename = name;\n            setLabelFont();\n        }\n    }\n    JMenuItem item = new JMenuItem(name);\n    ActionListener listener = new FaceItemListener();\n    item.addActionListener(listener);\n    return item;\n}\n","name":"createFaceItem","className":"FontFrame2","variables":{"actionPerformed":1,"item":3,"name":2,"listener":1,"event":1,"FaceItemListener":1,"facename":1},"constants":{},"javaDoc":"Creates a menu item to change the font face and set its action listener name the name of the font face the menu item","comments":"\n      Creates a menu item to change the font face and set its action listener.\n      @param name the name of the font face\n      @return the menu item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":5,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent event) {\n    fontsize = fontsize + increment;\n    setLabelFont();\n}\n","name":"actionPerformed","className":"SizeItemListener","variables":{"fontsize":2,"increment":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String","int"],"returnType":"JMenuItem","methodCalls":{"setLabelFont":1,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"SizeItemListener":1,"ActionListener":1,"JMenuItem":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":15,"AssignExpr":1,"MethodCallExpr":2},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Creates a menu item to change the font size\n      and set its action listener.\n      @param name the name of the menu item\n      @param increment the amount by which to change the size\n      @return the menu item\n   */\npublic JMenuItem createSizeItem(String name, final int increment) {\n    class SizeItemListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            fontsize = fontsize + increment;\n            setLabelFont();\n        }\n    }\n    JMenuItem item = new JMenuItem(name);\n    ActionListener listener = new SizeItemListener();\n    item.addActionListener(listener);\n    return item;\n}\n","name":"createSizeItem","className":"FontFrame2","variables":{"actionPerformed":1,"SizeItemListener":1,"item":3,"name":1,"listener":1,"fontsize":2,"increment":1,"event":1},"constants":{},"javaDoc":"Creates a menu item to change the font size and set its action listener name the name of the menu item increment the amount by which to change the size the menu item","comments":"\n      Creates a menu item to change the font size\n      and set its action listener.\n      @param name the name of the menu item\n      @param increment the amount by which to change the size\n      @return the menu item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent event) {\n    fontstyle = style;\n    setLabelFont();\n}\n","name":"actionPerformed","className":"StyleItemListener","variables":{"fontstyle":1,"style":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String","int"],"returnType":"JMenuItem","methodCalls":{"setLabelFont":1,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"StyleItemListener":1,"JMenuItem":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":14,"AssignExpr":1,"MethodCallExpr":2},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Creates a menu item to change the font style\n      and set its action listener.\n      @param name the name of the menu item\n      @param style the new font style\n      @return the menu item\n   */\npublic JMenuItem createStyleItem(String name, final int style) {\n    class StyleItemListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            fontstyle = style;\n            setLabelFont();\n        }\n    }\n    JMenuItem item = new JMenuItem(name);\n    ActionListener listener = new StyleItemListener();\n    item.addActionListener(listener);\n    return item;\n}\n","name":"createStyleItem","className":"FontFrame2","variables":{"actionPerformed":1,"item":3,"fontstyle":1,"StyleItemListener":1,"name":1,"listener":1,"style":1,"event":1},"constants":{},"javaDoc":"Creates a menu item to change the font style and set its action listener name the name of the menu item style the new font style the menu item","comments":"\n      Creates a menu item to change the font style\n      and set its action listener.\n      @param name the name of the menu item\n      @param style the new font style\n      @return the menu item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Font":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Sets the font of the text sample.\n   */\npublic void setLabelFont() {\n    Font f = new Font(facename, fontstyle, fontsize);\n    label.setFont(f);\n}\n","name":"setLabelFont","className":"FontFrame2","variables":{"fontstyle":1,"f":1,"fontsize":1,"label":1,"facename":1},"constants":{},"javaDoc":"Sets the font of the text sample","comments":"\n      Sets the font of the text sample.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":2,"translate":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Rectangle":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":2,"CastExpr":1,"NameExpr":12,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"public void paintComponent(Graphics g) {\n    // Recover Graphics2D\n    Graphics2D g2 = (Graphics2D) g;\n    // Construct a rectangle and draw it\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    g2.draw(box);\n    // Move rectangle 15 units to the right and 25 units down\n    box.translate(15, 25);\n    // Draw moved rectangle\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent","variables":{"g":1,"box":2,"g2":3},"constants":{"25":1,"15":1,"5":1,"30":1,"20":1,"10":1},"javaDoc":"","comments":"Recover Graphics2D Construct a rectangle and draw it Move rectangle 15 units to the right and 25 units down Draw moved rectangle ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"RectangleComponent":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setTitle(\"Two rectangles\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    RectangleComponent component = new RectangleComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer","variables":{"component":1,"frame":6},"constants":{"300":1,"\"Two rectangles\"":1,"400":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":2,"translate":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Rectangle":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":2,"CastExpr":1,"NameExpr":12,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"public void paintComponent(Graphics g) {\n    // Recover Graphics2D\n    Graphics2D g2 = (Graphics2D) g;\n    // Construct a rectangle and draw it\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    g2.draw(box);\n    // Move rectangle 15 units to the right and 25 units down\n    box.translate(15, 25);\n    // Draw moved rectangle\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent","variables":{"g":1,"box":2,"g2":3},"constants":{"25":1,"15":1,"5":1,"30":1,"20":1,"10":1},"javaDoc":"","comments":"Recover Graphics2D Construct a rectangle and draw it Move rectangle 15 units to the right and 25 units down Draw moved rectangle ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":4,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":49,"StringLiteralExpr":4,"FieldAccessExpr":8,"MethodCallExpr":8,"AssignExpr":3},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    // Declares width and initializes it with 10\n    int width = 10;\n    System.out.print(\"width: \");\n    System.out.println(width);\n    // Changes width to 20\n    width = 20;\n    System.out.print(\"width: \");\n    System.out.println(width);\n    int height = 20;\n    // The right hand side can be an expression\n    width = height + 10;\n    System.out.print(\"width: \");\n    System.out.println(width);\n    // The same variable can occur on both sides\n    width = width + 10;\n    System.out.print(\"width: \");\n    System.out.println(width);\n}\n","name":"main","className":"VariableDemo","variables":{"width":5,"height":2},"constants":{"\"width: \"":4,"20":2,"10":3},"javaDoc":"","comments":"Declares width and initializes it with 10 Changes width to 20 The right hand side can be an expression The same variable can occur on both sides ","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getWidth":1,"System.out.print":4,"translate":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"Rectangle":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":2,"NameExpr":50,"StringLiteralExpr":4,"FieldAccessExpr":8,"MethodCallExpr":10},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    System.out.print(\"box: \");\n    System.out.println(box);\n    // getWidth is an accessor method\n    double width = box.getWidth();\n    System.out.print(\"width: \");\n    System.out.println(width);\n    // Calling an accessor doesn't change the object\n    System.out.print(\"box: \");\n    System.out.println(box);\n    // translate is a mutator method\n    box.translate(15, 25);\n    // Calling a mutator changes the object.\n    System.out.print(\"box: \");\n    System.out.println(box);\n}\n","name":"main","className":"AccessorMutatorDemo","variables":{"width":1,"box":3},"constants":{"\"width: \"":1,"\"box: \"":3,"25":1,"15":1,"5":1,"30":1,"20":1,"10":1},"javaDoc":"","comments":"getWidth is an accessor method Calling an accessor doesn't change the object translate is a mutator method Calling a mutator changes the object ","isEmpty":false,"hasInnerClass":false,"lineCount":15,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":15,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setTitle(\"An empty frame\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"EmptyFrameViewer","variables":{"frame":5},"constants":{"300":1,"400":1,"true":1,"\"An empty frame\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":2,"replace":1,"System.out.print":3,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2,"int":1},"expressions":{"VariableDeclarationExpr":3,"StringLiteralExpr":7,"NameExpr":48,"FieldAccessExpr":7,"MethodCallExpr":10,"AssignExpr":1},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    String greeting = \"Hello, World!\";\n    System.out.println(greeting);\n    // greeting is the argument in this call to the println method\n    int numberOfCharacters = greeting.length();\n    // The length method returns a value\n    System.out.print(\"numberOfCharacters: \");\n    System.out.println(numberOfCharacters);\n    // You can use the return value of one method as an argument of another method\n    System.out.print(\"greeting.length(): \");\n    System.out.println(greeting.length());\n    // The replace method has two arguments\n    String river = \"Mississippi\";\n    river = river.replace(\"issipp\", \"our\");\n    System.out.print(\"river: \");\n    System.out.println(river);\n}\n","name":"main","className":"MethodDemo","variables":{"greeting":3,"numberOfCharacters":1,"river":3},"constants":{"\"numberOfCharacters: \"":1,"\"Mississippi\"":1,"\"river: \"":1,"\"issipp\"":1,"\"Hello, World!\"":1,"\"our\"":1,"\"greeting.length(): \"":1},"javaDoc":"","comments":"The length method returns a value You can use the return value of one method as an argument of another method greeting is the argument in this call to the println method The replace method has two arguments ","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":3,"draw":2,"fill":2,"translate":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Line2D.Double":1,"Ellipse2D.Double":1,"Rectangle":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":16,"VariableDeclarationExpr":4,"CastExpr":1,"NameExpr":41,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":9},"statements":{"ExpressionStmt":13},"text":"public void paintComponent(Graphics g) {\n    // Recover Graphics2D \n    Graphics2D g2 = (Graphics2D) g;\n    // Draw the head\n    Ellipse2D.Double head = new Ellipse2D.Double(5, 10, 100, 150);\n    g2.draw(head);\n    // Draw the eyes\n    g2.setColor(Color.GREEN);\n    Rectangle eye = new Rectangle(25, 70, 15, 15);\n    g2.fill(eye);\n    eye.translate(50, 0);\n    g2.fill(eye);\n    // Draw the mouth\n    Line2D.Double mouth = new Line2D.Double(30, 110, 80, 110);\n    g2.setColor(Color.RED);\n    g2.draw(mouth);\n    // Draw the greeting\n    g2.setColor(Color.BLUE);\n    g2.drawString(\"Hello, World!\", 5, 175);\n}\n","name":"paintComponent","className":"FaceComponent","variables":{"head":1,"eye":2,"mouth":1,"g":1,"g2":9},"constants":{"25":1,"15":2,"\"Hello, World!\"":1,"150":1,"175":1,"0":1,"110":2,"100":1,"5":2,"80":1,"70":1,"50":1,"30":1,"10":1},"javaDoc":"","comments":"Recover Graphics2D Draw the head Draw the eyes Draw the mouth Draw the greeting ","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"FaceComponent":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(150, 250);\n    frame.setTitle(\"An Alien Face\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    FaceComponent component = new FaceComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"FaceViewer","variables":{"component":1,"frame":6},"constants":{"\"An Alien Face\"":1,"true":1,"150":1,"250":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"daysFrom":1,"toString":1,"System.out.print":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Day":2,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"NameExpr":28,"StringLiteralExpr":2,"FieldAccessExpr":4,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Day jamesGoslingsBirthday = new Day(1955, 5, 19);\n    Day today = new Day();\n    System.out.print(\"Today: \");\n    System.out.println(today.toString());\n    int daysAlive = today.daysFrom(jamesGoslingsBirthday);\n    System.out.print(\"Days alive: \");\n    System.out.println(daysAlive);\n}\n","name":"main","className":"DaysAlivePrinter","variables":{"daysAlive":1,"jamesGoslingsBirthday":1,"today":3},"constants":{"5":1,"\"Days alive: \"":1,"19":1,"\"Today: \"":1,"1955":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"Day","methodCalls":{"get":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"GregorianCalendar":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":21,"FieldAccessExpr":3,"AssignExpr":3,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a day object representing today's date.\n   */\npublic Day() {\n    GregorianCalendar today = new GregorianCalendar();\n    year = today.get(GregorianCalendar.YEAR);\n    month = today.get(GregorianCalendar.MONTH) + 1;\n    date = today.get(GregorianCalendar.DAY_OF_MONTH);\n}\n","name":"Day","className":"Day","variables":{"date":1,"month":1,"year":1,"today":4},"constants":{"1":1},"javaDoc":"Constructs a day object representing today's date","comments":"\n      Constructs a day object representing today's date.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"Day","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a day with a given year, month, and day\n      of the Julian/Gregorian calendar. The Julian calendar\n      is used for all days before October 15, 1582\n      @param aYear a year != 0\n      @param aMonth a month between 1 and 12\n      @param aDate a date between 1 and 31\n   */\npublic Day(int aYear, int aMonth, int aDate) {\n    year = aYear;\n    month = aMonth;\n    date = aDate;\n}\n","name":"Day","className":"Day","variables":{"date":1,"month":1,"year":1,"aMonth":1,"aDate":1,"aYear":1},"constants":{},"javaDoc":"Constructs a day with a given year month and day of the Julian/Gregorian calendar The Julian calendar is used for all days before October 15 1582 aYear a year != 0 aMonth a month between 1 and 12 aDate a date between 1 and 31","comments":"\n      Constructs a day with a given year, month, and day\n      of the Julian/Gregorian calendar. The Julian calendar\n      is used for all days before October 15, 1582\n      @param aYear a year != 0\n      @param aMonth a month between 1 and 12\n      @param aDate a date between 1 and 31\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the year of this day.\n      @return the year\n   */\npublic int getYear() {\n    return year;\n}\n","name":"getYear","className":"Day","variables":{"year":1},"constants":{},"javaDoc":"Returns the year of this day the year","comments":"\n      Returns the year of this day.\n      @return the year\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the month of this day.\n      @return the month\n   */\npublic int getMonth() {\n    return month;\n}\n","name":"getMonth","className":"Day","variables":{"month":1},"constants":{},"javaDoc":"Returns the month of this day the month","comments":"\n      Returns the month of this day.\n      @return the month\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the day of the month of this day.\n      @return the day of the month\n   */\npublic int getDate() {\n    return date;\n}\n","name":"getDate","className":"Day","variables":{"date":1},"constants":{},"javaDoc":"Returns the day of the month of this day the day of the month","comments":"\n      Returns the day of the month of this day.\n      @return the day of the month\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Day","methodCalls":{"nextDay":1,"previousDay":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Day":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":13,"UnaryExpr":2,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":2},"statements":{"WhileStmt":2,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Returns a day that is a certain number of days away from\n      this day.\n      @param n the number of days, can be negative\n      @return a day that is n days away from this one\n   */\npublic Day addDays(int n) {\n    Day result = this;\n    while (n > 0) {\n        result = result.nextDay();\n        n--;\n    }\n    while (n < 0) {\n        result = result.previousDay();\n        n++;\n    }\n    return result;\n}\n","name":"addDays","className":"Day","variables":{"result":6,"n":4},"constants":{"0":2},"javaDoc":"Returns a day that is a certain number of days away from this day n the number of days can be negative a day that is n days away from this one","comments":"\n      Returns a day that is a certain number of days away from\n      this day.\n      @param n the number of days, can be negative\n      @return a day that is n days away from this one\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Day"],"returnType":"int","methodCalls":{"compareTo":2,"previousDay":1,"nextDay":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Day":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":19,"UnaryExpr":2,"ThisExpr":1,"MethodCallExpr":4,"AssignExpr":2},"statements":{"WhileStmt":2,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n      Returns the number of days between this day and another\n      day.\n      @param other the other day\n      @return the number of days that this day is away from \n      the other (larger than 0 if this day comes later than <code>other</code>)\n   */\npublic int daysFrom(Day other) {\n    int n = 0;\n    Day d = this;\n    while (d.compareTo(other) > 0) {\n        d = d.previousDay();\n        n++;\n    }\n    while (d.compareTo(other) < 0) {\n        d = d.nextDay();\n        n--;\n    }\n    return n;\n}\n","name":"daysFrom","className":"Day","variables":{"d":7,"n":4},"constants":{"0":3},"javaDoc":"Returns the number of days between this day and another day other the other day the number of days that this day is away from the other (larger than 0 if this day comes later than <code>other</code>)","comments":"\n      Returns the number of days between this day and another\n      day.\n      @param other the other day\n      @return the number of days that this day is away from \n      the other (larger than 0 if this day comes later than <code>other</code>)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return String.format(\"%04d-%02d-%02d\", year, month, date);\n}\n","name":"toString","className":"Day","variables":{"String":1},"constants":{"\"%04d-%02d-%02d\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Day"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"BinaryExpr":5,"NameExpr":20,"FieldAccessExpr":5,"UnaryExpr":2},"statements":{"IfStmt":4,"ReturnStmt":5},"text":"/**\n      Compares this day with another day.\n      @param other the other day\n      @return a positive number if this day comes after the\n      other day, a negative number if this day comes before\n      the other day, and zero if the days are the same\n   */\nprivate int compareTo(Day other) {\n    if (year > other.year)\n        return 1;\n    if (year < other.year)\n        return -1;\n    if (month > other.month)\n        return 1;\n    if (month < other.month)\n        return -1;\n    return date - other.date;\n}\n","name":"compareTo","className":"Day","variables":{"date":1,"month":2,"year":2},"constants":{"1":4},"javaDoc":"Compares this day with another day other the other day a positive number if this day comes after the other day a negative number if this day comes before the other day and zero if the days are the same","comments":"\n      Compares this day with another day.\n      @param other the other day\n      @return a positive number if this day comes after the\n      other day, a negative number if this day comes before\n      the other day, and zero if the days are the same\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":2}
{"paramTypes":[],"returnType":"Day","methodCalls":{"daysPerMonth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":8,"NameExpr":29,"UnaryExpr":4,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":4,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":10},"text":"/**\n      Computes the next day.\n      @return the day following this day\n   */\nprivate Day nextDay() {\n    int y = year;\n    int m = month;\n    int d = date;\n    if (y == GREGORIAN_START_YEAR && m == GREGORIAN_START_MONTH && d == JULIAN_END_DAY)\n        d = GREGORIAN_START_DAY;\n    else if (d < daysPerMonth(y, m))\n        d++;\n    else {\n        d = 1;\n        m++;\n        if (m > DECEMBER) {\n            m = JANUARY;\n            y++;\n            if (y == 0)\n                y++;\n        }\n    }\n    return new Day(y, m, d);\n}\n","name":"nextDay","className":"Day","variables":{"date":1,"JANUARY":1,"month":1,"d":7,"year":1,"GREGORIAN_START_MONTH":1,"GREGORIAN_START_DAY":1,"DECEMBER":1,"y":6,"m":6,"JULIAN_END_DAY":1,"GREGORIAN_START_YEAR":1},"constants":{"0":1,"1":1},"javaDoc":"Computes the next day the day following this day","comments":"\n      Computes the next day.\n      @return the day following this day\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":2}
{"paramTypes":[],"returnType":"Day","methodCalls":{"daysPerMonth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":8,"NameExpr":29,"UnaryExpr":4,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":4,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":10},"text":"/**\n      Computes the previous day.\n      @return the day preceding this day\n   */\nprivate Day previousDay() {\n    int y = year;\n    int m = month;\n    int d = date;\n    if (y == GREGORIAN_START_YEAR && m == GREGORIAN_START_MONTH && d == GREGORIAN_START_DAY)\n        d = JULIAN_END_DAY;\n    else if (d > 1)\n        d--;\n    else {\n        m--;\n        if (m < JANUARY) {\n            m = DECEMBER;\n            y--;\n            if (y == 0)\n                y--;\n        }\n        d = daysPerMonth(y, m);\n    }\n    return new Day(y, m, d);\n}\n","name":"previousDay","className":"Day","variables":{"date":1,"JANUARY":1,"month":1,"d":7,"year":1,"GREGORIAN_START_MONTH":1,"GREGORIAN_START_DAY":1,"DECEMBER":1,"y":6,"m":6,"JULIAN_END_DAY":1,"GREGORIAN_START_YEAR":1},"constants":{"0":1,"1":1},"javaDoc":"Computes the previous day the day preceding this day","comments":"\n      Computes the previous day.\n      @return the day preceding this day\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":2}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"isLeapYear":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":9,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the days in a given month.\n      @param y the year\n      @param m the month\n      @return the last day in the given month\n   */\nprivate static int daysPerMonth(int y, int m) {\n    int days = DAYS_PER_MONTH[m - 1];\n    if (m == FEBRUARY && isLeapYear(y))\n        days++;\n    return days;\n}\n","name":"daysPerMonth","className":"Day","variables":{"days":3,"FEBRUARY":1,"m":2,"DAYS_PER_MONTH":1},"constants":{"1":1},"javaDoc":"Gets the days in a given month y the year m the month the last day in the given month","comments":"\n      Gets the days in a given month.\n      @param y the year\n      @param m the month\n      @return the last day in the given month\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":6,"BinaryExpr":8,"BooleanLiteralExpr":2,"NameExpr":5,"EnclosedExpr":2},"statements":{"IfStmt":2,"ReturnStmt":3},"text":"/**\n      Tests if a year is a leap year.\n      @param y the year\n      @return true if y is a leap year\n   */\nprivate static boolean isLeapYear(int y) {\n    if (y % 4 != 0)\n        return false;\n    if (y < GREGORIAN_START_YEAR)\n        return true;\n    return (y % 100 != 0) || (y % 400 == 0);\n}\n","name":"isLeapYear","className":"Day","variables":{"y":4,"GREGORIAN_START_YEAR":1},"constants":{"0":3,"100":1,"4":1,"400":1,"false":1,"true":1},"javaDoc":"Tests if a year is a leap year y the year true if y is a leap year","comments":"\n      Tests if a year is a leap year.\n      @param y the year\n      @return true if y is a leap year\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"daysFrom":1,"getYear":1,"addDays":1,"getDate":1,"getMonth":1,"System.out.println":8},"annotations":[],"exceptions":[],"concepts":[],"types":{"Day":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"NameExpr":56,"StringLiteralExpr":4,"FieldAccessExpr":8,"MethodCallExpr":13},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    // February 15, 2010\n    Day today = new Day(2010, 2, 15);\n    Day later = today.addDays(30);\n    System.out.println(later.getYear());\n    System.out.println(\"Expected: 2010\");\n    System.out.println(later.getMonth());\n    System.out.println(\"Expected: 3\");\n    System.out.println(later.getDate());\n    System.out.println(\"Expected: 13\");\n    System.out.println(later.daysFrom(today));\n    System.out.println(\"Expected: 30\");\n}\n","name":"main","className":"DayTester","variables":{"later":5,"today":2},"constants":{"2":1,"15":1,"\"Expected: 3\"":1,"\"Expected: 2010\"":1,"\"Expected: 30\"":1,"2010":1,"\"Expected: 13\"":1,"30":1},"javaDoc":"","comments":"February 15 2010 ","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"load":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Picture":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Picture pic = new Picture();\n    pic.load(\"queen-mary.png\");\n}\n","name":"main","className":"PictureDemo","variables":{"pic":2},"constants":{"\"queen-mary.png\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"border":1,"getHeight":1,"move":1,"load":1,"scale":1,"getWidth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Picture":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":20,"StringLiteralExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Picture pic = new Picture();\n    pic.load(\"queen-mary.png\");\n    int newWidth = pic.getWidth() - 40;\n    int newHeight = pic.getHeight() - 40;\n    pic.scale(newWidth, newHeight);\n    pic.move(20, 20);\n    pic.border(10);\n}\n","name":"main","className":"BorderMaker","variables":{"newWidth":1,"newHeight":1,"pic":7},"constants":{"\"queen-mary.png\"":1,"40":2,"20":2,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"Picture","methodCalls":{"add":1,"setVisible":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"BooleanLiteralExpr":1,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"/**\n      Constructs a blank picture.\n   */\npublic Picture() {\n    frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    label = new JLabel(\"(No image)\");\n    frame.add(label);\n    frame.pack();\n    frame.setVisible(true);\n}\n","name":"Picture","className":"Picture","variables":{"label":1,"frame":5},"constants":{"\"(No image)\"":1,"true":1},"javaDoc":"Constructs a blank picture","comments":"\n      Constructs a blank picture.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getWidth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the width of this picture.\n      @return the width\n    */\npublic int getWidth() {\n    return image.getWidth();\n}\n","name":"getWidth","className":"Picture","variables":{"image":1},"constants":{},"javaDoc":"Gets the width of this picture the width","comments":"\n      Gets the width of this picture.\n      @return the width\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getHeight":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the height of this picture.\n      @return the height\n    */\npublic int getHeight() {\n    return image.getHeight();\n}\n","name":"getHeight","className":"Picture","variables":{"image":1},"constants":{},"javaDoc":"Gets the height of this picture the height","comments":"\n      Gets the height of this picture.\n      @return the height\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"read":2,"printStackTrace":1,"startsWith":1,"setImage":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"BufferedImage":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":26,"StringLiteralExpr":1,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":4,"MethodCallExpr":6},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n    */\npublic void load(String source) {\n    try {\n        this.source = source;\n        BufferedImage img;\n        if (source.startsWith(\"http://\"))\n            img = ImageIO.read(new URL(source).openStream());\n        else\n            img = ImageIO.read(new File(source));\n        setImage(img);\n    } catch (Exception ex) {\n        this.source = null;\n        ex.printStackTrace();\n    }\n}\n","name":"load","className":"Picture","variables":{"img":3,"ex":2,"source":4,"ImageIO":2},"constants":{"null":1,"\"http://\"":1},"javaDoc":"Loads a picture from a given source source the image source If the source starts with http:// it is a URL otherwise a filename","comments":"\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"load":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Reloads this picture, undoing any manipulations.\n    */\npublic void reload() {\n    load(source);\n}\n","name":"reload","className":"Picture","variables":{},"constants":{},"javaDoc":"Reloads this picture undoing any manipulations","comments":"\n      Reloads this picture, undoing any manipulations.\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showOpenDialog":1,"load":1,"getSelectedFile":1,"getAbsolutePath":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":13,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Displays a file chooser for picking a picture.\n    */\npublic void pick() {\n    JFileChooser chooser = new JFileChooser(\".\");\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        load(chooser.getSelectedFile().getAbsolutePath());\n    }\n}\n","name":"pick","className":"Picture","variables":{"chooser":3},"constants":{"null":1,"\".\"":1},"javaDoc":"Displays a file chooser for picking a picture","comments":"\n      Displays a file chooser for picking a picture.\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"filter":1,"getTranslateInstance":1,"getHeight":1,"getWidth":1,"setImage":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"BufferedImageOp":1,"BufferedImage":1,"AffineTransformOp":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":4},"text":"/**\n      Moves this picture by the given amount in x- and y-direction. \n      @param dx the offset in the x-direction\n      @param dy the offset in the y-direction\n    */\npublic void move(int dx, int dy) {\n    BufferedImageOp op = new AffineTransformOp(AffineTransform.getTranslateInstance(dx, dy), AffineTransformOp.TYPE_BILINEAR);\n    BufferedImage filteredImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);\n    op.filter(image, filteredImage);\n    setImage(filteredImage);\n}\n","name":"move","className":"Picture","variables":{"op":2,"image":2,"AffineTransform":1,"filteredImage":1},"constants":{},"javaDoc":"Moves this picture by the given amount in x- and y-direction dx the offset in the x-direction dy the offset in the y-direction","comments":"\n      Moves this picture by the given amount in x- and y-direction. \n      @param dx the offset in the x-direction\n      @param dy the offset in the y-direction\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"filter":1,"getHeight":2,"getWidth":2,"getScaleInstance":1,"setImage":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"BufferedImageOp":1,"double":2,"BufferedImage":1,"AffineTransformOp":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"DoubleLiteralExpr":2,"BinaryExpr":4,"NameExpr":33,"FieldAccessExpr":2,"MethodCallExpr":7},"statements":{"ExpressionStmt":6},"text":"/**\n      Scales this picture to a new size. If the new size is smaller \n      than the old size, the remainder is filled with transparent \n      pixels. If it is larger, it is clipped.\n      @param newWidth the new width of the picture\n      @param newHeight the new height of the picture\n   */\npublic void scale(int newWidth, int newHeight) {\n    double dx = newWidth * 1.0 / image.getWidth();\n    double dy = newHeight * 1.0 / image.getHeight();\n    BufferedImageOp op = new AffineTransformOp(AffineTransform.getScaleInstance(dx, dy), AffineTransformOp.TYPE_BILINEAR);\n    BufferedImage filteredImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);\n    op.filter(image, filteredImage);\n    setImage(filteredImage);\n}\n","name":"scale","className":"Picture","variables":{"image":4,"op":2,"dx":1,"newWidth":1,"dy":1,"newHeight":1,"AffineTransform":1,"filteredImage":1},"constants":{"1.0":2},"javaDoc":"Scales this picture to a new size If the new size is smaller than the old size the remainder is filled with transparent pixels If it is larger it is clipped newWidth the new width of the picture newHeight the new height of the picture","comments":"\n      Scales this picture to a new size. If the new size is smaller \n      than the old size, the remainder is filled with transparent \n      pixels. If it is larger, it is clipped.\n      @param newWidth the new width of the picture\n      @param newHeight the new height of the picture\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getHeight":2,"setColorAt":4,"getWidth":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":4},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":4,"BinaryExpr":9,"NameExpr":52,"FieldAccessExpr":4,"UnaryExpr":4,"MethodCallExpr":8},"statements":{"BlockStmt":4,"ForStmt":4,"ExpressionStmt":4},"text":"/**\n      Adds a black border to the image.\n      @param width the border width\n   */\npublic void border(int width) {\n    for (int x = 0; x < width; x++) {\n        for (int y = 0; y < image.getHeight(); y++) {\n            setColorAt(x, y, Color.BLACK);\n            setColorAt(image.getWidth() - 1 - x, y, Color.BLACK);\n        }\n    }\n    for (int y = 0; y < width; y++) {\n        for (int x = width; x < image.getWidth() - width; x++) {\n            setColorAt(x, y, Color.BLACK);\n            setColorAt(x, image.getHeight() - 1 - y, Color.BLACK);\n        }\n    }\n}\n","name":"border","className":"Picture","variables":{"image":4,"x":7,"width":4,"y":7},"constants":{"0":3,"1":2},"javaDoc":"Adds a black border to the image width the border width","comments":"\n      Adds a black border to the image.\n      @param width the border width\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Color","methodCalls":{"getColorModel":1,"getDataElements":1,"getRaster":1,"getRGB":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ColorModel":1,"Raster":1,"int":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"NameExpr":15,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   */\npublic Color getColorAt(int x, int y) {\n    Raster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    int argb = model.getRGB(raster.getDataElements(x, y, null));\n    return new Color(argb, true);\n}\n","name":"getColorAt","className":"Picture","variables":{"image":2,"argb":2,"raster":2,"model":2},"constants":{"null":1,"true":1},"javaDoc":"Gets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) the color of the pixel at position (x y)","comments":"\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int","Color"],"returnType":"void","methodCalls":{"getColorModel":1,"getDataElements":1,"setDataElements":1,"repaint":1,"getRaster":1,"getRGB":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"WritableRaster":1,"ColorModel":1,"Object":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":21,"MethodCallExpr":6},"statements":{"ExpressionStmt":5},"text":"/**\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   */\npublic void setColorAt(int x, int y, Color c) {\n    WritableRaster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    Object colorData = model.getDataElements(c.getRGB(), null);\n    raster.setDataElements(x, y, colorData);\n    label.repaint();\n}\n","name":"setColorAt","className":"Picture","variables":{"image":2,"c":1,"colorData":1,"raster":2,"model":2,"label":1},"constants":{"null":1},"javaDoc":"Sets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) c the color for the pixel at position (x y)","comments":"\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["BufferedImage"],"returnType":"void","methodCalls":{"setIcon":1,"getHeight":1,"setSize":1,"getWidth":1,"pack":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":22,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":5},"text":"private void setImage(BufferedImage image) {\n    this.image = image;\n    label.setIcon(new ImageIcon(image));\n    label.setText(\"\");\n    label.setSize(image.getWidth(), image.getHeight());\n    frame.pack();\n}\n","name":"setImage","className":"Picture","variables":{"image":4,"label":3,"frame":1},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"translate":1,"System.out.print":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"NameExpr":39,"StringLiteralExpr":4,"FieldAccessExpr":6,"MethodCallExpr":9},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    // Move the rectangle\n    box.translate(15, 25);\n    // Print information about the moved rectangle \n    System.out.print(\"x: \");\n    System.out.println(box.getX());\n    System.out.println(\"Expected: 20\");\n    System.out.print(\"y: \");\n    System.out.println(box.getY());\n    System.out.println(\"Expected: 35\");\n}\n","name":"main","className":"MoveTester","variables":{"box":4},"constants":{"\"x: \"":1,"25":1,"\"y: \"":1,"15":1,"5":1,"\"Expected: 20\"":1,"\"Expected: 35\"":1,"30":1,"20":1,"10":1},"javaDoc":"","comments":"Move the rectangle Print information about the moved rectangle ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":8,"translate":1,"System.out.println":10},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":2,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":8,"VariableDeclarationExpr":4,"NameExpr":104,"StringLiteralExpr":10,"FieldAccessExpr":18,"MethodCallExpr":19,"AssignExpr":1},"statements":{"ExpressionStmt":24},"text":"public static void main(String[] args) {\n    // Declare two object variables and copy the first into the second\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    Rectangle box2 = box;\n    // Both variables refer to the same object\n    System.out.print(\"box: \");\n    System.out.println(box);\n    System.out.print(\"box2: \");\n    System.out.println(box2);\n    System.out.println(\"Mutating box2\");\n    box2.translate(15, 25);\n    // Both variables refer to the mutated object\n    System.out.print(\"box: \");\n    System.out.println(box);\n    System.out.print(\"box2: \");\n    System.out.println(box2);\n    // Declare two number variables and copy the first into the second\n    int luckyNumber = 13;\n    int luckyNumber2 = luckyNumber;\n    System.out.print(\"luckyNumber: \");\n    System.out.println(luckyNumber);\n    System.out.print(\"luckyNumber2: \");\n    System.out.println(luckyNumber2);\n    System.out.println(\"Changing luckyNumber2\");\n    luckyNumber2 = 12;\n    // Only the second number changes.\n    System.out.print(\"luckyNumber: \");\n    System.out.println(luckyNumber);\n    System.out.print(\"luckyNumber2: \");\n    System.out.println(luckyNumber2);\n}\n","name":"main","className":"CopyDemo","variables":{"luckyNumber2":2,"luckyNumber":2,"box2":2,"box":2},"constants":{"12":1,"13":1,"25":1,"15":1,"\"luckyNumber2: \"":2,"\"luckyNumber: \"":2,"\"box: \"":2,"\"Mutating box2\"":1,"\"box2: \"":2,"5":1,"\"Changing luckyNumber2\"":1,"30":1,"20":1,"10":1},"javaDoc":"","comments":"Declare two object variables and copy the first into the second Both variables refer to the same object Both variables refer to the mutated object Declare two number variables and copy the first into the second Only the second number changes ","isEmpty":false,"hasInnerClass":false,"lineCount":29,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":2,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":8,"VariableDeclarationExpr":1,"NameExpr":28,"StringLiteralExpr":2,"FieldAccessExpr":5,"MethodCallExpr":5,"AssignExpr":1},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    // Constructs and prints a rectangle\n    System.out.println(new Rectangle(5, 10, 20, 30));\n    // Constructs a rectangle and saves it in a variable\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    System.out.print(\"box: \");\n    System.out.println(box);\n    // The constructor with no arguments\n    box = new Rectangle();\n    System.out.print(\"box: \");\n    System.out.println(box);\n}\n","name":"main","className":"ConstructorDemo","variables":{"box":2},"constants":{"\"box: \"":2,"5":2,"30":2,"20":2,"10":2},"javaDoc":"","comments":"Constructs and prints a rectangle Constructs a rectangle and saves it in a variable The constructor with no arguments ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":1,"parse":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"ArrayList<LineItem>":1,"LineItem":1,"ItemListParser":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) throws Exception {\n    ItemListParser parser = new ItemListParser();\n    ArrayList<LineItem> items = parser.parse(\"items.xml\");\n    for (LineItem anItem : items) {\n        System.out.println(anItem.format());\n    }\n}\n","name":"main","className":"ItemListParserDemo","variables":{"parser":2,"anItem":2,"items":2},"constants":{"\"items.xml\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Product","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   */\npublic Product(String aDescription, double aPrice) {\n    description = aDescription;\n    price = aPrice;\n}\n","name":"Product","className":"Product","variables":{"aDescription":1,"price":1,"description":1,"aPrice":1},"constants":{},"javaDoc":"Constructs a product from a description and a price aDescription the product description aPrice the product price","comments":"\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product description.\n      @return the description\n   */\npublic String getDescription() {\n    return description;\n}\n","name":"getDescription","className":"Product","variables":{"description":1},"constants":{},"javaDoc":"Gets the product description the description","comments":"\n      Gets the product description.\n      @return the description\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product price.\n      @return the unit price\n   */\npublic double getPrice() {\n    return price;\n}\n","name":"getPrice","className":"Product","variables":{"price":1},"constants":{},"javaDoc":"Gets the product price the unit price","comments":"\n      Gets the product price.\n      @return the unit price\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ItemListParser","methodCalls":{"newDocumentBuilder":1,"newXPath":1,"newInstance":2},"annotations":[],"exceptions":["ParserConfigurationException"],"concepts":[],"types":{"XPathFactory":1,"DocumentBuilderFactory":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":14,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a parser that can parse item lists.\n   */\npublic ItemListParser() throws ParserConfigurationException {\n    DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();\n    builder = dbfactory.newDocumentBuilder();\n    XPathFactory xpfactory = XPathFactory.newInstance();\n    path = xpfactory.newXPath();\n}\n","name":"ItemListParser","className":"ItemListParser","variables":{"xpfactory":2,"XPathFactory":1,"path":1,"DocumentBuilderFactory":1,"dbfactory":2,"builder":1},"constants":{},"javaDoc":"Constructs a parser that can parse item lists","comments":"\n      Constructs a parser that can parse item lists.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String"],"returnType":"ArrayList<LineItem>","methodCalls":{"parseInt":2,"parseDouble":1,"add":1,"parse":1,"evaluate":4},"annotations":[],"exceptions":["XPathExpressionException","IOException","SAXException"],"concepts":["PolyMorphism"],"types":{"ArrayList<LineItem>":1,"double":1,"ArrayList":1,"Product":1,"LineItem":1,"String":1,"Document":1,"File":1,"int":3},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":10,"BinaryExpr":7,"NameExpr":45,"StringLiteralExpr":7,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"/**\n      Parses an XML file containing an item list.\n      @param fileName the name of the file\n      @return an array list containing all items in the XML file\n   */\npublic ArrayList<LineItem> parse(String fileName) throws SAXException, IOException, XPathExpressionException {\n    File f = new File(fileName);\n    Document doc = builder.parse(f);\n    ArrayList<LineItem> items = new ArrayList<>();\n    int itemCount = Integer.parseInt(path.evaluate(\"count(/items/item)\", doc));\n    for (int i = 1; i <= itemCount; i++) {\n        String description = path.evaluate(\"/items/item[\" + i + \"]/product/description\", doc);\n        double price = Double.parseDouble(path.evaluate(\"/items/item[\" + i + \"]/product/price\", doc));\n        Product pr = new Product(description, price);\n        int quantity = Integer.parseInt(path.evaluate(\"/items/item[\" + i + \"]/quantity\", doc));\n        LineItem it = new LineItem(pr, quantity);\n        items.add(it);\n    }\n    return items;\n}\n","name":"parse","className":"ItemListParser","variables":{"fileName":1,"pr":2,"quantity":2,"f":1,"i":6,"description":2,"it":1,"Double":1,"itemCount":2,"Integer":2,"path":4,"price":2,"builder":1,"doc":1,"items":3},"constants":{"1":1,"\"]/product/price\"":1,"\"count(/items/item)\"":1,"\"]/product/description\"":1,"\"/items/item[\"":3,"\"]/quantity\"":1},"javaDoc":"Parses an XML file containing an item list fileName the name of the file an array list containing all items in the XML file","comments":"\n      Parses an XML file containing an item list.\n      @param fileName the name of the file\n      @return an array list containing all items in the XML file\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":["Product","int"],"returnType":"LineItem","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   */\npublic LineItem(Product aProduct, int aQuantity) {\n    theProduct = aProduct;\n    quantity = aQuantity;\n}\n","name":"LineItem","className":"LineItem","variables":{"quantity":1,"aProduct":1,"aQuantity":1,"theProduct":1},"constants":{},"javaDoc":"Constructs an item from the product and quantity aProduct the product aQuantity the item quantity","comments":"\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes the total cost of this line item.\n      @return the total price\n   */\npublic double getTotalPrice() {\n    return theProduct.getPrice() * quantity;\n}\n","name":"getTotalPrice","className":"LineItem","variables":{"quantity":1,"theProduct":1},"constants":{},"javaDoc":"Computes the total cost of this line item the total price","comments":"\n      Computes the total cost of this line item.\n      @return the total price\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1,"getTotalPrice":1,"getDescription":1,"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n      Formats this item.\n      @return a formatted string of this item\n   */\npublic String format() {\n    return String.format(\"%-30s%8.2f%5d%8.2f\", theProduct.getDescription(), theProduct.getPrice(), quantity, getTotalPrice());\n}\n","name":"format","className":"LineItem","variables":{"String":1,"theProduct":2},"constants":{"\"%-30s%8.2f%5d%8.2f\"":1},"javaDoc":"Formats this item a formatted string of this item","comments":"\n      Formats this item.\n      @return a formatted string of this item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","double"],"returnType":"Product","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   */\npublic Product(String aDescription, double aPrice) {\n    description = aDescription;\n    price = aPrice;\n}\n","name":"Product","className":"Product","variables":{"aDescription":1,"price":1,"description":1,"aPrice":1},"constants":{},"javaDoc":"Constructs a product from a description and a price aDescription the product description aPrice the product price","comments":"\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product description.\n      @return the description\n   */\npublic String getDescription() {\n    return description;\n}\n","name":"getDescription","className":"Product","variables":{"description":1},"constants":{},"javaDoc":"Gets the product description the description","comments":"\n      Gets the product description.\n      @return the description\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product price.\n      @return the unit price\n   */\npublic double getPrice() {\n    return price;\n}\n","name":"getPrice","className":"Product","variables":{"price":1},"constants":{},"javaDoc":"Gets the product price the unit price","comments":"\n      Gets the product price.\n      @return the unit price\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"writeToString":1,"build":1,"getImplementation":1,"createLSSerializer":1,"getFeature":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","PolyMorphism"],"types":{"ArrayList<LineItem>":1,"ItemListBuilder":1,"DOMImplementationLS":1,"ArrayList":1,"DOMImplementation":1,"LSSerializer":1,"String":1,"Document":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"DoubleLiteralExpr":2,"NameExpr":29,"StringLiteralExpr":4,"CastExpr":1,"FieldAccessExpr":1,"MethodCallExpr":8},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) throws Exception {\n    ArrayList<LineItem> items = new ArrayList<>();\n    items.add(new LineItem(new Product(\"Toaster\", 29.95), 3));\n    items.add(new LineItem(new Product(\"Hair dryer\", 24.95), 1));\n    ItemListBuilder builder = new ItemListBuilder();\n    Document doc = builder.build(items);\n    DOMImplementation impl = doc.getImplementation();\n    DOMImplementationLS implLS = (DOMImplementationLS) impl.getFeature(\"LS\", \"3.0\");\n    LSSerializer ser = implLS.createLSSerializer();\n    String out = ser.writeToString(doc);\n    System.out.println(out);\n}\n","name":"main","className":"ItemListBuilderDemo","variables":{"impl":2,"ser":2,"implLS":2,"builder":2,"doc":2,"items":3,"out":1},"constants":{"24.95":1,"1":1,"3":1,"\"Hair dryer\"":1,"29.95":1,"\"3.0\"":1,"\"LS\"":1,"\"Toaster\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["Product","int"],"returnType":"LineItem","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   */\npublic LineItem(Product aProduct, int aQuantity) {\n    theProduct = aProduct;\n    quantity = aQuantity;\n}\n","name":"LineItem","className":"LineItem","variables":{"quantity":1,"aProduct":1,"aQuantity":1,"theProduct":1},"constants":{},"javaDoc":"Constructs an item from the product and quantity aProduct the product aQuantity the item quantity","comments":"\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes the total cost of this line item.\n      @return the total price\n   */\npublic double getTotalPrice() {\n    return theProduct.getPrice() * quantity;\n}\n","name":"getTotalPrice","className":"LineItem","variables":{"quantity":1,"theProduct":1},"constants":{},"javaDoc":"Computes the total cost of this line item the total price","comments":"\n      Computes the total cost of this line item.\n      @return the total price\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Product","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product that this item describes.\n      @return the product\n   */\npublic Product getProduct() {\n    return theProduct;\n}\n","name":"getProduct","className":"LineItem","variables":{"theProduct":1},"constants":{},"javaDoc":"Gets the product that this item describes the product","comments":"\n      Gets the product that this item describes.\n      @return the product\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the quantity of the product that this item describes.\n      @return the quantity\n   */\npublic int getQuantity() {\n    return quantity;\n}\n","name":"getQuantity","className":"LineItem","variables":{"quantity":1},"constants":{},"javaDoc":"Gets the quantity of the product that this item describes the quantity","comments":"\n      Gets the quantity of the product that this item describes.\n      @return the quantity\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1,"getTotalPrice":1,"getDescription":1,"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n      Formats this item.\n      @return a formatted string of this item\n   */\npublic String format() {\n    return String.format(\"%-30s%8.2f%5d%8.2f\", theProduct.getDescription(), theProduct.getPrice(), quantity, getTotalPrice());\n}\n","name":"format","className":"LineItem","variables":{"String":1,"theProduct":2},"constants":{"\"%-30s%8.2f%5d%8.2f\"":1},"javaDoc":"Formats this item a formatted string of this item","comments":"\n      Formats this item.\n      @return a formatted string of this item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ItemListBuilder","methodCalls":{"newDocumentBuilder":1,"newInstance":1},"annotations":[],"exceptions":["ParserConfigurationException"],"concepts":[],"types":{"DocumentBuilderFactory":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":7,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an item list builder.\n   */\npublic ItemListBuilder() throws ParserConfigurationException {\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    builder = factory.newDocumentBuilder();\n}\n","name":"ItemListBuilder","className":"ItemListBuilder","variables":{"factory":2,"DocumentBuilderFactory":1,"builder":1},"constants":{},"javaDoc":"Constructs an item list builder","comments":"\n      Constructs an item list builder.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["ArrayList<LineItem>"],"returnType":"Document","methodCalls":{"appendChild":1,"createItems":1,"newDocument":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":11,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Builds a DOM document for an array list of items.\n      @param items the items\n      @return a DOM document describing the items\n   */\npublic Document build(ArrayList<LineItem> items) {\n    doc = builder.newDocument();\n    doc.appendChild(createItems(items));\n    return doc;\n}\n","name":"build","className":"ItemListBuilder","variables":{"builder":1,"doc":3},"constants":{},"javaDoc":"Builds a DOM document for an array list of items items the items a DOM document describing the items","comments":"\n      Builds a DOM document for an array list of items.\n      @param items the items\n      @return a DOM document describing the items\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ArrayList<LineItem>"],"returnType":"Element","methodCalls":{"appendChild":1,"createItem":1,"createElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Element":1,"LineItem":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Builds a DOM element for an array list of items.\n      @param items the items\n      @return a DOM element describing the items\n   */\nprivate Element createItems(ArrayList<LineItem> items) {\n    Element e = doc.createElement(\"items\");\n    for (LineItem anItem : items) {\n        e.appendChild(createItem(anItem));\n    }\n    return e;\n}\n","name":"createItems","className":"ItemListBuilder","variables":{"e":3,"anItem":1,"doc":1,"items":1},"constants":{"\"items\"":1},"javaDoc":"Builds a DOM element for an array list of items items the items a DOM element describing the items","comments":"\n      Builds a DOM element for an array list of items.\n      @param items the items\n      @return a DOM element describing the items\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":2}
{"paramTypes":["LineItem"],"returnType":"Element","methodCalls":{"appendChild":2,"getProduct":1,"createTextElement":1,"getQuantity":1,"createProduct":1,"createElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Element":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":3,"MethodCallExpr":7},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Builds a DOM element for an item.\n      @param anItem the item\n      @return a DOM element describing the item\n   */\nprivate Element createItem(LineItem anItem) {\n    Element e = doc.createElement(\"item\");\n    e.appendChild(createProduct(anItem.getProduct()));\n    e.appendChild(createTextElement(\"quantity\", \"\" + anItem.getQuantity()));\n    return e;\n}\n","name":"createItem","className":"ItemListBuilder","variables":{"e":4,"anItem":2,"doc":1},"constants":{"\"quantity\"":1,"\"\"":1,"\"item\"":1},"javaDoc":"Builds a DOM element for an item anItem the item a DOM element describing the item","comments":"\n      Builds a DOM element for an item.\n      @param anItem the item\n      @return a DOM element describing the item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":["Product"],"returnType":"Element","methodCalls":{"appendChild":2,"createTextElement":2,"createElement":1,"getDescription":1,"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Element":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":4,"MethodCallExpr":7},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Builds a DOM element for a product.\n      @param p the product\n      @return a DOM element describing the product\n   */\nprivate Element createProduct(Product p) {\n    Element e = doc.createElement(\"product\");\n    e.appendChild(createTextElement(\"description\", p.getDescription()));\n    e.appendChild(createTextElement(\"price\", \"\" + p.getPrice()));\n    return e;\n}\n","name":"createProduct","className":"ItemListBuilder","variables":{"p":2,"e":4,"doc":1},"constants":{"\"\"":1,"\"price\"":1,"\"product\"":1,"\"description\"":1},"javaDoc":"Builds a DOM element for a product p the product a DOM element describing the product","comments":"\n      Builds a DOM element for a product.\n      @param p the product\n      @return a DOM element describing the product\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":["String","String"],"returnType":"Element","methodCalls":{"appendChild":1,"createTextNode":1,"createElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Element":1,"Text":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":13,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"private Element createTextElement(String name, String text) {\n    Text t = doc.createTextNode(text);\n    Element e = doc.createElement(name);\n    e.appendChild(t);\n    return e;\n}\n","name":"createTextElement","className":"ItemListBuilder","variables":{"t":1,"e":3,"doc":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":1,"comparing":3,"sort":2,"parse":1,"toList":1,"sorted":1,"thenComparing":1,"get":1,"toString":2,"lines":1,"collect":1,"map":1,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"List<Country>":1,"String[]":1,"Stream<String>":1,"Comparator<String>":1},"expressions":{"VariableDeclarationExpr":4,"LambdaExpr":2,"NameExpr":69,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodReferenceExpr":3,"TypeExpr":3,"MethodCallExpr":20},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) throws IOException {\n    Comparator<String> comp = Comparator.comparing( t -> t.length());\n    String[] words = \"how much wood could a wood chuck chuck\".split(\" \");\n    Arrays.sort(words, comp);\n    System.out.println(Arrays.toString(words));\n    Arrays.sort(words, Comparator.comparing(String::length));\n    System.out.println(Arrays.toString(words));\n    try (Stream<String> lines = Files.lines(Paths.get(\"../population.txt\"))) {\n        List<Country> result = lines.map( line -> Country.parse(line)).sorted(Comparator.comparing(Country::getContinent).thenComparing(Country::getName)).collect(Collectors.toList());\n        System.out.println(result);\n    }\n}\n","name":"main","className":"ComparatorDemo","variables":{"result":1,"comp":1,"Collectors":1,"t":2,"line":1,"words":1,"Country":1,"Paths":1,"Arrays":4,"lines":2,"Files":1,"Comparator":3},"constants":{"\"../population.txt\"":1,"\" \"":1,"\"how much wood could a wood chuck chuck\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["String"],"returnType":"Country","methodCalls":{"parseInt":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Country":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":2,"AssignExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":5},"text":"public static Country parse(String line) {\n    String[] fields = line.split(\"\\\\|\");\n    Country country = new Country();\n    country.name = fields[0];\n    country.continent = fields[1];\n    country.population = Integer.parseInt(fields[2]);\n    return country;\n}\n","name":"parse","className":"Country","variables":{"Integer":1,"country":2,"line":1,"fields":4},"constants":{"0":1,"1":1,"\"\\\\|\"":1,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getContinent() {\n    return continent;\n}\n","name":"getContinent","className":"Country","variables":{"continent":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getPopulation() {\n    return population;\n}\n","name":"getPopulation","className":"Country","variables":{"population":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":3,"StringLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return name + \"|\" + continent + \"|\" + population;\n}\n","name":"toString","className":"Country","variables":{"continent":1,"name":1,"population":1},"constants":{"\"|\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"stream":1,"of":3,"get":1,"show":5,"lines":1},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Stream<Integer>":1,"ArrayList":1,"Stream<String>":2,"Integer[]":1,"List<String>":1},"expressions":{"IntegerLiteralExpr":12,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayInitializerExpr":1,"NameExpr":42,"StringLiteralExpr":13,"MethodCallExpr":13,"AssignExpr":2},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] args) throws IOException {\n    Stream<String> words = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\");\n    show(\"A stream of individually specified words\", words);\n    Stream<Integer> digits = Stream.of(3, 1, 4, 1, 5, 9);\n    show(\"A stream of individually specified digits\", digits);\n    Integer[] digitArray = { 3, 1, 4, 1, 5, 9 };\n    digits = Stream.of(digitArray);\n    show(\"A stream of digits from an array\", digits);\n    List<String> wordList = new ArrayList<>();\n    // Populate wordList\n    wordList.add(\"Hello\");\n    wordList.add(\"World\");\n    words = wordList.stream();\n    show(\"A stream of words from a list\", words);\n    try (Stream<String> lines = Files.lines(Paths.get(\"../countries.txt\"))) {\n        show(\"A stream of lines from a file\", lines);\n    }\n}\n","name":"main","className":"Streams","variables":{"wordList":4,"words":2,"digitArray":1,"Stream":3,"digits":2,"Paths":1,"lines":1,"Files":1},"constants":{"\"Hello\"":1,"\"a\"":1,"\"little\"":1,"\"../countries.txt\"":1,"\"A stream of lines from a file\"":1,"\"World\"":1,"\"Mary\"":1,"\"A stream of words from a list\"":1,"1":4,"\"lamb\"":1,"3":2,"4":2,"5":2,"\"A stream of individually specified digits\"":1,"\"had\"":1,"9":2,"\"A stream of individually specified words\"":1,"\"A stream of digits from an array\"":1},"javaDoc":"","comments":"Populate wordList ","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"List<T>":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":53,"StringLiteralExpr":3,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Streams","variables":{"Collectors":1,"stream":1,"values":4,"caption":1,"i":4,"Math":1,"SHOW_LIMIT":3},"constants":{"0":2,"1":1,"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":2,"sorted":2,"of":4,"length":6,"show":4,"distinct":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Stream<String>":3,"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"LambdaExpr":4,"BinaryExpr":4,"NameExpr":69,"StringLiteralExpr":12,"MethodCallExpr":24,"AssignExpr":3},"statements":{"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).filter( w -> w.length() > 4);\n    show(\"Filtering with a simple lambda expression\", words);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).filter((String w) -> w.length() > 4);\n    show(\"Filtering with a lambda expression with parameter type\", words);\n    Stream<String> distinctWords = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).distinct();\n    Stream<String> sortedWords = distinctWords.sorted(( s,  t) -> s.length() - t.length());\n    show(\"Sorting with a lambda expression with two parameters\", sortedWords);\n    distinctWords = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).distinct();\n    sortedWords = distinctWords.sorted(( v,  w) -> {\n        int first = v.length();\n        int second = w.length();\n        return first - second;\n    });\n    show(\"Sorting with a complex lambda expression\", sortedWords);\n}\n","name":"main","className":"Streams","variables":{"sortedWords":2,"s":2,"t":2,"v":2,"w":6,"distinctWords":4,"words":2,"Stream":4,"first":2,"second":2},"constants":{"\" \"":4,"4":2,"\"Filtering with a simple lambda expression\"":1,"\"Filtering with a lambda expression with parameter type\"":1,"\"how much wood could a wood chuck chuck\"":4,"\"Sorting with a lambda expression with two parameters\"":1,"\"Sorting with a complex lambda expression\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"List<T>":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":53,"StringLiteralExpr":3,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Streams","variables":{"Collectors":1,"stream":1,"values":4,"caption":1,"i":4,"Math":1,"SHOW_LIMIT":3},"constants":{"0":2,"1":1,"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"random":1,"show":4,"generate":2,"isPrime":1,"iterate":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Stream<Integer>":4},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":4,"LambdaExpr":5,"BinaryExpr":4,"NameExpr":36,"StringLiteralExpr":4,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":11,"AssignExpr":1},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    Stream<Integer> ones = Stream.generate(() -> 1);\n    show(\"An infinite stream of ones\", ones);\n    Stream<Integer> dieTosses = Stream.generate(() -> 1 + (int) (6 * Math.random()));\n    show(\"An infinite stream of random numbers\", dieTosses);\n    Stream<Integer> integers = Stream.iterate(0,  n -> n + 1);\n    show(\"An infinite stream of integers\", integers);\n    integers = Stream.iterate(0,  n -> n + 1);\n    Stream<Integer> primes = integers.filter( n -> isPrime(n));\n    show(\"An infinite stream of primes\", primes);\n}\n","name":"main","className":"Infinite","variables":{"primes":1,"ones":1,"Stream":4,"dieTosses":1,"Math":1,"n":5,"integers":3},"constants":{"0":2,"1":4,"\"An infinite stream of ones\"":1,"\"An infinite stream of primes\"":1,"6":1,"\"An infinite stream of integers\"":1,"\"An infinite stream of random numbers\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["int"],"returnType":"boolean","methodCalls":{"filter":1,"count":1,"limit":1,"iterate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"BinaryExpr":4,"LambdaExpr":2,"NameExpr":13,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public static boolean isPrime(int number) {\n    return Stream.iterate(1,  n -> n + 1).limit(number).filter( n -> number % n == 0).count() == 2;\n}\n","name":"isPrime","className":"Infinite","variables":{"number":1,"Stream":1,"n":4},"constants":{"0":1,"1":2,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"List<T>":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":53,"StringLiteralExpr":3,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Infinite","variables":{"Collectors":1,"stream":1,"values":4,"caption":1,"i":4,"Math":1,"SHOW_LIMIT":3},"constants":{"0":2,"1":1,"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"of":1,"ifPresent":1,"get":1,"length":1,"isPresent":1,"findFirst":1,"orElse":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Optional<String>":1,"Stream<String>":1,"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"LambdaExpr":2,"BinaryExpr":4,"NameExpr":45,"StringLiteralExpr":13,"FieldAccessExpr":4,"MethodCallExpr":12},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"Zimbabwe\", \"Namibia\", \"Uganda\", \"Botswana\", \"Madagascar\", \"Mozambique\", // \"Ivory Coast\",\n    \"Swaziland\", \"Togo\");\n    Optional<String> optResult = words.filter( w -> w.length() > 10).findFirst();\n    // Using orElse\n    String first = optResult.orElse(\"(None)\");\n    System.out.println(\"The first country with more than ten characters: \" + first);\n    // Using ifPresent\n    optResult.ifPresent( v -> System.out.println(\"The first country with more than ten characters: \" + v));\n    // Using isPresent/get\n    if (optResult.isPresent()) {\n        System.out.println(\"The first country with more than ten characters: \" + optResult.get());\n    } else {\n        System.out.println(\"None of these countries has more than ten characters\");\n    }\n}\n","name":"main","className":"OptionalDemo","variables":{"optResult":5,"v":2,"w":2,"words":2,"Stream":1,"first":2},"constants":{"\"None of these countries has more than ten characters\"":1,"\"Uganda\"":1,"\"Botswana\"":1,"\"Togo\"":1,"\"Madagascar\"":1,"\"The first country with more than ten characters: \"":3,"\"Namibia\"":1,"\"Mozambique\"":1,"\"(None)\"":1,"\"Zimbabwe\"":1,"10":1},"javaDoc":"","comments":"\"Ivory Coast\" Using orElse Using ifPresent Using isPresent/get ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":4,"toSet":1,"joining":1,"contains":4,"of":4,"toArray":1,"toString":1,"toList":1,"collect":3,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Set<String>":1,"Stream<String>":1,"String[]":1,"String":1,"List<String>":1},"expressions":{"VariableDeclarationExpr":5,"LambdaExpr":4,"BinaryExpr":4,"NameExpr":83,"StringLiteralExpr":29,"FieldAccessExpr":4,"MethodReferenceExpr":1,"TypeExpr":1,"MethodCallExpr":24,"AssignExpr":3},"statements":{"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    Stream<String> stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    String[] result1 = stream.toArray(String[]::new);\n    System.out.println(\"Converting to an array: \" + Arrays.toString(result1));\n    stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    List<String> result2 = stream.collect(Collectors.toList());\n    System.out.println(\"Collecting to a list: \" + result2);\n    stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    Set<String> result3 = stream.collect(Collectors.toSet());\n    System.out.println(\"Collecting to a set: \" + result3);\n    stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    String result4 = stream.collect(Collectors.joining(\", \"));\n    System.out.println(\"Joining with commas: \" + result4);\n}\n","name":"main","className":"Streams","variables":{"Collectors":3,"stream":8,"w":8,"Stream":4,"Arrays":1,"result4":2,"result3":2,"result2":2,"result1":1},"constants":{"\"Collecting to a list: \"":1,"\"lamb\"":4,"\"a\"":8,"\"little\"":4,"\"had\"":4,"\"Converting to an array: \"":1,"\"Collecting to a set: \"":1,"\"Mary\"":4,"\", \"":1,"\"Joining with commas: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":12,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"filter":2,"contains":1,"nextLine":1,"hasNextLine":1,"length":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"ArrayList":1,"List<String>":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"LambdaExpr":1,"BinaryExpr":3,"StringLiteralExpr":4,"NameExpr":33,"FieldAccessExpr":2,"MethodCallExpr":9,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../countries.txt\"));\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNextLine()) {\n        wordList.add(in.nextLine());\n    }\n    List<String> filtered = filter(wordList,  w -> w.length() > 10);\n    System.out.println(\"Long country names: \" + filtered);\n    filtered = filter(wordList, contains(\" and \"));\n    System.out.println(\"Countries with and in their name: \" + filtered);\n}\n","name":"main","className":"HigherOrderFunctions","variables":{"filtered":4,"in":3,"wordList":2,"w":2},"constants":{"\" and \"":1,"\"../countries.txt\"":1,"\"Countries with and in their name: \"":1,"\"Long country names: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["List<T>","Predicate<T>"],"returnType":"List<T>","methodCalls":{"add":1,"test":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"T":1,"ArrayList":1,"List<T>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":10,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static <T> List<T> filter(List<T> values, Predicate<T> p) {\n    List<T> result = new ArrayList<>();\n    for (T value : values) {\n        if (p.test(value)) {\n            result.add(value);\n        }\n    }\n    return result;\n}\n","name":"filter","className":"HigherOrderFunctions","variables":{"result":3,"p":1,"values":1,"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String"],"returnType":"Predicate<String>","methodCalls":{"indexOf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"LambdaExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public static Predicate<String> contains(String target) {\n    return  s -> s.indexOf(target) >= 0;\n}\n","name":"contains","className":"HigherOrderFunctions","variables":{"s":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"joining":1,"max":1,"count":1,"range":2,"sum":1,"findFirst":2,"orElse":4,"mapToObj":1,"filter":3,"min":1,"of":6,"toArray":1,"toString":1,"map":1,"collect":1,"System.out.println":9,"codePoints":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double[]":1,"double":4,"int[]":1,"String":2,"int":2,"long":1,"OptionalDouble":1},"expressions":{"IntegerLiteralExpr":15,"VariableDeclarationExpr":12,"ArrayAccessExpr":1,"LambdaExpr":5,"BinaryExpr":11,"NameExpr":148,"StringLiteralExpr":9,"CharLiteralExpr":1,"UnaryExpr":1,"AssignExpr":1,"ArrayInitializerExpr":1,"DoubleLiteralExpr":2,"FieldAccessExpr":12,"MethodCallExpr":38},"statements":{"ExpressionStmt":27},"text":"public static void main(String[] args) {\n    int n = 10;\n    int[] squares = IntStream.range(0, n).map( i -> i * i).toArray();\n    System.out.println(Arrays.toString(squares));\n    double[] values = { 32, 54, 67.5, 29, 35, 80, 115, 44.5, 100, 65 };\n    double total = DoubleStream.of(values).sum();\n    double average = DoubleStream.of(values).average().orElse(0);\n    double largest = DoubleStream.of(values).max().orElse(Double.MIN_VALUE);\n    double smallest = DoubleStream.of(values).min().orElse(Double.MAX_VALUE);\n    System.out.println(\"total: \" + total);\n    System.out.println(\"average: \" + average);\n    System.out.println(\"largest: \" + largest);\n    System.out.println(\"smallest: \" + smallest);\n    String str = \"How much wood could a woodchuck chuck?\";\n    long spaces = str.codePoints().filter( ch -> ch == ' ').count();\n    System.out.println(\"spaces: \" + spaces);\n    String result = DoubleStream.of(values).mapToObj( v -> \"\" + v).collect(Collectors.joining(\" | \"));\n    System.out.println(result);\n    OptionalDouble result2 = DoubleStream.of(values).filter( v -> v > 100).findFirst();\n    System.out.println(result2);\n    n = values.length;\n    int pos = IntStream.range(0, n).filter( i -> values[i] == 100).findFirst().orElse(-1);\n    System.out.println(\"pos: \" + pos);\n}\n","name":"main","className":"CommonAlgorithmsRevisited","variables":{"average":2,"largest":2,"Collectors":1,"ch":2,"smallest":2,"values":2,"squares":1,"i":5,"n":2,"str":2,"result":1,"total":2,"pos":2,"v":4,"spaces":2,"DoubleStream":6,"Arrays":1,"IntStream":2,"result2":1},"constants":{"\"\"":1,"35":1,"29":1,"\"How much wood could a woodchuck chuck?\"":1,"\"pos: \"":1,"' '":1,"\" | \"":1,"0":3,"\"smallest: \"":1,"67.5":1,"100":3,"1":1,"115":1,"\"largest: \"":1,"\"total: \"":1,"80":1,"\"average: \"":1,"\"spaces: \"":1,"10":1,"32":1,"54":1,"44.5":1,"65":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":22,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getPopulation":6,"average":1,"groupingBy":2,"compare":1,"distinct":2,"parse":1,"toList":5,"orElse":1,"filter":3,"sorted":1,"stream":8,"findAny":1,"mapToInt":1,"get":1,"equals":1,"ifPresent":1,"limit":1,"lines":1,"map":3,"collect":7,"averagingInt":1,"getContinent":5,"System.out.println":8},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Stream<Country>":2,"Map<String, Double>":1,"Optional<Country>":1,"double":1,"Map<String, List<Country>>":1,"List<Country>":2,"Stream<String>":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":11,"LambdaExpr":12,"BinaryExpr":10,"NameExpr":191,"StringLiteralExpr":10,"FieldAccessExpr":8,"MethodCallExpr":62},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":30},"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../population.txt\"))) {\n        Stream<Country> countries = lines.map( line -> Country.parse(line));\n        List<Country> countryList = countries.collect(Collectors.toList());\n        Stream<Country> africanCountries = countryList.stream().filter( c -> c.getContinent().equals(\"Africa\"));\n        System.out.println(\"African countries: \" + africanCountries.collect(Collectors.toList()));\n        Stream<String> continents = countryList.stream().map( c -> c.getContinent()).distinct();\n        System.out.println(\"Continents: \" + continents.collect(Collectors.toList()));\n        Stream<String> continentsWithPopulousCountries = countryList.stream().filter( c -> c.getPopulation() >= 100_000_000).map( c -> c.getContinent()).distinct();\n        System.out.println(\"Continents with populous countries: \" + continentsWithPopulousCountries.collect(Collectors.toList()));\n        Optional<Country> aPopulousCountry = countryList.stream().filter( country -> country.getPopulation() > 100_000_000).findAny();\n        aPopulousCountry.ifPresent( c -> System.out.println(\"A populous country: \" + c));\n        List<Country> mostPopulous = countryList.stream().sorted(( c,  d) -> Double.compare(d.getPopulation(), c.getPopulation())).limit(10).collect(Collectors.toList());\n        System.out.println(\"Ten most populous countries: \" + mostPopulous);\n        double average = countryList.stream().mapToInt( country -> country.getPopulation()).average().orElse(0);\n        System.out.println(\"Average population of all countries: \" + average);\n        Map<String, List<Country>> countriesByContinent = countryList.stream().collect(Collectors.groupingBy( c -> c.getContinent()));\n        System.out.println(\"Countries by continent: \" + countriesByContinent);\n        Map<String, Double> averagePopulationByContinent = countryList.stream().collect(Collectors.groupingBy( c -> c.getContinent(), Collectors.averagingInt( c -> c.getPopulation())));\n        System.out.println(\"Average population by continent: \" + averagePopulationByContinent);\n    }\n}\n","name":"main","className":"Countries","variables":{"Collectors":8,"country":4,"average":2,"c":18,"d":2,"aPopulousCountry":2,"line":1,"mostPopulous":2,"averagePopulationByContinent":2,"countries":2,"countryList":9,"africanCountries":2,"Double":1,"continents":2,"continentsWithPopulousCountries":2,"Country":1,"Paths":1,"lines":2,"Files":1,"countriesByContinent":2},"constants":{"\"../population.txt\"":1,"100_000_000":2,"\"Average population by continent: \"":1,"\"Africa\"":1,"\"Continents with populous countries: \"":1,"\"Average population of all countries: \"":1,"\"African countries: \"":1,"0":1,"\"Countries by continent: \"":1,"\"Ten most populous countries: \"":1,"\"A populous country: \"":1,"\"Continents: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"Country","methodCalls":{"parseInt":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Country":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":2,"AssignExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":5},"text":"public static Country parse(String line) {\n    String[] fields = line.split(\"\\\\|\");\n    Country country = new Country();\n    country.name = fields[0];\n    country.continent = fields[1];\n    country.population = Integer.parseInt(fields[2]);\n    return country;\n}\n","name":"parse","className":"Country","variables":{"Integer":1,"country":2,"line":1,"fields":4},"constants":{"0":1,"1":1,"\"\\\\|\"":1,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getContinent() {\n    return continent;\n}\n","name":"getContinent","className":"Country","variables":{"continent":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getPopulation() {\n    return population;\n}\n","name":"getPopulation","className":"Country","variables":{"population":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return name;\n}\n","name":"toString","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"next":1,"filter":1,"size":1,"stream":2,"parallel":1,"forEach":1,"count":1,"length":2,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"ArrayList":2,"long":1,"List<String>":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"LambdaExpr":2,"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":47,"FieldAccessExpr":2,"MethodCallExpr":15},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":10},"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../words.txt\"));\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNext()) {\n        wordList.add(in.next());\n    }\n    long count = wordList.stream().filter( w -> w.length() > 10).count();\n    System.out.println(\"count: \" + count);\n    List<String> longWords = new ArrayList<>();\n    // The following code will probably throw an exception\n    wordList.stream().parallel().forEach( w -> {\n        if (w.length() > 10) {\n            longWords.add(w);\n        }\n    });\n    // If the program made it until here, the size will\n    // probably be wrong\n    System.out.println(\"longWords.size(): \" + longWords.size());\n}\n","name":"main","className":"Horror","variables":{"in":3,"wordList":4,"w":4,"count":2,"longWords":3},"constants":{"\"count: \"":1,"\"../words.txt\"":1,"10":2,"\"longWords.size(): \"":1},"javaDoc":"","comments":"If the program made it until here the size will The following code will probably throw an exception probably be wrong ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"max":1,"count":1,"length":1,"comparing":2,"toList":2,"orElse":2,"filter":11,"min":1,"get":5,"endsWith":5,"limit":1,"hasFiveVowels":5,"lines":5,"collect":2,"System.out.println":5},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Stream<String>":5,"String":2,"long":1,"List<String>":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":10,"LambdaExpr":11,"BinaryExpr":6,"NameExpr":148,"StringLiteralExpr":17,"FieldAccessExpr":5,"MethodReferenceExpr":2,"TypeExpr":2,"UnaryExpr":5,"MethodCallExpr":49},"statements":{"TryStmt":5,"BlockStmt":5,"ExpressionStmt":21},"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        long count = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).count();\n        System.out.println(\"Number of words with all five vowels: \" + count);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        List<String> examples = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).limit(20).collect(Collectors.toList());\n        System.out.println(\"20 words with all five vowels: \" + examples);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        String shortest = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).min(Comparator.comparing(String::length)).orElse(\"\");\n        System.out.println(\"Shortest: \" + shortest);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        List<String> allShortest = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).filter( w -> w.length() == 7).collect(Collectors.toList());\n        System.out.println(\"All of that length: \" + allShortest);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        String longest = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).max(Comparator.comparing(String::length)).orElse(\"\");\n        System.out.println(\"Longest: \" + longest);\n    }\n}\n","name":"main","className":"Words","variables":{"Collectors":2,"longest":2,"examples":2,"w":17,"count":2,"allShortest":2,"Paths":5,"lines":10,"Files":5,"shortest":2,"Comparator":2},"constants":{"\"\"":2,"\"Number of words with all five vowels: \"":1,"\"'s\"":5,"\"All of that length: \"":1,"\"Longest: \"":1,"7":1,"\"20 words with all five vowels: \"":1,"\"Shortest: \"":1,"\"../words.txt\"":5,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"filter":1,"toLowerCase":1,"count":1,"distinct":1,"codePoints":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":10,"LambdaExpr":1,"NameExpr":16,"CharLiteralExpr":5,"MethodCallExpr":5},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public static boolean hasFiveVowels(String word) {\n    return word.toLowerCase().codePoints().filter( c -> c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').distinct().count() == 5;\n}\n","name":"hasFiveVowels","className":"Words","variables":{"c":6,"word":1},"constants":{"'i'":1,"5":1,"'e'":1,"'u'":1,"'a'":1,"'o'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"List<Movie>","methodCalls":{"add":1,"parseInt":1,"nextLine":5,"hasNextLine":1,"getList":3,"getString":2},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"List<Movie>":1,"ArrayList":1,"String":5},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":7,"NameExpr":41,"MethodCallExpr":13},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":7},"text":"public static List<Movie> readMovies(String filename) throws IOException {\n    List<Movie> movies = new ArrayList<>();\n    try (Scanner in = new Scanner(new File(filename))) {\n        while (in.hasNextLine()) {\n            String nameLine = in.nextLine();\n            String yearLine = in.nextLine();\n            String directorsLine = in.nextLine();\n            String producersLine = in.nextLine();\n            String actorsLine = in.nextLine();\n            movies.add(new Movie(getString(nameLine), Integer.parseInt(getString(yearLine)), getList(directorsLine), getList(producersLine), getList(actorsLine)));\n        }\n    }\n    return movies;\n}\n","name":"readMovies","className":"Movies","variables":{"movies":3,"Integer":1,"filename":1,"in":7,"yearLine":1,"actorsLine":1,"directorsLine":1,"producersLine":1,"nameLine":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"trim":1,"indexOf":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"private static String getString(String line) {\n    int colon = line.indexOf(\":\");\n    return line.substring(colon + 1).trim();\n}\n","name":"getString","className":"Movies","variables":{"line":2,"colon":2},"constants":{"1":1,"\":\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":10}
{"paramTypes":["String"],"returnType":"List<String>","methodCalls":{"split":1,"of":1,"getString":1,"toList":1,"collect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":13,"StringLiteralExpr":1,"MethodCallExpr":5},"statements":{"ReturnStmt":1},"text":"private static List<String> getList(String line) {\n    return Stream.of(getString(line).split(\", \")).collect(Collectors.toList());\n/* Alternative without streams:\n      ArrayList<String> result = new ArrayList<>();\n      for (String s : getString(line).split(\", \"))\n      {\n         result.add(s);\n      }\n      return result;\n      */\n}\n","name":"getList","className":"Movies","variables":{"Collectors":1,"Stream":1},"constants":{"\", \"":1},"javaDoc":"","comments":"Alternative without streams: ArrayList<String> result = new ArrayList<>(); for (String s : getString(line) split(\" \")) { result add(s); } return result; ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"groupingBy":2,"toList":2,"substring":1,"remove":1,"getActors":4,"getTitle":4,"readMovies":1,"stream":9,"ifPresent":1,"get":3,"map":3,"System.out.println":10,"counting":1,"getKey":1,"intersect":1,"max":3,"entrySet":1,"count":3,"comparing":1,"orElse":1,"filter":5,"getValue":1,"commonActorAndDirector":1,"size":8,"mapToInt":1,"getDirectors":3,"collect":4,"startsWith":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"List<Movie>":1,"Map<String, Long>":1,"Map<String, List<Movie>>":1,"String":1,"long":1,"int":1,"List<String>":2},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":8,"LambdaExpr":14,"BinaryExpr":14,"NameExpr":232,"StringLiteralExpr":14,"FieldAccessExpr":10,"MethodCallExpr":78,"AssignExpr":1},"statements":{"ExpressionStmt":34},"text":"public static void main(String[] args) throws IOException {\n    List<Movie> movieList = readMovies(\"movies.txt\");\n    List<String> result1 = movieList.stream().map( m -> m.getTitle()).filter( t -> t.startsWith(\"X\")).collect(Collectors.toList());\n    System.out.println(\"Movies that start with X: \" + result1);\n    long count = movieList.stream().map( m -> intersect(m.getDirectors(), m.getActors())).filter( l -> l.size() > 0).count();\n    System.out.println(\"Movies in which directors are actors: \" + count);\n    count = movieList.stream().filter( m -> commonActorAndDirector(m)).count();\n    System.out.println(\"Movies in which directors are actors: \" + count);\n    int result2 = movieList.stream().mapToInt( m -> m.getActors().size()).max().orElse(0);\n    System.out.println(\"The most actors in a movie: \" + result2);\n    movieList.stream().max(( a,  b) -> a.getActors().size() - b.getActors().size()).ifPresent( m -> System.out.println(\"Movie with most actors: \" + m));\n    /* Alternative: \n      movieList.stream()\n         .max(Comparator.comparing(m -> m.getActors().size()))\n\t     .ifPresent(m -> System.out.println(\"Movie with most actors: \" + m));\n      */\n    Map<String, Long> firstLetters = movieList.stream().collect(Collectors.groupingBy( m -> m.getTitle().substring(0, 1), Collectors.counting()));\n    System.out.println(\"Movies by first letter: \" + firstLetters);\n    System.out.println(\"Movies starting with The: \" + movieList.stream().filter( m -> m.getTitle().startsWith(\"The \")).count());\n    Map<String, List<Movie>> moviesByDirector = movieList.stream().filter( m -> m.getDirectors().size() > 0).collect(Collectors.groupingBy( m -> m.getDirectors().get(0)));\n    moviesByDirector.remove(\"\");\n    System.out.println(\"Directors in the database: \" + moviesByDirector.size());\n    String mostProlificDirector = Collections.max(moviesByDirector.entrySet(), Comparator.comparing( e -> e.getValue().size())).getKey();\n    System.out.println(mostProlificDirector + \" directed \" + moviesByDirector.get(mostProlificDirector).size() + \" movies:\");\n    List<String> titles = moviesByDirector.get(mostProlificDirector).stream().map( m -> m.getTitle()).collect(Collectors.toList());\n    System.out.println(titles);\n}\n","name":"main","className":"Movies","variables":{"Collectors":5,"a":2,"b":2,"e":2,"firstLetters":2,"count":4,"movieList":9,"titles":1,"l":2,"m":20,"Comparator":1,"moviesByDirector":6,"t":2,"mostProlificDirector":2,"Collections":1,"result2":2,"result1":2},"constants":{"\"\"":1,"\"The \"":1,"\" directed \"":1,"\"The most actors in a movie: \"":1,"\"Movie with most actors: \"":1,"\"X\"":1,"\"Movies by first letter: \"":1,"0":5,"\"Movies that start with X: \"":1,"1":1,"\"movies.txt\"":1,"\"Directors in the database: \"":1,"\" movies:\"":1,"\"Movies in which directors are actors: \"":2,"\"Movies starting with The: \"":1},"javaDoc":"","comments":"Alternative: movieList stream() max(Comparator comparing(m -> m getActors() size())) ifPresent(m -> System out println(\"Movie with most actors: \" + m)); ","isEmpty":false,"hasInnerClass":false,"lineCount":21,"modifier":9}
{"paramTypes":["Movie"],"returnType":"boolean","methodCalls":{"contains":1,"getActors":1,"stream":1,"getDirectors":1,"anyMatch":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"LambdaExpr":1,"NameExpr":13,"MethodCallExpr":5},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public static boolean commonActorAndDirector(Movie m) {\n    return m.getDirectors().stream().anyMatch( d -> m.getActors().contains(d));\n}\n","name":"commonActorAndDirector","className":"Movies","variables":{"d":1,"m":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["Collection<String>","Collection<String>"],"returnType":"Set<String>","methodCalls":{"retainAll":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Set<String>":1,"HashSet":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public static Set<String> intersect(Collection<String> a, Collection<String> b) {\n    Set<String> intersection = new HashSet<>(a);\n    intersection.retainAll(b);\n    return intersection;\n}\n","name":"intersect","className":"Movies","variables":{"a":1,"intersection":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["List<String>"],"returnType":"boolean","methodCalls":{"lastIndexOf":1,"sorted":1,"stream":2,"equals":1,"toList":2,"collect":2,"map":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"List<String>":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"LambdaExpr":1,"BinaryExpr":1,"NameExpr":29,"StringLiteralExpr":1,"MethodCallExpr":11},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public static boolean isSorted(List<String> names) {\n    List<String> lastNames = names.stream().map( n -> n.substring(n.lastIndexOf(\" \") + 1)).collect(Collectors.toList());\n    return lastNames.equals(lastNames.stream().sorted().collect(Collectors.toList()));\n}\n","name":"isSorted","className":"Movies","variables":{"Collectors":2,"names":1,"lastNames":3,"n":3},"constants":{"1":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String","int","List<String>","List<String>","List<String>"],"returnType":"Movie","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":15,"FieldAccessExpr":5,"ThisExpr":5,"AssignExpr":5},"statements":{"ExpressionStmt":5},"text":"public Movie(String title, int year, List<String> directors, List<String> producers, List<String> actors) {\n    this.title = title;\n    this.year = year;\n    this.directors = directors;\n    this.producers = producers;\n    this.actors = actors;\n}\n","name":"Movie","className":"Movie","variables":{"actors":1,"year":1,"directors":1,"title":1,"producers":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public List<String> getActors() {\n    return actors;\n}\n","name":"getActors","className":"Movie","variables":{"actors":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public List<String> getDirectors() {\n    return directors;\n}\n","name":"getDirectors","className":"Movie","variables":{"directors":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public List<String> getProducers() {\n    return producers;\n}\n","name":"getProducers","className":"Movie","variables":{"producers":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getTitle() {\n    return title;\n}\n","name":"getTitle","className":"Movie","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getYear() {\n    return year;\n}\n","name":"getYear","className":"Movie","variables":{"year":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":9,"StringLiteralExpr":5,"NameExpr":5},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"Name: \" + title + \"\\nYear: \" + year + \"\\nDirected by: \" + directors + \"\\nProduced by: \" + producers + \"\\nActors: \" + actors;\n}\n","name":"toString","className":"Movie","variables":{"actors":1,"year":1,"directors":1,"title":1,"producers":1},"constants":{"\"\\nProduced by: \"":1,"\"\\nYear: \"":1,"\"\\nDirected by: \"":1,"\"\\nActors: \"":1,"\"Name: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"encode":2,"getJsonObject":1,"size":2,"createReader":1,"getJsonArray":1,"getString":1,"printFilm":1,"openStream":1,"readObject":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"JsonArray":1,"boolean":1,"InputStream":1,"JsonReader":1,"JsonObject":1,"String":5,"URL":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":12,"ArrayAccessExpr":1,"BinaryExpr":25,"NameExpr":47,"StringLiteralExpr":26,"ConditionalExpr":1,"UnaryExpr":3,"AssignExpr":2,"NullLiteralExpr":2,"BooleanLiteralExpr":1,"EnclosedExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] args) throws Exception {\n    String apiKey = args[0];\n    String urlString = \"https://www.googleapis.com/freebase/v1/mqlread\";\n    String query = \"[{\" + \"  \\\"type\\\": \\\"/film/film\\\",\" + \"  \\\"name\\\": null,\" + \"  \\\"initial_release_date\\\": null,\" + \"  \\\"directed_by\\\": [],\" + \"  \\\"produced_by\\\": [],\" + \"  \\\"starring\\\": [{\" + \"    \\\"actor\\\": []\" + \"  }],\" + \"  \\\"country\\\": [{\" + \"    \\\"id\\\": \\\"/en/united_states\\\"\" + \"  }],\" + \"  \\\"genre\\\": [{\" + \"    \\\"id\\\": \\\"/en/drama\\\"\" + \"  }]\" + \"}]\";\n    String cursor = null;\n    boolean done = false;\n    while (!done) {\n        String request = \"?query=\" + URLEncoder.encode(query, \"UTF-8\") + \"&key=\" + apiKey + \"&cursor\" + (cursor == null ? \"\" : \"=\" + URLEncoder.encode(cursor, \"UTF-8\"));\n        URL url = new URL(urlString + request);\n        try (InputStream in = url.openStream()) {\n            JsonReader reader = Json.createReader(in);\n            JsonObject contents = reader.readObject();\n            JsonArray result = contents.getJsonArray(\"result\");\n            for (int k = 0; k < result.size(); k++) {\n                printFilm(result.getJsonObject(k));\n            }\n            done = result.size() < 100;\n            if (!done) {\n                cursor = contents.getString(\"cursor\");\n            }\n        }\n    }\n}\n","name":"main","className":"Freebase","variables":{"cursor":3,"request":2,"apiKey":2,"in":1,"reader":2,"query":1,"urlString":2,"Json":1,"k":3,"done":4,"url":2,"args":1,"result":4,"contents":3,"URLEncoder":2},"constants":{"\"\"":1,"\"    \\\"id\\\": \\\"/en/drama\\\"\"":1,"\"  \\\"name\\\": null,\"":1,"\"  \\\"type\\\": \\\"/film/film\\\",\"":1,"\"[{\"":1,"\"result\"":1,"\"}]\"":1,"\"  \\\"genre\\\": [{\"":1,"\"    \\\"id\\\": \\\"/en/united_states\\\"\"":1,"\"  }]\"":1,"\"  \\\"produced_by\\\": [],\"":1,"\"?query=\"":1,"\"  \\\"directed_by\\\": [],\"":1,"\"&key=\"":1,"\"&cursor\"":1,"\"=\"":1,"false":1,"\"  \\\"country\\\": [{\"":1,"0":2,"100":1,"\"  \\\"starring\\\": [{\"":1,"\"UTF-8\"":2,"\"  }],\"":2,"null":2,"\"https://www.googleapis.com/freebase/v1/mqlread\"":1,"\"  \\\"initial_release_date\\\": null,\"":1,"\"    \\\"actor\\\": []\"":1,"\"cursor\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String","List<JsonValue>"],"returnType":"StringBuilder","methodCalls":{"size":1,"get":1,"replace":1,"toString":1,"append":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuilder":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":28,"StringLiteralExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"public static StringBuilder format(String title, List<JsonValue> array) {\n    StringBuilder result = new StringBuilder();\n    result.append(title);\n    result.append(\": \");\n    for (int i = 0; i < array.size(); i++) {\n        if (i > 0) {\n            result.append(\", \");\n        }\n        result.append(array.get(i).toString().replace(\",\", \" \"));\n    }\n    return result;\n}\n","name":"format","className":"Freebase","variables":{"result":6,"array":2,"i":4},"constants":{"0":2,"\" \"":1,"\",\"":1,"\": \"":1,"\", \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["JsonObject"],"returnType":"void","methodCalls":{"getJsonObject":1,"size":1,"addAll":1,"get":1,"getJsonArray":4,"replace":1,"format":3,"toString":1,"getString":1,"substring":1,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"List<JsonValue>":1,"JsonArray":1,"ArrayList":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":67,"StringLiteralExpr":13,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":20},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"public static void printFilm(JsonObject film) {\n    System.out.println(\"Name: \" + film.getString(\"name\"));\n    System.out.println(\"Year: \" + film.get(\"initial_release_date\").toString().replace(\"\\\"\", \"\").substring(0, 4));\n    System.out.println(format(\"Directed by\", film.getJsonArray(\"directed_by\")));\n    System.out.println(format(\"Produced by\", film.getJsonArray(\"produced_by\")));\n    List<JsonValue> actors = new ArrayList<>();\n    JsonArray jactors = film.getJsonArray(\"starring\");\n    for (int i = 0; i < jactors.size(); i++) {\n        actors.addAll(jactors.getJsonObject(i).getJsonArray(\"actor\"));\n    }\n    System.out.println(format(\"Actors\", actors));\n}\n","name":"printFilm","className":"Freebase","variables":{"actors":2,"i":3,"film":5,"jactors":3},"constants":{"\"\"":1,"\"Actors\"":1,"\"Produced by\"":1,"\"Year: \"":1,"\"\\\"\"":1,"\"actor\"":1,"\"Name: \"":1,"\"directed_by\"":1,"\"initial_release_date\"":1,"0":2,"\"produced_by\"":1,"4":1,"\"name\"":1,"\"starring\"":1,"\"Directed by\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sorted":2,"of":5,"toUpperCase":1,"show":6,"limit":2,"toArray":1,"toString":1,"map":3,"generate":1,"iterate":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Stream<Double>":1,"Stream<String>":1,"String[]":1,"Stream<BankAccount>":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"DoubleLiteralExpr":12,"LambdaExpr":2,"BinaryExpr":2,"NameExpr":81,"StringLiteralExpr":15,"FieldAccessExpr":1,"MethodReferenceExpr":6,"TypeExpr":6,"MethodCallExpr":28,"AssignExpr":4},"statements":{"ExpressionStmt":17},"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).map( w -> w.toUpperCase());\n    show(\"Mapping to uppercase with a lambda expression\", words);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).map(String::toUpperCase);\n    show(\"Mapping to uppercase with a method reference\", words);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).sorted(String::compareTo);\n    show(\"Sorting strings with a method reference\", words);\n    Stream<Double> numbers = Stream.of(32.0, 54.0, 67.5, 29.0, 35.0, 80.0, 115.0, 44.5, 100.0, 65.0).sorted(Double::compare);\n    show(\"Sorting numbers with a method reference\", numbers);\n    Stream<BankAccount> accounts = Stream.generate(BankAccount::new).limit(5);\n    show(\"Constructing accounts with a constructor reference\", accounts);\n    accounts = Stream.iterate(0.0,  n -> n + 1000.0).map(BankAccount::new).limit(5);\n    show(\"Mapping with a constructor reference\", accounts);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \"));\n    String[] array = words.toArray(String[]::new);\n    System.out.println(\"Using toArray with an array constructor reference: \" + Arrays.toString(array));\n}\n","name":"main","className":"MethodReferences","variables":{"array":1,"w":2,"words":5,"numbers":1,"Stream":7,"accounts":2,"Arrays":1,"n":2},"constants":{"80.0":1,"\"Sorting numbers with a method reference\"":1,"\" \"":4,"\"Constructing accounts with a constructor reference\"":1,"\"Using toArray with an array constructor reference: \"":1,"67.5":1,"0.0":1,"35.0":1,"5":2,"\"how much wood could a wood chuck chuck\"":4,"32.0":1,"\"Mapping to uppercase with a lambda expression\"":1,"\"Mapping to uppercase with a method reference\"":1,"65.0":1,"54.0":1,"1000.0":1,"100.0":1,"\"Mapping with a constructor reference\"":1,"29.0":1,"115.0":1,"\"Sorting strings with a method reference\"":1,"44.5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":15,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"List<T>":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":53,"StringLiteralExpr":3,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"MethodReferences","variables":{"Collectors":1,"stream":1,"values":4,"caption":1,"i":4,"Math":1,"SHOW_LIMIT":3},"constants":{"0":2,"1":1,"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"BankAccount[balance=\" + balance + \"]\";\n}\n","name":"toString","className":"BankAccount","variables":{"balance":1},"constants":{"\"]\"":1,"\"BankAccount[balance=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"filter":1,"nextLine":1,"stream":1,"hasNextLine":1,"length":2,"count":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"ArrayList":1,"String":1,"long":1,"List<String>":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":4,"LambdaExpr":1,"StringLiteralExpr":3,"NameExpr":37,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":10,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ForeachStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../countries.txt\"));\n    // This file contains one country name per line\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNextLine()) {\n        wordList.add(in.nextLine());\n    }\n    // Now wordList is a list of country names\n    // Traditional loop for counting the long words\n    long count = 0;\n    for (String w : wordList) {\n        if (w.length() > 10) {\n            count++;\n        }\n    }\n    System.out.println(\"Long words: \" + count);\n    // The same computation with streams\n    count = wordList.stream().filter( w -> w.length() > 10).count();\n    System.out.println(\"Long words: \" + count);\n}\n","name":"main","className":"StreamDemo","variables":{"in":3,"wordList":4,"w":4,"count":5},"constants":{"0":1,"\"../countries.txt\"":1,"\"Long words: \"":2,"10":2},"javaDoc":"","comments":"Now wordList is a list of country names This file contains one country name per line Traditional loop for counting the long words The same computation with streams ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"next":1,"max":1,"length":3,"hasNext":1,"orElse":1,"allMatch":1,"filter":2,"contains":1,"stream":3,"parallel":1,"findAny":1,"ifPresent":1,"endsWith":1,"System.out.print":1,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"Optional<String>":1,"boolean":1,"ArrayList":1,"Stream<String>":1,"String":1,"List<String>":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"LambdaExpr":5,"BinaryExpr":4,"StringLiteralExpr":7,"NameExpr":78,"FieldAccessExpr":4,"MethodCallExpr":23,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":18},"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../words.txt\"));\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNext()) {\n        wordList.add(in.next());\n    }\n    Stream<String> words = wordList.stream();\n    String result = words.parallel().filter( w -> w.length() > 10).filter( w -> w.endsWith(\"y\")).findAny().orElse(\"None found\");\n    // Note the use of findAny. Run this program several times\n    // and check whether the result changes\n    System.out.println(\"A word ending in y: \" + result);\n    words = wordList.stream();\n    Optional<String> result2 = words.max(( v,  w) -> v.length() - w.length());\n    System.out.print(\"The longest word: \");\n    result2.ifPresent( w -> System.out.println(w));\n    words = wordList.stream();\n    boolean result3 = words.allMatch( w -> w.contains(\"e\"));\n    System.out.println(\"All words contain an e: \" + result3);\n}\n","name":"main","className":"TerminalOperations","variables":{"result":2,"in":3,"wordList":5,"v":2,"w":9,"words":6,"result3":2,"result2":2},"constants":{"\"None found\"":1,"\"A word ending in y: \"":1,"\"All words contain an e: \"":1,"\"y\"":1,"\"The longest word: \"":1,"\"../words.txt\"":1,"10":1,"\"e\"":1},"javaDoc":"","comments":"Note the use of findAny Run this program several times and check whether the result changes ","isEmpty":false,"hasInnerClass":false,"lineCount":14,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"max":2,"length":3,"range":4,"sum":3,"orElse":2,"mapToObj":1,"substring":1,"ints":1,"sqrt":1,"mapToInt":2,"of":4,"toArray":6,"limit":1,"toString":6,"map":1,"System.out.println":11,"mapToDouble":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Random":1,"double":1,"int[]":1,"DoubleStream":1,"Stream<String>":2,"String":1,"IntStream":3,"int":2},"expressions":{"IntegerLiteralExpr":27,"ObjectCreationExpr":1,"VariableDeclarationExpr":12,"BinaryExpr":12,"LambdaExpr":5,"NameExpr":183,"StringLiteralExpr":18,"MethodReferenceExpr":1,"TypeExpr":1,"AssignExpr":5,"ArrayInitializerExpr":1,"FieldAccessExpr":11,"MethodCallExpr":53},"statements":{"ExpressionStmt":33},"text":"public static void main(String[] args) {\n    IntStream stream = IntStream.of(3, 1, 4, 1, 5, 9);\n    System.out.println(\"The sum of a stream of ints: \" + stream.sum());\n    int[] values = { 3, 1, 4, 1, 5, 9 };\n    stream = IntStream.of(values);\n    System.out.println(\"The sum of a stream of ints from an array: \" + stream.sum());\n    stream = IntStream.range(1, 101);\n    System.out.println(\"The sum of a range: \" + stream.sum());\n    Random generator = new Random();\n    IntStream dieTosses = generator.ints(1, 7);\n    System.out.println(\"Twenty random die tosses: \" + Arrays.toString(dieTosses.limit(20).toArray()));\n    IntStream codePoints = \"Hello\".codePoints();\n    System.out.println(\"The Unicode code points of the string Hello: \" + Arrays.toString(codePoints.toArray()));\n    Stream<String> words = Stream.of(\"Hello\", \"World\");\n    stream = words.mapToInt( w -> w.length());\n    System.out.println(\"Mapping objects to ints: \" + Arrays.toString(stream.toArray()));\n    stream = IntStream.range(0, 20).map( n -> Math.max(n, 10));\n    System.out.println(\"Mapping ints to ints: \" + Arrays.toString(stream.toArray()));\n    String river = \"Mississippi\";\n    int n = river.length();\n    Stream<String> prefixes = IntStream.range(0, n).mapToObj( i -> river.substring(0, i + 1));\n    System.out.println(\"Mapping ints to objects: \" + Arrays.toString(prefixes.toArray(String[]::new)));\n    DoubleStream roots = IntStream.range(0, 20).mapToDouble( i -> Math.sqrt(i));\n    System.out.println(\"Mapping ints to doubles: \" + Arrays.toString(roots.toArray()));\n    words = Stream.of(\"Goodbye\", \"World\");\n    double average = words.mapToInt( w -> w.length()).average().orElse(0);\n    System.out.println(\"Computing an average of ints: \" + average);\n    int max = \"World\".codePoints().max().orElse(0);\n    System.out.println(\"Computing a maximum of ints: \" + max);\n}\n","name":"main","className":"PrimitiveStreams","variables":{"average":2,"max":2,"values":1,"words":4,"generator":2,"i":3,"roots":2,"Math":2,"n":2,"prefixes":2,"stream":10,"w":4,"Stream":2,"river":3,"dieTosses":2,"Arrays":6,"IntStream":6,"codePoints":2},"constants":{"\"Goodbye\"":1,"\"The sum of a range: \"":1,"\"World\"":3,"\"Computing a maximum of ints: \"":1,"\"The Unicode code points of the string Hello: \"":1,"\"Mapping ints to ints: \"":1,"\"Twenty random die tosses: \"":1,"10":1,"\"Hello\"":2,"\"Mapping ints to doubles: \"":1,"\"Mapping ints to objects: \"":1,"0":6,"1":7,"\"The sum of a stream of ints from an array: \"":1,"\"The sum of a stream of ints: \"":1,"101":1,"3":2,"4":2,"5":2,"\"Computing an average of ints: \"":1,"7":1,"\"Mississippi\"":1,"9":2,"\"Mapping objects to ints: \"":1,"20":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":28,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"sorted":1,"of":6,"toLowerCase":3,"equals":1,"show":6,"length":1,"distinct":2,"map":6,"replaceAll":2,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Stream<Integer>":1,"Stream<String>":6},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"LambdaExpr":7,"NameExpr":96,"StringLiteralExpr":32,"MethodCallExpr":33,"AssignExpr":5},"statements":{"ExpressionStmt":25},"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"A\", \"Tale\", \"of\", \"Two\", \"Cities\");\n    Stream<String> lowerCaseWords = words.map( w -> w.toLowerCase());\n    show(\"Mapping to lowercase: \", lowerCaseWords);\n    lowerCaseWords = Stream.of(\"A\", \"Tale\", \"of\", \"Two\", \"Cities\").map( w -> w.toLowerCase());\n    Stream<String> consonantsOnly = lowerCaseWords.map( w -> w.replaceAll(\"[aeiou]\", \"\"));\n    show(\"Removing vowels\", consonantsOnly);\n    consonantsOnly = Stream.of(\"A\", \"Tale\", \"of\", \"Two\", \"Cities\").map( w -> w.toLowerCase()).map( w -> w.replaceAll(\"[aeiou]\", \"\"));\n    Stream<Integer> consonantCount = consonantsOnly.map( w -> w.length());\n    show(\"Counting consonants\", consonantCount);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \"));\n    Stream<String> cWords = words.filter( w -> w.substring(0, 1).equals(\"c\"));\n    show(\"Words with c\", cWords);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \"));\n    Stream<String> distinctWords = words.distinct();\n    show(\"Distinct words\", distinctWords);\n    distinctWords = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).distinct();\n    Stream<String> sortedWords = distinctWords.sorted();\n    show(\"Sorted words\", sortedWords);\n}\n","name":"main","className":"Streams","variables":{"sortedWords":1,"consonantCount":1,"w":14,"distinctWords":3,"words":6,"consonantsOnly":3,"Stream":6,"lowerCaseWords":3,"cWords":1},"constants":{"\"\"":2,"\"c\"":1,"\"A\"":3,"\"Mapping to lowercase: \"":1,"\"[aeiou]\"":2,"\" \"":3,"\"Distinct words\"":1,"\"Tale\"":3,"\"Counting consonants\"":1,"\"Sorted words\"":1,"0":1,"1":1,"\"Words with c\"":1,"\"how much wood could a wood chuck chuck\"":3,"\"of\"":3,"\"Cities\"":3,"\"Removing vowels\"":1,"\"Two\"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":18,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"List<T>":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":53,"StringLiteralExpr":3,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Streams","variables":{"Collectors":1,"stream":1,"values":4,"caption":1,"i":4,"Math":1,"SHOW_LIMIT":3},"constants":{"0":2,"1":1,"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"get":1,"limit":1,"length":1,"distinct":1,"toList":1,"lines":1,"collect":1,"map":2,"substring":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Stream<String>":1,"List<String>":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"LambdaExpr":3,"BinaryExpr":2,"NameExpr":35,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":12},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../countries.txt\"))) {\n        // Read the lines\n        List<String> result = lines.filter(// Keep only long words\n         w -> w.length() > 10).map(// Truncate to seven characters\n         w -> w.substring(0, 7)).map(// Add ellipses\n         w -> w + \"...\").distinct().limit(// Keep only the first twenty\n        20).collect(// Collect into a list\n        Collectors.toList());\n        System.out.println(result);\n    }\n}\n","name":"main","className":"StreamDemo","variables":{"result":1,"Collectors":1,"w":6,"Paths":1,"lines":2,"Files":1},"constants":{"0":1,"\"...\"":1,"\"../countries.txt\"":1,"7":1,"10":1},"javaDoc":"","comments":"Read the lines Keep only long words Truncate to seven characters Add ellipses Remove duplicates Keep only the first twenty Collect into a list ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"counting":1,"groupingBy":4,"toSet":1,"maxBy":1,"of":4,"length":2,"collect":4,"substring":4,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Map<String, Long>":1,"Map<String, List<String>>":1,"String[]":1,"Map<String, Set<String>>":1,"Map<String, Optional<String>>":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":5,"BinaryExpr":6,"LambdaExpr":5,"StringLiteralExpr":7,"NameExpr":89,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":26},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    String[] words = (\"how much wood would a woodchuck chuck \" + \"if a woodchuck could chuck wood\").split(\" \");\n    Map<String, List<String>> groups = Stream.of(words).collect(Collectors.groupingBy( w -> w.substring(0, 1)));\n    System.out.println(\"Lists by first letter: \" + groups);\n    Map<String, Set<String>> groupOfSets = Stream.of(words).collect(Collectors.groupingBy(// The function for extracting the keys\n     w -> w.substring(0, 1), // The group collector\n    Collectors.toSet()));\n    System.out.println(\"Sets by first letter: \" + groupOfSets);\n    Map<String, Long> groupCounts = Stream.of(words).collect(Collectors.groupingBy( w -> w.substring(0, 1), Collectors.counting()));\n    System.out.println(\"Counts by first letter: \" + groupCounts);\n    Map<String, Optional<String>> groupLongest = Stream.of(words).collect(Collectors.groupingBy(// The function for extracting the keys\n     w -> w.substring(0, 1), Collectors.maxBy(( v,  w) -> v.length() - w.length())));\n    // The comparator function\n    System.out.println(\"Longest word by first letter: \" + groupLongest);\n}\n","name":"main","className":"GroupDemo","variables":{"Collectors":7,"v":2,"w":10,"words":1,"groups":2,"Stream":4,"groupOfSets":2,"groupCounts":2,"groupLongest":2},"constants":{"0":4,"1":4,"\"Counts by first letter: \"":1,"\" \"":1,"\"if a woodchuck could chuck wood\"":1,"\"Longest word by first letter: \"":1,"\"how much wood would a woodchuck chuck \"":1,"\"Lists by first letter: \"":1,"\"Sets by first letter: \"":1},"javaDoc":"","comments":"The function for extracting the keys The group collector The function for extracting the keys The comparator function ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getPopulation":1,"groupingBy":1,"get":1,"parse":1,"lines":1,"map":1,"collect":1,"getContinent":1,"summingLong":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Stream<Country>":1,"Map<String, Long>":1,"Stream<String>":1},"expressions":{"VariableDeclarationExpr":3,"LambdaExpr":3,"BinaryExpr":1,"NameExpr":34,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":10},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../population.txt\"))) {\n        Stream<Country> countries = lines.map( line -> Country.parse(line));\n        Map<String, Long> groupSum = countries.collect(Collectors.groupingBy(// The function for extracting the keys\n         c -> c.getContinent(), Collectors.summingLong(// The function for getting the summands\n         c -> c.getPopulation())));\n        System.out.println(\"Population per continent: \" + groupSum);\n    }\n}\n","name":"main","className":"GroupDemo2","variables":{"Collectors":2,"groupSum":2,"c":4,"line":1,"Country":1,"Paths":1,"countries":2,"lines":2,"Files":1},"constants":{"\"../population.txt\"":1,"\"Population per continent: \"":1},"javaDoc":"","comments":"The function for extracting the keys The function for getting the summands ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"Country","methodCalls":{"parseInt":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Country":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":2,"AssignExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":5},"text":"public static Country parse(String line) {\n    String[] fields = line.split(\"\\\\|\");\n    Country country = new Country();\n    country.name = fields[0];\n    country.continent = fields[1];\n    country.population = Integer.parseInt(fields[2]);\n    return country;\n}\n","name":"parse","className":"Country","variables":{"Integer":1,"country":2,"line":1,"fields":4},"constants":{"0":1,"1":1,"\"\\\\|\"":1,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getContinent() {\n    return continent;\n}\n","name":"getContinent","className":"Country","variables":{"continent":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getPopulation() {\n    return population;\n}\n","name":"getPopulation","className":"Country","variables":{"population":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":3,"StringLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return name + \"|\" + continent + \"|\" + population;\n}\n","name":"toString","className":"Country","variables":{"continent":1,"name":1,"population":1},"constants":{"\"|\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"moveRectangleTo":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void mousePressed(MouseEvent event) {\n    int x = event.getX();\n    int y = event.getY();\n    scene.moveRectangleTo(x, y);\n}\n","name":"mousePressed","className":"MousePressListener","variables":{"x":1,"y":1,"event":2,"scene":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Do-nothing methods\npublic void mouseReleased(MouseEvent event) {\n}\n","name":"mouseReleased","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","comments":" Do-nothing methods","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseClicked(MouseEvent event) {\n}\n","name":"mouseClicked","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseEntered(MouseEvent event) {\n}\n","name":"mouseEntered","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseExited(MouseEvent event) {\n}\n","name":"mouseExited","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"getKeyStrokeForEvent":1,"equals":4,"replace":1,"toString":1,"moveRectangleBy":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":1,"NameExpr":32,"StringLiteralExpr":6,"UnaryExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":5},"text":"public void keyPressed(KeyEvent event) {\n    String key = KeyStroke.getKeyStrokeForEvent(event).toString().replace(\"pressed \", \"\");\n    if (key.equals(\"DOWN\")) {\n        scene.moveRectangleBy(0, 1);\n    } else if (key.equals(\"UP\")) {\n        scene.moveRectangleBy(0, -1);\n    } else if (key.equals(\"LEFT\")) {\n        scene.moveRectangleBy(-1, 0);\n    } else if (key.equals(\"RIGHT\")) {\n        scene.moveRectangleBy(1, 0);\n    }\n}\n","name":"keyPressed","className":"KeyStrokeListener","variables":{"KeyStroke":1,"key":5,"scene":4},"constants":{"\"\"":1,"0":4,"1":4,"\"UP\"":1,"\"DOWN\"":1,"\"pressed \"":1,"\"LEFT\"":1,"\"RIGHT\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void keyTyped(KeyEvent event) {\n}\n","name":"keyTyped","className":"KeyStrokeListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void keyReleased(KeyEvent event) {\n}\n","name":"keyReleased","className":"KeyStrokeListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame3","methodCalls":{"add":1,"setSize":1,"addKeyListener":1,"setFocusable":1,"addMouseListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"MouseListener":1,"MousePressListener":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":18,"AssignExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public RectangleFrame3() {\n    scene = new RectangleComponent3();\n    add(scene);\n    MouseListener listener = new MousePressListener();\n    scene.addMouseListener(listener);\n    scene.addKeyListener(new KeyStrokeListener());\n    scene.setFocusable(true);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"RectangleFrame3","className":"RectangleFrame3","variables":{"listener":1,"scene":4},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"RectangleComponent3","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public RectangleComponent3() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent3","className":"RectangleComponent3","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"constants":{},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Graphics2D":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent3","variables":{"g":1,"g2":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"setLocation":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   */\npublic void moveRectangleTo(int x, int y) {\n    box.setLocation(x, y);\n    repaint();\n}\n","name":"moveRectangleTo","className":"RectangleComponent3","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle to the given location x the x-position of the new location y the y-position of the new location","comments":"\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"repaint":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   */\npublic void moveRectangleBy(int dx, int dy) {\n    box.translate(dx, dy);\n    repaint();\n}\n","name":"moveRectangleBy","className":"RectangleComponent3","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle by a given amount dx the amount to move in the x-direction dy the amount to move in the y-direction","comments":"\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"RectangleFrame3":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame3();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer3","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"compare":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"BankAccount":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    BankAccount other = (BankAccount) otherObject;\n    return Double.compare(balance, other.balance);\n}\n","name":"compareTo","className":"BankAccount","variables":{"other":1,"Double":1,"otherObject":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"BankAccount[balance=\" + balance + \"]\";\n}\n","name":"toString","className":"BankAccount","variables":{"balance":1},"constants":{"\"]\"":1,"\"BankAccount[balance=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":2,"sort":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Comparable[]":2},"expressions":{"IntegerLiteralExpr":14,"ObjectCreationExpr":6,"VariableDeclarationExpr":2,"ArrayAccessExpr":6,"NameExpr":32,"StringLiteralExpr":6,"FieldAccessExpr":2,"ArrayCreationExpr":2,"AssignExpr":6,"MethodCallExpr":6},"statements":{"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    Comparable[] accounts = new Comparable[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    Arrays.sort(accounts);\n    System.out.println(Arrays.toString(accounts));\n    Comparable[] people = new Comparable[3];\n    people[0] = new Person(\"James\", \"Gosling\", 42);\n    people[2] = new Person(\"Alonzo\", \"Church\", 30510);\n    people[1] = new Person(\"John\", \"Mauchly\", 1729);\n    Arrays.sort(people);\n    System.out.println(Arrays.toString(people));\n}\n","name":"main","className":"ComparableDemo","variables":{"accounts":4,"Arrays":4,"people":4},"constants":{"\"James\"":1,"2000":1,"\"Mauchly\"":1,"0":3,"1":2,"2":2,"30510":1,"3":2,"10000":1,"\"Alonzo\"":1,"1729":1,"\"Gosling\"":1,"42":1,"\"Church\"":1,"\"John\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":12,"modifier":9}
{"paramTypes":["String","String","int"],"returnType":"Person","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":3,"ThisExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public Person(String first, String last, int id) {\n    this.first = first;\n    this.last = last;\n    this.id = id;\n}\n","name":"Person","className":"Person","variables":{"last":1,"id":1,"first":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":6,"StringLiteralExpr":4,"NameExpr":3},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"Person[first=\" + first + \",last=\" + last + \",id=\" + id + \"]\";\n}\n","name":"toString","className":"Person","variables":{"last":1,"id":1,"first":1},"constants":{"\",last=\"":1,"\"]\"":1,"\",id=\"":1,"\"Person[first=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Person":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"CastExpr":1,"NameExpr":5,"FieldAccessExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    Person other = (Person) otherObject;\n    return id - other.id;\n}\n","name":"compareTo","className":"Person","variables":{"other":1,"id":1,"otherObject":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Computes the measure of the object.\n      @return the measure\n   */\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"constants":{},"javaDoc":"Computes the measure of the object the measure","comments":"\n      Computes the measure of the object.\n      @return the measure\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Measurable","Measurable"],"returnType":"Measurable","methodCalls":{"getMeasure":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"public static Measurable larger(Measurable obj1, Measurable obj2) {\n    if (obj1.getMeasure() > obj2.getMeasure()) {\n        return obj1;\n    } else {\n        return obj2;\n    }\n}\n","name":"larger","className":"ConversionTester","variables":{"obj2":2,"obj1":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"larger":1,"getName":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Measurable":1,"Country":3,"String":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":19,"CastExpr":1,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Country uruguay = new Country(\"Uruguay\", 176220);\n    Country thailand = new Country(\"Thailand\", 513120);\n    Measurable max = larger(uruguay, thailand);\n    Country maxCountry = (Country) max;\n    String name = maxCountry.getName();\n    System.out.println(\"Country with larger area: \" + name);\n    System.out.println(\"Expected: Thailand\");\n}\n","name":"main","className":"ConversionTester","variables":{"maxCountry":2,"max":2,"thailand":1,"name":2,"uruguay":1},"constants":{"\"Thailand\"":1,"513120":1,"\"Country with larger area: \"":1,"\"Expected: Thailand\"":1,"\"Uruguay\"":1,"176220":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return balance;\n}\n","name":"getMeasure","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// An abstract method\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"constants":{},"javaDoc":"","comments":" An abstract method","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Measurable[]"],"returnType":"// A static method\ndouble","methodCalls":{"getMeasure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Measurable":1,"double":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":13,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"static // A static method\ndouble average(// A static method\nMeasurable[] objects) {\n    double sum = 0;\n    for (Measurable obj : objects) {\n        sum = sum + obj.getMeasure();\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Measurable","variables":{"obj":2,"objects":1,"sum":4},"constants":{"0":3},"javaDoc":"","comments":"A static method A static method A static method ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2,"Measurable[]":2},"expressions":{"IntegerLiteralExpr":14,"ObjectCreationExpr":6,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":7,"FieldAccessExpr":4,"ArrayCreationExpr":2,"AssignExpr":6,"MethodCallExpr":6},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    // Calling the static average method\n    // with an array of BankAccount objects\n    Measurable[] accounts = new Measurable[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    double averageBalance = Measurable.average(accounts);\n    System.out.println(\"Average balance: \" + averageBalance);\n    System.out.println(\"Expected: 4000\");\n    // Calling the static average method\n    // with an array of Country objects\n    Measurable[] countries = new Measurable[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    double averageArea = Measurable.average(countries);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 239950\");\n}\n","name":"main","className":"MeasurableTester","variables":{"Measurable":2,"accounts":4,"countries":4,"averageBalance":2,"averageArea":2},"constants":{"\"Average balance: \"":1,"\"Thailand\"":1,"513120":1,"\"Belgium\"":1,"\"Expected: 239950\"":1,"2000":1,"\"Uruguay\"":1,"\"Expected: 4000\"":1,"0":3,"1":2,"2":2,"30510":1,"\"Average area: \"":1,"3":2,"10000":1,"176220":1},"javaDoc":"","comments":"Calling the static average method with an array of BankAccount objects Calling the static average method with an array of Country objects ","isEmpty":false,"hasInnerClass":false,"lineCount":18,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object[]","Measurer"],"returnType":"double","methodCalls":{"measure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"Object":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":14,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   */\npublic static double average(Object[] objects, Measurer meas) {\n    double sum = 0;\n    for (Object obj : objects) {\n        sum = sum + meas.measure(obj);\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":1,"objects":1,"meas":1,"sum":4},"constants":{"0":3},"javaDoc":"Computes the average of the measures of the given objects objects an array of objects meas the measurer for the objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   */\ndouble measure(Object anObject);\n","name":"measure","className":"Measurer","variables":{},"constants":{},"javaDoc":"Computes the measure of an object anObject the object to be measured the measure","comments":"\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{"getHeight":1,"getWidth":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"double":1,"Rectangle":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":1,"CastExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public double measure(Object anObject) {\n    Rectangle aRectangle = (Rectangle) anObject;\n    double area = aRectangle.getWidth() * aRectangle.getHeight();\n    return area;\n}\n","name":"measure","className":"AreaMeasurer","variables":{"area":2,"aRectangle":3,"anObject":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"getHeight":1,"getWidth":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["Casting","InnerMethod","PolyMorphism","InnerClass"],"types":{"Measurer":1,"double":2,"Rectangle":1,"Rectangle[]":1,"AreaMeasurer":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":12,"VariableDeclarationExpr":5,"ArrayInitializerExpr":1,"BinaryExpr":2,"NameExpr":28,"CastExpr":1,"StringLiteralExpr":2,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":5},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    class AreaMeasurer implements Measurer {\n\n        public double measure(Object anObject) {\n            Rectangle aRectangle = (Rectangle) anObject;\n            double area = aRectangle.getWidth() * aRectangle.getHeight();\n            return area;\n        }\n    }\n    Measurer areaMeas = new AreaMeasurer();\n    Rectangle[] rects = new Rectangle[] { new Rectangle(5, 10, 20, 30), new Rectangle(10, 20, 30, 40), new Rectangle(20, 30, 5, 15) };\n    double averageArea = Data.average(rects, areaMeas);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 625\");\n}\n","name":"main","className":"MeasurerTester","variables":{"area":2,"measure":1,"aRectangle":3,"anObject":2,"AreaMeasurer":1,"areaMeas":1,"rects":1,"Data":1,"averageArea":2},"constants":{"\"Average area: \"":1,"15":1,"\"Expected: 625\"":1,"5":2,"40":1,"30":3,"20":3,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    System.out.println(\"I was clicked.\");\n}\n","name":"actionPerformed","className":"ClickListener","variables":{},"constants":{"\"I was clicked.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"addActionListener":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"JFrame":1,"JButton":1,"ClickListener":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    JButton button = new JButton(\"Click me!\");\n    frame.add(button);\n    ActionListener listener = new ClickListener();\n    button.addActionListener(listener);\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ButtonViewer","variables":{"button":2,"listener":1,"frame":5},"constants":{"true":1,"\"Click me!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"name":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Named":1,"User":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":13,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    Named user = new User(\"Amy\", \"Smith\");\n    System.out.println(\"Name: \" + user.name());\n    // And not \"(NONE)\"\n    System.out.println(\"Expected: Amy Smith\");\n}\n","name":"main","className":"ConflictingDefaultMethodsTester","variables":{"user":2},"constants":{"\"Expected: Amy Smith\"":1,"\"Smith\"":1,"\"Amy\"":1,"\"Name: \"":1},"javaDoc":"","comments":"And not \"(NONE)\" ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"default String name() {\n    return \"(NONE)\";\n}\n","name":"name","className":"Named","variables":{},"constants":{"\"(NONE)\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["String","String"],"returnType":"User","methodCalls":{"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":9,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"public User(String first, String last) {\n    super(first, last);\n    username = (first.substring(0, 1) + last).toLowerCase();\n}\n","name":"User","className":"User","variables":{"last":2,"first":2,"username":1},"constants":{"0":1,"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String","String"],"returnType":"Person","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Person(String firstName, String lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n","name":"Person","className":"Person","variables":{"firstName":1,"lastName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"firstName":1,"lastName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String name() {\n    return firstName() + \" \" + lastName();\n}\n","name":"name","className":"Person","variables":{},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String firstName() {\n    return firstName;\n}\n","name":"firstName","className":"Person","variables":{"firstName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String lastName() {\n    return lastName;\n}\n","name":"lastName","className":"Person","variables":{"lastName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"addActionListener":1,"setDefaultCloseOperation":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"JButton":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"LambdaExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":2,"NameExpr":26,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    JButton button = new JButton(\"Click me!\");\n    frame.add(button);\n    button.addActionListener((ActionEvent event) -> System.out.println(\"I was clicked.\"));\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ButtonViewer","variables":{"button":2,"event":1,"frame":5},"constants":{"\"I was clicked.\"":1,"true":1,"\"Click me!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"void addScore(int studentId, double score);\n","name":"addScore","className":"IGradeBook","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"double getAverageScore(int studentId);\n","name":"getAverageScore","className":"IGradeBook","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"void save(String filename);\n","name":"save","className":"IGradeBook","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"void load(String filename);\n","name":"load","className":"IGradeBook","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"MockGradeBook","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public MockGradeBook() {\n    scores = new ArrayList<Double>();\n}\n","name":"MockGradeBook","className":"MockGradeBook","variables":{"scores":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void addScore(int studentId, double score) {\n    // Ignore studentId\n    scores.add(score);\n}\n","name":"addScore","className":"MockGradeBook","variables":{"scores":1},"constants":{},"javaDoc":"","comments":"Ignore studentId ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":8,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public double getAverageScore(int studentId) {\n    double total = 0;\n    for (double x : scores) {\n        total = total + x;\n    }\n    return total / scores.size();\n}\n","name":"getAverageScore","className":"MockGradeBook","variables":{"total":4,"scores":2,"x":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void save(String filename) {\n// Do nothing\n}\n","name":"save","className":"MockGradeBook","variables":{},"constants":{},"javaDoc":"","comments":"Do nothing ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":4},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":4,"NameExpr":12,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void load(String filename) {\n    // Add sample scores\n    scores.add(1.0);\n    scores.add(7.0);\n    scores.add(2.0);\n    scores.add(9.0);\n}\n","name":"load","className":"MockGradeBook","variables":{"scores":4},"constants":{"1.0":1,"2.0":1,"7.0":1,"9.0":1},"javaDoc":"","comments":"Add sample scores ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":3,"load":1,"getAverageScore":1,"equals":5,"addScore":1,"toUpperCase":1,"save":1,"nextInt":2,"System.out.print":6,"nextDouble":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Scanner":1,"boolean":1,"MockGradeBook":1,"IGradeBook":1,"double":1,"String":3,"int":2},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":9,"BooleanLiteralExpr":2,"BinaryExpr":3,"NameExpr":93,"StringLiteralExpr":13,"FieldAccessExpr":8,"UnaryExpr":1,"MethodCallExpr":23,"AssignExpr":1},"statements":{"IfStmt":5,"WhileStmt":1,"BlockStmt":6,"ExpressionStmt":20},"text":"public static void main(String[] args) {\n    IGradeBook gradeBook = new MockGradeBook();\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"L)oad A)dd aV)erage S)ave Q)uit: \");\n        String command = in.next().toUpperCase();\n        if (command.equals(\"L\")) {\n            System.out.print(\"Filename: \");\n            String filename = in.next();\n            gradeBook.load(filename);\n        } else if (command.equals(\"S\")) {\n            System.out.print(\"Filename: \");\n            String filename = in.next();\n            gradeBook.save(filename);\n        } else if (command.equals(\"A\")) {\n            System.out.print(\"ID: \");\n            int id = in.nextInt();\n            System.out.print(\"Score: \");\n            double score = in.nextDouble();\n            gradeBook.addScore(id, score);\n        } else if (command.equals(\"V\")) {\n            System.out.print(\"ID: \");\n            int id = in.nextInt();\n            System.out.println(\"Average for \" + id + \": \" + gradeBook.getAverageScore(id));\n        } else if (command.equals(\"Q\")) {\n            done = true;\n        }\n    }\n}\n","name":"main","className":"GradingProgram","variables":{"score":1,"filename":2,"in":7,"id":3,"done":3,"gradeBook":5,"command":6},"constants":{"\"A\"":1,"false":1,"\": \"":1,"\"Filename: \"":2,"\"Score: \"":1,"\"V\"":1,"\"S\"":1,"\"Q\"":1,"\"Average for \"":1,"\"ID: \"":2,"\"L\"":1,"true":1,"\"L)oad A)dd aV)erage S)ave Q)uit: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return balance;\n}\n","name":"getMeasure","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// An abstract method\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"constants":{},"javaDoc":"","comments":" An abstract method","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Measurable"],"returnType":"boolean","methodCalls":{"getMeasure":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"default boolean smallerThan(Measurable other) {\n    return getMeasure() < other.getMeasure();\n}\n","name":"smallerThan","className":"Measurable","variables":{"other":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Measurable[]":1},"expressions":{"IntegerLiteralExpr":11,"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":7,"BinaryExpr":2,"NameExpr":31,"StringLiteralExpr":7,"FieldAccessExpr":4,"ArrayCreationExpr":1,"AssignExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Measurable[] countries = new Measurable[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    System.out.println(\"Uruguay is smaller than Thailand: \" + countries[0].smallerThan(countries[1]));\n    System.out.println(\"Expected: true\");\n    System.out.println(\"Uruguay is smaller than Belgium: \" + countries[0].smallerThan(countries[2]));\n    System.out.println(\"Expected: false\");\n}\n","name":"main","className":"MeasurableTester","variables":{"countries":8},"constants":{"\"Thailand\"":1,"513120":1,"\"Belgium\"":1,"\"Uruguay is smaller than Belgium: \"":1,"\"Uruguay\"":1,"0":3,"1":2,"2":2,"30510":1,"3":1,"\"Uruguay is smaller than Thailand: \"":1,"\"Expected: true\"":1,"176220":1,"\"Expected: false\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"name":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Named":1,"User":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":13,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    Named user = new User(\"Amy\", \"Smith\");\n    System.out.println(\"Name: \" + user.name());\n    System.out.println(\"Expected: asmith\");\n}\n","name":"main","className":"ConflictingDefaultMethodsTester","variables":{"user":2},"constants":{"\"Smith\"":1,"\"Amy\"":1,"\"Name: \"":1,"\"Expected: asmith\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"default String name() {\n    return \"(NONE)\";\n}\n","name":"name","className":"Named","variables":{},"constants":{"\"(NONE)\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":["String","String"],"returnType":"User","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public User(String first, String last) {\n    this.first = first;\n    this.last = last;\n}\n","name":"User","className":"User","variables":{"last":1,"first":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":6,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"// This method MUST be implemented to resolve the conflict.\npublic String name() {\n    // Here, we provide a different implementation.\n    return (first.substring(0, 1) + last).toLowerCase();\n// You could have also called one of the default methods:\n// return Person.super.name();\n}\n","name":"name","className":"User","variables":{"last":1,"first":1},"constants":{"0":1,"1":1},"javaDoc":"","comments":"You could have also called one of the default methods: return Person super name(); Here we provide a different implementation  This method MUST be implemented to resolve the conflict.","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String firstName() {\n    return first;\n}\n","name":"firstName","className":"User","variables":{"first":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String lastName() {\n    return last;\n}\n","name":"lastName","className":"User","variables":{"last":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"firstName":1,"lastName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"default String name() {\n    return firstName() + \" \" + lastName();\n}\n","name":"name","className":"Person","variables":{},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"String firstName();\n","name":"firstName","className":"Person","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"String lastName();\n","name":"lastName","className":"Person","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"BankAccount":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":9,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":3,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    BankAccount other = (BankAccount) otherObject;\n    if (balance < other.balance) {\n        return -1;\n    }\n    if (balance > other.balance) {\n        return 1;\n    }\n    return 0;\n}\n","name":"compareTo","className":"BankAccount","variables":{"other":1,"balance":2,"otherObject":1},"constants":{"0":1,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount[]":1,"int":1},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":2,"NameExpr":31,"StringLiteralExpr":2,"FieldAccessExpr":4,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    BankAccount[] accounts = new BankAccount[3];\n    accounts[0] = new BankAccount(10000);\n    accounts[1] = new BankAccount(0);\n    accounts[2] = new BankAccount(2000);\n    Arrays.sort(accounts);\n    for (int i = 0; i < accounts.length; i++) {\n        System.out.print(accounts[i].getBalance() + \" \");\n    }\n    System.out.println();\n    System.out.println(\"Expected: 0.0 2000.0 10000.0\");\n}\n","name":"main","className":"ComparableTester","variables":{"i":4,"accounts":5,"Arrays":1},"constants":{"0":3,"1":1,"2":1,"3":1,"\" \"":1,"10000":1,"2000":1,"\"Expected: 0.0 2000.0 10000.0\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"RectangleFrame2":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame2();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer2","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"RectangleComponent2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public RectangleComponent2() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent2","className":"RectangleComponent2","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"constants":{},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Graphics2D":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent2","variables":{"g":1,"g2":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"setLocation":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   */\npublic void moveRectangleTo(int x, int y) {\n    box.setLocation(x, y);\n    repaint();\n}\n","name":"moveRectangleTo","className":"RectangleComponent2","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle to the given location x the x-position of the new location y the y-position of the new location","comments":"\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"moveRectangleTo":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void mousePressed(MouseEvent event) {\n    int x = event.getX();\n    int y = event.getY();\n    scene.moveRectangleTo(x, y);\n}\n","name":"mousePressed","className":"MousePressListener","variables":{"x":1,"y":1,"event":2,"scene":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Do-nothing methods\npublic void mouseReleased(MouseEvent event) {\n}\n","name":"mouseReleased","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","comments":" Do-nothing methods","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseClicked(MouseEvent event) {\n}\n","name":"mouseClicked","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseEntered(MouseEvent event) {\n}\n","name":"mouseEntered","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseExited(MouseEvent event) {\n}\n","name":"mouseExited","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame2","methodCalls":{"add":1,"setSize":1,"addMouseListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"MouseListener":1,"MousePressListener":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":12,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"public RectangleFrame2() {\n    scene = new RectangleComponent2();\n    add(scene);\n    MouseListener listener = new MousePressListener();\n    scene.addMouseListener(listener);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"RectangleFrame2","className":"RectangleFrame2","variables":{"listener":1,"scene":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"random":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"CastExpr":1,"NameExpr":6,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int next() {\n    return (int) (Integer.MAX_VALUE * Math.random());\n}\n","name":"next","className":"RandomSequence","variables":{"Math":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":2,"display":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LastDigitDistribution":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"NameExpr":17,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    LastDigitDistribution dist1 = new LastDigitDistribution();\n    dist1.process(new SquareSequence(), 1000);\n    dist1.display();\n    System.out.println();\n    LastDigitDistribution dist2 = new LastDigitDistribution();\n    dist2.process(new RandomSequence(), 1000);\n    dist2.display();\n}\n","name":"main","className":"SequenceDemo","variables":{"dist1":3,"dist2":3},"constants":{"1000":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"int next();\n","name":"next","className":"Sequence","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"UnaryExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int next() {\n    n++;\n    return n * n;\n}\n","name":"next","className":"SquareSequence","variables":{"n":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"LastDigitDistribution","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a distribution whose counters are set to zero.\n   */\npublic LastDigitDistribution() {\n    counters = new int[10];\n}\n","name":"LastDigitDistribution","className":"LastDigitDistribution","variables":{"counters":1},"constants":{"10":1},"javaDoc":"Constructs a distribution whose counters are set to zero","comments":"\n      Constructs a distribution whose counters are set to zero.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Sequence","int"],"returnType":"void","methodCalls":{"next":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":9,"UnaryExpr":2,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"/**\n      Processes values from this sequence.\n      @param seq the sequence from which to obtain the values\n      @param valuesToProcess the number of values to process\n   */\npublic void process(Sequence seq, int valuesToProcess) {\n    for (int i = 1; i <= valuesToProcess; i++) {\n        int value = seq.next();\n        int lastDigit = value % 10;\n        counters[lastDigit]++;\n    }\n}\n","name":"process","className":"LastDigitDistribution","variables":{"counters":1,"lastDigit":2,"i":3,"valuesToProcess":1,"value":2,"seq":1},"constants":{"1":1,"10":1},"javaDoc":"Processes values from this sequence seq the sequence from which to obtain the values valuesToProcess the number of values to process","comments":"\n      Processes values from this sequence.\n      @param seq the sequence from which to obtain the values\n      @param valuesToProcess the number of values to process\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"/**\n      Displays the counter values of this distribution.\n   */\npublic void display() {\n    for (int i = 0; i < counters.length; i++) {\n        System.out.println(i + \": \" + counters[i]);\n    }\n}\n","name":"display","className":"LastDigitDistribution","variables":{"counters":1,"i":5},"constants":{"0":1,"\": \"":1},"javaDoc":"Displays the counter values of this distribution","comments":"\n      Displays the counter values of this distribution.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return balance;\n}\n","name":"getMeasure","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Measurable[]"],"returnType":"double","methodCalls":{"getMeasure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Measurable":1,"double":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":13,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of Measurable objects\n      @return the average of the measures\n   */\npublic static double average(Measurable[] objects) {\n    double sum = 0;\n    for (Measurable obj : objects) {\n        sum = sum + obj.getMeasure();\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":2,"objects":1,"sum":4},"constants":{"0":3},"javaDoc":"Computes the average of the measures of the given objects objects an array of Measurable objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of Measurable objects\n      @return the average of the measures\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Computes the measure of the object.\n      @return the measure\n   */\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"constants":{},"javaDoc":"Computes the measure of the object the measure","comments":"\n      Computes the measure of the object.\n      @return the measure\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2,"Measurable[]":2},"expressions":{"IntegerLiteralExpr":14,"ObjectCreationExpr":6,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":7,"FieldAccessExpr":4,"ArrayCreationExpr":2,"AssignExpr":6,"MethodCallExpr":6},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    // Calling the average method with an array of BankAccount objects\n    Measurable[] accounts = new Measurable[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    double averageBalance = Data.average(accounts);\n    System.out.println(\"Average balance: \" + averageBalance);\n    System.out.println(\"Expected: 4000\");\n    // Calling the average method with an array of Country objects\n    Measurable[] countries = new Measurable[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    double averageArea = Data.average(countries);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 239950\");\n}\n","name":"main","className":"MeasurableTester","variables":{"Data":2,"accounts":4,"countries":4,"averageBalance":2,"averageArea":2},"constants":{"\"Average balance: \"":1,"\"Thailand\"":1,"513120":1,"\"Belgium\"":1,"\"Expected: 239950\"":1,"2000":1,"\"Uruguay\"":1,"\"Expected: 4000\"":1,"0":3,"1":2,"2":2,"30510":1,"\"Average area: \"":1,"3":2,"10000":1,"176220":1},"javaDoc":"","comments":"Calling the average method with an array of BankAccount objects Calling the average method with an array of Country objects ","isEmpty":false,"hasInnerClass":false,"lineCount":14,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"moveRectangleTo":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void mousePressed(MouseEvent event) {\n    int x = event.getX();\n    int y = event.getY();\n    scene.moveRectangleTo(x, y);\n}\n","name":"mousePressed","className":"MousePressListener","variables":{"x":1,"y":1,"event":2,"scene":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Do-nothing methods\npublic void mouseReleased(MouseEvent event) {\n}\n","name":"mouseReleased","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","comments":" Do-nothing methods","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseClicked(MouseEvent event) {\n}\n","name":"mouseClicked","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseEntered(MouseEvent event) {\n}\n","name":"mouseEntered","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseExited(MouseEvent event) {\n}\n","name":"mouseExited","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"getKeyStrokeForEvent":1,"equals":4,"replace":1,"toString":1,"moveRectangleBy":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":1,"NameExpr":32,"StringLiteralExpr":6,"UnaryExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":5},"text":"public void keyPressed(KeyEvent event) {\n    String key = KeyStroke.getKeyStrokeForEvent(event).toString().replace(\"pressed \", \"\");\n    if (key.equals(\"DOWN\")) {\n        scene.moveRectangleBy(0, 1);\n    } else if (key.equals(\"UP\")) {\n        scene.moveRectangleBy(0, -1);\n    } else if (key.equals(\"LEFT\")) {\n        scene.moveRectangleBy(-1, 0);\n    } else if (key.equals(\"RIGHT\")) {\n        scene.moveRectangleBy(1, 0);\n    }\n}\n","name":"keyPressed","className":"KeyStrokeListener","variables":{"KeyStroke":1,"key":5,"scene":4},"constants":{"\"\"":1,"0":4,"1":4,"\"UP\"":1,"\"DOWN\"":1,"\"pressed \"":1,"\"LEFT\"":1,"\"RIGHT\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void keyTyped(KeyEvent event) {\n}\n","name":"keyTyped","className":"KeyStrokeListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void keyReleased(KeyEvent event) {\n}\n","name":"keyReleased","className":"KeyStrokeListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame3","methodCalls":{"add":1,"setSize":1,"addKeyListener":1,"setFocusable":1,"addMouseListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"MouseListener":1,"MousePressListener":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":18,"AssignExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public RectangleFrame3() {\n    scene = new RectangleComponent3();\n    add(scene);\n    MouseListener listener = new MousePressListener();\n    scene.addMouseListener(listener);\n    scene.addKeyListener(new KeyStrokeListener());\n    scene.setFocusable(true);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"RectangleFrame3","className":"RectangleFrame3","variables":{"listener":1,"scene":4},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"RectangleComponent3","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public RectangleComponent3() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent3","className":"RectangleComponent3","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"constants":{},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Graphics2D":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent3","variables":{"g":1,"g2":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"setLocation":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   */\npublic void moveRectangleTo(int x, int y) {\n    box.setLocation(x, y);\n    repaint();\n}\n","name":"moveRectangleTo","className":"RectangleComponent3","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle to the given location x the x-position of the new location y the y-position of the new location","comments":"\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"repaint":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   */\npublic void moveRectangleBy(int dx, int dy) {\n    box.translate(dx, dy);\n    repaint();\n}\n","name":"moveRectangleBy","className":"RectangleComponent3","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle by a given amount dx the amount to move in the x-direction dy the amount to move in the y-direction","comments":"\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"RectangleFrame3":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame3();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer3","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getBalance":2,"deposit":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":14,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent event) {\n    double interest = account.getBalance() * INTEREST_RATE / 100;\n    account.deposit(interest);\n    label.setText(\"balance: \" + account.getBalance());\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"interest":1,"INTEREST_RATE":1,"label":1,"account":3},"constants":{"100":1,"\"balance: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"setVisible":1,"getBalance":3,"setSize":1,"addActionListener":1,"deposit":1,"setDefaultCloseOperation":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables","PolyMorphism","InnerClass"],"types":{"JPanel":1,"ActionListener":1,"JFrame":1,"double":1,"AddInterestListener":1,"JButton":1,"JLabel":1,"BankAccount":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":4,"BooleanLiteralExpr":1,"StringLiteralExpr":3,"NameExpr":52,"FieldAccessExpr":1,"MethodCallExpr":12},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    // The button to trigger the calculation\n    JButton button = new JButton(\"Add Interest\");\n    // The application adds interest to this bank account\n    final BankAccount account = new BankAccount(INITIAL_BALANCE);\n    // The label for displaying the results\n    final JLabel label = new JLabel(\"balance: \" + account.getBalance());\n    // The panel that holds the user interface components\n    JPanel panel = new JPanel();\n    panel.add(button);\n    panel.add(label);\n    frame.add(panel);\n    class AddInterestListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            double interest = account.getBalance() * INTEREST_RATE / 100;\n            account.deposit(interest);\n            label.setText(\"balance: \" + account.getBalance());\n        }\n    }\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer2","variables":{"button":2,"actionPerformed":1,"interest":1,"AddInterestListener":1,"INTEREST_RATE":1,"listener":1,"label":2,"INITIAL_BALANCE":1,"panel":3,"event":1,"account":5,"frame":5},"constants":{"100":1,"true":1,"\"Add Interest\"":1,"\"balance: \"":2},"javaDoc":"","comments":"The button to trigger the calculation The application adds interest to this bank account The label for displaying the results The panel that holds the user interface components ","isEmpty":false,"hasInnerClass":false,"lineCount":14,"modifier":9}
{"paramTypes":["Object[]","Measurer"],"returnType":"double","methodCalls":{"measure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"Object":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":14,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   */\npublic static double average(Object[] objects, Measurer meas) {\n    double sum = 0;\n    for (Object obj : objects) {\n        sum = sum + meas.measure(obj);\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":1,"objects":1,"meas":1,"sum":4},"constants":{"0":3},"javaDoc":"Computes the average of the measures of the given objects objects an array of objects meas the measurer for the objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   */\ndouble measure(Object anObject);\n","name":"measure","className":"Measurer","variables":{},"constants":{},"javaDoc":"Computes the measure of an object anObject the object to be measured the measure","comments":"\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{"getHeight":1,"getWidth":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"double":1,"Rectangle":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":1,"CastExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public double measure(Object anObject) {\n    Rectangle aRectangle = (Rectangle) anObject;\n    double area = aRectangle.getWidth() * aRectangle.getHeight();\n    return area;\n}\n","name":"measure","className":"AreaMeasurer","variables":{"area":2,"aRectangle":3,"anObject":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Measurer":1,"double":1,"Rectangle[]":1,"AreaMeasurer":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":12,"VariableDeclarationExpr":3,"ArrayInitializerExpr":1,"BinaryExpr":1,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Measurer areaMeas = new AreaMeasurer();\n    Rectangle[] rects = new Rectangle[] { new Rectangle(5, 10, 20, 30), new Rectangle(10, 20, 30, 40), new Rectangle(20, 30, 5, 15) };\n    double averageArea = Data.average(rects, areaMeas);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 625\");\n}\n","name":"main","className":"MeasurerTester","variables":{"areaMeas":1,"rects":1,"Data":1,"averageArea":2},"constants":{"\"Average area: \"":1,"15":1,"\"Expected: 625\"":1,"5":2,"40":1,"30":3,"20":3,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object[]","Measurer"],"returnType":"double","methodCalls":{"measure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"Object":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":14,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   */\npublic static double average(Object[] objects, Measurer meas) {\n    double sum = 0;\n    for (Object obj : objects) {\n        sum = sum + meas.measure(obj);\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":1,"objects":1,"meas":1,"sum":4},"constants":{"0":3},"javaDoc":"Computes the average of the measures of the given objects objects an array of objects meas the measurer for the objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   */\ndouble measure(Object anObject);\n","name":"measure","className":"Measurer","variables":{},"constants":{},"javaDoc":"Computes the measure of an object anObject the object to be measured the measure","comments":"\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":2,"getHeight":1,"getWidth":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Measurer":1,"double":2,"Rectangle[]":1,"Rectangle":1,"BankAccount[]":1},"expressions":{"IntegerLiteralExpr":19,"ObjectCreationExpr":6,"VariableDeclarationExpr":6,"ArrayAccessExpr":3,"LambdaExpr":2,"BinaryExpr":3,"NameExpr":44,"StringLiteralExpr":4,"AssignExpr":3,"ArrayInitializerExpr":1,"CastExpr":2,"FieldAccessExpr":4,"EnclosedExpr":1,"ArrayCreationExpr":2,"MethodCallExpr":9},"statements":{"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    BankAccount[] accounts = new BankAccount[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    double averageBalance = Data.average(accounts, (Object obj) -> ((BankAccount) obj).getBalance());\n    System.out.println(\"Average balance: \" + averageBalance);\n    System.out.println(\"Expected: 4000\");\n    Rectangle[] rects = new Rectangle[] { new Rectangle(5, 10, 20, 30), new Rectangle(10, 20, 30, 40), new Rectangle(20, 30, 5, 15) };\n    Measurer areaMeas = (Object obj) -> {\n        Rectangle r = (Rectangle) obj;\n        return r.getWidth() * r.getHeight();\n    };\n    double averageArea = Data.average(rects, areaMeas);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 625\");\n}\n","name":"main","className":"MeasurerTester","variables":{"r":3,"obj":4,"Data":2,"rects":1,"areaMeas":1,"accounts":4,"averageBalance":2,"averageArea":2},"constants":{"\"Average balance: \"":1,"15":1,"\"Expected: 625\"":1,"2000":1,"\"Expected: 4000\"":1,"0":2,"1":1,"2":1,"\"Average area: \"":1,"3":1,"5":2,"10000":1,"40":1,"30":3,"20":3,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":12,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"RectangleFrame":1,"JFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame();\n    frame.setTitle(\"An animated rectangle\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer","variables":{"frame":4},"constants":{"true":1,"\"An animated rectangle\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"RectangleComponent","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public RectangleComponent() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent","className":"RectangleComponent","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"constants":{},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Graphics2D":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent","variables":{"g":1,"g2":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"repaint":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   */\npublic void moveRectangleBy(int dx, int dy) {\n    box.translate(dx, dy);\n    repaint();\n}\n","name":"moveRectangleBy","className":"RectangleComponent","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle by a given amount dx the amount to move in the x-direction dy the amount to move in the y-direction","comments":"\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"moveRectangleBy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    scene.moveRectangleBy(1, 1);\n}\n","name":"actionPerformed","className":"TimerListener","variables":{"scene":1},"constants":{"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame","methodCalls":{"add":1,"setSize":1,"start":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables","PolyMorphism"],"types":{"ActionListener":1,"Timer":1,"TimerListener":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":13,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":7},"text":"public RectangleFrame() {\n    scene = new RectangleComponent();\n    add(scene);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    ActionListener listener = new TimerListener();\n    // Milliseconds between timer ticks\n    final int DELAY = 100;\n    Timer t = new Timer(DELAY, listener);\n    t.start();\n}\n","name":"RectangleFrame","className":"RectangleFrame","variables":{"t":2,"listener":2,"DELAY":2,"scene":1},"constants":{"100":1},"javaDoc":"","comments":"Milliseconds between timer ticks ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getBalance":2,"deposit":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent event) {\n    // The listener method accesses the account variable\n    // from the surrounding block\n    double interest = account.getBalance() * INTEREST_RATE / 100;\n    account.deposit(interest);\n    System.out.println(\"balance: \" + account.getBalance());\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"interest":1,"INTEREST_RATE":1,"account":3},"constants":{"100":1,"\"balance: \"":1},"javaDoc":"","comments":"The listener method accesses the account variable from the surrounding block ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"getBalance":2,"setSize":1,"addActionListener":1,"deposit":1,"setDefaultCloseOperation":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"JFrame":1,"double":1,"AddInterestListener":1,"JButton":1,"BankAccount":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":3,"BooleanLiteralExpr":1,"StringLiteralExpr":2,"NameExpr":43,"FieldAccessExpr":2,"MethodCallExpr":9},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    // The button to trigger the calculation\n    JButton button = new JButton(\"Add Interest\");\n    frame.add(button);\n    // The application adds interest to this bank account\n    final BankAccount account = new BankAccount(INITIAL_BALANCE);\n    class AddInterestListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            // The listener method accesses the account variable\n            // from the surrounding block\n            double interest = account.getBalance() * INTEREST_RATE / 100;\n            account.deposit(interest);\n            System.out.println(\"balance: \" + account.getBalance());\n        }\n    }\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer1","variables":{"button":2,"actionPerformed":1,"interest":1,"AddInterestListener":1,"INTEREST_RATE":1,"listener":1,"INITIAL_BALANCE":1,"event":1,"account":4,"frame":5},"constants":{"100":1,"true":1,"\"Add Interest\"":1,"\"balance: \"":1},"javaDoc":"","comments":"The button to trigger the calculation The application adds interest to this bank account The listener method accesses the account variable from the surrounding block ","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n// implementationfilled in later\n}\n","name":"BankAccount","className":"BankAccount","variables":{},"constants":{},"javaDoc":"Constructs a bank account with a zero balance","comments":"implementationfilled in later \n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n// implementationfilled in later\n}\n","name":"BankAccount","className":"BankAccount","variables":{},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"implementationfilled in later \n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n// implementationfilled in later\n}\n","name":"deposit","className":"BankAccount","variables":{},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"implementationfilled in later \n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n// implementationfilled in later\n}\n","name":"withdraw","className":"BankAccount","variables":{},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"implementationfilled in later \n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    // implementationfilled in later\n    return 0;\n}\n","name":"getBalance","className":"BankAccount","variables":{},"constants":{"0":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"implementationfilled in later \n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"CashRegister","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":4,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a cash register with no money in it.\n      @param rate the tax rate for taxable purchases\n   */\npublic CashRegister(double rate) {\n    taxRate = rate;\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"taxRate":1,"rate":1,"purchase":1,"payment":1},"constants":{"0":2},"javaDoc":"Constructs a cash register with no money in it rate the tax rate for taxable purchases","comments":"\n      Constructs a cash register with no money in it.\n      @param rate the tax rate for taxable purchases\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the sale of a tax-free item.\n      @param amount the price of the item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":1,"purchase":2},"constants":{},"javaDoc":"Records the sale of a tax-free item amount the price of the item","comments":"\n      Records the sale of a tax-free item.\n      @param amount the price of the item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the sale of a taxable item.\n      @param amount the price of the item\n   */\npublic void recordTaxablePurchase(double amount) {\n    taxablePurchase = taxablePurchase + amount;\n}\n","name":"recordTaxablePurchase","className":"CashRegister","variables":{"amount":1,"taxablePurchase":2},"constants":{},"javaDoc":"Records the sale of a taxable item amount the price of the item","comments":"\n      Records the sale of a taxable item.\n      @param amount the price of the item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   */\npublic void receivePayment(double amount) {\n    payment = payment + amount;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"amount":1,"payment":2},"constants":{},"javaDoc":"Processes a payment received from the customer amount the amount of the payment","comments":"\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Processes the sales tax due.\n      @return the sales tax due\n   */\npublic double getSalesTax() {\n    return taxablePurchase * taxRate / 100;\n}\n","name":"getSalesTax","className":"CashRegister","variables":{"taxRate":1,"taxablePurchase":1},"constants":{"100":1},"javaDoc":"Processes the sales tax due the sales tax due","comments":"\n      Processes the sales tax due.\n      @return the sales tax due\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":6,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase - get;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"get":1,"purchase":2,"payment":2},"constants":{"0":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":2,"receivePayment":1,"giveChange":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"CashRegister":1,"double":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"DoubleLiteralExpr":2,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(29.50);\n    register.recordPurchase(9.25);\n    register.receivePayment(50);\n    double change = register.giveChange();\n    System.out.println(change);\n    System.out.println(\"Expected: 11.25\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"change":1,"register":5},"constants":{"9.25":1,"29.50":1,"50":1,"\"Expected: 11.25\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getValue":2,"click":3,"System.out.print":2,"resetTo":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Counter":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":41,"StringLiteralExpr":2,"FieldAccessExpr":4,"MethodCallExpr":10,"AssignExpr":1},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Counter tally = new Counter();\n    tally.click();\n    tally.click();\n    // Sets result to 2\n    int result = tally.getValue();\n    System.out.print(\"result: \");\n    System.out.println(result);\n    tally.resetTo(10);\n    tally.click();\n    // Sets result to 11\n    result = tally.getValue();\n    System.out.print(\"result: \");\n    System.out.println(result);\n}\n","name":"main","className":"CounterDemo","variables":{"result":2,"tally":7},"constants":{"\"result: \"":2,"10":1},"javaDoc":"","comments":"Sets result to 2 Sets result to 11 ","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Advances the value of this counter by 1.\n   */\npublic void click() {\n    int updatedValue = value + 1;\n    // updatedValue is a local variable\n    value = updatedValue;\n// updatedValue is forgotten here\n}\n","name":"click","className":"Counter","variables":{"value":2,"updatedValue":2},"constants":{"1":1},"javaDoc":"Advances the value of this counter by 1","comments":"updatedValue is forgotten here updatedValue is a local variable \n      Advances the value of this counter by 1.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Resets the value of this counter to a given value.\n   */\npublic void resetTo(int newValue) // newValue is a parameter variable\n// newValue is initialized with the argument of a method call\n{\n    value = newValue;\n// newValue is forgotten here     \n}\n","name":"resetTo","className":"Counter","variables":{"newValue":1,"value":1},"constants":{},"javaDoc":"Resets the value of this counter to a given value","comments":"newValue is a parameter variable newValue is initialized with the argument of a method call newValue is forgotten here \n      Resets the value of this counter to a given value.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current value of this counter.\n      @return the current value\n   */\npublic int getValue() {\n    return value;\n}\n","name":"getValue","className":"Counter","variables":{"value":1},"constants":{},"javaDoc":"Gets the current value of this counter the current value","comments":"\n      Gets the current value of this counter.\n      @return the current value\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"ItalianFlag":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    ItalianFlag flag = new ItalianFlag(100, 100, 90);\n    flag.draw(g2);\n}\n","name":"paintComponent","className":"ItalianFlagComponent","variables":{"flag":2,"g":1,"g2":1},"constants":{"100":2,"90":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"ItalianFlag","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public ItalianFlag(int x, int y, int aWidth) {\n    xLeft = x;\n    yTop = y;\n    width = aWidth;\n}\n","name":"ItalianFlag","className":"ItalianFlag","variables":{"xLeft":1,"yTop":1,"aWidth":1,"x":1,"width":1,"y":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["Graphics2D"],"returnType":"void","methodCalls":{"setColor":3,"draw":2,"fill":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Line2D.Double":2,"Rectangle":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":18,"VariableDeclarationExpr":4,"BinaryExpr":25,"NameExpr":57,"FieldAccessExpr":3,"MethodCallExpr":7},"statements":{"ExpressionStmt":11},"text":"public void draw(Graphics2D g2) {\n    Rectangle leftRectangle = new Rectangle(xLeft, yTop, width / 3, width * 2 / 3);\n    Rectangle rightRectangle = new Rectangle(xLeft + 2 * width / 3, yTop, width / 3, width * 2 / 3);\n    Line2D.Double topLine = new Line2D.Double(xLeft + width / 3, yTop, xLeft + width * 2 / 3, yTop);\n    Line2D.Double bottomLine = new Line2D.Double(xLeft + width / 3, yTop + width * 2 / 3, xLeft + width * 2 / 3, yTop + width * 2 / 3);\n    g2.setColor(Color.GREEN);\n    g2.fill(leftRectangle);\n    g2.setColor(Color.RED);\n    g2.fill(rightRectangle);\n    g2.setColor(Color.BLACK);\n    g2.draw(topLine);\n    g2.draw(bottomLine);\n}\n","name":"draw","className":"ItalianFlag","variables":{"xLeft":6,"rightRectangle":1,"topLine":1,"leftRectangle":1,"yTop":6,"width":11,"g2":7,"bottomLine":1},"constants":{"2":7,"3":11},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"ItalianFlagComponent":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":16,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    ItalianFlagComponent component = new ItalianFlagComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"ItalianFlagViewer","variables":{"component":1,"frame":5},"constants":{"300":1,"400":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"constants":{"0":2},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the sale of an item.\n      @param amount the price of the item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":1,"purchase":2},"constants":{},"javaDoc":"Records the sale of an item amount the price of the item","comments":"\n      Records the sale of an item.\n      @param amount the price of the item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   */\npublic void receivePayment(double amount) {\n    payment = payment + amount;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"amount":1,"payment":2},"constants":{},"javaDoc":"Processes a payment received from the customer amount the amount of the payment","comments":"\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":5,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"constants":{"0":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":2,"receivePayment":1,"giveChange":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"CashRegister":1,"double":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"DoubleLiteralExpr":2,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(29.50);\n    register.recordPurchase(9.25);\n    register.receivePayment(50);\n    double change = register.giveChange();\n    System.out.println(change);\n    System.out.println(\"Expected: 11.25\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"change":1,"register":5},"constants":{"9.25":1,"29.50":1,"50":1,"\"Expected: 11.25\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"Menu","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":2,"StringLiteralExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a menu with no options.\n   */\npublic Menu() {\n    menuText = \"\";\n    optionCount = 0;\n}\n","name":"Menu","className":"Menu","variables":{"menuText":1,"optionCount":1},"constants":{"\"\"":1,"0":1},"javaDoc":"Constructs a menu with no options","comments":"\n      Constructs a menu with no options.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":5,"NameExpr":6,"StringLiteralExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Adds an option to the end of this menu.\n      @param option the option to add\n   */\npublic void addOption(String option) {\n    optionCount = optionCount + 1;\n    menuText = menuText + optionCount + \") \" + option + \"\\n\";\n}\n","name":"addOption","className":"Menu","variables":{"optionCount":3,"menuText":2,"option":1},"constants":{"1":1,"\") \"":1,"\"\\n\"":1},"javaDoc":"Adds an option to the end of this menu option the option to add","comments":"\n      Adds an option to the end of this menu.\n      @param option the option to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Displays the menu on the console.\n   */\npublic void display() {\n    System.out.println(menuText);\n}\n","name":"display","className":"Menu","variables":{},"constants":{},"javaDoc":"Displays the menu on the console","comments":"\n      Displays the menu on the console.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addOption":4,"display":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Menu":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":15,"StringLiteralExpr":4,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Menu mainMenu = new Menu();\n    mainMenu.addOption(\"Open new account\");\n    mainMenu.addOption(\"Log into existing account\");\n    mainMenu.addOption(\"Help\");\n    mainMenu.addOption(\"Quit\");\n    mainMenu.display();\n}\n","name":"main","className":"MenuDemo","variables":{"mainMenu":6},"constants":{"\"Open new account\"":1,"\"Quit\"":1,"\"Help\"":1,"\"Log into existing account\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getValue":1,"click":2,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Counter":1,"int":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Counter tally = new Counter();\n    tally.click();\n    tally.click();\n    // Sets result to 2\n    int result = tally.getValue();\n    System.out.print(\"result: \");\n    System.out.println(result);\n}\n","name":"main","className":"CounterDemo","variables":{"result":1,"tally":4},"constants":{"\"result: \"":1},"javaDoc":"","comments":"Sets result to 2 ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current value of this counter.\n      @return the current value\n   */\npublic int getValue() {\n    return value;\n}\n","name":"getValue","className":"Counter","variables":{"value":1},"constants":{},"javaDoc":"Gets the current value of this counter the current value","comments":"\n      Gets the current value of this counter.\n      @return the current value\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Advances the value of this counter by 1.\n   */\npublic void click() {\n    value = value + 1;\n}\n","name":"click","className":"Counter","variables":{"value":2},"constants":{"1":1},"javaDoc":"Advances the value of this counter by 1","comments":"\n      Advances the value of this counter by 1.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Resets the value of this counter to 0.\n   */\npublic void reset() {\n    value = 0;\n}\n","name":"reset","className":"Counter","variables":{"value":1},"constants":{"0":1},"javaDoc":"Resets the value of this counter to 0","comments":"\n      Resets the value of this counter to 0.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Counter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a counter with a given value\n   */\npublic Counter(int value) {\n    this.value = value;\n// this. resolves the conflict between an instance variable\n// and a local variable with the same name\n}\n","name":"Counter","className":"Counter","variables":{"value":1},"constants":{},"javaDoc":"Constructs a counter with a given value","comments":"this resolves the conflict between an instance variable and a local variable with the same name \n      Constructs a counter with a given value\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Counter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public Counter() {\n    this(0);\n// Invokes the Counter(int value) constructor with value = 0\n}\n","name":"Counter","className":"Counter","variables":{},"constants":{"0":1},"javaDoc":"","comments":"Invokes the Counter(int value) constructor with value = 0 ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Advances the value of this counter by 1.\n   */\npublic void click() {\n    this.value = this.value + 1;\n// Using this makes it clear that the instance variable is updated\n}\n","name":"click","className":"Counter","variables":{},"constants":{"1":1},"javaDoc":"Advances the value of this counter by 1","comments":"Using this makes it clear that the instance variable is updated \n      Advances the value of this counter by 1.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getValue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the previous value of this counter.\n      @return the previous value\n   */\npublic int getPrevious() {\n    return getValue() - 1;\n// When you call a method without an object, it is invoked\n// on the this reference, i.e this.getValue().\n}\n","name":"getPrevious","className":"Counter","variables":{},"constants":{"1":1},"javaDoc":"Gets the previous value of this counter the previous value","comments":"When you call a method without an object it is invoked on the this reference i e this getValue() \n      Gets the previous value of this counter.\n      @return the previous value\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current value of this counter.\n      @return the current value\n   */\npublic int getValue() {\n    return value;\n// Or, if you prefer, return this.value;\n}\n","name":"getValue","className":"Counter","variables":{"value":1},"constants":{},"javaDoc":"Gets the current value of this counter the current value","comments":"Or if you prefer return this value; \n      Gets the current value of this counter.\n      @return the current value\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"CarComponent":1,"JFrame":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setTitle(\"Two cars\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    CarComponent component = new CarComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"CarViewer","variables":{"component":1,"frame":6},"constants":{"300":1,"400":1,"true":1,"\"Two cars\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["int","int"],"returnType":"Car","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a car with a given top left corner.\n      @param x the x coordinate of the top left corner\n      @param y the y coordinate of the top left corner\n   */\npublic Car(int x, int y) {\n    xLeft = x;\n    yTop = y;\n}\n","name":"Car","className":"Car","variables":{"xLeft":1,"yTop":1,"x":1,"y":1},"constants":{},"javaDoc":"Constructs a car with a given top left corner x the x coordinate of the top left corner y the y coordinate of the top left corner","comments":"\n      Constructs a car with a given top left corner.\n      @param x the x coordinate of the top left corner\n      @param y the y coordinate of the top left corner\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Graphics2D"],"returnType":"void","methodCalls":{"draw":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"Line2D.Double":3,"Rectangle":1,"Ellipse2D.Double":2,"Point2D.Double":4},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":17,"VariableDeclarationExpr":10,"BinaryExpr":11,"NameExpr":44,"MethodCallExpr":6},"statements":{"ExpressionStmt":16},"text":"/**\n      Draws the car.\n      @param g2 the graphics context\n   */\npublic void draw(Graphics2D g2) {\n    Rectangle body = new Rectangle(xLeft, yTop + 10, 60, 10);\n    Ellipse2D.Double frontTire = new Ellipse2D.Double(xLeft + 10, yTop + 20, 10, 10);\n    Ellipse2D.Double rearTire = new Ellipse2D.Double(xLeft + 40, yTop + 20, 10, 10);\n    // The bottom of the front windshield\n    Point2D.Double r1 = new Point2D.Double(xLeft + 10, yTop + 10);\n    // The front of the roof\n    Point2D.Double r2 = new Point2D.Double(xLeft + 20, yTop);\n    // The rear of the roof\n    Point2D.Double r3 = new Point2D.Double(xLeft + 40, yTop);\n    // The bottom of the rear windshield\n    Point2D.Double r4 = new Point2D.Double(xLeft + 50, yTop + 10);\n    Line2D.Double frontWindshield = new Line2D.Double(r1, r2);\n    Line2D.Double roofTop = new Line2D.Double(r2, r3);\n    Line2D.Double rearWindshield = new Line2D.Double(r3, r4);\n    g2.draw(body);\n    g2.draw(frontTire);\n    g2.draw(rearTire);\n    g2.draw(frontWindshield);\n    g2.draw(roofTop);\n    g2.draw(rearWindshield);\n}\n","name":"draw","className":"Car","variables":{"xLeft":7,"r2":3,"r3":3,"r4":2,"rearTire":1,"yTop":7,"rearWindshield":1,"g2":6,"body":1,"frontTire":1,"frontWindshield":1,"roofTop":1,"r1":2},"constants":{"60":1,"50":1,"40":2,"20":3,"10":10},"javaDoc":"Draws the car g2 the graphics context","comments":"The bottom of the front windshield The front of the roof The rear of the roof The bottom of the rear windshield \n      Draws the car.\n      @param g2 the graphics context\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":16,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getHeight":1,"getWidth":1,"draw":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Car":2,"int":2,"Graphics2D":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"BinaryExpr":2,"CastExpr":1,"NameExpr":15,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    Car car1 = new Car(0, 0);\n    int x = getWidth() - 60;\n    int y = getHeight() - 30;\n    Car car2 = new Car(x, y);\n    car1.draw(g2);\n    car2.draw(g2);\n}\n","name":"paintComponent","className":"CarComponent","variables":{"car2":2,"car1":2,"g":1,"x":2,"y":2,"g2":1},"constants":{"0":2,"60":1,"30":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1,"withdraw":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"/**\n      Tests the methods of the BankAccount class.\n      @param args not used\n   */\npublic static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount();\n    harrysChecking.deposit(2000);\n    harrysChecking.withdraw(500);\n    System.out.println(harrysChecking.getBalance());\n    System.out.println(\"Expected: 1500\");\n}\n","name":"main","className":"BankAccountTester","variables":{"harrysChecking":4},"constants":{"500":1,"2000":1,"\"Expected: 1500\"":1},"javaDoc":"Tests the methods of the BankAccount class args not used","comments":"\n      Tests the methods of the BankAccount class.\n      @param args not used\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"isPalindrome":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":2,"StringLiteralExpr":4,"NameExpr":28,"FieldAccessExpr":4,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    String sentence1 = \"Madam, I'm Adam!\";\n    System.out.println(sentence1);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence1));\n    String sentence2 = \"Sir, I'm Eve!\";\n    System.out.println(sentence2);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence2));\n}\n","name":"main","className":"Palindromes","variables":{"sentence1":1,"sentence2":1},"constants":{"\"Madam, I'm Adam!\"":1,"\"Palindrome: \"":2,"\"Sir, I'm Eve!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"isPalindrome":1,"length":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   */\npublic static boolean isPalindrome(String text) {\n    return isPalindrome(text, 0, text.length() - 1);\n}\n","name":"isPalindrome","className":"Palindromes","variables":{"text":1},"constants":{"0":1,"1":1},"javaDoc":"Tests whether a text is a palindrome text a string that is being checked true if text is a palindrome false otherwise","comments":"\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String","int","int"],"returnType":"boolean","methodCalls":{"isPalindrome":3,"toLowerCase":2,"charAt":2,"isLetter":3},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"char":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":7,"BooleanLiteralExpr":2,"NameExpr":45,"UnaryExpr":1,"MethodCallExpr":10},"statements":{"IfStmt":4,"BlockStmt":7,"ReturnStmt":5,"ExpressionStmt":2},"text":"/**\n      Tests whether a substring is a palindrome.\n      @param text a string that is being checked\n      @param start the index of the first character of the substring\n      @param end the index of the last character of the substring\n      @return true if the substring is a palindrome\n   */\npublic static boolean isPalindrome(String text, int start, int end) {\n    // Separate case for substrings of length 0 and 1.\n    if (start >= end) {\n        return true;\n    } else {\n        // Get first and last characters, converted to lowercase.\n        char first = Character.toLowerCase(text.charAt(start));\n        char last = Character.toLowerCase(text.charAt(end));\n        if (Character.isLetter(first) && Character.isLetter(last)) {\n            if (first == last) {\n                // Test substring that doesnt contain the matching letters.\n                return isPalindrome(text, start + 1, end - 1);\n            } else {\n                return false;\n            }\n        } else if (!Character.isLetter(last)) {\n            // Test substring that doesnt contain the last character.\n            return isPalindrome(text, start, end - 1);\n        } else {\n            // Test substring that doesnt contain the first character.\n            return isPalindrome(text, start + 1, end);\n        }\n    }\n}\n","name":"isPalindrome","className":"Palindromes","variables":{"Character":5,"last":2,"start":3,"end":3,"text":2,"first":2},"constants":{"1":4,"true":1,"false":1},"javaDoc":"Tests whether a substring is a palindrome text a string that is being checked start the index of the first character of the substring end the index of the last character of the substring true if the substring is a palindrome","comments":"Separate case for substrings of length 0 and 1 Get first and last characters converted to lowercase Test substring that doesnt contain the matching letters Test substring that doesnt contain the last character Test substring that doesnt contain the first character \n      Tests whether a substring is a palindrome.\n      @param text a string that is being checked\n      @param start the index of the first character of the substring\n      @param end the index of the last character of the substring\n      @return true if the substring is a palindrome\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"Evaluator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an evaluator.\n      @param anExpression a string containing the expression\n      to be evaluated\n   */\npublic Evaluator(String anExpression) {\n    tokenizer = new ExpressionTokenizer(anExpression);\n}\n","name":"Evaluator","className":"Evaluator","variables":{"anExpression":1,"tokenizer":1},"constants":{},"javaDoc":"Constructs an evaluator anExpression a string containing the expression to be evaluated","comments":"\n      Constructs an evaluator.\n      @param anExpression a string containing the expression\n      to be evaluated\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"nextToken":1,"peekToken":1,"getTermValue":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"String":1,"int":2},"expressions":{"VariableDeclarationExpr":4,"BooleanLiteralExpr":2,"BinaryExpr":3,"NameExpr":28,"StringLiteralExpr":3,"UnaryExpr":1,"MethodCallExpr":7,"AssignExpr":3},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Evaluates the expression.\n      @return the value of the expression.\n   */\npublic int getExpressionValue() {\n    int value = getTermValue();\n    boolean done = false;\n    while (!done) {\n        String next = tokenizer.peekToken();\n        if (\"+\".equals(next) || \"-\".equals(next)) {\n            // Discard \"+\" or \"-\"\n            tokenizer.nextToken();\n            int value2 = getTermValue();\n            if (\"+\".equals(next)) {\n                value = value + value2;\n            } else {\n                value = value - value2;\n            }\n        } else {\n            done = true;\n        }\n    }\n    return value;\n}\n","name":"getExpressionValue","className":"Evaluator","variables":{"next":1,"value2":3,"value":6,"done":3,"tokenizer":2},"constants":{"\"-\"":1,"false":1,"true":1,"\"+\"":2},"javaDoc":"Evaluates the expression the value of the expression","comments":"Discard \"+\" or \"-\" \n      Evaluates the expression.\n      @return the value of the expression.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getFactorValue":2,"nextToken":1,"peekToken":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"String":1,"int":2},"expressions":{"VariableDeclarationExpr":4,"BooleanLiteralExpr":2,"BinaryExpr":3,"NameExpr":28,"StringLiteralExpr":3,"UnaryExpr":1,"MethodCallExpr":7,"AssignExpr":3},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Evaluates the next term found in the expression.\n      @return the value of the term\n   */\npublic int getTermValue() {\n    int value = getFactorValue();\n    boolean done = false;\n    while (!done) {\n        String next = tokenizer.peekToken();\n        if (\"*\".equals(next) || \"/\".equals(next)) {\n            tokenizer.nextToken();\n            int value2 = getFactorValue();\n            if (\"*\".equals(next)) {\n                value = value * value2;\n            } else {\n                value = value / value2;\n            }\n        } else {\n            done = true;\n        }\n    }\n    return value;\n}\n","name":"getTermValue","className":"Evaluator","variables":{"next":1,"value2":3,"value":6,"done":3,"tokenizer":2},"constants":{"\"/\"":1,"false":1,"true":1,"\"*\"":2},"javaDoc":"Evaluates the next term found in the expression the value of the term","comments":"\n      Evaluates the next term found in the expression.\n      @return the value of the term\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"parseInt":1,"nextToken":3,"peekToken":1,"getExpressionValue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":23,"StringLiteralExpr":1,"MethodCallExpr":7,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n      Evaluates the next factor found in the expression.\n      @return the value of the factor\n   */\npublic int getFactorValue() {\n    int value;\n    String next = tokenizer.peekToken();\n    if (\"(\".equals(next)) {\n        // Discard \"(\"\n        tokenizer.nextToken();\n        value = getExpressionValue();\n        // Discard \")\"\n        tokenizer.nextToken();\n    } else {\n        value = Integer.parseInt(tokenizer.nextToken());\n    }\n    return value;\n}\n","name":"getFactorValue","className":"Evaluator","variables":{"next":1,"Integer":1,"value":4,"tokenizer":4},"constants":{"\"(\"":1},"javaDoc":"Evaluates the next factor found in the expression the value of the factor","comments":"Discard \"(\" Discard \")\" \n      Evaluates the next factor found in the expression.\n      @return the value of the factor\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String"],"returnType":"ExpressionTokenizer","methodCalls":{"nextToken":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":6,"AssignExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a tokenizer.\n      @param anInput the string to tokenize\n   */\npublic ExpressionTokenizer(String anInput) {\n    input = anInput;\n    start = 0;\n    end = 0;\n    // Find the first token\n    nextToken();\n}\n","name":"ExpressionTokenizer","className":"ExpressionTokenizer","variables":{"input":1,"anInput":1,"start":1,"end":1},"constants":{"0":2},"javaDoc":"Constructs a tokenizer anInput the string to tokenize","comments":"Find the first token \n      Constructs a tokenizer.\n      @param anInput the string to tokenize\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"length":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":9,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Peeks at the next token without consuming it.\n      @return the next token or null if there are no more tokens\n   */\npublic String peekToken() {\n    if (start >= input.length()) {\n        return null;\n    } else {\n        return input.substring(start, end);\n    }\n}\n","name":"peekToken","className":"ExpressionTokenizer","variables":{"input":2,"start":1},"constants":{"null":1},"javaDoc":"Peeks at the next token without consuming it the next token or null if there are no more tokens","comments":"\n      Peeks at the next token without consuming it.\n      @return the next token or null if there are no more tokens\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"peekToken":1,"length":2,"isDigit":2,"charAt":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":33,"UnaryExpr":1,"MethodCallExpr":7,"AssignExpr":3},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":5},"text":"/**\n      Gets the next token and moves the tokenizer to the following token.\n      @return the next token or null if there are no more tokens\n   */\npublic String nextToken() {\n    String r = peekToken();\n    start = end;\n    if (start >= input.length()) {\n        return r;\n    }\n    if (Character.isDigit(input.charAt(start))) {\n        end = start + 1;\n        while (end < input.length() && Character.isDigit(input.charAt(end))) {\n            end++;\n        }\n    } else {\n        end = start + 1;\n    }\n    return r;\n}\n","name":"nextToken","className":"ExpressionTokenizer","variables":{"input":4,"r":3,"Character":2,"start":4,"end":5},"constants":{"1":2},"javaDoc":"Gets the next token and moves the tokenizer to the following token the next token or null if there are no more tokens","comments":"\n      Gets the next token and moves the tokenizer to the following token.\n      @return the next token or null if there are no more tokens\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"getExpressionValue":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":1,"Evaluator":1,"int":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter an expression: \");\n    String input = in.nextLine();\n    Evaluator e = new Evaluator(input);\n    int value = e.getExpressionValue();\n    System.out.println(input + \"=\" + value);\n}\n","name":"main","className":"ExpressionCalculator","variables":{"input":3,"in":2,"e":2,"value":2},"constants":{"\"Enter an expression: \"":1,"\"=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"solve":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    solve(new PartialSolution(0));\n}\n","name":"main","className":"EightQueens","variables":{},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["PartialSolution"],"returnType":"void","methodCalls":{"extend":1,"examine":1,"solve":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"PartialSolution":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":23,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":3,"ForeachStmt":1,"ExpressionStmt":3},"text":"/**\n      Prints all solutions to the problem that can be extended from \n      a given partial solution.\n      @param sol the partial solution\n   */\npublic static void solve(PartialSolution sol) {\n    int exam = sol.examine();\n    if (exam == PartialSolution.ACCEPT) {\n        System.out.println(sol);\n    } else if (exam == PartialSolution.CONTINUE) {\n        for (PartialSolution p : sol.extend()) {\n            solve(p);\n        }\n    }\n}\n","name":"solve","className":"EightQueens","variables":{"exam":3,"p":1,"sol":2},"constants":{},"javaDoc":"Prints all solutions to the problem that can be extended from a given partial solution sol the partial solution","comments":"\n      Prints all solutions to the problem that can be extended from \n      a given partial solution.\n      @param sol the partial solution\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["int"],"returnType":"PartialSolution","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a partial solution of a given size.\n      @param size the size\n   */\npublic PartialSolution(int size) {\n    queens = new Queen[size];\n}\n","name":"PartialSolution","className":"PartialSolution","variables":{"size":1,"queens":1},"constants":{},"javaDoc":"Constructs a partial solution of a given size size the size","comments":"\n      Constructs a partial solution of a given size.\n      @param size the size\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":24,"FieldAccessExpr":3,"UnaryExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":2,"BlockStmt":5,"ForStmt":2,"ReturnStmt":3},"text":"/**\n      Examines a partial solution.\n      @return one of ACCEPT, ABANDON, CONTINUE\n   */\npublic int examine() {\n    for (int i = 0; i < queens.length; i++) {\n        for (int j = i + 1; j < queens.length; j++) {\n            if (queens[i].attacks(queens[j])) {\n                return ABANDON;\n            }\n        }\n    }\n    if (queens.length == NQUEENS) {\n        return ACCEPT;\n    } else {\n        return CONTINUE;\n    }\n}\n","name":"examine","className":"PartialSolution","variables":{"CONTINUE":1,"ACCEPT":1,"ABANDON":1,"i":5,"j":4,"queens":2,"NQUEENS":1},"constants":{"0":1,"1":1},"javaDoc":"Examines a partial solution one of ACCEPT ABANDON CONTINUE","comments":"\n      Examines a partial solution.\n      @return one of ACCEPT, ABANDON, CONTINUE\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"PartialSolution[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"PartialSolution[]":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":3,"NameExpr":30,"FieldAccessExpr":4,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":3},"statements":{"BlockStmt":2,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Yields all extensions of this partial solution.\n      @return an array of partial solutions that extend this solution.\n   */\npublic PartialSolution[] extend() {\n    // Generate a new solution for each column\n    PartialSolution[] result = new PartialSolution[NQUEENS];\n    for (int i = 0; i < result.length; i++) {\n        int size = queens.length;\n        // The new solution has one more row than this one\n        result[i] = new PartialSolution(size + 1);\n        // Copy this solution into the new one\n        for (int j = 0; j < size; j++) {\n            result[i].queens[j] = queens[j];\n        }\n        // Append the new queen into the ith column\n        result[i].queens[size] = new Queen(size, i);\n    }\n    return result;\n}\n","name":"extend","className":"PartialSolution","variables":{"result":5,"size":5,"i":7,"j":5,"queens":1,"NQUEENS":1},"constants":{"0":2,"1":1},"javaDoc":"Yields all extensions of this partial solution an array of partial solutions that extend this solution","comments":"Generate a new solution for each column The new solution has one more row than this one Copy this solution into the new one Append the new queen into the ith column \n      Yields all extensions of this partial solution.\n      @return an array of partial solutions that extend this solution.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return Arrays.toString(queens);\n}\n","name":"toString","className":"PartialSolution","variables":{"Arrays":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Queen","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a queen at a given position.\n      @param r the row \n      @param c the column\n   */\npublic Queen(int r, int c) {\n    row = r;\n    column = c;\n}\n","name":"Queen","className":"Queen","variables":{"r":1,"c":1,"column":1,"row":1},"constants":{},"javaDoc":"Constructs a queen at a given position r the row c the column","comments":"\n      Constructs a queen at a given position.\n      @param r the row \n      @param c the column\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Queen"],"returnType":"boolean","methodCalls":{"abs":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":7,"NameExpr":22,"FieldAccessExpr":4,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this queen attacks another.\n      @param other the other queen\n      @return true if this and the other queen are in the same\n      row, column, or diagonal.\n   */\npublic boolean attacks(Queen other) {\n    return row == other.row || column == other.column || Math.abs(row - other.row) == Math.abs(column - other.column);\n}\n","name":"attacks","className":"Queen","variables":{"column":2,"row":2,"Math":2},"constants":{},"javaDoc":"Checks whether this queen attacks another other the other queen true if this and the other queen are in the same row column or diagonal","comments":"\n      Checks whether this queen attacks another.\n      @param other the other queen\n      @return true if this and the other queen are in the same\n      row, column, or diagonal.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":4,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"\" + \"abcdefgh\".charAt(column) + (row + 1);\n}\n","name":"toString","className":"Queen","variables":{"row":1},"constants":{"\"\"":1,"1":1,"\"abcdefgh\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"fib":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":2,"long":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":24,"StringLiteralExpr":3,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter n: \");\n    int n = in.nextInt();\n    for (int i = 1; i <= n; i++) {\n        long f = fib(i);\n        System.out.println(\"fib(\" + i + \") = \" + f);\n    }\n}\n","name":"main","className":"RecursiveFib","variables":{"in":2,"f":2,"i":4,"n":2},"constants":{"1":1,"\") = \"":1,"\"fib(\"":1,"\"Enter n: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int"],"returnType":"long","methodCalls":{"fib":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":4,"BinaryExpr":4,"NameExpr":7,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   */\npublic static long fib(int n) {\n    if (n <= 2) {\n        return 1;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n","name":"fib","className":"RecursiveFib","variables":{"n":3},"constants":{"1":2,"2":2},"javaDoc":"Computes a Fibonacci number n an integer the nth Fibonacci number","comments":"\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"isPalindrome":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":2,"StringLiteralExpr":4,"NameExpr":28,"FieldAccessExpr":4,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    String sentence1 = \"Madam, I'm Adam!\";\n    System.out.println(sentence1);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence1));\n    String sentence2 = \"Sir, I'm Eve!\";\n    System.out.println(sentence2);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence2));\n}\n","name":"main","className":"LoopPalindromes","variables":{"sentence1":1,"sentence2":1},"constants":{"\"Madam, I'm Adam!\"":1,"\"Palindrome: \"":2,"\"Sir, I'm Eve!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"toLowerCase":2,"length":1,"charAt":2,"isLetter":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"char":2,"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":4,"BooleanLiteralExpr":2,"NameExpr":41,"UnaryExpr":6,"MethodCallExpr":9},"statements":{"IfStmt":4,"WhileStmt":1,"BlockStmt":6,"ReturnStmt":2,"ExpressionStmt":8},"text":"/**\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   */\npublic static boolean isPalindrome(String text) {\n    int start = 0;\n    int end = text.length() - 1;\n    while (start < end) {\n        char first = Character.toLowerCase(text.charAt(start));\n        char last = Character.toLowerCase(text.charAt(end));\n        if (Character.isLetter(first) && Character.isLetter(last)) {\n            // Both are letters.\n            if (first == last) {\n                start++;\n                end--;\n            } else {\n                return false;\n            }\n        }\n        if (!Character.isLetter(last)) {\n            end--;\n        }\n        if (!Character.isLetter(first)) {\n            start++;\n        }\n    }\n    return true;\n}\n","name":"isPalindrome","className":"LoopPalindromes","variables":{"Character":6,"last":2,"start":4,"end":4,"text":3,"first":2},"constants":{"0":1,"1":1,"false":1,"true":1},"javaDoc":"Tests whether a text is a palindrome text a string that is being checked true if text is a palindrome false otherwise","comments":"Both are letters \n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"fib":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":2,"long":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":24,"StringLiteralExpr":3,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter n: \");\n    int n = in.nextInt();\n    for (int i = 1; i <= n; i++) {\n        long f = fib(i);\n        System.out.println(\"fib(\" + i + \") = \" + f);\n    }\n}\n","name":"main","className":"LoopFib","variables":{"in":2,"f":2,"i":4,"n":2},"constants":{"1":1,"\") = \"":1,"\"fib(\"":1,"\"Enter n: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int"],"returnType":"long","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":3,"int":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":12,"UnaryExpr":1,"AssignExpr":3},"statements":{"IfStmt":1,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":6},"text":"/**\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   */\npublic static long fib(int n) {\n    if (n <= 2) {\n        return 1;\n    } else {\n        long olderValue = 1;\n        long oldValue = 1;\n        long newValue = 1;\n        for (int i = 3; i <= n; i++) {\n            newValue = oldValue + olderValue;\n            olderValue = oldValue;\n            oldValue = newValue;\n        }\n        return newValue;\n    }\n}\n","name":"fib","className":"LoopFib","variables":{"newValue":4,"i":3,"oldValue":4,"n":2,"olderValue":3},"constants":{"1":4,"2":1,"3":1},"javaDoc":"Computes a Fibonacci number n an integer the nth Fibonacci number","comments":"\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"fib":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":1,"long":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter n: \");\n    int n = in.nextInt();\n    long f = fib(n);\n    System.out.println(\"fib(\" + n + \") = \" + f);\n}\n","name":"main","className":"RecursiveFibTracer","variables":{"in":2,"f":2,"n":2},"constants":{"\") = \"":1,"\"fib(\"":1,"\"Enter n: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["int"],"returnType":"long","methodCalls":{"fib":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"long":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":8,"NameExpr":23,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   */\npublic static long fib(int n) {\n    System.out.println(\"Entering fib: n = \" + n);\n    long f;\n    if (n <= 2) {\n        f = 1;\n    } else {\n        f = fib(n - 1) + fib(n - 2);\n    }\n    System.out.println(\"Exiting fib: n = \" + n + \" return value = \" + f);\n    return f;\n}\n","name":"fib","className":"RecursiveFibTracer","variables":{"f":5,"n":5},"constants":{"1":2,"2":2,"\"Exiting fib: n = \"":1,"\" return value = \"":1,"\"Entering fib: n = \"":1},"javaDoc":"Computes a Fibonacci number n an integer the nth Fibonacci number","comments":"\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"isPalindrome":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":2,"StringLiteralExpr":4,"NameExpr":28,"FieldAccessExpr":4,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    String sentence1 = \"Madam, I'm Adam!\";\n    System.out.println(sentence1);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence1));\n    String sentence2 = \"Sir, I'm Eve!\";\n    System.out.println(sentence2);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence2));\n}\n","name":"main","className":"Palindromes","variables":{"sentence1":1,"sentence2":1},"constants":{"\"Madam, I'm Adam!\"":1,"\"Palindrome: \"":2,"\"Sir, I'm Eve!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"isPalindrome":3,"toLowerCase":2,"length":1,"charAt":2,"isLetter":3,"substring":3},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"char":2,"String":3,"int":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":6,"BinaryExpr":6,"BooleanLiteralExpr":2,"NameExpr":51,"UnaryExpr":1,"MethodCallExpr":14},"statements":{"IfStmt":4,"BlockStmt":7,"ReturnStmt":5,"ExpressionStmt":6},"text":"/**\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   */\npublic static boolean isPalindrome(String text) {\n    int length = text.length();\n    // Separate case for shortest strings. \n    if (length <= 1) {\n        return true;\n    } else {\n        // Get first and last characters, converted to lowercase. \n        char first = Character.toLowerCase(text.charAt(0));\n        char last = Character.toLowerCase(text.charAt(length - 1));\n        if (Character.isLetter(first) && Character.isLetter(last)) {\n            // Both are letters. \n            if (first == last) {\n                // Remove both first and last character. \n                String shorter = text.substring(1, length - 1);\n                return isPalindrome(shorter);\n            } else {\n                return false;\n            }\n        } else if (!Character.isLetter(last)) {\n            // Remove last character. \n            String shorter = text.substring(0, length - 1);\n            return isPalindrome(shorter);\n        } else {\n            // Remove first character. \n            String shorter = text.substring(1);\n            return isPalindrome(shorter);\n        }\n    }\n}\n","name":"isPalindrome","className":"Palindromes","variables":{"Character":5,"last":2,"length":5,"text":6,"first":2,"shorter":3},"constants":{"0":2,"1":6,"true":1,"false":1},"javaDoc":"Tests whether a text is a palindrome text a string that is being checked true if text is a palindrome false otherwise","comments":"Separate case for shortest strings Get first and last characters converted to lowercase Both are letters Remove both first and last character Remove last character Remove first character \n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"find":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"File":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":2,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    File startingDirectory = new File(\"/home/myname\");\n    find(startingDirectory, \".java\");\n}\n","name":"main","className":"FileFinder2","variables":{"startingDirectory":1},"constants":{"\".java\"":1,"\"/home/myname\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["File","String"],"returnType":"void","methodCalls":{"find":1,"endsWith":1,"toString":1,"listFiles":1,"isDirectory":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"String":1,"File":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":23,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":2,"BlockStmt":4,"ForeachStmt":1,"ExpressionStmt":3},"text":"/**\n      Prints all files whose names end in a given extension.\n      @param aFile a file or directory\n      @param extension a file extension (such as \".java\")\n   */\npublic static void find(File aFile, String extension) {\n    if (aFile.isDirectory()) {\n        for (File child : aFile.listFiles()) {\n            find(child, extension);\n        }\n    } else {\n        String fileName = aFile.toString();\n        if (fileName.endsWith(extension)) {\n            System.out.println(fileName);\n        }\n    }\n}\n","name":"find","className":"FileFinder2","variables":{"fileName":2,"aFile":3,"child":1},"constants":{},"javaDoc":"Prints all files whose names end in a given extension aFile a file or directory extension a file extension (such as \" java\")","comments":"\n      Prints all files whose names end in a given extension.\n      @param aFile a file or directory\n      @param extension a file extension (such as \".java\")\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["File"],"returnType":"FileFinder","methodCalls":{"listFiles":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a file finder for a given directory tree.\n      @param startingDirectory the starting directory of the tree\n   */\npublic FileFinder(File startingDirectory) {\n    children = startingDirectory.listFiles();\n}\n","name":"FileFinder","className":"FileFinder","variables":{"startingDirectory":1,"children":1},"constants":{},"javaDoc":"Constructs a file finder for a given directory tree startingDirectory the starting directory of the tree","comments":"\n      Constructs a file finder for a given directory tree.\n      @param startingDirectory the starting directory of the tree\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"find":1,"endsWith":1,"toString":1,"isDirectory":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"FileFinder":1,"File":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":2,"BlockStmt":3,"ForeachStmt":1,"ExpressionStmt":4},"text":"/**\n      Prints all files whose names end in a given extension.\n      @param extension a file extension (such as \".java\")\n   */\npublic void find(String extension) {\n    for (File child : children) {\n        String fileName = child.toString();\n        if (child.isDirectory()) {\n            FileFinder finder = new FileFinder(child);\n            finder.find(extension);\n        } else if (fileName.endsWith(extension)) {\n            System.out.println(fileName);\n        }\n    }\n}\n","name":"find","className":"FileFinder","variables":{"fileName":2,"children":1,"child":4,"finder":2},"constants":{},"javaDoc":"Prints all files whose names end in a given extension extension a file extension (such as \" java\")","comments":"\n      Prints all files whose names end in a given extension.\n      @param extension a file extension (such as \".java\")\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"find":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"FileFinder":1,"File":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"StringLiteralExpr":2,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    File startingDirectory = new File(\"/home/myname\");\n    FileFinder finder = new FileFinder(startingDirectory);\n    finder.find(\".java\");\n}\n","name":"main","className":"FileFinderDemo","variables":{"startingDirectory":2,"finder":2},"constants":{"\".java\"":1,"\"/home/myname\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int"],"returnType":"Tower","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Constructs a tower holding a given number of disks of decreasing size.\n      @param ndisks the number of disks\n   */\npublic Tower(int ndisks) {\n    disks = new ArrayList<Integer>();\n    for (int d = ndisks; d >= 1; d--) {\n        disks.add(d);\n    }\n}\n","name":"Tower","className":"Tower","variables":{"disks":2,"d":3,"ndisks":1},"constants":{"1":1},"javaDoc":"Constructs a tower holding a given number of disks of decreasing size ndisks the number of disks","comments":"\n      Constructs a tower holding a given number of disks of decreasing size.\n      @param ndisks the number of disks\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Removes the top disk from this tower.\n      @return the size of the removed disk\n   */\npublic int remove() {\n    return disks.remove(disks.size() - 1);\n}\n","name":"remove","className":"Tower","variables":{"disks":2},"constants":{"1":1},"javaDoc":"Removes the top disk from this tower the size of the removed disk","comments":"\n      Removes the top disk from this tower.\n      @return the size of the removed disk\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"add":1,"size":2,"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"BinaryExpr":4,"NameExpr":14,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n      Adds a disk to this tower.\n      @param size the size of the disk to add\n   */\npublic void add(int size) {\n    if (disks.size() > 0 && disks.get(disks.size() - 1) < size) {\n        throw new IllegalStateException(\"Disk is too large\");\n    }\n    disks.add(size);\n}\n","name":"add","className":"Tower","variables":{"disks":4,"size":1},"constants":{"0":1,"\"Disk is too large\"":1,"1":1},"javaDoc":"Adds a disk to this tower size the size of the disk to add","comments":"\n      Adds a disk to this tower.\n      @param size the size of the disk to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return disks.toString();\n}\n","name":"toString","className":"Tower","variables":{"disks":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    move(5, 1, 3);\n}\n","name":"main","className":"TowersOfHanoiInstructions","variables":{},"constants":{"1":1,"3":1,"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["int","int","int"],"returnType":"void","methodCalls":{"move":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":8,"NameExpr":20,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n      Print instructions for moving a pile of disks from one peg to another.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   */\npublic static void move(int disks, int from, int to) {\n    if (disks > 0) {\n        int other = 6 - from - to;\n        move(disks - 1, from, other);\n        System.out.println(\"Move disk from peg \" + from + \" to \" + to);\n        move(disks - 1, other, to);\n    }\n}\n","name":"move","className":"TowersOfHanoiInstructions","variables":{"other":1,"disks":3,"from":2,"to":2},"constants":{"0":1,"1":2,"\"Move disk from peg \"":1,"\" to \"":1,"6":1},"javaDoc":"Print instructions for moving a pile of disks from one peg to another disks the number of disks to move from the peg from which to move the disks to the peg to which to move the disks","comments":"\n      Print instructions for moving a pile of disks from one peg to another.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"TowersOfHanoi":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    final int NDISKS = 5;\n    TowersOfHanoi towers = new TowersOfHanoi(NDISKS);\n    towers.move(NDISKS, 0, 2);\n}\n","name":"main","className":"TowersOfHanoiDemo","variables":{"NDISKS":2,"towers":2},"constants":{"0":1,"2":1,"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int"],"returnType":"TowersOfHanoi","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":3,"ArrayAccessExpr":3,"NameExpr":5,"ArrayCreationExpr":1,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a puzzle in which the first tower has a given number of disks.\n      @param ndisks the number of disks\n   */\npublic TowersOfHanoi(int ndisks) {\n    towers = new Tower[3];\n    towers[0] = new Tower(ndisks);\n    towers[1] = new Tower(0);\n    towers[2] = new Tower(0);\n}\n","name":"TowersOfHanoi","className":"TowersOfHanoi","variables":{"towers":4,"ndisks":1},"constants":{"0":3,"1":1,"2":1,"3":1},"javaDoc":"Constructs a puzzle in which the first tower has a given number of disks ndisks the number of disks","comments":"\n      Constructs a puzzle in which the first tower has a given number of disks.\n      @param ndisks the number of disks\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"void","methodCalls":{"move":2,"toString":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":30,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"/**\n      Moves a pile of disks from one peg to another and displays the movement.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   */\npublic void move(int disks, int from, int to) {\n    if (disks > 0) {\n        int other = 3 - from - to;\n        move(disks - 1, from, other);\n        towers[to].add(towers[from].remove());\n        System.out.println(Arrays.toString(towers));\n        move(disks - 1, other, to);\n    }\n}\n","name":"move","className":"TowersOfHanoi","variables":{"other":1,"disks":3,"from":2,"to":2,"Arrays":1,"towers":2},"constants":{"0":1,"1":2,"3":1},"javaDoc":"Moves a pile of disks from one peg to another and displays the movement disks the number of disks to move from the peg from which to move the disks to the peg to which to move the disks","comments":"\n      Moves a pile of disks from one peg to another and displays the movement.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Triangle","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a triangular shape.\n      @param aWidth the width (and height) of the triangle\n   */\npublic Triangle(int aWidth) {\n    width = aWidth;\n}\n","name":"Triangle","className":"Triangle","variables":{"aWidth":1,"width":1},"constants":{},"javaDoc":"Constructs a triangular shape aWidth the width (and height) of the triangle","comments":"\n      Constructs a triangular shape.\n      @param aWidth the width (and height) of the triangle\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getArea":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Triangle":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":8,"MethodCallExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3,"ExpressionStmt":2},"text":"/**\n      Computes the area of the triangle.\n      @return the area\n   */\npublic int getArea() {\n    if (width <= 0) {\n        return 0;\n    } else if (width == 1) {\n        return 1;\n    } else {\n        Triangle smallerTriangle = new Triangle(width - 1);\n        int smallerArea = smallerTriangle.getArea();\n        return smallerArea + width;\n    }\n}\n","name":"getArea","className":"Triangle","variables":{"width":4,"smallerTriangle":2,"smallerArea":2},"constants":{"0":2,"1":3},"javaDoc":"Computes the area of the triangle the area","comments":"\n      Computes the area of the triangle.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getArea":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Triangle":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":14,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    Triangle t = new Triangle(10);\n    int area = t.getArea();\n    System.out.println(\"Area: \" + area);\n    System.out.println(\"Expected: 55\");\n}\n","name":"main","className":"TriangleTester","variables":{"area":2,"t":2},"constants":{"\"Area: \"":1,"\"Expected: 55\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"permutations":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    for (String s : permutations(\"eat\")) {\n        System.out.println(s);\n    }\n}\n","name":"main","className":"Permutations","variables":{"s":1},"constants":{"\"eat\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String"],"returnType":"ArrayList<String>","methodCalls":{"add":2,"length":2,"permutations":1,"substring":2,"charAt":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"ArrayList<String>":2,"String":2,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"BinaryExpr":5,"NameExpr":34,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":4,"ForeachStmt":1,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Gets all permutations of a given word.\n      @param word the string to permute\n      @return a list of all permutations\n   */\npublic static ArrayList<String> permutations(String word) {\n    ArrayList<String> result = new ArrayList<String>();\n    // The empty string has a single permutation: itself\n    if (word.length() == 0) {\n        result.add(word);\n        return result;\n    } else {\n        // Loop through all character positions\n        for (int i = 0; i < word.length(); i++) {\n            // Form a shorter word by removing the ith character\n            String shorter = word.substring(0, i) + word.substring(i + 1);\n            // Generate all permutations of the simpler word\n            ArrayList<String> shorterPermutations = permutations(shorter);\n            // each permutation of the simpler word, \n            for (String s : shorterPermutations) {\n                result.add(word.charAt(i) + s);\n            }\n        }\n        // Return all permutations\n        return result;\n    }\n}\n","name":"permutations","className":"Permutations","variables":{"result":5,"s":2,"i":4,"word":5,"shorterPermutations":2,"shorter":1},"constants":{"0":3,"1":1},"javaDoc":"Gets all permutations of a given word word the string to permute a list of all permutations","comments":"The empty string has a single permutation: itself Loop through all character positions Add the removed character to the front of Form a shorter word by removing the ith character Generate all permutations of the simpler word each permutation of the simpler word Return all permutations \n      Gets all permutations of a given word.\n      @param word the string to permute\n      @return a list of all permutations\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["double","String"],"returnType":"Coin","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a coin.\n      @param aValue the monetary value of the coin\n      @param aName the name of the coin\n   */\npublic Coin(double aValue, String aName) {\n    value = aValue;\n    name = aName;\n}\n","name":"Coin","className":"Coin","variables":{"aName":1,"name":1,"value":1,"aValue":1},"constants":{},"javaDoc":"Constructs a coin aValue the monetary value of the coin aName the name of the coin","comments":"\n      Constructs a coin.\n      @param aValue the monetary value of the coin\n      @param aName the name of the coin\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the coin value.\n      @return the value\n   */\npublic double getValue() {\n    return value;\n}\n","name":"getValue","className":"Coin","variables":{"value":1},"constants":{},"javaDoc":"Gets the coin value the value","comments":"\n      Gets the coin value.\n      @return the value\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the coin name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Coin","variables":{"name":1},"constants":{},"javaDoc":"Gets the coin name the name","comments":"\n      Gets the coin name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"constants":{"0":2},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":1,"purchase":2},"constants":{},"javaDoc":"Records the purchase price of an item amount the price of the purchased item","comments":"\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","Coin"],"returnType":"void","methodCalls":{"getValue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Enters the payment received from the customer.\n      @param coinCount the number of coins received\n      @param coinType the type of coin that was received\n   */\npublic void receivePayment(int coinCount, Coin coinType) {\n    payment = payment + coinCount * coinType.getValue();\n}\n","name":"receivePayment","className":"CashRegister","variables":{"coinType":1,"payment":2,"coinCount":1},"constants":{},"javaDoc":"Enters the payment received from the customer coinCount the number of coins received coinType the type of coin that was received","comments":"\n      Enters the payment received from the customer.\n      @param coinCount the number of coins received\n      @param coinType the type of coin that was received\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":5,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"constants":{"0":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":2,"receivePayment":2,"giveChange":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Coin":2,"CashRegister":1,"double":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"DoubleLiteralExpr":4,"StringLiteralExpr":3,"NameExpr":28,"FieldAccessExpr":2,"MethodCallExpr":7},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    final Coin DOLLAR = new Coin(1.0, \"Dollar\");\n    final Coin QUARTER = new Coin(0.25, \"Quarter\");\n    CashRegister register = new CashRegister();\n    register.recordPurchase(1.95);\n    register.recordPurchase(1.40);\n    register.receivePayment(3, DOLLAR);\n    register.receivePayment(2, QUARTER);\n    double change = register.giveChange();\n    System.out.println(change);\n    System.out.println(\"Expected: 0.15\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"QUARTER":1,"change":1,"DOLLAR":1,"register":6},"constants":{"2":1,"1.0":1,"3":1,"0.25":1,"\"Quarter\"":1,"\"Dollar\"":1,"\"Expected: 0.15\"":1,"1.95":1,"1.40":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"StringLiteralExpr":1},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n}\n","name":"main","className":"Gallery1","variables":{"PICTURES":1,"MAX_WIDTH":1,"GAP":1,"pic":1},"constants":{"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"getMaxX":1,"getBounds":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":2,"int":3},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":2,"VariableDeclarationExpr":5,"StringLiteralExpr":2,"NameExpr":8,"MethodCallExpr":3},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    Picture pic2 = new Picture(\"picture2.jpg\");\n    pic2.move(pic.getBounds().getMaxX(), 0);\n}\n","name":"main","className":"Gallery2","variables":{"PICTURES":1,"MAX_WIDTH":1,"GAP":1,"pic":2,"pic2":2},"constants":{"0":1,"\"picture2.jpg\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"getMaxX":1,"getBounds":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":2,"double":1,"int":4},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":2,"VariableDeclarationExpr":7,"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":16,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    for (int i = 2; i <= PICTURES; i++) {\n        Picture previous = pic;\n        pic = new Picture(\"picture\" + i + \".jpg\");\n        double x = previous.getBounds().getMaxX() + GAP;\n        pic.move(x, 0);\n    }\n}\n","name":"main","className":"Gallery4","variables":{"PICTURES":2,"previous":2,"MAX_WIDTH":1,"GAP":2,"x":1,"i":4,"pic":4},"constants":{"0":1,"2":1,"\".jpg\"":1,"\"picture\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"getMaxX":1,"getBounds":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":2,"double":1,"int":3},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":2,"VariableDeclarationExpr":6,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":10,"MethodCallExpr":3},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    Picture pic2 = new Picture(\"picture2.jpg\");\n    double x = pic.getBounds().getMaxX() + GAP;\n    pic2.move(x, 0);\n}\n","name":"main","className":"Gallery3","variables":{"PICTURES":1,"MAX_WIDTH":1,"GAP":2,"x":1,"pic":2,"pic2":2},"constants":{"0":1,"\"picture2.jpg\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["String"],"returnType":"Picture","methodCalls":{"setIcon":2,"read":2,"printStackTrace":1,"getPreferredSize":1,"show":1,"getInstance":1,"setBounds":1,"startsWith":1,"setText":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Dimension":1,"BufferedImage":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":48,"StringLiteralExpr":2,"FieldAccessExpr":3,"ThisExpr":2,"AssignExpr":3,"MethodCallExpr":12},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":11},"text":"/**\n      Constructs a picture from a given file or URL.\n      @param source the filename or URL\n   */\npublic Picture(String source) {\n    try {\n        this.source = source;\n        BufferedImage image;\n        if (source.startsWith(\"http://\")) {\n            image = ImageIO.read(new URL(source).openStream());\n        } else {\n            image = ImageIO.read(new File(source));\n        }\n        label.setIcon(new ImageIcon(image));\n        label.setText(\"\");\n        Dimension dim = label.getPreferredSize();\n        label.setBounds(0, 0, dim.width, dim.height);\n    } catch (Exception ex) {\n        label.setIcon(null);\n        ex.printStackTrace();\n    }\n    Canvas.getInstance().show(this);\n}\n","name":"Picture","className":"Picture","variables":{"image":4,"ex":2,"Canvas":1,"dim":1,"source":4,"label":5,"ImageIO":2},"constants":{"\"\"":1,"0":2,"null":1,"\"http://\"":1},"javaDoc":"Constructs a picture from a given file or URL source the filename or URL","comments":"\n      Constructs a picture from a given file or URL.\n      @param source the filename or URL\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Rectangle","methodCalls":{"round":2,"getBounds":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":15,"CastExpr":2,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Returns the bounds of this picture\n      @return the rectangle that contains the picture\n   */\npublic Rectangle getBounds() {\n    Rectangle r = label.getBounds();\n    r.translate((int) Math.round(x), (int) Math.round(y));\n    return r;\n}\n","name":"getBounds","className":"Picture","variables":{"r":3,"label":1,"Math":2},"constants":{},"javaDoc":"Returns the bounds of this picture the rectangle that contains the picture","comments":"\n      Returns the bounds of this picture\n      @return the rectangle that contains the picture\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{"getInstance":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Moves this picture by a given amount.\n      @param dx the amount by which to move in x-direction\n      @param dy the amount by which to move in y-direction\n   */\npublic void move(double dx, double dy) {\n    x += dx;\n    y += dy;\n    Canvas.getInstance().repaint();\n}\n","name":"move","className":"Picture","variables":{"dx":1,"dy":1,"Canvas":1,"x":1,"y":1},"constants":{},"javaDoc":"Moves this picture by a given amount dx the amount by which to move in x-direction dy the amount by which to move in y-direction","comments":"\n      Moves this picture by a given amount.\n      @param dx the amount by which to move in x-direction\n      @param dy the amount by which to move in y-direction\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"Picture[source=\" + source + \",bounds=\" + getBounds() + \"]\";\n}\n","name":"toString","className":"Picture","variables":{"source":1},"constants":{"\"]\"":1,"\",bounds=\"":1,"\"Picture[source=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Graphics2D"],"returnType":"void","methodCalls":{"paint":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"private void paintShape(Graphics2D g2) {\n    g2.translate(x, y);\n    label.paint(g2);\n}\n","name":"paintShape","className":"Picture","variables":{"g2":1,"label":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getHeight":1,"setColor":1,"create":1,"dispose":1,"getWidth":1,"fillRect":1,"paintShape":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Picture":1,"Graphics2D":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"NameExpr":28,"CastExpr":1,"FieldAccessExpr":3,"MethodCallExpr":7},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":5},"text":"public void paintComponent(Graphics g) {\n    g.setColor(java.awt.Color.WHITE);\n    g.fillRect(0, 0, getWidth(), getHeight());\n    for (Picture s : pictures) {\n        Graphics2D g2 = (Graphics2D) g.create();\n        s.paintShape(g2);\n        g2.dispose();\n    }\n}\n","name":"paintComponent","className":"CanvasComponent","variables":{"s":2,"g":3,"g2":2,"pictures":1},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"getX":1,"getHeight":1,"getY":1,"max":2,"getWidth":1,"getBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Picture":1,"Rectangle":1,"int":2},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":30,"CastExpr":2,"MethodCallExpr":7,"AssignExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"public Dimension getPreferredSize() {\n    int maxx = MIN_SIZE;\n    int maxy = MIN_SIZE;\n    for (Picture s : pictures) {\n        Rectangle r = s.getBounds();\n        maxx = (int) Math.max(maxx, r.getX() + r.getWidth());\n        maxy = (int) Math.max(maxy, r.getY() + r.getHeight());\n    }\n    return new Dimension(maxx, maxy);\n}\n","name":"getPreferredSize","className":"CanvasComponent","variables":{"MIN_SIZE":2,"r":5,"s":2,"maxy":3,"maxx":3,"Math":2,"pictures":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"getState":1,"printStackTrace":1,"saveToDisk":1},"annotations":[],"exceptions":["Exception"],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":18,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":4},"text":"public void run() {\n    try {\n        final int DELAY = 10;\n        while (currentThread.getState() != Thread.State.TERMINATED) {\n            Thread.sleep(DELAY);\n        }\n        saveToDisk(SAVEFILE);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"run","className":"","variables":{"currentThread":1,"ex":2,"DELAY":1,"Thread":1},"constants":{"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Canvas","methodCalls":{"add":1,"setVisible":1,"currentThread":1,"getProperty":2,"printStackTrace":1,"start":1,"saveToDisk":1,"pack":1,"sleep":1,"contains":1,"getState":1,"setLocation":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","FinalVariables"],"types":{"String":1,"int":1,"Thread":2},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":56,"StringLiteralExpr":4,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":14,"AssignExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":7,"TryStmt":1,"ExpressionStmt":14},"text":"private Canvas() {\n    if (System.getProperty(\"com.horstmann.codecheck\") == null) {\n        frame = new JFrame();\n        if (!System.getProperty(\"java.class.path\").contains(\"bluej\")) {\n            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        }\n        frame.add(component);\n        frame.pack();\n        frame.setLocation(LOCATION_OFFSET, LOCATION_OFFSET);\n        frame.setVisible(true);\n    } else {\n        final String SAVEFILE = \"canvas.png\";\n        final Thread currentThread = Thread.currentThread();\n        Thread watcherThread = new Thread() {\n\n            public void run() {\n                try {\n                    final int DELAY = 10;\n                    while (currentThread.getState() != Thread.State.TERMINATED) {\n                        Thread.sleep(DELAY);\n                    }\n                    saveToDisk(SAVEFILE);\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        };\n        watcherThread.start();\n    }\n}\n","name":"Canvas","className":"Canvas","variables":{"currentThread":2,"ex":2,"watcherThread":2,"run":1,"SAVEFILE":1,"DELAY":1,"System":2,"frame":6,"Thread":2},"constants":{"\"com.horstmann.codecheck\"":1,"\"bluej\"":1,"null":1,"\"java.class.path\"":1,"true":1,"\"canvas.png\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":[],"returnType":"Canvas","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public static Canvas getInstance() {\n    return canvas;\n}\n","name":"getInstance","className":"Canvas","variables":{"canvas":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["Picture"],"returnType":"void","methodCalls":{"add":1,"contains":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"public void show(Picture s) {\n    if (!pictures.contains(s)) {\n        pictures.add(s);\n    }\n    repaint();\n}\n","name":"show","className":"Canvas","variables":{"pictures":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getHeight":2,"getPreferredSize":1,"getWidth":2,"repaint":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Dimension":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":22,"MethodCallExpr":7},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":1,"ExpressionStmt":3},"text":"public void repaint() {\n    if (frame == null) {\n        return;\n    }\n    Dimension dim = component.getPreferredSize();\n    if (dim.getWidth() > component.getWidth() || dim.getHeight() > component.getHeight()) {\n        frame.pack();\n    } else {\n        frame.repaint();\n    }\n}\n","name":"repaint","className":"Canvas","variables":{"component":3,"dim":3,"frame":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"lastIndexOf":1,"setColor":2,"getPreferredSize":1,"paintComponent":1,"javax.swing.JOptionPane.showMessageDialog":1,"getMessage":1,"dispose":1,"getGraphics":1,"fill":1,"System.err.println":1,"write":1,"substring":1},"annotations":[],"exceptions":["Throwable"],"concepts":["Casting"],"types":{"java.awt.Rectangle":1,"Dimension":1,"String":1,"BufferedImage":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":2,"NameExpr":80,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":14,"CharLiteralExpr":1,"MethodCallExpr":13},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":13},"text":"public void saveToDisk(String fileName) {\n    try {\n        Dimension dim = component.getPreferredSize();\n        java.awt.Rectangle rect = new java.awt.Rectangle(0, 0, dim.width, dim.height);\n        BufferedImage image = new BufferedImage(rect.width, rect.height, BufferedImage.TYPE_INT_RGB);\n        Graphics2D g = (Graphics2D) image.getGraphics();\n        g.setColor(java.awt.Color.WHITE);\n        g.fill(rect);\n        g.setColor(java.awt.Color.BLACK);\n        component.paintComponent(g);\n        String extension = fileName.substring(fileName.lastIndexOf('.') + 1);\n        ImageIO.write(image, extension, new File(fileName));\n        g.dispose();\n    } catch (Throwable e) {\n        javax.swing.JOptionPane.showMessageDialog(null, e.getMessage());\n        System.err.println(\"Was unable to save the image to \" + fileName);\n    }\n}\n","name":"saveToDisk","className":"Canvas","variables":{"rect":1,"image":2,"component":2,"extension":1,"fileName":4,"e":2,"g":5,"dim":1,"ImageIO":1},"constants":{"0":2,"'.'":1,"\"Was unable to save the image to \"":1,"1":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":2,"getY":1,"max":1,"getMaxX":1,"getMaxY":1,"getWidth":1,"getBounds":4},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":2,"double":2,"int":4},"expressions":{"IntegerLiteralExpr":7,"ObjectCreationExpr":2,"VariableDeclarationExpr":8,"BinaryExpr":7,"StringLiteralExpr":3,"NameExpr":42,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    double maxY = 0;\n    for (int i = 2; i <= 20; i++) {\n        maxY = Math.max(maxY, pic.getBounds().getMaxY());\n        Picture previous = pic;\n        pic = new Picture(\"picture\" + i + \".jpg\");\n        double x = previous.getBounds().getMaxX() + GAP;\n        if (x + pic.getBounds().getWidth() < MAX_WIDTH) {\n            pic.move(x, previous.getBounds().getY());\n        } else {\n            pic.move(0, maxY + GAP);\n        }\n    }\n}\n","name":"main","className":"Gallery6","variables":{"PICTURES":1,"previous":3,"MAX_WIDTH":2,"maxY":3,"GAP":3,"x":2,"i":4,"pic":7,"Math":1},"constants":{"0":2,"2":1,"\".jpg\"":1,"\"picture\"":1,"720":1,"\"picture1.jpg\"":1,"20":2,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":2,"getY":1,"max":1,"getMaxX":1,"getMaxY":1,"getWidth":1,"getBounds":4},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":2,"double":2,"int":4},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":2,"VariableDeclarationExpr":8,"BinaryExpr":7,"StringLiteralExpr":3,"NameExpr":43,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    double maxY = 0;\n    for (int i = 2; i <= PICTURES; i++) {\n        maxY = Math.max(maxY, pic.getBounds().getMaxY());\n        Picture previous = pic;\n        pic = new Picture(\"picture\" + i + \".jpg\");\n        double x = previous.getBounds().getMaxX() + GAP;\n        if (x + pic.getBounds().getWidth() < MAX_WIDTH) {\n            pic.move(x, previous.getBounds().getY());\n        } else {\n            pic.move(0, maxY + GAP);\n            return;\n        }\n    }\n}\n","name":"main","className":"Gallery5","variables":{"PICTURES":2,"previous":3,"MAX_WIDTH":2,"maxY":3,"GAP":3,"x":2,"i":4,"pic":7,"Math":1},"constants":{"0":2,"2":1,"\".jpg\"":1,"\"picture\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":6,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Transfers money from this account and tries to add it\n      @param amount the amount of money to transfer\n      @param otherBalance balance to add the amount to\n   */\nvoid transfer(double amount, double otherBalance) {\n    balance = balance - amount;\n    otherBalance = otherBalance + amount;\n// Wont update the argument\n}\n","name":"transfer","className":"BankAccount","variables":{"amount":2,"balance":2,"otherBalance":2},"constants":{},"javaDoc":"Transfers money from this account and tries to add it amount the amount of money to transfer otherBalance balance to add the amount to","comments":"Wont update the argument \n      Transfers money from this account and tries to add it\n      @param amount the amount of money to transfer\n      @param otherBalance balance to add the amount to\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":0}
{"paramTypes":["double","BankAccount"],"returnType":"void","methodCalls":{"deposit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Transfers money from this account to another.\n      @param amount the amount of money to transfer\n      @param otherAccount account to add the amount to\n   */\npublic void transfer(double amount, BankAccount otherAccount) {\n    balance = balance - amount;\n    otherAccount.deposit(amount);\n}\n","name":"transfer","className":"BankAccount","variables":{"amount":1,"otherAccount":1,"balance":2},"constants":{},"javaDoc":"Transfers money from this account to another amount the amount of money to transfer otherAccount account to add the amount to","comments":"\n      Transfers money from this account to another.\n      @param amount the amount of money to transfer\n      @param otherAccount account to add the amount to\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double","BankAccount"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":9,"FieldAccessExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"public void transfer2(double amount, BankAccount otherAccount) {\n    balance = balance - amount;\n    double newBalance = otherAccount.balance + amount;\n    // Wont work\n    otherAccount = new BankAccount(newBalance);\n}\n","name":"transfer2","className":"BankAccount","variables":{"amount":2,"otherAccount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"","comments":"Wont work ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"transfer":2,"getBalance":4,"transfer2":1,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"BankAccount":3},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":7,"VariableDeclarationExpr":4,"BinaryExpr":6,"NameExpr":56,"StringLiteralExpr":6,"FieldAccessExpr":6,"MethodCallExpr":13},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount(2500);\n    double savingsBalance = 1000;\n    System.out.println(\"Before: \" + savingsBalance);\n    harrysChecking.transfer(500, savingsBalance);\n    System.out.println(\"After: \" + savingsBalance);\n    BankAccount harrysSavings = new BankAccount(1000);\n    System.out.println(\"Before: \" + harrysSavings.getBalance());\n    harrysChecking.transfer(500, harrysSavings);\n    System.out.println(\"After: \" + harrysSavings.getBalance());\n    BankAccount savingsAccount = new BankAccount(1000);\n    System.out.println(\"Before: \" + savingsAccount.getBalance());\n    harrysChecking.transfer2(500, savingsAccount);\n    System.out.println(\"After: \" + savingsAccount.getBalance());\n}\n","name":"main","className":"CallByValueDemo","variables":{"harrysChecking":4,"savingsBalance":3,"savingsAccount":3,"harrysSavings":3},"constants":{"2500":1,"500":3,"\"After: \"":3,"1000":3,"\"Before: \"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":["double","double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   */\npublic static double percentOf(double percentage, double amount) {\n    return (percentage / 100) * amount;\n}\n","name":"percentOf","className":"Financial","variables":{"amount":1,"percentage":1},"constants":{"100":1},"javaDoc":"Computes a percentage of an amount percentage the percentage to apply amount the amount to which the percentage is applied the requested percentage of the amount","comments":"\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["double","double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Adds a percentage to an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the sum of the amount and the requested percentage\n   */\npublic static double addPercentTo(double percentage, double amount) {\n    return (1 + percentage / 100) * amount;\n}\n","name":"addPercentTo","className":"Financial","variables":{"amount":1,"percentage":1},"constants":{"1":1,"100":1},"javaDoc":"Adds a percentage to an amount percentage the percentage to apply amount the amount to which the percentage is applied the sum of the amount and the requested percentage","comments":"\n      Adds a percentage to an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the sum of the amount and the requested percentage\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":1,"percentOf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":3},"expressions":{"VariableDeclarationExpr":3,"DoubleLiteralExpr":2,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    double price = 9.95;\n    double taxRate = 8.25;\n    double tax = Financial.percentOf(price, taxRate);\n    System.out.printf(\"Tax: %.2f\\n\", tax);\n}\n","name":"main","className":"PackageDemo","variables":{"taxRate":1,"price":1,"Financial":1,"tax":1},"constants":{"8.25":1,"\"Tax: %.2f\\n\"":1,"9.95":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"public void eat() {\n    System.out.println(\"Yum!\");\n    hungry = NOT_HUNGRY;\n}\n","name":"eat","className":"Fish","variables":{"hungry":1,"NOT_HUNGRY":1},"constants":{"\"Yum!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public void move() {\n    if (hungry == VERY_HUNGRY) {\n        System.out.println(\"Looking for food\");\n    } else {\n        System.out.println(\"Looking for love\");\n        hungry++;\n    }\n}\n","name":"move","className":"Fish","variables":{"hungry":2,"VERY_HUNGRY":1},"constants":{"\"Looking for love\"":1,"\"Looking for food\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Student(int anId) {\n    id = anId;\n}\n","name":"Student","className":"Student","variables":{"anId":1,"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getId() {\n    return id;\n}\n","name":"getId","className":"Student","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// No setId method\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Student","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"length":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":5,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":1},"text":"public void setName(String newName) {\n    if (newName.length() > 0) {\n        name = newName;\n    }\n}\n","name":"setName","className":"Student","variables":{"newName":2,"name":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":4},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":12,"UnaryExpr":4},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":8},"text":"public void moveOneUnit() {\n    final int NORTH = 0;\n    final int EAST = 1;\n    final int SOUTH = 2;\n    final int WEST = 3;\n    if (direction == NORTH) {\n        row--;\n    } else if (direction == EAST) {\n        column++;\n    } else if (direction == SOUTH) {\n        row++;\n    } else if (direction == WEST) {\n        column--;\n    }\n}\n","name":"moveOneUnit","className":"Bug","variables":{"NORTH":2,"WEST":2,"column":2,"SOUTH":2,"row":2,"EAST":2,"direction":4},"constants":{"0":1,"1":1,"2":1,"3":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public void turnRight() {\n    int DIRECTIONS = 4;\n    direction++;\n    if (direction == DIRECTIONS) {\n        direction = 0;\n    }\n}\n","name":"turnRight","className":"Bug","variables":{"DIRECTIONS":2,"direction":3},"constants":{"0":1,"4":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getRow() {\n    return row;\n}\n","name":"getRow","className":"Bug","variables":{"row":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getColumn() {\n    return column;\n}\n","name":"getColumn","className":"Bug","variables":{"column":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void move(double distanceMoved) {\n    distanceFromTerminus = distanceFromTerminus + distanceMoved;\n}\n","name":"move","className":"Train","variables":{"distanceFromTerminus":2,"distanceMoved":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getPosition() {\n    return distanceFromTerminus;\n}\n","name":"getPosition","className":"Train","variables":{"distanceFromTerminus":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"recordPurchase":2,"assertEquals":1,"receivePayment":1,"giveChange":1},"annotations":["Test"],"exceptions":[],"concepts":[],"types":{"CashRegister":1,"double":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"DoubleLiteralExpr":3,"NameExpr":17,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"@Test\npublic void twoPurchases() {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(0.75);\n    register.recordPurchase(1.50);\n    register.receivePayment(2, 0, 5, 0, 0);\n    double expected = 0.25;\n    Assert.assertEquals(expected, register.giveChange(), EPSILON);\n}\n","name":"twoPurchases","className":"CashRegisterTest","variables":{"Assert":1,"expected":1,"register":5},"constants":{"0":3,"2":1,"5":1,"0.25":1,"0.75":1,"1.50":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"recordPurchase":2,"assertEquals":1,"receivePayment":1,"giveChange":1},"annotations":["Test"],"exceptions":[],"concepts":[],"types":{"CashRegister":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"DoubleLiteralExpr":2,"NameExpr":16,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"@Test\npublic void testZeroBalance() {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(2.25);\n    register.recordPurchase(19.25);\n    register.receivePayment(21, 2, 0, 0, 0);\n    Assert.assertEquals(0, register.giveChange(), EPSILON);\n}\n","name":"testZeroBalance","className":"CashRegisterTest","variables":{"Assert":1,"register":5},"constants":{"0":4,"2":1,"19.25":1,"2.25":1,"21":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"constants":{"0":2},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":1,"purchase":2},"constants":{},"javaDoc":"Records the purchase price of an item amount the price of the purchased item","comments":"\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":8,"NameExpr":10,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Enters the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   */\npublic void receivePayment(int dollars, int quarters, int dimes, int nickels, int pennies) {\n    payment = dollars + quarters * QUARTER_VALUE + dimes * DIME_VALUE + nickels * NICKEL_VALUE + pennies * PENNY_VALUE;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"NICKEL_VALUE":1,"dimes":1,"nickels":1,"quarters":1,"pennies":1,"payment":1,"dollars":1,"QUARTER_VALUE":1,"DIME_VALUE":1,"PENNY_VALUE":1},"constants":{},"javaDoc":"Enters the payment received from the customer dollars the number of dollars in the payment quarters the number of quarters in the payment dimes the number of dimes in the payment nickels the number of nickels in the payment pennies the number of pennies in the payment","comments":"\n      Enters the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":5,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"constants":{"0":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    lastAssignedNumber++;\n    accountNumber = lastAssignedNumber;\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"lastAssignedNumber":2,"balance":1,"accountNumber":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into this account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into this account amount the amount to deposit","comments":"\n      Deposits money into this account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":8,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"/**\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   */\npublic void withdraw(double amount) {\n    if (amount > balance) {\n        balance = balance - OVERDRAFT_FEE;\n    } else {\n        balance = balance - amount;\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":5,"OVERDRAFT_FEE":1},"constants":{},"javaDoc":"Makes a withdrawal from this account or charges a penalty if sufficient funds are not available amount the amount of the withdrawal","comments":"\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"percentOf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds interest to this account.\n      @param rate the interest rate in percent\n   */\npublic void addInterest(double rate) {\n    balance = balance + Financial.percentOf(rate, balance);\n}\n","name":"addInterest","className":"BankAccount","variables":{"balance":2,"Financial":1},"constants":{},"javaDoc":"Adds interest to this account rate the interest rate in percent","comments":"\n      Adds interest to this account.\n      @param rate the interest rate in percent\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of this account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of this account the current balance","comments":"\n      Gets the current balance of this account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double","double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   */\npublic static double percentOf(double percentage, double amount) {\n    return (percentage / 100) * amount;\n}\n","name":"percentOf","className":"Financial","variables":{"amount":1,"percentage":1},"constants":{"100":1},"javaDoc":"Computes a percentage of an amount percentage the percentage to apply amount the amount to which the percentage is applied the requested percentage of the amount","comments":"\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"TimeBean","methodCalls":{"getTimeInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Initializes the formatter.\n   */\npublic TimeBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n}\n","name":"TimeBean","className":"TimeBean","variables":{"DateFormat":1,"timeFormatter":1},"constants":{},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"Date":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Read-only time property.\n      @return the formatted time\n   */\npublic String getTime() {\n    Date time = new Date();\n    String timeString = timeFormatter.format(time);\n    return timeString;\n}\n","name":"getTime","className":"TimeBean","variables":{"timeString":2,"time":1,"timeFormatter":1},"constants":{},"javaDoc":"Read-only time property the formatted time","comments":"\n      Read-only time property.\n      @return the formatted time\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"TimeZoneBean","methodCalls":{"getTimeInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Initializes the formatter.\n   */\npublic TimeZoneBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n    cities = new ArrayList<>();\n}\n","name":"TimeZoneBean","className":"TimeZoneBean","variables":{"cities":1,"DateFormat":1,"timeFormatter":1},"constants":{},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   */\npublic void setCityToAdd(String city) {\n    cityToAdd = city;\n}\n","name":"setCityToAdd","className":"TimeZoneBean","variables":{"city":1,"cityToAdd":1},"constants":{},"javaDoc":"Setter for cityToAdd property city the city to add to the list of cities","comments":"\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   */\npublic String getCityToAdd() {\n    return cityToAdd;\n}\n","name":"getCityToAdd","className":"TimeZoneBean","variables":{"cityToAdd":1},"constants":{},"javaDoc":"Getter for cityToAdd property the city to add to the list of cities","comments":"\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   */\npublic void setCityToRemove(String city) {\n    cityToRemove = city;\n}\n","name":"setCityToRemove","className":"TimeZoneBean","variables":{"city":1,"cityToRemove":1},"constants":{},"javaDoc":"Setter for the cityToRemove property city the city to remove from the list of cities","comments":"\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   */\npublic String getCityToRemove() {\n    return cityToRemove;\n}\n","name":"getCityToRemove","className":"TimeZoneBean","variables":{"cityToRemove":1},"constants":{},"javaDoc":"Getter for the cityToRemove property the city to remove from the list of cities","comments":"\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Map<String, String>","methodCalls":{"size":1,"getTimeZone":1,"get":1,"setTimeZone":1,"format":1,"put":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<String, String>":1,"TimeZone":1,"String":3,"TreeMap":1,"Date":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":5,"NameExpr":33,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":6,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"/**\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   */\npublic Map<String, String> getCitiesAndTimes() {\n    Date time = new Date();\n    Map<String, String> result = new TreeMap<>();\n    for (int i = 0; i < cities.size(); i++) {\n        String city = cities.get(i);\n        String label = city + \": \";\n        TimeZone zone = getTimeZone(city);\n        if (zone != null) {\n            timeFormatter.setTimeZone(zone);\n            String timeString = timeFormatter.format(time);\n            label = label + timeString;\n        } else {\n            label = label + \"unavailable\";\n        }\n        result.put(label, city);\n    }\n    return result;\n}\n","name":"getCitiesAndTimes","className":"TimeZoneBean","variables":{"result":3,"cities":2,"city":2,"zone":2,"timeString":2,"i":3,"time":1,"label":5,"timeFormatter":2},"constants":{"0":1,"null":1,"\"unavailable\"":1,"\": \"":1},"javaDoc":"Read-only citiesAndTimes property a map containing the cities and formatted times","comments":"\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"add":1,"getTimeZone":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"TimeZone":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":3,"MethodCallExpr":2,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Action for adding a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   */\npublic String addCity() {\n    TimeZone zone = getTimeZone(cityToAdd);\n    if (zone == null) {\n        return \"error\";\n    }\n    cities.add(cityToAdd);\n    cityToRemove = cityToAdd;\n    cityToAdd = \"\";\n    return \"next\";\n}\n","name":"addCity","className":"TimeZoneBean","variables":{"cities":1,"zone":2,"cityToAdd":2,"cityToRemove":1},"constants":{"\"\"":1,"null":1,"\"error\"":1,"\"next\"":1},"javaDoc":"Action for adding a city \"next\" if time zone information is available for the city \"error\" otherwise","comments":"\n      Action for adding a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"size":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Action for removing a city.\n      @return null if there are more cities to remove, \"index\" otherwise\n   */\npublic String removeCity() {\n    cities.remove(cityToRemove);\n    if (cities.size() > 0) {\n        return null;\n    } else {\n        return \"index\";\n    }\n}\n","name":"removeCity","className":"TimeZoneBean","variables":{"cities":2},"constants":{"0":1,"null":1,"\"index\"":1},"javaDoc":"Action for removing a city null if there are more cities to remove \"index\" otherwise","comments":"\n      Action for removing a city.\n      @return null if there are more cities to remove, \"index\" otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"TimeZone","methodCalls":{"getTimeZone":2,"Logger.global.info":1,"getAvailableIDs":1,"timeZoneIDmatch":1,"getZoneNameFromDB":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"String[]":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":32,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":2,"BlockStmt":5,"TryStmt":1,"ForStmt":1,"ReturnStmt":3,"ExpressionStmt":3},"text":"/**\n      Looks up the time zone for a city\n      @param city the city for which to find the time zone\n      @return the time zone or null if no match is found\n   */\nprivate TimeZone getTimeZone(String city) {\n    String[] ids = TimeZone.getAvailableIDs();\n    for (int i = 0; i < ids.length; i++) {\n        if (timeZoneIDmatch(ids[i], city)) {\n            return TimeZone.getTimeZone(ids[i]);\n        }\n    }\n    try {\n        String id = getZoneNameFromDB(city);\n        if (id != null) {\n            return TimeZone.getTimeZone(id);\n        }\n    } catch (Exception ex) {\n        Logger.global.info(\"Caught in TimeZone.getTimeZone: \" + ex);\n    }\n    return null;\n}\n","name":"getTimeZone","className":"TimeZoneBean","variables":{"TimeZone":3,"ex":2,"ids":3,"i":5,"id":2},"constants":{"0":1,"null":2,"\"Caught in TimeZone.getTimeZone: \"":1},"javaDoc":"Looks up the time zone for a city city the city for which to find the time zone the time zone or null if no match is found","comments":"\n      Looks up the time zone for a city\n      @param city the city for which to find the time zone\n      @return the time zone or null if no match is found\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"next":1,"getConnection":1,"setString":1,"Logger.global.info":1,"prepareStatement":1,"getString":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"Connection":1,"ResultSet":1,"PreparedStatement":1},"expressions":{"NullLiteralExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":25,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":2,"BlockStmt":4,"TryStmt":1,"ReturnStmt":3,"ExpressionStmt":4},"text":"private String getZoneNameFromDB(String city) throws SQLException {\n    if (source == null) {\n        Logger.global.info(\"No database connection\");\n        return null;\n    }\n    try (Connection conn = source.getConnection()) {\n        PreparedStatement stat = conn.prepareStatement(\"SELECT Zone FROM CityZone WHERE City=?\");\n        stat.setString(1, city);\n        ResultSet result = stat.executeQuery();\n        if (result.next()) {\n            return result.getString(1);\n        } else {\n            return null;\n        }\n    }\n}\n","name":"getZoneNameFromDB","className":"TimeZoneBean","variables":{"result":3,"conn":2,"stat":3,"source":2},"constants":{"1":2,"null":3,"\"No database connection\"":1,"\"SELECT Zone FROM CityZone WHERE City=?\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":["String","String"],"returnType":"boolean","methodCalls":{"equals":1,"replace":1,"indexOf":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"CharLiteralExpr":3,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Checks whether a time zone ID matches a city\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param city the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   */\nprivate static boolean timeZoneIDmatch(String id, String city) {\n    String idCity = id.substring(id.indexOf('/') + 1);\n    return idCity.replace('_', ' ').equals(city);\n}\n","name":"timeZoneIDmatch","className":"TimeZoneBean","variables":{"idCity":2,"id":2},"constants":{"1":1,"' '":1,"'/'":1,"'_'":1},"javaDoc":"Checks whether a time zone ID matches a city id the time zone ID (e g \"America/Los_Angeles\") city the city to match (e g \"Los Angeles\") true if the ID and city match","comments":"\n      Checks whether a time zone ID matches a city\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param city the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":10}
{"paramTypes":[],"returnType":"TimeZoneBean","methodCalls":{"getTimeInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Initializes the formatter.\n   */\npublic TimeZoneBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n    cities = new ArrayList<>();\n}\n","name":"TimeZoneBean","className":"TimeZoneBean","variables":{"cities":1,"DateFormat":1,"timeFormatter":1},"constants":{},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   */\npublic void setCityToAdd(String city) {\n    cityToAdd = city;\n}\n","name":"setCityToAdd","className":"TimeZoneBean","variables":{"city":1,"cityToAdd":1},"constants":{},"javaDoc":"Setter for cityToAdd property city the city to add to the list of cities","comments":"\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   */\npublic String getCityToAdd() {\n    return cityToAdd;\n}\n","name":"getCityToAdd","className":"TimeZoneBean","variables":{"cityToAdd":1},"constants":{},"javaDoc":"Getter for cityToAdd property the city to add to the list of cities","comments":"\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   */\npublic void setCityToRemove(String city) {\n    cityToRemove = city;\n}\n","name":"setCityToRemove","className":"TimeZoneBean","variables":{"city":1,"cityToRemove":1},"constants":{},"javaDoc":"Setter for the cityToRemove property city the city to remove from the list of cities","comments":"\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   */\npublic String getCityToRemove() {\n    return cityToRemove;\n}\n","name":"getCityToRemove","className":"TimeZoneBean","variables":{"cityToRemove":1},"constants":{},"javaDoc":"Getter for the cityToRemove property the city to remove from the list of cities","comments":"\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Map<String, String>","methodCalls":{"size":1,"getTimeZone":1,"get":1,"setTimeZone":1,"format":1,"put":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<String, String>":1,"TimeZone":1,"String":3,"TreeMap":1,"Date":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":5,"NameExpr":33,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":6,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"/**\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   */\npublic Map<String, String> getCitiesAndTimes() {\n    Date time = new Date();\n    Map<String, String> result = new TreeMap<>();\n    for (int i = 0; i < cities.size(); i++) {\n        String city = cities.get(i);\n        String label = city + \": \";\n        TimeZone zone = getTimeZone(city);\n        if (zone != null) {\n            timeFormatter.setTimeZone(zone);\n            String timeString = timeFormatter.format(time);\n            label = label + timeString;\n        } else {\n            label = label + \"unavailable\";\n        }\n        result.put(label, city);\n    }\n    return result;\n}\n","name":"getCitiesAndTimes","className":"TimeZoneBean","variables":{"result":3,"cities":2,"city":2,"zone":2,"timeString":2,"i":3,"time":1,"label":5,"timeFormatter":2},"constants":{"0":1,"null":1,"\"unavailable\"":1,"\": \"":1},"javaDoc":"Read-only citiesAndTimes property a map containing the cities and formatted times","comments":"\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"add":1,"getTimeZone":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"TimeZone":1},"expressions":{"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":2,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Action for adding a city.\n      @return null\n   */\npublic String addCity() {\n    TimeZone zone = getTimeZone(cityToAdd);\n    if (zone == null) {\n        return null;\n    }\n    cities.add(cityToAdd);\n    cityToRemove = cityToAdd;\n    cityToAdd = \"\";\n    return null;\n}\n","name":"addCity","className":"TimeZoneBean","variables":{"cities":1,"zone":2,"cityToAdd":2,"cityToRemove":1},"constants":{"\"\"":1,"null":3},"javaDoc":"Action for adding a city null","comments":"\n      Action for adding a city.\n      @return null\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Action for removing a city.\n      @return null\n   */\npublic String removeCity() {\n    cities.remove(cityToRemove);\n    return null;\n}\n","name":"removeCity","className":"TimeZoneBean","variables":{"cities":1},"constants":{"null":1},"javaDoc":"Action for removing a city null","comments":"\n      Action for removing a city.\n      @return null\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"TimeZone","methodCalls":{"getTimeZone":1,"getAvailableIDs":1,"timeZoneIDmatch":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":18,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   */\nprivate static TimeZone getTimeZone(String aCity) {\n    String[] ids = TimeZone.getAvailableIDs();\n    for (int i = 0; i < ids.length; i++) {\n        if (timeZoneIDmatch(ids[i], aCity)) {\n            return TimeZone.getTimeZone(ids[i]);\n        }\n    }\n    return null;\n}\n","name":"getTimeZone","className":"TimeZoneBean","variables":{"TimeZone":2,"ids":3,"i":5},"constants":{"0":1,"null":1},"javaDoc":"Looks up the time zone for a city aCity the city for which to find the time zone the time zone or null if no match is found","comments":"\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["String","String"],"returnType":"boolean","methodCalls":{"equals":1,"replace":1,"indexOf":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"CharLiteralExpr":3,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   */\nprivate static boolean timeZoneIDmatch(String id, String aCity) {\n    String idCity = id.substring(id.indexOf('/') + 1);\n    return idCity.replace('_', ' ').equals(aCity);\n}\n","name":"timeZoneIDmatch","className":"TimeZoneBean","variables":{"idCity":2,"id":2},"constants":{"1":1,"' '":1,"'/'":1,"'_'":1},"javaDoc":"Checks whether a time zone ID matches a city id the time zone ID (e g \"America/Los_Angeles\") aCity the city to match (e g \"Los Angeles\") true if the ID and city match","comments":"\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":10}
{"paramTypes":[],"returnType":"TimeZoneBean","methodCalls":{"getTimeInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Initializes the formatter.\n   */\npublic TimeZoneBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n}\n","name":"TimeZoneBean","className":"TimeZoneBean","variables":{"DateFormat":1,"timeFormatter":1},"constants":{},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Setter for city property.\n      @param aCity the city for which to report the local time\n   */\npublic void setCity(String aCity) {\n    city = aCity;\n}\n","name":"setCity","className":"TimeZoneBean","variables":{"city":1,"aCity":1},"constants":{},"javaDoc":"Setter for city property aCity the city for which to report the local time","comments":"\n      Setter for city property.\n      @param aCity the city for which to report the local time\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Getter for city property.\n      @return the city for which to report the local time\n   */\npublic String getCity() {\n    return city;\n}\n","name":"getCity","className":"TimeZoneBean","variables":{"city":1},"constants":{},"javaDoc":"Getter for city property the city for which to report the local time","comments":"\n      Getter for city property.\n      @return the city for which to report the local time\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"setTimeZone":1,"format":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"Date":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":3},"text":"/**\n      Read-only time property.\n      @return the formatted time\n   */\npublic String getTime() {\n    if (zone == null) {\n        return \"not available\";\n    }\n    timeFormatter.setTimeZone(zone);\n    Date time = new Date();\n    String timeString = timeFormatter.format(time);\n    return timeString;\n}\n","name":"getTime","className":"TimeZoneBean","variables":{"zone":1,"timeString":2,"time":1,"timeFormatter":2},"constants":{"null":1,"\"not available\"":1},"javaDoc":"Read-only time property the formatted time","comments":"\n      Read-only time property.\n      @return the formatted time\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getTimeZone":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":5,"StringLiteralExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Action for checking a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   */\npublic String checkCity() {\n    zone = getTimeZone(city);\n    if (zone == null) {\n        return \"error\";\n    }\n    return \"next\";\n}\n","name":"checkCity","className":"TimeZoneBean","variables":{"zone":2},"constants":{"null":1,"\"error\"":1,"\"next\"":1},"javaDoc":"Action for checking a city \"next\" if time zone information is available for the city \"error\" otherwise","comments":"\n      Action for checking a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String"],"returnType":"TimeZone","methodCalls":{"getTimeZone":1,"getAvailableIDs":1,"timeZoneIDmatch":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":18,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   */\nprivate static TimeZone getTimeZone(String aCity) {\n    String[] ids = TimeZone.getAvailableIDs();\n    for (int i = 0; i < ids.length; i++) {\n        if (timeZoneIDmatch(ids[i], aCity)) {\n            return TimeZone.getTimeZone(ids[i]);\n        }\n    }\n    return null;\n}\n","name":"getTimeZone","className":"TimeZoneBean","variables":{"TimeZone":2,"ids":3,"i":5},"constants":{"0":1,"null":1},"javaDoc":"Looks up the time zone for a city aCity the city for which to find the time zone the time zone or null if no match is found","comments":"\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["String","String"],"returnType":"boolean","methodCalls":{"equals":1,"replace":1,"indexOf":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"CharLiteralExpr":3,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   */\nprivate static boolean timeZoneIDmatch(String id, String aCity) {\n    String idCity = id.substring(id.indexOf('/') + 1);\n    return idCity.replace('_', ' ').equals(aCity);\n}\n","name":"timeZoneIDmatch","className":"TimeZoneBean","variables":{"idCity":2,"id":2},"constants":{"1":1,"' '":1,"'/'":1,"'_'":1},"javaDoc":"Checks whether a time zone ID matches a city id the time zone ID (e g \"America/Los_Angeles\") aCity the city to match (e g \"Los Angeles\") true if the ID and city match","comments":"\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setAnswer":1,"addChoice":4,"addQuestion":2,"presentQuestions":1,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Quiz":1,"Question":1,"ChoiceQuestion":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"BooleanLiteralExpr":4,"NameExpr":32,"StringLiteralExpr":7,"MethodCallExpr":10},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    Question first = new Question();\n    first.setText(\"Who was the inventor of Java?\");\n    first.setAnswer(\"James Gosling\");\n    ChoiceQuestion second = new ChoiceQuestion();\n    second.setText(\"In which country was the inventor of Java born?\");\n    second.addChoice(\"Australia\", false);\n    second.addChoice(\"Canada\", true);\n    second.addChoice(\"Denmark\", false);\n    second.addChoice(\"United States\", false);\n    Quiz q = new Quiz();\n    q.addQuestion(first);\n    q.addQuestion(second);\n    q.presentQuestions();\n}\n","name":"main","className":"QuizDemo","variables":{"q":4,"first":3,"second":6},"constants":{"\"Who was the inventor of Java?\"":1,"\"In which country was the inventor of Java born?\"":1,"\"Denmark\"":1,"\"United States\"":1,"\"James Gosling\"":1,"false":3,"true":1,"\"Canada\"":1,"\"Australia\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":[],"returnType":"Quiz","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a quiz with no questions.\n   */\npublic Quiz() {\n    questions = new ArrayList<Question>();\n}\n","name":"Quiz","className":"Quiz","variables":{"questions":1},"constants":{},"javaDoc":"Constructs a quiz with no questions","comments":"\n      Constructs a quiz with no questions.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Question"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds a question to this quiz.\n      @param q the question\n   */\npublic void addQuestion(Question q) {\n    questions.add(q);\n}\n","name":"addQuestion","className":"Quiz","variables":{"questions":1},"constants":{},"javaDoc":"Adds a question to this quiz q the question","comments":"\n      Adds a question to this quiz.\n      @param q the question\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"display":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Question":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":24,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":5},"text":"/**\n      Presents the questions to the user and checks the response.\n   */\npublic void presentQuestions() {\n    Scanner in = new Scanner(System.in);\n    for (Question q : questions) {\n        q.display();\n        System.out.print(\"Your answer: \");\n        String response = in.nextLine();\n        System.out.println(q.checkAnswer(response));\n    }\n}\n","name":"presentQuestions","className":"Quiz","variables":{"q":3,"in":2,"response":1,"questions":1},"constants":{"\"Your answer: \"":1},"javaDoc":"Presents the questions to the user and checks the response","comments":"\n      Presents the questions to the user and checks the response.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"constants":{"\"\"":2},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":1},"constants":{},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":1},"constants":{},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":1},"constants":{},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"constants":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ChoiceQuestion","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a choice question with no choices.\n   */\npublic ChoiceQuestion() {\n    choices = new ArrayList<String>();\n}\n","name":"ChoiceQuestion","className":"ChoiceQuestion","variables":{"choices":1},"constants":{},"javaDoc":"Constructs a choice question with no choices","comments":"\n      Constructs a choice question with no choices.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","boolean"],"returnType":"void","methodCalls":{"add":1,"size":1,"setAnswer":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   */\npublic void addChoice(String choice, boolean correct) {\n    choices.add(choice);\n    if (correct) {\n        // Convert choices.size() to string\n        String choiceString = \"\" + choices.size();\n        setAnswer(choiceString);\n    }\n}\n","name":"addChoice","className":"ChoiceQuestion","variables":{"correct":1,"choiceString":1,"choices":2},"constants":{"\"\"":1},"javaDoc":"Adds an answer choice to this question choice the choice to add correct true if this is the correct choice false otherwise","comments":"Convert choices size() to string \n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"SuperExpr":1,"BinaryExpr":4,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public void display() {\n    // Display the question text\n    super.display();\n    // Display the answer choices\n    for (int i = 0; i < choices.size(); i++) {\n        int choiceNumber = i + 1;\n        System.out.println(choiceNumber + \": \" + choices.get(i));\n    }\n}\n","name":"display","className":"ChoiceQuestion","variables":{"choiceNumber":2,"i":4,"choices":2},"constants":{"0":1,"1":1,"\": \"":1},"javaDoc":"","comments":"Display the question text Display the answer choices ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Address"],"returnType":"Invoice","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an invoice.\n      @param anAddress the billing address\n   */\npublic Invoice(Address anAddress) {\n    items = new ArrayList<LineItem>();\n    billingAddress = anAddress;\n}\n","name":"Invoice","className":"Invoice","variables":{"anAddress":1,"billingAddress":1,"items":1},"constants":{},"javaDoc":"Constructs an invoice anAddress the billing address","comments":"\n      Constructs an invoice.\n      @param anAddress the billing address\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Product","int"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LineItem":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Adds a charge for a product to this invoice.\n      @param aProduct the product that the customer ordered\n      @param quantity the quantity of the product\n   */\npublic void add(Product aProduct, int quantity) {\n    LineItem anItem = new LineItem(aProduct, quantity);\n    items.add(anItem);\n}\n","name":"add","className":"Invoice","variables":{"quantity":1,"aProduct":1,"anItem":1,"items":1},"constants":{},"javaDoc":"Adds a charge for a product to this invoice aProduct the product that the customer ordered quantity the quantity of the product","comments":"\n      Adds a charge for a product to this invoice.\n      @param aProduct the product that the customer ordered\n      @param quantity the quantity of the product\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":4,"getAmountDue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LineItem":1,"String":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":5,"StringLiteralExpr":8,"NameExpr":20,"MethodCallExpr":5,"AssignExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Formats the invoice.\n      @return the formatted invoice\n   */\npublic String format() {\n    String r = \"                     I N V O I C E\\n\\n\" + billingAddress.format() + String.format(\"\\n\\n%-30s%8s%5s%8s\\n\", \"Description\", \"Price\", \"Qty\", \"Total\");\n    for (LineItem item : items) {\n        r = r + item.format() + \"\\n\";\n    }\n    r = r + String.format(\"\\nAMOUNT DUE: $%8.2f\", getAmountDue());\n    return r;\n}\n","name":"format","className":"Invoice","variables":{"r":6,"item":2,"billingAddress":1,"String":2,"items":1},"constants":{"\"Price\"":1,"\"Description\"":1,"\"\\nAMOUNT DUE: $%8.2f\"":1,"\"                     I N V O I C E\\n\\n\"":1,"\"Qty\"":1,"\"\\n\\n%-30s%8s%5s%8s\\n\"":1,"\"Total\"":1,"\"\\n\"":1},"javaDoc":"Formats the invoice the formatted invoice","comments":"\n      Formats the invoice.\n      @return the formatted invoice\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getTotalPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"LineItem":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the total amount due.\n      @return the amount due\n   */\nprivate double getAmountDue() {\n    double amountDue = 0;\n    for (LineItem item : items) {\n        amountDue = amountDue + item.getTotalPrice();\n    }\n    return amountDue;\n}\n","name":"getAmountDue","className":"Invoice","variables":{"amountDue":4,"item":2,"items":1},"constants":{"0":1},"javaDoc":"Computes the total amount due the amount due","comments":"\n      Computes the total amount due.\n      @return the amount due\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"format":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Invoice":1,"Address":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"DoubleLiteralExpr":3,"StringLiteralExpr":8,"NameExpr":18,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Address samsAddress = new Address(\"Sam's Small Appliances\", \"100 Main Street\", \"Anytown\", \"CA\", \"98765\");\n    Invoice samsInvoice = new Invoice(samsAddress);\n    samsInvoice.add(new Product(\"Toaster\", 29.95), 3);\n    samsInvoice.add(new Product(\"Hair dryer\", 24.95), 1);\n    samsInvoice.add(new Product(\"Car vacuum\", 19.99), 2);\n    System.out.println(samsInvoice.format());\n}\n","name":"main","className":"InvoicePrinter","variables":{"samsInvoice":5,"samsAddress":2},"constants":{"\"Hair dryer\"":1,"\"Anytown\"":1,"\"98765\"":1,"\"Car vacuum\"":1,"19.99":1,"\"100 Main Street\"":1,"\"Toaster\"":1,"24.95":1,"1":1,"\"CA\"":1,"2":1,"3":1,"29.95":1,"\"Sam's Small Appliances\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Product","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   */\npublic Product(String aDescription, double aPrice) {\n    description = aDescription;\n    price = aPrice;\n}\n","name":"Product","className":"Product","variables":{"aDescription":1,"price":1,"description":1,"aPrice":1},"constants":{},"javaDoc":"Constructs a product from a description and a price aDescription the product description aPrice the product price","comments":"\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product description.\n      @return the description\n   */\npublic String getDescription() {\n    return description;\n}\n","name":"getDescription","className":"Product","variables":{"description":1},"constants":{},"javaDoc":"Gets the product description the description","comments":"\n      Gets the product description.\n      @return the description\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product price.\n      @return the unit price\n   */\npublic double getPrice() {\n    return price;\n}\n","name":"getPrice","className":"Product","variables":{"price":1},"constants":{},"javaDoc":"Gets the product price the unit price","comments":"\n      Gets the product price.\n      @return the unit price\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","String","String","String","String"],"returnType":"Address","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"AssignExpr":5},"statements":{"ExpressionStmt":5},"text":"/**\n      Constructs a mailing address. \n      @param aName the recipient name\n      @param aStreet the street\n      @param aCity the city\n      @param aState the two-letter state code\n      @param aZip the ZIP postal code\n   */\npublic Address(String aName, String aStreet, String aCity, String aState, String aZip) {\n    name = aName;\n    street = aStreet;\n    city = aCity;\n    state = aState;\n    zip = aZip;\n}\n","name":"Address","className":"Address","variables":{"zip":1,"aStreet":1,"city":1,"street":1,"aName":1,"name":1,"aCity":1,"state":1,"aState":1,"aZip":1},"constants":{},"javaDoc":"Constructs a mailing address aName the recipient name aStreet the street aCity the city aState the two-letter state code aZip the ZIP postal code","comments":"\n      Constructs a mailing address. \n      @param aName the recipient name\n      @param aStreet the street\n      @param aCity the city\n      @param aState the two-letter state code\n      @param aZip the ZIP postal code\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":8,"NameExpr":5,"StringLiteralExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n      Formats the address.\n      @return the address as a string with three lines\n   */\npublic String format() {\n    return name + \"\\n\" + street + \"\\n\" + city + \", \" + state + \" \" + zip;\n}\n","name":"format","className":"Address","variables":{"zip":1,"city":1,"street":1,"name":1,"state":1},"constants":{"\" \"":1,"\", \"":1,"\"\\n\"":2},"javaDoc":"Formats the address the address as a string with three lines","comments":"\n      Formats the address.\n      @return the address as a string with three lines\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Product","int"],"returnType":"LineItem","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   */\npublic LineItem(Product aProduct, int aQuantity) {\n    theProduct = aProduct;\n    quantity = aQuantity;\n}\n","name":"LineItem","className":"LineItem","variables":{"quantity":1,"aProduct":1,"aQuantity":1,"theProduct":1},"constants":{},"javaDoc":"Constructs an item from the product and quantity aProduct the product aQuantity the item quantity","comments":"\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes the total cost of this line item.\n      @return the total price\n   */\npublic double getTotalPrice() {\n    return theProduct.getPrice() * quantity;\n}\n","name":"getTotalPrice","className":"LineItem","variables":{"quantity":1,"theProduct":1},"constants":{},"javaDoc":"Computes the total cost of this line item the total price","comments":"\n      Computes the total cost of this line item.\n      @return the total price\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1,"getTotalPrice":1,"getDescription":1,"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n      Formats this item.\n      @return a formatted string of this item\n   */\npublic String format() {\n    return String.format(\"%-30s%8.2f%5d%8.2f\", theProduct.getDescription(), theProduct.getPrice(), quantity, getTotalPrice());\n}\n","name":"format","className":"LineItem","variables":{"String":1,"theProduct":2},"constants":{"\"%-30s%8.2f%5d%8.2f\"":1},"javaDoc":"Formats this item a formatted string of this item","comments":"\n      Formats this item.\n      @return a formatted string of this item\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Deposits money into the account.\n      @param amount the amount of money to withdraw\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the account amount the amount of money to withdraw","comments":" \n      Deposits money into the account.\n      @param amount the amount of money to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Withdraws money from the account.\n      @param amount the amount of money to deposit\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the account amount the amount of money to deposit","comments":" \n      Withdraws money from the account.\n      @param amount the amount of money to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the account balance.\n      @return the account balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the account balance the account balance","comments":" \n      Gets the account balance.\n      @return the account balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"showMessageDialog":1,"readCustomers":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Bank":1,"JFrame":1,"ATM":1,"ATMFrame":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    ATM theATM;\n    try {\n        Bank theBank = new Bank();\n        theBank.readCustomers(\"customers.txt\");\n        theATM = new ATM(theBank);\n    } catch (IOException e) {\n        JOptionPane.showMessageDialog(null, \"Error opening accounts file.\");\n        return;\n    }\n    JFrame frame = new ATMFrame(theATM);\n    frame.setTitle(\"First National Bank of Java\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ATMViewer","variables":{"theATM":3,"theBank":3,"e":1,"JOptionPane":1,"frame":4},"constants":{"\"customers.txt\"":1,"\"Error opening accounts file.\"":1,"null":1,"true":1,"\"First National Bank of Java\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"selectAccount":2,"back":3,"nextInt":2,"nextDouble":2,"setCustomerNumber":1,"getState":1,"getBalance":1,"readCustomers":1,"reset":1,"deposit":1,"equalsIgnoreCase":6,"System.out.print":6,"selectCustomer":1,"System.out.println":4,"withdraw":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Scanner":1,"Bank":1,"double":2,"ATM":1,"String":2,"int":3},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":10,"BooleanLiteralExpr":1,"BinaryExpr":5,"NameExpr":156,"StringLiteralExpr":17,"FieldAccessExpr":17,"MethodCallExpr":35,"AssignExpr":1},"statements":{"IfStmt":10,"WhileStmt":1,"TryStmt":1,"BlockStmt":15,"ReturnStmt":1,"ExpressionStmt":32},"text":"public static void main(String[] args) {\n    ATM theATM;\n    try {\n        Bank theBank = new Bank();\n        theBank.readCustomers(\"customers.txt\");\n        theATM = new ATM(theBank);\n    } catch (IOException e) {\n        System.out.println(\"Error opening accounts file.\");\n        return;\n    }\n    Scanner in = new Scanner(System.in);\n    while (true) {\n        int state = theATM.getState();\n        if (state == ATM.START) {\n            System.out.print(\"Enter customer number: \");\n            int number = in.nextInt();\n            theATM.setCustomerNumber(number);\n        } else if (state == ATM.PIN) {\n            System.out.print(\"Enter PIN: \");\n            int pin = in.nextInt();\n            theATM.selectCustomer(pin);\n        } else if (state == ATM.ACCOUNT) {\n            System.out.print(\"A=Checking, B=Savings, C=Quit: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                theATM.selectAccount(ATM.CHECKING);\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                theATM.selectAccount(ATM.SAVINGS);\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.reset();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        } else if (state == ATM.TRANSACT) {\n            System.out.println(\"Balance=\" + theATM.getBalance());\n            System.out.print(\"A=Deposit, B=Withdrawal, C=Cancel: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.deposit(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.withdraw(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.back();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        }\n    }\n}\n","name":"main","className":"ATMSimulator","variables":{"number":1,"amount":2,"theATM":14,"theBank":3,"pin":1,"e":1,"in":7,"state":5,"command":8},"constants":{"\"customers.txt\"":1,"\"Error opening accounts file.\"":1,"\"Enter customer number: \"":1,"\"Illegal input!\"":2,"\"C\"":2,"\"B\"":2,"\"A\"":2,"\"A=Checking, B=Savings, C=Quit: \"":1,"\"Balance=\"":1,"\"A=Deposit, B=Withdrawal, C=Cancel: \"":1,"true":1,"\"Amount: \"":2,"\"Enter PIN: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int","int"],"returnType":"Customer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":6,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a customer with a given number and PIN.\n      @param aNumber the customer number\n      @param aPin the personal identification number\n   */\npublic Customer(int aNumber, int aPin) {\n    customerNumber = aNumber;\n    pin = aPin;\n    checkingAccount = new BankAccount();\n    savingsAccount = new BankAccount();\n}\n","name":"Customer","className":"Customer","variables":{"aNumber":1,"pin":1,"savingsAccount":1,"checkingAccount":1,"aPin":1,"customerNumber":1},"constants":{},"javaDoc":"Constructs a customer with a given number and PIN aNumber the customer number aPin the personal identification number","comments":"\n      Constructs a customer with a given number and PIN.\n      @param aNumber the customer number\n      @param aPin the personal identification number\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":4},"statements":{"ReturnStmt":1},"text":"/** \n      Tests if this customer matches a customer number \n      and PIN.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return true if the customer number and PIN match\n   */\npublic boolean match(int aNumber, int aPin) {\n    return customerNumber == aNumber && pin == aPin;\n}\n","name":"match","className":"Customer","variables":{"aNumber":1,"pin":1,"aPin":1,"customerNumber":1},"constants":{},"javaDoc":"Tests if this customer matches a customer number and PIN aNumber a customer number aPin a personal identification number true if the customer number and PIN match","comments":" \n      Tests if this customer matches a customer number \n      and PIN.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return true if the customer number and PIN match\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the checking account of this customer.\n      @return the checking account\n   */\npublic BankAccount getCheckingAccount() {\n    return checkingAccount;\n}\n","name":"getCheckingAccount","className":"Customer","variables":{"checkingAccount":1},"constants":{},"javaDoc":"Gets the checking account of this customer the checking account","comments":" \n      Gets the checking account of this customer.\n      @return the checking account\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the savings account of this customer.\n      @return the checking account\n   */\npublic BankAccount getSavingsAccount() {\n    return savingsAccount;\n}\n","name":"getSavingsAccount","className":"Customer","variables":{"savingsAccount":1},"constants":{},"javaDoc":"Gets the savings account of this customer the checking account","comments":" \n      Gets the savings account of this customer.\n      @return the checking account\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Bank","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank with no customers.\n   */\npublic Bank() {\n    customers = new ArrayList<Customer>();\n}\n","name":"Bank","className":"Bank","variables":{"customers":1},"constants":{},"javaDoc":"Constructs a bank with no customers","comments":"\n      Constructs a bank with no customers.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"addCustomer":1,"hasNext":1,"nextInt":2,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Scanner":1,"Customer":1,"int":2},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":4,"NameExpr":18,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"/**\n      Reads the customer numbers and pins.\n      @param filename the name of the customer file\n   */\npublic void readCustomers(String filename) throws IOException {\n    Scanner in = new Scanner(new File(filename));\n    while (in.hasNext()) {\n        int number = in.nextInt();\n        int pin = in.nextInt();\n        Customer c = new Customer(number, pin);\n        addCustomer(c);\n    }\n    in.close();\n}\n","name":"readCustomers","className":"Bank","variables":{"number":2,"filename":1,"c":1,"pin":2,"in":5},"constants":{},"javaDoc":"Reads the customer numbers and pins filename the name of the customer file","comments":"\n      Reads the customer numbers and pins.\n      @param filename the name of the customer file\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["Customer"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds a customer to the bank.\n      @param c the customer to add\n   */\npublic void addCustomer(Customer c) {\n    customers.add(c);\n}\n","name":"addCustomer","className":"Bank","variables":{"customers":1},"constants":{},"javaDoc":"Adds a customer to the bank c the customer to add","comments":"\n      Adds a customer to the bank.\n      @param c the customer to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Customer","methodCalls":{"match":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Customer":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ReturnStmt":2},"text":"/** \n      Finds a customer in the bank.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return the matching customer, or null if no customer \n      matches\n   */\npublic Customer findCustomer(int aNumber, int aPin) {\n    for (Customer c : customers) {\n        if (c.match(aNumber, aPin)) {\n            return c;\n        }\n    }\n    return null;\n}\n","name":"findCustomer","className":"Bank","variables":{"c":3,"customers":1},"constants":{"null":1},"javaDoc":"Finds a customer in the bank aNumber a customer number aPin a personal identification number the matching customer or null if no customer matches","comments":" \n      Finds a customer in the bank.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return the matching customer, or null if no customer \n      matches\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Bank"],"returnType":"ATM","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   */\npublic ATM(Bank aBank) {\n    theBank = aBank;\n    reset();\n}\n","name":"ATM","className":"ATM","variables":{"theBank":1,"aBank":1},"constants":{},"javaDoc":"Constructs an ATM for a given bank aBank the bank to which this ATM connects","comments":"\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Resets the ATM to the initial state.\n   */\npublic void reset() {\n    customerNumber = -1;\n    currentAccount = null;\n    state = START;\n}\n","name":"reset","className":"ATM","variables":{"START":1,"currentAccount":1,"state":1,"customerNumber":1},"constants":{"1":1,"null":1},"javaDoc":"Resets the ATM to the initial state","comments":"\n      Resets the ATM to the initial state.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   */\npublic void setCustomerNumber(int number) {\n    customerNumber = number;\n    state = PIN;\n}\n","name":"setCustomerNumber","className":"ATM","variables":{"number":1,"PIN":1,"state":1,"customerNumber":1},"constants":{},"javaDoc":"Sets the current customer number and sets state to PIN (Precondition: state is START) number the customer number","comments":" \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"findCustomer":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":11,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   */\npublic void selectCustomer(int pin) {\n    currentCustomer = theBank.findCustomer(customerNumber, pin);\n    if (currentCustomer == null) {\n        state = START;\n    } else {\n        state = ACCOUNT;\n    }\n}\n","name":"selectCustomer","className":"ATM","variables":{"ACCOUNT":1,"currentCustomer":2,"theBank":1,"START":1,"state":2},"constants":{"null":1},"javaDoc":"Finds customer in bank If found sets state to ACCOUNT else to START (Precondition: state is PIN) pin the PIN of the current customer","comments":" \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getCheckingAccount":1,"getSavingsAccount":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":12,"AssignExpr":3,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   */\npublic void selectAccount(int account) {\n    if (account == CHECKING) {\n        currentAccount = currentCustomer.getCheckingAccount();\n    } else {\n        currentAccount = currentCustomer.getSavingsAccount();\n    }\n    state = TRANSACT;\n}\n","name":"selectAccount","className":"ATM","variables":{"currentCustomer":2,"TRANSACT":1,"CHECKING":1,"currentAccount":2,"state":1,"account":1},"constants":{},"javaDoc":"Sets current account to checking or savings Sets state to TRANSACT (Precondition: state is ACCOUNT or TRANSACT) account one of CHECKING or SAVINGS","comments":" \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"withdraw":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   */\npublic void withdraw(double value) {\n    currentAccount.withdraw(value);\n}\n","name":"withdraw","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Withdraws amount from current account (Precondition: state is TRANSACT) value the amount to withdraw","comments":" \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"deposit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   */\npublic void deposit(double value) {\n    currentAccount.deposit(value);\n}\n","name":"deposit","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Deposits amount to current account (Precondition: state is TRANSACT) value the amount to deposit","comments":" \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getBalance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   */\npublic double getBalance() {\n    return currentAccount.getBalance();\n}\n","name":"getBalance","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Gets the balance of the current account (Precondition: state is TRANSACT) the balance","comments":" \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":12,"AssignExpr":3},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":3},"text":"/**\n      Moves back to the previous state.\n   */\npublic void back() {\n    if (state == TRANSACT) {\n        state = ACCOUNT;\n    } else if (state == ACCOUNT) {\n        state = PIN;\n    } else if (state == PIN) {\n        state = START;\n    }\n}\n","name":"back","className":"ATM","variables":{"ACCOUNT":2,"TRANSACT":1,"PIN":2,"START":1,"state":6},"constants":{},"javaDoc":"Moves back to the previous state","comments":"\n      Moves back to the previous state.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current state of this ATM.\n      @return the current state\n   */\npublic int getState() {\n    return state;\n}\n","name":"getState","className":"ATM","variables":{"state":1},"constants":{},"javaDoc":"Gets the current state of this ATM the current state","comments":"\n      Gets the current state of this ATM.\n      @return the current state\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    display.setText(\"\");\n}\n","name":"actionPerformed","className":"ClearButtonListener","variables":{"display":1},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"KeyPad","methodCalls":{"add":3,"addActionListener":1,"addButton":11,"setLayout":2,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"ClearButtonListener":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":50,"StringLiteralExpr":15,"MethodCallExpr":18,"AssignExpr":3},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":22},"text":"/**\n      Constructs the keypad panel.\n   */\npublic KeyPad() {\n    setLayout(new BorderLayout());\n    // Add display field\n    display = new JTextField();\n    add(display, \"North\");\n    // Make button panel\n    buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 3));\n    // Add digit buttons\n    addButton(\"7\");\n    addButton(\"8\");\n    addButton(\"9\");\n    addButton(\"4\");\n    addButton(\"5\");\n    addButton(\"6\");\n    addButton(\"1\");\n    addButton(\"2\");\n    addButton(\"3\");\n    addButton(\"0\");\n    addButton(\".\");\n    // Add clear entry button\n    clearButton = new JButton(\"CE\");\n    buttonPanel.add(clearButton);\n    class ClearButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            display.setText(\"\");\n        }\n    }\n    ActionListener listener = new ClearButtonListener();\n    clearButton.addActionListener(new ClearButtonListener());\n    add(buttonPanel, \"Center\");\n}\n","name":"KeyPad","className":"KeyPad","variables":{"actionPerformed":1,"clearButton":2,"display":2,"buttonPanel":3,"listener":1,"ClearButtonListener":1,"event":1},"constants":{"\"North\"":1,"\"\"":1,"\"9\"":1,"\"8\"":1,"\"Center\"":1,"\"7\"":1,"\"6\"":1,"\"CE\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"3":1,"\"1\"":1,"4":1,"\"0\"":1,"\".\"":1},"javaDoc":"Constructs the keypad panel","comments":"Add display field Make button panel Add digit buttons Add clear entry button \n      Constructs the keypad panel.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":26,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":2,"equals":1,"indexOf":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":3,"NameExpr":15,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    // Don't add two decimal points\n    if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n        return;\n    }\n    // Append label text to button\n    display.setText(display.getText() + label);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"display":3,"label":2},"constants":{"1":1,"\".\"":2},"javaDoc":"","comments":"Don't add two decimal points Append label text to button ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"getText":2,"equals":1,"addActionListener":1,"indexOf":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":28,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"TypeDeclarationStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Adds a button to the button panel \n      @param label the button label\n   */\nprivate void addButton(final String label) {\n    class DigitButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            // Don't add two decimal points\n            if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n                return;\n            }\n            // Append label text to button\n            display.setText(display.getText() + label);\n        }\n    }\n    JButton button = new JButton(label);\n    buttonPanel.add(button);\n    ActionListener listener = new DigitButtonListener();\n    button.addActionListener(listener);\n}\n","name":"addButton","className":"KeyPad","variables":{"button":2,"actionPerformed":1,"DigitButtonListener":1,"display":3,"buttonPanel":1,"listener":1,"label":3,"event":1},"constants":{"1":1,"\".\"":2},"javaDoc":"Adds a button to the button panel label the button label","comments":"Don't add two decimal points Append label text to button \n      Adds a button to the button panel \n      @param label the button label\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":2}
{"paramTypes":[],"returnType":"double","methodCalls":{"parseDouble":1,"getText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   */\npublic double getValue() {\n    return Double.parseDouble(display.getText());\n}\n","name":"getValue","className":"KeyPad","variables":{"display":1,"Double":1},"constants":{},"javaDoc":"Gets the value that the user entered the value in the text field of the keypad","comments":" \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Clears the display. \n   */\npublic void clear() {\n    display.setText(\"\");\n}\n","name":"clear","className":"KeyPad","variables":{"display":1},"constants":{"\"\"":1},"javaDoc":"Clears the display","comments":" \n      Clears the display. \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ATM"],"returnType":"ATMFrame","methodCalls":{"add":6,"showState":1,"setSize":1,"addActionListener":3,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":45,"StringLiteralExpr":3,"AssignExpr":6,"MethodCallExpr":12},"statements":{"ExpressionStmt":19},"text":"/**\n      Constructs the user interface of the ATM frame.\n   */\npublic ATMFrame(ATM anATM) {\n    theATM = anATM;\n    // Construct components\n    pad = new KeyPad();\n    display = new JTextArea(4, 20);\n    aButton = new JButton(\"  A  \");\n    aButton.addActionListener(new AButtonListener());\n    bButton = new JButton(\"  B  \");\n    bButton.addActionListener(new BButtonListener());\n    cButton = new JButton(\"  C  \");\n    cButton.addActionListener(new CButtonListener());\n    // Add components\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.add(aButton);\n    buttonPanel.add(bButton);\n    buttonPanel.add(cButton);\n    setLayout(new FlowLayout());\n    add(pad);\n    add(display);\n    add(buttonPanel);\n    showState();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"ATMFrame","className":"ATMFrame","variables":{"aButton":2,"pad":1,"theATM":1,"anATM":1,"display":1,"buttonPanel":4,"cButton":2,"bButton":2},"constants":{"\"  C  \"":1,"\"  B  \"":1,"4":1,"\"  A  \"":1,"20":1},"javaDoc":"Constructs the user interface of the ATM frame","comments":"Add components Construct components \n      Constructs the user interface of the ATM frame.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":20,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getState":1,"getBalance":1,"clear":1,"setText":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":8,"NameExpr":37,"StringLiteralExpr":7,"FieldAccessExpr":4,"MethodCallExpr":7},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":6},"text":"/** \n      Updates display message.\n   */\npublic void showState() {\n    int state = theATM.getState();\n    pad.clear();\n    if (state == ATM.START) {\n        display.setText(\"Enter customer number\\nA = OK\");\n    } else if (state == ATM.PIN) {\n        display.setText(\"Enter PIN\\nA = OK\");\n    } else if (state == ATM.ACCOUNT) {\n        display.setText(\"Select Account\\n\" + \"A = Checking\\nB = Savings\\nC = Exit\");\n    } else if (state == ATM.TRANSACT) {\n        display.setText(\"Balance = \" + theATM.getBalance() + \"\\nEnter amount and select transaction\\n\" + \"A = Withdraw\\nB = Deposit\\nC = Cancel\");\n    }\n}\n","name":"showState","className":"ATMFrame","variables":{"pad":1,"theATM":2,"display":4,"state":5},"constants":{"\"Select Account\\n\"":1,"\"Balance = \"":1,"\"A = Withdraw\\nB = Deposit\\nC = Cancel\"":1,"\"Enter PIN\\nA = OK\"":1,"\"A = Checking\\nB = Savings\\nC = Exit\"":1,"\"\\nEnter amount and select transaction\\n\"":1,"\"Enter customer number\\nA = OK\"":1},"javaDoc":"Updates display message","comments":" \n      Updates display message.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setCustomerNumber":1,"showState":1,"getValue":3,"getState":1,"selectAccount":1,"back":1,"selectCustomer":1,"withdraw":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":48,"CastExpr":2,"FieldAccessExpr":5,"MethodCallExpr":10},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":7},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.START) {\n        theATM.setCustomerNumber((int) pad.getValue());\n    } else if (state == ATM.PIN) {\n        theATM.selectCustomer((int) pad.getValue());\n    } else if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.CHECKING);\n    } else if (state == ATM.TRANSACT) {\n        theATM.withdraw(pad.getValue());\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"AButtonListener","variables":{"pad":3,"theATM":6,"state":5},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getValue":1,"getState":1,"selectAccount":1,"deposit":1,"back":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":28,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.SAVINGS);\n    } else if (state == ATM.TRANSACT) {\n        theATM.deposit(pad.getValue());\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"BButtonListener","variables":{"pad":1,"theATM":4,"state":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getState":1,"reset":1,"back":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":19,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.reset();\n    } else if (state == ATM.TRANSACT) {\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"CButtonListener","variables":{"theATM":3,"state":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"openConnection":1,"hasNextLine":1,"getResponseCode":1,"getResponseMessage":1,"getInputStream":1,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["Casting"],"types":{"Scanner":1,"HttpURLConnection":1,"InputStream":1,"String":3,"URL":1,"URLConnection":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"VariableDeclarationExpr":9,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":50,"StringLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":5,"AssignExpr":2,"MethodCallExpr":9},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":14},"text":"public static void main(String[] args) throws IOException {\n    // Get command line arguments\n    String urlString;\n    if (args.length == 1) {\n        urlString = args[0];\n    } else {\n        urlString = \"http://horstmann.com/\";\n        System.out.println(\"Using \" + urlString);\n    }\n    // Open connection\n    URL u = new URL(urlString);\n    URLConnection connection = u.openConnection();\n    // Check if response code is HTTP_OK (200)\n    HttpURLConnection httpConnection = (HttpURLConnection) connection;\n    int code = httpConnection.getResponseCode();\n    String message = httpConnection.getResponseMessage();\n    System.out.println(code + \" \" + message);\n    if (code != HttpURLConnection.HTTP_OK) {\n        return;\n    }\n    // Read server response\n    InputStream instream = connection.getInputStream();\n    Scanner in = new Scanner(instream);\n    while (in.hasNextLine()) {\n        String input = in.nextLine();\n        System.out.println(input);\n    }\n}\n","name":"main","className":"URLGet","variables":{"args":1,"input":1,"code":3,"u":2,"in":3,"urlString":5,"connection":3,"httpConnection":3,"instream":2,"message":2},"constants":{"0":1,"1":1,"\" \"":1,"\"Using \"":1,"\"http://horstmann.com/\"":1},"javaDoc":"","comments":"Get command line arguments Open connection Check if response code is HTTP_OK (200) Read server response ","isEmpty":false,"hasInnerClass":false,"lineCount":16,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":1,"flush":1,"nextLine":1,"hasNextLine":1,"getOutputStream":1,"getInputStream":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables"],"types":{"Scanner":1,"InputStream":1,"OutputStream":1,"String":4,"int":1,"Socket":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":3,"VariableDeclarationExpr":10,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":45,"StringLiteralExpr":7,"FieldAccessExpr":3,"AssignExpr":4,"MethodCallExpr":8},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":17},"text":"public static void main(String[] args) throws IOException {\n    // Get command-line arguments\n    String host;\n    String resource;\n    if (args.length == 2) {\n        host = args[0];\n        resource = args[1];\n    } else {\n        System.out.println(\"Getting / from horstmann.com\");\n        host = \"horstmann.com\";\n        resource = \"/\";\n    }\n    // Open socket\n    final int HTTP_PORT = 80;\n    try (Socket s = new Socket(host, HTTP_PORT)) {\n        // Get streams\n        InputStream instream = s.getInputStream();\n        OutputStream outstream = s.getOutputStream();\n        // Turn streams into scanners and writers\n        Scanner in = new Scanner(instream);\n        PrintWriter out = new PrintWriter(outstream);\n        // Send command\n        String command = \"GET \" + resource + \" HTTP/1.1\\n\" + \"Host: \" + host + \"\\n\\n\";\n        out.print(command);\n        out.flush();\n        while (in.hasNextLine()) {\n            String input = in.nextLine();\n            System.out.println(input);\n        }\n    }\n// The try-with-resources statement closes the socket\n}\n","name":"main","className":"WebGet","variables":{"args":2,"input":1,"s":3,"outstream":2,"resource":4,"in":3,"host":5,"HTTP_PORT":2,"instream":2,"command":1,"out":3},"constants":{"0":1,"1":1,"2":1,"\"\\n\\n\"":1,"\"/\"":1,"80":1,"\"Getting / from horstmann.com\"":1,"\"horstmann.com\"":1,"\"GET \"":1,"\" HTTP/1.1\\n\"":1,"\"Host: \"":1},"javaDoc":"","comments":"Get command-line arguments Open socket The try-with-resources statement closes the socket Get streams Turn streams into scanners and writers Send command Read server response ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":1,"System.out.println":2,"accept":1},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables"],"types":{"BankService":1,"Bank":1,"ServerSocket":1,"int":2,"Socket":1,"Thread":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":4,"VariableDeclarationExpr":7,"BooleanLiteralExpr":1,"NameExpr":21,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) throws IOException {\n    final int ACCOUNTS_LENGTH = 10;\n    Bank bank = new Bank(ACCOUNTS_LENGTH);\n    final int SBAP_PORT = 8888;\n    ServerSocket server = new ServerSocket(SBAP_PORT);\n    System.out.println(\"Waiting for clients to connect...\");\n    while (true) {\n        Socket s = server.accept();\n        System.out.println(\"Client connected.\");\n        BankService service = new BankService(s, bank);\n        Thread t = new Thread(service);\n        t.start();\n    }\n}\n","name":"main","className":"BankServer","variables":{"server":2,"bank":2,"s":2,"SBAP_PORT":2,"t":2,"service":2,"ACCOUNTS_LENGTH":2},"constants":{"\"Waiting for clients to connect...\"":1,"true":1,"8888":1,"\"Client connected.\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n    balanceChangeLock = new ReentrantLock();\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"balanceChangeLock":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"unlock":1,"lock":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"MethodCallExpr":2,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balanceChangeLock.lock();\n    try {\n        double newBalance = balance + amount;\n        balance = newBalance;\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2,"balanceChangeLock":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"unlock":1,"lock":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"MethodCallExpr":2,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balanceChangeLock.lock();\n    try {\n        double newBalance = balance - amount;\n        balance = newBalance;\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2,"balanceChangeLock":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Bank","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":9,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a given number of accounts.\n      @param size the number of accounts\n   */\npublic Bank(int size) {\n    accounts = new BankAccount[size];\n    for (int i = 0; i < accounts.length; i++) {\n        accounts[i] = new BankAccount();\n    }\n}\n","name":"Bank","className":"Bank","variables":{"size":1,"i":4,"accounts":2},"constants":{"0":1},"javaDoc":"Constructs a bank account with a given number of accounts size the number of accounts","comments":"\n      Constructs a bank account with a given number of accounts.\n      @param size the number of accounts\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{"deposit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Deposits money into a bank account.\n      @param accountNumber the account number\n      @param amount the amount to deposit\n   */\npublic void deposit(int accountNumber, double amount) {\n    BankAccount account = accounts[accountNumber];\n    account.deposit(amount);\n}\n","name":"deposit","className":"Bank","variables":{"accounts":1,"accountNumber":1,"account":2},"constants":{},"javaDoc":"Deposits money into a bank account accountNumber the account number amount the amount to deposit","comments":"\n      Deposits money into a bank account.\n      @param accountNumber the account number\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{"withdraw":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Withdraws money from a bank account.\n      @param accountNumber the account number\n      @param amount the amount to withdraw\n   */\npublic void withdraw(int accountNumber, double amount) {\n    BankAccount account = accounts[accountNumber];\n    account.withdraw(amount);\n}\n","name":"withdraw","className":"Bank","variables":{"accounts":1,"accountNumber":1,"account":2},"constants":{},"javaDoc":"Withdraws money from a bank account accountNumber the account number amount the amount to withdraw","comments":"\n      Withdraws money from a bank account.\n      @param accountNumber the account number\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{"getBalance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Gets the balance of a bank account.\n      @param accountNumber the account number\n      @return the account balance\n   */\npublic double getBalance(int accountNumber) {\n    BankAccount account = accounts[accountNumber];\n    return account.getBalance();\n}\n","name":"getBalance","className":"Bank","variables":{"accounts":1,"accountNumber":1,"account":2},"constants":{},"javaDoc":"Gets the balance of a bank account accountNumber the account number the account balance","comments":"\n      Gets the balance of a bank account.\n      @param accountNumber the account number\n      @return the account balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":3,"flush":3,"nextLine":2,"getOutputStream":1,"getInputStream":1,"System.out.println":5},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables"],"types":{"Scanner":1,"InputStream":1,"OutputStream":1,"String":2,"int":1,"Socket":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":3,"VariableDeclarationExpr":8,"BinaryExpr":8,"StringLiteralExpr":12,"NameExpr":69,"FieldAccessExpr":5,"MethodCallExpr":15,"AssignExpr":3},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":21},"text":"public static void main(String[] args) throws IOException {\n    final int SBAP_PORT = 8888;\n    try (Socket s = new Socket(\"localhost\", SBAP_PORT)) {\n        InputStream instream = s.getInputStream();\n        OutputStream outstream = s.getOutputStream();\n        Scanner in = new Scanner(instream);\n        PrintWriter out = new PrintWriter(outstream);\n        String command = \"DEPOSIT 3 1000\";\n        System.out.println(\"Sending: \" + command);\n        out.print(command + \"\\n\");\n        out.flush();\n        String response = in.nextLine();\n        System.out.println(\"Receiving: \" + response);\n        command = \"WITHDRAW 3 500\";\n        System.out.println(\"Sending: \" + command);\n        out.print(command + \"\\n\");\n        out.flush();\n        response = in.nextLine();\n        System.out.println(\"Receiving: \" + response);\n        command = \"QUIT\";\n        System.out.println(\"Sending: \" + command);\n        out.print(command + \"\\n\");\n        out.flush();\n    }\n}\n","name":"main","className":"BankClient","variables":{"s":3,"outstream":2,"SBAP_PORT":2,"in":3,"response":4,"instream":2,"command":9,"out":7},"constants":{"\"localhost\"":1,"\"QUIT\"":1,"\"DEPOSIT 3 1000\"":1,"\"WITHDRAW 3 500\"":1,"8888":1,"\"Receiving: \"":2,"\"Sending: \"":3,"\"\\n\"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["Socket","Bank"],"returnType":"BankService","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a service object that processes commands\n      from a socket for a bank.\n      @param aSocket the socket\n      @param aBank the bank\n   */\npublic BankService(Socket aSocket, Bank aBank) {\n    s = aSocket;\n    bank = aBank;\n}\n","name":"BankService","className":"BankService","variables":{"bank":1,"s":1,"aBank":1,"aSocket":1},"constants":{},"javaDoc":"Constructs a service object that processes commands from a socket for a bank aSocket the socket aBank the bank","comments":"\n      Constructs a service object that processes commands\n      from a socket for a bank.\n      @param aSocket the socket\n      @param aBank the bank\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"doService":1,"printStackTrace":1,"getOutputStream":1,"getInputStream":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":16,"AssignExpr":2,"MethodCallExpr":5},"statements":{"TryStmt":2,"BlockStmt":4,"ExpressionStmt":5},"text":"public void run() {\n    try {\n        try {\n            in = new Scanner(s.getInputStream());\n            out = new PrintWriter(s.getOutputStream());\n            doService();\n        } finally {\n            s.close();\n        }\n    } catch (IOException exception) {\n        exception.printStackTrace();\n    }\n}\n","name":"run","className":"BankService","variables":{"exception":2,"s":3,"in":1,"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"next":1,"equals":1,"hasNext":1,"executeCommand":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Executes all commands until the QUIT command or the\n      end of input.\n   */\npublic void doService() throws IOException {\n    while (true) {\n        if (!in.hasNext()) {\n            return;\n        }\n        String command = in.next();\n        if (command.equals(\"QUIT\")) {\n            return;\n        } else {\n            executeCommand(command);\n        }\n    }\n}\n","name":"doService","className":"BankService","variables":{"in":2,"command":2},"constants":{"\"QUIT\"":1,"true":1},"javaDoc":"Executes all commands until the QUIT command or the end of input","comments":"\n      Executes all commands until the QUIT command or the\n      end of input.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":2,"getBalance":1,"flush":2,"equals":3,"deposit":1,"nextInt":1,"nextDouble":2,"withdraw":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2,"int":1},"expressions":{"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":45,"StringLiteralExpr":5,"UnaryExpr":1,"MethodCallExpr":13},"statements":{"IfStmt":3,"BlockStmt":3,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n      Executes a single command.\n      @param command the command to execute\n   */\npublic void executeCommand(String command) {\n    int account = in.nextInt();\n    if (command.equals(\"DEPOSIT\")) {\n        double amount = in.nextDouble();\n        bank.deposit(account, amount);\n    } else if (command.equals(\"WITHDRAW\")) {\n        double amount = in.nextDouble();\n        bank.withdraw(account, amount);\n    } else if (!command.equals(\"BALANCE\")) {\n        out.println(\"Invalid command\");\n        out.flush();\n        return;\n    }\n    out.println(account + \" \" + bank.getBalance(account));\n    out.flush();\n}\n","name":"executeCommand","className":"BankService","variables":{"amount":2,"bank":3,"in":3,"account":2,"command":3,"out":4},"constants":{"\"Invalid command\"":1,"\"WITHDRAW\"":1,"\" \"":1,"\"BALANCE\"":1,"\"DEPOSIT\"":1},"javaDoc":"Executes a single command command the command to execute","comments":"\n      Executes a single command.\n      @param command the command to execute\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int","int"],"returnType":"int","methodCalls":{"search":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":23,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":3,"BlockStmt":5,"ReturnStmt":4,"ExpressionStmt":1},"text":"/**\n      Finds a value in a range of a sorted array, using the binary\n      search algorithm.\n      @param a the array in which to search\n      @param low the low index of the range\n      @param high the high index of the range\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   */\npublic static int search(int[] a, int low, int high, int value) {\n    if (low <= high) {\n        int mid = (low + high) / 2;\n        if (a[mid] == value) {\n            return mid;\n        } else if (a[mid] < value) {\n            return search(a, mid + 1, high, value);\n        } else {\n            return search(a, low, mid - 1, value);\n        }\n    } else {\n        return -1;\n    }\n}\n","name":"search","className":"BinarySearcher","variables":{"a":2,"high":2,"low":2,"mid":6,"value":2},"constants":{"1":3,"2":1},"javaDoc":"Finds a value in a range of a sorted array using the binary search algorithm a the array in which to search low the low index of the range high the high index of the range value the value to find the index at which the value occurs or -1 if it does not occur in the array","comments":"\n      Finds a value in a range of a sorted array, using the binary\n      search algorithm.\n      @param a the array in which to search\n      @param low the low index of the range\n      @param high the high index of the range\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"search":1,"randomIntArray":1,"toString":1,"sort":1,"nextInt":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"boolean":1,"int[]":1,"int":2},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"BooleanLiteralExpr":2,"BinaryExpr":3,"NameExpr":44,"StringLiteralExpr":2,"FieldAccessExpr":5,"UnaryExpr":2,"MethodCallExpr":8,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    Arrays.sort(a);\n    System.out.println(Arrays.toString(a));\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"Enter number to search for, -1 to quit: \");\n        int n = in.nextInt();\n        if (n == -1) {\n            done = true;\n        } else {\n            int pos = BinarySearcher.search(a, 0, a.length - 1, n);\n            System.out.println(\"Found in position \" + pos);\n        }\n    }\n}\n","name":"main","className":"BinarySearchDemo","variables":{"a":1,"BinarySearcher":1,"in":2,"pos":2,"Arrays":2,"done":3,"n":2,"ArrayUtil":1},"constants":{"0":1,"100":1,"1":2,"\"Enter number to search for, -1 to quit: \"":1,"false":1,"true":1,"\"Found in position \"":1,"20":1},"javaDoc":"","comments":"Construct random array ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"constants":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":6,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"constants":{"true":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":9,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{"false":1},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":8,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"constants":{"0":1,"false":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"stop":1,"start":1,"nextInt":1,"sort":1,"System.out.print":1,"getElapsedTime":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int[]":1,"int":1,"StopWatch":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":33,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter array size: \");\n    int n = in.nextInt();\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(n, 100);\n    // Use stopwatch to time selection sort\n    StopWatch timer = new StopWatch();\n    timer.start();\n    SelectionSorter.sort(a);\n    timer.stop();\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"SelectionSortTimer","variables":{"a":1,"timer":4,"in":2,"SelectionSorter":1,"n":1,"ArrayUtil":1},"constants":{"100":1,"\" milliseconds\"":1,"\"Enter array size: \"":1,"\"Elapsed time: \"":1},"javaDoc":"","comments":"Construct random array Use stopwatch to time selection sort ","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"swap":1,"minimumPosition":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":15,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        int minPos = minimumPosition(a, i);\n        ArrayUtil.swap(a, minPos, i);\n    }\n}\n","name":"sort","className":"SelectionSorter","variables":{"i":3,"minPos":1,"ArrayUtil":1},"constants":{"0":1,"1":1},"javaDoc":"Sorts an array using selection sort a the array to sort","comments":"\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":14,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   */\nprivate static int minimumPosition(int[] a, int from) {\n    int minPos = from;\n    for (int i = from + 1; i < a.length; i++) {\n        if (a[i] < a[minPos]) {\n            minPos = i;\n        }\n    }\n    return minPos;\n}\n","name":"minimumPosition","className":"SelectionSorter","variables":{"a":2,"minPos":4,"i":5,"from":2},"constants":{"1":1},"javaDoc":"Finds the smallest element in a tail range of the array a the array to sort from the first position in a to compare the position of the smallest element in the range a[from] a[a length - 1]","comments":"\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":3,"comparing":2,"toString":3,"sort":3,"getArea":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Country[]":1,"String[]":1},"expressions":{"IntegerLiteralExpr":7,"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"LambdaExpr":3,"BinaryExpr":1,"StringLiteralExpr":14,"NameExpr":61,"AssignExpr":4,"ArrayInitializerExpr":2,"FieldAccessExpr":3,"ArrayCreationExpr":2,"MethodCallExpr":15},"statements":{"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    String[] words = { \"Mary\", \"had\", \"a\", \"little\", \"lamb\" };\n    Arrays.sort(words, ( v,  w) -> v.length() - w.length());\n    System.out.println(Arrays.toString(words));\n    words = new String[] { \"Its\", \"fleece\", \"was\", \"white\", \"as\", \"snow\" };\n    Arrays.sort(words, Comparator.comparing( w -> w.length()));\n    System.out.println(Arrays.toString(words));\n    Country[] countries = new Country[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    Arrays.sort(countries, Comparator.comparing( c -> c.getArea()));\n    System.out.println(Arrays.toString(countries));\n}\n","name":"main","className":"ComparatorDemo","variables":{"c":2,"v":2,"w":4,"words":2,"countries":4,"Arrays":6,"Comparator":2},"constants":{"\"Thailand\"":1,"\"a\"":1,"513120":1,"\"Belgium\"":1,"\"little\"":1,"\"Mary\"":1,"\"Uruguay\"":1,"\"was\"":1,"\"snow\"":1,"0":1,"1":1,"\"lamb\"":1,"2":1,"30510":1,"3":1,"\"white\"":1,"\"fleece\"":1,"\"had\"":1,"176220":1,"\"Its\"":1,"\"as\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":12,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"Country[name=\" + name + \",area=\" + area + \"]\";\n}\n","name":"toString","className":"Country","variables":{"area":1,"name":1},"constants":{"\"]\"":1,"\",area=\"":1,"\"Country[name=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"merge":1,"sort":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int[]":2,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"ArrayAccessExpr":4,"BinaryExpr":6,"NameExpr":44,"FieldAccessExpr":7,"ArrayCreationExpr":2,"UnaryExpr":2,"AssignExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":3,"ReturnStmt":1,"ForStmt":2,"ExpressionStmt":7},"text":"/**\n      Sorts an array, using merge sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    if (a.length <= 1) {\n        return;\n    }\n    int[] first = new int[a.length / 2];\n    int[] second = new int[a.length - first.length];\n    // Copy the first half of a into first, the second half into second\n    for (int i = 0; i < first.length; i++) {\n        first[i] = a[i];\n    }\n    for (int i = 0; i < second.length; i++) {\n        second[i] = a[first.length + i];\n    }\n    sort(first);\n    sort(second);\n    merge(first, second, a);\n}\n","name":"sort","className":"MergeSorter","variables":{"a":2,"i":10,"first":2,"second":2},"constants":{"0":2,"1":1,"2":1},"javaDoc":"Sorts an array using merge sort a the array to sort","comments":"Copy the first half of a into first the second half into second \n      Sorts an array, using merge sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["int[]","int[]","int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":10,"BinaryExpr":6,"NameExpr":43,"FieldAccessExpr":4,"UnaryExpr":7,"AssignExpr":4},"statements":{"IfStmt":1,"WhileStmt":3,"BlockStmt":5,"ExpressionStmt":14},"text":"/**\n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   */\nprivate static void merge(int[] first, int[] second, int[] a) {\n    // Next element to consider in the first array\n    int iFirst = 0;\n    // Next element to consider in the second array\n    int iSecond = 0;\n    // Next open position in a\n    int j = 0;\n    // the smaller element into a\n    while (iFirst < first.length && iSecond < second.length) {\n        if (first[iFirst] < second[iSecond]) {\n            a[j] = first[iFirst];\n            iFirst++;\n        } else {\n            a[j] = second[iSecond];\n            iSecond++;\n        }\n        j++;\n    }\n    // Copy any remaining entries of the first array\n    while (iFirst < first.length) {\n        a[j] = first[iFirst];\n        iFirst++;\n        j++;\n    }\n    // Copy any remaining entries of the second half\n    while (iSecond < second.length) {\n        a[j] = second[iSecond];\n        iSecond++;\n        j++;\n    }\n}\n","name":"merge","className":"MergeSorter","variables":{"a":4,"iSecond":8,"j":8,"first":3,"iFirst":8,"second":3},"constants":{"0":3},"javaDoc":"Merges two sorted arrays into an array first the first sorted array second the second sorted array a the array into which to merge first and second","comments":"As long as neither iFirst nor iSecond is past the end move Note that only one of the two loops below copies entries Next element to consider in the first array Next element to consider in the second array Next open position in a the smaller element into a Copy any remaining entries of the first array Copy any remaining entries of the second half \n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"stop":1,"start":1,"nextInt":1,"sort":1,"System.out.print":1,"getElapsedTime":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int[]":1,"int":1,"StopWatch":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":33,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter array size: \");\n    int n = in.nextInt();\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(n, 100);\n    // Use stopwatch to time merge sort\n    StopWatch timer = new StopWatch();\n    timer.start();\n    MergeSorter.sort(a);\n    timer.stop();\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"MergeSortTimer","variables":{"a":1,"timer":4,"in":2,"MergeSorter":1,"n":1,"ArrayUtil":1},"constants":{"100":1,"\" milliseconds\"":1,"\"Enter array size: \"":1,"\"Elapsed time: \"":1},"javaDoc":"","comments":"Construct random array Use stopwatch to time merge sort ","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":9}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"constants":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":6,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"constants":{"true":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":9,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{"false":1},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":8,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"constants":{"0":1,"false":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"search":1,"randomIntArray":1,"toString":1,"nextInt":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"boolean":1,"int[]":1,"int":2},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"BooleanLiteralExpr":2,"BinaryExpr":2,"NameExpr":37,"StringLiteralExpr":2,"FieldAccessExpr":4,"UnaryExpr":2,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"Enter number to search for, -1 to quit: \");\n        int n = in.nextInt();\n        if (n == -1) {\n            done = true;\n        } else {\n            int pos = LinearSearcher.search(a, n);\n            System.out.println(\"Found in position \" + pos);\n        }\n    }\n}\n","name":"main","className":"LinearSearchDemo","variables":{"a":1,"in":2,"pos":2,"Arrays":1,"done":3,"n":2,"LinearSearcher":1,"ArrayUtil":1},"constants":{"100":1,"1":1,"\"Enter number to search for, -1 to quit: \"":1,"false":1,"true":1,"\"Found in position \"":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":9,"FieldAccessExpr":1,"UnaryExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2},"text":"/**\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   */\npublic static int search(int[] a, int value) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] == value) {\n            return i;\n        }\n    }\n    return -1;\n}\n","name":"search","className":"LinearSearcher","variables":{"a":1,"i":5,"value":1},"constants":{"0":1,"1":1},"javaDoc":"Finds a value in an array using the linear search algorithm a the array to search value the value to find the index at which the value occurs or -1 if it does not occur in the array","comments":"\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    QuickSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"QuickSortDemo","variables":{"a":1,"QuickSorter":1,"Arrays":2,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sorts an array, using quick sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    sort(a, 0, a.length - 1);\n}\n","name":"sort","className":"QuickSorter","variables":{},"constants":{"0":1,"1":1},"javaDoc":"Sorts an array using quick sort a the array to sort","comments":"\n      Sorts an array, using quick sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{"partition":1,"sort":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":17,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Sorts a portion of an array, using quick sort.\n      @param a the array to sort\n      @param from the first index of the portion to be sorted\n      @param to the last index of the portion to be sorted\n   */\npublic static void sort(int[] a, int from, int to) {\n    if (from >= to) {\n        return;\n    }\n    int p = partition(a, from, to);\n    sort(a, from, p);\n    sort(a, p + 1, to);\n}\n","name":"sort","className":"QuickSorter","variables":{"p":2,"from":1,"to":1},"constants":{"1":1},"javaDoc":"Sorts a portion of an array using quick sort a the array to sort from the first index of the portion to be sorted to the last index of the portion to be sorted","comments":"\n      Sorts a portion of an array, using quick sort.\n      @param a the array to sort\n      @param from the first index of the portion to be sorted\n      @param to the last index of the portion to be sorted\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"int","methodCalls":{"swap":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":6,"NameExpr":25,"UnaryExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"WhileStmt":3,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Partitions a portion of an array.\n      @param a the array to partition\n      @param from the first index of the portion to be partitioned\n      @param to the last index of the portion to be partitioned\n      @return the last index of the first partition\n   */\nprivate static int partition(int[] a, int from, int to) {\n    int pivot = a[from];\n    int i = from - 1;\n    int j = to + 1;\n    while (i < j) {\n        i++;\n        while (a[i] < pivot) {\n            i++;\n        }\n        j--;\n        while (a[j] > pivot) {\n            j--;\n        }\n        if (i < j) {\n            ArrayUtil.swap(a, i, j);\n        }\n    }\n    return j;\n}\n","name":"partition","className":"QuickSorter","variables":{"a":3,"pivot":3,"i":6,"from":2,"j":7,"to":1,"ArrayUtil":1},"constants":{"1":2},"javaDoc":"Partitions a portion of an array a the array to partition from the first index of the portion to be partitioned to the last index of the portion to be partitioned the last index of the first partition","comments":"\n      Partitions a portion of an array.\n      @param a the array to partition\n      @param from the first index of the portion to be partitioned\n      @param to the last index of the portion to be partitioned\n      @return the last index of the first partition\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"stop":3,"equals":1,"start":3,"reset":2,"nextInt":1,"sort":3,"copyOf":2,"System.out.print":1,"getElapsedTime":3,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int[]":3,"int":1,"StopWatch":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":6,"NameExpr":94,"StringLiteralExpr":8,"FieldAccessExpr":7,"UnaryExpr":1,"MethodCallExpr":23},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":21},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter array size: \");\n    int n = in.nextInt();\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(n, 100);\n    int[] a2 = Arrays.copyOf(a, a.length);\n    int[] a3 = Arrays.copyOf(a, a.length);\n    // Use stopwatch to time selection sort\n    StopWatch timer = new StopWatch();\n    timer.start();\n    ShellSorter.sort(a);\n    timer.stop();\n    System.out.println(\"Elapsed time with Shell sort: \" + timer.getElapsedTime() + \" milliseconds\");\n    timer.reset();\n    timer.start();\n    Arrays.sort(a2);\n    timer.stop();\n    System.out.println(\"Elapsed time with Arrays.sort: \" + timer.getElapsedTime() + \" milliseconds\");\n    if (!Arrays.equals(a, a2)) {\n        throw new IllegalStateException(\"Incorrect sort result\");\n    }\n    timer.reset();\n    timer.start();\n    InsertionSorter.sort(a3);\n    timer.stop();\n    System.out.println(\"Elapsed time with insertion sort: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"ShellSortTimer","variables":{"a":1,"a2":1,"timer":12,"a3":1,"ShellSorter":1,"in":2,"Arrays":4,"n":1,"InsertionSorter":1,"ArrayUtil":1},"constants":{"100":1,"\"Elapsed time with insertion sort: \"":1,"\"Incorrect sort result\"":1,"\" milliseconds\"":3,"\"Elapsed time with Shell sort: \"":1,"\"Enter array size: \"":1,"\"Elapsed time with Arrays.sort: \"":1},"javaDoc":"","comments":"Construct random array Use stopwatch to time selection sort ","isEmpty":false,"hasInnerClass":false,"lineCount":24,"modifier":9}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"constants":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":6,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"constants":{"true":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":9,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{"false":1},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":8,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"constants":{"0":1,"false":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    ShellSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"ShellSortDemo","variables":{"a":1,"ShellSorter":1,"Arrays":2,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":5,"BinaryExpr":6,"NameExpr":20,"FieldAccessExpr":1,"UnaryExpr":2,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 1; i < a.length; i++) {\n        int next = a[i];\n        // Move all larger elements up\n        int j = i;\n        while (j > 0 && a[j - 1] > next) {\n            a[j] = a[j - 1];\n            j--;\n        }\n        // Insert the element\n        a[j] = next;\n    }\n}\n","name":"sort","className":"InsertionSorter","variables":{"next":3,"a":5,"i":5,"j":7},"constants":{"0":1,"1":3},"javaDoc":"Sorts an array using insertion sort a the array to sort","comments":"Move all larger elements up Insert the element \n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"add":1,"size":1,"insertionSort":1,"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArrayList<Integer>":1,"int":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":4,"BinaryExpr":6,"NameExpr":28,"FieldAccessExpr":1,"UnaryExpr":2,"MethodCallExpr":4,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":3,"ForStmt":2,"ExpressionStmt":6},"text":"/**\n      Sorts an array, using Shell sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    // Generate the sequence values\n    ArrayList<Integer> columns = new ArrayList<Integer>();\n    int c = 1;\n    while (c < a.length) {\n        columns.add(c);\n        c = 3 * c + 1;\n    }\n    // For each column count, sort all columns\n    for (int s = columns.size() - 1; s >= 0; s--) {\n        c = columns.get(s);\n        for (int k = 0; k < c; k++) {\n            insertionSort(a, k, c);\n        }\n    }\n}\n","name":"sort","className":"ShellSorter","variables":{"c":6,"s":3,"columns":4,"k":3},"constants":{"0":2,"1":3,"3":1},"javaDoc":"Sorts an array using Shell sort a the array to sort","comments":"Generate the sequence values For each column count sort all columns \n      Sorts an array, using Shell sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"VariableDeclarationExpr":3,"ArrayAccessExpr":5,"BinaryExpr":9,"NameExpr":29,"FieldAccessExpr":1,"AssignExpr":4},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Sorts a column, using insertion sort.\n      @param a the array to sort\n      @param k the index of the first element in the column\n      @param c the gap between elements in the column\n   */\npublic static void insertionSort(int[] a, int k, int c) {\n    for (int i = k + c; i < a.length; i = i + c) {\n        int next = a[i];\n        // Move all larger elements up\n        int j = i;\n        while (j >= c && a[j - c] > next) {\n            a[j] = a[j - c];\n            j = j - c;\n        }\n        // Insert the element\n        a[j] = next;\n    }\n}\n","name":"insertionSort","className":"ShellSorter","variables":{"next":3,"a":5,"c":6,"i":6,"j":8,"k":1},"constants":{},"javaDoc":"Sorts a column using insertion sort a the array to sort k the index of the first element in the column c the gap between elements in the column","comments":"Move all larger elements up Insert the element \n      Sorts a column, using insertion sort.\n      @param a the array to sort\n      @param k the index of the first element in the column\n      @param c the gap between elements in the column\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    InsertionSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"InsertionSortDemo","variables":{"a":1,"Arrays":2,"InsertionSorter":1,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":5,"BinaryExpr":6,"NameExpr":20,"FieldAccessExpr":1,"UnaryExpr":2,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 1; i < a.length; i++) {\n        int next = a[i];\n        // Move all larger elements up\n        int j = i;\n        while (j > 0 && a[j - 1] > next) {\n            a[j] = a[j - 1];\n            j--;\n        }\n        // Insert the element\n        a[j] = next;\n    }\n}\n","name":"sort","className":"InsertionSorter","variables":{"next":3,"a":5,"i":5,"j":7},"constants":{"0":1,"1":3},"javaDoc":"Sorts an array using insertion sort a the array to sort","comments":"Move all larger elements up Insert the element \n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    SelectionSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"SelectionSortDemo","variables":{"a":1,"SelectionSorter":1,"Arrays":2,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"swap":1,"minimumPosition":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":15,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        int minPos = minimumPosition(a, i);\n        ArrayUtil.swap(a, minPos, i);\n    }\n}\n","name":"sort","className":"SelectionSorter","variables":{"i":3,"minPos":1,"ArrayUtil":1},"constants":{"0":1,"1":1},"javaDoc":"Sorts an array using selection sort a the array to sort","comments":"\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":14,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   */\nprivate static int minimumPosition(int[] a, int from) {\n    int minPos = from;\n    for (int i = from + 1; i < a.length; i++) {\n        if (a[i] < a[minPos]) {\n            minPos = i;\n        }\n    }\n    return minPos;\n}\n","name":"minimumPosition","className":"SelectionSorter","variables":{"a":2,"minPos":4,"i":5,"from":2},"constants":{"1":1},"javaDoc":"Finds the smallest element in a tail range of the array a the array to sort from the first position in a to compare the position of the smallest element in the range a[from] a[a length - 1]","comments":"\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"constants":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":6,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"constants":{"true":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":9,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{"false":1},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":8,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"constants":{"0":1,"false":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"size":1,"stop":2,"get":2,"start":2,"mostFrequent2":1,"mostFrequent1":1,"reset":1,"shuffle":1,"getElapsedTime":2,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArrayList<Integer>":1,"int[]":1,"int":6,"StopWatch":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":5,"VariableDeclarationExpr":9,"ArrayAccessExpr":2,"BinaryExpr":10,"NameExpr":101,"StringLiteralExpr":6,"FieldAccessExpr":8,"UnaryExpr":4,"ArrayCreationExpr":1,"MethodCallExpr":20,"AssignExpr":3},"statements":{"BlockStmt":4,"ForStmt":4,"ExpressionStmt":21},"text":"public static void main(String[] args) {\n    ArrayList<Integer> values = new ArrayList<Integer>();\n    int k = 300;\n    // Adds one times 1, two times 2, three times 3, ... , k times k\n    for (int i = 1; i <= k; i++) {\n        for (int j = 1; j <= i; j++) {\n            values.add(i);\n        }\n    }\n    // This method shuffles the array list randomly\n    Collections.shuffle(values);\n    StopWatch timer = new StopWatch();\n    int[] a = new int[values.size()];\n    // of the algorithm\n    for (int i = 0; i < a.length; i++) {\n        a[i] = values.get(i);\n    }\n    timer.start();\n    int result = mostFrequent1(a);\n    timer.stop();\n    System.out.println(result);\n    System.out.println(\"Expected: \" + k);\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n    // Copies the same values and runs the second version     \n    for (int i = 0; i < a.length; i++) {\n        a[i] = values.get(i);\n    }\n    timer.reset();\n    timer.start();\n    result = mostFrequent2(a);\n    timer.stop();\n    System.out.println(result);\n    System.out.println(\"Expected: \" + k);\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"MostFrequent","variables":{"result":2,"timer":8,"a":3,"values":5,"i":12,"j":3,"k":4,"Collections":1},"constants":{"0":2,"1":2,"300":1,"\" milliseconds\"":2,"\"Expected: \"":2,"\"Elapsed time: \"":2},"javaDoc":"","comments":"Copies the values into an array and runs the first version Adds one times 1 two times 2 three times 3 k times k This method shuffles the array list randomly of the algorithm Copies the same values and runs the second version ","isEmpty":false,"hasInnerClass":false,"lineCount":22,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{"search":1,"max":1,"count":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":3},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":3,"BinaryExpr":1,"NameExpr":24,"FieldAccessExpr":2,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   */\npublic static int mostFrequent1(int[] a) {\n    int[] counts = new int[a.length];\n    for (// O(n*n)\n    int i = 0; // O(n*n)\n    i < a.length; // O(n*n)\n    i++) {\n        // O(n) in each iteration\n        counts[i] = count(a, a[i]);\n    }\n    // O(n)\n    int highestFrequency = max(counts);\n    // O(n)\n    int highestFrequencyIndex = search(counts, highestFrequency);\n    return a[highestFrequencyIndex];\n}\n","name":"mostFrequent1","className":"MostFrequent","variables":{"a":2,"counts":2,"i":5,"highestFrequencyIndex":2,"highestFrequency":1},"constants":{"0":1},"javaDoc":"Returns the most frequently occurring value in an array a an array the most frequently occurring value in a","comments":"O(n n) O(n n) O(n n) O(n) in each iteration O(n) O(n) \n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{"search":1,"max":1,"sort":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":4},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":5,"ArrayAccessExpr":4,"BinaryExpr":6,"NameExpr":34,"FieldAccessExpr":3,"ArrayCreationExpr":1,"UnaryExpr":2,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   */\npublic static int mostFrequent2(int[] a) {\n    // O(n log(n))\n    Arrays.sort(a);\n    int[] counts = new int[a.length];\n    int count = 0;\n    for (// O(n)\n    int i = 0; // O(n)\n    i < a.length; // O(n)\n    i++) {\n        count++;\n        if (i == a.length - 1 || a[i] != a[i + 1]) {\n            counts[i] = count;\n            count = 0;\n        }\n    }\n    // O(n)\n    int highestFrequency = max(counts);\n    // O(n)\n    int highestFrequencyIndex = search(counts, highestFrequency);\n    return a[highestFrequencyIndex];\n}\n","name":"mostFrequent2","className":"MostFrequent","variables":{"a":3,"counts":2,"count":4,"i":7,"highestFrequencyIndex":2,"Arrays":1,"highestFrequency":1},"constants":{"0":3,"1":2},"javaDoc":"Returns the most frequently occurring value in an array a an array the most frequently occurring value in a","comments":"O(n log(n)) O(n) O(n) O(n) O(n) O(n) \n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":10,"FieldAccessExpr":1,"UnaryExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Counts how often a value occurs in an array.\n      @param a the array\n      @param value the value to count\n      @return the number of occurrences of value in a\n   */\npublic static int count(int[] a, int value) {\n    int count = 0;\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] == value) {\n            count++;\n        }\n    }\n    return count;\n}\n","name":"count","className":"MostFrequent","variables":{"a":1,"count":3,"i":4,"value":1},"constants":{"0":2},"javaDoc":"Counts how often a value occurs in an array a the array value the value to count the number of occurrences of value in a","comments":"\n      Counts how often a value occurs in an array.\n      @param a the array\n      @param value the value to count\n      @return the number of occurrences of value in a\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":2,"NameExpr":13,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the largest value of an array.\n      @param a the array\n      @return the largest value in a\n   */\npublic static int max(int[] values) {\n    int largest = values[0];\n    for (int i = 1; i < values.length; i++) {\n        if (values[i] > largest) {\n            largest = values[i];\n        }\n    }\n    return largest;\n}\n","name":"max","className":"MostFrequent","variables":{"largest":4,"values":3,"i":5},"constants":{"0":1,"1":1},"javaDoc":"Computes the largest value of an array a the array the largest value in a","comments":"\n      Computes the largest value of an array.\n      @param a the array\n      @return the largest value in a\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":9,"FieldAccessExpr":1,"UnaryExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2},"text":"/**\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   */\npublic static int search(int[] a, int value) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] == value) {\n            return i;\n        }\n    }\n    return -1;\n}\n","name":"search","className":"MostFrequent","variables":{"a":1,"i":5,"value":1},"constants":{"0":1,"1":1},"javaDoc":"Finds a value in an array using the linear search algorithm a the array to search value the value to find the index at which the value occurs or -1 if it does not occur in the array","comments":"\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Country":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":9,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    Country other = (Country) otherObject;\n    if (area < other.area) {\n        return -1;\n    } else if (area == other.area) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n","name":"compareTo","className":"Country","variables":{"area":2,"other":1,"otherObject":1},"constants":{"0":1,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"NameExpr":6,"StringLiteralExpr":3,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \",area=\" + area + \"]\";\n}\n","name":"toString","className":"Country","variables":{"area":1,"name":1},"constants":{"\"[name=\"":1,"\"]\"":1,"\",area=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"toString":1,"sort":2,"binarySearch":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArrayList<Country>":1,"Country":3,"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":21,"ObjectCreationExpr":4,"VariableDeclarationExpr":6,"ArrayInitializerExpr":1,"BinaryExpr":3,"NameExpr":56,"StringLiteralExpr":5,"FieldAccessExpr":4,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":12,"AssignExpr":1},"statements":{"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    int[] values = { 1, 4, 9, 1, 6, 2, 5, 3, 6, 4, 9, 6, 4, 8, 1 };\n    Arrays.sort(values);\n    System.out.println(Arrays.toString(values));\n    int pos = Arrays.binarySearch(values, 4);\n    System.out.println(\"Position of 4: \" + pos);\n    pos = Arrays.binarySearch(values, 7);\n    System.out.println(\"Position for inserting 7: \" + (-pos - 1));\n    Country country1 = new Country(\"Belgium\", 30510);\n    Country country2 = new Country(\"Thailand\", 514000);\n    Country country3 = new Country(\"Uruguay\", 176220);\n    ArrayList<Country> countries = new ArrayList<Country>();\n    countries.add(country1);\n    countries.add(country2);\n    countries.add(country3);\n    Collections.sort(countries);\n    System.out.println(countries);\n}\n","name":"main","className":"JavaLibraryDemo","variables":{"pos":4,"values":1,"country1":1,"countries":4,"Arrays":4,"Collections":1,"country3":1,"country2":1},"constants":{"\"Thailand\"":1,"\"Belgium\"":1,"514000":1,"\"Position of 4: \"":1,"\"Uruguay\"":1,"1":4,"2":1,"\"Position for inserting 7: \"":1,"30510":1,"3":1,"4":4,"5":1,"6":3,"7":1,"8":1,"9":2,"176220":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":16,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"merge":1,"sort":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int[]":2,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"ArrayAccessExpr":4,"BinaryExpr":6,"NameExpr":44,"FieldAccessExpr":7,"ArrayCreationExpr":2,"UnaryExpr":2,"AssignExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":3,"ReturnStmt":1,"ForStmt":2,"ExpressionStmt":7},"text":"/**\n      Sorts an array, using merge sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    if (a.length <= 1) {\n        return;\n    }\n    int[] first = new int[a.length / 2];\n    int[] second = new int[a.length - first.length];\n    // Copy the first half of a into first, the second half into second\n    for (int i = 0; i < first.length; i++) {\n        first[i] = a[i];\n    }\n    for (int i = 0; i < second.length; i++) {\n        second[i] = a[first.length + i];\n    }\n    sort(first);\n    sort(second);\n    merge(first, second, a);\n}\n","name":"sort","className":"MergeSorter","variables":{"a":2,"i":10,"first":2,"second":2},"constants":{"0":2,"1":1,"2":1},"javaDoc":"Sorts an array using merge sort a the array to sort","comments":"Copy the first half of a into first the second half into second \n      Sorts an array, using merge sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["int[]","int[]","int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":10,"BinaryExpr":6,"NameExpr":43,"FieldAccessExpr":4,"UnaryExpr":7,"AssignExpr":4},"statements":{"IfStmt":1,"WhileStmt":3,"BlockStmt":5,"ExpressionStmt":14},"text":"/**\n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   */\nprivate static void merge(int[] first, int[] second, int[] a) {\n    // Next element to consider in the first array\n    int iFirst = 0;\n    // Next element to consider in the second array\n    int iSecond = 0;\n    // Next open position in a\n    int j = 0;\n    // the smaller element into a\n    while (iFirst < first.length && iSecond < second.length) {\n        if (first[iFirst] < second[iSecond]) {\n            a[j] = first[iFirst];\n            iFirst++;\n        } else {\n            a[j] = second[iSecond];\n            iSecond++;\n        }\n        j++;\n    }\n    // Copy any remaining entries of the first array\n    while (iFirst < first.length) {\n        a[j] = first[iFirst];\n        iFirst++;\n        j++;\n    }\n    // Copy any remaining entries of the second half\n    while (iSecond < second.length) {\n        a[j] = second[iSecond];\n        iSecond++;\n        j++;\n    }\n}\n","name":"merge","className":"MergeSorter","variables":{"a":4,"iSecond":8,"j":8,"first":3,"iFirst":8,"second":3},"constants":{"0":3},"javaDoc":"Merges two sorted arrays into an array first the first sorted array second the second sorted array a the array into which to merge first and second","comments":"As long as neither iFirst nor iSecond is past the end move Note that only one of the two loops below copies entries Next element to consider in the first array Next element to consider in the second array Next open position in a the smaller element into a Copy any remaining entries of the first array Copy any remaining entries of the second half \n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":10}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    MergeSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"MergeSortDemo","variables":{"a":1,"Arrays":2,"MergeSorter":1,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createStatement":1,"init":1,"getConnection":1,"nextLine":1,"hasNextLine":1,"getResultSet":1,"showResultSet":1,"execute":1,"System.out.println":2},"annotations":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"concepts":[],"types":{"Scanner":1,"boolean":1,"Statement":1,"Connection":1,"ResultSet":1,"String":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":3,"VariableDeclarationExpr":6,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":53,"StringLiteralExpr":2,"FieldAccessExpr":6,"MethodCallExpr":10,"AssignExpr":2},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":9,"TryStmt":3,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) throws SQLException, IOException, ClassNotFoundException {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". ExecSQL propertiesFile [SQLcommandFile]\");\n        return;\n    }\n    SimpleDataSource.init(args[0]);\n    Scanner in;\n    if (args.length > 1) {\n        in = new Scanner(new File(args[1]));\n    } else {\n        in = new Scanner(System.in);\n    }\n    try (Connection conn = SimpleDataSource.getConnection();\n        Statement stat = conn.createStatement()) {\n        while (in.hasNextLine()) {\n            String line = in.nextLine();\n            try {\n                boolean hasResultSet = stat.execute(line);\n                if (hasResultSet) {\n                    try (ResultSet result = stat.getResultSet()) {\n                        showResultSet(result);\n                    }\n                }\n            } catch (SQLException ex) {\n                System.out.println(ex);\n            }\n        }\n    }\n}\n","name":"main","className":"ExecSQL","variables":{"args":2,"result":1,"conn":2,"stat":3,"ex":1,"in":5,"hasResultSet":2,"SimpleDataSource":2,"line":1},"constants":{"0":2,"\"Usage: java -classpath driver_class_path\"":1,"1":2,"\". ExecSQL propertiesFile [SQLcommandFile]\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["ResultSet"],"returnType":"void","methodCalls":{"next":1,"getColumnLabel":1,"getColumnCount":1,"getString":1,"getMetaData":1,"System.out.print":4,"System.out.println":2},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"ResultSetMetaData":1,"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":55,"StringLiteralExpr":2,"FieldAccessExpr":6,"UnaryExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ForStmt":2,"ExpressionStmt":8},"text":"/**\n      Prints a result set.\n      @param result the result set\n   */\npublic static void showResultSet(ResultSet result) throws SQLException {\n    ResultSetMetaData metaData = result.getMetaData();\n    int columnCount = metaData.getColumnCount();\n    for (int i = 1; i <= columnCount; i++) {\n        if (i > 1) {\n            System.out.print(\", \");\n        }\n        System.out.print(metaData.getColumnLabel(i));\n    }\n    System.out.println();\n    while (result.next()) {\n        for (int i = 1; i <= columnCount; i++) {\n            if (i > 1) {\n                System.out.print(\", \");\n            }\n            System.out.print(result.getString(i));\n        }\n        System.out.println();\n    }\n}\n","name":"showResultSet","className":"ExecSQL","variables":{"result":3,"metaData":3,"i":8,"columnCount":3},"constants":{"1":4,"\", \"":2},"javaDoc":"Prints a result set result the result set","comments":"\n      Prints a result set.\n      @param result the result set\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":6,"MethodCallExpr":6,"AssignExpr":5},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":10},"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":1,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"constants":{},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"init":1,"getConnection":1,"printStackTrace":3,"System.out.println":4,"addInvoice":1},"annotations":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"concepts":[],"types":{"Scanner":1,"Connection":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":49,"StringLiteralExpr":5,"FieldAccessExpr":7,"MethodCallExpr":10},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String args[]) {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". InvoiceEntry propertiesFile\");\n        return;\n    }\n    try {\n        SimpleDataSource.init(args[0]);\n        try (Connection conn = SimpleDataSource.getConnection();\n            Scanner in = new Scanner(System.in)) {\n            addInvoice(in, conn);\n        }\n    } catch (SQLException ex) {\n        System.out.println(\"Database error\");\n        ex.printStackTrace();\n    } catch (ClassNotFoundException ex) {\n        System.out.println(\"Error loading database driver\");\n        ex.printStackTrace();\n    } catch (IOException ex) {\n        System.out.println(\"Error loading database properties\");\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"InvoiceEntry","variables":{"args":1,"conn":1,"ex":6,"in":1,"SimpleDataSource":2},"constants":{"0":2,"\"Usage: java -classpath driver_class_path\"":1,"\". InvoiceEntry propertiesFile\"":1,"\"Error loading database driver\"":1,"\"Database error\"":1,"\"Error loading database properties\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["Scanner","Connection"],"returnType":"void","methodCalls":{"nextLine":1,"listProducts":1,"showInvoice":1,"addLineItem":1,"prepareStatement":1,"nextInt":1,"setInt":2,"findProduct":1,"newCustomer":1,"equals":2,"getNewId":1,"executeUpdate":1,"System.out.println":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"boolean":1,"PreparedStatement":1,"String":1,"int":3},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":6,"BooleanLiteralExpr":2,"NameExpr":57,"StringLiteralExpr":7,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":15,"AssignExpr":1},"statements":{"IfStmt":3,"WhileStmt":1,"TryStmt":1,"BlockStmt":6,"ExpressionStmt":13},"text":"public static void addInvoice(Scanner in, Connection conn) throws SQLException {\n    int customerNumber = newCustomer(conn, in);\n    int id = getNewId(conn, \"Invoice\");\n    try (PreparedStatement stat = conn.prepareStatement(\"INSERT INTO Invoice VALUES (?, ?, 0)\")) {\n        stat.setInt(1, id);\n        stat.setInt(2, customerNumber);\n        stat.executeUpdate();\n    }\n    boolean done = false;\n    while (!done) {\n        String productCode = nextLine(in, \"Product code (D=Done, L=List)\");\n        if (productCode.equals(\"D\")) {\n            done = true;\n        } else if (productCode.equals(\"L\")) {\n            listProducts(conn);\n        } else if (findProduct(conn, productCode)) {\n            int quantity = nextInt(in, \"Quantity\");\n            addLineItem(conn, id, productCode, quantity);\n        } else {\n            System.out.println(\"Invalid product code.\");\n        }\n    }\n    showInvoice(conn, id);\n}\n","name":"addInvoice","className":"InvoiceEntry","variables":{"stat":4,"conn":1,"productCode":3,"quantity":1,"id":1,"customerNumber":1,"done":3},"constants":{"\"D\"":1,"1":1,"2":1,"\"Quantity\"":1,"\"Invoice\"":1,"\"Product code (D=Done, L=List)\"":1,"\"Invalid product code.\"":1,"false":1,"true":1,"\"L\"":1,"\"INSERT INTO Invoice VALUES (?, ?, 0)\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["Connection","Scanner"],"returnType":"int","methodCalls":{"setString":5,"nextLine":5,"prepareStatement":1,"getNewId":1,"setInt":1,"executeUpdate":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"PreparedStatement":1,"String":5,"int":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":7,"NameExpr":49,"StringLiteralExpr":7,"MethodCallExpr":14},"statements":{"TryStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":13},"text":"/**\n      Prompts the user for the customer information and creates a new customer.\n      @param conn the database connection\n      @param in the scanner\n      @return the ID of the new customer\n   */\nprivate static int newCustomer(Connection conn, Scanner in) throws SQLException {\n    String name = nextLine(in, \"Name\");\n    String address = nextLine(in, \"Street address\");\n    String city = nextLine(in, \"City\");\n    String state = nextLine(in, \"State\");\n    String zip = nextLine(in, \"Zip\");\n    int id = getNewId(conn, \"Customer\");\n    try (PreparedStatement stat = conn.prepareStatement(\"INSERT INTO Customer VALUES (?, ?, ?, ?, ?, ?)\")) {\n        stat.setInt(1, id);\n        stat.setString(2, name);\n        stat.setString(3, address);\n        stat.setString(4, city);\n        stat.setString(5, state);\n        stat.setString(6, zip);\n        stat.executeUpdate();\n    }\n    return id;\n}\n","name":"newCustomer","className":"InvoiceEntry","variables":{"zip":1,"stat":8,"conn":1,"address":1,"city":1,"name":1,"state":1,"id":2},"constants":{"\"Customer\"":1,"\"INSERT INTO Customer VALUES (?, ?, ?, ?, ?, ?)\"":1,"\"Name\"":1,"\"Zip\"":1,"1":1,"2":1,"\"City\"":1,"3":1,"4":1,"\"Street address\"":1,"\"State\"":1,"5":1,"6":1},"javaDoc":"Prompts the user for the customer information and creates a new customer conn the database connection in the scanner the ID of the new customer","comments":"\n      Prompts the user for the customer information and creates a new customer.\n      @param conn the database connection\n      @param in the scanner\n      @return the ID of the new customer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":10}
{"paramTypes":["Connection","String"],"returnType":"boolean","methodCalls":{"next":1,"setString":1,"prepareStatement":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"boolean":1,"ResultSet":1,"PreparedStatement":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"NameExpr":15,"StringLiteralExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Finds a product in the database.\n      @param conn the database connection\n      @param code the product code to search\n      @return true if there is a product with the given code\n   */\nprivate static boolean findProduct(Connection conn, String code) throws SQLException {\n    boolean found = false;\n    try (PreparedStatement stat = conn.prepareStatement(\"SELECT * FROM Product WHERE Product_Code = ?\")) {\n        stat.setString(1, code);\n        ResultSet result = stat.executeQuery();\n        found = result.next();\n    }\n    return found;\n}\n","name":"findProduct","className":"InvoiceEntry","variables":{"result":2,"stat":3,"conn":1,"found":3},"constants":{"1":1,"\"SELECT * FROM Product WHERE Product_Code = ?\"":1,"false":1},"javaDoc":"Finds a product in the database conn the database connection code the product code to search true if there is a product with the given code","comments":"\n      Finds a product in the database.\n      @param conn the database connection\n      @param code the product code to search\n      @return true if there is a product with the given code\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["Connection","int","String","int"],"returnType":"void","methodCalls":{"setString":1,"prepareStatement":1,"setInt":2,"executeUpdate":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"PreparedStatement":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"NameExpr":18,"StringLiteralExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n      Adds a line item to the database\n      @param conn the database connection\n      @param id the invoice ID\n      @param code the product code\n      @param quantity the quantity to order\n   */\nprivate static void addLineItem(Connection conn, int id, String code, int quantity) throws SQLException {\n    try (PreparedStatement stat = conn.prepareStatement(\"INSERT INTO LineItem VALUES (?, ?, ?)\")) {\n        stat.setInt(1, id);\n        stat.setString(2, code);\n        stat.setInt(3, quantity);\n        stat.executeUpdate();\n    }\n}\n","name":"addLineItem","className":"InvoiceEntry","variables":{"stat":5,"conn":1},"constants":{"\"INSERT INTO LineItem VALUES (?, ?, ?)\"":1,"1":1,"2":1,"3":1},"javaDoc":"Adds a line item to the database conn the database connection id the invoice ID code the product code quantity the quantity to order","comments":"\n      Adds a line item to the database\n      @param conn the database connection\n      @param id the invoice ID\n      @param code the product code\n      @param quantity the quantity to order\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["Connection"],"returnType":"void","methodCalls":{"createStatement":1,"next":1,"getString":2,"executeQuery":1,"System.out.println":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"Statement":1,"ResultSet":1,"String":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/**\n      Lists all products in the database.\n      @param conn the database connection\n   */\nprivate static void listProducts(Connection conn) throws SQLException {\n    try (Statement stat = conn.createStatement()) {\n        ResultSet result = stat.executeQuery(\"SELECT Product_Code, Description FROM Product\");\n        while (result.next()) {\n            String code = result.getString(1);\n            String description = result.getString(2);\n            System.out.println(code + \" \" + description);\n        }\n    }\n}\n","name":"listProducts","className":"InvoiceEntry","variables":{"result":4,"stat":2,"conn":1,"code":2,"description":2},"constants":{"1":1,"2":1,"\" \"":1,"\"SELECT Product_Code, Description FROM Product\"":1},"javaDoc":"Lists all products in the database conn the database connection","comments":"\n      Lists all products in the database.\n      @param conn the database connection\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["Connection","String"],"returnType":"int","methodCalls":{"createStatement":1,"next":1,"getInt":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"Statement":1,"ResultSet":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":16,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Gets a new ID for a table. This method should be called from\n      inside a transaction that also creates the new row with this ID.\n      The ID field should have name table_Number and type INTEGER.\n      @param table the table name\n      @return a new ID that has not yet been used.\n   */\nprivate static int getNewId(Connection conn, String table) throws SQLException {\n    int max = -1;\n    try (Statement stat = conn.createStatement()) {\n        ResultSet result = stat.executeQuery(\"SELECT max(\" + table + \"_Number) FROM \" + table);\n        result.next();\n        max = result.getInt(1) + 1;\n    }\n    return max;\n}\n","name":"getNewId","className":"InvoiceEntry","variables":{"result":3,"stat":2,"conn":1,"max":3,"table":2},"constants":{"1":3,"\"SELECT max(\"":1,"\"_Number) FROM \"":1},"javaDoc":"Gets a new ID for a table This method should be called from inside a transaction that also creates the new row with this ID The ID field should have name table_Number and type INTEGER table the table name a new ID that has not yet been used","comments":"\n      Gets a new ID for a table. This method should be called from\n      inside a transaction that also creates the new row with this ID.\n      The ID field should have name table_Number and type INTEGER.\n      @param table the table name\n      @return a new ID that has not yet been used.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["Connection","int"],"returnType":"void","methodCalls":{"next":2,"getInt":1,"trim":2,"prepareStatement":2,"getString":7,"setInt":2,"executeQuery":2,"System.out.println":4},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"ResultSet":2,"PreparedStatement":2,"String":2,"int":1},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":7,"BinaryExpr":15,"NameExpr":77,"StringLiteralExpr":13,"FieldAccessExpr":4,"MethodCallExpr":22},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":3,"ExpressionStmt":12},"text":"/**\n      Shows an invoice.\n      @param conn the database connection\n      @param id the invoice ID\n   */\nprivate static void showInvoice(Connection conn, int id) throws SQLException {\n    try (PreparedStatement stat = conn.prepareStatement(\"SELECT Customer.Name, Customer.Address, \" + \"Customer.City, Customer.State, Customer.Zip \" + \"FROM Customer, Invoice \" + \"WHERE Customer.Customer_Number = Invoice.Customer_Number \" + \"AND Invoice.Invoice_Number = ?\")) {\n        stat.setInt(1, id);\n        ResultSet result = stat.executeQuery();\n        result.next();\n        System.out.println(result.getString(1));\n        System.out.println(result.getString(2));\n        System.out.println(result.getString(3).trim() + \", \" + result.getString(4) + \" \" + result.getString(5));\n    }\n    try (PreparedStatement stat = conn.prepareStatement(\"SELECT Product.Product_Code, Product.Description, LineItem.Quantity \" + \"FROM Product, LineItem \" + \"WHERE Product.Product_Code = LineItem.Product_Code \" + \"AND LineItem.Invoice_Number = ?\")) {\n        stat.setInt(1, id);\n        ResultSet result = stat.executeQuery();\n        while (result.next()) {\n            String code = result.getString(1);\n            String description = result.getString(2).trim();\n            int qty = result.getInt(3);\n            System.out.println(qty + \" x \" + code + \" \" + description);\n        }\n    }\n}\n","name":"showInvoice","className":"InvoiceEntry","variables":{"result":12,"stat":6,"conn":2,"code":2,"qty":2,"description":2},"constants":{"\" \"":2,"\"WHERE Product.Product_Code = LineItem.Product_Code \"":1,"\"FROM Customer, Invoice \"":1,"\"FROM Product, LineItem \"":1,"1":4,"2":2,"3":2,"\" x \"":1,"\"SELECT Customer.Name, Customer.Address, \"":1,"4":1,"\"AND Invoice.Invoice_Number = ?\"":1,"5":1,"\"SELECT Product.Product_Code, Product.Description, LineItem.Quantity \"":1,"\"WHERE Customer.Customer_Number = Invoice.Customer_Number \"":1,"\"AND LineItem.Invoice_Number = ?\"":1,"\"Customer.City, Customer.State, Customer.Zip \"":1,"\", \"":1},"javaDoc":"Shows an invoice conn the database connection id the invoice ID","comments":"\n      Shows an invoice.\n      @param conn the database connection\n      @param id the invoice ID\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":10}
{"paramTypes":["Scanner","String"],"returnType":"String","methodCalls":{"nextLine":1,"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Prompts the user and reads a line from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the string that the user entered\n   */\nprivate static String nextLine(Scanner in, String prompt) {\n    System.out.print(prompt + \": \");\n    return in.nextLine();\n}\n","name":"nextLine","className":"InvoiceEntry","variables":{"in":1,"prompt":1},"constants":{"\": \"":1},"javaDoc":"Prompts the user and reads a line from a scanner in the scanner prompt the prompt the string that the user entered","comments":"\n      Prompts the user and reads a line from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the string that the user entered\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":10}
{"paramTypes":["Scanner","String"],"returnType":"int","methodCalls":{"nextLine":1,"nextInt":1,"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Prompts the user and reads an integer from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the integer that the user entered\n   */\nprivate static int nextInt(Scanner in, String prompt) {\n    System.out.print(prompt + \": \");\n    int result = in.nextInt();\n    // Consume newline\n    in.nextLine();\n    return result;\n}\n","name":"nextInt","className":"InvoiceEntry","variables":{"result":2,"in":2,"prompt":1},"constants":{"\": \"":1},"javaDoc":"Prompts the user and reads an integer from a scanner in the scanner prompt the prompt the integer that the user entered","comments":"Consume newline \n      Prompts the user and reads an integer from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the integer that the user entered\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":10}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":6,"MethodCallExpr":6,"AssignExpr":5},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":10},"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":1,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"constants":{},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createStatement":1,"next":1,"init":1,"getConnection":1,"getString":1,"execute":3,"System.out.println":2,"executeQuery":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Statement":1,"Connection":1,"ResultSet":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":44,"StringLiteralExpr":7,"FieldAccessExpr":4,"MethodCallExpr":11},"statements":{"IfStmt":1,"BlockStmt":2,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) throws Exception {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". TestDB propertiesFile\");\n        return;\n    }\n    SimpleDataSource.init(args[0]);\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        Statement stat = conn.createStatement();\n        stat.execute(\"CREATE TABLE Test (Name VARCHAR(20))\");\n        stat.execute(\"INSERT INTO Test VALUES ('Romeo')\");\n        ResultSet result = stat.executeQuery(\"SELECT * FROM Test\");\n        result.next();\n        System.out.println(result.getString(\"Name\"));\n        stat.execute(\"DROP TABLE Test\");\n    }\n}\n","name":"main","className":"TestDB","variables":{"args":1,"result":3,"conn":2,"stat":5,"SimpleDataSource":2},"constants":{"0":2,"\"Usage: java -classpath driver_class_path\"":1,"\"SELECT * FROM Test\"":1,"\". TestDB propertiesFile\"":1,"\"INSERT INTO Test VALUES ('Romeo')\"":1,"\"Name\"":1,"\"CREATE TABLE Test (Name VARCHAR(20))\"":1,"\"DROP TABLE Test\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number\n   */\npublic BankAccount(int anAccountNumber) {\n    accountNumber = anAccountNumber;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":1,"accountNumber":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance anAccountNumber the account number","comments":"\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"setDouble":1,"getConnection":1,"prepareStatement":1,"setInt":1,"executeUpdate":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"Connection":1,"PreparedStatement":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":3,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n      Deposits money into a bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        PreparedStatement stat = conn.prepareStatement(\"UPDATE Account\" + \" SET Balance = Balance + ?\" + \" WHERE Account_Number = ?\");\n        stat.setDouble(1, amount);\n        stat.setInt(2, accountNumber);\n        stat.executeUpdate();\n    }\n}\n","name":"deposit","className":"BankAccount","variables":{"conn":2,"stat":4,"SimpleDataSource":1},"constants":{"1":1,"2":1,"\" WHERE Account_Number = ?\"":1,"\"UPDATE Account\"":1,"\" SET Balance = Balance + ?\"":1},"javaDoc":"Deposits money into a bank account amount the amount to deposit","comments":"\n      Deposits money into a bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"setDouble":1,"getConnection":1,"prepareStatement":1,"setInt":1,"executeUpdate":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"Connection":1,"PreparedStatement":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":3,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n      Withdraws money from a bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        PreparedStatement stat = conn.prepareStatement(\"UPDATE Account\" + \" SET Balance = Balance - ?\" + \" WHERE Account_Number = ?\");\n        stat.setDouble(1, amount);\n        stat.setInt(2, accountNumber);\n        stat.executeUpdate();\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"conn":2,"stat":4,"SimpleDataSource":1},"constants":{"1":1,"2":1,"\" WHERE Account_Number = ?\"":1,"\"UPDATE Account\"":1,"\" SET Balance = Balance - ?\"":1},"javaDoc":"Withdraws money from a bank account amount the amount to withdraw","comments":"\n      Withdraws money from a bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"next":1,"getConnection":1,"getDouble":1,"prepareStatement":1,"setInt":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"double":1,"Connection":1,"ResultSet":1,"PreparedStatement":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"NameExpr":21,"StringLiteralExpr":1,"MethodCallExpr":6,"AssignExpr":1},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Gets the balance of a bank account.\n      @return the account balance\n   */\npublic double getBalance() throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        double balance = 0;\n        PreparedStatement stat = conn.prepareStatement(\"SELECT Balance FROM Account WHERE Account_Number = ?\");\n        stat.setInt(1, accountNumber);\n        ResultSet result = stat.executeQuery();\n        if (result.next()) {\n            balance = result.getDouble(1);\n        }\n        return balance;\n    }\n}\n","name":"getBalance","className":"BankAccount","variables":{"result":3,"conn":2,"stat":3,"balance":3,"SimpleDataSource":1},"constants":{"0":1,"1":2,"\"SELECT Balance FROM Account WHERE Account_Number = ?\"":1},"javaDoc":"Gets the balance of a bank account the account balance","comments":"\n      Gets the balance of a bank account.\n      @return the account balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"init":1,"showMessageDialog":3,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":["PolyMorphism"],"types":{"Bank":1,"JFrame":1,"ATM":1,"ATMFrame":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":3,"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":31,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":5,"TryStmt":1,"ReturnStmt":3,"ExpressionStmt":11},"text":"public static void main(String[] args) throws IOException, ClassNotFoundException {\n    if (args.length == 0) {\n        JOptionPane.showMessageDialog(null, \"Usage: ATMViewer propertiesFile\");\n        return;\n    } else {\n        try {\n            SimpleDataSource.init(args[0]);\n        } catch (IOException exception) {\n            JOptionPane.showMessageDialog(null, \"Can't connect to database\");\n            return;\n        } catch (ClassNotFoundException exception) {\n            JOptionPane.showMessageDialog(null, \"Can't connect to database\");\n            return;\n        }\n    }\n    ATM theATM;\n    Bank theBank = new Bank();\n    theATM = new ATM(theBank);\n    JFrame frame = new ATMFrame(theATM);\n    frame.setTitle(\"First National Bank of Java\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ATMViewer","variables":{"args":1,"exception":2,"theATM":3,"theBank":2,"SimpleDataSource":1,"JOptionPane":3,"frame":4},"constants":{"0":2,"\"Can't connect to database\"":2,"null":3,"\"Usage: ATMViewer propertiesFile\"":1,"true":1,"\"First National Bank of Java\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"init":1,"selectAccount":2,"back":3,"nextInt":2,"nextDouble":2,"setCustomerNumber":1,"getState":1,"getBalance":1,"reset":1,"deposit":1,"equalsIgnoreCase":6,"System.out.print":6,"selectCustomer":1,"System.out.println":4,"withdraw":1},"annotations":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"concepts":[],"types":{"Scanner":1,"Bank":1,"double":2,"ATM":1,"String":2,"int":3},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":10,"ArrayAccessExpr":1,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":159,"StringLiteralExpr":16,"FieldAccessExpr":18,"MethodCallExpr":35},"statements":{"IfStmt":11,"WhileStmt":1,"BlockStmt":15,"ReturnStmt":1,"ExpressionStmt":31},"text":"public static void main(String[] args) throws IOException, SQLException, ClassNotFoundException {\n    if (args.length == 0) {\n        System.out.println(\"Usage: ATMTester propertiesFile\");\n        return;\n    } else {\n        SimpleDataSource.init(args[0]);\n    }\n    Bank theBank = new Bank();\n    ATM theATM = new ATM(theBank);\n    Scanner in = new Scanner(System.in);\n    while (true) {\n        int state = theATM.getState();\n        if (state == ATM.START) {\n            System.out.print(\"Enter account number: \");\n            int number = in.nextInt();\n            theATM.setCustomerNumber(number);\n        } else if (state == ATM.PIN) {\n            System.out.print(\"Enter PIN: \");\n            int pin = in.nextInt();\n            theATM.selectCustomer(pin);\n        } else if (state == ATM.ACCOUNT) {\n            System.out.print(\"A=Checking, B=Savings, C=Quit: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                theATM.selectAccount(ATM.CHECKING);\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                theATM.selectAccount(ATM.SAVINGS);\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.reset();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        } else if (state == ATM.TRANSACT) {\n            System.out.println(\"Balance=\" + theATM.getBalance());\n            System.out.print(\"A=Deposit, B=Withdrawal, C=Cancel: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.deposit(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.withdraw(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.back();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        }\n    }\n}\n","name":"main","className":"ATMSimulator","variables":{"args":1,"number":1,"amount":2,"theATM":13,"theBank":2,"pin":1,"in":7,"SimpleDataSource":1,"state":5,"command":8},"constants":{"\"Usage: ATMTester propertiesFile\"":1,"\"Enter account number: \"":1,"\"Illegal input!\"":2,"\"C\"":2,"\"B\"":2,"\"A\"":2,"\"A=Checking, B=Savings, C=Quit: \"":1,"\"Balance=\"":1,"0":2,"\"A=Deposit, B=Withdrawal, C=Cancel: \"":1,"true":1,"\"Amount: \"":2,"\"Enter PIN: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["int","int","int"],"returnType":"Customer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a customer with a given number and PIN.\n      @param aCustomerNumber the customer number\n      @param checkingAccountNumber the checking account number\n      @param savingsAccountNumber the savings account number\n   */\npublic Customer(int aCustomerNumber, int checkingAccountNumber, int savingsAccountNumber) {\n    customerNumber = aCustomerNumber;\n    checkingAccount = new BankAccount(checkingAccountNumber);\n    savingsAccount = new BankAccount(savingsAccountNumber);\n}\n","name":"Customer","className":"Customer","variables":{"savingsAccountNumber":1,"savingsAccount":1,"checkingAccountNumber":1,"checkingAccount":1,"customerNumber":1,"aCustomerNumber":1},"constants":{},"javaDoc":"Constructs a customer with a given number and PIN aCustomerNumber the customer number checkingAccountNumber the checking account number savingsAccountNumber the savings account number","comments":"\n      Constructs a customer with a given number and PIN.\n      @param aCustomerNumber the customer number\n      @param checkingAccountNumber the checking account number\n      @param savingsAccountNumber the savings account number\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the checking account of this customer.\n      @return the checking account\n   */\npublic BankAccount getCheckingAccount() {\n    return checkingAccount;\n}\n","name":"getCheckingAccount","className":"Customer","variables":{"checkingAccount":1},"constants":{},"javaDoc":"Gets the checking account of this customer the checking account","comments":" \n      Gets the checking account of this customer.\n      @return the checking account\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the savings account of this customer.\n      @return the savings account\n   */\npublic BankAccount getSavingsAccount() {\n    return savingsAccount;\n}\n","name":"getSavingsAccount","className":"Customer","variables":{"savingsAccount":1},"constants":{},"javaDoc":"Gets the savings account of this customer the savings account","comments":" \n      Gets the savings account of this customer.\n      @return the savings account\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Customer","methodCalls":{"next":1,"getConnection":1,"getInt":3,"prepareStatement":1,"setInt":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"Customer":1,"Connection":1,"ResultSet":1,"PreparedStatement":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":29,"StringLiteralExpr":4,"MethodCallExpr":8,"AssignExpr":1},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Finds a customer with a given number and PIN.\n      @param customerNumber the customer number\n      @param pin the personal identification number\n      @return the matching customer, or null if none found\n   */\npublic Customer findCustomer(int customerNumber, int pin) throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        Customer c = null;\n        PreparedStatement stat = conn.prepareStatement(\"SELECT * FROM BankCustomer WHERE Customer_Number = ?\");\n        stat.setInt(1, customerNumber);\n        ResultSet result = stat.executeQuery();\n        if (result.next() && pin == result.getInt(\"PIN\")) {\n            c = new Customer(customerNumber, result.getInt(\"Checking_Account_Number\"), result.getInt(\"Savings_Account_Number\"));\n        }\n        return c;\n    }\n}\n","name":"findCustomer","className":"Bank","variables":{"result":5,"conn":2,"stat":3,"c":3,"pin":1,"SimpleDataSource":1,"customerNumber":1},"constants":{"1":1,"\"Savings_Account_Number\"":1,"null":1,"\"Checking_Account_Number\"":1,"\"SELECT * FROM BankCustomer WHERE Customer_Number = ?\"":1,"\"PIN\"":1},"javaDoc":"Finds a customer with a given number and PIN customerNumber the customer number pin the personal identification number the matching customer or null if none found","comments":"\n      Finds a customer with a given number and PIN.\n      @param customerNumber the customer number\n      @param pin the personal identification number\n      @return the matching customer, or null if none found\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Bank"],"returnType":"ATM","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   */\npublic ATM(Bank aBank) {\n    theBank = aBank;\n    reset();\n}\n","name":"ATM","className":"ATM","variables":{"theBank":1,"aBank":1},"constants":{},"javaDoc":"Constructs an ATM for a given bank aBank the bank to which this ATM connects","comments":"\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Resets the ATM to the initial state.\n   */\npublic void reset() {\n    customerNumber = -1;\n    currentAccount = null;\n    state = START;\n}\n","name":"reset","className":"ATM","variables":{"START":1,"currentAccount":1,"state":1,"customerNumber":1},"constants":{"1":1,"null":1},"javaDoc":"Resets the ATM to the initial state","comments":"\n      Resets the ATM to the initial state.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   */\npublic void setCustomerNumber(int number) {\n    customerNumber = number;\n    state = PIN;\n}\n","name":"setCustomerNumber","className":"ATM","variables":{"number":1,"PIN":1,"state":1,"customerNumber":1},"constants":{},"javaDoc":"Sets the current customer number and sets state to PIN (Precondition: state is START) number the customer number","comments":" \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"findCustomer":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":11,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   */\npublic void selectCustomer(int pin) throws SQLException {\n    currentCustomer = theBank.findCustomer(customerNumber, pin);\n    if (currentCustomer == null) {\n        state = START;\n    } else {\n        state = ACCOUNT;\n    }\n}\n","name":"selectCustomer","className":"ATM","variables":{"ACCOUNT":1,"currentCustomer":2,"theBank":1,"START":1,"state":2},"constants":{"null":1},"javaDoc":"Finds customer in bank If found sets state to ACCOUNT else to START (Precondition: state is PIN) pin the PIN of the current customer","comments":" \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getCheckingAccount":1,"getSavingsAccount":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":12,"AssignExpr":3,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   */\npublic void selectAccount(int account) {\n    if (account == CHECKING) {\n        currentAccount = currentCustomer.getCheckingAccount();\n    } else {\n        currentAccount = currentCustomer.getSavingsAccount();\n    }\n    state = TRANSACT;\n}\n","name":"selectAccount","className":"ATM","variables":{"currentCustomer":2,"TRANSACT":1,"CHECKING":1,"currentAccount":2,"state":1,"account":1},"constants":{},"javaDoc":"Sets current account to checking or savings Sets state to TRANSACT (Precondition: state is ACCOUNT or TRANSACT) account one of CHECKING or SAVINGS","comments":" \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"withdraw":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   */\npublic void withdraw(double value) throws SQLException {\n    currentAccount.withdraw(value);\n}\n","name":"withdraw","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Withdraws amount from current account (Precondition: state is TRANSACT) value the amount to withdraw","comments":" \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"deposit":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   */\npublic void deposit(double value) throws SQLException {\n    currentAccount.deposit(value);\n}\n","name":"deposit","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Deposits amount to current account (Precondition: state is TRANSACT) value the amount to deposit","comments":" \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getBalance":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   */\npublic double getBalance() throws SQLException {\n    return currentAccount.getBalance();\n}\n","name":"getBalance","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Gets the balance of the current account (Precondition: state is TRANSACT) the balance","comments":" \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":12,"AssignExpr":3},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":3},"text":"/**\n      Moves back to the previous state.\n   */\npublic void back() {\n    if (state == TRANSACT) {\n        state = ACCOUNT;\n    } else if (state == ACCOUNT) {\n        state = PIN;\n    } else if (state == PIN) {\n        state = START;\n    }\n}\n","name":"back","className":"ATM","variables":{"ACCOUNT":2,"TRANSACT":1,"PIN":2,"START":1,"state":6},"constants":{},"javaDoc":"Moves back to the previous state","comments":"\n      Moves back to the previous state.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current state of this ATM.\n      @return the current state\n   */\npublic int getState() {\n    return state;\n}\n","name":"getState","className":"ATM","variables":{"state":1},"constants":{},"javaDoc":"Gets the current state of this ATM the current state","comments":"\n      Gets the current state of this ATM.\n      @return the current state\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    display.setText(\"\");\n}\n","name":"actionPerformed","className":"ClearButtonListener","variables":{"display":1},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"KeyPad","methodCalls":{"add":3,"addActionListener":1,"addButton":11,"setLayout":2,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"ClearButtonListener":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":50,"StringLiteralExpr":15,"MethodCallExpr":18,"AssignExpr":3},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":22},"text":"/**\n      Constructs the keypad panel.\n   */\npublic KeyPad() {\n    setLayout(new BorderLayout());\n    // Add display field\n    display = new JTextField();\n    add(display, \"North\");\n    // Make button panel\n    buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 3));\n    // Add digit buttons\n    addButton(\"7\");\n    addButton(\"8\");\n    addButton(\"9\");\n    addButton(\"4\");\n    addButton(\"5\");\n    addButton(\"6\");\n    addButton(\"1\");\n    addButton(\"2\");\n    addButton(\"3\");\n    addButton(\"0\");\n    addButton(\".\");\n    // Add clear entry button\n    clearButton = new JButton(\"CE\");\n    buttonPanel.add(clearButton);\n    class ClearButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            display.setText(\"\");\n        }\n    }\n    ActionListener listener = new ClearButtonListener();\n    clearButton.addActionListener(new ClearButtonListener());\n    add(buttonPanel, \"Center\");\n}\n","name":"KeyPad","className":"KeyPad","variables":{"actionPerformed":1,"clearButton":2,"display":2,"buttonPanel":3,"listener":1,"ClearButtonListener":1,"event":1},"constants":{"\"North\"":1,"\"\"":1,"\"9\"":1,"\"8\"":1,"\"Center\"":1,"\"7\"":1,"\"6\"":1,"\"CE\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"3":1,"\"1\"":1,"4":1,"\"0\"":1,"\".\"":1},"javaDoc":"Constructs the keypad panel","comments":"Add display field Make button panel Add digit buttons Add clear entry button \n      Constructs the keypad panel.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":26,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":2,"equals":1,"indexOf":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":3,"NameExpr":15,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    // Don't add two decimal points\n    if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n        return;\n    }\n    // Append label text to button\n    display.setText(display.getText() + label);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"display":3,"label":2},"constants":{"1":1,"\".\"":2},"javaDoc":"","comments":"Don't add two decimal points Append label text to button ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"getText":2,"equals":1,"addActionListener":1,"indexOf":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":28,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"TypeDeclarationStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Adds a button to the button panel.\n      @param label the button label\n   */\nprivate void addButton(final String label) {\n    class DigitButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            // Don't add two decimal points\n            if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n                return;\n            }\n            // Append label text to button\n            display.setText(display.getText() + label);\n        }\n    }\n    JButton button = new JButton(label);\n    buttonPanel.add(button);\n    ActionListener listener = new DigitButtonListener();\n    button.addActionListener(listener);\n}\n","name":"addButton","className":"KeyPad","variables":{"button":2,"actionPerformed":1,"DigitButtonListener":1,"display":3,"buttonPanel":1,"listener":1,"label":3,"event":1},"constants":{"1":1,"\".\"":2},"javaDoc":"Adds a button to the button panel label the button label","comments":"Don't add two decimal points Append label text to button \n      Adds a button to the button panel.\n      @param label the button label\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":2}
{"paramTypes":[],"returnType":"double","methodCalls":{"parseDouble":1,"getText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   */\npublic double getValue() {\n    return Double.parseDouble(display.getText());\n}\n","name":"getValue","className":"KeyPad","variables":{"display":1,"Double":1},"constants":{},"javaDoc":"Gets the value that the user entered the value in the text field of the keypad","comments":" \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Clears the dislay. \n   */\npublic void clear() {\n    display.setText(\"\");\n}\n","name":"clear","className":"KeyPad","variables":{"display":1},"constants":{"\"\"":1},"javaDoc":"Clears the dislay","comments":" \n      Clears the dislay. \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":6,"MethodCallExpr":6,"AssignExpr":5},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":10},"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":1,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"constants":{},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["ATM"],"returnType":"ATMFrame","methodCalls":{"add":6,"showState":1,"setSize":1,"addActionListener":3,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":45,"StringLiteralExpr":3,"AssignExpr":6,"MethodCallExpr":12},"statements":{"ExpressionStmt":19},"text":"/**\n      Constructs the user interface of the ATM frame.\n   */\npublic ATMFrame(ATM anATM) {\n    theATM = anATM;\n    // Construct components\n    pad = new KeyPad();\n    display = new JTextArea(4, 20);\n    aButton = new JButton(\"  A  \");\n    aButton.addActionListener(new AButtonListener());\n    bButton = new JButton(\"  B  \");\n    bButton.addActionListener(new BButtonListener());\n    cButton = new JButton(\"  C  \");\n    cButton.addActionListener(new CButtonListener());\n    // Add components\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.add(aButton);\n    buttonPanel.add(bButton);\n    buttonPanel.add(cButton);\n    setLayout(new FlowLayout());\n    add(pad);\n    add(display);\n    add(buttonPanel);\n    showState();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"ATMFrame","className":"ATMFrame","variables":{"aButton":2,"pad":1,"theATM":1,"anATM":1,"display":1,"buttonPanel":4,"cButton":2,"bButton":2},"constants":{"\"  C  \"":1,"\"  B  \"":1,"4":1,"\"  A  \"":1,"20":1},"javaDoc":"Constructs the user interface of the ATM frame","comments":"Construct components Add components \n      Constructs the user interface of the ATM frame.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":21,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getState":1,"getBalance":1,"showMessageDialog":1,"clear":1,"setText":4},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"int":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":8,"NameExpr":40,"StringLiteralExpr":8,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"IfStmt":4,"BlockStmt":6,"TryStmt":1,"ExpressionStmt":7},"text":"/** \n      Updates display message.\n   */\npublic void showState() {\n    int state = theATM.getState();\n    pad.clear();\n    if (state == ATM.START) {\n        display.setText(\"Enter customer number\\nA = OK\");\n    } else if (state == ATM.PIN) {\n        display.setText(\"Enter PIN\\nA = OK\");\n    } else if (state == ATM.ACCOUNT) {\n        display.setText(\"Select Account\\n\" + \"A = Checking\\nB = Savings\\nC = Exit\");\n    } else if (state == ATM.TRANSACT) {\n        try {\n            display.setText(\"Balance = \" + theATM.getBalance() + \"\\nEnter amount and select transaction\\n\" + \"A = Withdraw\\nB = Deposit\\nC = Cancel\");\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n    }\n}\n","name":"showState","className":"ATMFrame","variables":{"exception":1,"pad":1,"theATM":2,"display":4,"state":5,"JOptionPane":1},"constants":{"\"Select Account\\n\"":1,"null":1,"\"Balance = \"":1,"\"A = Withdraw\\nB = Deposit\\nC = Cancel\"":1,"\"Enter PIN\\nA = OK\"":1,"\"A = Checking\\nB = Savings\\nC = Exit\"":1,"\"\\nEnter amount and select transaction\\n\"":1,"\"Enter customer number\\nA = OK\"":1,"\"Database error\"":1},"javaDoc":"Updates display message","comments":" \n      Updates display message.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setCustomerNumber":1,"showState":1,"getValue":3,"getState":1,"showMessageDialog":2,"selectAccount":1,"back":1,"selectCustomer":1,"withdraw":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"int":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":54,"CastExpr":2,"StringLiteralExpr":2,"FieldAccessExpr":5,"MethodCallExpr":12},"statements":{"IfStmt":4,"BlockStmt":8,"TryStmt":2,"ExpressionStmt":9},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.START) {\n        theATM.setCustomerNumber((int) pad.getValue());\n    } else if (state == ATM.PIN) {\n        try {\n            theATM.selectCustomer((int) pad.getValue());\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n    } else if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.CHECKING);\n    } else if (state == ATM.TRANSACT) {\n        try {\n            theATM.withdraw(pad.getValue());\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"AButtonListener","variables":{"exception":2,"pad":3,"theATM":6,"state":5,"JOptionPane":2},"constants":{"null":2,"\"Database error\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getValue":1,"getState":1,"selectAccount":1,"showMessageDialog":1,"deposit":1,"back":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"int":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":31,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":7},"statements":{"IfStmt":2,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":6},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.SAVINGS);\n    } else if (state == ATM.TRANSACT) {\n        try {\n            theATM.deposit(pad.getValue());\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"BButtonListener","variables":{"exception":1,"pad":1,"theATM":4,"state":3,"JOptionPane":1},"constants":{"null":1,"\"Database error\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getState":1,"reset":1,"back":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":19,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.reset();\n    } else if (state == ATM.TRANSACT) {\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"CButtonListener","variables":{"theATM":3,"state":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createStatement":1,"init":1,"getConnection":1,"nextLine":1,"hasNextLine":1,"getResultSet":1,"showResultSet":1,"execute":1,"System.out.println":2},"annotations":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"concepts":[],"types":{"Scanner":1,"boolean":1,"Statement":1,"Connection":1,"ResultSet":1,"String":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":3,"VariableDeclarationExpr":6,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":53,"StringLiteralExpr":2,"FieldAccessExpr":6,"MethodCallExpr":10,"AssignExpr":2},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":9,"TryStmt":3,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) throws SQLException, IOException, ClassNotFoundException {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". ExecSQL propertiesFile [SQLcommandFile]\");\n        return;\n    }\n    SimpleDataSource.init(args[0]);\n    Scanner in;\n    if (args.length > 1) {\n        in = new Scanner(new File(args[1]));\n    } else {\n        in = new Scanner(System.in);\n    }\n    try (Connection conn = SimpleDataSource.getConnection();\n        Statement stat = conn.createStatement()) {\n        while (in.hasNextLine()) {\n            String line = in.nextLine();\n            try {\n                boolean hasResultSet = stat.execute(line);\n                if (hasResultSet) {\n                    try (ResultSet result = stat.getResultSet()) {\n                        showResultSet(result);\n                    }\n                }\n            } catch (SQLException ex) {\n                System.out.println(ex);\n            }\n        }\n    }\n}\n","name":"main","className":"ExecSQL","variables":{"args":2,"result":1,"conn":2,"stat":3,"ex":1,"in":5,"hasResultSet":2,"SimpleDataSource":2,"line":1},"constants":{"0":2,"\"Usage: java -classpath driver_class_path\"":1,"1":2,"\". ExecSQL propertiesFile [SQLcommandFile]\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["ResultSet"],"returnType":"void","methodCalls":{"next":1,"getColumnLabel":1,"getColumnCount":1,"getString":1,"getMetaData":1,"System.out.print":4,"System.out.println":2},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"ResultSetMetaData":1,"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":55,"StringLiteralExpr":2,"FieldAccessExpr":6,"UnaryExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ForStmt":2,"ExpressionStmt":8},"text":"/**\n      Prints a result set.\n      @param result the result set\n   */\npublic static void showResultSet(ResultSet result) throws SQLException {\n    ResultSetMetaData metaData = result.getMetaData();\n    int columnCount = metaData.getColumnCount();\n    for (int i = 1; i <= columnCount; i++) {\n        if (i > 1) {\n            System.out.print(\", \");\n        }\n        System.out.print(metaData.getColumnLabel(i));\n    }\n    System.out.println();\n    while (result.next()) {\n        for (int i = 1; i <= columnCount; i++) {\n            if (i > 1) {\n                System.out.print(\", \");\n            }\n            System.out.print(result.getString(i));\n        }\n        System.out.println();\n    }\n}\n","name":"showResultSet","className":"ExecSQL","variables":{"result":3,"metaData":3,"i":8,"columnCount":3},"constants":{"1":4,"\", \"":2},"javaDoc":"Prints a result set result the result set","comments":"\n      Prints a result set.\n      @param result the result set\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":6,"MethodCallExpr":6,"AssignExpr":5},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":10},"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":1,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"constants":{},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{"newCondition":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"NameExpr":6,"AssignExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n    balanceChangeLock = new ReentrantLock();\n    sufficientFundsCondition = balanceChangeLock.newCondition();\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"sufficientFundsCondition":1,"balanceChangeLock":2},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"signalAll":1,"unlock":1,"lock":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":25,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":5,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balanceChangeLock.lock();\n    try {\n        System.out.print(\"Depositing \" + amount);\n        double newBalance = balance + amount;\n        System.out.println(\", new balance is \" + newBalance);\n        balance = newBalance;\n        sufficientFundsCondition.signalAll();\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":3,"sufficientFundsCondition":1,"balanceChangeLock":2},"constants":{"\", new balance is \"":1,"\"Depositing \"":1},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"unlock":1,"await":1,"lock":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":27,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":5,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":7},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) throws InterruptedException {\n    balanceChangeLock.lock();\n    try {\n        while (balance < amount) {\n            sufficientFundsCondition.await();\n        }\n        System.out.print(\"Withdrawing \" + amount);\n        double newBalance = balance - amount;\n        System.out.println(\", new balance is \" + newBalance);\n        balance = newBalance;\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":3,"balance":3,"sufficientFundsCondition":1,"newBalance":3,"balanceChangeLock":2},"constants":{"\"Withdrawing \"":1,"\", new balance is \"":1},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["BankAccount","double","int"],"returnType":"WithdrawRunnable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   */\npublic WithdrawRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"WithdrawRunnable","className":"WithdrawRunnable","variables":{"amount":1,"aCount":1,"count":1,"anAccount":1,"anAmount":1,"account":1},"constants":{},"javaDoc":"Constructs a withdraw runnable anAccount the account from which to withdraw money anAmount the amount to withdraw in each repetition aCount the number of repetitions","comments":"\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"withdraw":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.withdraw(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"WithdrawRunnable","variables":{"exception":1,"count":1,"i":3,"account":1,"Thread":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"DepositRunnable":1,"WithdrawRunnable":1,"double":1,"BankAccount":1,"int":3,"Thread":2},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":9,"BinaryExpr":1,"NameExpr":17,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    BankAccount account = new BankAccount();\n    final double AMOUNT = 100;\n    final int REPETITIONS = 100;\n    final int THREADS = 100;\n    for (int i = 1; i <= THREADS; i++) {\n        DepositRunnable d = new DepositRunnable(account, AMOUNT, REPETITIONS);\n        WithdrawRunnable w = new WithdrawRunnable(account, AMOUNT, REPETITIONS);\n        Thread dt = new Thread(d);\n        Thread wt = new Thread(w);\n        dt.start();\n        wt.start();\n    }\n}\n","name":"main","className":"BankAccountThreadRunner","variables":{"dt":2,"d":2,"AMOUNT":3,"THREADS":2,"w":2,"i":3,"REPETITIONS":3,"wt":2,"account":3},"constants":{"100":3,"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["BankAccount","double","int"],"returnType":"DepositRunnable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   */\npublic DepositRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"DepositRunnable","className":"DepositRunnable","variables":{"amount":1,"aCount":1,"count":1,"anAccount":1,"anAmount":1,"account":1},"constants":{},"javaDoc":"Constructs a deposit runnable anAccount the account into which to deposit money anAmount the amount to deposit in each repetition aCount the number of repetitions","comments":"\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"deposit":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.deposit(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"DepositRunnable","variables":{"exception":1,"count":1,"i":3,"account":1,"Thread":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"SelectionSortComponent","methodCalls":{"randomIntArray":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":5,"ThisExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs the component.\n   */\npublic SelectionSortComponent() {\n    int[] values = ArrayUtil.randomIntArray(30, 300);\n    sorter = new SelectionSorter(values, this);\n}\n","name":"SelectionSortComponent","className":"SelectionSortComponent","variables":{"sorter":1,"values":2,"ArrayUtil":1},"constants":{"300":1,"30":1},"javaDoc":"Constructs the component","comments":"\n      Constructs the component.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void paintComponent(Graphics g) {\n    sorter.draw(g);\n}\n","name":"paintComponent","className":"SelectionSortComponent","variables":{"sorter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":1},"text":"public void run() {\n    try {\n        sorter.sort();\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"AnimationRunnable","variables":{"exception":1,"sorter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"start":1,"sort":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"AnimationRunnable":1,"Runnable":1,"Thread":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":2},"statements":{"TypeDeclarationStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":4},"text":"/**\n      Starts a new animation thread.\n   */\npublic void startAnimation() {\n    class AnimationRunnable implements Runnable {\n\n        public void run() {\n            try {\n                sorter.sort();\n            } catch (InterruptedException exception) {\n            }\n        }\n    }\n    Runnable r = new AnimationRunnable();\n    Thread t = new Thread(r);\n    t.start();\n}\n","name":"startAnimation","className":"SelectionSortComponent","variables":{"exception":1,"r":2,"sorter":1,"t":2,"AnimationRunnable":1,"run":1},"constants":{},"javaDoc":"Starts a new animation thread","comments":"\n      Starts a new animation thread.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int[]","JComponent"],"returnType":"SelectionSorter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a selection sorter.\n      @param anArray the array to sort\n      @param aComponent the component to be repainted when the animation \n      pauses\n   */\npublic SelectionSorter(int[] anArray, JComponent aComponent) {\n    a = anArray;\n    sortStateLock = new ReentrantLock();\n    component = aComponent;\n}\n","name":"SelectionSorter","className":"SelectionSorter","variables":{"a":1,"component":1,"sortStateLock":1,"anArray":1,"aComponent":1},"constants":{},"javaDoc":"Constructs a selection sorter anArray the array to sort aComponent the component to be repainted when the animation pauses","comments":"\n      Constructs a selection sorter.\n      @param anArray the array to sort\n      @param aComponent the component to be repainted when the animation \n      pauses\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"unlock":1,"swap":1,"minimumPosition":1,"lock":1,"pause":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":24,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"/**\n      Sorts the array managed by this selection sorter.\n   */\npublic void sort() throws InterruptedException {\n    for (int i = 0; i < a.length - 1; i++) {\n        int minPos = minimumPosition(i);\n        sortStateLock.lock();\n        try {\n            ArrayUtil.swap(a, minPos, i);\n            // For animation\n            alreadySorted = i;\n        } finally {\n            sortStateLock.unlock();\n        }\n        pause(2);\n    }\n}\n","name":"sort","className":"SelectionSorter","variables":{"sortStateLock":2,"alreadySorted":1,"i":4,"minPos":1,"ArrayUtil":1},"constants":{"0":1,"1":1,"2":1},"javaDoc":"Sorts the array managed by this selection sorter","comments":"For animation \n      Sorts the array managed by this selection sorter.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"unlock":1,"lock":1,"pause":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":24,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n      Finds the smallest element in a tail range of the array\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from]...a[a.length - 1]\n   */\nprivate int minimumPosition(int from) throws InterruptedException {\n    int minPos = from;\n    for (int i = from + 1; i < a.length; i++) {\n        sortStateLock.lock();\n        try {\n            if (a[i] < a[minPos]) {\n                minPos = i;\n            }\n            // For animation\n            markedPosition = i;\n        } finally {\n            sortStateLock.unlock();\n        }\n        pause(2);\n    }\n    return minPos;\n}\n","name":"minimumPosition","className":"SelectionSorter","variables":{"a":2,"sortStateLock":2,"minPos":4,"i":6,"from":2,"markedPosition":1},"constants":{"1":1,"2":1},"javaDoc":"Finds the smallest element in a tail range of the array from the first position in a to compare the position of the smallest element in the range a[from] a[a length - 1]","comments":"For animation \n      Finds the smallest element in a tail range of the array\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from]...a[a.length - 1]\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":2}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":3,"unlock":1,"lock":1,"getWidth":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":48,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":6,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Draws the current state of the sorting algorithm.\n      @param g the graphics context\n   */\npublic void draw(Graphics g) {\n    sortStateLock.lock();\n    try {\n        int deltaX = component.getWidth() / a.length;\n        for (int i = 0; i < a.length; i++) {\n            if (i == markedPosition) {\n                g.setColor(Color.RED);\n            } else if (i <= alreadySorted) {\n                g.setColor(Color.BLUE);\n            } else {\n                g.setColor(Color.BLACK);\n            }\n            g.drawLine(i * deltaX, 0, i * deltaX, a[i]);\n        }\n    } finally {\n        sortStateLock.unlock();\n    }\n}\n","name":"draw","className":"SelectionSorter","variables":{"a":1,"component":1,"sortStateLock":2,"deltaX":3,"g":4,"alreadySorted":1,"i":8,"markedPosition":1},"constants":{"0":2},"javaDoc":"Draws the current state of the sorting algorithm g the graphics context","comments":"\n      Draws the current state of the sorting algorithm.\n      @param g the graphics context\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"sleep":1,"repaint":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Pauses the animation.\n      @param steps the number of steps to pause\n   */\npublic void pause(int steps) throws InterruptedException {\n    component.repaint();\n    Thread.sleep(steps * DELAY);\n}\n","name":"pause","className":"SelectionSorter","variables":{"component":1,"steps":1,"DELAY":1,"Thread":1},"constants":{},"javaDoc":"Pauses the animation steps the number of steps to pause","comments":"\n      Pauses the animation.\n      @param steps the number of steps to pause\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setDefaultCloseOperation":1,"startAnimation":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"JFrame":1,"int":2,"SelectionSortComponent":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"NameExpr":24,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    final int FRAME_WIDTH = 300;\n    final int FRAME_HEIGHT = 400;\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    final SelectionSortComponent component = new SelectionSortComponent();\n    frame.add(component, BorderLayout.CENTER);\n    frame.setVisible(true);\n    component.startAnimation();\n}\n","name":"main","className":"SelectionSortViewer","variables":{"component":2,"FRAME_WIDTH":1,"FRAME_HEIGHT":1,"frame":5},"constants":{"300":1,"400":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":4},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    System.out.print(\"Depositing \" + amount);\n    double newBalance = balance + amount;\n    System.out.println(\", new balance is \" + newBalance);\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":3},"constants":{"\", new balance is \"":1,"\"Depositing \"":1},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":4},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    System.out.print(\"Withdrawing \" + amount);\n    double newBalance = balance - amount;\n    System.out.println(\", new balance is \" + newBalance);\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":3},"constants":{"\"Withdrawing \"":1,"\", new balance is \"":1},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["BankAccount","double","int"],"returnType":"WithdrawRunnable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   */\npublic WithdrawRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"WithdrawRunnable","className":"WithdrawRunnable","variables":{"amount":1,"aCount":1,"count":1,"anAccount":1,"anAmount":1,"account":1},"constants":{},"javaDoc":"Constructs a withdraw runnable anAccount the account from which to withdraw money anAmount the amount to withdraw in each repetition aCount the number of repetitions","comments":"\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"withdraw":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.withdraw(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"WithdrawRunnable","variables":{"exception":1,"count":1,"i":3,"account":1,"Thread":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"DepositRunnable":1,"WithdrawRunnable":1,"double":1,"BankAccount":1,"int":3,"Thread":2},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":9,"BinaryExpr":1,"NameExpr":17,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    BankAccount account = new BankAccount();\n    final double AMOUNT = 100;\n    final int REPETITIONS = 100;\n    final int THREADS = 100;\n    for (int i = 1; i <= THREADS; i++) {\n        DepositRunnable d = new DepositRunnable(account, AMOUNT, REPETITIONS);\n        WithdrawRunnable w = new WithdrawRunnable(account, AMOUNT, REPETITIONS);\n        Thread dt = new Thread(d);\n        Thread wt = new Thread(w);\n        dt.start();\n        wt.start();\n    }\n}\n","name":"main","className":"BankAccountThreadRunner","variables":{"dt":2,"d":2,"AMOUNT":3,"THREADS":2,"w":2,"i":3,"REPETITIONS":3,"wt":2,"account":3},"constants":{"100":3,"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["BankAccount","double","int"],"returnType":"DepositRunnable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   */\npublic DepositRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"DepositRunnable","className":"DepositRunnable","variables":{"amount":1,"aCount":1,"count":1,"anAccount":1,"anAmount":1,"account":1},"constants":{},"javaDoc":"Constructs a deposit runnable anAccount the account into which to deposit money anAmount the amount to deposit in each repetition aCount the number of repetitions","comments":"\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"deposit":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.deposit(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"DepositRunnable","variables":{"exception":1,"count":1,"i":3,"account":1,"Thread":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"GreetingRunnable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs the runnable object.\n      @param aGreeting the greeting to display\n   */\npublic GreetingRunnable(String aGreeting) {\n    greeting = aGreeting;\n}\n","name":"GreetingRunnable","className":"GreetingRunnable","variables":{"greeting":1,"aGreeting":1},"constants":{},"javaDoc":"Constructs the runnable object aGreeting the greeting to display","comments":"\n      Constructs the runnable object.\n      @param aGreeting the greeting to display\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{"int":1,"Date":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":14,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":3},"text":"public void run() {\n    try {\n        for (int i = 1; i <= REPETITIONS; i++) {\n            Date now = new Date();\n            System.out.println(now + \" \" + greeting);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"GreetingRunnable","variables":{"exception":1,"now":2,"greeting":1,"i":3,"REPETITIONS":1,"Thread":1},"constants":{"1":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"GreetingRunnable":2,"Thread":2},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":4,"StringLiteralExpr":2,"NameExpr":8,"MethodCallExpr":2},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    GreetingRunnable r1 = new GreetingRunnable(\"Hello\");\n    GreetingRunnable r2 = new GreetingRunnable(\"Goodbye\");\n    Thread t1 = new Thread(r1);\n    Thread t2 = new Thread(r2);\n    t1.start();\n    t2.start();\n}\n","name":"main","className":"GreetingThreadRunner","variables":{"r2":2,"t1":2,"t2":2,"r1":2},"constants":{"\"Hello\"":1,"\"Goodbye\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getNumberOfTires() {\n    return numberOfTires;\n}\n","name":"getNumberOfTires","className":"Vehicle","variables":{"numberOfTires":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setNumberOfTires(int newValue) {\n    numberOfTires = newValue;\n}\n","name":"setNumberOfTires","className":"Vehicle","variables":{"newValue":1,"numberOfTires":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getDescription() {\n    return \"A vehicle with \" + numberOfTires + \" tires\";\n}\n","name":"getDescription","className":"Vehicle","variables":{"numberOfTires":1},"constants":{"\"A vehicle with \"":1,"\" tires\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Car","methodCalls":{"setNumberOfTires":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"public Car() {\n    // Use the public interface to access the instance variable of the superclass\n    // same as this.setNumberOfTires(4)\n    setNumberOfTires(4);\n    licensePlateNumber = \"??????\";\n}\n","name":"Car","className":"Car","variables":{"licensePlateNumber":1},"constants":{"4":1,"\"??????\"":1},"javaDoc":"","comments":"Use the public interface to access the instance variable of the superclass same as this setNumberOfTires(4) ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// This method is added to the subclass\npublic void setLicensePlateNumber(String newValue) {\n    licensePlateNumber = newValue;\n}\n","name":"setLicensePlateNumber","className":"Car","variables":{"newValue":1,"licensePlateNumber":1},"constants":{},"javaDoc":"","comments":" This method is added to the subclass","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// This method overrides a method from the superclass\npublic String getDescription() {\n    return \"A car with license plate \" + licensePlateNumber;\n}\n","name":"getDescription","className":"Car","variables":{"licensePlateNumber":1},"constants":{"\"A car with license plate \"":1},"javaDoc":"","comments":" This method overrides a method from the superclass","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Car"],"returnType":"void","methodCalls":{"getNumberOfTires":1,"getDescription":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":2},"text":"public static void print(Car c) {\n    System.out.println(c.getDescription());\n    System.out.println(\"Tires: \" + c.getNumberOfTires());\n}\n","name":"print","className":"CarDemo","variables":{"c":2},"constants":{"\"Tires: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":2,"setLicensePlateNumber":1,"setNumberOfTires":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Car":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Car aPlainCar = new Car();\n    print(aPlainCar);\n    Car aLimo = new Car();\n    aLimo.setLicensePlateNumber(\"W00H00\");\n    aLimo.setNumberOfTires(8);\n    print(aLimo);\n}\n","name":"main","className":"CarDemo","variables":{"aPlainCar":1,"aLimo":3},"constants":{"8":1,"\"W00H00\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getNumberOfTires() {\n    return numberOfTires;\n}\n","name":"getNumberOfTires","className":"Vehicle","variables":{"numberOfTires":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setNumberOfTires(int newValue) {\n    numberOfTires = newValue;\n}\n","name":"setNumberOfTires","className":"Vehicle","variables":{"newValue":1,"numberOfTires":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return getClass().getName() + \"[numberOfTires=\" + numberOfTires + \"]\";\n// This is a good way of implementing toString in a superclass--see Special Topic 9.6\n}\n","name":"toString","className":"Vehicle","variables":{"numberOfTires":1},"constants":{"\"]\"":1,"\"[numberOfTires=\"":1},"javaDoc":"","comments":"This is a good way of implementing toString in a superclass--see Special Topic 9 6 ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Car","methodCalls":{"setNumberOfTires":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"public Car() {\n    setNumberOfTires(4);\n    licensePlateNumber = \"??????\";\n}\n","name":"Car","className":"Car","variables":{"licensePlateNumber":1},"constants":{"4":1,"\"??????\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setLicensePlateNumber(String newValue) {\n    licensePlateNumber = newValue;\n}\n","name":"setLicensePlateNumber","className":"Car","variables":{"newValue":1,"licensePlateNumber":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":3,"NameExpr":3,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return super.toString() + \"[licensePlateNumber=\" + licensePlateNumber + \"]\";\n// This is a good way of implementing toString in a subclass--see Special Topic 9.6\n}\n","name":"toString","className":"Car","variables":{"licensePlateNumber":1},"constants":{"\"]\"":1,"\"[licensePlateNumber=\"":1},"javaDoc":"","comments":"This is a good way of implementing toString in a subclass--see Special Topic 9 6 ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Vehicle","String"],"returnType":"void","methodCalls":{"setLicensePlateNumber":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Car":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":12,"CastExpr":1,"FieldAccessExpr":1,"InstanceOfExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public static void process(Vehicle v, String plateNumber) {\n    // This example shows the syntax of instanceof and casting\n    if (v instanceof Car) {\n        // Vehicle has no setLicensePlateNumber method--must cast\n        Car c = (Car) v;\n        c.setLicensePlateNumber(plateNumber);\n    }\n    // calls v.toString()\n    System.out.println(v);\n}\n","name":"process","className":"VehicleDemo","variables":{"c":2,"v":2},"constants":{},"javaDoc":"","comments":"This example shows the syntax of instanceof and casting Vehicle has no setLicensePlateNumber method--must cast calls v toString() ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":3,"setNumberOfTires":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Vehicle":2,"Car":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":11,"StringLiteralExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Vehicle aCar = new Car();\n    process(aCar, \"XYX123\");\n    Vehicle aLimo = new Car();\n    aLimo.setNumberOfTires(8);\n    process(aLimo, \"W00H00\");\n    process(new Motorcycle(), \"MT1729\");\n}\n","name":"main","className":"VehicleDemo","variables":{"aLimo":2,"aCar":1},"constants":{"\"MT1729\"":1,"8":1,"\"W00H00\"":1,"\"XYX123\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"Motorcycle","methodCalls":{"setNumberOfTires":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public Motorcycle() {\n    setNumberOfTires(2);\n}\n","name":"Motorcycle","className":"Motorcycle","variables":{},"constants":{"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addChoice":8,"presentQuestion":2,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"ChoiceQuestion":2},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":8,"NameExpr":36,"StringLiteralExpr":10,"MethodCallExpr":12},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    ChoiceQuestion first = new ChoiceQuestion();\n    first.setText(\"What was the original name of the Java language?\");\n    first.addChoice(\"*7\", false);\n    first.addChoice(\"Duke\", false);\n    first.addChoice(\"Oak\", true);\n    first.addChoice(\"Gosling\", false);\n    ChoiceQuestion second = new ChoiceQuestion();\n    second.setText(\"In which country was the inventor of Java born?\");\n    second.addChoice(\"Australia\", false);\n    second.addChoice(\"Canada\", true);\n    second.addChoice(\"Denmark\", false);\n    second.addChoice(\"United States\", false);\n    presentQuestion(first);\n    presentQuestion(second);\n}\n","name":"main","className":"QuestionDemo2","variables":{"first":6,"second":6},"constants":{"\"In which country was the inventor of Java born?\"":1,"\"*7\"":1,"\"Denmark\"":1,"\"United States\"":1,"\"What was the original name of the Java language?\"":1,"false":6,"true":2,"\"Canada\"":1,"\"Duke\"":1,"\"Australia\"":1,"\"Gosling\"":1,"\"Oak\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":14,"modifier":9}
{"paramTypes":["ChoiceQuestion"],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"display":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"/**\n      Presents a question to the user and checks the response.\n      @param q the question\n   */\npublic static void presentQuestion(ChoiceQuestion q) {\n    q.display();\n    System.out.print(\"Your answer: \");\n    Scanner in = new Scanner(System.in);\n    String response = in.nextLine();\n    System.out.println(q.checkAnswer(response));\n}\n","name":"presentQuestion","className":"QuestionDemo2","variables":{"q":2,"in":2,"response":1},"constants":{"\"Your answer: \"":1},"javaDoc":"Presents a question to the user and checks the response q the question","comments":"\n      Presents a question to the user and checks the response.\n      @param q the question\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"constants":{"\"\"":2},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":1},"constants":{},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":1},"constants":{},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":1},"constants":{},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"constants":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ChoiceQuestion","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a choice question with no choices.\n   */\npublic ChoiceQuestion() {\n    choices = new ArrayList<String>();\n}\n","name":"ChoiceQuestion","className":"ChoiceQuestion","variables":{"choices":1},"constants":{},"javaDoc":"Constructs a choice question with no choices","comments":"\n      Constructs a choice question with no choices.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","boolean"],"returnType":"void","methodCalls":{"add":1,"size":1,"setAnswer":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   */\npublic void addChoice(String choice, boolean correct) {\n    choices.add(choice);\n    if (correct) {\n        // Convert choices.size() to string\n        String choiceString = \"\" + choices.size();\n        setAnswer(choiceString);\n    }\n}\n","name":"addChoice","className":"ChoiceQuestion","variables":{"correct":1,"choiceString":1,"choices":2},"constants":{"\"\"":1},"javaDoc":"Adds an answer choice to this question choice the choice to add correct true if this is the correct choice false otherwise","comments":"Convert choices size() to string \n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"SuperExpr":1,"BinaryExpr":4,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public void display() {\n    // Display the question text\n    super.display();\n    // Display the answer choices\n    for (int i = 0; i < choices.size(); i++) {\n        int choiceNumber = i + 1;\n        System.out.println(choiceNumber + \": \" + choices.get(i));\n    }\n}\n","name":"display","className":"ChoiceQuestion","variables":{"choiceNumber":2,"i":4,"choices":2},"constants":{"0":1,"1":1,"\": \"":1},"javaDoc":"","comments":"Display the question text Display the answer choices ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with zero balance","comments":"\n      Constructs a bank account with zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Makes a deposit into this account.\n      @param amount the amount of the deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Makes a deposit into this account amount the amount of the deposit","comments":"\n      Makes a deposit into this account.\n      @param amount the amount of the deposit\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Makes a withdrawal from this account or charges a penalty if sufficient funds are not available amount the amount of the withdrawal","comments":"\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Carries out the end of month processing that is appropriate\n      for this account.\n   */\npublic void monthEnd() {\n}\n","name":"monthEnd","className":"BankAccount","variables":{},"constants":{},"javaDoc":"Carries out the end of month processing that is appropriate for this account","comments":"\n      Carries out the end of month processing that is appropriate\n      for this account.\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of this bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of this bank account the current balance","comments":"\n      Gets the current balance of this bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"SavingsAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a savings account with a zero balance.\n   */\npublic SavingsAccount() {\n    interestRate = 0;\n    minBalance = 0;\n}\n","name":"SavingsAccount","className":"SavingsAccount","variables":{"interestRate":1,"minBalance":1},"constants":{"0":2},"javaDoc":"Constructs a savings account with a zero balance","comments":"\n      Constructs a savings account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the interest rate for this account.\n      @param rate the monthly interest rate in percent\n   */\npublic void setInterestRate(double rate) {\n    interestRate = rate;\n}\n","name":"setInterestRate","className":"SavingsAccount","variables":{"interestRate":1,"rate":1},"constants":{},"javaDoc":"Sets the interest rate for this account rate the monthly interest rate in percent","comments":"\n      Sets the interest rate for this account.\n      @param rate the monthly interest rate in percent\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"getBalance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":1,"NameExpr":9,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public void withdraw(double amount) {\n    super.withdraw(amount);\n    double balance = getBalance();\n    if (balance < minBalance) {\n        minBalance = balance;\n    }\n}\n","name":"withdraw","className":"SavingsAccount","variables":{"minBalance":2,"balance":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":8,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"public void monthEnd() {\n    double interest = minBalance * interestRate / 100;\n    deposit(interest);\n    minBalance = getBalance();\n}\n","name":"monthEnd","className":"SavingsAccount","variables":{"interestRate":1,"minBalance":2,"interest":1},"constants":{"100":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"equals":5,"setInterestRate":1,"nextInt":1,"System.out.print":2,"nextDouble":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Scanner":1,"SavingsAccount":1,"boolean":1,"double":1,"BankAccount[]":1,"String":1,"int":5},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":3,"VariableDeclarationExpr":11,"ArrayAccessExpr":7,"BinaryExpr":9,"NameExpr":99,"StringLiteralExpr":9,"UnaryExpr":4,"AssignExpr":3,"DoubleLiteralExpr":1,"BooleanLiteralExpr":2,"FieldAccessExpr":9,"ArrayCreationExpr":1,"MethodCallExpr":18},"statements":{"IfStmt":4,"WhileStmt":1,"BlockStmt":9,"ForStmt":3,"ExpressionStmt":19},"text":"public static void main(String[] args) {\n    // Create accounts\n    final int ACCOUNTS_SIZE = 10;\n    BankAccount[] accounts = new BankAccount[ACCOUNTS_SIZE];\n    for (int i = 0; i < accounts.length / 2; i++) {\n        accounts[i] = new CheckingAccount();\n    }\n    for (int i = accounts.length / 2; i < accounts.length; i++) {\n        SavingsAccount account = new SavingsAccount();\n        account.setInterestRate(0.75);\n        accounts[i] = account;\n    }\n    // Execute commands\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"D)eposit  W)ithdraw  M)onth end  Q)uit: \");\n        String input = in.next();\n        if (// Deposit or withdrawal\n        input.equals(\"D\") || input.equals(\"W\")) {\n            System.out.print(\"Enter account number and amount: \");\n            int num = in.nextInt();\n            double amount = in.nextDouble();\n            if (input.equals(\"D\")) {\n                accounts[num].deposit(amount);\n            } else {\n                accounts[num].withdraw(amount);\n            }\n            System.out.println(\"Balance: \" + accounts[num].getBalance());\n        } else if (// Month end processing\n        input.equals(\"M\")) {\n            for (int n = 0; n < accounts.length; n++) {\n                accounts[n].monthEnd();\n                System.out.println(n + \" \" + accounts[n].getBalance());\n            }\n        } else if (input.equals(\"Q\")) {\n            done = true;\n        }\n    }\n}\n","name":"main","className":"AccountDemo","variables":{"ACCOUNTS_SIZE":2,"input":6,"amount":1,"in":4,"num":4,"i":8,"accounts":8,"done":3,"account":3,"n":6},"constants":{"\"D\"":2,"\" \"":1,"false":1,"0.75":1,"\"W\"":1,"\"Balance: \"":1,"0":2,"2":2,"\"Q\"":1,"\"D)eposit  W)ithdraw  M)onth end  Q)uit: \"":1,"\"M\"":1,"true":1,"\"Enter account number and amount: \"":1,"10":1},"javaDoc":"","comments":"Create accounts Execute commands Deposit or withdrawal Month end processing ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":[],"returnType":"CheckingAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a checking account with a zero balance.\n   */\npublic CheckingAccount() {\n    withdrawals = 0;\n}\n","name":"CheckingAccount","className":"CheckingAccount","variables":{"withdrawals":1},"constants":{"0":1},"javaDoc":"Constructs a checking account with a zero balance","comments":"\n      Constructs a checking account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"SuperExpr":2,"BinaryExpr":1,"NameExpr":9,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public void withdraw(double amount) {\n    final int FREE_WITHDRAWALS = 3;\n    final int WITHDRAWAL_FEE = 1;\n    super.withdraw(amount);\n    withdrawals++;\n    if (withdrawals > FREE_WITHDRAWALS) {\n        super.withdraw(WITHDRAWAL_FEE);\n    }\n}\n","name":"withdraw","className":"CheckingAccount","variables":{"FREE_WITHDRAWALS":2,"WITHDRAWAL_FEE":1,"withdrawals":2},"constants":{"1":1,"3":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void monthEnd() {\n    withdrawals = 0;\n}\n","name":"monthEnd","className":"CheckingAccount","variables":{"withdrawals":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getName":1,"nextInt":1,"weeklyPay":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Employee":1,"Employee[]":1,"int":1},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":4,"VariableDeclarationExpr":4,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":27,"StringLiteralExpr":6,"FieldAccessExpr":3,"ArrayCreationExpr":1,"AssignExpr":3,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Employee[] staff = new Employee[3];\n    staff[0] = new HourlyEmployee(\"Morgan, Harry\", 30);\n    staff[1] = new SalariedEmployee(\"Lin, Sally\", 52000);\n    staff[2] = new Manager(\"Smith, Mary\", 104000, 50);\n    Scanner in = new Scanner(System.in);\n    for (Employee e : staff) {\n        System.out.print(\"Hours worked by \" + e.getName() + \": \");\n        int hours = in.nextInt();\n        System.out.println(\"Salary: \" + e.weeklyPay(hours));\n    }\n}\n","name":"main","className":"SalaryDemo","variables":{"hours":1,"in":2,"e":3,"staff":5},"constants":{"\"Smith, Mary\"":1,"104000":1,"\": \"":1,"0":1,"1":1,"\"Lin, Sally\"":1,"52000":1,"2":1,"3":1,"\"Morgan, Harry\"":1,"\"Salary: \"":1,"50":1,"30":1,"\"Hours worked by \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String","double","double"],"returnType":"Manager","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/**\n      Constructs a manager with a given name, annual salary and weekly bonus.\n      @param name the name of this employee\n      @param salary the annual salary\n      @param bonus the weekly bonus\n    */\npublic Manager(String name, double salary, double bonus) {\n    super(name, salary);\n    weeklyBonus = bonus;\n}\n","name":"Manager","className":"Manager","variables":{"bonus":1,"name":1,"weeklyBonus":1,"salary":1},"constants":{},"javaDoc":"Constructs a manager with a given name annual salary and weekly bonus name the name of this employee salary the annual salary bonus the weekly bonus","comments":"\n      Constructs a manager with a given name, annual salary and weekly bonus.\n      @param name the name of this employee\n      @param salary the annual salary\n      @param bonus the weekly bonus\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public double weeklyPay(int hoursWorked) {\n    return super.weeklyPay(hoursWorked) + weeklyBonus;\n}\n","name":"weeklyPay","className":"Manager","variables":{"weeklyBonus":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Employee","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1,"StringLiteralExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an employee with an empty name.\n   */\npublic Employee() {\n    name = \"\";\n}\n","name":"Employee","className":"Employee","variables":{"name":1},"constants":{"\"\"":1},"javaDoc":"Constructs an employee with an empty name","comments":"\n      Constructs an employee with an empty name.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the name of this employee.\n      @param employeeName the new name \n   */\npublic void setName(String employeeName) {\n    name = employeeName;\n}\n","name":"setName","className":"Employee","variables":{"employeeName":1,"name":1},"constants":{},"javaDoc":"Sets the name of this employee employeeName the new name","comments":"\n      Sets the name of this employee.\n      @param employeeName the new name \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the name of this employee.\n      @return the name \n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Employee","variables":{"name":1},"constants":{},"javaDoc":"Gets the name of this employee the name","comments":"\n      Gets the name of this employee.\n      @return the name \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes the pay for one week of work.\n      @param hoursWorked the number of hours worked in the week\n      @return the pay for the given number of hours\n   */\npublic double weeklyPay(int hoursWorked) {\n    return 0;\n}\n","name":"weeklyPay","className":"Employee","variables":{},"constants":{"0":1},"javaDoc":"Computes the pay for one week of work hoursWorked the number of hours worked in the week the pay for the given number of hours","comments":"\n      Computes the pay for one week of work.\n      @param hoursWorked the number of hours worked in the week\n      @return the pay for the given number of hours\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","double"],"returnType":"SalariedEmployee","methodCalls":{"setName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a salaried employee with a given name and annual salary.\n      @param name the name of this employee\n      @param salary the annual salary\n    */\npublic SalariedEmployee(String name, double salary) {\n    setName(name);\n    annualSalary = salary;\n}\n","name":"SalariedEmployee","className":"SalariedEmployee","variables":{"annualSalary":1,"salary":1},"constants":{},"javaDoc":"Constructs a salaried employee with a given name and annual salary name the name of this employee salary the annual salary","comments":"\n      Constructs a salaried employee with a given name and annual salary.\n      @param name the name of this employee\n      @param salary the annual salary\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public double weeklyPay(int hoursWorked) {\n    final int WEEKS_PER_YEAR = 52;\n    return annualSalary / WEEKS_PER_YEAR;\n}\n","name":"weeklyPay","className":"SalariedEmployee","variables":{"annualSalary":1,"WEEKS_PER_YEAR":2},"constants":{"52":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String","double"],"returnType":"HourlyEmployee","methodCalls":{"setName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an hourly employee with a given name and weekly wage.\n      @param name the name of this employee\n      @param wage the hourly wage \n   */\npublic HourlyEmployee(String name, double wage) {\n    setName(name);\n    hourlyWage = wage;\n}\n","name":"HourlyEmployee","className":"HourlyEmployee","variables":{"hourlyWage":1,"wage":1},"constants":{},"javaDoc":"Constructs an hourly employee with a given name and weekly wage name the name of this employee wage the hourly wage","comments":"\n      Constructs an hourly employee with a given name and weekly wage.\n      @param name the name of this employee\n      @param wage the hourly wage \n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":6,"NameExpr":8,"EnclosedExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public double weeklyPay(int hoursWorked) {\n    double pay = hoursWorked * hourlyWage;\n    if (hoursWorked > 40) {\n        // Add overtime\n        pay = pay + ((hoursWorked - 40) * 0.5) * hourlyWage;\n    }\n    return pay;\n}\n","name":"weeklyPay","className":"HourlyEmployee","variables":{"hourlyWage":2,"pay":4,"hoursWorked":3},"constants":{"0.5":1,"40":2},"javaDoc":"","comments":"Add overtime ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"setAnswer":1,"display":1,"System.out.print":1,"setText":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Question":1,"String":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"NameExpr":29,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":7},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    Question q = new Question();\n    q.setText(\"Who was the inventor of Java?\");\n    q.setAnswer(\"James Gosling\");\n    q.display();\n    System.out.print(\"Your answer: \");\n    String response = in.nextLine();\n    System.out.println(q.checkAnswer(response));\n}\n","name":"main","className":"QuestionDemo1","variables":{"q":5,"in":2,"response":1},"constants":{"\"Who was the inventor of Java?\"":1,"\"Your answer: \"":1,"\"James Gosling\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":9}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"constants":{"\"\"":2},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":1},"constants":{},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":1},"constants":{},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":1},"constants":{},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"constants":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setAnswer":1,"addChoice":4,"presentQuestion":2,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Question":1,"ChoiceQuestion":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":4,"NameExpr":27,"StringLiteralExpr":7,"MethodCallExpr":9},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Question first = new Question();\n    first.setText(\"Who was the inventor of Java?\");\n    first.setAnswer(\"James Gosling\");\n    ChoiceQuestion second = new ChoiceQuestion();\n    second.setText(\"In which country was the inventor of Java born?\");\n    second.addChoice(\"Australia\", false);\n    second.addChoice(\"Canada\", true);\n    second.addChoice(\"Denmark\", false);\n    second.addChoice(\"United States\", false);\n    presentQuestion(first);\n    presentQuestion(second);\n}\n","name":"main","className":"QuestionDemo3","variables":{"first":3,"second":6},"constants":{"\"Who was the inventor of Java?\"":1,"\"In which country was the inventor of Java born?\"":1,"\"Denmark\"":1,"\"United States\"":1,"\"James Gosling\"":1,"false":3,"true":1,"\"Canada\"":1,"\"Australia\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":9}
{"paramTypes":["Question"],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"display":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"/**\n      Presents a question to the user and checks the response.\n      @param q the question\n   */\npublic static void presentQuestion(Question q) {\n    q.display();\n    System.out.print(\"Your answer: \");\n    Scanner in = new Scanner(System.in);\n    String response = in.nextLine();\n    System.out.println(q.checkAnswer(response));\n}\n","name":"presentQuestion","className":"QuestionDemo3","variables":{"q":2,"in":2,"response":1},"constants":{"\"Your answer: \"":1},"javaDoc":"Presents a question to the user and checks the response q the question","comments":"\n      Presents a question to the user and checks the response.\n      @param q the question\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"constants":{"\"\"":2},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":1},"constants":{},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":1},"constants":{},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":1},"constants":{},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"constants":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ChoiceQuestion","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a choice question with no choices.\n   */\npublic ChoiceQuestion() {\n    choices = new ArrayList<String>();\n}\n","name":"ChoiceQuestion","className":"ChoiceQuestion","variables":{"choices":1},"constants":{},"javaDoc":"Constructs a choice question with no choices","comments":"\n      Constructs a choice question with no choices.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String","boolean"],"returnType":"void","methodCalls":{"add":1,"size":1,"setAnswer":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   */\npublic void addChoice(String choice, boolean correct) {\n    choices.add(choice);\n    if (correct) {\n        // Convert choices.size() to string\n        String choiceString = \"\" + choices.size();\n        setAnswer(choiceString);\n    }\n}\n","name":"addChoice","className":"ChoiceQuestion","variables":{"correct":1,"choiceString":1,"choices":2},"constants":{"\"\"":1},"javaDoc":"Adds an answer choice to this question choice the choice to add correct true if this is the correct choice false otherwise","comments":"Convert choices size() to string \n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"SuperExpr":1,"BinaryExpr":4,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public void display() {\n    // Display the question text\n    super.display();\n    // Display the answer choices\n    for (int i = 0; i < choices.size(); i++) {\n        int choiceNumber = i + 1;\n        System.out.println(choiceNumber + \": \" + choices.get(i));\n    }\n}\n","name":"display","className":"ChoiceQuestion","variables":{"choiceNumber":2,"i":4,"choices":2},"constants":{"0":1,"1":1,"\": \"":1},"javaDoc":"","comments":"Display the question text Display the answer choices ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"ArrayList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":3,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs an empty array list.\n   */\npublic ArrayList() {\n    final int INITIAL_SIZE = 10;\n    elements = new Object[INITIAL_SIZE];\n    currentSize = 0;\n}\n","name":"ArrayList","className":"ArrayList","variables":{"INITIAL_SIZE":2,"elements":1,"currentSize":1},"constants":{"0":1,"10":1},"javaDoc":"Constructs an empty array list","comments":"\n      Constructs an empty array list.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the size of this array list.\n      @return the size\n   */\npublic int size() {\n    return currentSize;\n}\n","name":"size","className":"ArrayList","variables":{"currentSize":1},"constants":{},"javaDoc":"Gets the size of this array list the size","comments":"\n      Gets the size of this array list.\n      @return the size\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":3,"NameExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1},"text":"/**\n      Throws an IndexOutOfBoundsException if the checked index is out of bounds\n      @param n the index to check\n   */\nprivate void checkBounds(int n) {\n    if (n < 0 || n >= currentSize) {\n        throw new IndexOutOfBoundsException();\n    }\n}\n","name":"checkBounds","className":"ArrayList","variables":{"n":2,"currentSize":1},"constants":{"0":1},"javaDoc":"Throws an IndexOutOfBoundsException if the checked index is out of bounds n the index to check","comments":"\n      Throws an IndexOutOfBoundsException if the checked index is out of bounds\n      @param n the index to check\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"checkBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Gets the element at a given position.\n      @param pos the position\n      @return the element at pos\n   */\npublic Object get(int pos) {\n    checkBounds(pos);\n    return elements[pos];\n}\n","name":"get","className":"ArrayList","variables":{"pos":1,"elements":1},"constants":{},"javaDoc":"Gets the element at a given position pos the position the element at pos","comments":"\n      Gets the element at a given position.\n      @param pos the position\n      @return the element at pos\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"checkBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":6,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Sets the element at a given position.\n      @param pos the position\n      @param element the new value\n   */\npublic void set(int pos, Object element) {\n    checkBounds(pos);\n    elements[pos] = element;\n}\n","name":"set","className":"ArrayList","variables":{"pos":1,"elements":1,"element":1},"constants":{},"javaDoc":"Sets the element at a given position pos the position element the new value","comments":"\n      Sets the element at a given position.\n      @param pos the position\n      @param element the new value\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"checkBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":15,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Removes the element at a given position.\n      @param pos the position\n      @return the removed element\n   */\npublic Object remove(int pos) {\n    checkBounds(pos);\n    Object removed = elements[pos];\n    for (int i = pos + 1; i < currentSize; i++) {\n        elements[i - 1] = elements[i];\n    }\n    currentSize--;\n    return removed;\n}\n","name":"remove","className":"ArrayList","variables":{"removed":2,"pos":2,"elements":3,"i":5,"currentSize":2},"constants":{"1":2},"javaDoc":"Removes the element at a given position pos the position the removed element","comments":"\n      Removes the element at a given position.\n      @param pos the position\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"boolean","methodCalls":{"checkBounds":1,"growIfNecessary":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":3,"BooleanLiteralExpr":1,"NameExpr":17,"UnaryExpr":2,"MethodCallExpr":2,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Adds an element after a given position.\n      @param pos the position\n      @param newElement the element to add\n   */\npublic boolean add(int pos, Object newElement) {\n    growIfNecessary();\n    currentSize++;\n    checkBounds(pos);\n    for (int i = currentSize - 1; i > pos; i--) {\n        elements[i] = elements[i - 1];\n    }\n    elements[pos] = newElement;\n    return true;\n}\n","name":"add","className":"ArrayList","variables":{"pos":2,"elements":3,"i":5,"newElement":1,"currentSize":2},"constants":{"1":2,"true":1},"javaDoc":"Adds an element after a given position pos the position newElement the element to add","comments":"\n      Adds an element after a given position.\n      @param pos the position\n      @param newElement the element to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"growIfNecessary":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Adds an element after the end of the array list\n      @param newElement the element to add\n   */\npublic boolean addLast(Object newElement) {\n    growIfNecessary();\n    currentSize++;\n    elements[currentSize - 1] = newElement;\n    return true;\n}\n","name":"addLast","className":"ArrayList","variables":{"elements":1,"newElement":1,"currentSize":2},"constants":{"1":1,"true":1},"javaDoc":"Adds an element after the end of the array list newElement the element to add","comments":"\n      Adds an element after the end of the array list\n      @param newElement the element to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object[]":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":18,"FieldAccessExpr":3,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"/**\n      Grows the elements array if the current size equals the capacity.\n   */\nprivate void growIfNecessary() {\n    if (currentSize == elements.length) {\n        Object[] newElements = new Object[2 * elements.length];\n        for (int i = 0; i < elements.length; i++) {\n            newElements[i] = elements[i];\n        }\n        elements = newElements;\n    }\n}\n","name":"growIfNecessary","className":"ArrayList","variables":{"elements":2,"i":5,"newElements":3,"currentSize":1},"constants":{"0":1,"2":1},"javaDoc":"Grows the elements array if the current size equals the capacity","comments":"\n      Grows the elements array if the current size equals the capacity.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"addLast":3,"size":1,"get":1,"remove":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArrayList":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":32,"StringLiteralExpr":4,"FieldAccessExpr":1,"UnaryExpr":2,"MethodCallExpr":8},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    ArrayList staff = new ArrayList();\n    staff.addLast(\"Diana\");\n    staff.addLast(\"Harry\");\n    for (int i = 1; i <= 10; i++) {\n        staff.addLast(\"Tom\" + i);\n    }\n    staff.add(0, \"Juliet\");\n    staff.remove(1);\n    for (int i = 0; i < staff.size(); i++) {\n        System.out.println(staff.get(i));\n    }\n}\n","name":"main","className":"ArrayListDemo","variables":{"i":7,"staff":8},"constants":{"0":2,"1":2,"\"Tom\"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":[],"returnType":"CircularArrayQueue","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"NameExpr":5,"ArrayCreationExpr":1,"AssignExpr":4},"statements":{"ExpressionStmt":5},"text":"/**\n      Constructs an empty queue.\n   */\npublic CircularArrayQueue() {\n    final int INITIAL_SIZE = 10;\n    elements = new Object[INITIAL_SIZE];\n    currentSize = 0;\n    head = 0;\n    tail = 0;\n}\n","name":"CircularArrayQueue","className":"CircularArrayQueue","variables":{"head":1,"INITIAL_SIZE":2,"tail":1,"elements":1,"currentSize":1},"constants":{"0":3,"10":1},"javaDoc":"Constructs an empty queue","comments":"\n      Constructs an empty queue.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this queue is empty.\n      @return true if this queue is empty\n   */\npublic boolean empty() {\n    return currentSize == 0;\n}\n","name":"empty","className":"CircularArrayQueue","variables":{"currentSize":1},"constants":{"0":1},"javaDoc":"Checks whether this queue is empty true if this queue is empty","comments":"\n      Checks whether this queue is empty.\n      @return true if this queue is empty\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"growIfNecessary":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":11,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":4},"text":"/**\n      Adds an element to the tail of this queue.\n      @param newElement the element to add\n   */\npublic void add(Object newElement) {\n    growIfNecessary();\n    currentSize++;\n    elements[tail] = newElement;\n    tail = (tail + 1) % elements.length;\n}\n","name":"add","className":"CircularArrayQueue","variables":{"tail":3,"elements":1,"newElement":1,"currentSize":1},"constants":{"1":1},"javaDoc":"Adds an element to the tail of this queue newElement the element to add","comments":"\n      Adds an element to the tail of this queue.\n      @param newElement the element to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":10,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Removes an element from the head of this queue.\n      @return the removed element\n   */\npublic Object remove() {\n    if (currentSize == 0) {\n        throw new NoSuchElementException();\n    }\n    Object removed = elements[head];\n    head = (head + 1) % elements.length;\n    currentSize--;\n    return removed;\n}\n","name":"remove","className":"CircularArrayQueue","variables":{"head":3,"removed":2,"elements":1,"currentSize":2},"constants":{"0":1,"1":1},"javaDoc":"Removes an element from the head of this queue the removed element","comments":"\n      Removes an element from the head of this queue.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object[]":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":25,"FieldAccessExpr":4,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Grows the element array if the current size equals the capacity.\n   */\nprivate void growIfNecessary() {\n    if (currentSize == elements.length) {\n        Object[] newElements = new Object[2 * elements.length];\n        for (int i = 0; i < elements.length; i++) {\n            newElements[i] = elements[(head + i) % elements.length];\n        }\n        elements = newElements;\n        head = 0;\n        tail = currentSize;\n    }\n}\n","name":"growIfNecessary","className":"CircularArrayQueue","variables":{"head":2,"tail":1,"elements":2,"i":5,"newElements":3,"currentSize":2},"constants":{"0":2,"2":1},"javaDoc":"Grows the element array if the current size equals the capacity","comments":"\n      Grows the element array if the current size equals the capacity.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"remove":1,"empty":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"CircularArrayQueue":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    CircularArrayQueue q = new CircularArrayQueue();\n    q.add(\"Tom\");\n    q.add(\"Diana\");\n    q.add(\"Harry\");\n    while (!q.empty()) {\n        System.out.println(q.remove());\n    }\n}\n","name":"main","className":"QueueDemo","variables":{"q":6},"constants":{"\"Tom\"":1,"\"Diana\"":1,"\"Harry\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":4,"add":2,"addLast":4,"previous":1,"listIterator":2,"hasNext":1,"remove":1,"System.out.print":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"ListIterator":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":66,"StringLiteralExpr":7,"FieldAccessExpr":4,"MethodCallExpr":19,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    LinkedList staff = new LinkedList();\n    staff.addLast(\"Diana\");\n    staff.addLast(\"Harry\");\n    staff.addLast(\"Romeo\");\n    staff.addLast(\"Tom\");\n    // | in the comments indicates the iterator position\n    // |DHRT\n    ListIterator iterator = staff.listIterator();\n    // D|HRT\n    iterator.next();\n    // DH|RT\n    iterator.next();\n    // Add more elements after second element\n    // DHJ|RT\n    iterator.add(\"Juliet\");\n    // DHJN|RT\n    iterator.add(\"Nina\");\n    // DHJNR|T\n    System.out.println(iterator.next());\n    // DHJN|RT\n    System.out.println(iterator.previous());\n    // Remove last traversed element \n    // DHJN|T\n    iterator.remove();\n    // Print all elements\n    iterator = staff.listIterator();\n    while (iterator.hasNext()) {\n        System.out.print(iterator.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"ListDemo","variables":{"iterator":11,"staff":7},"constants":{"\"Nina\"":1,"\"Tom\"":1,"\" \"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Romeo\"":1},"javaDoc":"","comments":"| in the comments indicates the iterator position Add more elements after second element Remove last traversed element Print all elements |DHRT D|HRT DH|RT DHJ|RT DHJN|RT DHJNR|T DHJN|RT DHJN|T ","isEmpty":false,"hasInnerClass":false,"lineCount":20,"modifier":9}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Moves the iterator past the next element.\n      @return the traversed element\n   */\nObject next();\n","name":"next","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n      Moves the iterator past the next element.\n      @return the traversed element\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   */\nboolean hasNext();\n","name":"hasNext","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Moves the iterator after the previous element.\n      @return the traversed element\n   */\nObject previous();\n","name":"previous","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Moves the iterator after the previous element the traversed element","comments":"\n      Moves the iterator after the previous element.\n      @return the traversed element\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Tests if there is an element before the iterator position.\n      @return true if there is an element before the iterator position\n   */\nboolean hasPrevious();\n","name":"hasPrevious","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Tests if there is an element before the iterator position true if there is an element before the iterator position","comments":"\n      Tests if there is an element before the iterator position.\n      @return true if there is an element before the iterator position\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   */\nvoid add(Object element);\n","name":"add","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   */\nvoid remove();\n","name":"remove","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   */\nvoid set(Object element);\n","name":"set","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"LinkedList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n      Constructs an empty linked list.\n   */\npublic LinkedList() {\n    first = null;\n    last = null;\n}\n","name":"LinkedList","className":"LinkedList","variables":{"last":1,"first":1},"constants":{"null":2},"javaDoc":"Constructs an empty linked list","comments":" \n      Constructs an empty linked list.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"/**\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   */\npublic Object getFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    return first.data;\n}\n","name":"getFirst","className":"LinkedList","variables":{"first":1},"constants":{"null":1},"javaDoc":"Returns the first element in the linked list the first element in the linked list","comments":"\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"NullLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":14,"FieldAccessExpr":3,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Removes the first element in the linked list.\n      @return the removed element\n   */\npublic Object removeFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    if (// List is now empty\n    first == null) // List is now empty\n    {\n        last = null;\n    } else {\n        first.previous = null;\n    }\n    return element;\n}\n","name":"removeFirst","className":"LinkedList","variables":{"last":1,"first":3,"element":2},"constants":{"null":4},"javaDoc":"Removes the first element in the linked list the removed element","comments":"List is now empty List is now empty \n      Removes the first element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"FieldAccessExpr":4,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   */\npublic void addFirst(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    newNode.previous = null;\n    if (first == null) {\n        last = newNode;\n    } else {\n        first.previous = newNode;\n    }\n    first = newNode;\n}\n","name":"addFirst","className":"LinkedList","variables":{"last":1,"newNode":4,"first":3,"element":1},"constants":{"null":2},"javaDoc":"Adds an element to the front of the linked list element the element to add","comments":"\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"/**\n      Returns the last element in the linked list.\n      @return the last element in the linked list\n   */\npublic Object getLast() {\n    if (last == null) {\n        throw new NoSuchElementException();\n    }\n    return last.data;\n}\n","name":"getLast","className":"LinkedList","variables":{"last":1},"constants":{"null":1},"javaDoc":"Returns the last element in the linked list the last element in the linked list","comments":"\n      Returns the last element in the linked list.\n      @return the last element in the linked list\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"NullLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":14,"FieldAccessExpr":3,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Removes the last element in the linked list.\n      @return the removed element\n   */\npublic Object removeLast() {\n    if (last == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = last.data;\n    last = last.previous;\n    if (// List is now empty\n    last == null) // List is now empty\n    {\n        first = null;\n    } else {\n        last.next = null;\n    }\n    return element;\n}\n","name":"removeLast","className":"LinkedList","variables":{"last":3,"first":1,"element":2},"constants":{"null":4},"javaDoc":"Removes the last element in the linked list the removed element","comments":"List is now empty List is now empty \n      Removes the last element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"FieldAccessExpr":4,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Adds an element to the back of the linked list.\n      @param element the element to add\n   */\npublic void addLast(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = null;\n    newNode.previous = last;\n    if (last == null) {\n        first = newNode;\n    } else {\n        last.next = newNode;\n    }\n    last = newNode;\n}\n","name":"addLast","className":"LinkedList","variables":{"last":3,"newNode":4,"first":1,"element":1},"constants":{"null":2},"javaDoc":"Adds an element to the back of the linked list element the element to add","comments":"\n      Adds an element to the back of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"ListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   */\npublic ListIterator listIterator() {\n    return new LinkedListIterator();\n}\n","name":"listIterator","className":"LinkedList","variables":{},"constants":{},"javaDoc":"Returns an iterator for iterating through this list an iterator for iterating through this list","comments":"\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"LinkedListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BooleanLiteralExpr":2,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n         Constructs an iterator that points to the front\n         of the linked list.\n      */\npublic LinkedListIterator() {\n    position = null;\n    isAfterNext = false;\n    isAfterPrevious = false;\n}\n","name":"LinkedListIterator","className":"LinkedListIterator","variables":{"isAfterPrevious":1,"position":1,"isAfterNext":1},"constants":{"null":1,"false":2},"javaDoc":"Constructs an iterator that points to the front of the linked list","comments":"\n         Constructs an iterator that points to the front\n         of the linked list.\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"BooleanLiteralExpr":2,"BinaryExpr":1,"NameExpr":14,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":4},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n         Moves the iterator past the next element.\n         @return the traversed element\n      */\npublic Object next() {\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    isAfterNext = true;\n    isAfterPrevious = false;\n    if (position == null) {\n        position = first;\n    } else {\n        position = position.next;\n    }\n    return position.data;\n}\n","name":"next","className":"LinkedListIterator","variables":{"isAfterPrevious":1,"position":3,"first":1,"isAfterNext":1},"constants":{"null":1,"true":1,"false":1},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n         Moves the iterator past the next element.\n         @return the traversed element\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"BinaryExpr":3,"NameExpr":5,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      */\npublic boolean hasNext() {\n    if (position == null) {\n        return first != null;\n    } else {\n        return position.next != null;\n    }\n}\n","name":"hasNext","className":"LinkedListIterator","variables":{"position":1,"first":1},"constants":{"null":3},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasPrevious":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":2,"NameExpr":12,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n         Moves the iterator before the previous element.\n         @return the traversed element\n      */\npublic Object previous() {\n    if (!hasPrevious()) {\n        throw new NoSuchElementException();\n    }\n    isAfterNext = false;\n    isAfterPrevious = true;\n    Object result = position.data;\n    position = position.previous;\n    return result;\n}\n","name":"previous","className":"LinkedListIterator","variables":{"result":2,"isAfterPrevious":1,"position":1,"isAfterNext":1},"constants":{"false":1,"true":1},"javaDoc":"Moves the iterator before the previous element the traversed element","comments":"\n         Moves the iterator before the previous element.\n         @return the traversed element\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n         Tests if there is an element before the iterator position.\n         @return true if there is an element before the iterator position\n      */\npublic boolean hasPrevious() {\n    return position != null;\n}\n","name":"hasPrevious","className":"LinkedListIterator","variables":{"position":1},"constants":{"null":1},"javaDoc":"Tests if there is an element before the iterator position true if there is an element before the iterator position","comments":"\n         Tests if there is an element before the iterator position.\n         @return true if there is an element before the iterator position\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"addLast":1,"addFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":41,"FieldAccessExpr":7,"MethodCallExpr":2,"AssignExpr":10},"statements":{"IfStmt":2,"BlockStmt":3,"ExpressionStmt":13},"text":"/**\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      */\npublic void add(Object element) {\n    if (position == null) {\n        addFirst(element);\n        position = first;\n    } else if (position == last) {\n        addLast(element);\n        position = last;\n    } else {\n        Node newNode = new Node();\n        newNode.data = element;\n        newNode.next = position.next;\n        newNode.next.previous = newNode;\n        position.next = newNode;\n        newNode.previous = position;\n        position = newNode;\n    }\n    isAfterNext = false;\n    isAfterPrevious = false;\n}\n","name":"add","className":"LinkedListIterator","variables":{"last":2,"isAfterPrevious":1,"newNode":4,"position":6,"first":1,"element":1,"isAfterNext":1},"constants":{"null":1,"false":2},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeFirst":1,"lastPosition":1,"removeLast":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":33,"FieldAccessExpr":7,"MethodCallExpr":3,"AssignExpr":5},"statements":{"IfStmt":3,"BlockStmt":4,"ExpressionStmt":8},"text":"/**\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      */\npublic void remove() {\n    Node positionToRemove = lastPosition();\n    if (positionToRemove == first) {\n        removeFirst();\n    } else if (positionToRemove == last) {\n        removeLast();\n    } else {\n        positionToRemove.previous.next = positionToRemove.next;\n        positionToRemove.next.previous = positionToRemove.previous;\n    }\n    if (isAfterNext) {\n        position = position.previous;\n    }\n    isAfterNext = false;\n    isAfterPrevious = false;\n}\n","name":"remove","className":"LinkedListIterator","variables":{"last":1,"isAfterPrevious":1,"position":1,"positionToRemove":3,"first":1,"isAfterNext":2},"constants":{"false":2},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"lastPosition":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      */\npublic void set(Object element) {\n    Node positionToSet = lastPosition();\n    positionToSet.data = element;\n}\n","name":"set","className":"LinkedListIterator","variables":{"positionToSet":1,"element":1},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Node","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":8,"FieldAccessExpr":1},"statements":{"IfStmt":3,"BlockStmt":5,"ReturnStmt":3,"ThrowStmt":1},"text":"/**\n         Returns the last node traversed by this iterator, or\n         throws an IllegalStateException if there wasn't an immediately\n         preceding call to next or previous.\n         @return the last traversed node\n      */\nprivate Node lastPosition() {\n    if (isAfterNext) {\n        return position;\n    } else if (isAfterPrevious) {\n        if (position == null) {\n            return first;\n        } else {\n            return position.next;\n        }\n    } else {\n        throw new IllegalStateException();\n    }\n}\n","name":"lastPosition","className":"LinkedListIterator","variables":{"isAfterPrevious":1,"position":2,"first":1,"isAfterNext":1},"constants":{"null":1},"javaDoc":"Returns the last node traversed by this iterator or throws an IllegalStateException if there wasn't an immediately preceding call to next or previous the last traversed node","comments":"\n         Returns the last node traversed by this iterator, or\n         throws an IllegalStateException if there wasn't an immediately\n         preceding call to next or previous.\n         @return the last traversed node\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":17,"add":3,"addLast":19,"set":4,"previous":8,"removeFirst":2,"listIterator":4,"assertEquals":29,"check":27,"removeLast":2,"addFirst":2,"remove":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"ListIterator":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":7,"VariableDeclarationExpr":2,"NameExpr":349,"StringLiteralExpr":111,"MethodCallExpr":123,"AssignExpr":9},"statements":{"ExpressionStmt":101},"text":"public static void main(String[] args) {\n    LinkedList lst = new LinkedList();\n    check(\"\", lst, \"Constructing empty list\");\n    lst.addLast(\"A\");\n    check(\"A\", lst, \"Adding last to empty list\");\n    lst.addLast(\"B\");\n    check(\"AB\", lst, \"Adding last to non-empty list\");\n    lst = new LinkedList();\n    lst.addFirst(\"A\");\n    check(\"A\", lst, \"Adding first to empty list\");\n    lst.addFirst(\"B\");\n    check(\"BA\", lst, \"Adding first to non-empty list\");\n    assertEquals(\"B\", lst.removeFirst());\n    check(\"A\", lst, \"Removing first, yielding non-empty list\");\n    assertEquals(\"A\", lst.removeFirst());\n    check(\"\", lst, \"Removing first, yielding empty list\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    check(\"AB\", lst, \"\");\n    assertEquals(\"B\", lst.removeLast());\n    check(\"A\", lst, \"Removing last, yielding non-empty list\");\n    assertEquals(\"A\", lst.removeLast());\n    check(\"\", lst, \"Removing last, yielding empty list\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    check(\"ABC\", lst, \"\");\n    ListIterator iter = lst.listIterator();\n    assertEquals(\"A\", iter.next());\n    iter.set(\"D\");\n    check(\"DBC\", lst, \"Set element after next\");\n    assertEquals(\"D\", iter.previous());\n    iter.set(\"E\");\n    check(\"EBC\", lst, \"Set first element after previous\");\n    assertEquals(\"E\", iter.next());\n    assertEquals(\"B\", iter.next());\n    assertEquals(\"B\", iter.previous());\n    iter.set(\"F\");\n    check(\"EFC\", lst, \"Set second element after previous\");\n    assertEquals(\"F\", iter.next());\n    assertEquals(\"C\", iter.next());\n    assertEquals(\"C\", iter.previous());\n    iter.set(\"G\");\n    check(\"EFG\", lst, \"Set last element after previous\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    lst.addLast(\"D\");\n    lst.addLast(\"E\");\n    check(\"ABCDE\", lst, \"\");\n    iter = lst.listIterator();\n    assertEquals(\"A\", iter.next());\n    iter.remove();\n    check(\"BCDE\", lst, \"Remove first element after next\");\n    assertEquals(\"B\", iter.next());\n    assertEquals(\"C\", iter.next());\n    iter.remove();\n    check(\"BDE\", lst, \"Remove middle element after next\");\n    assertEquals(\"D\", iter.next());\n    assertEquals(\"E\", iter.next());\n    iter.remove();\n    check(\"BD\", lst, \"Remove last element after next\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    lst.addLast(\"D\");\n    lst.addLast(\"E\");\n    check(\"ABCDE\", lst, \"\");\n    iter = lst.listIterator();\n    assertEquals(\"A\", iter.next());\n    assertEquals(\"B\", iter.next());\n    assertEquals(\"C\", iter.next());\n    assertEquals(\"D\", iter.next());\n    assertEquals(\"E\", iter.next());\n    assertEquals(\"E\", iter.previous());\n    iter.remove();\n    check(\"ABCD\", lst, \"Remove last element after previous\");\n    assertEquals(\"D\", iter.previous());\n    assertEquals(\"C\", iter.previous());\n    iter.remove();\n    check(\"ABD\", lst, \"Remove middle element after previous\");\n    assertEquals(\"B\", iter.previous());\n    assertEquals(\"A\", iter.previous());\n    iter.remove();\n    check(\"BD\", lst, \"Remove first element after previous\");\n    lst = new LinkedList();\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    check(\"BC\", lst, \"\");\n    iter = lst.listIterator();\n    iter.add(\"A\");\n    check(\"ABC\", lst, \"Add first element\");\n    assertEquals(\"B\", iter.next());\n    iter.add(\"D\");\n    check(\"ABDC\", lst, \"Add middle element\");\n    assertEquals(\"C\", iter.next());\n    iter.add(\"E\");\n    check(\"ABDCE\", lst, \"Add last element\");\n}\n","name":"main","className":"LinkedListTest","variables":{"iter":42,"lst":36},"constants":{"\"\"":8,"\"D\"":8,"\"Add first element\"":1,"\"EBC\"":1,"\"EFG\"":1,"\"B\"":15,"\"Adding first to non-empty list\"":1,"\"Adding last to non-empty list\"":1,"\"ABCD\"":1,"\"Removing last, yielding non-empty list\"":1,"\"BC\"":1,"\"Adding last to empty list\"":1,"\"Set second element after previous\"":1,"\"Removing first, yielding non-empty list\"":1,"\"Constructing empty list\"":1,"\"Removing first, yielding empty list\"":1,"\"ABDC\"":1,"\"Remove last element after next\"":1,"\"ABD\"":1,"\"G\"":1,"\"Add middle element\"":1,"\"E\"":8,"\"BDE\"":1,"\"DBC\"":1,"\"Remove middle element after previous\"":1,"\"C\"":10,"\"ABCDE\"":2,"\"A\"":17,"\"Removing last, yielding empty list\"":1,"\"Adding first to empty list\"":1,"\"Set element after next\"":1,"\"Set last element after previous\"":1,"\"Remove last element after previous\"":1,"\"BD\"":2,"\"AB\"":2,"\"Set first element after previous\"":1,"\"BA\"":1,"\"Remove first element after next\"":1,"\"BCDE\"":1,"\"Remove middle element after next\"":1,"\"Remove first element after previous\"":1,"\"Add last element\"":1,"\"EFC\"":1,"\"F\"":2,"\"ABC\"":2,"\"ABDCE\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":101,"modifier":9}
{"paramTypes":["Object","Object"],"returnType":"void","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"BinaryExpr":7,"NameExpr":8,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1},"text":"/**\n      Checks whether two objects are equal and throws an exception if not.\n      @param expected the expected value\n      @param actual the actual value\n   */\npublic static void assertEquals(Object expected, Object actual) {\n    if (expected == null && actual != null || !expected.equals(actual)) {\n        throw new AssertionError(\"Expected \" + expected + \" but found \" + actual);\n    }\n}\n","name":"assertEquals","className":"LinkedListTest","variables":{"actual":2,"expected":3},"constants":{"null":2,"\"Expected \"":1,"\" but found \"":1},"javaDoc":"Checks whether two objects are equal and throws an exception if not expected the expected value actual the actual value","comments":"\n      Checks whether two objects are equal and throws an exception if not.\n      @param expected the expected value\n      @param actual the actual value\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String","LinkedList","String"],"returnType":"void","methodCalls":{"next":1,"previous":1,"getFirst":2,"length":2,"listIterator":1,"hasPrevious":2,"assertEquals":8,"hasNext":2,"getLast":2,"substring":4,"System.out.println":1},"annotations":[],"exceptions":["NoSuchElementException"],"concepts":[],"types":{"ListIterator":1,"int":3},"expressions":{"IntegerLiteralExpr":10,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":10,"BooleanLiteralExpr":4,"NameExpr":85,"StringLiteralExpr":4,"FieldAccessExpr":1,"UnaryExpr":2,"MethodCallExpr":26},"statements":{"IfStmt":2,"BlockStmt":9,"TryStmt":2,"ForStmt":2,"ThrowStmt":2,"ExpressionStmt":13},"text":"/**\n      Checks whether a linked list has the expected contents, and throws\n      an exception if not.\n      @param expected the letters that are expected in each node\n      @param actual the linked list\n      @param what a string explaining what has been tested. It is \n      included in the message that is displayed when the test passes.\n   */\npublic static void check(String expected, LinkedList actual, String what) {\n    int n = expected.length();\n    if (n > 0) {\n        // Check first and last reference       \n        assertEquals(expected.substring(0, 1), actual.getFirst());\n        assertEquals(expected.substring(n - 1), actual.getLast());\n        // Check next references\n        ListIterator iter = actual.listIterator();\n        for (int i = 0; i < n; i++) {\n            assertEquals(true, iter.hasNext());\n            assertEquals(expected.substring(i, i + 1), iter.next());\n        }\n        assertEquals(false, iter.hasNext());\n        // Check previous references\n        for (int i = n - 1; i >= 0; i--) {\n            assertEquals(true, iter.hasPrevious());\n            assertEquals(expected.substring(i, i + 1), iter.previous());\n        }\n        assertEquals(false, iter.hasPrevious());\n    } else {\n        // Check that first and last are null\n        try {\n            actual.getFirst();\n            throw new IllegalStateException(\"first not null\");\n        } catch (NoSuchElementException ex) {\n        }\n        try {\n            actual.getLast();\n            throw new IllegalStateException(\"last not null\");\n        } catch (NoSuchElementException ex) {\n        }\n    }\n    if (what.length() > 0) {\n        System.out.println(\"Passed \\\"\" + what + \"\\\".\");\n    }\n}\n","name":"check","className":"LinkedListTest","variables":{"actual":5,"ex":2,"what":2,"expected":5,"iter":7,"i":8,"n":5},"constants":{"0":5,"1":5,"\"Passed \\\"\"":1,"\"last not null\"":1,"\"\\\".\"":1,"true":2,"false":2,"\"first not null\"":1},"javaDoc":"Checks whether a linked list has the expected contents and throws an exception if not expected the letters that are expected in each node actual the linked list what a string explaining what has been tested It is included in the message that is displayed when the test passes","comments":"Check first and last reference Check next references Check previous references Check that first and last are null \n      Checks whether a linked list has the expected contents, and throws\n      an exception if not.\n      @param expected the letters that are expected in each node\n      @param actual the linked list\n      @param what a string explaining what has been tested. It is \n      included in the message that is displayed when the test passes.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":4,"add":2,"listIterator":2,"hasNext":1,"addFirst":4,"remove":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ListIterator":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":53,"StringLiteralExpr":7,"FieldAccessExpr":2,"MethodCallExpr":16,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    LinkedList staff = new LinkedList();\n    staff.addFirst(\"Tom\");\n    staff.addFirst(\"Romeo\");\n    staff.addFirst(\"Harry\");\n    staff.addFirst(\"Diana\");\n    // | in the comments indicates the iterator position\n    // |DHRT\n    ListIterator iterator = staff.listIterator();\n    // D|HRT\n    iterator.next();\n    // DH|RT\n    iterator.next();\n    // Add more elements after second element\n    // DHJ|RT\n    iterator.add(\"Juliet\");\n    // DHJN|RT\n    iterator.add(\"Nina\");\n    // DHJNR|T\n    iterator.next();\n    // Remove last traversed element \n    // DHJN|T\n    iterator.remove();\n    // Print all elements\n    iterator = staff.listIterator();\n    while (iterator.hasNext()) {\n        System.out.print(iterator.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"ListDemo","variables":{"iterator":10,"staff":7},"constants":{"\"Nina\"":1,"\"Tom\"":1,"\" \"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Romeo\"":1},"javaDoc":"","comments":"| in the comments indicates the iterator position Add more elements after second element Remove last traversed element Print all elements |DHRT D|HRT DH|RT DHJ|RT DHJN|RT DHJNR|T DHJN|T ","isEmpty":false,"hasInnerClass":false,"lineCount":19,"modifier":9}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Moves the iterator past the next element.\n      @return the traversed element\n   */\nObject next();\n","name":"next","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n      Moves the iterator past the next element.\n      @return the traversed element\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   */\nboolean hasNext();\n","name":"hasNext","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   */\nvoid add(Object element);\n","name":"add","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   */\nvoid remove();\n","name":"remove","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   */\nvoid set(Object element);\n","name":"set","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"LinkedList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Constructs an empty linked list.\n   */\npublic LinkedList() {\n    first = null;\n}\n","name":"LinkedList","className":"LinkedList","variables":{"first":1},"constants":{"null":1},"javaDoc":"Constructs an empty linked list","comments":" \n      Constructs an empty linked list.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"/**\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   */\npublic Object getFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    return first.data;\n}\n","name":"getFirst","className":"LinkedList","variables":{"first":1},"constants":{"null":1},"javaDoc":"Returns the first element in the linked list the first element in the linked list","comments":"\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Removes the first element in the linked list.\n      @return the removed element\n   */\npublic Object removeFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    return element;\n}\n","name":"removeFirst","className":"LinkedList","variables":{"first":2,"element":2},"constants":{"null":1},"javaDoc":"Removes the first element in the linked list the removed element","comments":"\n      Removes the first element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":10,"FieldAccessExpr":2,"AssignExpr":3},"statements":{"ExpressionStmt":4},"text":"/**\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   */\npublic void addFirst(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    first = newNode;\n}\n","name":"addFirst","className":"LinkedList","variables":{"newNode":2,"first":2,"element":1},"constants":{},"javaDoc":"Adds an element to the front of the linked list element the element to add","comments":"\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"ListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   */\npublic ListIterator listIterator() {\n    return new LinkedListIterator();\n}\n","name":"listIterator","className":"LinkedList","variables":{},"constants":{},"javaDoc":"Returns an iterator for iterating through this list an iterator for iterating through this list","comments":"\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"LinkedListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BooleanLiteralExpr":1,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n         Constructs an iterator that points to the front\n         of the linked list.\n      */\npublic LinkedListIterator() {\n    position = null;\n    previous = null;\n    isAfterNext = false;\n}\n","name":"LinkedListIterator","className":"LinkedListIterator","variables":{"previous":1,"position":1,"isAfterNext":1},"constants":{"null":2,"false":1},"javaDoc":"Constructs an iterator that points to the front of the linked list","comments":"\n         Constructs an iterator that points to the front\n         of the linked list.\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":15,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":4},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n         Moves the iterator past the next element.\n         @return the traversed element\n      */\npublic Object next() {\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    // Remember for remove\n    previous = position;\n    isAfterNext = true;\n    if (position == null) {\n        position = first;\n    } else {\n        position = position.next;\n    }\n    return position.data;\n}\n","name":"next","className":"LinkedListIterator","variables":{"previous":1,"position":4,"first":1,"isAfterNext":1},"constants":{"null":1,"true":1},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"Remember for remove \n         Moves the iterator past the next element.\n         @return the traversed element\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"BinaryExpr":3,"NameExpr":5,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      */\npublic boolean hasNext() {\n    if (position == null) {\n        return first != null;\n    } else {\n        return position.next != null;\n    }\n}\n","name":"hasNext","className":"LinkedListIterator","variables":{"position":1,"first":1},"constants":{"null":3},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"addFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":23,"FieldAccessExpr":4,"MethodCallExpr":1,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":8},"text":"/**\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      */\npublic void add(Object element) {\n    if (position == null) {\n        addFirst(element);\n        position = first;\n    } else {\n        Node newNode = new Node();\n        newNode.data = element;\n        newNode.next = position.next;\n        position.next = newNode;\n        position = newNode;\n    }\n    isAfterNext = false;\n}\n","name":"add","className":"LinkedListIterator","variables":{"newNode":3,"position":3,"first":1,"element":1,"isAfterNext":1},"constants":{"null":1,"false":1},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":14,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":4},"text":"/**\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      */\npublic void remove() {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    if (position == first) {\n        removeFirst();\n    } else {\n        previous.next = position.next;\n    }\n    position = previous;\n    isAfterNext = false;\n}\n","name":"remove","className":"LinkedListIterator","variables":{"previous":1,"position":2,"first":1,"isAfterNext":2},"constants":{"false":1},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      */\npublic void set(Object element) {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    position.data = element;\n}\n","name":"set","className":"LinkedListIterator","variables":{"isAfterNext":1,"element":1},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"HashSet","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a hash table.\n      @param bucketsLength the length of the buckets array\n   */\npublic HashSet(int bucketsLength) {\n    buckets = new Node[bucketsLength];\n    currentSize = 0;\n}\n","name":"HashSet","className":"HashSet","variables":{"buckets":1,"bucketsLength":1,"currentSize":1},"constants":{"0":1},"javaDoc":"Constructs a hash table bucketsLength the length of the buckets array","comments":"\n      Constructs a hash table.\n      @param bucketsLength the length of the buckets array\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"hashCode":1,"current.data.equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":24,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":3},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":3,"ReturnStmt":2,"ExpressionStmt":5},"text":"/**\n      Tests for set membership.\n      @param x an object\n      @return true if x is an element of this set\n   */\npublic boolean contains(Object x) {\n    int h = x.hashCode();\n    h = h % buckets.length;\n    if (h < 0) {\n        h = -h;\n    }\n    Node current = buckets[h];\n    while (current != null) {\n        if (current.data.equals(x)) {\n            return true;\n        }\n        current = current.next;\n    }\n    return false;\n}\n","name":"contains","className":"HashSet","variables":{"current":3,"buckets":1,"h":7,"x":1},"constants":{"0":1,"null":1,"true":1,"false":1},"javaDoc":"Tests for set membership x an object true if x is an element of this set","comments":"\n      Tests for set membership.\n      @param x an object\n      @return true if x is an element of this set\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"hashCode":1,"current.data.equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":2,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":37,"FieldAccessExpr":5,"UnaryExpr":2,"MethodCallExpr":2,"AssignExpr":6},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":3,"ReturnStmt":2,"ExpressionStmt":10},"text":"/**\n      Adds an element to this set.\n      @param x an object\n      @return true if x is a new object, false if x was\n      already in the set\n   */\npublic boolean add(Object x) {\n    int h = x.hashCode();\n    h = h % buckets.length;\n    if (h < 0) {\n        h = -h;\n    }\n    Node current = buckets[h];\n    while (current != null) {\n        if (current.data.equals(x)) {\n            return false;\n        }\n        // Already in the set\n        current = current.next;\n    }\n    Node newNode = new Node();\n    newNode.data = x;\n    newNode.next = buckets[h];\n    buckets[h] = newNode;\n    currentSize++;\n    return true;\n}\n","name":"add","className":"HashSet","variables":{"current":3,"buckets":3,"h":9,"x":2,"newNode":2,"currentSize":1},"constants":{"0":1,"null":1,"false":1,"true":1},"javaDoc":"Adds an element to this set x an object true if x is a new object false if x was already in the set","comments":"Already in the set \n      Adds an element to this set.\n      @param x an object\n      @return true if x is a new object, false if x was\n      already in the set\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":11,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"hashCode":1,"current.data.equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":2,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":4,"BooleanLiteralExpr":2,"NameExpr":39,"FieldAccessExpr":6,"UnaryExpr":2,"MethodCallExpr":2,"AssignExpr":6},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":5,"ReturnStmt":2,"ExpressionStmt":10},"text":"/**\n      Removes an object from this set.\n      @param x an object\n      @return true if x was removed from this set, false\n      if x was not an element of this set\n   */\npublic boolean remove(Object x) {\n    int h = x.hashCode();\n    h = h % buckets.length;\n    if (h < 0) {\n        h = -h;\n    }\n    Node current = buckets[h];\n    Node previous = null;\n    while (current != null) {\n        if (current.data.equals(x)) {\n            if (previous == null) {\n                buckets[h] = current.next;\n            } else {\n                previous.next = current.next;\n            }\n            currentSize--;\n            return true;\n        }\n        previous = current;\n        current = current.next;\n    }\n    return false;\n}\n","name":"remove","className":"HashSet","variables":{"current":4,"previous":3,"buckets":2,"h":8,"x":1,"currentSize":1},"constants":{"0":1,"null":3,"true":1,"false":1},"javaDoc":"Removes an object from this set x an object true if x was removed from this set false if x was not an element of this set","comments":"\n      Removes an object from this set.\n      @param x an object\n      @return true if x was removed from this set, false\n      if x was not an element of this set\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":1}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns an iterator that traverses the elements of this set.\n      @return a hash set iterator\n   */\npublic Iterator iterator() {\n    return new HashSetIterator();\n}\n","name":"iterator","className":"HashSet","variables":{},"constants":{},"javaDoc":"Returns an iterator that traverses the elements of this set a hash set iterator","comments":"\n      Returns an iterator that traverses the elements of this set.\n      @return a hash set iterator\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the number of elements in this set.\n      @return the number of elements\n   */\npublic int size() {\n    return currentSize;\n}\n","name":"size","className":"HashSet","variables":{"currentSize":1},"constants":{},"javaDoc":"Gets the number of elements in this set the number of elements","comments":"\n      Gets the number of elements in this set.\n      @return the number of elements\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"HashSetIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"NameExpr":2,"UnaryExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n         Constructs a hash set iterator that points to the\n         first element of the hash set.\n      */\npublic HashSetIterator() {\n    current = null;\n    bucketIndex = -1;\n}\n","name":"HashSetIterator","className":"HashSetIterator","variables":{"current":1,"bucketIndex":1},"constants":{"1":1,"null":1},"javaDoc":"Constructs a hash set iterator that points to the first element of the hash set","comments":"\n         Constructs a hash set iterator that points to the\n         first element of the hash set.\n      ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"NullLiteralExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":6,"BooleanLiteralExpr":3,"NameExpr":12,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3,"ForStmt":1},"text":"public boolean hasNext() {\n    if (current != null && current.next != null) {\n        return true;\n    }\n    for (int b = bucketIndex + 1; b < buckets.length; b++) {\n        if (buckets[b] != null) {\n            return true;\n        }\n    }\n    return false;\n}\n","name":"hasNext","className":"HashSetIterator","variables":{"current":1,"b":4,"buckets":1,"bucketIndex":1},"constants":{"1":1,"null":3,"true":2,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"ObjectCreationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":20,"FieldAccessExpr":4,"UnaryExpr":1,"AssignExpr":2},"statements":{"IfStmt":2,"BlockStmt":4,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":3,"DoStmt":1},"text":"public Object next() {\n    if (current != null && current.next != null) {\n        // Move to next element in bucket\n        current = current.next;\n    } else // Move to next bucket\n    {\n        do {\n            bucketIndex++;\n            if (bucketIndex == buckets.length) {\n                throw new NoSuchElementException();\n            }\n            current = buckets[bucketIndex];\n        } while (current == null);\n    }\n    return current.data;\n}\n","name":"next","className":"HashSetIterator","variables":{"current":4,"buckets":1,"bucketIndex":3},"constants":{"null":3},"javaDoc":"","comments":"Move to next element in bucket Move to next bucket ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ThrowStmt":1},"text":"public void remove() {\n    throw new UnsupportedOperationException();\n}\n","name":"remove","className":"HashSetIterator","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":12,"next":1,"iterator":1,"hasNext":1,"remove":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Iterator":1,"HashSet":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":56,"StringLiteralExpr":14,"FieldAccessExpr":1,"MethodCallExpr":18},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":17},"text":"public static void main(String[] args) {\n    HashSet names = new HashSet(101);\n    names.add(\"Harry\");\n    names.add(\"Sue\");\n    names.add(\"Nina\");\n    names.add(\"Susannah\");\n    names.add(\"Larry\");\n    names.add(\"Eve\");\n    names.add(\"Sarah\");\n    names.add(\"Adam\");\n    names.add(\"Tony\");\n    names.add(\"Katherine\");\n    names.add(\"Juliet\");\n    names.add(\"Romeo\");\n    names.remove(\"Romeo\");\n    names.remove(\"George\");\n    Iterator iter = names.iterator();\n    while (iter.hasNext()) {\n        System.out.println(iter.next());\n    }\n}\n","name":"main","className":"HashSetDemo","variables":{"names":16,"iter":3},"constants":{"\"Tony\"":1,"\"Sue\"":1,"\"Susannah\"":1,"\"Katherine\"":1,"\"George\"":1,"\"Larry\"":1,"\"Eve\"":1,"101":1,"\"Nina\"":1,"\"Adam\"":1,"\"Juliet\"":1,"\"Harry\"":1,"\"Romeo\"":2,"\"Sarah\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":17,"modifier":9}
{"paramTypes":[],"returnType":"LinkedListStack","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Constructs an empty stack.\n   */\npublic LinkedListStack() {\n    first = null;\n}\n","name":"LinkedListStack","className":"LinkedListStack","variables":{"first":1},"constants":{"null":1},"javaDoc":"Constructs an empty stack","comments":" \n      Constructs an empty stack.\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":10,"FieldAccessExpr":2,"AssignExpr":3},"statements":{"ExpressionStmt":4},"text":"/**\n      Adds an element to the top of the stack.\n      @param element the element to add\n   */\npublic void push(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    first = newNode;\n}\n","name":"push","className":"LinkedListStack","variables":{"newNode":2,"first":2,"element":1},"constants":{},"javaDoc":"Adds an element to the top of the stack element the element to add","comments":"\n      Adds an element to the top of the stack.\n      @param element the element to add\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Removes the element from the top of the stack.\n      @return the removed element\n   */\npublic Object pop() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    return element;\n}\n","name":"pop","className":"LinkedListStack","variables":{"first":2,"element":2},"constants":{"null":1},"javaDoc":"Removes the element from the top of the stack the removed element","comments":"\n      Removes the element from the top of the stack.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this stack is empty.\n      @return true if the stack is empty\n   */\npublic boolean empty() {\n    return first == null;\n}\n","name":"empty","className":"LinkedListStack","variables":{"first":1},"constants":{"null":1},"javaDoc":"Checks whether this stack is empty true if the stack is empty","comments":"\n      Checks whether this stack is empty.\n      @return true if the stack is empty\n   ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"push":3,"empty":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LinkedListStack":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    LinkedListStack s = new LinkedListStack();\n    s.push(\"Tom\");\n    s.push(\"Diana\");\n    s.push(\"Harry\");\n    while (!s.empty()) {\n        System.out.println(s.pop());\n    }\n}\n","name":"main","className":"StackDemo","variables":{"s":6},"constants":{"\"Tom\"":1,"\"Diana\"":1,"\"Harry\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":[],"returnType":"IntListVer1","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic IntListVer1() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"IntListVer1","className":"IntListVer1","variables":{"DEFAULT_CAP":1},"constants":{},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"IntListVer1","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic IntListVer1(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new int[initialCap];\n    iSize = 0;\n}\n","name":"IntListVer1","className":"IntListVer1","variables":{"iValues":1,"iSize":1,"initialCap":3},"constants":{"0":2,"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["boolean[][]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"String":1,"boolean[]":1},"expressions":{"VariableDeclarationExpr":3,"StringLiteralExpr":4,"NameExpr":12,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ForeachStmt":2,"ExpressionStmt":5},"text":"public static void show(boolean[][] grid) {\n    String s = \"\";\n    for (boolean[] row : grid) {\n        for (boolean val : row) if (val)\n            s += \"*\";\n        else\n            s += \".\";\n        s += \"\\n\";\n    }\n    System.out.println(s);\n}\n","name":"show","className":"Life","variables":{"val":2,"s":4,"grid":1,"row":2},"constants":{"\"\"":1,"\".\"":1,"\"*\"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"boolean[][]","methodCalls":{"random":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2,"boolean[][]":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"DoubleLiteralExpr":1,"ArrayAccessExpr":2,"BinaryExpr":3,"BooleanLiteralExpr":1,"NameExpr":11,"ArrayCreationExpr":1,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static boolean[][] gen() {\n    boolean[][] grid = new boolean[10][10];\n    for (int r = 0; r < 10; r++) for (int c = 0; c < 10; c++) if (Math.random() > 0.7)\n        grid[r][c] = true;\n    return grid;\n}\n","name":"gen","className":"Life","variables":{"r":4,"c":4,"grid":3,"Math":1},"constants":{"0":2,"true":1,"0.7":1,"10":4},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"gen":1,"nextLine":1,"show":3,"length":1,"nextGen":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"boolean[][]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":37,"FieldAccessExpr":3,"MethodCallExpr":10,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    boolean[][] world = gen();\n    show(world);\n    System.out.println();\n    world = nextGen(world);\n    show(world);\n    Scanner s = new Scanner(System.in);\n    while (s.nextLine().length() == 0) {\n        System.out.println();\n        world = nextGen(world);\n        show(world);\n    }\n}\n","name":"main","className":"Life","variables":{"world":3,"s":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["boolean[][]"],"returnType":"boolean[][]","methodCalls":{"numNeighbors":1,"occupiedNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3,"boolean[][]":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":32,"FieldAccessExpr":4,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"public static boolean[][] nextGen(boolean[][] world) {\n    boolean[][] newWorld = new boolean[world.length][world[0].length];\n    int num;\n    for (int r = 0; r < world.length; r++) {\n        for (int c = 0; c < world[0].length; c++) {\n            num = numNeighbors(world, r, c);\n            if (occupiedNext(num, world[r][c]))\n                newWorld[r][c] = true;\n        }\n    }\n    return newWorld;\n}\n","name":"nextGen","className":"Life","variables":{"r":5,"world":3,"c":5,"newWorld":3,"num":2},"constants":{"0":4,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int","boolean"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":6,"BooleanLiteralExpr":3,"NameExpr":5,"EnclosedExpr":1,"UnaryExpr":1},"statements":{"IfStmt":2,"ReturnStmt":3},"text":"public static boolean occupiedNext(int numNeighbors, boolean occupied) {\n    if (occupied && (numNeighbors == 2 || numNeighbors == 3))\n        return true;\n    else if (!occupied && numNeighbors == 3)\n        return true;\n    else\n        return false;\n}\n","name":"occupiedNext","className":"Life","variables":{"numNeighbors":3,"occupied":2},"constants":{"2":1,"3":2,"true":2,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["boolean[][]","int","int"],"returnType":"int","methodCalls":{"inbounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"ArrayAccessExpr":4,"BinaryExpr":7,"NameExpr":21,"ConditionalExpr":1,"UnaryExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":2},"text":"private static int numNeighbors(boolean[][] world, int row, int col) {\n    int num = world[row][col] ? -1 : 0;\n    for (int r = row - 1; r <= row + 1; r++) for (int c = col - 1; c <= col + 1; c++) if (inbounds(world, r, c) && world[r][c])\n        num++;\n    return num;\n}\n","name":"numNeighbors","className":"Life","variables":{"col":3,"r":4,"world":2,"c":4,"num":3,"row":3},"constants":{"0":1,"1":5},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["boolean[][]","int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"ArrayAccessExpr":1,"BinaryExpr":7,"NameExpr":10,"FieldAccessExpr":2},"statements":{"ReturnStmt":1},"text":"private static boolean inbounds(boolean[][] world, int r, int c) {\n    return r >= 0 && r < world.length && c >= 0 && c < world[0].length;\n}\n","name":"inbounds","className":"Life","variables":{"r":2,"c":2,"world":1},"constants":{"0":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"inBounds":1,"cellPicked":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"ArrayAccessExpr":6,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":23,"UnaryExpr":5,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":2,"ForStmt":2,"ExpressionStmt":2},"text":"public void cellPicked(int row, int col) {\n    if (inBounds(row, col) && !myShow[row][col]) {\n        myShow[row][col] = true;\n        if (myTruth[row][col] == 0) {\n            for (int r = -1; r <= 1; r++) for (int c = -1; c <= 1; c++) cellPicked(row + r, col + c);\n        }\n    }\n}\n","name":"cellPicked","className":"MineSweeper","variables":{"col":4,"r":4,"c":4,"myShow":2,"myTruth":1,"row":4},"constants":{"0":1,"1":4,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"ArrayAccessExpr":1,"BinaryExpr":7,"NameExpr":10,"FieldAccessExpr":2},"statements":{"ReturnStmt":1},"text":"public boolean inBounds(int row, int col) {\n    return 0 <= row && row < myTruth.length && 0 <= col && col < myTruth[0].length;\n}\n","name":"inBounds","className":"MineSweeper","variables":{"col":2,"myTruth":1,"row":2},"constants":{"0":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"nanoTime":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n\t start the stop watch.\n\t*/\npublic void start() {\n    startTime = System.nanoTime();\n}\n","name":"start","className":"Stopwatch","variables":{"startTime":1,"System":1},"constants":{},"javaDoc":"start the stop watch","comments":"\n\t start the stop watch.\n\t","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"nanoTime":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n\t stop the stop watch.\n\t*/\npublic void stop() {\n    stopTime = System.nanoTime();\n}\n","name":"stop","className":"Stopwatch","variables":{"stopTime":1,"System":1},"constants":{},"javaDoc":"stop the stop watch","comments":"\n\t stop the stop watch.\n\t","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":3,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n\telapsed time in seconds.\n\t@return the time recorded on the stopwatch in seconds\n\t*/\npublic double time() {\n    return (stopTime - startTime) / NANOS_PER_SEC;\n}\n","name":"time","className":"Stopwatch","variables":{"NANOS_PER_SEC":1,"stopTime":1,"startTime":1},"constants":{},"javaDoc":"elapsed time in seconds the time recorded on the stopwatch in seconds","comments":"\n\telapsed time in seconds.\n\t@return the time recorded on the stopwatch in seconds\n\t","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"time":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"elapsed time: \" + time() + \" seconds.\";\n}\n","name":"toString","className":"Stopwatch","variables":{},"constants":{"\" seconds.\"":1,"\"elapsed time: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n\telapsed time in nanoseconds.\n\t@return the time recorded on the stopwatch in nanoseconds\n\t*/\npublic long timeInNanoseconds() {\n    return (stopTime - startTime);\n}\n","name":"timeInNanoseconds","className":"Stopwatch","variables":{"stopTime":1,"startTime":1},"constants":{},"javaDoc":"elapsed time in nanoseconds the time recorded on the stopwatch in nanoseconds","comments":"\n\telapsed time in nanoseconds.\n\t@return the time recorded on the stopwatch in nanoseconds\n\t","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Directory"],"returnType":"int","methodCalls":{"getSize":1,"getSubs":1,"getFiles":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"File[]":1,"Directory[]":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":5,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":27,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"public int getSize(Directory dir) {\n    int total = 0;\n    //check files\n    File[] files = dir.getFiles();\n    for (int i = 0; i < files.length; i++) total += files[i].getSize();\n    //get sub directories and check them\n    Directory[] subs = dir.getSubs();\n    for (int i = 0; i < subs.length; i++) total += getSize(subs[i]);\n    return total;\n}\n","name":"getSize","className":"RecursionExampleDirectory","variables":{"total":4,"subs":2,"files":2,"i":8,"dir":2},"constants":{"0":3},"javaDoc":"","comments":"check files get sub directories and check them ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getSize":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"RecursionExampleDirectory":1,"Directory":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    RecursionExampleDirectory r = new RecursionExampleDirectory();\n    Directory d = new Directory();\n    System.out.println(r.getSize(d));\n}\n","name":"main","className":"RecursionExampleDirectory","variables":{"r":2,"d":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"fact":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":8,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"//pre: n >= 0\npublic static int fact(int n) {\n    int result = 0;\n    if (n == 0)\n        result = 1;\n    else\n        result = n * fact(n - 1);\n    return result;\n}\n","name":"fact","className":"RecursionExampleDirectory","variables":{"result":4,"n":3},"constants":{"0":2,"1":2},"javaDoc":"","comments":"pre: n >= 0","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"pow":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":9,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"//pre: exp >= 0\npublic static int pow(int base, int exp) {\n    int result = 0;\n    if (exp == 0)\n        result = 1;\n    else\n        result = base * pow(base, exp - 1);\n    return result;\n}\n","name":"pow","className":"RecursionExampleDirectory","variables":{"result":4,"exp":2,"base":1},"constants":{"0":2,"1":2},"javaDoc":"","comments":"pre: exp >= 0","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"fib":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"BinaryExpr":6,"NameExpr":11,"AssignExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"//slow fib\n//pre: n >= 1\npublic static int fib(int n) {\n    int result = 0;\n    if (n == 1 || n == 2)\n        result = 1;\n    else\n        result = fib(n - 1) + fib(n - 2);\n    return result;\n}\n","name":"fib","className":"RecursionExampleDirectory","variables":{"result":4,"n":4},"constants":{"0":1,"1":3,"2":2},"javaDoc":"","comments":"pre: n >= 1","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"int","methodCalls":{"minWasted":2,"min":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":32,"FieldAccessExpr":1,"AssignExpr":4,"MethodCallExpr":3},"statements":{"IfStmt":3,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":7},"text":"public static int minWasted(int[] items, int itemNum, int capLeft) {\n    int result = 0;\n    if (itemNum >= items.length)\n        result = capLeft;\n    else if (capLeft == 0)\n        result = 0;\n    else {\n        int minWithout = minWasted(items, itemNum + 1, capLeft);\n        if (capLeft <= items[itemNum]) {\n            int minWith = minWasted(items, itemNum + 1, capLeft - items[itemNum]);\n            result = Math.min(minWith, minWithout);\n        } else\n            result = minWithout;\n    }\n    return result;\n}\n","name":"minWasted","className":"RecursionExampleDirectory","variables":{"result":6,"minWithout":2,"itemNum":5,"minWith":1,"capLeft":4,"Math":1,"items":2},"constants":{"0":3,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"Directory","methodCalls":{"random":3},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":4},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":27,"UnaryExpr":2,"AssignExpr":4,"CastExpr":3,"FieldAccessExpr":2,"EnclosedExpr":3,"ArrayCreationExpr":2,"MethodCallExpr":3},"statements":{"ForStmt":2,"ExpressionStmt":6},"text":"public Directory() {\n    int numSubs = (int) (Math.random() * 3);\n    mySubs = new Directory[numSubs];\n    int numFiles = (int) (Math.random() * 10);\n    myFiles = new File[numFiles];\n    for (int i = 0; i < myFiles.length; i++) myFiles[i] = new File((int) (Math.random() * 1000));\n    for (int i = 0; i < mySubs.length; i++) mySubs[i] = new Directory();\n}\n","name":"Directory","className":"Directory","variables":{"numSubs":2,"myFiles":2,"numFiles":2,"i":8,"Math":3,"mySubs":2},"constants":{"0":2,"3":1,"1000":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"Directory[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Directory[] getSubs() {\n    return mySubs;\n}\n","name":"getSubs","className":"Directory","variables":{"mySubs":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"File[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public File[] getFiles() {\n    return myFiles;\n}\n","name":"getFiles","className":"Directory","variables":{"myFiles":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"File","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public File(int size) {\n    iMySize = size;\n}\n","name":"File","className":"File","variables":{"size":1,"iMySize":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getSize() {\n    return iMySize;\n}\n","name":"getSize","className":"File","variables":{"iMySize":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"stop":2,"getPrimes":1,"start":2,"printTest":5,"isPrime":4,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Stopwatch":1,"boolean[]":1,"int":3},"expressions":{"IntegerLiteralExpr":20,"ObjectCreationExpr":3,"VariableDeclarationExpr":6,"BinaryExpr":8,"NameExpr":73,"StringLiteralExpr":5,"FieldAccessExpr":6,"UnaryExpr":3,"MethodCallExpr":20},"statements":{"IfStmt":2,"BlockStmt":2,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":21},"text":"/**\n\t * @param args\n\t */\npublic static void main(String[] args) {\n    printTest(10, 4);\n    printTest(2, 2);\n    printTest(54161329, 4);\n    printTest(1882341361, 2);\n    printTest(36, 9);\n    System.out.println(isPrime(54161329) + \" expect false\");\n    System.out.println(isPrime(1882341361) + \" expect true\");\n    System.out.println(isPrime(2) + \" expect true\");\n    int numPrimes = 0;\n    Stopwatch s = new Stopwatch();\n    s.start();\n    for (int i = 2; i < 10000000; i++) {\n        if (isPrime(i)) {\n            numPrimes++;\n        }\n    }\n    s.stop();\n    System.out.println(numPrimes + \" \" + s);\n    s.start();\n    boolean[] primes = getPrimes(10000000);\n    int np = 0;\n    for (boolean b : primes) if (b)\n        np++;\n    s.stop();\n    System.out.println(np + \" \" + s);\n    System.out.println(new BigInteger(1024, 10, new Random()));\n}\n","name":"main","className":"PrimeEx","variables":{"primes":2,"np":3,"b":2,"s":7,"numPrimes":3,"i":3},"constants":{"54161329":2,"36":1,"1882341361":2,"\" \"":2,"\" expect true\"":2,"0":2,"2":5,"\" expect false\"":1,"4":2,"1024":1,"10000000":2,"9":1,"10":2},"javaDoc":"args","comments":"\n\t * @param args\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":21,"modifier":9}
{"paramTypes":["int"],"returnType":"boolean[]","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":1,"boolean[]":1,"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":5,"BooleanLiteralExpr":2,"NameExpr":27,"FieldAccessExpr":2,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":6},"text":"public static boolean[] getPrimes(int max) {\n    boolean[] result = new boolean[max + 1];\n    for (int i = 2; i < result.length; i++) result[i] = true;\n    final double LIMIT = Math.sqrt(max);\n    for (int i = 2; i <= LIMIT; i++) {\n        if (result[i]) {\n            // cross out all multiples;\n            int index = 2 * i;\n            while (index < result.length) {\n                result[index] = false;\n                index += i;\n            }\n        }\n    }\n    return result;\n}\n","name":"getPrimes","className":"PrimeEx","variables":{"result":5,"max":1,"i":10,"index":4,"LIMIT":2,"Math":1},"constants":{"1":1,"2":3,"true":1,"false":1},"javaDoc":"","comments":"cross out all multiples; ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"stop":1,"numFactors":1,"start":1,"time":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Stopwatch":1,"int":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":7,"NameExpr":37,"StringLiteralExpr":6,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"IfStmt":1,"ExpressionStmt":8},"text":"public static void printTest(int num, int expectedFactors) {\n    Stopwatch st = new Stopwatch();\n    st.start();\n    int actualFactors = numFactors(num);\n    st.stop();\n    System.out.println(\"Testing \" + num + \" expect \" + expectedFactors + \", \" + \"actual \" + actualFactors);\n    if (actualFactors == expectedFactors)\n        System.out.println(\"PASSED\");\n    else\n        System.out.println(\"FAILED\");\n    System.out.println(st.time());\n}\n","name":"printTest","className":"PrimeEx","variables":{"st":4,"num":1,"actualFactors":3,"expectedFactors":2},"constants":{"\"actual \"":1,"\"Testing \"":1,"\" expect \"":1,"\", \"":1,"\"FAILED\"":1,"\"PASSED\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["int"],"returnType":"boolean","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"boolean":1,"double":1,"int":1},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":3,"BinaryExpr":9,"BooleanLiteralExpr":1,"NameExpr":16,"StringLiteralExpr":1,"ConditionalExpr":1,"EnclosedExpr":1,"MethodCallExpr":1,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"// pre: num >= 2\npublic static boolean isPrime(int num) {\n    assert num >= 2 : \"failed precondition. num must be >= 2. num: \" + num;\n    final double LIMIT = Math.sqrt(num);\n    boolean isPrime = (num == 2) ? true : num % 2 != 0;\n    int div = 3;\n    while (div <= LIMIT && isPrime) {\n        isPrime = num % div != 0;\n        div += 2;\n    }\n    return isPrime;\n}\n","name":"isPrime","className":"PrimeEx","variables":{"div":4,"num":5,"LIMIT":2,"Math":1,"isPrime":4},"constants":{"0":2,"2":4,"3":1,"true":1,"\"failed precondition. num must be >= 2. num: \"":1},"javaDoc":"","comments":" pre: num >= 2","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":1,"int":2},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"BinaryExpr":7,"NameExpr":16,"StringLiteralExpr":1,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":2,"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"// pre: num >= 2\npublic static int numFactors(int num) {\n    assert num >= 2 : \"failed precondition. num must be >= 2. num: \" + num;\n    int result = 0;\n    final double SQRT = Math.sqrt(num);\n    for (int i = 1; i < SQRT; i++) {\n        if (num % i == 0) {\n            result += 2;\n        }\n    }\n    if (num % SQRT == 0)\n        result++;\n    return result;\n}\n","name":"numFactors","className":"PrimeEx","variables":{"result":4,"SQRT":3,"num":4,"i":4,"Math":1},"constants":{"0":3,"1":1,"2":2,"\"failed precondition. num must be >= 2. num: \"":1},"javaDoc":"","comments":" pre: num >= 2","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createFreqTableURL":1,"createTable":1,"sum":2,"System.out.println":8},"annotations":[],"exceptions":["FileNotFoundException","IOException"],"concepts":[],"types":{"int[]":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":18,"NameExpr":76,"StringLiteralExpr":14,"UnaryExpr":2,"AssignExpr":2,"ArrayInitializerExpr":1,"CastExpr":2,"FieldAccessExpr":11,"ArrayCreationExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":7,"TryStmt":1,"ForStmt":2,"ExpressionStmt":11},"text":"// program to create a frequency table.\n// Example of simple try catch blocks to deal with checked exceptions\npublic static void main(String[] args) {\n    int[] freqs = createFreqTableURL(\"http://www.utexas.edu/\");\n    if (freqs.length == 0)\n        System.out.println(\"No frequency table created due to problems when reading from file\");\n    else {\n        for (int i = 0; i < NUM_ASCII_CHAR; i++) {\n            System.out.println(\"charcater code: \" + i + \" ,character: \" + (char) i + \" ,frequency: \" + freqs[i]);\n        }\n        System.out.println(\"Total characters in file: \" + sum(freqs));\n    }\n    freqs = new int[] {};\n    try {\n        freqs = createTable(\"ciaFactBook2008.txt\");\n    } catch (FileNotFoundException e) {\n        System.out.println(\"File not found. Unable to create freq table\" + e);\n    } catch (IOException e) {\n        System.out.println(\"Problem while reading from file. Unable to create freq table\" + e);\n    }\n    if (freqs.length == 0)\n        System.out.println(\"No frequency table created due to problems when reading from file\");\n    else {\n        for (int i = 0; i < freqs.length; i++) {\n            System.out.println(\"charcater code: \" + i + \" ,character: \" + (char) i + \" ,frequency: \" + freqs[i]);\n        }\n        System.out.println(\"Total characters in file: \" + sum(freqs));\n    }\n}\n","name":"main","className":"FreqTableExampleOriginal","variables":{"NUM_ASCII_CHAR":1,"e":4,"freqs":5,"i":12},"constants":{"0":4,"\"Problem while reading from file. Unable to create freq table\"":1,"\" ,frequency: \"":2,"\"File not found. Unable to create freq table\"":1,"\"No frequency table created due to problems when reading from file\"":2,"\"ciaFactBook2008.txt\"":1,"\"http://www.utexas.edu/\"":1,"\"charcater code: \"":2,"\"Total characters in file: \"":2,"\" ,character: \"":2},"javaDoc":"","comments":" Example of simple try catch blocks to deal with checked exceptions","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":5,"StringLiteralExpr":2,"AssignExpr":1},"statements":{"BlockStmt":1,"AssertStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"// return sum of ints in list\n// list may not be null\nprivate static int sum(int[] list) {\n    assert list != null : \"Failed precondition, sum: parameter list\" + \" may not be null.\";\n    int total = 0;\n    for (int x : list) {\n        total += x;\n    }\n    return total;\n}\n","name":"sum","className":"FreqTableExampleOriginal","variables":{"total":3,"x":2,"list":2},"constants":{"0":1,"\" may not be null.\"":1,"null":1,"\"Failed precondition, sum: parameter list\"":1},"javaDoc":"","comments":" list may not be null","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":10}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"read":1,"ready":1,"openStream":1,"close":1,"System.out.println":3},"annotations":[],"exceptions":["MalformedURLException","IOException"],"concepts":[],"types":{"InputStreamReader":1,"int[]":1,"URL":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":8,"NameExpr":43,"StringLiteralExpr":5,"UnaryExpr":1,"AssignExpr":2,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":4,"ArrayCreationExpr":3,"MethodCallExpr":7},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":11},"text":"// pre: url != null\n// Connect to the URL specified by the String url.\n// Map characters to index in array.\n// All non ASCII character dumped into one element of array\n// If IOException occurs message printed and array of\n// length 0 returned.\npublic static int[] createFreqTableURL(String url) {\n    if (url == null)\n        throw new IllegalArgumentException(\"Violation of precondition. parameter url must not be null.\");\n    int[] freqs = new int[NUM_ASCII_CHAR];\n    try {\n        URL inputURL = new URL(url);\n        InputStreamReader in = new InputStreamReader(inputURL.openStream());\n        while (in.ready()) {\n            int c = in.read();\n            if (0 <= c && c < freqs.length)\n                freqs[c]++;\n            else\n                System.out.println(\"Non ASCII char: \" + c + \" \" + (char) c);\n        }\n        in.close();\n    } catch (MalformedURLException e) {\n        System.out.println(\"Bad URL.\");\n        freqs = new int[0];\n    } catch (IOException e) {\n        System.out.println(\"Unable to read from resource.\" + e);\n        freqs = new int[0];\n    }\n    return freqs;\n}\n","name":"createFreqTableURL","className":"FreqTableExampleOriginal","variables":{"c":6,"NUM_ASCII_CHAR":1,"in":4,"e":3,"freqs":5,"inputURL":2,"url":2},"constants":{"0":3,"\"Bad URL.\"":1,"\"Non ASCII char: \"":1,"null":1,"\" \"":1,"\"Violation of precondition. parameter url must not be null.\"":1,"\"Unable to read from resource.\"":1},"javaDoc":"","comments":" length 0 returned.","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"read":1,"ready":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["FileNotFoundException","IOException"],"concepts":[],"types":{"int[]":1,"FileReader":1,"File":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":26,"CastExpr":1,"FieldAccessExpr":2,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"// Connect to the file specified by the String fileName.\n// Assumes it is in same directory as compiled code.\n// Map characters to index in array.\npublic static int[] createTable(String fileName) throws FileNotFoundException, IOException {\n    int[] freqs = new int[NUM_ASCII_CHAR];\n    File f = new File(fileName);\n    FileReader r = new FileReader(f);\n    while (r.ready()) {\n        int ch = r.read();\n        //                freqs[INDEX_NON_ASCII]++;\n        if (0 <= ch && ch < freqs.length)\n            freqs[ch]++;\n        else\n            System.out.println((char) ch);\n    }\n    r.close();\n    return freqs;\n}\n","name":"createTable","className":"FreqTableExampleOriginal","variables":{"fileName":1,"r":4,"NUM_ASCII_CHAR":1,"ch":5,"f":2,"freqs":3},"constants":{"0":1},"javaDoc":"","comments":"if( 0 <= ch && ch <= NUM_ASCII_CHAR) freqs[ch]++; else freqs[INDEX_NON_ASCII]++;  Map characters to index in array.","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["int"],"returnType":"SortedIntList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public SortedIntList(int initialCap) {\n    //call IntList constructor\n    super(initialCap);\n}\n","name":"SortedIntList","className":"SortedIntList","variables":{"initialCap":1},"constants":{},"javaDoc":"","comments":"call IntList constructor ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"SortedIntList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public SortedIntList() {\n    super();\n}\n","name":"SortedIntList","className":"SortedIntList","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"size":1,"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":3,"NameExpr":12,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"//override add\npublic void add(int value) {\n    //search for location to insert value\n    int pos = 0;\n    while (pos < size() && value > get(pos)) {\n        pos++;\n    }\n    super.insert(pos, value);\n}\n","name":"add","className":"SortedIntList","variables":{"pos":3,"value":1},"constants":{"0":1},"javaDoc":"","comments":"search for location to insert value override add","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"size":1,"containsKey":1,"get":2,"hasNext":1,"keySet":1,"put":2,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"Map<String, Integer>":1,"String":2,"TreeMap":1,"File":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":3,"StringLiteralExpr":3,"NameExpr":50,"FieldAccessExpr":3,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ForeachStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    try {\n        File f = new File(\"ciaFactBook2008.txt\");\n        Scanner sc;\n        sc = new Scanner(f);\n        // sc.useDelimiter(\"[^a-zA-Z']+\");\n        Map<String, Integer> wordCount = new TreeMap<String, Integer>();\n        while (sc.hasNext()) {\n            String word = sc.next();\n            if (!wordCount.containsKey(word))\n                wordCount.put(word, 1);\n            else\n                wordCount.put(word, wordCount.get(word) + 1);\n        }\n        // show results\n        for (String word : wordCount.keySet()) System.out.println(word + \" \" + wordCount.get(word));\n        System.out.println(wordCount.size());\n    } catch (IOException e) {\n        System.out.println(\"Unable to read from file.\");\n    }\n}\n","name":"main","className":"SimpleWordCounter","variables":{"sc":4,"wordCount":8,"e":1,"f":2,"word":3},"constants":{"1":2,"\" \"":1,"\"Unable to read from file.\"":1,"\"ciaFactBook2008.txt\"":1},"javaDoc":"","comments":"sc useDelimiter(\"[^a-zA-Z']+\"); show results ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"printStackTrace":1,"openConnection":1,"hasNext":1,"getInputStream":1,"close":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Scanner":1,"URL":1,"URLConnection":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":30,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    try {\n        URL mySite = new URL(\"http://www.cs.utexas.edu/~scottm\");\n        URLConnection yc = mySite.openConnection();\n        Scanner in = new Scanner(new InputStreamReader(yc.getInputStream()));\n        int count = 0;\n        while (in.hasNext()) {\n            System.out.println(in.next());\n            count++;\n        }\n        System.out.println(\"Number of tokens: \" + count);\n        in.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"main","className":"URLExpSimple","variables":{"mySite":2,"in":4,"e":2,"count":3,"yc":2},"constants":{"0":1,"\"http://www.cs.utexas.edu/~scottm\"":1,"\"Number of tokens: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"DemoClass","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public DemoClass() {\n    // assign default value\n    x = 0;\n}\n","name":"DemoClass","className":"DemoClass","variables":{"x":1},"constants":{"0":1},"javaDoc":"","comments":"assign default value ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"DemoClass","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public DemoClass(int x) {\n    // use this.x to refer to the instance variable x\n    // use x to refer to a local variable x (more specifically,\n    // method parameter x)\n    this.x = x;\n}\n","name":"DemoClass","className":"DemoClass","variables":{"x":1},"constants":{},"javaDoc":"","comments":"use this x to refer to the instance variable x use x to refer to a local variable x (more specifically method parameter x) ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["DemoClass"],"returnType":"DemoClass","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"FieldAccessExpr":2,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public DemoClass(DemoClass otherDemo) {\n    // copy the value from the otherDemo\n    this.x = otherDemo.x;\n}\n","name":"DemoClass","className":"DemoClass","variables":{},"constants":{},"javaDoc":"","comments":"copy the value from the otherDemo ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"ReturnStmt":1},"text":"// static method (aka class method)\npublic static void s1() {\n    return;\n}\n","name":"s1","className":"DemoClass","variables":{},"constants":{},"javaDoc":"","comments":" static method (aka class method)","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"ReturnStmt":1},"text":"// instance method\npublic void i1() {\n    return;\n}\n","name":"i1","className":"DemoClass","variables":{},"constants":{},"javaDoc":"","comments":" instance method","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"s1":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"// static calling static OK\n// static calling instance is a compile-time error\npublic static void s2() {\n    //        i1();     // compile-time error\n    // DemoClass.s1\n    s1();\n    return;\n}\n","name":"s2","className":"DemoClass","variables":{},"constants":{},"javaDoc":"","comments":"i1(); // compile-time error DemoClass s1  static calling instance is a compile-time error","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"i1":1,"s1":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"// instance calling static OK\n// instance calling instance OK\npublic void i2() {\n    // DemoClass.s1();\n    s1();\n    // this.i1();\n    i1();\n    return;\n}\n","name":"i2","className":"DemoClass","variables":{},"constants":{},"javaDoc":"","comments":"DemoClass s1(); this i1();  instance calling instance OK","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"overload":8,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"DoubleLiteralExpr":2,"BooleanLiteralExpr":1,"NameExpr":21,"StringLiteralExpr":1,"CastExpr":2,"LongLiteralExpr":1,"FieldAccessExpr":1,"CharLiteralExpr":1,"MethodCallExpr":9},"statements":{"ExpressionStmt":9},"text":"// call various versions of overload() based on their \n// list of parameters (aka function signatures)\npublic void overloadTester() {\n    System.out.println(\"overloadTester:\\n\");\n    overload((byte) 1);\n    overload((short) 1);\n    overload(1);\n    overload(1L);\n    overload(1.0f);\n    overload(1.0);\n    overload('1');\n    overload(true);\n}\n","name":"overloadTester","className":"DemoClass","variables":{},"constants":{"1":3,"1.0":1,"\"overloadTester:\\n\"":1,"1.0f":1,"true":1,"1L":1,"'1'":1},"javaDoc":"","comments":" list of parameters (aka function signatures)","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":1}
{"paramTypes":["byte"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(byte b) {\n    System.out.println(\"byte\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"byte\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["short"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(short s) {\n    System.out.println(\"short\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"short\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(int i) {\n    System.out.println(\"int\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"int\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["long"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(long l) {\n    System.out.println(\"long\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"long\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(float f) {\n    System.out.println(\"float\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"float\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(double d) {\n    System.out.println(\"double\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"double\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["char"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(char c) {\n    System.out.println(\"char\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"char\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(boolean b) {\n    System.out.println(\"boolean\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"boolean\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"overloadTester":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"DemoClass":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    DemoClass dc = new DemoClass();\n    dc.overloadTester();\n}\n","name":"main","className":"DemoClass","variables":{"dc":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toBinaryString":1,"toBinary":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":27,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":2,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    for (int i = -5; i < 33; i++) {\n        System.out.println(i + \": \" + toBinary(i));\n        System.out.println(i);\n        //always another way\n        System.out.println(i + \": \" + Integer.toBinaryString(i));\n    }\n}\n","name":"main","className":"BinaryConverter","variables":{"Integer":1,"i":5},"constants":{"33":1,"5":1,"\": \"":2},"javaDoc":"","comments":"always another way ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["int"],"returnType":"String","methodCalls":{"abs":1,"all0sAnd1s":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"String":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":2,"BinaryExpr":10,"NameExpr":24,"StringLiteralExpr":3,"EnclosedExpr":1,"AssignExpr":5,"MethodCallExpr":2},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":1,"AssertStmt":2,"ReturnStmt":1,"ExpressionStmt":7},"text":"/*\n     * pre: none\n     * post: returns a String with base10Num in base 2\n     */\npublic static String toBinary(int base10Num) {\n    boolean isNeg = base10Num < 0;\n    base10Num = Math.abs(base10Num);\n    String result = \"\";\n    while (base10Num > 1) {\n        result = (base10Num % 2) + result;\n        base10Num /= 2;\n    }\n    assert base10Num == 0 || base10Num == 1 : \"value is not <= 1: \" + base10Num;\n    result = base10Num + result;\n    assert all0sAnd1s(result);\n    if (isNeg)\n        result = \"-\" + result;\n    return result;\n}\n","name":"toBinary","className":"BinaryConverter","variables":{"result":8,"base10Num":9,"isNeg":2,"Math":1},"constants":{"0":2,"\"\"":1,"1":2,"2":2,"\"-\"":1,"\"value is not <= 1: \"":1},"javaDoc":"","comments":"\n     * pre: none\n     * post: returns a String with base10Num in base 2\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"length":1,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"char":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":16,"StringLiteralExpr":1,"CharLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"/*\n     * pre: cal != null\n     * post: return true if val consists only of characters 1 and 0, false otherwise\n     */\npublic static boolean all0sAnd1s(String val) {\n    assert val != null : \"Failed precondition all0sAnd1s. parameter cannot be null\";\n    boolean all = true;\n    int i = 0;\n    char c;\n    while (all && i < val.length()) {\n        c = val.charAt(i);\n        all = c == '0' || c == '1';\n        i++;\n    }\n    return all;\n}\n","name":"all0sAnd1s","className":"BinaryConverter","variables":{"val":3,"all":4,"c":4,"i":3},"constants":{"0":1,"null":1,"\"Failed precondition all0sAnd1s. parameter cannot be null\"":1,"true":1,"'1'":1,"'0'":1},"javaDoc":"","comments":"\n     * pre: cal != null\n     * post: return true if val consists only of characters 1 and 0, false otherwise\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"factorial":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    final int NUM_FACTS = 100;\n    for (int i = 0; i < NUM_FACTS; i++) System.out.println(i + \"! is \" + factorial(i));\n}\n","name":"main","className":"Factorial","variables":{"i":4,"NUM_FACTS":2},"constants":{"0":1,"100":1,"\"! is \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":6,"UnaryExpr":1,"AssignExpr":1},"statements":{"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static int factorial(int n) {\n    int result = 1;\n    for (int i = 2; i <= n; i++) result *= i;\n    return result;\n}\n","name":"factorial","className":"Factorial","variables":{"result":3,"i":4,"n":1},"constants":{"1":1,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"bubblesort":4,"showList":4,"findAndPrintPairs":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":34,"VariableDeclarationExpr":1,"ArrayInitializerExpr":4,"NameExpr":30,"ArrayCreationExpr":3,"UnaryExpr":2,"MethodCallExpr":9,"AssignExpr":3},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    int[] list = { 1, 2, 3, 4, 1, 2, 3 };\n    findAndPrintPairs(list, 5);\n    bubblesort(list);\n    showList(list);\n    list = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };\n    bubblesort(list);\n    showList(list);\n    list = new int[] { 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2 };\n    bubblesort(list);\n    showList(list);\n    list = new int[] { 1 };\n    bubblesort(list);\n    showList(list);\n}\n","name":"main","className":"ArrayExamples","variables":{"list":4},"constants":{"11":2,"0":1,"1":6,"2":5,"3":4,"4":3,"5":3,"6":2,"7":2,"8":2,"9":2,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"// pre: list != null, list.length > 0\n// post: return index of minimum element of array\npublic static int findMin(int[] list) {\n    assert list != null && list.length > 0 : \"failed precondition\";\n    int indexOfMin = 0;\n    for (int i = 1; i < list.length; i++) {\n        if (list[i] < list[indexOfMin]) {\n            indexOfMin = i;\n        }\n    }\n    return indexOfMin;\n}\n","name":"findMin","className":"ArrayExamples","variables":{"indexOfMin":4,"i":5,"list":3},"constants":{"0":2,"1":1,"null":1,"\"failed precondition\"":1},"javaDoc":"","comments":" post: return index of minimum element of array","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"void","methodCalls":{"min":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":2},"statements":{"BlockStmt":1,"AssertStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/*\n\t *pre: list != null, newSize >= 0\n\t *post: nothing. the method does not succeed it resizing the\n\t * argument\n\t */\npublic static void badResize(int[] list, int newSize) {\n    assert list != null && newSize >= 0 : \"failed precondition\";\n    int[] temp = new int[newSize];\n    int limit = Math.min(list.length, newSize);\n    for (int i = 0; i < limit; i++) {\n        temp[i] = list[i];\n    }\n    // uh oh!! Changing pointer, not pointee. This breaks the\n    // relationship between the parameter and argument\n    list = temp;\n}\n","name":"badResize","className":"ArrayExamples","variables":{"temp":3,"limit":2,"i":5,"newSize":2,"list":3,"Math":1},"constants":{"0":2,"null":1,"\"failed precondition\"":1},"javaDoc":"","comments":"uh oh!! Changing pointer not pointee This breaks the relationship between the parameter and argument \n\t *pre: list != null, newSize >= 0\n\t *post: nothing. the method does not succeed it resizing the\n\t * argument\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int[]","methodCalls":{"min":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/*\n\t *pre: list != null, newSize >= 0\n\t *post: returns an array of size newSize. Elements from 0 to newSize - 1\n\t *\twill be copied into the new array\n\t */\npublic static int[] goodResize(int[] list, int newSize) {\n    assert list != null && newSize >= 0 : \"failed precondition\";\n    int[] result = new int[newSize];\n    int limit = Math.min(list.length, newSize);\n    for (int i = 0; i < limit; i++) {\n        result[i] = list[i];\n    }\n    return result;\n}\n","name":"goodResize","className":"ArrayExamples","variables":{"result":3,"limit":2,"i":5,"newSize":2,"list":2,"Math":1},"constants":{"0":2,"null":1,"\"failed precondition\"":1},"javaDoc":"","comments":"\n\t *pre: list != null, newSize >= 0\n\t *post: returns an array of size newSize. Elements from 0 to newSize - 1\n\t *\twill be copied into the new array\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":15,"NameExpr":29,"StringLiteralExpr":6,"FieldAccessExpr":3,"UnaryExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"AssertStmt":1,"ForStmt":2,"ExpressionStmt":1},"text":"/*\n\t *pre: list != null\n\t *post: prints out the indices and values of all pairs of numbers\n\t *in list such that list[a] + list[b] = target\n\t */\npublic static void findAndPrintPairs(int[] list, int target) {\n    assert list != null : \"failed precondition\";\n    for (int i = 0; i < list.length; i++) {\n        for (int j = i + 1; j < list.length; j++) {\n            if (list[i] + list[j] == target) {\n                System.out.println(\"The two elements at indices \" + i + \" and \" + j + \" are \" + list[i] + \" and \" + list[j] + \" add up to \" + target);\n            }\n        }\n    }\n}\n","name":"findAndPrintPairs","className":"ArrayExamples","variables":{"i":7,"j":6,"list":5,"target":2},"constants":{"0":1,"\" add up to \"":1,"1":1,"\"The two elements at indices \"":1,"\" and \"":2,"\" are \"":1,"null":1,"\"failed precondition\"":1},"javaDoc":"","comments":"\n\t *pre: list != null\n\t *post: prints out the indices and values of all pairs of numbers\n\t *in list such that list[a] + list[b] = target\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"isAscending":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":3},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":16,"NameExpr":38,"StringLiteralExpr":3,"UnaryExpr":2,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":3,"FieldAccessExpr":3,"EnclosedExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"AssertStmt":3,"ForStmt":2,"ExpressionStmt":7},"text":"/*\n\t *pre: list != null;\n\t *post: sort the elements of list so that they are in ascending order\n\t */\npublic static void bubblesort(int[] list) {\n    assert list != null : \"failed precondition\";\n    int temp;\n    boolean changed = true;\n    for (int i = 0; i < list.length && changed; i++) {\n        changed = false;\n        for (int j = 0; j < list.length - i - 1; j++) {\n            assert (j > 0) && (j + 1 < list.length) : \"loop counter j \" + j + \"is out of bounds.\";\n            if (list[j] > list[j + 1]) {\n                changed = true;\n                temp = list[j + 1];\n                list[j + 1] = list[j];\n                list[j] = temp;\n            }\n        }\n    }\n    assert isAscending(list);\n}\n","name":"bubblesort","className":"ArrayExamples","variables":{"temp":3,"i":4,"j":12,"list":7,"changed":4},"constants":{"0":3,"1":5,"null":1,"\"is out of bounds.\"":1,"true":2,"false":1,"\"failed precondition\"":1,"\"loop counter j \"":1},"javaDoc":"","comments":"\n\t *pre: list != null;\n\t *post: sort the elements of list so that they are in ascending order\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public static void showList(int[] list) {\n    for (int i = 0; i < list.length; i++) System.out.print(list[i] + \" \");\n    System.out.println();\n}\n","name":"showList","className":"ArrayExamples","variables":{"i":4,"list":1},"constants":{"0":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["int[]"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":7,"NameExpr":17,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/* \tpre: list != null\n\t\tpost: return true if list is sorted in ascedning order, false otherwise\n\t*/\npublic static boolean isAscending(int[] list) {\n    boolean ascending = true;\n    int index = 1;\n    while (ascending && index < list.length) {\n        assert index >= 0 && index < list.length;\n        ascending = (list[index - 1] <= list[index]);\n        index++;\n    }\n    return ascending;\n}\n","name":"isAscending","className":"ArrayExamples","variables":{"index":7,"ascending":4,"list":2},"constants":{"0":1,"1":2,"true":1},"javaDoc":"","comments":" \tpre: list != null\n\t\tpost: return true if list is sorted in ascedning order, false otherwise\n\t","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addOne":1,"printList":3,"addOneError":1,"sumListEnhanced":1,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"BinaryExpr":1,"NameExpr":49,"StringLiteralExpr":6,"FieldAccessExpr":6,"MethodCallExpr":12},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    int[] list = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int sum = sumListEnhanced(list);\n    System.out.println(\"Sum of elements in list: \" + sum);\n    System.out.println(\"Original List\");\n    printList(list);\n    System.out.println(\"Calling addOne\");\n    addOne(list);\n    System.out.println(\"List after call to addOne\");\n    printList(list);\n    System.out.println(\"Calling addOneError\");\n    addOneError(list);\n    System.out.println(\"List after call to addOneError. Note elements of list did not change.\");\n    printList(list);\n}\n","name":"main","className":"EnhancedFor","variables":{"sum":2,"list":1},"constants":{"\"Sum of elements in list: \"":1,"\"Calling addOneError\"":1,"1":1,"2":1,"3":1,"\"Original List\"":1,"\"List after call to addOneError. Note elements of list did not change.\"":1,"4":1,"5":1,"\"List after call to addOne\"":1,"6":1,"7":1,"8":1,"9":1,"10":1,"\"Calling addOne\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":13,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"// pre: list != null\n// post: return sum of elements\n// uses enhanced for loop\npublic static int sumListEnhanced(int[] list) {\n    int total = 0;\n    for (int val : list) {\n        total += val;\n    }\n    return total;\n}\n","name":"sumListEnhanced","className":"EnhancedFor","variables":{"val":2,"total":3,"list":1},"constants":{"0":1},"javaDoc":"","comments":" uses enhanced for loop","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":16,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"// pre: list != null\n// post: return sum of elements\n// use traditional for loop\npublic static int sumListOld(int[] list) {\n    int total = 0;\n    for (int i = 0; i < list.length; i++) {\n        total += list[i];\n        System.out.println(list[i]);\n    }\n    return total;\n}\n","name":"sumListOld","className":"EnhancedFor","variables":{"total":3,"i":5,"list":2},"constants":{"0":2},"javaDoc":"","comments":" use traditional for loop","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":1},"text":"// pre: list != null\n// post: none.\n// The code appears to add one to every element in the list, but does not\npublic static void addOneError(int[] list) {\n    for (int val : list) {\n        val = val + 1;\n    }\n}\n","name":"addOneError","className":"EnhancedFor","variables":{"val":3,"list":1},"constants":{"1":1},"javaDoc":"","comments":" The code appears to add one to every element in the list, but does not","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":7,"FieldAccessExpr":1,"UnaryExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"// pre: list != null\n// post: adds one to every element of list\npublic static void addOne(int[] list) {\n    for (int i = 0; i < list.length; i++) {\n        list[i]++;\n    }\n}\n","name":"addOne","className":"EnhancedFor","variables":{"i":4,"list":1},"constants":{"0":1},"javaDoc":"","comments":" post: adds one to every element of list","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":18,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"public static void printList(int[] list) {\n    System.out.println(\"index, value\");\n    for (int i = 0; i < list.length; i++) {\n        System.out.println(i + \", \" + list[i]);\n    }\n}\n","name":"printList","className":"EnhancedFor","variables":{"i":5,"list":1},"constants":{"0":1,"\", \"":1,"\"index, value\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":[],"returnType":"UnsortedHashSet","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"CastExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public UnsortedHashSet() {\n    con = (LinkedList<E>[]) (new LinkedList[10]);\n}\n","name":"UnsortedHashSet","className":"UnsortedHashSet","variables":{"con":1},"constants":{"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{"abs":1,"hashCode":1,"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"DoubleLiteralExpr":1,"ArrayAccessExpr":4,"BinaryExpr":6,"NameExpr":34,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":3,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"public boolean add(E obj) {\n    int oldSize = size;\n    int index = Math.abs(obj.hashCode()) % con.length;\n    if (con[index] == null)\n        con[index] = new LinkedList<E>();\n    if (!con[index].contains(obj)) {\n        con[index].add(obj);\n        size++;\n    }\n    if (1.0 * size / con.length > LOAD_FACTOR_LIMIT)\n        resize();\n    return oldSize != size;\n}\n","name":"add","className":"UnsortedHashSet","variables":{"con":4,"size":4,"obj":1,"index":5,"Math":1,"oldSize":2,"LOAD_FACTOR_LIMIT":1},"constants":{"1.0":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"UnsortedHashSet<E>":1,"E":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":23,"UnaryExpr":1,"AssignExpr":2,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"private void resize() {\n    UnsortedHashSet<E> temp = new UnsortedHashSet<E>();\n    temp.con = (LinkedList<E>[]) (new LinkedList[con.length * 2 + 1]);\n    for (int i = 0; i < con.length; i++) {\n        if (con[i] != null)\n            for (E e : con[i]) temp.add(e);\n    }\n    con = temp.con;\n}\n","name":"resize","className":"UnsortedHashSet","variables":{"temp":2,"con":3,"e":1,"i":5},"constants":{"0":1,"1":1,"2":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int size() {\n    return size;\n}\n","name":"size","className":"UnsortedHashSet","variables":{"size":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Add an item to the end of this list.\n\t * <br>pre: none\n\t * <br>post: size() = old size() + 1, get(size() - 1) = item\n\t * @param item the data to be added to the end of this list\n\t */\nvoid add(E item);\n","name":"add","className":"IList","variables":{},"constants":{},"javaDoc":"Add an item to the end of this list <br>pre: none <br>post: size() = old size() + 1 get(size() - 1) = item item the data to be added to the end of this list","comments":"\n\t * Add an item to the end of this list.\n\t * <br>pre: none\n\t * <br>post: size() = old size() + 1, get(size() - 1) = item\n\t * @param item the data to be added to the end of this list\n\t ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["int","E"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Insert an item at a specified position in the list.\n\t * <br>pre: 0 <= pos <= size()\n\t * <br>post: size() = old size() + 1, get(pos) = item, all elements in\n\t * the list with a positon >= pos have a position = old position + 1\n\t * @param pos the position to insert the data at in the list\n\t * @param item the data to add to the list\n\t*/\nvoid insert(int pos, E item);\n","name":"insert","className":"IList","variables":{},"constants":{},"javaDoc":"Insert an item at a specified position in the list <br>pre: 0 <= pos <= size() <br>post: size() = old size() + 1 get(pos) = item all elements in the list with a positon >= pos have a position = old position + 1 pos the position to insert the data at in the list item the data to add to the list","comments":"\n\t * Insert an item at a specified position in the list.\n\t * <br>pre: 0 <= pos <= size()\n\t * <br>post: size() = old size() + 1, get(pos) = item, all elements in\n\t * the list with a positon >= pos have a position = old position + 1\n\t * @param pos the position to insert the data at in the list\n\t * @param item the data to add to the list\n\t","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["int","E"],"returnType":"E","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Change the data at the specified position in the list.\n\t * the old data at that position is returned.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: get(pos) = item, return the\n\t * old get(pos)\n     * @param pos the position in the list to overwrite\t \n\t * @param item the new item that will overwrite the old item\n\t * @return the old data at the specified position\n\t */\nE set(int pos, E item);\n","name":"set","className":"IList","variables":{},"constants":{},"javaDoc":"Change the data at the specified position in the list the old data at that position is returned <br>pre: 0 <= pos < size() <br>post: get(pos) = item return the old get(pos) pos the position in the list to overwrite item the new item that will overwrite the old item the old data at the specified position","comments":"\n\t * Change the data at the specified position in the list.\n\t * the old data at that position is returned.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: get(pos) = item, return the\n\t * old get(pos)\n     * @param pos the position in the list to overwrite\t \n\t * @param item the new item that will overwrite the old item\n\t * @return the old data at the specified position\n\t ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["int"],"returnType":"E","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Get an element from the list.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the item at pos\n\t * @param pos specifies which element to get\n\t * @return the element at the specified position in the list\n\t */\nE get(int pos);\n","name":"get","className":"IList","variables":{},"constants":{},"javaDoc":"Get an element from the list <br>pre: 0 <= pos < size() <br>post: return the item at pos pos specifies which element to get the element at the specified position in the list","comments":"\n\t * Get an element from the list.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the item at pos\n\t * @param pos specifies which element to get\n\t * @return the element at the specified position in the list\n\t ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["int"],"returnType":"E","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Remove an element in the list based on position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: size() = old size() - 1, all elements of\n\t * list with a positon > pos have a position = old position - 1\n\t * @param pos the position of the element to remove from the list\n\t * @return the data at position pos\n\t */\nE remove(int pos);\n","name":"remove","className":"IList","variables":{},"constants":{},"javaDoc":"Remove an element in the list based on position <br>pre: 0 <= pos < size() <br>post: size() = old size() - 1 all elements of list with a positon > pos have a position = old position - 1 pos the position of the element to remove from the list the data at position pos","comments":"\n\t * Remove an element in the list based on position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: size() = old size() - 1, all elements of\n\t * list with a positon > pos have a position = old position - 1\n\t * @param pos the position of the element to remove from the list\n\t * @return the data at position pos\n\t ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Remove the first occurrence of obj in this list.\n\t * Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t * <br>pre: none\n\t * <br>post: if obj is in this list the first occurence has been removed and size() = old size() - 1. \n\t * If obj is not present the list is not altered in any way.\n\t * @param obj The item to remove from this list.\n\t * @return Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t */\nboolean remove(E obj);\n","name":"remove","className":"IList","variables":{},"constants":{},"javaDoc":"Remove the first occurrence of obj in this list Return <tt>true</tt> if this list changed as a result of this call <tt>false</tt> otherwise <br>pre: none <br>post: if obj is in this list the first occurence has been removed and size() = old size() - 1 If obj is not present the list is not altered in any way obj The item to remove from this list Return <tt>true</tt> if this list changed as a result of this call <tt>false</tt> otherwise","comments":"\n\t * Remove the first occurrence of obj in this list.\n\t * Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t * <br>pre: none\n\t * <br>post: if obj is in this list the first occurence has been removed and size() = old size() - 1. \n\t * If obj is not present the list is not altered in any way.\n\t * @param obj The item to remove from this list.\n\t * @return Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["int","int"],"returnType":"IList<E>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Return a sublist of elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n\t * This list is not changed as a result of this call.\n\t * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n\t * <br>post: return a list whose size is stop - start and contains the elements at positions start through stop - 1 in this list.\n\t * @param start index of the first element of the sublist.\n\t * @param stop stop - 1 is the index of the last element of the sublist.\n\t * @return a list with <tt>stop - start</tt> elements, The elements are from positions <tt>start</tt> inclusive to\n\t * <tt>stop</tt> exclusive in this list.\n\t */\nIList<E> getSubList(int start, int stop);\n","name":"getSubList","className":"IList","variables":{},"constants":{},"javaDoc":"Return a sublist of elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive This list is not changed as a result of this call <br>pre: <tt>0 <= start < size() start <= stop <= size()</tt> <br>post: return a list whose size is stop - start and contains the elements at positions start through stop - 1 in this list start index of the first element of the sublist stop stop - 1 is the index of the last element of the sublist a list with <tt>stop - start</tt> elements The elements are from positions <tt>start</tt> inclusive to <tt>stop</tt> exclusive in this list","comments":"\n\t * Return a sublist of elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n\t * This list is not changed as a result of this call.\n\t * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n\t * <br>post: return a list whose size is stop - start and contains the elements at positions start through stop - 1 in this list.\n\t * @param start index of the first element of the sublist.\n\t * @param stop stop - 1 is the index of the last element of the sublist.\n\t * @return a list with <tt>stop - start</tt> elements, The elements are from positions <tt>start</tt> inclusive to\n\t * <tt>stop</tt> exclusive in this list.\n\t ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Return the size of this list. In other words the number of elements in this list.\n\t * <br>pre: none\n\t * <br>post: return the number of items in this list\n\t * @return the number of items in this list\n\t */\nint size();\n","name":"size","className":"IList","variables":{},"constants":{},"javaDoc":"Return the size of this list In other words the number of elements in this list <br>pre: none <br>post: return the number of items in this list the number of items in this list","comments":"\n\t * Return the size of this list. In other words the number of elements in this list.\n\t * <br>pre: none\n\t * <br>post: return the number of items in this list\n\t * @return the number of items in this list\n\t ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["E"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Find the position of an element in the list.\n\t * <br>pre: none\n\t * <br>post: return the index of the first element equal to item\n\t * or -1 if item is not present\n\t * @param item the element to search for in the list\n\t * @return return the index of the first element equal to item or a -1 if item is not present\n\t */\nint indexOf(E item);\n","name":"indexOf","className":"IList","variables":{},"constants":{},"javaDoc":"Find the position of an element in the list <br>pre: none <br>post: return the index of the first element equal to item or -1 if item is not present item the element to search for in the list return the index of the first element equal to item or a -1 if item is not present","comments":"\n\t * Find the position of an element in the list.\n\t * <br>pre: none\n\t * <br>post: return the index of the first element equal to item\n\t * or -1 if item is not present\n\t * @param item the element to search for in the list\n\t * @return return the index of the first element equal to item or a -1 if item is not present\n\t ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["E","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * find the position of an element in the list starting at a specified position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the index of the first element equal to item starting at pos\n\t * or -1 if item is not present from position pos onward\n\t * @param item the element to search for in the list\n\t * @param pos the position in the list to start searching from\n\t * @return starting from the specified position return the index of the first element equal to item or a -1 if item is not present between pos and the end of the list\n\t */\nint indexOf(E item, int pos);\n","name":"indexOf","className":"IList","variables":{},"constants":{},"javaDoc":"find the position of an element in the list starting at a specified position <br>pre: 0 <= pos < size() <br>post: return the index of the first element equal to item starting at pos or -1 if item is not present from position pos onward item the element to search for in the list pos the position in the list to start searching from starting from the specified position return the index of the first element equal to item or a -1 if item is not present between pos and the end of the list","comments":"\n\t * find the position of an element in the list starting at a specified position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the index of the first element equal to item starting at pos\n\t * or -1 if item is not present from position pos onward\n\t * @param item the element to search for in the list\n\t * @param pos the position in the list to start searching from\n\t * @return starting from the specified position return the index of the first element equal to item or a -1 if item is not present between pos and the end of the list\n\t ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * return the list to an empty state.\n\t * <br>pre: none\n\t * <br>post: size() = 0\n\t */\nvoid makeEmpty();\n","name":"makeEmpty","className":"IList","variables":{},"constants":{},"javaDoc":"return the list to an empty state <br>pre: none <br>post: size() = 0","comments":"\n\t * return the list to an empty state.\n\t * <br>pre: none\n\t * <br>post: size() = 0\n\t ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"Iterator<E>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t* return an Iterator for this list.\n\t* <br>pre: none\n\t* <br>post: return an Iterator object for this List\n\t*/\nIterator<E> iterator();\n","name":"iterator","className":"IList","variables":{},"constants":{},"javaDoc":"return an Iterator for this list <br>pre: none <br>post: return an Iterator object for this List","comments":"\n\t* return an Iterator for this list.\n\t* <br>pre: none\n\t* <br>post: return an Iterator object for this List\n\t","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n     * Remove all elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n     * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n     * <br>post: <tt>size() = old size() - (stop - start)</tt>\n     * @param start position at beginning of range of elements to be removed\n     * @param stop stop - 1 is the position at the end of the range of elements to be removed\n     */\nvoid removeRange(int start, int stop);\n","name":"removeRange","className":"IList","variables":{},"constants":{},"javaDoc":"Remove all elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive <br>pre: <tt>0 <= start < size() start <= stop <= size()</tt> <br>post: <tt>size() = old size() - (stop - start)</tt> start position at beginning of range of elements to be removed stop stop - 1 is the position at the end of the range of elements to be removed","comments":"\n     * Remove all elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n     * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n     * <br>post: <tt>size() = old size() - (stop - start)</tt>\n     * @param start position at beginning of range of elements to be removed\n     * @param stop stop - 1 is the position at the end of the range of elements to be removed\n     ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n     * Return a String version of this list enclosed in\n     * square brackets, []. Elements are in\n     * are in order based on position in the \n     * list with the first element\n     * first. Adjacent elements are seperated by comma's\n     * @return a String representation of this IList\n     */\npublic String toString();\n","name":"toString","className":"IList","variables":{},"constants":{},"javaDoc":"Return a String version of this list enclosed in square brackets [] Elements are in are in order based on position in the list with the first element first Adjacent elements are seperated by comma's a String representation of this IList","comments":"\n     * Return a String version of this list enclosed in\n     * square brackets, []. Elements are in\n     * are in order based on position in the \n     * list with the first element\n     * first. Adjacent elements are seperated by comma's\n     * @return a String representation of this IList\n     ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n     * Determine if this IList is equal to other. Two\n     * ILists are equal if they contain the same elements\n     * in the same order.\n     * @return true if this IList is equal to other, false otherwise\n     */\npublic boolean equals(Object other);\n","name":"equals","className":"IList","variables":{},"constants":{},"javaDoc":"Determine if this IList is equal to other Two ILists are equal if they contain the same elements in the same order true if this IList is equal to other false otherwise","comments":"\n     * Determine if this IList is equal to other. Two\n     * ILists are equal if they contain the same elements\n     * in the same order.\n     * @return true if this IList is equal to other, false otherwise\n     ","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"insert":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(Object x) {\n    insert(iSize, x);\n}\n","name":"add","className":"GenericList","variables":{},"constants":{},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public Object get(int pos) {\n    return iValues[pos];\n}\n","name":"get","className":"GenericList","variables":{"iValues":1,"pos":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"ensureCapcity":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":2,"NameExpr":14,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/**\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     */\npublic void insert(int pos, Object obj) {\n    ensureCapcity();\n    for (int i = iSize; i > pos; i--) {\n        iValues[i] = iValues[i - 1];\n    }\n    iValues[pos] = obj;\n    iSize++;\n}\n","name":"insert","className":"GenericList","variables":{"iValues":3,"iSize":2,"pos":2,"obj":1,"i":5},"constants":{"1":1},"javaDoc":"Insert obj at position pos post: get(pos) = x size() = old size() + 1 pos 0 <= pos <= size() obj The element to add","comments":"\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":4,"NameExpr":14,"UnaryExpr":2,"AssignExpr":2},"statements":{"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public Object remove(int pos) {\n    Object removedValue = iValues[pos];\n    for (int i = pos; i < iSize - 1; i++) iValues[i] = iValues[i + 1];\n    iValues[iSize - 1] = null;\n    iSize--;\n    return removedValue;\n}\n","name":"remove","className":"GenericList","variables":{"iValues":4,"removedValue":2,"iSize":3,"pos":2,"i":5},"constants":{"1":3,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"private void ensureCapcity() {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n}\n","name":"ensureCapcity","className":"GenericList","variables":{"iSize":1},"constants":{},"javaDoc":"","comments":"is there extra capacity available? if not resize ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int size() {\n    return iSize;\n}\n","name":"size","className":"GenericList","variables":{"iSize":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object[]":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    Object[] temp = new Object[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"GenericList","variables":{"temp":2,"iValues":1,"System":1},"constants":{"0":2,"2":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":7,"StringLiteralExpr":4,"NameExpr":15,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i].toString() + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"GenericList","variables":{"result":5,"iValues":2,"iSize":4,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":33,"StringLiteralExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"GenericList","variables":{"result":9,"iValues":2,"iSize":3,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"GenericList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic GenericList() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"GenericList","className":"GenericList","variables":{"DEFAULT_CAP":1},"constants":{},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"GenericList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic GenericList(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new Object[initialCap];\n    iSize = 0;\n}\n","name":"GenericList","className":"GenericList","variables":{"iValues":1,"iSize":1,"initialCap":3},"constants":{"0":2,"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1,"size":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":1,"GenericList":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":32,"UnaryExpr":1,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":2,"ThisExpr":4,"MethodCallExpr":5},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other is not null and refers to an IntList\n        GenericList otherList = (GenericList) other;\n        result = this.size() == otherList.size();\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i].equals(otherList.iValues[i]);\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"GenericList","variables":{"result":8,"other":4,"iSize":1,"i":5,"otherList":2},"constants":{"0":1,"null":1,"false":2,"true":1},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other is not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"substring":1,"System.out.println":8},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":8,"int":2},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":10,"BinaryExpr":18,"StringLiteralExpr":15,"NameExpr":62,"FieldAccessExpr":8,"MethodCallExpr":9,"AssignExpr":1},"statements":{"ExpressionStmt":19},"text":"public static void main(String[] args) {\n    String s1 = \"Computer Science\";\n    int x = 307;\n    String s2 = s1 + \" \" + x;\n    String s3 = s2.substring(10, 17);\n    String s4 = \"is fun\";\n    String s5 = s2 + s4;\n    System.out.println(\"s1: \" + s1);\n    System.out.println(\"s2: \" + s2);\n    System.out.println(\"s3: \" + s3);\n    System.out.println(\"s4: \" + s4);\n    System.out.println(\"s5: \" + s5);\n    //showing effect of precedence\n    x = 3;\n    int y = 5;\n    String s6 = x + y + \"total\";\n    String s7 = \"total \" + x + y;\n    String s8 = \" \" + x + y + \"total\";\n    System.out.println(\"s6: \" + s6);\n    System.out.println(\"s7: \" + s7);\n    System.out.println(\"s8: \" + s8);\n}\n","name":"main","className":"StringExample","variables":{"s3":2,"s4":3,"s5":2,"s6":2,"s7":2,"s8":2,"x":6,"y":4,"s1":3,"s2":4},"constants":{"\"Computer Science\"":1,"\" \"":2,"\"s6: \"":1,"\"s7: \"":1,"17":1,"\"s8: \"":1,"\"s4: \"":1,"\"s5: \"":1,"\"s2: \"":1,"\"s3: \"":1,"\"s1: \"":1,"\"is fun\"":1,"\"total \"":1,"3":1,"5":1,"\"total\"":2,"307":1,"10":1},"javaDoc":"","comments":"showing effect of precedence ","isEmpty":false,"hasInnerClass":false,"lineCount":20,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    go();\n}\n","name":"main","className":"ObjectVarsAsParameters","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setSize":1,"alterPointee":1,"alterPointer":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"BinaryExpr":8,"NameExpr":33,"StringLiteralExpr":8,"FieldAccessExpr":4,"MethodCallExpr":7},"statements":{"ExpressionStmt":8},"text":"public static void go() {\n    Rectangle r1 = new Rectangle(0, 0, 5, 5);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n    // could have been \n    //System.out.prinltn(\"r1\" + r1.toString());\n    r1.setSize(10, 15);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n    alterPointee(r1);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n    alterPointer(r1);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n}\n","name":"go","className":"ObjectVarsAsParameters","variables":{"r1":6},"constants":{"0":2,"\"In method go. r1 \"":4,"15":1,"5":2,"\"\\n\"":4,"10":1},"javaDoc":"","comments":"could have been System out prinltn(\"r1\" + r1 toString()); ","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["Rectangle"],"returnType":"void","methodCalls":{"setSize":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":4,"NameExpr":15,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public static void alterPointee(Rectangle r) {\n    System.out.println(\"In method alterPointee. r \" + r + \"\\n\");\n    r.setSize(20, 30);\n    System.out.println(\"In method alterPointee. r \" + r + \"\\n\");\n}\n","name":"alterPointee","className":"ObjectVarsAsParameters","variables":{"r":3},"constants":{"\"In method alterPointee. r \"":2,"30":1,"\"\\n\"":2,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["Rectangle"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"BinaryExpr":4,"NameExpr":13,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"public static void alterPointer(Rectangle r) {\n    System.out.println(\"In method alterPointer. r \" + r + \"\\n\");\n    r = new Rectangle(5, 10, 30, 35);\n    System.out.println(\"In method alterPointer. r \" + r + \"\\n\");\n}\n","name":"alterPointer","className":"ObjectVarsAsParameters","variables":{"r":3},"constants":{"35":1,"5":1,"\"In method alterPointer. r \"":2,"30":1,"\"\\n\"":2,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"equals":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"IntListVer1":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    IntListVer1 list1 = new IntListVer1();\n    IntListVer1 list2 = new IntListVer1(100);\n    //equal when empty?\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n}\n","name":"main","className":"IntListTesterVer1","variables":{"list1":3,"list2":2},"constants":{"\"list1: \"":1,"100":1,"\"list2: \"":1,"\"list1.equals(list2): \"":1},"javaDoc":"","comments":"equal when empty? ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"countWords":1,"countWordsOurBinarySearchTree":1,"countWordsCollection":2,"countWordsOurUnsortedSet":1,"countWordsOurHash":1,"System.out.println":4},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"int[]":1,"String[]":2,"String":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"ArrayInitializerExpr":2,"ArrayAccessExpr":3,"BinaryExpr":2,"StringLiteralExpr":11,"NameExpr":42,"FieldAccessExpr":4,"MethodCallExpr":10},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":12},"text":"public static void main(String[] args) throws Exception {\n    String[] allFileNames = { \"hounds.txt\", \"huckfinn.txt\", \"oz.txt\", \"war.txt\", \"ciaFactBook2008.txt\" };\n    String[] noCIA = { \"hounds.txt\", \"huckfinn.txt\", \"oz.txt\", \"war.txt\" };\n    countWords(new BinarySearchTree<String>(), allFileNames[0]);\n    for (String s : allFileNames) {\n        System.out.println(s);\n        countWordsOurUnsortedSet(s);\n        countWordsOurBinarySearchTree(s);\n        countWordsOurHash(s);\n        countWordsCollection(new TreeSet<String>(), s);\n        int[] result = countWordsCollection(new HashSet<String>(), s);\n        System.out.println(result[0] + \" total words.\");\n        System.out.println(result[1] + \" distinct words.\");\n        System.out.println();\n    }\n}\n","name":"main","className":"UnsortedSetTest","variables":{"allFileNames":3,"result":3,"s":1,"noCIA":1},"constants":{"0":2,"1":1,"\"huckfinn.txt\"":2,"\" total words.\"":1,"\"hounds.txt\"":2,"\"ciaFactBook2008.txt\"":1,"\"oz.txt\"":2,"\"war.txt\"":2,"\" distinct words.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":["Collection<String>","String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"getClass":1,"stop":1,"size":2,"clear":1,"start":1,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Scanner":1,"Stopwatch":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayInitializerExpr":1,"BinaryExpr":4,"NameExpr":42,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":11},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"// return total num words, and num distinct words\npublic static int[] countWordsCollection(Collection<String> c, String fileName) throws Exception {\n    c.clear();\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for \" + c.getClass() + \" : \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n","name":"countWordsCollection","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":1,"total":4,"c":5},"constants":{"0":1,"\"Time for \"":1,"\" : \\n\"":1},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \");  return total num words, and num distinct words","isEmpty":false,"hasInnerClass":false,"lineCount":12,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"stop":1,"size":2,"start":1,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Scanner":1,"Stopwatch":1,"UnsortedHashSet<String>":1,"int":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":9},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"// GACKY GACKY GACKY repition. Look into removing repetition with reflection\n// we assume there will be add and size methods\npublic static int[] countWordsOurHash(String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    UnsortedHashSet<String> c = new UnsortedHashSet<String>();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for our hashtable (closed address hashing): \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n","name":"countWordsOurHash","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":1,"total":4,"c":4},"constants":{"0":1,"\"Time for our hashtable (closed address hashing): \\n\"":1},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \");  we assume there will be add and size methods","isEmpty":false,"hasInnerClass":false,"lineCount":12,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"stop":1,"size":2,"start":1,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Scanner":1,"Stopwatch":1,"int":1,"UnsortedSet<String>":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":9},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"public static int[] countWordsOurUnsortedSet(String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    UnsortedSet<String> c = new UnsortedSet<String>();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for our unsorted set based on ArrayList: \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n","name":"countWordsOurUnsortedSet","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":1,"total":4,"c":4},"constants":{"0":1,"\"Time for our unsorted set based on ArrayList: \\n\"":1},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \"); ","isEmpty":false,"hasInnerClass":false,"lineCount":12,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"stop":1,"size":2,"start":1,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Scanner":1,"BinarySearchTree<String>":1,"Stopwatch":1,"int":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":9},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"public static int[] countWordsOurBinarySearchTree(String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    BinarySearchTree<String> c = new BinarySearchTree<String>();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for our binary search tree: \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n","name":"countWordsOurBinarySearchTree","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":1,"total":4,"c":4},"constants":{"0":1,"\"Time for our binary search tree: \\n\"":1},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \"); ","isEmpty":false,"hasInnerClass":false,"lineCount":12,"modifier":9}
{"paramTypes":["Object","String"],"returnType":"int[]","methodCalls":{"next":1,"getClass":4,"stop":1,"start":1,"toString":1,"hasNext":1,"invoke":2,"getMethod":2,"getMethods":1,"System.out.println":3},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"Scanner":1,"Stopwatch":1,"Method":2,"int":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":3,"NameExpr":61,"StringLiteralExpr":4,"UnaryExpr":1,"ArrayInitializerExpr":1,"CastExpr":1,"FieldAccessExpr":3,"ClassExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":17},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":13},"text":"// a try at reflection. Not working on Binary Search tree from class. \n// Hunch. Due to add method taking in Comparable, not Object!\n// Alterantives: search list of methods for name?\npublic static int[] countWords(Object c, String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    System.out.println(Arrays.toString(c.getClass().getMethods()));\n    Method addMethod = c.getClass().getMethod(\"add\", Object.class);\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        addMethod.invoke(c, fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for \" + c.getClass() + \": \" + st);\n    Method sizeMethod = c.getClass().getMethod(\"size\");\n    int distictWords = (Integer) sizeMethod.invoke(c);\n    //        System.out.println(distictWords + \" distinct words\");\n    //        System.out.println(total + \" total words including duplicates: \");\n    System.out.println();\n    return new int[] { total, distictWords };\n}\n","name":"countWords","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":1,"total":3,"c":4,"distictWords":2,"Arrays":1,"sizeMethod":2,"addMethod":2},"constants":{"0":1,"\"size\"":1,"\"Time for \"":1,"\": \"":1,"\"add\"":1},"javaDoc":"","comments":"System out println(distictWords + \" distinct words\"); System out println(total + \" total words including duplicates: \");  Alterantives: search list of methods for name?","isEmpty":false,"hasInnerClass":false,"lineCount":14,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    System.out.print(\"Enter your name: \");\n    String name = s.nextLine();\n    System.out.println(\"Hello \" + name + \"!\");\n}\n","name":"main","className":"ScannerAndKeyboard","variables":{"s":2,"name":2},"constants":{"\"!\"":1,"\"Hello \"":1,"\"Enter your name: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":9}
{"paramTypes":[],"returnType":"Die","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor.<p>\n     * pre: none<br>\n     * post: getNumSides() = DEFAULT_SIDES, getResult() = 1\n     */\npublic Die() {\n    this(DEFAULT_SIDES);\n}\n","name":"Die","className":"Die","variables":{"DEFAULT_SIDES":1},"constants":{},"javaDoc":"Default constructor <p> pre: none<br> post: getNumSides() = DEFAULT_SIDES getResult() = 1","comments":"\n     * Default constructor.<p>\n     * pre: none<br>\n     * post: getNumSides() = DEFAULT_SIDES, getResult() = 1\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Die","methodCalls":{"getResult":1,"getNumSides":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":6,"NameExpr":10,"StringLiteralExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"AssertStmt":2,"ExpressionStmt":2},"text":"/**\n     * Create a Die with numSides sides<p>\n     * pre: numSides > 1<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     */\npublic Die(int numSides) {\n    assert numSides > 1 : \"Violation of precondition: numSides = \" + numSides + \"numSides must be greater than 1\";\n    iMyNumSides = numSides;\n    iMyResult = 1;\n    assert getResult() == 1 && getNumSides() == numSides;\n}\n","name":"Die","className":"Die","variables":{"iMyResult":1,"numSides":4,"iMyNumSides":1},"constants":{"\"Violation of precondition: numSides = \"":1,"1":3,"\"numSides must be greater than 1\"":1},"javaDoc":"Create a Die with numSides sides<p> pre: numSides > 1<br> post: getNumSides() = numSides getResult() = 1<br> An exception will be generated if the preconditions are not met","comments":"\n     * Create a Die with numSides sides<p>\n     * pre: numSides > 1<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Die","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":5,"NameExpr":8,"StringLiteralExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Create a Die with numSides and top side and result set to result<p>\n     * pre: numSides > 1, 1 <= result <= numSides<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     */\npublic Die(int numSides, int result) {\n    assert numSides > 1 && 1 <= result && result <= numSides : \"Violation of precondition\";\n    iMyNumSides = numSides;\n    iMyResult = result;\n}\n","name":"Die","className":"Die","variables":{"result":3,"iMyResult":1,"numSides":3,"iMyNumSides":1},"constants":{"1":2,"\"Violation of precondition\"":1},"javaDoc":"Create a Die with numSides and top side and result set to result<p> pre: numSides > 1 1 <= result <= numSides<br> post: getNumSides() = numSides getResult() = 1<br> An exception will be generated if the preconditions are not met","comments":"\n     * Create a Die with numSides and top side and result set to result<p>\n     * pre: numSides > 1, 1 <= result <= numSides<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getResult":2,"nextInt":1,"getNumSides":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":4,"NameExpr":12,"EnclosedExpr":2,"AssignExpr":1,"MethodCallExpr":4},"statements":{"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n     * roll this Die. Every side has an equal chance of being the new result<p>\n     * pre: none<br>\n     * post: 1 <= getResult() <= getNumSides()\n     * @return the result of the Die after the roll\n     */\npublic int roll() {\n    iMyResult = ourRandNumGen.nextInt(iMyNumSides) + 1;\n    assert (1 <= getResult()) && (getResult() <= getNumSides());\n    return iMyResult;\n}\n","name":"roll","className":"Die","variables":{"ourRandNumGen":1,"iMyResult":2},"constants":{"1":2},"javaDoc":"roll this Die Every side has an equal chance of being the new result<p> pre: none<br> post: 1 <= getResult() <= getNumSides() the result of the Die after the roll","comments":"\n     * roll this Die. Every side has an equal chance of being the new result<p>\n     * pre: none<br>\n     * post: 1 <= getResult() <= getNumSides()\n     * @return the result of the Die after the roll\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * return how many sides this Die has<p>\n     * pre: none<br>\n     * post: return how many sides this Die has\n     * @return the number of sides on this Die\n     */\npublic int getNumSides() {\n    return iMyNumSides;\n}\n","name":"getNumSides","className":"Die","variables":{"iMyNumSides":1},"constants":{},"javaDoc":"return how many sides this Die has<p> pre: none<br> post: return how many sides this Die has the number of sides on this Die","comments":"\n     * return how many sides this Die has<p>\n     * pre: none<br>\n     * post: return how many sides this Die has\n     * @return the number of sides on this Die\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * get the current result or top number of this Die<p>\n     * pre: none<br>\n     * post: return the number on top of this Die\n     * @return the current result of this Die\n     */\npublic int getResult() {\n    return iMyResult;\n}\n","name":"getResult","className":"Die","variables":{"iMyResult":1},"constants":{},"javaDoc":"get the current result or top number of this Die<p> pre: none<br> post: return the number on top of this Die the current result of this Die","comments":"\n     * get the current result or top number of this Die<p>\n     * pre: none<br>\n     * post: return the number on top of this Die\n     * @return the current result of this Die\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Die":1,"boolean":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BooleanLiteralExpr":4,"BinaryExpr":6,"NameExpr":23,"CastExpr":1,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4,"MethodCallExpr":2},"statements":{"IfStmt":3,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n     * returns true if this Die and the parameter otherObj are equal<p>\n     * pre: none<br>\n     * post: return true if the parameter is a Die object with the same number of sides as this Die and currently has the same result.\n     * @return true if the the two Dice are equal, false otherwise\n     */\npublic boolean equals(Object otherObj) {\n    boolean result = true;\n    if (otherObj == null)\n        result = false;\n    else if (this == otherObj)\n        result = true;\n    else if (this.getClass() != otherObj.getClass())\n        result = false;\n    else {\n        Die otherDie = (Die) otherObj;\n        result = this.iMyResult == otherDie.iMyResult && this.iMyNumSides == otherDie.iMyNumSides;\n    }\n    return result;\n}\n","name":"equals","className":"Die","variables":{"result":6,"otherDie":1,"otherObj":4},"constants":{"null":1,"true":2,"false":2},"javaDoc":"returns true if this Die and the parameter otherObj are equal<p> pre: none<br> post: return true if the parameter is a Die object with the same number of sides as this Die and currently has the same result true if the the two Dice are equal false otherwise","comments":"\n     * returns true if this Die and the parameter otherObj are equal<p>\n     * pre: none<br>\n     * post: return true if the parameter is a Die object with the same number of sides as this Die and currently has the same result.\n     * @return true if the the two Dice are equal, false otherwise\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getResult":1,"getNumSides":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":4,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n     * returns a String containing information about this Die<p>\n     * pre: none<br>\n     * post: return a String with information about the current state of this Die\n     * @return: A String with the number of sides and current result of this Die\n     */\npublic String toString() {\n    return \"Num sides \" + getNumSides() + \" result \" + getResult();\n}\n","name":"toString","className":"Die","variables":{},"constants":{"\" result \"":1,"\"Num sides \"":1},"javaDoc":"returns a String containing information about this Die<p> pre: none<br> post: return a String with information about the current state of this Die : A String with the number of sides and current result of this Die","comments":"\n     * returns a String containing information about this Die<p>\n     * pre: none<br>\n     * post: return a String with information about the current state of this Die\n     * @return: A String with the number of sides and current result of this Die\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"hasNextInt":1,"nextInt":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Scanner":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":17,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    try {\n        Scanner s = new Scanner(new File(\"scores.dat\"));\n        while (s.hasNextInt()) {\n            System.out.println(s.nextInt());\n        }\n    } catch (IOException e) {\n        System.out.println(e);\n    }\n}\n","name":"main","className":"ReadAndPrintScores","variables":{"s":3,"e":1},"constants":{"\"scores.dat\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"makeSet":3,"toString":6,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle[]":1,"String[]":1,"Object[]":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":12,"VariableDeclarationExpr":3,"ArrayInitializerExpr":3,"BinaryExpr":6,"StringLiteralExpr":18,"NameExpr":60,"FieldAccessExpr":6,"MethodCallExpr":15},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    String[] words = { \"A\", \"B\", \"B\", \"D\", \"C\", \"A\" };\n    System.out.println(\"original: \" + Arrays.toString(words));\n    System.out.println(\"as a set: \" + Arrays.toString(makeSet(words)));\n    Rectangle[] rectList = { new Rectangle(), new Rectangle(), new Rectangle(0, 1, 2, 3), new Rectangle(0, 1, 2, 3) };\n    System.out.println(\"original: \" + Arrays.toString(rectList));\n    System.out.println(\"as a set: \" + Arrays.toString(makeSet(rectList)));\n    Object[] mixed = { \"A\", \"C\", \"A\", \"B\", new Rectangle(), new Rectangle(), \"A\", new Rectangle(0, 1, 2, 3), \"D\" };\n    System.out.println(\"original: \" + Arrays.toString(mixed));\n    System.out.println(\"as a set: \" + Arrays.toString(makeSet(mixed)));\n}\n","name":"main","className":"CreateASet","variables":{"rectList":1,"words":1,"mixed":1,"Arrays":6},"constants":{"\"D\"":2,"0":3,"\"C\"":2,"1":3,"\"B\"":3,"2":3,"\"A\"":5,"\"as a set: \"":3,"3":3,"\"original: \"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":9,"modifier":9}
{"paramTypes":["Object[]"],"returnType":"Object[]","methodCalls":{"noNulls":1,"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Object[]":2,"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":6,"ArrayAccessExpr":4,"BinaryExpr":4,"NameExpr":39,"StringLiteralExpr":2,"UnaryExpr":5,"AssignExpr":4,"NullLiteralExpr":1,"BooleanLiteralExpr":1,"FieldAccessExpr":2,"ArrayCreationExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"AssertStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":12},"text":"/**\n     * An example of polymorphism in action. The method relies\n     * on Java's inheritance requirement and polymorhphism to call\n     * the correct equals method.\n     * @param data != null, no elements of data are null\n     * @return a Set (no duplicates) of the elements in data.\n     */\npublic static Object[] makeSet(Object[] data) {\n    assert data != null : \"Failed precondition makeSet. parameter cannot be null\";\n    assert noNulls(data) : \"Failed precondition makeSet. no elements of parameter can be null\";\n    Object[] result = new Object[data.length];\n    int numUnique = 0;\n    boolean found;\n    int indexInResult;\n    for (int i = 0; i < data.length; i++) {\n        // maybe should break this out into another method\n        indexInResult = 0;\n        found = false;\n        while (!found && indexInResult < numUnique) {\n            found = data[i].equals(result[indexInResult]);\n            indexInResult++;\n        }\n        if (!found) {\n            result[numUnique] = data[i];\n            numUnique++;\n        }\n    }\n    Object[] result2 = new Object[numUnique];\n    System.arraycopy(result, 0, result2, 0, numUnique);\n    return result2;\n}\n","name":"makeSet","className":"CreateASet","variables":{"result":3,"found":5,"data":3,"numUnique":5,"indexInResult":5,"i":5,"result2":2,"System":1},"constants":{"0":5,"null":1,"\"Failed precondition makeSet. parameter cannot be null\"":1,"\"Failed precondition makeSet. no elements of parameter can be null\"":1,"false":1},"javaDoc":"An example of polymorphism in action The method relies on Java's inheritance requirement and polymorhphism to call the correct equals method data != null no elements of data are null a Set (no duplicates) of the elements in data","comments":"maybe should break this out into another method \n     * An example of polymorphism in action. The method relies\n     * on Java's inheritance requirement and polymorhphism to call\n     * the correct equals method.\n     * @param data != null, no elements of data are null\n     * @return a Set (no duplicates) of the elements in data.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":10,"modifier":9}
{"paramTypes":["Object[]"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":1},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":4,"BooleanLiteralExpr":1,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"// pre: data != null\n// return true if all elements of data are non null,\n// false otherwise\nprivate static boolean noNulls(Object[] data) {\n    assert data != null : \"Failed precondition makeSet. parameter cannot be null\";\n    boolean good = true;\n    int i = 0;\n    while (good && i < data.length) {\n        good = data[i] != null;\n        i++;\n    }\n    return good;\n}\n","name":"noNulls","className":"CreateASet","variables":{"data":2,"i":4,"good":4},"constants":{"0":1,"null":2,"\"Failed precondition makeSet. parameter cannot be null\"":1,"true":1},"javaDoc":"","comments":" false otherwise","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":10}
{"paramTypes":[],"returnType":"ListNode","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n\t * default constructor\n\t * pre: none<br>\n\t * post: getData() = null, getNext() = null\n\t */\npublic ListNode() {\n    this(null, null);\n}\n","name":"ListNode","className":"ListNode","variables":{},"constants":{"null":2},"javaDoc":"default constructor pre: none<br> post: getData() = null getNext() = null","comments":"\n\t * default constructor\n\t * pre: none<br>\n\t * post: getData() = null, getNext() = null\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object","ListNode"],"returnType":"ListNode","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n\t * create a ListNode that holds the specified data and refers to the specified next element\n\t * pre: none<br>\n\t * post: getData() = item, getNext() = next\n\t * @param item the  data this ListNode should hold\n\t * @param next the next node in the list\n\t */\npublic ListNode(Object data, ListNode next) {\n    myData = data;\n    myNext = next;\n}\n","name":"ListNode","className":"ListNode","variables":{"next":1,"myNext":1,"data":1,"myData":1},"constants":{},"javaDoc":"create a ListNode that holds the specified data and refers to the specified next element pre: none<br> post: getData() = item getNext() = next item the data this ListNode should hold next the next node in the list","comments":"\n\t * create a ListNode that holds the specified data and refers to the specified next element\n\t * pre: none<br>\n\t * post: getData() = item, getNext() = next\n\t * @param item the  data this ListNode should hold\n\t * @param next the next node in the list\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n\t * return the data in this node\n\t * pre: none<br>\n\t * @return the data this ListNode holds\n\t */\npublic Object getData() {\n    return myData;\n}\n","name":"getData","className":"ListNode","variables":{"myData":1},"constants":{},"javaDoc":"return the data in this node pre: none<br> the data this ListNode holds","comments":"\n\t * return the data in this node\n\t * pre: none<br>\n\t * @return the data this ListNode holds\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"ListNode","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n\t * return the ListNode this ListNode refers to\n\t * pre: none<br>\n\t * @return the ListNode this ListNode refers to (normally the next one in a list)\n\t */\npublic ListNode getNext() {\n    return myNext;\n}\n","name":"getNext","className":"ListNode","variables":{"myNext":1},"constants":{},"javaDoc":"return the ListNode this ListNode refers to pre: none<br> the ListNode this ListNode refers to (normally the next one in a list)","comments":"\n\t * return the ListNode this ListNode refers to\n\t * pre: none<br>\n\t * @return the ListNode this ListNode refers to (normally the next one in a list)\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n\t * set the data in this node\n\t * The old data is over written.<br>\n\t * pre: none<br>\n\t * @param data the new data for this ListNode to hold\n\t */\npublic void setData(Object data) {\n    myData = data;\n}\n","name":"setData","className":"ListNode","variables":{"data":1,"myData":1},"constants":{},"javaDoc":"set the data in this node The old data is over written <br> pre: none<br> data the new data for this ListNode to hold","comments":"\n\t * set the data in this node\n\t * The old data is over written.<br>\n\t * pre: none<br>\n\t * @param data the new data for this ListNode to hold\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["ListNode"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n\t * set the next node this ListNode refers to\n\t * pre: none<br>\n\t * @param next the next node this ListNode should refer to\n\t */\npublic void setNext(ListNode next) {\n    myNext = next;\n}\n","name":"setNext","className":"ListNode","variables":{"next":1,"myNext":1},"constants":{},"javaDoc":"set the next node this ListNode refers to pre: none<br> next the next node this ListNode should refer to","comments":"\n\t * set the next node this ListNode refers to\n\t * pre: none<br>\n\t * @param next the next node this ListNode should refer to\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"stop":2,"equals":3,"start":2,"toString":3,"System.out.println":14,"toStringUsingStringBuffer":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"IntListVer2":2,"Stopwatch":1,"int":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":7,"VariableDeclarationExpr":5,"BinaryExpr":13,"NameExpr":132,"StringLiteralExpr":14,"FieldAccessExpr":14,"UnaryExpr":1,"MethodCallExpr":29,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":2,"ExpressionStmt":28},"text":"public static void main(String[] args) {\n    IntListVer2 list1 = new IntListVer2();\n    IntListVer2 list2 = new IntListVer2(100);\n    //equal when empty?\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n    //add elements\n    for (int i = 0; i < 100; i += 5) {\n        list1.add(i);\n        list2.add(i);\n    }\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n    list2.add(200);\n    System.out.println(\"Added 200 to list2.\");\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n    System.out.println(\"Testing efficieny of StringBuffer versus using String.\");\n    System.out.println(\"Increasing list1 size to 10000.\");\n    Stopwatch s = new Stopwatch();\n    list1 = new IntListVer2();\n    for (int i = 0; i < 10000; i++) list1.add(i);\n    s.start();\n    list1.toString();\n    s.stop();\n    System.out.println(\"Time to build String using String class: \" + s.toString());\n    s.start();\n    list1.toStringUsingStringBuffer();\n    s.stop();\n    System.out.println(\"Time to build String using StringBuffer class: \" + s.toString());\n}\n","name":"main","className":"IntListTesterVer2","variables":{"list1":12,"s":7,"list2":6,"i":6},"constants":{"\"Added 200 to list2.\"":1,"\"Testing efficieny of StringBuffer versus using String.\"":1,"\"list1.equals(list2): \"":3,"\"list1: \"":3,"0":2,"100":2,"\"list2: \"":3,"200":1,"\"Increasing list1 size to 10000.\"":1,"5":1,"\"Time to build String using StringBuffer class: \"":1,"10000":1,"\"Time to build String using String class: \"":1},"javaDoc":"","comments":"equal when empty? add elements ","isEmpty":false,"hasInnerClass":false,"lineCount":27,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    go();\n}\n","name":"main","className":"PrimitiveParameters","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"moreParameters":1,"falseSwap":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":9,"NameExpr":29,"StringLiteralExpr":6,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public static void go() {\n    int x = 3;\n    int y = 2;\n    System.out.println(\"In method go. x: \" + x + \" y: \" + y);\n    falseSwap(x, y);\n    System.out.println(\"in method go. x: \" + x + \" y: \" + y);\n    moreParameters(x, y);\n    System.out.println(\"in method go. x: \" + x + \" y: \" + y);\n}\n","name":"go","className":"PrimitiveParameters","variables":{"x":4,"y":4},"constants":{"\"in method go. x: \"":2,"2":1,"3":1,"\"In method go. x: \"":1,"\" y: \"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":9}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":6,"NameExpr":19,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":5},"text":"public static void falseSwap(int x, int y) {\n    System.out.println(\"in method falseSwap. x: \" + x + \" y: \" + y);\n    int temp = x;\n    x = y;\n    y = temp;\n    System.out.println(\"in method falseSwap. x: \" + x + \" y: \" + y);\n}\n","name":"falseSwap","className":"PrimitiveParameters","variables":{"temp":2,"x":4,"y":4},"constants":{"\"in method falseSwap. x: \"":2,"\" y: \"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":9}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"falseSwap":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":10,"NameExpr":29,"StringLiteralExpr":6,"FieldAccessExpr":3,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":6},"text":"public static void moreParameters(int a, int b) {\n    System.out.println(\"in method moreParameters. a: \" + a + \" b: \" + b);\n    a = a * b;\n    b = 12;\n    System.out.println(\"in method moreParameters. a: \" + a + \" b: \" + b);\n    falseSwap(b, a);\n    System.out.println(\"in method moreParameters. a: \" + a + \" b: \" + b);\n}\n","name":"moreParameters","className":"PrimitiveParameters","variables":{"a":5,"b":5},"constants":{"\"in method moreParameters. a: \"":3,"12":1,"\" b: \"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":9}
{"paramTypes":[],"returnType":"GenericListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"private GenericListIterator() {\n    position = 0;\n    removeOK = false;\n}\n","name":"GenericListIterator","className":"GenericListIterator","variables":{"position":1,"removeOK":1},"constants":{"0":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public boolean hasNext() {\n    return position < iSize;\n}\n","name":"hasNext","className":"GenericListIterator","variables":{"iSize":1,"position":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BooleanLiteralExpr":1,"NameExpr":5,"UnaryExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"public Object next() {\n    Object result = iValues[position];\n    position++;\n    removeOK = true;\n    return result;\n}\n","name":"next","className":"GenericListIterator","variables":{"result":2,"iValues":1,"position":2,"removeOK":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"UnaryExpr":2,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":3},"text":"public void remove() {\n    if (!removeOK)\n        throw new IllegalStateException();\n    // which element should be removed??\n    removeOK = false;\n    GenericListVersion2.this.remove(position - 1);\n    position--;\n}\n","name":"remove","className":"GenericListIterator","variables":{"GenericListVersion2":1,"position":2,"removeOK":2},"constants":{"1":1,"false":1},"javaDoc":"","comments":"which element should be removed?? ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"public Iterator iterator() {\n    return new GenericListIterator();\n}\n","name":"iterator","className":"GenericListVersion2","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Collection"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":4,"ThisExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":1},"text":"public void addAll(Collection c) {\n    // for each loop\n    for (Object obj : c) {\n        this.add(obj);\n    }\n}\n","name":"addAll","className":"GenericListVersion2","variables":{"c":1,"obj":1},"constants":{},"javaDoc":"","comments":"for each loop ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"insert":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(Object x) {\n    insert(iSize, x);\n}\n","name":"add","className":"GenericListVersion2","variables":{},"constants":{},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public Object get(int pos) {\n    return iValues[pos];\n}\n","name":"get","className":"GenericListVersion2","variables":{"iValues":1,"pos":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"ensureCapcity":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":2,"NameExpr":14,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/**\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     */\npublic void insert(int pos, Object obj) {\n    ensureCapcity();\n    for (int i = iSize; i > pos; i--) {\n        iValues[i] = iValues[i - 1];\n    }\n    iValues[pos] = obj;\n    iSize++;\n}\n","name":"insert","className":"GenericListVersion2","variables":{"iValues":3,"iSize":2,"pos":2,"obj":1,"i":5},"constants":{"1":1},"javaDoc":"Insert obj at position pos post: get(pos) = x size() = old size() + 1 pos 0 <= pos <= size() obj The element to add","comments":"\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":4,"NameExpr":14,"UnaryExpr":2,"AssignExpr":2},"statements":{"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public Object remove(int pos) {\n    Object removedValue = iValues[pos];\n    for (int i = pos; i < iSize - 1; i++) iValues[i] = iValues[i + 1];\n    iValues[iSize - 1] = null;\n    iSize--;\n    return removedValue;\n}\n","name":"remove","className":"GenericListVersion2","variables":{"iValues":4,"removedValue":2,"iSize":3,"pos":2,"i":5},"constants":{"1":3,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"private void ensureCapcity() {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n}\n","name":"ensureCapcity","className":"GenericListVersion2","variables":{"iSize":1},"constants":{},"javaDoc":"","comments":"is there extra capacity available? if not resize ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int size() {\n    return iSize;\n}\n","name":"size","className":"GenericListVersion2","variables":{"iSize":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object[]":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    Object[] temp = new Object[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"GenericListVersion2","variables":{"temp":2,"iValues":1,"System":1},"constants":{"0":2,"2":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":7,"StringLiteralExpr":4,"NameExpr":15,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i].toString() + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"GenericListVersion2","variables":{"result":5,"iValues":2,"iSize":4,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":33,"StringLiteralExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"GenericListVersion2","variables":{"result":9,"iValues":2,"iSize":3,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"GenericListVersion2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic GenericListVersion2() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"GenericListVersion2","className":"GenericListVersion2","variables":{"DEFAULT_CAP":1},"constants":{},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"GenericListVersion2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic GenericListVersion2(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new Object[initialCap];\n    iSize = 0;\n}\n","name":"GenericListVersion2","className":"GenericListVersion2","variables":{"iValues":1,"iSize":1,"initialCap":3},"constants":{"0":2,"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1,"size":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":1,"GenericListVersion2":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":32,"UnaryExpr":1,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":2,"ThisExpr":4,"MethodCallExpr":5},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other is not null and refers to an IntList\n        GenericListVersion2 otherList = (GenericListVersion2) other;\n        result = this.size() == otherList.size();\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i].equals(otherList.iValues[i]);\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"GenericListVersion2","variables":{"result":8,"other":4,"iSize":1,"i":5,"otherList":2},"constants":{"0":1,"null":1,"false":2,"true":1},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other is not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"exit":1,"split":1,"nextLine":3,"hasNext":1,"System.out.print":2,"canRedeem":1,"System.out.println":4},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Scanner":2,"Airline":1,"ArrayList<Airline>":1,"String":3,"String[]":1,"ArrayList<String>":2},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":7,"IntegerLiteralExpr":1,"VariableDeclarationExpr":10,"BinaryExpr":6,"NameExpr":72,"StringLiteralExpr":9,"FieldAccessExpr":7,"AssignExpr":4,"MethodCallExpr":14},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":22},"text":"public static void main(String[] args) {\n    Scanner scannerToReadAirlines = null;\n    try {\n        scannerToReadAirlines = new Scanner(new File(\"airlines.txt\"));\n    } catch (IOException e) {\n        System.out.println(\"Could not connect to file airlines.txt.\");\n        System.exit(0);\n    }\n    if (scannerToReadAirlines != null) {\n        ArrayList<Airline> airlinesPartnersNetwork = new ArrayList<Airline>();\n        Airline newAirline;\n        String lineFromFile;\n        String[] airlineNames;\n        while (scannerToReadAirlines.hasNext()) {\n            lineFromFile = scannerToReadAirlines.nextLine();\n            airlineNames = lineFromFile.split(\",\");\n            newAirline = new Airline(airlineNames);\n            airlinesPartnersNetwork.add(newAirline);\n        }\n        System.out.println(airlinesPartnersNetwork);\n        Scanner keyboard = new Scanner(System.in);\n        System.out.print(\"Enter airline miles are on: \");\n        String start = keyboard.nextLine();\n        System.out.print(\"Enter goal airline: \");\n        String goal = keyboard.nextLine();\n        ArrayList<String> pathForMiles = new ArrayList<String>();\n        ArrayList<String> airlinesVisited = new ArrayList<String>();\n        if (canRedeem(start, goal, pathForMiles, airlinesVisited, airlinesPartnersNetwork))\n            System.out.println(\"Path to redeem miles: \" + pathForMiles);\n        else\n            System.out.println(\"Cannot convert miles from \" + start + \" to \" + goal + \".\");\n    }\n}\n","name":"main","className":"AirlineProblem","variables":{"airlineNames":3,"keyboard":3,"scannerToReadAirlines":5,"goal":2,"e":1,"airlinesVisited":1,"start":2,"newAirline":2,"lineFromFile":3,"pathForMiles":2,"System":1,"airlinesPartnersNetwork":2},"constants":{"0":1,"\"Could not connect to file airlines.txt.\"":1,"\"Enter goal airline: \"":1,"null":2,"\" to \"":1,"\".\"":1,"\"airlines.txt\"":1,"\",\"":1,"\"Path to redeem miles: \"":1,"\"Cannot convert miles from \"":1,"\"Enter airline miles are on: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":9}
{"paramTypes":["String","String","ArrayList<String>","ArrayList<String>","ArrayList<Airline>"],"returnType":"boolean","methodCalls":{"add":3,"contains":1,"getName":1,"size":2,"equals":2,"get":2,"getPartners":1,"canRedeem":1,"remove":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"boolean":1,"String[]":1,"int":2},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BooleanLiteralExpr":4,"BinaryExpr":7,"NameExpr":68,"FieldAccessExpr":1,"UnaryExpr":7,"MethodCallExpr":14,"AssignExpr":3},"statements":{"IfStmt":5,"WhileStmt":2,"BlockStmt":4,"ReturnStmt":4,"ExpressionStmt":13},"text":"private static boolean canRedeem(String current, String goal, ArrayList<String> pathForMiles, ArrayList<String> airlinesVisited, ArrayList<Airline> network) {\n    if (current.equals(goal)) {\n        //base case 1, I have found a path!\n        pathForMiles.add(current);\n        return true;\n    } else if (airlinesVisited.contains(current))\n        // don't go into a cycle\n        return false;\n    else {\n        // I have not been here and it isn't\n        // the goal so check its partners\n        // now I have been here\n        airlinesVisited.add(current);\n        // add this to the path\n        pathForMiles.add(current);\n        // find this airline in the network\n        int pos = -1;\n        int index = 0;\n        while (pos == -1 && index < network.size()) {\n            if (network.get(index).getName().equals(current))\n                pos = index;\n            index++;\n        }\n        //if not in the network, no partners\n        if (pos == -1)\n            return false;\n        // loop through partners\n        index = 0;\n        String[] partners = network.get(pos).getPartners();\n        boolean foundPath = false;\n        while (!foundPath && index < partners.length) {\n            foundPath = canRedeem(partners[index], goal, pathForMiles, airlinesVisited, network);\n            index++;\n        }\n        if (!foundPath)\n            pathForMiles.remove(pathForMiles.size() - 1);\n        return foundPath;\n    }\n}\n","name":"canRedeem","className":"AirlineProblem","variables":{"current":1,"pos":4,"partners":2,"airlinesVisited":2,"index":8,"pathForMiles":4,"foundPath":5,"network":3},"constants":{"0":2,"1":4,"true":1,"false":3},"javaDoc":"","comments":"base case 1 I have found a path! base case 2 I have already been here don't go into a cycle I have not been here and it isn't the goal so check its partners now I have been here add this to the path find this airline in the network if not in the network no partners loop through partners ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["String[]"],"returnType":"Airline","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"AssertStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"//pre: data != null, data.length > 0\npublic Airline(String[] data) {\n    assert data != null && data.length > 0 : \"Failed precondition\";\n    name = data[0];\n    partners = new ArrayList<String>();\n    for (int i = 1; i < data.length; i++) partners.add(data[i]);\n}\n","name":"Airline","className":"Airline","variables":{"data":3,"partners":2,"name":1,"i":4},"constants":{"0":2,"\"Failed precondition\"":1,"1":1,"null":1},"javaDoc":"","comments":"pre: data != null, data.length > 0","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"String[]","methodCalls":{"size":1,"toArray":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"ArrayCreationExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String[] getPartners() {\n    return partners.toArray(new String[partners.size()]);\n}\n","name":"getPartners","className":"Airline","variables":{"partners":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"contains":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean isPartner(String name) {\n    return partners.contains(name);\n}\n","name":"isPartner","className":"Airline","variables":{"partners":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Airline","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":2,"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return name + \", partners: \" + partners;\n}\n","name":"toString","className":"Airline","variables":{"partners":1,"name":1},"constants":{"\", partners: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["Color[][]","int"],"returnType":"Color[][]","methodCalls":{"rectangularMatrix":1,"aveOfNeighbors":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color[][]":1,"int":2},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":3,"ArrayAccessExpr":5,"BinaryExpr":10,"NameExpr":37,"StringLiteralExpr":1,"UnaryExpr":2,"AssignExpr":1,"NullLiteralExpr":1,"FieldAccessExpr":6,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":2,"AssertStmt":1,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":2},"text":"/*\n\t *pre: image != null, image.length > 1, image[0].length > 1\n\t *\timage is a rectangular matrix, neighberhoodSize > 0\n\t *post: return a smoothed version of image\n\t */\npublic Color[][] smooth(Color[][] image, int neighberhoodSize) {\n    //check precondition\n    assert image != null && image.length > 1 && image[0].length > 1 && (neighberhoodSize > 0) && rectangularMatrix(image) : \"Violation of precondition: smooth\";\n    Color[][] result = new Color[image.length][image[0].length];\n    for (int row = 0; row < image.length; row++) {\n        for (int col = 0; col < image[0].length; col++) {\n            result[row][col] = aveOfNeighbors(image, row, col, neighberhoodSize);\n        }\n    }\n    return result;\n}\n","name":"smooth","className":"FilterExample","variables":{"result":3,"image":4,"neighberhoodSize":1,"col":4,"row":4},"constants":{"0":6,"1":2,"null":1,"\"Violation of precondition: smooth\"":1},"javaDoc":"","comments":"check precondition \n\t *pre: image != null, image.length > 1, image[0].length > 1\n\t *\timage is a rectangular matrix, neighberhoodSize > 0\n\t *post: return a smoothed version of image\n\t ","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Color[][]","int","int","int"],"returnType":"Color","methodCalls":{"inBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":6},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":6,"ArrayAccessExpr":6,"BinaryExpr":10,"NameExpr":43,"UnaryExpr":3,"MethodCallExpr":4,"AssignExpr":3},"statements":{"IfStmt":1,"BlockStmt":3,"AssertStmt":1,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":8},"text":"// helper method that determines the average color of a neighberhood\n// around a particular cell.\nprivate Color aveOfNeighbors(Color[][] image, int row, int col, int neighberhoodSize) {\n    int numNeighbors = 0;\n    int red = 0;\n    int green = 0;\n    int blue = 0;\n    for (int r = row - neighberhoodSize; r <= row + neighberhoodSize; r++) {\n        for (int c = col - neighberhoodSize; c <= col + neighberhoodSize; c++) {\n            if (inBounds(image, r, c)) {\n                numNeighbors++;\n                red += image[r][c].getRed();\n                green += image[r][c].getGreen();\n                blue += image[r][c].getBlue();\n            }\n        }\n    }\n    assert numNeighbors > 0;\n    return new Color(red / numNeighbors, green / numNeighbors, blue / numNeighbors);\n}\n","name":"aveOfNeighbors","className":"FilterExample","variables":{"red":3,"neighberhoodSize":4,"col":2,"image":3,"numNeighbors":6,"r":6,"green":3,"c":6,"blue":3,"row":2},"constants":{"0":5},"javaDoc":"","comments":" around a particular cell.","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":2}
{"paramTypes":["Color[][]","int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"ArrayAccessExpr":1,"BinaryExpr":7,"NameExpr":10,"FieldAccessExpr":2,"EnclosedExpr":4},"statements":{"ReturnStmt":1},"text":"//helper method to determine if given coordinates are in bounds\nprivate boolean inBounds(Color[][] image, int row, int col) {\n    return (row >= 0) && (row <= image.length) && (col >= 0) && (col < image[0].length);\n}\n","name":"inBounds","className":"FilterExample","variables":{"col":2,"image":1,"row":2},"constants":{"0":3},"javaDoc":"","comments":"helper method to determine if given coordinates are in bounds","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":2}
{"paramTypes":["Color[][]"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"boolean":1,"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":3,"NameExpr":16,"FieldAccessExpr":3,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"//private method to ensure mat is rectangular\nprivate boolean rectangularMatrix(Color[][] mat) {\n    boolean isRectangular = true;\n    int row = 1;\n    final int COLUMNS = mat[0].length;\n    while (isRectangular && row < mat.length) {\n        isRectangular = (mat[row].length == COLUMNS);\n        row++;\n    }\n    return isRectangular;\n}\n","name":"rectangularMatrix","className":"FilterExample","variables":{"mat":2,"COLUMNS":2,"row":4,"isRectangular":4},"constants":{"0":1,"1":1,"true":1},"javaDoc":"","comments":"private method to ensure mat is rectangular","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":2}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"public Iterator iterator() {\n    return new LLIterator();\n}\n","name":"iterator","className":"LinkedList","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"LLIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"private LLIterator() {\n    nextNode = head;\n    removeOK = false;\n    posToRemove = -1;\n}\n","name":"LLIterator","className":"LLIterator","variables":{"head":1,"nextNode":1,"posToRemove":1,"removeOK":1},"constants":{"1":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean hasNext() {\n    return nextNode != null;\n}\n","name":"hasNext","className":"LLIterator","variables":{"nextNode":1},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1,"getNext":1,"getData":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public Object next() {\n    assert hasNext();\n    Object result = nextNode.getData();\n    nextNode = nextNode.getNext();\n    removeOK = true;\n    posToRemove++;\n    return result;\n}\n","name":"next","className":"LLIterator","variables":{"result":2,"nextNode":3,"posToRemove":1,"removeOK":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":7,"UnaryExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"AssertStmt":1,"ExpressionStmt":3},"text":"public void remove() {\n    assert removeOK;\n    removeOK = false;\n    LinkedList.this.remove(posToRemove);\n    posToRemove--;\n}\n","name":"remove","className":"LLIterator","variables":{"posToRemove":1,"removeOK":2,"LinkedList":1},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":2},"text":"public void makeEmpty() {\n    // let GC do its job!!!!!!!\n    head = tail = null;\n    size = 0;\n}\n","name":"makeEmpty","className":"LinkedList","variables":{"head":1,"size":1,"tail":1},"constants":{"0":1,"null":1},"javaDoc":"","comments":"let GC do its job!!!!!!! ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"setNext":1,"getNext":5,"getData":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":8,"NameExpr":42,"UnaryExpr":2,"AssignExpr":6,"MethodCallExpr":8},"statements":{"IfStmt":3,"BlockStmt":2,"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"public Object remove(int pos) {\n    assert pos >= 0 && pos < size;\n    Object result;\n    if (pos == 0) {\n        result = head.getData();\n        head = head.getNext();\n        if (size == 1)\n            tail = null;\n    } else {\n        Node temp = head;\n        for (int i = 1; i < pos; i++) temp = temp.getNext();\n        result = temp.getNext().getData();\n        temp.setNext(temp.getNext().getNext());\n        if (pos == size - 1)\n            tail = temp;\n    }\n    size--;\n    return result;\n}\n","name":"remove","className":"LinkedList","variables":{"result":4,"head":4,"temp":7,"size":4,"pos":5,"tail":2,"i":3},"constants":{"0":2,"1":3,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"getNext":1,"getData":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":6,"NameExpr":22,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"public Object get(int pos) {\n    assert pos >= 0 && pos < size;\n    // array based list\n    // return myCon[pos]\n    Object result;\n    if (pos == size - 1)\n        //O(1)\n        result = tail.getData();\n    else {\n        Node temp = head;\n        for (int i = 0; i < pos; i++) temp = temp.getNext();\n        result = temp.getData();\n    // average case O(N) :((((\n    }\n    return result;\n}\n","name":"get","className":"LinkedList","variables":{"result":4,"head":1,"temp":4,"size":2,"pos":4,"tail":1,"i":3},"constants":{"0":2,"1":1},"javaDoc":"","comments":"array based list return myCon[pos] O(1) average case O(N) :(((( ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"add":1,"setNext":1,"getNext":2,"addFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":2,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":6,"NameExpr":29,"UnaryExpr":2,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":1,"AssertStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public void insert(int pos, Object obj) {\n    assert pos >= 0 && pos <= size;\n    // addFirst?\n    if (pos == 0)\n        // O(1)\n        addFirst(obj);\n    else // add last?\n    if (pos == size)\n        //at end O(1)\n        add(obj);\n    else {\n        // general case\n        Node temp = head;\n        for (int i = 1; i < pos; i++) temp = temp.getNext();\n        // I know temp is pointing at the\n        // node at position pos - 1\n        Node newNode = new Node(obj, temp.getNext());\n        temp.setNext(newNode);\n        size++;\n    }\n}\n","name":"insert","className":"LinkedList","variables":{"head":1,"temp":5,"size":3,"pos":5,"obj":1,"i":3,"newNode":1},"constants":{"0":2,"1":1},"javaDoc":"","comments":"addFirst? O(1) add last? at end O(1) I know temp is pointing at the general case node at position pos - 1 ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"setNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":5},"text":"public void add(Object obj) {\n    Node newNode = new Node(obj, null);\n    if (size == 0)\n        head = newNode;\n    else\n        tail.setNext(newNode);\n    tail = newNode;\n    size++;\n}\n","name":"add","className":"LinkedList","variables":{"head":1,"size":2,"obj":1,"tail":2,"newNode":3},"constants":{"0":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"public void addFirst(Object obj) {\n    if (size == 0)\n        add(obj);\n    else {\n        Node newNode = new Node(obj, head);\n        head = newNode;\n        size++;\n    }\n}\n","name":"addFirst","className":"LinkedList","variables":{"head":2,"size":2,"obj":1,"newNode":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getNext":1,"getData":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":13,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public String toString() {\n    String result = \"\";\n    Node temp = head;\n    for (int i = 0; i < size; i++) {\n        result += temp.getData() + \" \";\n        temp = temp.getNext();\n    }\n    return result;\n}\n","name":"toString","className":"LinkedList","variables":{"result":3,"head":1,"temp":4,"size":1,"i":3},"constants":{"\"\"":1,"0":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":4,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":15,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"AssertStmt":1,"ExpressionStmt":3},"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(int x) {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n    assert 0 <= iSize && iSize < iValues.length;\n    iValues[iSize] = x;\n    iSize++;\n}\n","name":"add","className":"IntListVer2","variables":{"iValues":1,"iSize":5,"x":1},"constants":{"0":1},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"is there extra capacity available? if not resize \n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    int[] temp = new int[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"IntListVer2","variables":{"temp":2,"iValues":1,"System":1},"constants":{"0":2,"2":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":7,"StringLiteralExpr":4,"NameExpr":13,"UnaryExpr":1,"AssignExpr":3},"statements":{"IfStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i] + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"IntListVer2","variables":{"result":5,"iValues":2,"iSize":4,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":33,"StringLiteralExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"IntListVer2","variables":{"result":9,"iValues":2,"iSize":3,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":1}
{"paramTypes":[],"returnType":"IntListVer2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic IntListVer2() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"IntListVer2","className":"IntListVer2","variables":{"DEFAULT_CAP":1},"constants":{},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"IntListVer2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic IntListVer2(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new int[initialCap];\n    iSize = 0;\n}\n","name":"IntListVer2","className":"IntListVer2","variables":{"iValues":1,"iSize":1,"initialCap":3},"constants":{"0":2,"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":1,"IntListVer2":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":30,"UnaryExpr":1,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":4,"ThisExpr":4,"MethodCallExpr":2},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other ris not null and refers to an IntList\n        IntListVer2 otherIntList = (IntListVer2) other;\n        result = this.iSize == otherIntList.iSize;\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i] == otherIntList.iValues[i];\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"IntListVer2","variables":{"result":8,"other":4,"iSize":1,"i":5,"otherIntList":1},"constants":{"0":1,"null":1,"false":2,"true":1},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other ris not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":[],"returnType":"IntListVer3","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic IntListVer3() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"IntListVer3","className":"IntListVer3","variables":{"DEFAULT_CAP":1},"constants":{},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int"],"returnType":"IntListVer3","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic IntListVer3(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new int[initialCap];\n    iSize = 0;\n}\n","name":"IntListVer3","className":"IntListVer3","variables":{"iValues":1,"iSize":1,"initialCap":3},"constants":{"0":2,"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"insert":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(int x) {\n    //example of loose coupling\n    insert(iSize, x);\n}\n","name":"add","className":"IntListVer3","variables":{},"constants":{},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"example of loose coupling \n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":7,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"AssertStmt":1,"ReturnStmt":1},"text":"/**\n     * Retrieve an element from the list based on position.\n     * @param pos 0 <= pos < size()\n     * @return The element at the given position.\n     */\npublic int get(int pos) {\n    assert 0 <= pos && pos < size() : \"Failed precondition get. \" + \"pos it out of bounds. Value of pos: \" + pos;\n    return iValues[pos];\n}\n","name":"get","className":"IntListVer3","variables":{"iValues":1,"pos":4},"constants":{"0":1,"\"Failed precondition get. \"":1,"\"pos it out of bounds. Value of pos: \"":1},"javaDoc":"Retrieve an element from the list based on position pos 0 <= pos < size() The element at the given position","comments":"\n     * Retrieve an element from the list based on position.\n     * @param pos 0 <= pos < size()\n     * @return The element at the given position.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"size":1,"ensureCapcity":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":7,"NameExpr":19,"StringLiteralExpr":2,"UnaryExpr":2,"MethodCallExpr":2,"AssignExpr":2},"statements":{"BlockStmt":1,"AssertStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/**\n     * Insert x at position pos. Elements with a position equal\n     * to pos or more are shifted to the right. (One added to their\n     * position.)\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param x\n     */\npublic void insert(int pos, int x) {\n    assert 0 <= pos && pos <= size() : \"Failed precondition insert. \" + \"pos is invalid. Value of pos: \" + pos;\n    ensureCapcity();\n    for (int i = iSize; i > pos; i--) {\n        iValues[i] = iValues[i - 1];\n    }\n    iValues[pos] = x;\n    iSize++;\n}\n","name":"insert","className":"IntListVer3","variables":{"iValues":3,"iSize":2,"pos":5,"x":1,"i":5},"constants":{"0":1,"1":1,"\"Failed precondition insert. \"":1,"\"pos is invalid. Value of pos: \"":1},"javaDoc":"Insert x at position pos Elements with a position equal to pos or more are shifted to the right (One added to their position ) post: get(pos) = x size() = old size() + 1 pos 0 <= pos <= size() x","comments":"\n     * Insert x at position pos. Elements with a position equal\n     * to pos or more are shifted to the right. (One added to their\n     * position.)\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param x\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":8,"NameExpr":17,"StringLiteralExpr":2,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":1},"statements":{"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n     * Remove an element from the list based on position.\n     * Elements with a position greater than pos\n     * are shifted to the left. (One subtracted from their\n     * position.)\n     * @param pos 0 <= pos < size()\n     * @return The element that is removed.\n     */\npublic int remove(int pos) {\n    assert 0 <= pos && pos < size() : \"Failed precondition remove. \" + \"pos it out of bounds. Value of pos: \" + pos;\n    int removedValue = iValues[pos];\n    for (int i = pos; i < iSize - 1; i++) iValues[i] = iValues[i + 1];\n    iSize--;\n    return removedValue;\n}\n","name":"remove","className":"IntListVer3","variables":{"iValues":3,"removedValue":2,"iSize":2,"pos":5,"i":5},"constants":{"0":1,"1":2,"\"Failed precondition remove. \"":1,"\"pos it out of bounds. Value of pos: \"":1},"javaDoc":"Remove an element from the list based on position Elements with a position greater than pos are shifted to the left (One subtracted from their position ) pos 0 <= pos < size() The element that is removed","comments":"\n     * Remove an element from the list based on position.\n     * Elements with a position greater than pos\n     * are shifted to the left. (One subtracted from their\n     * position.)\n     * @param pos 0 <= pos < size()\n     * @return The element that is removed.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":5,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"private void ensureCapcity() {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n}\n","name":"ensureCapcity","className":"IntListVer3","variables":{"iSize":1},"constants":{},"javaDoc":"","comments":"is there extra capacity available? if not resize ","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * Returns the size of the list.\n     * @return The size of the list.\n     */\npublic int size() {\n    return iSize;\n}\n","name":"size","className":"IntListVer3","variables":{"iSize":1},"constants":{},"javaDoc":"Returns the size of the list The size of the list","comments":"\n     * Returns the size of the list.\n     * @return The size of the list.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    int[] temp = new int[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"IntListVer3","variables":{"temp":2,"iValues":1,"System":1},"constants":{"0":2,"2":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":7,"StringLiteralExpr":4,"NameExpr":13,"UnaryExpr":1,"AssignExpr":3},"statements":{"IfStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i] + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"IntListVer3","variables":{"result":5,"iValues":2,"iSize":4,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":6,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":33,"StringLiteralExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"IntListVer3","variables":{"result":9,"iValues":2,"iSize":3,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"hasInnerClass":false,"lineCount":8,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1,"size":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":1,"IntListVer3":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":30,"UnaryExpr":1,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":2,"ThisExpr":4,"MethodCallExpr":4},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other is not null and refers to an IntList\n        IntListVer3 otherIntList = (IntListVer3) other;\n        result = this.size() == otherIntList.size();\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i] == otherIntList.iValues[i];\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"IntListVer3","variables":{"result":8,"other":4,"iSize":1,"i":5,"otherIntList":2},"constants":{"0":1,"null":1,"false":2,"true":1},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other is not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"println":1,"nextInt":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables"],"types":{"PrintStream":1,"Random":1,"int":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":17,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    try {\n        PrintStream writer = new PrintStream(new File(\"randInts.txt\"));\n        Random r = new Random();\n        final int LIMIT = 100;\n        for (int i = 0; i < LIMIT; i++) {\n            writer.println(r.nextInt());\n        }\n        writer.close();\n    } catch (IOException e) {\n        System.out.println(\"An error occured while trying to write to the file\");\n    }\n}\n","name":"main","className":"WriteToFile","variables":{"r":2,"e":1,"i":3,"LIMIT":2,"writer":3},"constants":{"0":1,"100":1,"\"randInts.txt\"":1,"\"An error occured while trying to write to the file\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"countWordsViaGUI":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    countWordsViaGUI();\n}\n","name":"main","className":"WordCount","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"countWordsWithArrayList":1,"nextLine":2,"toLowerCase":1,"start":1,"getFile":1,"parseInt":1,"stop":1,"showWords":1,"setLookAndFeel":1,"close":2,"System.out.print":2,"charAt":1,"System.out.println":3},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":2,"Stopwatch":1,"ArrayList<String>":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":3,"NameExpr":66,"StringLiteralExpr":5,"FieldAccessExpr":6,"CharLiteralExpr":1,"MethodCallExpr":18},"statements":{"TryStmt":1,"BlockStmt":3,"ExpressionStmt":16,"DoStmt":1},"text":"// allow user to pick file to exam via GUI.\n// allow multiple picks\npublic static void countWordsViaGUI() {\n    setLookAndFeel();\n    try {\n        Scanner key = new Scanner(System.in);\n        do {\n            System.out.println(\"Opening GUI to choose file.\");\n            Scanner fileScanner = new Scanner(getFile());\n            Stopwatch st = new Stopwatch();\n            st.start();\n            ArrayList<String> words = countWordsWithArrayList(fileScanner);\n            st.stop();\n            System.out.println(\"time to count: \" + st);\n            System.out.print(\"Enter number of words to display: \");\n            int numWordsToShow = Integer.parseInt(key.nextLine());\n            showWords(words, numWordsToShow);\n            fileScanner.close();\n            System.out.print(\"Perform another count? \");\n        } while (key.nextLine().toLowerCase().charAt(0) == 'y');\n        key.close();\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Problem reading the data file. Exiting the program.\" + e);\n    }\n}\n","name":"countWordsViaGUI","className":"WordCount","variables":{"Integer":1,"fileScanner":2,"st":4,"numWordsToShow":1,"e":2,"words":1,"key":4},"constants":{"0":1,"\"time to count: \"":1,"'y'":1,"\"Problem reading the data file. Exiting the program.\"":1,"\"Enter number of words to display: \"":1,"\"Opening GUI to choose file.\"":1,"\"Perform another count? \"":1},"javaDoc":"","comments":" allow multiple picks","isEmpty":false,"hasInnerClass":false,"lineCount":2,"modifier":9}
{"paramTypes":["Scanner"],"returnType":"ArrayList<String>","methodCalls":{"size":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"// determine distinct words in a file using an array list\nprivate static ArrayList<String> countWordsWithArrayList(Scanner fileScanner) {\n    System.out.println(\"Total number of words: \" + numWords);\n    System.out.println(\"number of distincy words: \" + result.size());\n    return result;\n}\n","name":"countWordsWithArrayList","className":"WordCount","variables":{"result":2,"numWords":1},"constants":{"\"Total number of words: \"":1,"\"number of distincy words: \"":1},"javaDoc":"","comments":" determine distinct words in a file using an array list","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["Scanner"],"returnType":"Map<String, Integer>","methodCalls":{"size":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"// determine distinct words in a file and frequency of each word with a Map\nprivate static Map<String, Integer> countWordsWithMap(Scanner fileScanner) {\n    System.out.println(\"Total number of words: \" + numWords);\n    System.out.println(\"number of distincy words: \" + result.size());\n    return result;\n}\n","name":"countWordsWithMap","className":"WordCount","variables":{"result":2,"numWords":1},"constants":{"\"Total number of words: \"":1,"\"number of distincy words: \"":1},"javaDoc":"","comments":" determine distinct words in a file and frequency of each word with a Map","isEmpty":false,"hasInnerClass":false,"lineCount":3,"modifier":10}
{"paramTypes":["ArrayList<String>","int"],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":16,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"private static void showWords(ArrayList<String> words, int numWordsToShow) {\n    for (int i = 0; i < words.size() && i < numWordsToShow; i++) System.out.println(words.get(i));\n}\n","name":"showWords","className":"WordCount","variables":{"numWordsToShow":1,"words":2,"i":4},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["Map<String, Integer>","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"private static void showWords(Map<String, Integer> words, int numWordsToShow) {\n}\n","name":"showWords","className":"WordCount","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"lineCount":0,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"timingExpWithArrayList":2,"timingExpWithMap":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayInitializerExpr":2,"StringLiteralExpr":5,"NameExpr":12,"MethodCallExpr":4},"statements":{"EmptyStmt":1,"ExpressionStmt":6},"text":"// perform a series of experiments on files. Determine average time to\n// count words in files of various sizes\nprivate static void performExp() {\n    String[] smallerWorks = { \"smallWords.txt\", \"2BR02B.txt\", \"Alice.txt\", \"SherlockHolmes.txt\" };\n    ;\n    String[] bigFile = { \"ciaFactBook2008.txt\" };\n    timingExpWithArrayList(smallerWorks, 50);\n    timingExpWithArrayList(bigFile, 3);\n    timingExpWithMap(smallerWorks, 50);\n    timingExpWithMap(bigFile, 3);\n}\n","name":"performExp","className":"WordCount","variables":{"bigFile":1,"smallerWorks":1},"constants":{"\"SherlockHolmes.txt\"":1,"\"Alice.txt\"":1,"3":2,"\"ciaFactBook2008.txt\"":1,"\"smallWords.txt\"":1,"50":2,"\"2BR02B.txt\"":1},"javaDoc":"","comments":" count words in files of various sizes","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":10}
{"paramTypes":["String[]","int"],"returnType":"void","methodCalls":{"stop":1,"size":1,"start":1,"time":1,"countWordsWithMap":1,"close":1,"System.out.println":3},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["FinalVariables"],"types":{"Scanner":1,"double[]":1,"Map<String, Integer>":1,"double":1,"Stopwatch":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":3,"VariableDeclarationExpr":8,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":52,"StringLiteralExpr":1,"FieldAccessExpr":5,"ArrayCreationExpr":1,"UnaryExpr":2,"MethodCallExpr":9,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":4,"ForeachStmt":1,"ForStmt":2,"ExpressionStmt":12},"text":"// pre: titles != null, elements of titles refer to files in the\n// same path as this program, numExp >= 0\n// read words from files and print average time to cound words.\nprivate static void timingExpWithMap(String[] titles, int numExp) {\n    try {\n        double[] times = new double[titles.length];\n        final int NUM_EXP = 50;\n        for (int i = 0; i < NUM_EXP; i++) {\n            for (int j = 0; j < titles.length; j++) {\n                Scanner fileScanner = new Scanner(new File(titles[j]));\n                Stopwatch st = new Stopwatch();\n                st.start();\n                Map<String, Integer> words = countWordsWithMap(fileScanner);\n                st.stop();\n                System.out.println(words.size());\n                times[j] += st.time();\n                fileScanner.close();\n            }\n        }\n        for (double a : times) System.out.println(a / NUM_EXP);\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Problem reading the data file. Exiting the program.\" + e);\n    }\n}\n","name":"timingExpWithMap","className":"WordCount","variables":{"fileScanner":2,"st":4,"a":2,"times":3,"e":2,"words":2,"i":3,"j":5,"titles":1,"NUM_EXP":3},"constants":{"0":2,"\"Problem reading the data file. Exiting the program.\"":1,"50":1},"javaDoc":"","comments":" read words from files and print average time to cound words.","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":["String[]","int"],"returnType":"void","methodCalls":{"stop":1,"countWordsWithArrayList":1,"start":1,"time":1,"close":1,"System.out.println":2},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":1,"double[]":1,"Stopwatch":1,"ArrayList<String>":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":3,"VariableDeclarationExpr":7,"ArrayAccessExpr":4,"BinaryExpr":8,"NameExpr":51,"StringLiteralExpr":3,"UnaryExpr":3,"AssignExpr":1,"FieldAccessExpr":5,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":7},"statements":{"TryStmt":1,"BlockStmt":4,"ForStmt":3,"ExpressionStmt":10},"text":"// pre: titles != null, elements of titles refer to files in the\n// same path as this program, numExp >= 0\n// read words from files and print average time to cound words.\nprivate static void timingExpWithArrayList(String[] titles, int numExp) {\n    try {\n        double[] times = new double[titles.length];\n        for (int i = 0; i < numExp; i++) {\n            for (int j = 0; j < titles.length; j++) {\n                Scanner fileScanner = new Scanner(new File(titles[j]));\n                Stopwatch st = new Stopwatch();\n                st.start();\n                ArrayList<String> words = countWordsWithArrayList(fileScanner);\n                st.stop();\n                times[j] += st.time();\n                fileScanner.close();\n            }\n        }\n        for (int i = 0; i < titles.length; i++) System.out.println(\"Average time for \" + titles[i] + \": \" + (times[i] / numExp));\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Problem reading the data file. Exiting the program.\" + e);\n    }\n}\n","name":"timingExpWithArrayList","className":"WordCount","variables":{"fileScanner":2,"st":4,"times":3,"e":2,"words":1,"i":8,"j":5,"titles":2,"numExp":2},"constants":{"0":3,"\"Problem reading the data file. Exiting the program.\"":1,"\": \"":1,"\"Average time for \"":1},"javaDoc":"","comments":" read words from files and print average time to cound words.","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSystemLookAndFeelClassName":1,"setLookAndFeel":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"// try to set look and feel to same as system\nprivate static void setLookAndFeel() {\n    try {\n        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n    } catch (Exception e) {\n        System.out.println(\"Unable to set look at feel to local settings. \" + \"Continuing with default Java look and feel.\");\n    }\n}\n","name":"setLookAndFeel","className":"WordCount","variables":{"e":1,"UIManager":2},"constants":{"\"Unable to set look at feel to local settings. \"":1,"\"Continuing with default Java look and feel.\"":1},"javaDoc":"","comments":" try to set look and feel to same as system","isEmpty":false,"hasInnerClass":false,"lineCount":1,"modifier":10}
{"paramTypes":[],"returnType":"File","methodCalls":{"showOpenDialog":1,"getSelectedFile":1,"grabFocus":1,"setDialogTitle":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1,"File":1,"int":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"/** Method to choose a file using a window.\n     * @return the file chosen by the user. Returns null if no file picked.\n     */\nprivate static File getFile() {\n    // create a GUI window to pick the text to evaluate\n    JFileChooser chooser = new JFileChooser(\".\");\n    chooser.setDialogTitle(\"Select File To Count Words:\");\n    int retval = chooser.showOpenDialog(null);\n    File f = null;\n    chooser.grabFocus();\n    if (retval == JFileChooser.APPROVE_OPTION)\n        f = chooser.getSelectedFile();\n    return f;\n}\n","name":"getFile","className":"WordCount","variables":{"f":3,"chooser":5,"retval":2},"constants":{"\"Select File To Count Words:\"":1,"null":2,"\".\"":1},"javaDoc":"Method to choose a file using a window the file chosen by the user Returns null if no file picked","comments":"create a GUI window to pick the text to evaluate  Method to choose a file using a window.\n     * @return the file chosen by the user. Returns null if no file picked.\n     ","isEmpty":false,"hasInnerClass":false,"lineCount":7,"modifier":10}
