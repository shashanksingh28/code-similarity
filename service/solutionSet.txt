{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Nose[]":1,"int":1},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":5,"BinaryExpr":3,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Nose[] i = new Nose[3];\n    i[0] = new Acts();\n    i[1] = new Clowns();\n    i[2] = new Of76();\n    for (int x = 0; x < 3; x++) {\n        System.out.println(i[x].iMethod() + \" \" + i[x].getClass());\n    }\n}\n","name":"main","className":"Of76","variables":{"x":5,"i":6},"constants":{"0":2,"1":1,"2":1,"3":2,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public int iMethod();\n","name":"iMethod","className":"Nose","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public int iMethod() {\n    return 7;\n}\n","name":"iMethod","className":"Picasso","variables":{},"constants":{"7":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public int iMethod() {\n    return 5;\n}\n","name":"iMethod","className":"Acts","variables":{},"constants":{"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setName":3,"add":3,"placeDotCom":1,"setLocationCells":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"DotCom":4,"ArrayList<String>":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"NameExpr":44,"StringLiteralExpr":6,"FieldAccessExpr":3,"MethodCallExpr":11},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":14},"text":"private void setUpGame() {\n    DotCom one = new DotCom();\n    one.setName(\"Pets.com\");\n    DotCom two = new DotCom();\n    two.setName(\"eToys.com\");\n    DotCom three = new DotCom();\n    three.setName(\"Go2.com\");\n    dotComsList.add(one);\n    dotComsList.add(two);\n    dotComsList.add(three);\n    System.out.println(\"Your goal is to sink three dot coms.\");\n    System.out.println(\"Pets.com, eToys.com, Go2.com\");\n    System.out.println(\"Try to sink them all in the fewest number of guesses\");\n    for (DotCom dotComSet : dotComsList) {\n        ArrayList<String> newLocation = helper.placeDotCom(3);\n        dotComSet.setLocationCells(newLocation);\n    }\n}\n","name":"setUpGame","className":"DotComBust","variables":{"dotComsList":4,"helper":1,"one":2,"two":2,"three":2,"newLocation":1,"dotComSet":2},"constants":{"\"Go2.com\"":1,"\"eToys.com\"":1,"\"Try to sink them all in the fewest number of guesses\"":1,"3":1,"\"Pets.com\"":1,"\"Pets.com, eToys.com, Go2.com\"":1,"\"Your goal is to sink three dot coms.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"checkUserGuess":1,"isEmpty":1,"getUserInput":1,"finishGame":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":11,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"private void startPlaying() {\n    while (!dotComsList.isEmpty()) {\n        String userGuess = helper.getUserInput(\"Enter a guess\");\n        checkUserGuess(userGuess);\n    }\n    finishGame();\n}\n","name":"startPlaying","className":"DotComBust","variables":{"dotComsList":1,"helper":1,"userGuess":1},"constants":{"\"Enter a guess\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"checkYourself":1,"equals":2,"remove":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"DotCom":1,"String":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":23,"StringLiteralExpr":3,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":2,"BreakStmt":2,"BlockStmt":3,"ForeachStmt":1,"ExpressionStmt":5},"text":"private void checkUserGuess(String userGuess) {\n    numOfGuesses++;\n    String result = \"miss\";\n    for (DotCom dotComToTest : dotComsList) {\n        result = dotComToTest.checkYourself(userGuess);\n        if (result.equals(\"hit\")) {\n            break;\n        }\n        if (result.equals(\"kill\")) {\n            dotComsList.remove(dotComToTest);\n            break;\n        }\n    }\n    System.out.println(result);\n}\n","name":"checkUserGuess","className":"DotComBust","variables":{"result":4,"dotComsList":2,"numOfGuesses":1,"dotComToTest":2},"constants":{"\"miss\"":1,"\"kill\"":1,"\"hit\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":5,"NameExpr":28,"StringLiteralExpr":7,"FieldAccessExpr":5,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"private void finishGame() {\n    System.out.println(\"All Dot Coms are dead!  Your stock is now worthless\");\n    if (numOfGuesses <= 18) {\n        System.out.println(\"It only took you \" + numOfGuesses + \" guesses\");\n        System.out.println(\"You got out before your options sank.\");\n    } else {\n        System.out.println(\"Took you long enough. \" + numOfGuesses + \" guesses.\");\n        System.out.println(\"Fish are dancing with your options.\");\n    }\n}\n","name":"finishGame","className":"DotComBust","variables":{"numOfGuesses":3},"constants":{"\"It only took you \"":1,"18":1,"\"All Dot Coms are dead!  Your stock is now worthless\"":1,"\"Took you long enough. \"":1,"\"You got out before your options sank.\"":1,"\"Fish are dancing with your options.\"":1,"\" guesses.\"":1,"\" guesses\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setUpGame":1,"startPlaying":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"DotComBust":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    DotComBust game = new DotComBust();\n    game.setUpGame();\n    game.startPlaying();\n}\n","name":"main","className":"DotComBust","variables":{"game":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ArrayList<String>"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setLocationCells(ArrayList<String> loc) {\n    locationCells = loc;\n}\n","name":"setLocationCells","className":"DotCom","variables":{"loc":1,"locationCells":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"isEmpty":1,"indexOf":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"StringLiteralExpr":3,"NameExpr":15,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":1,"ExpressionStmt":5},"text":"public String checkYourself(String userInput) {\n    String result = \"miss\";\n    int index = locationCells.indexOf(userInput);\n    if (index >= 0) {\n        locationCells.remove(index);\n        if (locationCells.isEmpty()) {\n            result = \"kill\";\n        } else {\n            result = \"hit\";\n        }\n    }\n    return result;\n}\n","name":"checkYourself","className":"DotCom","variables":{"result":4,"locationCells":3,"index":2},"constants":{"0":1,"\"miss\"":1,"\"kill\"":1,"\"hit\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setName(String string) {\n    name = string;\n}\n","name":"setName","className":"DotCom","variables":{"string":1,"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getSize":2,"setSize":2,"bark":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"GoodDog":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":28,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":8},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    GoodDog one = new GoodDog();\n    one.setSize(70);\n    GoodDog two = new GoodDog();\n    two.setSize(8);\n    System.out.println(\"Dog one: \" + one.getSize());\n    System.out.println(\"Dog two: \" + two.getSize());\n    one.bark();\n    two.bark();\n}\n","name":"main","className":"GoodDogTestDrive","variables":{"one":4,"two":4},"constants":{"\"Dog two: \"":1,"8":1,"70":1,"\"Dog one: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getSize() {\n    return size;\n}\n","name":"getSize","className":"GoodDog","variables":{"size":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setSize(int s) {\n    size = s;\n}\n","name":"setSize","className":"GoodDog","variables":{"s":1,"size":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ExpressionStmt":3},"text":"void bark() {\n    if (size > 60) {\n        System.out.println(\"Wooof! Wooof!\");\n    } else if (size > 60) {\n        System.out.println(\"Ruff! Ruff!\");\n    } else {\n        System.out.println(\"Yip! Yip!\");\n    }\n}\n","name":"bark","className":"GoodDog","variables":{"size":2},"constants":{"\"Wooof! Wooof!\"":1,"\"Yip! Yip!\"":1,"60":2,"\"Ruff! Ruff!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":1},"statements":{"ExpressionStmt":2},"text":"public void go() {\n    //added initialization after verified that it doesn't compile\n    int x = 0;\n    // without it -Tyler Boone\n    int z = x + 3;\n}\n","name":"go","className":"Foo","variables":{"x":2,"z":1},"constants":{"0":1,"3":1},"javaDoc":"","comments":"added initialization after verified that it doesn't compile without it -Tyler Boone ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getSize":1,"getName":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"PoorDog":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    PoorDog one = new PoorDog();\n    System.out.println(\"Dog size is \" + one.getSize());\n    System.out.println(\"Dog name is \" + one.getName());\n}\n","name":"main","className":"PoorDogTestDrive","variables":{"one":3},"constants":{"\"Dog name is \"":1,"\"Dog size is \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getSize() {\n    return size;\n}\n","name":"getSize","className":"PoorDog","variables":{"size":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"PoorDog","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpServletRequest","HttpServletResponse"],"returnType":"void","methodCalls":{"println":7,"getWriter":1,"setContentType":1,"close":1,"makePhrase":1},"annotations":[],"exceptions":["ServletException","IOException"],"concepts":[],"types":{"String":1,"PrintWriter":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":3,"StringLiteralExpr":10,"NameExpr":35,"MethodCallExpr":11,"AssignExpr":1},"statements":{"ExpressionStmt":12},"text":"public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    PrintWriter out;\n    String title = \"PhraseOMatic has generated the following phrase.\";\n    response.setContentType(\"text/html\");\n    out = response.getWriter();\n    out.println(\"<HTML><HEAD><TITLE>\");\n    out.println(\"PhraseOmatic\");\n    out.println(\"</TITLE></HEAD><BODY>\");\n    out.println(\"<H1>\" + title + \"</H1>\");\n    out.println(\"<P>\" + PhraseOMatic2.makePhrase());\n    out.println(\"<P><a href=\\\"KathyServlet\\\">make another phrase</a></p>\");\n    out.println(\"</BODY></HTML>\");\n    out.close();\n}\n","name":"doGet","className":"KathyServlet","variables":{"PhraseOMatic2":1,"response":2,"title":2,"out":10},"constants":{"\"</TITLE></HEAD><BODY>\"":1,"\"<P>\"":1,"\"<H1>\"":1,"\"PhraseOMatic has generated the following phrase.\"":1,"\"<P><a href=\\\"KathyServlet\\\">make another phrase</a></p>\"":1,"\"PhraseOmatic\"":1,"\"</H1>\"":1,"\"text/html\"":1,"\"</BODY></HTML>\"":1,"\"<HTML><HEAD><TITLE>\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"setVisible":1,"getServicesList":1,"setSize":1,"addActionListener":1,"getContentPane":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"Object[]":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":32,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"public void buildGUI() {\n    JFrame frame = new JFrame(\"RMI Browser\");\n    mainPanel = new JPanel();\n    frame.getContentPane().add(BorderLayout.CENTER, mainPanel);\n    Object[] services = getServicesList();\n    serviceList = new JComboBox(services);\n    frame.getContentPane().add(BorderLayout.NORTH, serviceList);\n    serviceList.addActionListener(new MyListListener());\n    frame.setSize(500, 500);\n    frame.setVisible(true);\n}\n","name":"buildGUI","className":"ServiceBrowser","variables":{"mainPanel":1,"serviceList":2,"services":2,"frame":5},"constants":{"500":2,"true":1,"\"RMI Browser\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"add":1,"getGuiPanel":1,"removeAll":1,"printStackTrace":1,"repaint":1,"getService":1,"validate":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Service":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":22,"MethodCallExpr":7},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"void loadService(Object serviceSelection) {\n    try {\n        Service svc = server.getService(serviceSelection);\n        mainPanel.removeAll();\n        mainPanel.add(svc.getGuiPanel());\n        mainPanel.validate();\n        mainPanel.repaint();\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"loadService","className":"ServiceBrowser","variables":{"svc":2,"server":1,"ex":2,"mainPanel":4},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"Object[]","methodCalls":{"lookup":1,"printStackTrace":2,"getServiceList":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Object":1,"Object[]":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":2,"NameExpr":17,"StringLiteralExpr":1,"CastExpr":1,"AssignExpr":3,"MethodCallExpr":4},"statements":{"TryStmt":2,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":7},"text":"Object[] getServicesList() {\n    Object obj = null;\n    Object[] services = null;\n    try {\n        obj = Naming.lookup(\"rmi://127.0.0.1/ServiceServer\");\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    server = (ServiceServer) obj;\n    try {\n        services = server.getServiceList();\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    return services;\n}\n","name":"getServicesList","className":"ServiceBrowser","variables":{"server":2,"ex":4,"obj":3,"services":3,"Naming":1},"constants":{"\"rmi://127.0.0.1/ServiceServer\"":1,"null":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"loadService":1,"getSelectedItem":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent ev) {\n    // do things to get the selected service\n    Object selection = serviceList.getSelectedItem();\n    loadService(selection);\n}\n","name":"actionPerformed","className":"MyListListener","variables":{"selection":1,"serviceList":1},"constants":{},"javaDoc":"","comments":"do things to get the selected service ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new ServiceBrowser().buildGUI();\n}\n","name":"main","className":"ServiceBrowser","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{"random":3},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"String[]":3,"String":1,"int":6},"expressions":{"VariableDeclarationExpr":10,"ArrayInitializerExpr":3,"ArrayAccessExpr":3,"BinaryExpr":8,"StringLiteralExpr":45,"NameExpr":28,"CastExpr":3,"FieldAccessExpr":3,"EnclosedExpr":4,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":10},"text":"public static String makePhrase() {\n    // make three sets of words to choose from\n    String[] wordListOne = { \"24/7\", \"multi-Tier\", \"30,000 foot\", \"B-to-B\", \"win-win\", \"front-end\", \"web-based\", \"pervasive\", \"smart\", \"six-sigma\", \"critical-path\", \"dynamic\" };\n    String[] wordListTwo = { \"empowered\", \"sticky\", \"valued-added\", \"oriented\", \"centric\", \"distributed\", \"clustered\", \"branded\", \"outside-the-box\", \"positioned\", \"networked\", \"focused\", \"leveraged\", \"aligned\", \"targeted\", \"shared\", \"cooperative\", \"accelerated\" };\n    String[] wordListThree = { \"process\", \"tipping point\", \"solution\", \"architecture\", \"core competency\", \"strategy\", \"mindshare\", \"portal\", \"space\", \"vision\", \"paradigm\", \"mission\" };\n    // find out how many words are in each list\n    int oneLength = wordListOne.length;\n    int twoLength = wordListTwo.length;\n    int threeLength = wordListThree.length;\n    // generate three random numbers, to pull random words from each list\n    int rand1 = (int) (Math.random() * oneLength);\n    int rand2 = (int) (Math.random() * twoLength);\n    int rand3 = (int) (Math.random() * threeLength);\n    // now build a phrase\n    String phrase = wordListOne[rand1] + \" \" + wordListTwo[rand2] + \" \" + wordListThree[rand3];\n    // now return it\n    return (\"What we need is a \" + phrase);\n}\n","name":"makePhrase","className":"PhraseOMatic2","variables":{"wordListTwo":2,"wordListThree":2,"phrase":2,"twoLength":2,"rand1":2,"wordListOne":2,"oneLength":2,"rand2":2,"rand3":2,"threeLength":2,"Math":3},"constants":{"\"accelerated\"":1,"\"strategy\"":1,"\"networked\"":1,"\"sticky\"":1,"\"24/7\"":1,"\"branded\"":1,"\"mission\"":1,"\"multi-Tier\"":1,"\"focused\"":1,"\"space\"":1,"\"paradigm\"":1,"\"process\"":1,"\"cooperative\"":1,"\"solution\"":1,"\"tipping point\"":1,"\"mindshare\"":1,"\"portal\"":1,"\"positioned\"":1,"\"leveraged\"":1,"\"empowered\"":1,"\"vision\"":1,"\"six-sigma\"":1,"\"valued-added\"":1,"\"oriented\"":1,"\"shared\"":1,"\"smart\"":1,"\" \"":2,"\"front-end\"":1,"\"pervasive\"":1,"\"B-to-B\"":1,"\"30,000 foot\"":1,"\"What we need is a \"":1,"\"outside-the-box\"":1,"\"centric\"":1,"\"win-win\"":1,"\"distributed\"":1,"\"targeted\"":1,"\"aligned\"":1,"\"dynamic\"":1,"\"architecture\"":1,"\"clustered\"":1,"\"core competency\"":1,"\"critical-path\"":1,"\"web-based\"":1},"javaDoc":"","comments":"make three sets of words to choose from find out how many words are in each list generate three random numbers to pull random words from each list now build a phrase now return it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":3,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"JButton":1,"String[]":1},"expressions":{"ObjectCreationExpr":5,"VariableDeclarationExpr":3,"ArrayInitializerExpr":1,"StringLiteralExpr":7,"NameExpr":19,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":9},"text":"public JPanel getGuiPanel() {\n    JPanel panel = new JPanel();\n    JButton button = new JButton(\"Roll 'em!\");\n    String[] choices = { \"1\", \"2\", \"3\", \"4\", \"5\" };\n    numOfDice = new JComboBox(choices);\n    label = new JLabel(\"dice values here\");\n    button.addActionListener(new RollEmListener());\n    panel.add(numOfDice);\n    panel.add(button);\n    panel.add(label);\n    return panel;\n}\n","name":"getGuiPanel","className":"DiceService","variables":{"button":2,"numOfDice":1,"label":1,"panel":5,"choices":2},"constants":{"\"4\"":1,"\"3\"":1,"\"2\"":1,"\"1\"":1,"\"dice values here\"":1,"\"Roll 'em!\"":1,"\"5\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseInt":1,"random":1,"getSelectedItem":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"String":2,"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":4,"StringLiteralExpr":2,"CastExpr":2,"NameExpr":19,"EnclosedExpr":3,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public void actionPerformed(ActionEvent ev) {\n    // roll the dice\n    String diceOutput = \"\";\n    String selection = (String) numOfDice.getSelectedItem();\n    int numOfDiceToRoll = Integer.parseInt(selection);\n    for (int i = 0; i < numOfDiceToRoll; i++) {\n        int r = (int) ((Math.random() * 6) + 1);\n        diceOutput += (\" \" + r);\n    }\n    label.setText(diceOutput);\n}\n","name":"actionPerformed","className":"RollEmListener","variables":{"Integer":1,"numOfDice":1,"r":2,"selection":1,"diceOutput":2,"i":3,"numOfDiceToRoll":2,"label":1,"Math":1},"constants":{"\"\"":1,"0":1,"1":1,"\" \"":1,"6":1},"javaDoc":"","comments":"roll the dice ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object[]","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"Object[] getServiceList() throws RemoteException;\n","name":"getServiceList","className":"ServiceServer","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Object"],"returnType":"Service","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"Service getService(Object serviceKey) throws RemoteException;\n","name":"getService","className":"ServiceServer","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"ServiceServerImpl","methodCalls":{"setUpServices":1},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public ServiceServerImpl() throws RemoteException {\n    // start and set up services \n    setUpServices();\n}\n","name":"ServiceServerImpl","className":"ServiceServerImpl","variables":{},"constants":{},"javaDoc":"","comments":"start and set up services ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"put":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":4,"NameExpr":10,"StringLiteralExpr":3,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"private void setUpServices() {\n    serviceList = new HashMap<String, Service>();\n    serviceList.put(\"Dice Rolling Service\", new DiceService());\n    serviceList.put(\"Day of the Week Service\", new DayOfTheWeekService());\n    serviceList.put(\"Visual Music Service\", new MiniMusicService());\n}\n","name":"setUpServices","className":"ServiceServerImpl","variables":{"serviceList":4},"constants":{"\"Visual Music Service\"":1,"\"Dice Rolling Service\"":1,"\"Day of the Week Service\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"Object[]","methodCalls":{"toArray":1,"keySet":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public Object[] getServiceList() {\n    System.out.println(\"in remote\");\n    return serviceList.keySet().toArray();\n}\n","name":"getServiceList","className":"ServiceServerImpl","variables":{"serviceList":1},"constants":{"\"in remote\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"Service","methodCalls":{"get":1},"annotations":[],"exceptions":["RemoteException"],"concepts":["Casting"],"types":{"Service":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public Service getService(Object serviceKey) throws RemoteException {\n    Service theService = (Service) serviceList.get(serviceKey);\n    return theService;\n}\n","name":"getService","className":"ServiceServerImpl","variables":{"theService":2,"serviceList":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"rebind":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":8,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    try {\n        Naming.rebind(\"ServiceServer\", new ServiceServerImpl());\n    } catch (Exception ex) {\n    }\n    System.out.println(\"Remote service is running\");\n}\n","name":"main","className":"ServiceServerImpl","variables":{"ex":1,"Naming":1},"constants":{"\"Remote service is running\"":1,"\"ServiceServer\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":2,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"JButton":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":2,"NameExpr":13,"StringLiteralExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":6},"text":"public JPanel getGuiPanel() {\n    JPanel mainPanel = new JPanel();\n    myPanel = new MyDrawPanel();\n    JButton playItButton = new JButton(\"Play it\");\n    playItButton.addActionListener(new PlayItListener());\n    mainPanel.add(myPanel);\n    mainPanel.add(playItButton);\n    return mainPanel;\n}\n","name":"getGuiPanel","className":"MiniMusicService","variables":{"mainPanel":4,"myPanel":1,"playItButton":2},"constants":{"\"Play it\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSequencer":1,"add":3,"setSequence":1,"random":1,"makeEvent":3,"printStackTrace":1,"setTempoInBPM":1,"addControllerEventListener":1,"createTrack":1,"start":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"Sequencer":1,"Sequence":1,"Track":1,"int":2},"expressions":{"IntegerLiteralExpr":20,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayInitializerExpr":1,"BinaryExpr":5,"NameExpr":55,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":15,"AssignExpr":1},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":13},"text":"public void actionPerformed(ActionEvent ev) {\n    try {\n        // make (and open) a sequencer, make a sequence and track\n        Sequencer sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        sequencer.addControllerEventListener(myPanel, new int[] { 127 });\n        Sequence seq = new Sequence(Sequence.PPQ, 4);\n        Track track = seq.createTrack();\n        for (int i = 0; i < 100; i += 4) {\n            int rNum = (int) ((Math.random() * 50) + 1);\n            if (rNum < 38) {\n                // so now only do it if num <38 (75% of the time)\n                track.add(makeEvent(144, 1, rNum, 100, i));\n                track.add(makeEvent(176, 1, 127, 0, i));\n                track.add(makeEvent(128, 1, rNum, 100, i + 2));\n            }\n        }\n        // end loop\n        // add the events to the track            \n        // add the sequence to the sequencer, set timing, and start\n        sequencer.setSequence(seq);\n        sequencer.start();\n        sequencer.setTempoInBPM(220);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n          // now make two midi events (containing a midi message)\n\n","name":"actionPerformed","className":"PlayItListener","variables":{"rNum":2,"ex":2,"i":4,"track":4,"Math":1,"MidiSystem":1,"seq":2,"sequencer":6},"constants":{"0":2,"176":1,"220":1,"100":3,"1":4,"144":1,"2":1,"4":2,"38":1,"127":2,"128":1,"50":1},"javaDoc":"","comments":"make (and open) a sequencer make a sequence and track now make two midi events (containing a midi message) end loop add the events to the track add the sequence to the sequencer set timing and start so now only do it if num <38 (75% of the time) ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"MidiEvent","methodCalls":{"setMessage":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"ShortMessage":1,"MidiEvent":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":1,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"// close inner class\npublic MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {\n    MidiEvent event = null;\n    try {\n        ShortMessage a = new ShortMessage();\n        a.setMessage(comd, chan, one, two);\n        event = new MidiEvent(a, tick);\n    } catch (Exception e) {\n    }\n    return event;\n}\n","name":"makeEvent","className":"MiniMusicService","variables":{"a":3,"e":1,"tick":1,"event":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ShortMessage"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":3,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void controlChange(ShortMessage event) {\n    msg = true;\n    repaint();\n}\n","name":"controlChange","className":"MyDrawPanel","variables":{"msg":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"public Dimension getPreferredSize() {\n    return new Dimension(300, 300);\n}\n","name":"getPreferredSize","className":"MyDrawPanel","variables":{},"constants":{"300":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"random":7,"setColor":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":7,"Graphics2D":1},"expressions":{"IntegerLiteralExpr":11,"ObjectCreationExpr":1,"VariableDeclarationExpr":8,"BinaryExpr":11,"BooleanLiteralExpr":1,"NameExpr":37,"CastExpr":8,"EnclosedExpr":11,"MethodCallExpr":9,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":11},"text":"public void paintComponent(Graphics g) {\n    if (msg) {\n        Graphics2D g2 = (Graphics2D) g;\n        int r = (int) (Math.random() * 250);\n        int gr = (int) (Math.random() * 250);\n        int b = (int) (Math.random() * 250);\n        g.setColor(new Color(r, gr, b));\n        int ht = (int) ((Math.random() * 120) + 10);\n        int width = (int) ((Math.random() * 120) + 10);\n        int x = (int) ((Math.random() * 40) + 10);\n        int y = (int) ((Math.random() * 40) + 10);\n        g.fillRect(x, y, ht, width);\n        msg = false;\n    }\n// close if\n}\n","name":"paintComponent","className":"MyDrawPanel","variables":{"msg":2,"r":2,"b":2,"g":3,"width":1,"x":1,"y":1,"g2":1,"gr":2,"Math":7,"ht":1},"constants":{"false":1,"40":2,"250":3,"120":2,"10":4},"javaDoc":"","comments":"close if ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public JPanel getGuiPanel();\n","name":"getGuiPanel","className":"Service","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":9,"addActionListener":1,"getMonths":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":2,"JButton":1,"DateFormatSymbols":1},"expressions":{"ObjectCreationExpr":13,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"StringLiteralExpr":5,"NameExpr":44,"MethodCallExpr":11,"AssignExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":18},"text":"public JPanel getGuiPanel() {\n    JPanel panel = new JPanel();\n    JButton button = new JButton(\"Do it!\");\n    button.addActionListener(new DoItListener());\n    outputLabel = new JLabel(\"date appears here\");\n    DateFormatSymbols dateStuff = new DateFormatSymbols();\n    month = new JComboBox(dateStuff.getMonths());\n    day = new JTextField(8);\n    year = new JTextField(8);\n    JPanel inputPanel = new JPanel(new GridLayout(3, 2));\n    inputPanel.add(new JLabel(\"Month\"));\n    inputPanel.add(month);\n    inputPanel.add(new JLabel(\"Day\"));\n    inputPanel.add(day);\n    inputPanel.add(new JLabel(\"Year\"));\n    inputPanel.add(year);\n    panel.add(inputPanel);\n    panel.add(button);\n    panel.add(outputLabel);\n    return panel;\n}\n","name":"getGuiPanel","className":"DayOfTheWeekService","variables":{"button":2,"inputPanel":7,"outputLabel":1,"month":1,"year":1,"dateStuff":2,"panel":5,"day":1},"constants":{"\"Do it!\"":1,"2":1,"3":1,"\"date appears here\"":1,"\"Day\"":1,"8":2,"\"Year\"":1,"\"Month\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseInt":2,"set":3,"getText":2,"getTime":1,"getSelectedIndex":1,"getInstance":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Calendar":1,"String":1,"int":3,"Date":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":6,"NameExpr":49,"StringLiteralExpr":1,"FieldAccessExpr":3,"EnclosedExpr":1,"MethodCallExpr":12},"statements":{"ExpressionStmt":10},"text":"public void actionPerformed(ActionEvent ev) {\n    int monthNum = month.getSelectedIndex();\n    int dayNum = Integer.parseInt(day.getText());\n    int yearNum = Integer.parseInt(year.getText());\n    Calendar c = Calendar.getInstance();\n    c.set(Calendar.MONTH, monthNum);\n    c.set(Calendar.DAY_OF_MONTH, dayNum);\n    c.set(Calendar.YEAR, yearNum);\n    Date date = c.getTime();\n    String dayOfWeek = (new SimpleDateFormat(\"EEEE\")).format(date);\n    outputLabel.setText(dayOfWeek);\n}\n","name":"actionPerformed","className":"DoItListener","variables":{"Integer":2,"date":1,"c":5,"dayOfWeek":1,"month":1,"outputLabel":1,"year":1,"Calendar":1,"dayNum":1,"monthNum":1,"day":1,"yearNum":1},"constants":{"\"EEEE\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"SimpleAnimation":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    SimpleAnimation gui = new SimpleAnimation();\n    gui.go();\n}\n","name":"main","className":"SimpleAnimation","variables":{"gui":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"sleep":1,"setSize":1,"getContentPane":1,"setDefaultCloseOperation":1,"repaint":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"MyDrawPanel":1,"JFrame":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":28,"FieldAccessExpr":1,"UnaryExpr":3,"MethodCallExpr":7},"statements":{"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public void go() {\n    JFrame frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    MyDrawPanel drawPanel = new MyDrawPanel();\n    frame.getContentPane().add(drawPanel);\n    frame.setSize(300, 300);\n    frame.setVisible(true);\n    for (int i = 0; i < 130; i++) {\n        x++;\n        y++;\n        drawPanel.repaint();\n        try {\n            Thread.sleep(50);\n        } catch (Exception ex) {\n        }\n    }\n}\n","name":"go","className":"SimpleAnimation","variables":{"drawPanel":2,"ex":1,"x":1,"i":3,"y":1,"frame":5,"Thread":1},"constants":{"0":1,"300":2,"true":1,"50":1,"130":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":2,"fillOval":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"NameExpr":24,"FieldAccessExpr":2,"ThisExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public void paintComponent(Graphics g) {\n    g.setColor(Color.white);\n    g.fillRect(0, 0, this.getWidth(), this.getHeight());\n    g.setColor(Color.green);\n    g.fillOval(x, y, 40, 40);\n}\n","name":"paintComponent","className":"MyDrawPanel","variables":{"g":4},"constants":{"0":2,"40":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MiniMusicPlayer3":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    MiniMusicPlayer3 mini = new MiniMusicPlayer3();\n    mini.go();\n}\n","name":"main","className":"MiniMusicPlayer3","variables":{"mini":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":1,"setContentPane":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"BooleanLiteralExpr":1,"NameExpr":11,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public void setUpGui() {\n    ml = new MyDrawPanel();\n    f.setContentPane(ml);\n    f.setBounds(30, 30, 300, 300);\n    f.setVisible(true);\n}\n","name":"setUpGui","className":"MiniMusicPlayer3","variables":{"f":3,"ml":1},"constants":{"300":2,"true":1,"30":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSequencer":1,"add":3,"setSequence":1,"random":1,"makeEvent":3,"printStackTrace":1,"setTempoInBPM":1,"addControllerEventListener":1,"createTrack":1,"start":1,"setUpGui":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Sequencer":1,"Sequence":1,"Track":1,"int":2},"expressions":{"IntegerLiteralExpr":20,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayInitializerExpr":1,"BinaryExpr":4,"NameExpr":57,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":16,"AssignExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":15},"text":"public void go() {\n    setUpGui();\n    try {\n        // make (and open) a sequencer, make a sequence and track\n        Sequencer sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        sequencer.addControllerEventListener(ml, new int[] { 127 });\n        Sequence seq = new Sequence(Sequence.PPQ, 4);\n        Track track = seq.createTrack();\n        // now make two midi events (containing a midi message)\n        int r = 0;\n        for (int i = 0; i < 60; i += 4) {\n            r = (int) ((Math.random() * 50) + 1);\n            track.add(makeEvent(144, 1, r, 100, i));\n            track.add(makeEvent(176, 1, 127, 0, i));\n            track.add(makeEvent(128, 1, r, 100, i + 2));\n        }\n        // end loop\n        // add the events to the track            \n        // add the sequence to the sequencer, set timing, and start\n        sequencer.setSequence(seq);\n        sequencer.start();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"go","className":"MiniMusicPlayer3","variables":{"r":2,"ex":2,"i":4,"track":4,"Math":1,"MidiSystem":1,"seq":2,"sequencer":6},"constants":{"0":3,"176":1,"1":4,"144":1,"100":2,"2":1,"4":2,"127":2,"128":1,"60":1,"50":1,"120":1},"javaDoc":"","comments":"make (and open) a sequencer make a sequence and track now make two midi events (containing a midi message) end loop add the events to the track add the sequence to the sequencer set timing and start ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"MidiEvent","methodCalls":{"setMessage":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"ShortMessage":1,"MidiEvent":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":1,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"// close go\npublic MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {\n    MidiEvent event = null;\n    try {\n        ShortMessage a = new ShortMessage();\n        a.setMessage(comd, chan, one, two);\n        event = new MidiEvent(a, tick);\n    } catch (Exception e) {\n    }\n    return event;\n}\n","name":"makeEvent","className":"MiniMusicPlayer3","variables":{"a":3,"e":1,"tick":1,"event":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ShortMessage"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":3,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void controlChange(ShortMessage event) {\n    msg = true;\n    repaint();\n}\n","name":"controlChange","className":"MyDrawPanel","variables":{"msg":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"random":7,"setColor":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":7,"Graphics2D":1},"expressions":{"IntegerLiteralExpr":11,"ObjectCreationExpr":1,"VariableDeclarationExpr":8,"BinaryExpr":11,"BooleanLiteralExpr":1,"NameExpr":37,"CastExpr":8,"EnclosedExpr":11,"MethodCallExpr":9,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":11},"text":"public void paintComponent(Graphics g) {\n    if (msg) {\n        Graphics2D g2 = (Graphics2D) g;\n        int r = (int) (Math.random() * 250);\n        int gr = (int) (Math.random() * 250);\n        int b = (int) (Math.random() * 250);\n        g.setColor(new Color(r, gr, b));\n        int ht = (int) ((Math.random() * 120) + 10);\n        int width = (int) ((Math.random() * 120) + 10);\n        int x = (int) ((Math.random() * 40) + 10);\n        int y = (int) ((Math.random() * 40) + 10);\n        g.fillRect(x, y, ht, width);\n        msg = false;\n    }\n// close if\n}\n","name":"paintComponent","className":"MyDrawPanel","variables":{"msg":2,"r":2,"b":2,"g":3,"width":1,"x":1,"y":1,"g2":1,"gr":2,"Math":7,"ht":1},"constants":{"false":1,"40":2,"250":3,"120":2,"10":4},"javaDoc":"","comments":"close if ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"TwoButtons":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    TwoButtons gui = new TwoButtons();\n    gui.go();\n}\n","name":"main","className":"TwoButtons","variables":{"gui":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":4,"setVisible":1,"setSize":1,"addActionListener":2,"getContentPane":4,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MyDrawPanel":1,"JButton":2},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"NameExpr":56,"StringLiteralExpr":3,"FieldAccessExpr":5,"AssignExpr":2,"MethodCallExpr":13},"statements":{"ExpressionStmt":14},"text":"public void go() {\n    frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    JButton labelButton = new JButton(\"Change Label\");\n    labelButton.addActionListener(new LabelButtonListener());\n    JButton colorButton = new JButton(\"Change Circle\");\n    colorButton.addActionListener(new ColorButtonListener());\n    label = new JLabel(\"I'm a label\");\n    MyDrawPanel drawPanel = new MyDrawPanel();\n    frame.getContentPane().add(BorderLayout.SOUTH, colorButton);\n    frame.getContentPane().add(BorderLayout.CENTER, drawPanel);\n    frame.getContentPane().add(BorderLayout.EAST, labelButton);\n    frame.getContentPane().add(BorderLayout.WEST, label);\n    frame.setSize(420, 300);\n    frame.setVisible(true);\n}\n","name":"go","className":"TwoButtons","variables":{"colorButton":2,"drawPanel":1,"labelButton":2,"label":1,"frame":8},"constants":{"\"Change Circle\"":1,"\"Change Label\"":1,"420":1,"\"I'm a label\"":1,"300":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    label.setText(\"Ouch!\");\n}\n","name":"actionPerformed","className":"LabelButtonListener","variables":{"label":1},"constants":{"\"Ouch!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    frame.repaint();\n}\n","name":"actionPerformed","className":"ColorButtonListener","variables":{"frame":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"random":3,"setColor":1,"fillOval":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Color":1,"int":3},"expressions":{"IntegerLiteralExpr":9,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":26,"CastExpr":3,"EnclosedExpr":3,"ThisExpr":2,"MethodCallExpr":8},"statements":{"ExpressionStmt":7},"text":"public void paintComponent(Graphics g) {\n    g.fillRect(0, 0, this.getWidth(), this.getHeight());\n    // make random colors to fill with\n    int red = (int) (Math.random() * 255);\n    int green = (int) (Math.random() * 255);\n    int blue = (int) (Math.random() * 255);\n    Color randomColor = new Color(red, green, blue);\n    g.setColor(randomColor);\n    g.fillOval(70, 70, 100, 100);\n}\n","name":"paintComponent","className":"MyDrawPanel","variables":{"red":2,"randomColor":1,"green":2,"blue":2,"g":3,"Math":3},"constants":{"0":2,"100":2,"255":3,"70":2},"javaDoc":"","comments":"make random colors to fill with ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Animate":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Animate gui = new Animate();\n    gui.go();\n}\n","name":"main","className":"Animate","variables":{"gui":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"sleep":1,"setSize":1,"getContentPane":1,"setDefaultCloseOperation":1,"repaint":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"JFrame":1,"MyDrawP":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":29,"FieldAccessExpr":1,"UnaryExpr":4,"MethodCallExpr":7},"statements":{"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":9},"text":"public void go() {\n    JFrame frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    MyDrawP drawP = new MyDrawP();\n    frame.getContentPane().add(drawP);\n    frame.setSize(500, 270);\n    frame.setVisible(true);\n    for (int i = 0; i < 124; i++, x++, y++) {\n        x++;\n        drawP.repaint();\n        try {\n            Thread.sleep(50);\n        } catch (Exception ex) {\n        }\n    }\n}\n","name":"go","className":"Animate","variables":{"ex":1,"x":2,"i":3,"y":1,"drawP":2,"frame":5,"Thread":1},"constants":{"0":1,"124":1,"500":1,"true":1,"270":1,"50":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":2,"fillRect":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":8,"BinaryExpr":4,"NameExpr":22,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void paintComponent(Graphics g) {\n    g.setColor(Color.white);\n    g.fillRect(0, 0, 500, 250);\n    g.setColor(Color.blue);\n    g.fillRect(x, y, 500 - x * 2, 250 - y * 2);\n}\n","name":"paintComponent","className":"MyDrawP","variables":{"g":4,"x":1,"y":1},"constants":{"0":2,"2":2,"500":2,"250":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getX":2,"getY":2,"getZ":2,"printStackTrace":1,"writeObject":1,"close":2,"System.out.println":2,"readObject":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"FileOutputStream":1,"DungeonGame":1,"ObjectOutputStream":1,"FileInputStream":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":5,"VariableDeclarationExpr":5,"BinaryExpr":4,"NameExpr":47,"StringLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":2,"MethodCallExpr":13,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    DungeonGame d = new DungeonGame();\n    System.out.println(d.getX() + d.getY() + d.getZ());\n    try {\n        FileOutputStream fos = new FileOutputStream(\"dg.ser\");\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(d);\n        oos.close();\n        FileInputStream fis = new FileInputStream(\"dg.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        d = (DungeonGame) ois.readObject();\n        ois.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    System.out.println(d.getX() + d.getY() + d.getZ());\n}\n","name":"main","className":"DungeonTest","variables":{"fis":2,"oos":3,"d":8,"e":2,"ois":3,"fos":2},"constants":{"\"dg.ser\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"int getX() {\n    return x;\n}\n","name":"getX","className":"DungeonGame","variables":{"x":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"long","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"long getY() {\n    return y;\n}\n","name":"getY","className":"DungeonGame","variables":{"y":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"short","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"short getZ() {\n    return z;\n}\n","name":"getZ","className":"DungeonGame","variables":{"z":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new BeatBoxSaveOnly().buildGUI();\n}\n","name":"main","className":"BeatBoxSaveOnly","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":13,"setVisible":1,"setSelected":1,"createEmptyBorder":1,"addActionListener":6,"getContentPane":1,"setBounds":1,"pack":1,"setVgap":1,"setBorder":1,"setDefaultCloseOperation":1,"setHgap":1,"setUpMidi":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JCheckBox":1,"JPanel":1,"GridLayout":1,"BorderLayout":1,"JButton":6,"Box":2,"int":2},"expressions":{"ObjectCreationExpr":22,"IntegerLiteralExpr":16,"VariableDeclarationExpr":14,"ArrayAccessExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":129,"StringLiteralExpr":7,"FieldAccessExpr":6,"UnaryExpr":2,"AssignExpr":3,"MethodCallExpr":30},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":43},"text":"public void buildGUI() {\n    theFrame = new JFrame(\"Cyber BeatBox\");\n    theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    BorderLayout layout = new BorderLayout();\n    JPanel background = new JPanel(layout);\n    background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n    checkboxList = new ArrayList<JCheckBox>();\n    Box buttonBox = new Box(BoxLayout.Y_AXIS);\n    JButton start = new JButton(\"Start\");\n    start.addActionListener(new MyStartListener());\n    buttonBox.add(start);\n    JButton stop = new JButton(\"Stop\");\n    stop.addActionListener(new MyStopListener());\n    buttonBox.add(stop);\n    JButton upTempo = new JButton(\"Tempo Up\");\n    upTempo.addActionListener(new MyUpTempoListener());\n    buttonBox.add(upTempo);\n    JButton downTempo = new JButton(\"Tempo Down\");\n    downTempo.addActionListener(new MyDownTempoListener());\n    buttonBox.add(downTempo);\n    // new button\n    JButton saveIt = new JButton(\"Serialize It\");\n    saveIt.addActionListener(new MySendListener());\n    buttonBox.add(saveIt);\n    // new button\n    JButton restore = new JButton(\"Restore\");\n    restore.addActionListener(new MyReadInListener());\n    buttonBox.add(restore);\n    Box nameBox = new Box(BoxLayout.Y_AXIS);\n    for (int i = 0; i < 16; i++) {\n        nameBox.add(new Label(instrumentNames[i]));\n    }\n    background.add(BorderLayout.EAST, buttonBox);\n    background.add(BorderLayout.WEST, nameBox);\n    theFrame.getContentPane().add(background);\n    GridLayout grid = new GridLayout(16, 16);\n    grid.setVgap(1);\n    grid.setHgap(2);\n    mainPanel = new JPanel(grid);\n    background.add(BorderLayout.CENTER, mainPanel);\n    for (int i = 0; i < 256; i++) {\n        JCheckBox c = new JCheckBox();\n        c.setSelected(false);\n        checkboxList.add(c);\n        mainPanel.add(c);\n    }\n    // end loop\n    setUpMidi();\n    theFrame.setBounds(50, 50, 300, 300);\n    theFrame.pack();\n    theFrame.setVisible(true);\n}\n","name":"buildGUI","className":"BeatBoxSaveOnly","variables":{"BorderFactory":1,"instrumentNames":1,"nameBox":2,"saveIt":2,"c":2,"restore":2,"theFrame":6,"mainPanel":2,"upTempo":2,"start":2,"buttonBox":7,"i":7,"layout":2,"checkboxList":2,"stop":2,"background":5,"grid":4,"downTempo":2},"constants":{"\"Start\"":1,"16":3,"false":1,"0":2,"\"Cyber BeatBox\"":1,"1":1,"\"Stop\"":1,"2":1,"\"Serialize It\"":1,"256":1,"300":2,"\"Restore\"":1,"true":1,"50":2,"\"Tempo Down\"":1,"\"Tempo Up\"":1,"10":4},"javaDoc":"","comments":"end loop new button new button ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSequencer":1,"printStackTrace":1,"setTempoInBPM":1,"createTrack":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"NameExpr":21,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"// close method\npublic void setUpMidi() {\n    try {\n        sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        // sequencer.addMetaEventListener(this);\n        sequence = new Sequence(Sequence.PPQ, 4);\n        track = sequence.createTrack();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"setUpMidi","className":"BeatBoxSaveOnly","variables":{"sequence":2,"e":2,"track":1,"MidiSystem":1,"sequencer":3},"constants":{"4":1,"120":1},"javaDoc":"","comments":"sequencer addMetaEventListener(this); ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"setSequence":1,"setLoopCount":1,"makeEvent":1,"printStackTrace":1,"deleteTrack":1,"setTempoInBPM":1,"createTrack":1,"get":1,"makeTracks":1,"isSelected":1,"start":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"JCheckBox":1,"int[]":1,"int":3},"expressions":{"IntegerLiteralExpr":13,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":4,"NameExpr":55,"UnaryExpr":2,"AssignExpr":4,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":1,"ForStmt":2,"ExpressionStmt":15},"text":"// close method\n/*\n     public class MyCheckBoxListener implements ItemListener {\n        public void itemStateChanged(ItemEvent ev) {      \n           // might add real-time removal or addition, probably not because of timing\n        }\n     } // close inner class\n*/\npublic void buildTrackAndStart() {\n    // this will hold the instruments for each vertical column,\n    // in other words, each tick (may have multiple instruments)\n    int[] trackList = null;\n    sequence.deleteTrack(track);\n    track = sequence.createTrack();\n    for (int i = 0; i < 16; i++) {\n        trackList = new int[16];\n        int key = instruments[i];\n        for (int j = 0; j < 16; j++) {\n            JCheckBox jc = (JCheckBox) checkboxList.get(j + (16 * i));\n            if (jc.isSelected()) {\n                trackList[j] = key;\n            } else {\n                trackList[j] = 0;\n            }\n        }\n        // close inner\n        makeTracks(trackList);\n    }\n    // close outer\n    // - so we always go to full 16 beats \n    track.add(makeEvent(192, 9, 1, 0, 15));\n    try {\n        sequencer.setSequence(sequence);\n        sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);\n        sequencer.start();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"buildTrackAndStart","className":"BeatBoxSaveOnly","variables":{"sequence":2,"instruments":1,"checkboxList":1,"trackList":4,"e":2,"i":5,"jc":2,"j":6,"track":2,"key":2,"sequencer":4},"constants":{"0":4,"1":1,"null":1,"15":1,"16":4,"9":1,"192":1,"120":1},"javaDoc":"","comments":"this will hold the instruments for each vertical column close outer in other words each tick (may have multiple instruments) close inner - so we always go to full 16 beats ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"buildTrackAndStart":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    buildTrackAndStart();\n}\n","name":"actionPerformed","className":"MyStartListener","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"stop":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    sequencer.stop();\n}\n","name":"actionPerformed","className":"MyStopListener","variables":{"sequencer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * 1.03));\n}\n","name":"actionPerformed","className":"MyUpTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{"1.03":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * .97));\n}\n","name":"actionPerformed","className":"MyDownTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{".97":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"printStackTrace":1,"writeObject":1,"get":1,"isSelected":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"JCheckBox":1,"FileOutputStream":1,"boolean[]":1,"ObjectOutputStream":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":3,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":1,"UnaryExpr":1,"AssignExpr":1,"BooleanLiteralExpr":1,"CastExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public void actionPerformed(ActionEvent a) {\n    // make an arraylist of just the STATE of the checkboxes\n    boolean[] checkboxState = new boolean[256];\n    for (int i = 0; i < 256; i++) {\n        JCheckBox check = (JCheckBox) checkboxList.get(i);\n        if (check.isSelected()) {\n            checkboxState[i] = true;\n        }\n    }\n    try {\n        FileOutputStream fileStream = new FileOutputStream(new File(\"Checkbox.ser\"));\n        ObjectOutputStream os = new ObjectOutputStream(fileStream);\n        os.writeObject(checkboxState);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"actionPerformed","className":"MySendListener","variables":{"ex":2,"checkboxList":1,"os":2,"checkboxState":2,"i":4,"check":2,"fileStream":2},"constants":{"0":1,"256":2,"true":1,"\"Checkbox.ser\"":1},"javaDoc":"","comments":"make an arraylist of just the STATE of the checkboxes ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"buildTrackAndStart":1,"printStackTrace":1,"stop":1,"setSelected":2,"get":1,"readObject":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"JCheckBox":1,"boolean[]":1,"FileInputStream":1,"int":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":27,"UnaryExpr":1,"AssignExpr":1,"NullLiteralExpr":1,"BooleanLiteralExpr":2,"CastExpr":2,"MethodCallExpr":7},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":5,"ForStmt":1,"ExpressionStmt":10},"text":"public void actionPerformed(ActionEvent a) {\n    // read in the thing\n    boolean[] checkboxState = null;\n    try {\n        FileInputStream fileIn = new FileInputStream(new File(\"Checkbox.ser\"));\n        ObjectInputStream is = new ObjectInputStream(fileIn);\n        checkboxState = (boolean[]) is.readObject();\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    // now reset the sequence to be this\n    for (int i = 0; i < 256; i++) {\n        JCheckBox check = (JCheckBox) checkboxList.get(i);\n        if (checkboxState[i]) {\n            check.setSelected(true);\n        } else {\n            check.setSelected(false);\n        }\n    }\n    // now stop sequence and restart\n    sequencer.stop();\n    buildTrackAndStart();\n}\n","name":"actionPerformed","className":"MyReadInListener","variables":{"ex":2,"checkboxList":1,"checkboxState":3,"fileIn":2,"i":4,"is":2,"check":3,"sequencer":1},"constants":{"0":1,"256":1,"null":1,"true":1,"false":1,"\"Checkbox.ser\"":1},"javaDoc":"","comments":"read in the thing now reset the sequence to be this now stop sequence and restart ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"add":2,"makeEvent":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":19,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"// close inner class\n//==============================================================       \npublic void makeTracks(int[] list) {\n    for (int i = 0; i < 16; i++) {\n        int key = list[i];\n        if (key != 0) {\n            track.add(makeEvent(144, 9, key, 100, i));\n            track.add(makeEvent(128, 9, key, 100, i + 1));\n        }\n    }\n}\n","name":"makeTracks","className":"BeatBoxSaveOnly","variables":{"i":5,"list":1,"track":2,"key":2},"constants":{"0":2,"144":1,"100":2,"1":1,"16":1,"128":1,"9":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"MidiEvent","methodCalls":{"setMessage":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"ShortMessage":1,"MidiEvent":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":1,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {\n    MidiEvent event = null;\n    try {\n        ShortMessage a = new ShortMessage();\n        a.setMessage(comd, chan, one, two);\n        event = new MidiEvent(a, tick);\n    } catch (Exception e) {\n    }\n    return event;\n}\n","name":"makeEvent","className":"BeatBoxSaveOnly","variables":{"a":3,"e":1,"tick":1,"event":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"QuizCardBuilder":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"// additional, bonus method not found in any book!\npublic static void main(String[] args) {\n    QuizCardBuilder builder = new QuizCardBuilder();\n    builder.go();\n}\n","name":"main","className":"QuizCardBuilder","variables":{"builder":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":9,"setJMenuBar":1,"setVisible":1,"setSize":1,"setVerticalScrollBarPolicy":2,"setHorizontalScrollBarPolicy":2,"addActionListener":3,"getContentPane":1,"setDefaultCloseOperation":1,"setFont":2,"setLineWrap":2,"setWrapStyleWord":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"JScrollPane":2,"JPanel":1,"JButton":1,"JLabel":2,"JMenuItem":2,"Font":1,"JMenuBar":1,"JMenu":1},"expressions":{"ObjectCreationExpr":18,"IntegerLiteralExpr":7,"VariableDeclarationExpr":11,"BooleanLiteralExpr":5,"NameExpr":119,"StringLiteralExpr":8,"FieldAccessExpr":7,"AssignExpr":4,"MethodCallExpr":27},"statements":{"ExpressionStmt":41},"text":"public void go() {\n    // build gui\n    frame = new JFrame(\"Quiz Card Builder\");\n    // title bar\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    JPanel mainPanel = new JPanel();\n    Font bigFont = new Font(\"sanserif\", Font.BOLD, 24);\n    question = new JTextArea(6, 20);\n    question.setLineWrap(true);\n    question.setWrapStyleWord(true);\n    question.setFont(bigFont);\n    JScrollPane qScroller = new JScrollPane(question);\n    qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    answer = new JTextArea(6, 20);\n    answer.setLineWrap(true);\n    answer.setWrapStyleWord(true);\n    answer.setFont(bigFont);\n    JScrollPane aScroller = new JScrollPane(answer);\n    aScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    aScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    JButton nextButton = new JButton(\"Next Card\");\n    cardList = new ArrayList();\n    JLabel qLabel = new JLabel(\"Question:\");\n    JLabel aLabel = new JLabel(\"Answer:\");\n    mainPanel.add(qLabel);\n    mainPanel.add(qScroller);\n    mainPanel.add(aLabel);\n    mainPanel.add(aScroller);\n    mainPanel.add(nextButton);\n    nextButton.addActionListener(new NextCardListener());\n    JMenuBar menuBar = new JMenuBar();\n    JMenu fileMenu = new JMenu(\"File\");\n    JMenuItem newMenuItem = new JMenuItem(\"New\");\n    JMenuItem saveMenuItem = new JMenuItem(\"Save\");\n    newMenuItem.addActionListener(new NewMenuListener());\n    saveMenuItem.addActionListener(new SaveMenuListener());\n    fileMenu.add(newMenuItem);\n    fileMenu.add(saveMenuItem);\n    menuBar.add(fileMenu);\n    frame.setJMenuBar(menuBar);\n    frame.getContentPane().add(BorderLayout.CENTER, mainPanel);\n    frame.setSize(500, 600);\n    frame.setVisible(true);\n}\n","name":"go","className":"QuizCardBuilder","variables":{"question":5,"mainPanel":6,"saveMenuItem":2,"nextButton":2,"cardList":1,"menuBar":2,"aLabel":1,"bigFont":1,"qLabel":1,"answer":5,"aScroller":3,"newMenuItem":2,"qScroller":3,"fileMenu":3,"frame":6},"constants":{"\"Quiz Card Builder\"":1,"\"New\"":1,"24":1,"\"Answer:\"":1,"\"sanserif\"":1,"\"Question:\"":1,"\"Save\"":1,"\"File\"":1,"500":1,"6":2,"600":1,"true":5,"20":2,"\"Next Card\"":1},"javaDoc":"","comments":"build gui title bar ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"add":1,"getText":2,"clearCard":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"QuizCard":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":12,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent ev) {\n    QuizCard card = new QuizCard(question.getText(), answer.getText());\n    cardList.add(card);\n    clearCard();\n}\n","name":"actionPerformed","className":"NextCardListener","variables":{"cardList":1,"question":1,"answer":1,"card":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"add":1,"getSelectedFile":1,"getText":2,"saveFile":1,"showSaveDialog":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1,"QuizCard":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":19,"MethodCallExpr":6},"statements":{"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent ev) {\n    QuizCard card = new QuizCard(question.getText(), answer.getText());\n    cardList.add(card);\n    JFileChooser fileSave = new JFileChooser();\n    fileSave.showSaveDialog(frame);\n    saveFile(fileSave.getSelectedFile());\n}\n","name":"actionPerformed","className":"SaveMenuListener","variables":{"cardList":1,"fileSave":3,"question":1,"answer":1,"card":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"clear":1,"clearCard":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent ev) {\n    cardList.clear();\n    clearCard();\n}\n","name":"actionPerformed","className":"NewMenuListener","variables":{"cardList":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"requestFocus":1,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"StringLiteralExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"private void clearCard() {\n    question.setText(\"\");\n    answer.setText(\"\");\n    question.requestFocus();\n}\n","name":"clearCard","className":"QuizCardBuilder","variables":{"question":2,"answer":1},"constants":{"\"\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["File"],"returnType":"void","methodCalls":{"next":1,"getQuestion":1,"iterator":1,"printStackTrace":1,"getAnswer":1,"hasNext":1,"write":2,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["Casting","ExceptionHandling"],"types":{"Iterator":1,"QuizCard":1,"BufferedWriter":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":33,"CastExpr":1,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":10},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"private void saveFile(File file) {\n    try {\n        BufferedWriter writer = new BufferedWriter(new FileWriter(file));\n        Iterator cardIterator = cardList.iterator();\n        while (cardIterator.hasNext()) {\n            QuizCard card = (QuizCard) cardIterator.next();\n            writer.write(card.getQuestion() + \"/\");\n            writer.write(card.getAnswer() + \"\\n\");\n        }\n        writer.close();\n    } catch (IOException ex) {\n        System.out.println(\"couldn't write the cardList out\");\n        ex.printStackTrace();\n    }\n}\n","name":"saveFile","className":"QuizCardBuilder","variables":{"cardList":1,"file":1,"ex":2,"writer":4,"cardIterator":3,"card":3},"constants":{"\"/\"":1,"\"couldn't write the cardList out\"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String","String"],"returnType":"QuizCard","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public QuizCard(String q, String a) {\n    question = q;\n    answer = a;\n}\n","name":"QuizCard","className":"QuizCard","variables":{"q":1,"a":1,"question":1,"answer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setUniqueID(String id) {\n    uniqueID = id;\n}\n","name":"setUniqueID","className":"QuizCard","variables":{"id":1,"uniqueID":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getUniqueID() {\n    return uniqueID;\n}\n","name":"getUniqueID","className":"QuizCard","variables":{"uniqueID":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setCategory(String c) {\n    category = c;\n}\n","name":"setCategory","className":"QuizCard","variables":{"c":1,"category":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getCategory() {\n    return category;\n}\n","name":"getCategory","className":"QuizCard","variables":{"category":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setQuestion(String q) {\n    question = q;\n}\n","name":"setQuestion","className":"QuizCard","variables":{"q":1,"question":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getQuestion() {\n    return question;\n}\n","name":"getQuestion","className":"QuizCard","variables":{"question":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setAnswer(String a) {\n    answer = a;\n}\n","name":"setAnswer","className":"QuizCard","variables":{"a":1,"answer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getAnswer() {\n    return answer;\n}\n","name":"getAnswer","className":"QuizCard","variables":{"answer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setHint(String h) {\n    hint = h;\n}\n","name":"setHint","className":"QuizCard","variables":{"hint":1,"h":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getHint() {\n    return hint;\n}\n","name":"getHint","className":"QuizCard","variables":{"hint":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":2,"getType":3,"writeObject":3,"close":1,"readObject":3,"System.out.println":3},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"GameCharacter":6,"ObjectOutputStream":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":3,"VariableDeclarationExpr":8,"BinaryExpr":3,"StringLiteralExpr":15,"NameExpr":57,"AssignExpr":3,"NullLiteralExpr":3,"ArrayInitializerExpr":3,"CastExpr":3,"FieldAccessExpr":3,"ArrayCreationExpr":3,"MethodCallExpr":15},"statements":{"TryStmt":2,"BlockStmt":4,"ExpressionStmt":20},"text":"public static void main(String[] args) {\n    GameCharacter one = new GameCharacter(50, \"Elf\", new String[] { \"bow\", \"sword\", \"dust\" });\n    GameCharacter two = new GameCharacter(200, \"Troll\", new String[] { \"bare hands\", \"big axe\" });\n    GameCharacter three = new GameCharacter(120, \"Magician\", new String[] { \"spells\", \"invisibility\" });\n    try {\n        ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"Game.ser\"));\n        os.writeObject(one);\n        os.writeObject(two);\n        os.writeObject(three);\n        os.close();\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n    one = null;\n    two = null;\n    three = null;\n    try {\n        ObjectInputStream is = new ObjectInputStream(new FileInputStream(\"Game.ser\"));\n        GameCharacter oneRestore = (GameCharacter) is.readObject();\n        GameCharacter twoRestore = (GameCharacter) is.readObject();\n        GameCharacter threeRestore = (GameCharacter) is.readObject();\n        System.out.println(\"One's type: \" + oneRestore.getType());\n        System.out.println(\"Two's type: \" + twoRestore.getType());\n        System.out.println(\"Three's type: \" + threeRestore.getType());\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"GameSaverTest","variables":{"oneRestore":2,"ex":4,"os":5,"threeRestore":2,"one":2,"is":4,"two":2,"three":2,"twoRestore":2},"constants":{"\"spells\"":1,"\"Elf\"":1,"\"Magician\"":1,"120":1,"\"Game.ser\"":2,"\"Three's type: \"":1,"\"dust\"":1,"200":1,"\"Two's type: \"":1,"\"invisibility\"":1,"null":3,"\"sword\"":1,"\"Troll\"":1,"\"bow\"":1,"\"bare hands\"":1,"\"big axe\"":1,"50":1,"\"One's type: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","String","String[]"],"returnType":"GameCharacter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public GameCharacter(int p, String t, String[] w) {\n    power = p;\n    type = t;\n    weapons = w;\n}\n","name":"GameCharacter","className":"GameCharacter","variables":{"p":1,"t":1,"w":1,"power":1,"type":1,"weapons":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getPower() {\n    return power;\n}\n","name":"getPower","className":"GameCharacter","variables":{"power":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getType() {\n    return type;\n}\n","name":"getType","className":"GameCharacter","variables":{"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":9,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public String getWeapons() {\n    String weaponList = \"\";\n    for (int i = 0; i < weapons.length; i++) {\n        weaponList += weapons[i] + \" \";\n    }\n    return weaponList;\n}\n","name":"getWeapons","className":"GameCharacter","variables":{"weaponList":3,"i":4,"weapons":1},"constants":{"\"\"":1,"0":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"QuizCardReader":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"// additional, bonus method not found in any book!\npublic static void main(String[] args) {\n    QuizCardReader qReader = new QuizCardReader();\n    qReader.go();\n}\n","name":"main","className":"QuizCardReader","variables":{"qReader":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5,"setJMenuBar":1,"setVisible":1,"setVerticalScrollBarPolicy":1,"addActionListener":2,"getContentPane":1,"setLineWrap":1,"setEditable":1,"setSize":1,"setHorizontalScrollBarPolicy":1,"setDefaultCloseOperation":1,"setFont":1,"setWrapStyleWord":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JScrollPane":1,"JPanel":1,"JMenuItem":1,"Font":1,"JMenuBar":1,"JMenu":1},"expressions":{"ObjectCreationExpr":11,"IntegerLiteralExpr":5,"VariableDeclarationExpr":6,"BooleanLiteralExpr":4,"NameExpr":79,"StringLiteralExpr":5,"FieldAccessExpr":5,"AssignExpr":3,"MethodCallExpr":18},"statements":{"ExpressionStmt":26},"text":"public void go() {\n    frame = new JFrame(\"Quiz Card Player\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    JPanel mainPanel = new JPanel();\n    Font bigFont = new Font(\"sanserif\", Font.BOLD, 24);\n    display = new JTextArea(9, 20);\n    display.setFont(bigFont);\n    display.setLineWrap(true);\n    display.setWrapStyleWord(true);\n    display.setEditable(false);\n    JScrollPane qScroller = new JScrollPane(display);\n    qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    nextButton = new JButton(\"Show Question\");\n    mainPanel.add(qScroller);\n    mainPanel.add(nextButton);\n    nextButton.addActionListener(new NextCardListener());\n    JMenuBar menuBar = new JMenuBar();\n    JMenu fileMenu = new JMenu(\"File\");\n    JMenuItem loadMenuItem = new JMenuItem(\"Load card set\");\n    loadMenuItem.addActionListener(new OpenMenuListener());\n    fileMenu.add(loadMenuItem);\n    menuBar.add(fileMenu);\n    frame.setJMenuBar(menuBar);\n    frame.getContentPane().add(BorderLayout.CENTER, mainPanel);\n    frame.setSize(500, 600);\n    frame.setVisible(true);\n}\n","name":"go","className":"QuizCardReader","variables":{"nextButton":2,"menuBar":2,"bigFont":1,"mainPanel":3,"display":6,"loadMenuItem":2,"qScroller":3,"fileMenu":2,"frame":6},"constants":{"24":1,"\"sanserif\"":1,"\"File\"":1,"\"Load card set\"":1,"500":1,"600":1,"true":3,"false":1,"\"Quiz Card Player\"":1,"9":1,"\"Show Question\"":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getAnswer":1,"showNextCard":1,"disable":1,"hasNext":1,"setText":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":22,"StringLiteralExpr":2,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":4,"ExpressionStmt":6},"text":"public void actionPerformed(ActionEvent ev) {\n    if (isShowAnswer) {\n        // show the answer because they've seen the question\n        display.setText(currentCard.getAnswer());\n        nextButton.setText(\"Next Card\");\n        isShowAnswer = false;\n    } else {\n        // show the next question\n        if (cardIterator.hasNext()) {\n            showNextCard();\n        } else {\n            // there are no more cards!\n            display.setText(\"That was last card\");\n            nextButton.disable();\n        }\n    }\n// close if\n}\n","name":"actionPerformed","className":"NextCardListener","variables":{"nextButton":2,"display":2,"currentCard":1,"isShowAnswer":2,"cardIterator":1},"constants":{"false":1,"\"That was last card\"":1,"\"Next Card\"":1},"javaDoc":"","comments":"close if show the answer because they've seen the question show the next question there are no more cards! ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showOpenDialog":1,"getSelectedFile":1,"loadFile":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent ev) {\n    JFileChooser fileOpen = new JFileChooser();\n    fileOpen.showOpenDialog(frame);\n    loadFile(fileOpen.getSelectedFile());\n}\n","name":"actionPerformed","className":"OpenMenuListener","variables":{"fileOpen":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["File"],"returnType":"void","methodCalls":{"iterator":1,"printStackTrace":1,"showNextCard":1,"readLine":1,"makeCard":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":26,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":3,"MethodCallExpr":7},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"private void loadFile(File file) {\n    cardList = new ArrayList();\n    try {\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            makeCard(line);\n        }\n        reader.close();\n    } catch (Exception ex) {\n        System.out.println(\"couldn't read the card file\");\n        ex.printStackTrace();\n    }\n    // now time to start\n    cardIterator = cardList.iterator();\n    showNextCard();\n}\n","name":"loadFile","className":"QuizCardReader","variables":{"cardList":2,"file":1,"ex":2,"reader":3,"line":2,"cardIterator":1},"constants":{"null":2,"\"couldn't read the card file\"":1},"javaDoc":"","comments":"now time to start ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"hasMoreTokens":1,"nextToken":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringTokenizer":1,"QuizCard":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":14,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"private void makeCard(String lineToParse) {\n    StringTokenizer parser = new StringTokenizer(lineToParse, \"/\");\n    if (parser.hasMoreTokens()) {\n        QuizCard card = new QuizCard(parser.nextToken(), parser.nextToken());\n        cardList.add(card);\n    }\n}\n","name":"makeCard","className":"QuizCardReader","variables":{"cardList":1,"parser":4,"lineToParse":1,"card":1},"constants":{"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"next":1,"getQuestion":1,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":14,"CastExpr":1,"StringLiteralExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"private void showNextCard() {\n    currentCard = (QuizCard) cardIterator.next();\n    display.setText(currentCard.getQuestion());\n    nextButton.setText(\"Show Answer\");\n    isShowAnswer = true;\n}\n","name":"showNextCard","className":"QuizCardReader","variables":{"nextButton":1,"currentCard":2,"display":1,"isShowAnswer":1,"cardIterator":1},"constants":{"\"Show Answer\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"getInputStream":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"InputStreamReader":1,"BufferedReader":1,"String":1,"Socket":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":19,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"public void go() {\n    try {\n        Socket s = new Socket(\"127.0.0.1\", 4242);\n        InputStreamReader streamReader = new InputStreamReader(s.getInputStream());\n        BufferedReader reader = new BufferedReader(streamReader);\n        String advice = reader.readLine();\n        System.out.println(\"Today you should: \" + advice);\n        reader.close();\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"go","className":"DailyAdviceClient","variables":{"s":2,"ex":2,"streamReader":2,"reader":3,"advice":2},"constants":{"4242":1,"\"127.0.0.1\"":1,"\"Today you should: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"DailyAdviceClient":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    DailyAdviceClient client = new DailyAdviceClient();\n    client.go();\n}\n","name":"main","className":"DailyAdviceClient","variables":{"client":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setName":2,"start":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"RunThreads":1,"Thread":2},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"NameExpr":14,"StringLiteralExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    RunThreads runner = new RunThreads();\n    Thread alpha = new Thread(runner);\n    Thread beta = new Thread(runner);\n    alpha.setName(\"Alpha thread\");\n    beta.setName(\"Beta thread\");\n    alpha.start();\n    beta.start();\n}\n","name":"main","className":"RunThreads","variables":{"alpha":3,"runner":3,"beta":3},"constants":{"\"Beta thread\"":1,"\"Alpha thread\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentThread":1,"getName":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    for (int i = 0; i < 25; i++) {\n        String threadName = Thread.currentThread().getName();\n        System.out.println(threadName + \" is running\");\n    }\n}\n","name":"run","className":"RunThreads","variables":{"i":3,"threadName":2,"Thread":1},"constants":{"0":1,"25":1,"\" is running\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"println":1,"printStackTrace":1,"getOutputStream":1,"getAdvice":1,"close":1,"accept":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"ServerSocket":1,"String":1,"Socket":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"NameExpr":24,"FieldAccessExpr":1,"MethodCallExpr":7},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public void go() {\n    try {\n        ServerSocket serverSock = new ServerSocket(4242);\n        while (true) {\n            Socket sock = serverSock.accept();\n            PrintWriter writer = new PrintWriter(sock.getOutputStream());\n            String advice = getAdvice();\n            writer.println(advice);\n            writer.close();\n            System.out.println(advice);\n        }\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"go","className":"DailyAdviceServer","variables":{"sock":2,"ex":2,"advice":1,"writer":3,"serverSock":2},"constants":{"4242":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"random":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"CastExpr":1,"NameExpr":8,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"private String getAdvice() {\n    int random = (int) (Math.random() * adviceList.length);\n    return adviceList[random];\n}\n","name":"getAdvice","className":"DailyAdviceServer","variables":{"random":2,"Math":1,"adviceList":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"DailyAdviceServer":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    DailyAdviceServer server = new DailyAdviceServer();\n    server.go();\n}\n","name":"main","className":"DailyAdviceServer","variables":{"server":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setName":2,"start":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"RyanAndMonicaJob":1,"Thread":2},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"NameExpr":14,"StringLiteralExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    RyanAndMonicaJob theJob = new RyanAndMonicaJob();\n    Thread one = new Thread(theJob);\n    Thread two = new Thread(theJob);\n    one.setName(\"Ryan\");\n    two.setName(\"Monica\");\n    one.start();\n    two.start();\n}\n","name":"main","className":"RyanAndMonicaJob","variables":{"theJob":3,"one":3,"two":3},"constants":{"\"Monica\"":1,"\"Ryan\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getBalance":1,"makeWithdrawal":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    for (int x = 0; x < 10; x++) {\n        makeWithdrawal(10);\n        if (account.getBalance() < 0) {\n            System.out.println(\"Overdrawn!\");\n        }\n    }\n}\n","name":"run","className":"RyanAndMonicaJob","variables":{"x":3,"account":1},"constants":{"0":2,"\"Overdrawn!\"":1,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"sleep":1,"currentThread":5,"getBalance":1,"getName":5,"printStackTrace":1,"System.out.println":5,"withdraw":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling","Synchronization"],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":6,"NameExpr":64,"StringLiteralExpr":5,"FieldAccessExpr":5,"MethodCallExpr":19},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":8},"text":"//  to demonstrate the \"overdrawn\" error remove the \"synchronized\" modifier\nprivate synchronized void makeWithdrawal(int amount) {\n    if (account.getBalance() >= amount) {\n        System.out.println(Thread.currentThread().getName() + \" is about to withdrawal\");\n        try {\n            System.out.println(Thread.currentThread().getName() + \" is going to sleep\");\n            Thread.sleep(500);\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" woke up\");\n        account.withdraw(amount);\n        System.out.println(Thread.currentThread().getName() + \" completes the withdrawal\");\n    } else {\n        System.out.println(\"Sorry, not enough for \" + Thread.currentThread().getName());\n    }\n}\n","name":"makeWithdrawal","className":"RyanAndMonicaJob","variables":{"amount":1,"ex":2,"account":2,"Thread":6},"constants":{"\" woke up\"":1,"\"Sorry, not enough for \"":1,"500":1,"\" is about to withdrawal\"":1,"\" is going to sleep\"":1,"\" completes the withdrawal\"":1},"javaDoc":"","comments":"  to demonstrate the \"overdrawn\" error remove the \"synchronized\" modifier","isEmpty":false,"hasInnerClass":false,"modifier":34}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void withdraw(int amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Socket"],"returnType":"ClientHandler","methodCalls":{"printStackTrace":1,"getInputStream":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"InputStreamReader":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":10,"AssignExpr":2,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public ClientHandler(Socket clientSOcket) {\n    try {\n        sock = clientSOcket;\n        InputStreamReader isReader = new InputStreamReader(sock.getInputStream());\n        reader = new BufferedReader(isReader);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"ClientHandler","className":"ClientHandler","variables":{"sock":2,"ex":2,"clientSOcket":1,"reader":1,"isReader":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"tellEveryone":1,"printStackTrace":1,"readLine":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":4},"text":"public void run() {\n    String message;\n    try {\n        while ((message = reader.readLine()) != null) {\n            System.out.println(\"read \" + message);\n            tellEveryone(message);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"run","className":"ClientHandler","variables":{"ex":2,"reader":1,"message":3},"constants":{"\"read \"":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new VerySimpleChatServer().go();\n}\n","name":"main","className":"VerySimpleChatServer","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"printStackTrace":1,"start":1,"getOutputStream":1,"accept":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"ServerSocket":1,"Socket":1,"PrintWriter":1,"Thread":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public void go() {\n    clientOutputStreams = new ArrayList();\n    try {\n        ServerSocket serverSock = new ServerSocket(5000);\n        while (true) {\n            Socket clientSocket = serverSock.accept();\n            PrintWriter writer = new PrintWriter(clientSocket.getOutputStream());\n            clientOutputStreams.add(writer);\n            Thread t = new Thread(new ClientHandler(clientSocket));\n            t.start();\n            System.out.println(\"got a connection\");\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"go","className":"VerySimpleChatServer","variables":{"clientSocket":3,"ex":2,"t":2,"clientOutputStreams":2,"writer":1,"serverSock":2},"constants":{"5000":1,"true":1,"\"got a connection\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"println":1,"flush":1,"printStackTrace":1,"hasNext":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"Iterator":1,"PrintWriter":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":19,"CastExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":5},"text":"public void tellEveryone(String message) {\n    Iterator it = clientOutputStreams.iterator();\n    while (it.hasNext()) {\n        try {\n            PrintWriter writer = (PrintWriter) it.next();\n            writer.println(message);\n            writer.flush();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n","name":"tellEveryone","className":"VerySimpleChatServer","variables":{"ex":2,"clientOutputStreams":1,"it":3,"writer":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3,"setVisible":1,"setSize":1,"addActionListener":1,"getContentPane":1,"setUpNetworking":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"JFrame":1,"JButton":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"StringLiteralExpr":2,"NameExpr":29,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":8},"statements":{"ExpressionStmt":11},"text":"public void go() {\n    JFrame frame = new JFrame(\"Ludicrously Simple Chat Client\");\n    JPanel mainPanel = new JPanel();\n    outgoing = new JTextField(20);\n    JButton sendButton = new JButton(\"Send\");\n    sendButton.addActionListener(new SendButtonListener());\n    mainPanel.add(outgoing);\n    mainPanel.add(sendButton);\n    frame.getContentPane().add(BorderLayout.CENTER, mainPanel);\n    setUpNetworking();\n    frame.setSize(400, 500);\n    frame.setVisible(true);\n}\n","name":"go","className":"SimpleChatClientA","variables":{"outgoing":1,"mainPanel":3,"frame":4,"sendButton":2},"constants":{"400":1,"500":1,"true":1,"\"Ludicrously Simple Chat Client\"":1,"\"Send\"":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"getOutputStream":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":1,"AssignExpr":2,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"private void setUpNetworking() {\n    try {\n        sock = new Socket(\"127.0.0.1\", 5000);\n        writer = new PrintWriter(sock.getOutputStream());\n        System.out.println(\"networking established\");\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"setUpNetworking","className":"SimpleChatClientA","variables":{"sock":2,"ex":2,"writer":1},"constants":{"5000":1,"\"127.0.0.1\"":1,"\"networking established\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"println":1,"requestFocus":1,"flush":1,"printStackTrace":1,"getText":1,"setText":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":18,"StringLiteralExpr":1,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent ev) {\n    try {\n        writer.println(outgoing.getText());\n        writer.flush();\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    outgoing.setText(\"\");\n    outgoing.requestFocus();\n}\n","name":"actionPerformed","className":"SendButtonListener","variables":{"outgoing":3,"ex":2,"writer":2},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new SimpleChatClientA().go();\n}\n","name":"main","className":"SimpleChatClientA","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":4,"setVisible":1,"setEditable":1,"setSize":1,"setVerticalScrollBarPolicy":1,"setHorizontalScrollBarPolicy":1,"addActionListener":1,"start":1,"getContentPane":1,"setUpNetworking":1,"setLineWrap":1,"setWrapStyleWord":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JScrollPane":1,"JPanel":1,"JFrame":1,"JButton":1,"Thread":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":5,"VariableDeclarationExpr":5,"BooleanLiteralExpr":4,"StringLiteralExpr":2,"NameExpr":59,"FieldAccessExpr":3,"AssignExpr":2,"MethodCallExpr":15},"statements":{"ExpressionStmt":21},"text":"public void go() {\n    JFrame frame = new JFrame(\"Ludicrously Simple Chat Client\");\n    JPanel mainPanel = new JPanel();\n    incoming = new JTextArea(15, 50);\n    incoming.setLineWrap(true);\n    incoming.setWrapStyleWord(true);\n    incoming.setEditable(false);\n    JScrollPane qScroller = new JScrollPane(incoming);\n    qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);\n    outgoing = new JTextField(20);\n    JButton sendButton = new JButton(\"Send\");\n    sendButton.addActionListener(new SendButtonListener());\n    mainPanel.add(qScroller);\n    mainPanel.add(outgoing);\n    mainPanel.add(sendButton);\n    frame.getContentPane().add(BorderLayout.CENTER, mainPanel);\n    setUpNetworking();\n    Thread readerThread = new Thread(new IncomingReader());\n    readerThread.start();\n    frame.setSize(650, 500);\n    frame.setVisible(true);\n}\n","name":"go","className":"SimpleChatClient","variables":{"incoming":5,"outgoing":1,"readerThread":2,"mainPanel":4,"qScroller":3,"frame":4,"sendButton":2},"constants":{"650":1,"15":1,"500":1,"true":3,"false":1,"\"Ludicrously Simple Chat Client\"":1,"50":1,"\"Send\"":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"getOutputStream":1,"getInputStream":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"InputStreamReader":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":18,"StringLiteralExpr":2,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"private void setUpNetworking() {\n    try {\n        sock = new Socket(\"127.0.0.1\", 5000);\n        InputStreamReader streamReader = new InputStreamReader(sock.getInputStream());\n        reader = new BufferedReader(streamReader);\n        writer = new PrintWriter(sock.getOutputStream());\n        System.out.println(\"networking established\");\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"setUpNetworking","className":"SimpleChatClient","variables":{"sock":3,"ex":2,"streamReader":2,"reader":1,"writer":1},"constants":{"5000":1,"\"127.0.0.1\"":1,"\"networking established\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"println":1,"requestFocus":1,"flush":1,"printStackTrace":1,"getText":1,"setText":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":18,"StringLiteralExpr":1,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent ev) {\n    try {\n        writer.println(outgoing.getText());\n        writer.flush();\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    outgoing.setText(\"\");\n    outgoing.requestFocus();\n}\n","name":"actionPerformed","className":"SendButtonListener","variables":{"outgoing":3,"ex":2,"writer":2},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new SimpleChatClient().go();\n}\n","name":"main","className":"SimpleChatClient","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"append":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":17,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":4},"text":"public void run() {\n    String message;\n    try {\n        while ((message = reader.readLine()) != null) {\n            System.out.println(\"client read \" + message);\n            incoming.append(message + \"\\n\");\n        }\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"run","className":"IncomingReader","variables":{"incoming":1,"ex":2,"reader":1,"message":4},"constants":{"null":1,"\"client read \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void run() {\n    go();\n}\n","name":"run","className":"MyRunnable","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"printStackTrace":1,"doMore":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":8,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public void go() {\n    //*\n    try {\n        Thread.sleep(2000);\n    } catch (InterruptedException ex) {\n        ex.printStackTrace();\n    }\n    //*/\n    doMore();\n}\n","name":"go","className":"MyRunnable","variables":{"ex":2,"Thread":1},"constants":{"2000":1},"javaDoc":"","comments":"/  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void doMore() {\n    System.out.println(\"top o' the stack\");\n}\n","name":"doMore","className":"MyRunnable","variables":{},"constants":{"\"top o' the stack\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"MyRunnable":1,"Runnable":1,"Thread":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    Runnable threadJob = new MyRunnable();\n    Thread myThread = new Thread(threadJob);\n    myThread.start();\n    System.out.println(\"back in main\");\n}\n","name":"main","className":"MyRunnable","variables":{"threadJob":2,"myThread":2},"constants":{"\"back in main\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"bark":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Dog[]":1,"Dog":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":9,"VariableDeclarationExpr":3,"ArrayAccessExpr":7,"BinaryExpr":2,"NameExpr":39,"StringLiteralExpr":4,"FieldAccessExpr":7,"ArrayCreationExpr":1,"MethodCallExpr":4,"AssignExpr":7},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    Dog dog1 = new Dog();\n    dog1.bark();\n    dog1.name = \"Bart\";\n    Dog[] myDogs = new Dog[3];\n    myDogs[0] = new Dog();\n    myDogs[1] = new Dog();\n    myDogs[2] = dog1;\n    myDogs[0].name = \"Fred\";\n    myDogs[1].name = \"Marge\";\n    System.out.print(\"last don't name is \");\n    System.out.println(myDogs[2].name);\n    int x = 0;\n    while (x < myDogs.length) {\n        myDogs[x].bark();\n        x = x + 1;\n    }\n}\n","name":"main","className":"Dog","variables":{"x":5,"dog1":3,"myDogs":8},"constants":{"0":3,"1":3,"\"Fred\"":1,"2":2,"3":1,"\"last don't name is \"":1,"\"Bart\"":1,"\"Marge\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void bark() {\n    System.out.println(name + \" says Ruff!\");\n}\n","name":"bark","className":"Dog","variables":{"name":1},"constants":{"\" says Ruff!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void eat() {\n}\n","name":"eat","className":"Dog","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void chaseCat() {\n}\n","name":"chaseCat","className":"Dog","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"startGame":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"GuessGame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    GuessGame game = new GuessGame();\n    game.startGame();\n}\n","name":"main","className":"GameLauncher","variables":{"game":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"random":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":10,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void guess() {\n    number = (int) (Math.random() * 10);\n    System.out.println(\"I'm guessing \" + number);\n}\n","name":"guess","className":"Player","variables":{"number":2,"Math":1},"constants":{"\"I'm guessing \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"random":1,"guess":3,"System.out.println":11},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":3,"int":4},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":4,"VariableDeclarationExpr":7,"BooleanLiteralExpr":7,"BinaryExpr":13,"NameExpr":101,"CastExpr":1,"StringLiteralExpr":11,"FieldAccessExpr":14,"EnclosedExpr":1,"AssignExpr":9,"MethodCallExpr":15},"statements":{"IfStmt":4,"WhileStmt":1,"BreakStmt":1,"BlockStmt":6,"ExpressionStmt":30},"text":"public void startGame() {\n    p1 = new Player();\n    p2 = new Player();\n    p3 = new Player();\n    int guessp1 = 0;\n    int guessp2 = 0;\n    int guessp3 = 0;\n    boolean p1isRight = false;\n    boolean p2isRight = false;\n    boolean p3isRight = false;\n    int targetNumber = (int) (Math.random() * 10);\n    System.out.println(\"I'm thinking of a number between 0 and 9...\");\n    while (true) {\n        System.out.println(\"Number to guess is \" + targetNumber);\n        p1.guess();\n        p2.guess();\n        p3.guess();\n        guessp1 = p1.number;\n        System.out.println(\"Player one guessed \" + guessp1);\n        guessp2 = p2.number;\n        System.out.println(\"Player two guessed \" + guessp2);\n        guessp3 = p3.number;\n        System.out.println(\"Player three guessed \" + guessp3);\n        if (guessp1 == targetNumber) {\n            p1isRight = true;\n        }\n        if (guessp2 == targetNumber) {\n            p2isRight = true;\n        }\n        if (guessp3 == targetNumber) {\n            p3isRight = true;\n        }\n        if (p1isRight || p2isRight || p3isRight) {\n            System.out.println(\"We have a winner!\");\n            System.out.println(\"Player one got it right? \" + p1isRight);\n            System.out.println(\"Player two got it right? \" + p2isRight);\n            System.out.println(\"Player three got it right? \" + p3isRight);\n            System.out.println(\"Game is over\");\n            break;\n        } else {\n            System.out.println(\"Players will have to try again.\");\n        }\n    }\n}\n","name":"startGame","className":"GuessGame","variables":{"p1":2,"targetNumber":5,"p2":2,"p3":2,"p3isRight":4,"guessp3":4,"guessp1":4,"guessp2":4,"p1isRight":4,"p2isRight":4,"Math":1},"constants":{"\"Player three guessed \"":1,"\"Player three got it right? \"":1,"\"Player two guessed \"":1,"\"We have a winner!\"":1,"\"Number to guess is \"":1,"\"Player one guessed \"":1,"false":3,"0":3,"\"I'm thinking of a number between 0 and 9...\"":1,"true":4,"\"Players will have to try again.\"":1,"\"Player two got it right? \"":1,"\"Game is over\"":1,"10":1,"\"Player one got it right? \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new Jukebox6().go();\n}\n","name":"main","className":"Jukebox6","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"addAll":1,"sort":1,"getSongs":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"HashSet<SongBad>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":28,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public void go() {\n    getSongs();\n    System.out.println(songList);\n    Collections.sort(songList);\n    System.out.println(songList);\n    HashSet<SongBad> songSet = new HashSet<SongBad>();\n    songSet.addAll(songList);\n    System.out.println(songSet);\n}\n","name":"go","className":"Jukebox6","variables":{"songSet":2,"Collections":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"addSong":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"File":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"void getSongs() {\n    try {\n        File file = new File(\"SongListMore.txt\");\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            addSong(line);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"getSongs","className":"Jukebox6","variables":{"file":2,"ex":2,"reader":2,"line":2},"constants":{"\"SongListMore.txt\"":1,"null":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"SongBad":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"void addSong(String lineToParse) {\n    String[] tokens = lineToParse.split(\"/\");\n    SongBad nextSong = new SongBad(tokens[0], tokens[1], tokens[2], tokens[3]);\n    songList.add(nextSong);\n}\n","name":"addSong","className":"Jukebox6","variables":{"lineToParse":1,"tokens":5,"songList":1,"nextSong":1},"constants":{"0":1,"1":1,"2":1,"3":1,"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String","String","String","String"],"returnType":"SongBad","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public SongBad(String t, String a, String r, String b) {\n    title = t;\n    artist = a;\n    rating = r;\n    bpm = b;\n}\n","name":"SongBad","className":"SongBad","variables":{"a":1,"r":1,"b":1,"t":1,"artist":1,"rating":1,"title":1,"bpm":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getTitle":2,"equals":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"SongBad":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":8,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean equals(Object aSong) {\n    SongBad s = (SongBad) aSong;\n    return getTitle().equals(s.getTitle());\n}\n","name":"equals","className":"SongBad","variables":{"s":2,"aSong":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["SongBad"],"returnType":"int","methodCalls":{"getTitle":1,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"//leaving this out makes this a bad form of song.  Uncomment this to get rid of the duplicates\n/*public int hashCode() {\n        return title.hashCode();\n    }\n    */\npublic int compareTo(SongBad s) {\n    return title.compareTo(s.getTitle());\n}\n","name":"compareTo","className":"SongBad","variables":{"s":1,"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getArtist() {\n    return artist;\n}\n","name":"getArtist","className":"SongBad","variables":{"artist":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getBpm() {\n    return bpm;\n}\n","name":"getBpm","className":"SongBad","variables":{"bpm":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getRating() {\n    return rating;\n}\n","name":"getRating","className":"SongBad","variables":{"rating":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getTitle() {\n    return title;\n}\n","name":"getTitle","className":"SongBad","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return title;\n}\n","name":"toString","className":"SongBad","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new Jukebox3().go();\n}\n","name":"main","className":"Jukebox3","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"sort":1,"getSongs":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":18,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void go() {\n    getSongs();\n    System.out.println(songList);\n    Collections.sort(songList);\n    System.out.println(songList);\n}\n","name":"go","className":"Jukebox3","variables":{"Collections":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"addSong":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"File":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"void getSongs() {\n    try {\n        File file = new File(\"SongList.txt\");\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            addSong(line);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"getSongs","className":"Jukebox3","variables":{"file":2,"ex":2,"reader":2,"line":2},"constants":{"null":2,"\"SongList.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Song":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"void addSong(String lineToParse) {\n    String[] tokens = lineToParse.split(\"/\");\n    Song nextSong = new Song(tokens[0], tokens[1], tokens[2], tokens[3]);\n    songList.add(nextSong);\n}\n","name":"addSong","className":"Jukebox3","variables":{"lineToParse":1,"tokens":5,"songList":1,"nextSong":1},"constants":{"0":1,"1":1,"2":1,"3":1,"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new Jukebox1().go();\n}\n","name":"main","className":"Jukebox1","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSongs":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void go() {\n    getSongs();\n    System.out.println(songList);\n}\n","name":"go","className":"Jukebox1","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"addSong":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"File":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"void getSongs() {\n    try {\n        File file = new File(\"SongList.txt\");\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            addSong(line);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"getSongs","className":"Jukebox1","variables":{"file":2,"ex":2,"reader":2,"line":2},"constants":{"null":2,"\"SongList.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":7,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"void addSong(String lineToParse) {\n    String[] tokens = lineToParse.split(\"/\");\n    songList.add(tokens[0]);\n}\n","name":"addSong","className":"Jukebox1","variables":{"lineToParse":1,"tokens":2,"songList":1},"constants":{"0":1,"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new Jukebox8().go();\n}\n","name":"main","className":"Jukebox8","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"addAll":1,"sort":1,"getSongs":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"TreeSet<Song>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":28,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public void go() {\n    getSongs();\n    System.out.println(songList);\n    Collections.sort(songList);\n    System.out.println(songList);\n    TreeSet<Song> songSet = new TreeSet<Song>();\n    songSet.addAll(songList);\n    System.out.println(songSet);\n}\n","name":"go","className":"Jukebox8","variables":{"songSet":2,"Collections":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"addSong":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"File":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"void getSongs() {\n    try {\n        File file = new File(\"SongListMore.txt\");\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            addSong(line);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"getSongs","className":"Jukebox8","variables":{"file":2,"ex":2,"reader":2,"line":2},"constants":{"\"SongListMore.txt\"":1,"null":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Song":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"void addSong(String lineToParse) {\n    String[] tokens = lineToParse.split(\"/\");\n    Song nextSong = new Song(tokens[0], tokens[1], tokens[2], tokens[3]);\n    songList.add(nextSong);\n}\n","name":"addSong","className":"Jukebox8","variables":{"lineToParse":1,"tokens":5,"songList":1,"nextSong":1},"constants":{"0":1,"1":1,"2":1,"3":1,"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new Jukebox5().go();\n}\n","name":"main","className":"Jukebox5","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Song","Song"],"returnType":"int","methodCalls":{"getArtist":2,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"MethodCallExpr":3},"statements":{"ReturnStmt":1},"text":"public int compare(Song one, Song two) {\n    return one.getArtist().compareTo(two.getArtist());\n}\n","name":"compare","className":"ArtistCompare","variables":{"one":1,"two":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sort":2,"getSongs":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArtistCompare":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":29,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public void go() {\n    getSongs();\n    System.out.println(songList);\n    Collections.sort(songList);\n    System.out.println(songList);\n    ArtistCompare artistCompare = new ArtistCompare();\n    Collections.sort(songList, artistCompare);\n    System.out.println(songList);\n}\n","name":"go","className":"Jukebox5","variables":{"artistCompare":1,"Collections":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1,"readLine":1,"addSong":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"File":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"void getSongs() {\n    try {\n        File file = new File(\"SongListMore.txt\");\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            addSong(line);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"getSongs","className":"Jukebox5","variables":{"file":2,"ex":2,"reader":2,"line":2},"constants":{"\"SongListMore.txt\"":1,"null":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Song":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"void addSong(String lineToParse) {\n    String[] tokens = lineToParse.split(\"/\");\n    Song nextSong = new Song(tokens[0], tokens[1], tokens[2], tokens[3]);\n    songList.add(nextSong);\n}\n","name":"addSong","className":"Jukebox5","variables":{"lineToParse":1,"tokens":5,"songList":1,"nextSong":1},"constants":{"0":1,"1":1,"2":1,"3":1,"\"/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String","String","String","String"],"returnType":"Song","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public Song(String t, String a, String r, String b) {\n    title = t;\n    artist = a;\n    rating = r;\n    bpm = b;\n}\n","name":"Song","className":"Song","variables":{"a":1,"r":1,"b":1,"t":1,"artist":1,"rating":1,"title":1,"bpm":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getTitle":2,"equals":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Song":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":8,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean equals(Object aSong) {\n    Song s = (Song) aSong;\n    return getTitle().equals(s.getTitle());\n}\n","name":"equals","className":"Song","variables":{"s":2,"aSong":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"hashCode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int hashCode() {\n    return title.hashCode();\n}\n","name":"hashCode","className":"Song","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Song"],"returnType":"int","methodCalls":{"getTitle":1,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public int compareTo(Song s) {\n    return title.compareTo(s.getTitle());\n}\n","name":"compareTo","className":"Song","variables":{"s":1,"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getArtist() {\n    return artist;\n}\n","name":"getArtist","className":"Song","variables":{"artist":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getBpm() {\n    return bpm;\n}\n","name":"getBpm","className":"Song","variables":{"bpm":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getRating() {\n    return rating;\n}\n","name":"getRating","className":"Song","variables":{"rating":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getTitle() {\n    return title;\n}\n","name":"getTitle","className":"Song","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return title;\n}\n","name":"toString","className":"Song","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":1,"setLocationCells":1,"checkYourself":1,"equals":1,"getUserInput":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"GameHelper":1,"SimpleDotCom":1,"boolean":1,"int[]":1,"String":2,"int":2},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":2,"VariableDeclarationExpr":8,"BinaryExpr":6,"NameExpr":29,"StringLiteralExpr":4,"UnaryExpr":1,"AssignExpr":1,"ArrayInitializerExpr":1,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    int numOfGuesses = 0;\n    GameHelper helper = new GameHelper();\n    SimpleDotCom theDotCom = new SimpleDotCom();\n    int randomNum = (int) (Math.random() * 5);\n    int[] locations = { randomNum, randomNum + 1, randomNum + 2 };\n    theDotCom.setLocationCells(locations);\n    boolean isAlive = true;\n    while (isAlive == true) {\n        String guess = helper.getUserInput(\"enter a number\");\n        String result = theDotCom.checkYourself(guess);\n        numOfGuesses++;\n        if (result.equals(\"kill\")) {\n            isAlive = false;\n            System.out.println(\"You took \" + numOfGuesses + \" guesses\");\n        }\n    }\n}\n","name":"main","className":"Game","variables":{"result":2,"isAlive":3,"numOfGuesses":3,"helper":2,"theDotCom":3,"guess":1,"locations":1,"Math":1,"randomNum":4},"constants":{"0":1,"1":1,"2":1,"5":1,"true":2,"false":1,"\"kill\"":1,"\"You took \"":1,"\"enter a number\"":1,"\" guesses\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setLocationCells":1,"checkYourself":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"SimpleDotCom":1,"int[]":1,"String":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"NameExpr":8,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    SimpleDotCom dot = new SimpleDotCom();\n    int[] locations = { 2, 3, 4 };\n    dot.setLocationCells(locations);\n    String userGuess = \"2\";\n    String result = dot.checkYourself(userGuess);\n}\n","name":"main","className":"SimpleDotComTester","variables":{"result":1,"userGuess":1,"dot":3,"locations":1},"constants":{"2":1,"\"2\"":1,"3":1,"4":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setLocationCells(int[] locs) {\n    locationCells = locs;\n}\n","name":"setLocationCells","className":"SimpleDotCom","variables":{"locs":1,"locationCells":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"parseInt":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":2},"expressions":{"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":2},"statements":{"IfStmt":2,"BreakStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"public String checkYourself(String stringGuess) {\n    int guess = Integer.parseInt(stringGuess);\n    String result = \"miss\";\n    for (int cell : locationCells) {\n        if (guess == cell) {\n            result = \"hit\";\n            numOfHits++;\n            break;\n        }\n    }\n    if (numOfHits == locationCells.length) {\n        result = \"kill\";\n    }\n    System.out.println(result);\n    return result;\n}\n","name":"checkYourself","className":"SimpleDotCom","variables":{"Integer":1,"result":4,"locationCells":1,"guess":2,"numOfHits":2,"cell":2},"constants":{"\"miss\"":1,"\"kill\"":1,"\"hit\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"toLowerCase":1,"length":1,"readLine":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":25,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":5},"text":"public String getUserInput(String prompt) {\n    String inputLine = null;\n    System.out.print(prompt + \"  \");\n    try {\n        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n        inputLine = is.readLine();\n        if (inputLine.length() == 0)\n            return null;\n    } catch (IOException e) {\n        System.out.println(\"IOException: \" + e);\n    }\n    return inputLine.toLowerCase();\n}\n","name":"getUserInput","className":"GameHelper","variables":{"inputLine":4,"e":2,"is":2,"prompt":1},"constants":{"0":1,"null":2,"\"IOException: \"":1,"\"  \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"ArrayList<String>","methodCalls":{"add":1,"random":1,"valueOf":1,"toString":1,"concat":1,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int[]":1,"ArrayList<String>":1,"String[]":1,"String":1,"int":7},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":14,"VariableDeclarationExpr":12,"ArrayAccessExpr":6,"BinaryExpr":16,"NameExpr":65,"UnaryExpr":5,"AssignExpr":12,"NullLiteralExpr":1,"BooleanLiteralExpr":5,"CastExpr":2,"EnclosedExpr":4,"ArrayCreationExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":4,"WhileStmt":3,"BlockStmt":8,"ReturnStmt":1,"ExpressionStmt":27},"text":"public ArrayList<String> placeDotCom(int comSize) {\n    // line 19\n    ArrayList<String> alphaCells = new ArrayList<String>();\n    // holds 'f6' type coords\n    String[] alphacoords = new String[comSize];\n    // temporary String for concat\n    String temp = null;\n    // current candidate coords\n    int[] coords = new int[comSize];\n    // current attempts counter\n    int attempts = 0;\n    // flag = found a good location ?\n    boolean success = false;\n    // current starting location\n    int location = 0;\n    // nth dot com to place\n    comCount++;\n    // set horizontal increment\n    int incr = 1;\n    if ((comCount % 2) == 1) {\n        // if odd dot com  (place vertically)\n        // set vertical increment\n        incr = gridLength;\n    }\n    while (!success & attempts++ < 200) {\n        // main search loop  (32)\n        // get random starting point\n        location = (int) (Math.random() * gridSize);\n        //System.out.print(\" try \" + location);\n        // nth position in dotcom to place\n        int x = 0;\n        // assume success\n        success = true;\n        while (success && x < comSize) {\n            // look for adjacent unused spots\n            if (grid[location] == 0) {\n                // if not already used\n                // save location\n                coords[x++] = location;\n                // try 'next' adjacent\n                location += incr;\n                if (location >= gridSize) {\n                    // out of bounds - 'bottom'\n                    // failure\n                    success = false;\n                }\n                if (x > 0 & (location % gridLength == 0)) {\n                    // out of bounds - right edge\n                    // failure\n                    success = false;\n                }\n            } else {\n                // found already used location\n                // System.out.print(\" used \" + location);  \n                // failure\n                success = false;\n            }\n        }\n    }\n    // end while\n    // turn good location into alpha coords\n    int x = 0;\n    int row = 0;\n    int column = 0;\n    // System.out.println(\"\\n\");\n    while (x < comSize) {\n        // mark master grid pts. as 'used'\n        grid[coords[x]] = 1;\n        // get row value\n        row = (int) (coords[x] / gridLength);\n        // get numeric column value\n        column = coords[x] % gridLength;\n        // convert to alpha\n        temp = String.valueOf(alphabet.charAt(column));\n        alphaCells.add(temp.concat(Integer.toString(row)));\n        x++;\n    // System.out.print(\"  coord \"+x+\" = \" + alphaCells.get(x-1));\n    }\n    return alphaCells;\n}\n","name":"placeDotCom","className":"GameHelper","variables":{"temp":3,"comCount":2,"incr":3,"column":2,"String":1,"alphabet":1,"Math":1,"gridLength":4,"Integer":1,"gridSize":2,"alphacoords":1,"success":7,"grid":2,"alphaCells":3,"comSize":4,"x":10,"location":7,"row":2,"coords":5,"attempts":2},"constants":{"0":9,"1":3,"2":1,"200":1,"null":1,"false":4,"true":1},"javaDoc":"","comments":"end while System out println(\"\\n\"); line 19 holds 'f6' type coords temporary String for concat current candidate coords current attempts counter flag = found a good location ? current starting location nth dot com to place set horizontal increment if odd dot com (place vertically) set vertical increment main search loop (32) System out print(\" try \" + location); get random starting point nth position in dotcom to place assume success look for adjacent unused spots if not already used save location try 'next' adjacent out of bounds - 'bottom' failure out of bounds - right edge failure found already used location System out print(\" used \" + location); failure turn good location into alpha coords System out println(\"\\n\"); System out print(\" coord \"+x+\" = \" + alphaCells get(x-1)); mark master grid pts as 'used' get row value get numeric column value convert to alpha ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new BeatBox().buildGUI();\n}\n","name":"main","className":"BeatBox","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":11,"setVisible":1,"setSelected":1,"createEmptyBorder":1,"addActionListener":4,"getContentPane":1,"setBounds":1,"pack":1,"setVgap":1,"setBorder":1,"setDefaultCloseOperation":1,"setHgap":1,"setUpMidi":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JCheckBox":1,"JPanel":1,"GridLayout":1,"BorderLayout":1,"JButton":4,"Box":2,"int":2},"expressions":{"ObjectCreationExpr":18,"IntegerLiteralExpr":16,"VariableDeclarationExpr":12,"ArrayAccessExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":115,"StringLiteralExpr":5,"FieldAccessExpr":6,"UnaryExpr":2,"AssignExpr":3,"MethodCallExpr":26},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":37},"text":"public void buildGUI() {\n    theFrame = new JFrame(\"Cyber BeatBox\");\n    theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    BorderLayout layout = new BorderLayout();\n    JPanel background = new JPanel(layout);\n    background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n    checkboxList = new ArrayList<JCheckBox>();\n    Box buttonBox = new Box(BoxLayout.Y_AXIS);\n    JButton start = new JButton(\"Start\");\n    start.addActionListener(new MyStartListener());\n    buttonBox.add(start);\n    JButton stop = new JButton(\"Stop\");\n    stop.addActionListener(new MyStopListener());\n    buttonBox.add(stop);\n    JButton upTempo = new JButton(\"Tempo Up\");\n    upTempo.addActionListener(new MyUpTempoListener());\n    buttonBox.add(upTempo);\n    JButton downTempo = new JButton(\"Tempo Down\");\n    downTempo.addActionListener(new MyDownTempoListener());\n    buttonBox.add(downTempo);\n    Box nameBox = new Box(BoxLayout.Y_AXIS);\n    for (int i = 0; i < 16; i++) {\n        nameBox.add(new Label(instrumentNames[i]));\n    }\n    background.add(BorderLayout.EAST, buttonBox);\n    background.add(BorderLayout.WEST, nameBox);\n    theFrame.getContentPane().add(background);\n    GridLayout grid = new GridLayout(16, 16);\n    grid.setVgap(1);\n    grid.setHgap(2);\n    mainPanel = new JPanel(grid);\n    background.add(BorderLayout.CENTER, mainPanel);\n    for (int i = 0; i < 256; i++) {\n        JCheckBox c = new JCheckBox();\n        c.setSelected(false);\n        checkboxList.add(c);\n        mainPanel.add(c);\n    }\n    // end loop\n    setUpMidi();\n    theFrame.setBounds(50, 50, 300, 300);\n    theFrame.pack();\n    theFrame.setVisible(true);\n}\n","name":"buildGUI","className":"BeatBox","variables":{"BorderFactory":1,"instrumentNames":1,"nameBox":2,"c":2,"theFrame":6,"mainPanel":2,"upTempo":2,"start":2,"buttonBox":5,"i":7,"layout":2,"checkboxList":2,"stop":2,"background":5,"grid":4,"downTempo":2},"constants":{"\"Start\"":1,"16":3,"false":1,"0":2,"\"Cyber BeatBox\"":1,"1":1,"\"Stop\"":1,"2":1,"256":1,"300":2,"true":1,"50":2,"\"Tempo Down\"":1,"\"Tempo Up\"":1,"10":4},"javaDoc":"","comments":"end loop ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSequencer":1,"printStackTrace":1,"setTempoInBPM":1,"createTrack":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"NameExpr":21,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"// close method\npublic void setUpMidi() {\n    try {\n        sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        sequence = new Sequence(Sequence.PPQ, 4);\n        track = sequence.createTrack();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"setUpMidi","className":"BeatBox","variables":{"sequence":2,"e":2,"track":1,"MidiSystem":1,"sequencer":3},"constants":{"4":1,"120":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"setSequence":1,"setLoopCount":1,"makeEvent":2,"printStackTrace":1,"deleteTrack":1,"setTempoInBPM":1,"createTrack":1,"get":1,"makeTracks":1,"isSelected":1,"start":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"JCheckBox":1,"int[]":1,"int":3},"expressions":{"IntegerLiteralExpr":18,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":4,"NameExpr":60,"UnaryExpr":2,"AssignExpr":4,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":14},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":1,"ForStmt":2,"ExpressionStmt":16},"text":"// close method\npublic void buildTrackAndStart() {\n    int[] trackList = null;\n    sequence.deleteTrack(track);\n    track = sequence.createTrack();\n    for (int i = 0; i < 16; i++) {\n        trackList = new int[16];\n        int key = instruments[i];\n        for (int j = 0; j < 16; j++) {\n            JCheckBox jc = (JCheckBox) checkboxList.get(j + (16 * i));\n            if (jc.isSelected()) {\n                trackList[j] = key;\n            } else {\n                trackList[j] = 0;\n            }\n        }\n        // close inner loop\n        makeTracks(trackList);\n        track.add(makeEvent(176, 1, 127, 0, 16));\n    }\n    // close outer\n    track.add(makeEvent(192, 9, 1, 0, 15));\n    try {\n        sequencer.setSequence(sequence);\n        sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);\n        sequencer.start();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"buildTrackAndStart","className":"BeatBox","variables":{"sequence":2,"instruments":1,"checkboxList":1,"trackList":4,"e":2,"i":5,"jc":2,"j":6,"track":3,"key":2,"sequencer":4},"constants":{"0":5,"176":1,"1":2,"null":1,"15":1,"16":5,"127":1,"9":1,"192":1,"120":1},"javaDoc":"","comments":"close outer close inner loop ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"buildTrackAndStart":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    buildTrackAndStart();\n}\n","name":"actionPerformed","className":"MyStartListener","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"stop":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    sequencer.stop();\n}\n","name":"actionPerformed","className":"MyStopListener","variables":{"sequencer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * 1.03));\n}\n","name":"actionPerformed","className":"MyUpTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{"1.03":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * .97));\n}\n","name":"actionPerformed","className":"MyDownTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{".97":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"add":2,"makeEvent":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":19,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"// close inner class\npublic void makeTracks(int[] list) {\n    for (int i = 0; i < 16; i++) {\n        int key = list[i];\n        if (key != 0) {\n            track.add(makeEvent(144, 9, key, 100, i));\n            track.add(makeEvent(128, 9, key, 100, i + 1));\n        }\n    }\n}\n","name":"makeTracks","className":"BeatBox","variables":{"i":5,"list":1,"track":2,"key":2},"constants":{"0":2,"144":1,"100":2,"1":1,"16":1,"128":1,"9":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"MidiEvent","methodCalls":{"printStackTrace":1,"setMessage":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"ShortMessage":1,"MidiEvent":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":14,"MethodCallExpr":2,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {\n    MidiEvent event = null;\n    try {\n        ShortMessage a = new ShortMessage();\n        a.setMessage(comd, chan, one, two);\n        event = new MidiEvent(a, tick);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return event;\n}\n","name":"makeEvent","className":"BeatBox","variables":{"a":3,"e":2,"tick":1,"event":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new BeatBoxFinal().startUp(args[0]);\n}\n","name":"main","className":"BeatBoxFinal","variables":{"args":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"buildGUI":1,"start":1,"getOutputStream":1,"setUpMidi":1,"getInputStream":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Socket":1,"Thread":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":9},"text":"public void startUp(String name) {\n    userName = name;\n    try {\n        Socket sock = new Socket(\"127.0.0.1\", 4242);\n        out = new ObjectOutputStream(sock.getOutputStream());\n        in = new ObjectInputStream(sock.getInputStream());\n        Thread remote = new Thread(new RemoteReader());\n        remote.start();\n    } catch (Exception ex) {\n        System.out.println(\"couldn't connect - you'll have to play alone.\");\n    }\n    setUpMidi();\n    buildGUI();\n}\n","name":"startUp","className":"BeatBoxFinal","variables":{"sock":3,"ex":1,"in":1,"name":1,"userName":1,"remote":2,"out":1},"constants":{"4242":1,"\"127.0.0.1\"":1,"\"couldn't connect - you'll have to play alone.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":15,"addListSelectionListener":1,"setVisible":1,"setSelected":1,"createEmptyBorder":1,"addActionListener":6,"getContentPane":1,"setSelectionMode":1,"setListData":1,"setBounds":1,"pack":1,"setVgap":1,"setBorder":1,"setDefaultCloseOperation":1,"setHgap":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JScrollPane":1,"JCheckBox":1,"JPanel":1,"GridLayout":1,"BorderLayout":1,"JButton":6,"Box":2,"int":2},"expressions":{"ObjectCreationExpr":26,"IntegerLiteralExpr":16,"VariableDeclarationExpr":15,"ArrayAccessExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":151,"StringLiteralExpr":7,"FieldAccessExpr":7,"UnaryExpr":2,"AssignExpr":5,"MethodCallExpr":34},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":50},"text":"public void buildGUI() {\n    theFrame = new JFrame(\"Cyber BeatBox\");\n    theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    BorderLayout layout = new BorderLayout();\n    JPanel background = new JPanel(layout);\n    background.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n    checkboxList = new ArrayList<JCheckBox>();\n    Box buttonBox = new Box(BoxLayout.Y_AXIS);\n    JButton start = new JButton(\"Start\");\n    start.addActionListener(new MyStartListener());\n    buttonBox.add(start);\n    JButton stop = new JButton(\"Stop\");\n    stop.addActionListener(new MyStopListener());\n    buttonBox.add(stop);\n    JButton upTempo = new JButton(\"Tempo Up\");\n    upTempo.addActionListener(new MyUpTempoListener());\n    buttonBox.add(upTempo);\n    JButton downTempo = new JButton(\"Tempo Down\");\n    downTempo.addActionListener(new MyDownTempoListener());\n    buttonBox.add(downTempo);\n    JButton sendIt = new JButton(\"sendIt\");\n    sendIt.addActionListener(new MySendListener());\n    buttonBox.add(sendIt);\n    // new button\n    JButton saveIt = new JButton(\"Serialize It\");\n    saveIt.addActionListener(new MySendListener());\n    buttonBox.add(saveIt);\n    userMessage = new JTextField();\n    buttonBox.add(userMessage);\n    incomingList = new JList();\n    incomingList.addListSelectionListener(new MyListSelectionListener());\n    incomingList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    JScrollPane theList = new JScrollPane(incomingList);\n    buttonBox.add(theList);\n    incomingList.setListData(listVector);\n    Box nameBox = new Box(BoxLayout.Y_AXIS);\n    for (int i = 0; i < 16; i++) {\n        nameBox.add(new Label(instrumentNames[i]));\n    }\n    background.add(BorderLayout.EAST, buttonBox);\n    background.add(BorderLayout.WEST, nameBox);\n    theFrame.getContentPane().add(background);\n    GridLayout grid = new GridLayout(16, 16);\n    grid.setVgap(1);\n    grid.setHgap(2);\n    mainPanel = new JPanel(grid);\n    background.add(BorderLayout.CENTER, mainPanel);\n    for (int i = 0; i < 256; i++) {\n        JCheckBox c = new JCheckBox();\n        c.setSelected(false);\n        checkboxList.add(c);\n        mainPanel.add(c);\n    }\n    // end loop\n    theFrame.setBounds(50, 50, 300, 300);\n    theFrame.pack();\n    theFrame.setVisible(true);\n}\n","name":"buildGUI","className":"BeatBoxFinal","variables":{"BorderFactory":1,"instrumentNames":1,"nameBox":2,"saveIt":2,"incomingList":5,"c":2,"theFrame":6,"mainPanel":2,"upTempo":2,"start":2,"buttonBox":9,"i":7,"layout":2,"userMessage":1,"theList":1,"sendIt":2,"checkboxList":2,"stop":2,"background":5,"grid":4,"downTempo":2},"constants":{"\"Start\"":1,"16":3,"\"sendIt\"":1,"false":1,"0":2,"\"Cyber BeatBox\"":1,"1":1,"\"Stop\"":1,"2":1,"\"Serialize It\"":1,"256":1,"300":2,"true":1,"50":2,"\"Tempo Down\"":1,"\"Tempo Up\"":1,"10":4},"javaDoc":"","comments":"end loop new button ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSequencer":1,"printStackTrace":1,"setTempoInBPM":1,"createTrack":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"NameExpr":21,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"// close method\npublic void setUpMidi() {\n    try {\n        sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        // sequencer.addMetaEventListener(this);\n        sequence = new Sequence(Sequence.PPQ, 4);\n        track = sequence.createTrack();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"setUpMidi","className":"BeatBoxFinal","variables":{"sequence":2,"e":2,"track":1,"MidiSystem":1,"sequencer":3},"constants":{"4":1,"120":1},"javaDoc":"","comments":"sequencer addMetaEventListener(this); ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3,"setSequence":1,"setLoopCount":1,"makeEvent":1,"printStackTrace":1,"deleteTrack":1,"setTempoInBPM":1,"createTrack":1,"get":1,"makeTracks":1,"isSelected":1,"start":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"JCheckBox":1,"ArrayList<Integer>":1,"int":3},"expressions":{"IntegerLiteralExpr":11,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":57,"UnaryExpr":2,"AssignExpr":2,"NullLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":14},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":1,"ForStmt":2,"ExpressionStmt":15},"text":"// close method\npublic void buildTrackAndStart() {\n    // this will hold the instruments for each vertical column,\n    // in other words, each tick (may have multiple instruments)\n    ArrayList<Integer> trackList = null;\n    sequence.deleteTrack(track);\n    track = sequence.createTrack();\n    for (int i = 0; i < 16; i++) {\n        trackList = new ArrayList<Integer>();\n        for (int j = 0; j < 16; j++) {\n            JCheckBox jc = (JCheckBox) checkboxList.get(j + (16 * i));\n            if (jc.isSelected()) {\n                int key = instruments[i];\n                trackList.add(key);\n            } else {\n                trackList.add(null);\n            }\n        }\n        // close inner\n        makeTracks(trackList);\n    }\n    // close outer\n    // - so we always go to full 16 beats\n    track.add(makeEvent(192, 9, 1, 0, 15));\n    try {\n        sequencer.setSequence(sequence);\n        sequencer.setLoopCount(sequencer.LOOP_CONTINUOUSLY);\n        sequencer.start();\n        sequencer.setTempoInBPM(120);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"buildTrackAndStart","className":"BeatBoxFinal","variables":{"sequence":2,"instruments":1,"checkboxList":1,"trackList":4,"e":2,"i":5,"jc":2,"j":4,"track":2,"key":1,"sequencer":4},"constants":{"0":3,"1":1,"null":2,"15":1,"16":3,"9":1,"192":1,"120":1},"javaDoc":"","comments":"this will hold the instruments for each vertical column close outer in other words each tick (may have multiple instruments) close inner - so we always go to full 16 beats ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"buildTrackAndStart":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    buildTrackAndStart();\n}\n","name":"actionPerformed","className":"MyStartListener","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"stop":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent a) {\n    sequencer.stop();\n}\n","name":"actionPerformed","className":"MyStopListener","variables":{"sequencer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * 1.03));\n}\n","name":"actionPerformed","className":"MyUpTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{"1.03":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTempoFactor":1,"setTempoFactor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent a) {\n    float tempoFactor = sequencer.getTempoFactor();\n    sequencer.setTempoFactor((float) (tempoFactor * .97));\n}\n","name":"actionPerformed","className":"MyDownTempoListener","variables":{"tempoFactor":2,"sequencer":2},"constants":{".97":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"printStackTrace":1,"writeObject":2,"getText":1,"get":1,"isSelected":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"JCheckBox":1,"boolean[]":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":31,"StringLiteralExpr":2,"UnaryExpr":2,"AssignExpr":1,"BooleanLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public void actionPerformed(ActionEvent a) {\n    // make an arraylist of just the STATE of the checkboxes\n    boolean[] checkboxState = new boolean[256];\n    for (int i = 0; i < 256; i++) {\n        JCheckBox check = (JCheckBox) checkboxList.get(i);\n        if (check.isSelected()) {\n            checkboxState[i] = true;\n        }\n    }\n    try {\n        out.writeObject(userName + nextNum++ + \": \" + userMessage.getText());\n        out.writeObject(checkboxState);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n        System.out.println(\"sorry dude. Could not send it to the server\");\n    }\n}\n","name":"actionPerformed","className":"MySendListener","variables":{"userMessage":1,"ex":2,"checkboxList":1,"nextNum":1,"checkboxState":2,"i":4,"check":2,"userName":1,"out":2},"constants":{"0":1,"256":2,"\"sorry dude. Could not send it to the server\"":1,"true":1,"\": \"":1},"javaDoc":"","comments":"make an arraylist of just the STATE of the checkboxes ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ListSelectionEvent"],"returnType":"void","methodCalls":{"buildTrackAndStart":1,"stop":1,"get":1,"getSelectedValue":1,"changeSequence":1,"getValueIsAdjusting":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"String":1,"boolean[]":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":19,"CastExpr":2,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":5},"text":"public void valueChanged(ListSelectionEvent le) {\n    if (!le.getValueIsAdjusting()) {\n        String selected = (String) incomingList.getSelectedValue();\n        if (selected != null) {\n            boolean[] selectedState = (boolean[]) otherSeqsMap.get(selected);\n            changeSequence(selectedState);\n            sequencer.stop();\n            buildTrackAndStart();\n        }\n    }\n}\n","name":"valueChanged","className":"MyListSelectionListener","variables":{"incomingList":1,"otherSeqsMap":1,"le":1,"selected":2,"selectedState":1,"sequencer":1},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"getClass":1,"printStackTrace":1,"setListData":1,"put":1,"readObject":2,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":38,"StringLiteralExpr":1,"CastExpr":2,"FieldAccessExpr":2,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":9},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public void run() {\n    try {\n        while ((obj = in.readObject()) != null) {\n            System.out.println(\"got an object from server\");\n            System.out.println(obj.getClass());\n            String nameToShow = (String) obj;\n            checkboxState = (boolean[]) in.readObject();\n            otherSeqsMap.put(nameToShow, checkboxState);\n            listVector.add(nameToShow);\n            incomingList.setListData(listVector);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"run","className":"RemoteReader","variables":{"incomingList":1,"in":2,"e":2,"obj":3,"otherSeqsMap":1,"listVector":1,"checkboxState":1,"nameToShow":1},"constants":{"null":1,"\"got an object from server\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean[]"],"returnType":"void","methodCalls":{"setSelected":2,"get":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"JCheckBox":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":14,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":3},"text":"//==============================================================       \npublic void changeSequence(boolean[] checkboxState) {\n    for (int i = 0; i < 256; i++) {\n        JCheckBox check = (JCheckBox) checkboxList.get(i);\n        if (checkboxState[i]) {\n            check.setSelected(true);\n        } else {\n            check.setSelected(false);\n        }\n    }\n}\n","name":"changeSequence","className":"BeatBoxFinal","variables":{"checkboxList":1,"checkboxState":1,"i":4,"check":3},"constants":{"0":1,"256":1,"true":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ArrayList<Integer>"],"returnType":"void","methodCalls":{"next":1,"add":2,"makeEvent":2,"iterator":1,"intValue":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Integer":1,"Iterator":1,"int":2},"expressions":{"IntegerLiteralExpr":9,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":26,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"public void makeTracks(ArrayList<Integer> list) {\n    Iterator it = list.iterator();\n    for (int i = 0; i < 16; i++) {\n        Integer num = (Integer) it.next();\n        if (num != null) {\n            int numKey = num.intValue();\n            track.add(makeEvent(144, 9, numKey, 100, i));\n            track.add(makeEvent(128, 9, numKey, 100, i + 1));\n        }\n    }\n}\n","name":"makeTracks","className":"BeatBoxFinal","variables":{"numKey":1,"num":3,"i":4,"it":2,"list":1,"track":2},"constants":{"0":1,"144":1,"100":2,"1":1,"null":1,"16":1,"128":1,"9":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"MidiEvent","methodCalls":{"setMessage":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"ShortMessage":1,"MidiEvent":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":1,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"public MidiEvent makeEvent(int comd, int chan, int one, int two, int tick) {\n    MidiEvent event = null;\n    try {\n        ShortMessage a = new ShortMessage();\n        a.setMessage(comd, chan, one, two);\n        event = new MidiEvent(a, tick);\n    } catch (Exception e) {\n    }\n    return event;\n}\n","name":"makeEvent","className":"BeatBoxFinal","variables":{"a":3,"e":1,"tick":1,"event":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new MusicServer().go();\n}\n","name":"main","className":"MusicServer","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Socket"],"returnType":"ClientHandler","methodCalls":{"printStackTrace":1,"getInputStream":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":9,"AssignExpr":2,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public ClientHandler(Socket clientSOcket) {\n    try {\n        sock = clientSOcket;\n        in = new ObjectInputStream(sock.getInputStream());\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"ClientHandler","className":"ClientHandler","variables":{"sock":2,"ex":2,"clientSOcket":1,"in":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"tellEveryone":1,"printStackTrace":1,"readObject":2,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Object":2},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":5},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":6},"text":"public void run() {\n    Object o1;\n    Object o2;\n    try {\n        while ((o1 = in.readObject()) != null) {\n            o2 = in.readObject();\n            System.out.println(\"read two objects\");\n            tellEveryone(o1, o2);\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"run","className":"ClientHandler","variables":{"o1":2,"o2":2,"ex":2,"in":2},"constants":{"null":1,"\"read two objects\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"printStackTrace":1,"start":1,"getOutputStream":1,"accept":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"ServerSocket":1,"ObjectOutputStream":1,"Socket":1,"Thread":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public void go() {\n    clientOutputStreams = new ArrayList();\n    try {\n        ServerSocket serverSock = new ServerSocket(4242);\n        while (true) {\n            Socket clientSocket = serverSock.accept();\n            ObjectOutputStream out = new ObjectOutputStream(clientSocket.getOutputStream());\n            clientOutputStreams.add(out);\n            Thread t = new Thread(new ClientHandler(clientSocket));\n            t.start();\n            System.out.println(\"got a connection\");\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"go","className":"MusicServer","variables":{"clientSocket":3,"ex":2,"t":2,"clientOutputStreams":2,"serverSock":2,"out":1},"constants":{"4242":1,"true":1,"\"got a connection\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"printStackTrace":1,"writeObject":2,"hasNext":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"Iterator":1,"ObjectOutputStream":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":20,"CastExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":5},"text":"public void tellEveryone(Object one, Object two) {\n    Iterator it = clientOutputStreams.iterator();\n    while (it.hasNext()) {\n        try {\n            ObjectOutputStream out = (ObjectOutputStream) it.next();\n            out.writeObject(one);\n            out.writeObject(two);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n","name":"tellEveryone","className":"MusicServer","variables":{"ex":2,"clientOutputStreams":1,"it":3,"out":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"println":1,"set":1,"setTimeInMillis":1,"getTimeInMillis":1,"format":1,"getInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Calendar":1,"long":1,"int":1},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":3,"DoubleLiteralExpr":1,"BinaryExpr":2,"NameExpr":24,"StringLiteralExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":6,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Calendar c = Calendar.getInstance();\n    c.set(2004, 0, 7, 15, 40);\n    long day1 = c.getTimeInMillis();\n    for (int x = 0; x < 60; x++) {\n        //TODO: added this last semi-colon\n        day1 += (DAY_IM * 29.52);\n        c.setTimeInMillis(day1);\n        out.println(String.format(\"full moon on %tc\", c));\n    }\n}\n","name":"main","className":"FullMoons","variables":{"DAY_IM":1,"c":4,"Calendar":1,"x":3,"day1":2,"String":1,"out":1},"constants":{"0":2,"\"full moon on %tc\"":1,"15":1,"2004":1,"7":1,"60":1,"40":1,"29.52":1},"javaDoc":"","comments":"TODO: added this last semi-colon ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"RetentionBot":1,"V3Radiator":1,"V2Radiator":1,"ArrayList":1,"Object":1,"int":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":3,"VariableDeclarationExpr":7,"BinaryExpr":2,"NameExpr":16,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":2,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    ArrayList aList = new ArrayList();\n    V2Radiator v2 = new V2Radiator(aList);\n    V3Radiator v3 = new V3Radiator(aList);\n    for (int z = 0; z < 20; z++) {\n        RetentionBot ret = new RetentionBot(aList);\n    }\n    //adding this to make sure the power is correct:\n    int totalPower = 0;\n    for (Object o : aList) {\n        totalPower += ((SimUnit) o).powerUse();\n    }\n    System.out.println(\"Total power: \" + totalPower);\n}\n","name":"main","className":"TestLifeSupportSim","variables":{"ret":1,"aList":5,"z":3,"v2":1,"v3":1,"totalPower":3,"o":2},"constants":{"0":2,"\"Total power: \"":1,"20":1},"javaDoc":"","comments":"adding this to make sure the power is correct: ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ArrayList"],"returnType":"V2Radiator","methodCalls":{"add":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"V2Radiator(ArrayList list) {\n    System.out.println(\"making a v2 radiator\");\n    for (int x = 0; x < 5; x++) {\n        list.add(new SimUnit(\"V2Radiator\"));\n    }\n}\n","name":"V2Radiator","className":"V2Radiator","variables":{"x":3,"list":1},"constants":{"0":1,"\"V2Radiator\"":1,"\"making a v2 radiator\"":1,"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["ArrayList"],"returnType":"V3Radiator","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"V3Radiator(ArrayList list) {\n    super(list);\n    for (int g = 0; g < 10; g++) {\n        list.add(new SimUnit(\"V3Radiator\"));\n    }\n}\n","name":"V3Radiator","className":"V3Radiator","variables":{"g":3,"list":2},"constants":{"0":1,"\"V3Radiator\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["ArrayList"],"returnType":"RetentionBot","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"RetentionBot(ArrayList rlist) {\n    rlist.add(new SimUnit(\"Retention\"));\n}\n","name":"RetentionBot","className":"RetentionBot","variables":{"rlist":1},"constants":{"\"Retention\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"SimUnit","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"SimUnit(String type) {\n    botType = type;\n}\n","name":"SimUnit","className":"SimUnit","variables":{"botType":1,"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"StringLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"int powerUse() {\n    if (\"Retention\".equals(botType)) {\n        return 2;\n    } else {\n        return 4;\n    }\n}\n","name":"powerUse","className":"SimUnit","variables":{},"constants":{"2":1,"4":1,"\"Retention\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setLength":1,"move":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Sailboat":1,"Rowboat":1,"Boat":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":12,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Boat b1 = new Boat();\n    Sailboat b2 = new Sailboat();\n    Rowboat b3 = new Rowboat();\n    b2.setLength(32);\n    b1.move();\n    b3.move();\n    b2.move();\n}\n","name":"main","className":"TestBoat","variables":{"b2":3,"b3":2,"b1":2},"constants":{"32":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setLength(int len) {\n    length = len;\n}\n","name":"setLength","className":"Boat","variables":{"len":1,"length":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getLength() {\n    return length;\n}\n","name":"getLength","className":"Boat","variables":{"length":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void move() {\n    System.out.print(\"drift \");\n}\n","name":"move","className":"Boat","variables":{},"constants":{"\"drift \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void rowTheBoat() {\n    System.out.print(\"stroke natasha\");\n}\n","name":"rowTheBoat","className":"Rowboat","variables":{},"constants":{"\"stroke natasha\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void move() {\n    System.out.print(\"hoist sail \");\n}\n","name":"move","className":"Sailboat","variables":{},"constants":{"\"hoist sail \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"BinaryExpr":13,"StringLiteralExpr":11,"NameExpr":42,"FieldAccessExpr":6,"AssignExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    int beerNum = 99;\n    String word = \"bottles\";\n    while (beerNum > 0) {\n        if (beerNum == 1) {\n            word = \"bottle\";\n        }\n        System.out.println(beerNum + \" \" + word + \" of beer on the wall\");\n        System.out.println(beerNum + \" \" + word + \" of beer\");\n        System.out.println(\"Take one down.\");\n        System.out.println(\"Pass it around.\");\n        beerNum = beerNum - 1;\n        if (beerNum > 0) {\n            System.out.println(beerNum + \" \" + word + \" of beer on the wall\");\n        } else {\n            System.out.println(\"No more bottles of beer on the wall\");\n        }\n    }\n}\n","name":"main","className":"BeerSong","variables":{"beerNum":9,"word":5},"constants":{"99":1,"0":2,"1":2,"\"bottles\"":1,"\" \"":3,"\"No more bottles of beer on the wall\"":1,"\"bottle\"":1,"\"Take one down.\"":1,"\"Pass it around.\"":1,"\" of beer on the wall\"":2,"\" of beer\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":3,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"String[]":3,"String":1,"int":6},"expressions":{"VariableDeclarationExpr":10,"ArrayInitializerExpr":3,"ArrayAccessExpr":3,"BinaryExpr":8,"StringLiteralExpr":45,"NameExpr":33,"CastExpr":3,"FieldAccessExpr":4,"EnclosedExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    String[] wordListOne = { \"24/7\", \"multi-Tier\", \"30,000 foot\", \"B-to-B\", \"win-win\", \"front-end\", \"web-based\", \"pervasive\", \"smart\", \"six-sigma\", \"critical-path\", \"dynamic\" };\n    String[] wordListTwo = { \"empowered\", \"sticky\", \"value-added\", \"oriented\", \"centric\", \"distributed\", \"clustered\", \"branded\", \"outside-the-box\", \"positioned\", \"networked\", \"focused\", \"leveraged\", \"aligned\", \"targeted\", \"shared\", \"cooperative\", \"accelerated\" };\n    String[] wordListThree = { \"process\", \"tipping-point\", \"solution\", \"architecture\", \"core competency\", \"strategy\", \"mindshare\", \"portal\", \"space\", \"vision\", \"paradigm\", \"mission\" };\n    int oneLength = wordListOne.length;\n    int twoLength = wordListTwo.length;\n    int threeLength = wordListThree.length;\n    int rand1 = (int) (Math.random() * oneLength);\n    int rand2 = (int) (Math.random() * twoLength);\n    int rand3 = (int) (Math.random() * threeLength);\n    String phrase = wordListOne[rand1] + \" \" + wordListTwo[rand2] + \" \" + wordListThree[rand3];\n    System.out.println(\"What we need is a \" + phrase);\n}\n","name":"main","className":"PhraseOMatic","variables":{"wordListTwo":2,"wordListThree":2,"phrase":2,"twoLength":2,"rand1":2,"wordListOne":2,"oneLength":2,"rand2":2,"rand3":2,"threeLength":2,"Math":3},"constants":{"\"accelerated\"":1,"\"strategy\"":1,"\"networked\"":1,"\"sticky\"":1,"\"24/7\"":1,"\"branded\"":1,"\"mission\"":1,"\"multi-Tier\"":1,"\"focused\"":1,"\"space\"":1,"\"paradigm\"":1,"\"value-added\"":1,"\"process\"":1,"\"tipping-point\"":1,"\"cooperative\"":1,"\"solution\"":1,"\"mindshare\"":1,"\"portal\"":1,"\"positioned\"":1,"\"leveraged\"":1,"\"empowered\"":1,"\"vision\"":1,"\"six-sigma\"":1,"\"oriented\"":1,"\"shared\"":1,"\"smart\"":1,"\" \"":2,"\"front-end\"":1,"\"pervasive\"":1,"\"B-to-B\"":1,"\"30,000 foot\"":1,"\"What we need is a \"":1,"\"outside-the-box\"":1,"\"centric\"":1,"\"win-win\"":1,"\"distributed\"":1,"\"targeted\"":1,"\"aligned\"":1,"\"dynamic\"":1,"\"architecture\"":1,"\"clustered\"":1,"\"core competency\"":1,"\"critical-path\"":1,"\"web-based\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":2,"play":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MiniMiniMusicCmdLine":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":21,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    MiniMiniMusicCmdLine mini = new MiniMiniMusicCmdLine();\n    if (args.length < 2) {\n        System.out.println(\"Don't forget the instrument and note args\");\n    } else {\n        int instrument = Integer.parseInt(args[0]);\n        int note = Integer.parseInt(args[1]);\n        mini.play(instrument, note);\n    }\n}\n","name":"main","className":"MiniMiniMusicCmdLine","variables":{"Integer":2,"args":2,"note":1,"mini":2,"instrument":1},"constants":{"0":1,"1":1,"2":1,"\"Don't forget the instrument and note args\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"getSequencer":1,"add":3,"setSequence":1,"sleep":1,"exit":1,"printStackTrace":1,"createTrack":1,"start":1,"setMessage":3,"close":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Sequencer":1,"ShortMessage":3,"MidiEvent":4,"Sequence":1,"Track":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":15,"NullLiteralExpr":1,"VariableDeclarationExpr":10,"NameExpr":58,"FieldAccessExpr":1,"MethodCallExpr":15},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":23},"text":"public void play(int instrument, int note) {\n    try {\n        Sequencer player = MidiSystem.getSequencer();\n        player.open();\n        Sequence seq = new Sequence(Sequence.PPQ, 4);\n        Track track = seq.createTrack();\n        MidiEvent event = null;\n        ShortMessage first = new ShortMessage();\n        first.setMessage(192, 1, instrument, 0);\n        MidiEvent changeInstrument = new MidiEvent(first, 1);\n        track.add(changeInstrument);\n        ShortMessage a = new ShortMessage();\n        a.setMessage(144, 1, note, 100);\n        MidiEvent noteOn = new MidiEvent(a, 1);\n        track.add(noteOn);\n        ShortMessage b = new ShortMessage();\n        b.setMessage(128, 1, note, 100);\n        MidiEvent noteOff = new MidiEvent(b, 16);\n        track.add(noteOff);\n        player.setSequence(seq);\n        player.start();\n        // new\n        Thread.sleep(5000);\n        player.close();\n        System.exit(0);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"play","className":"MiniMiniMusicCmdLine","variables":{"a":3,"changeInstrument":1,"b":3,"System":1,"Thread":1,"ex":2,"noteOff":1,"noteOn":1,"track":4,"event":1,"MidiSystem":1,"seq":2,"first":3,"player":5},"constants":{"0":2,"1":5,"144":1,"100":2,"5000":1,"4":1,"null":1,"16":1,"128":1,"192":1},"javaDoc":"","comments":"new ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"play":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MiniMiniMusicApp":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    MiniMiniMusicApp mini = new MiniMiniMusicApp();\n    mini.play();\n}\n","name":"main","className":"MiniMiniMusicApp","variables":{"mini":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSequencer":1,"add":2,"setSequence":1,"sleep":1,"exit":1,"printStackTrace":1,"createTrack":1,"start":1,"setMessage":2,"close":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Sequencer":1,"ShortMessage":2,"MidiEvent":3,"Sequence":1,"Track":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":13,"NullLiteralExpr":1,"VariableDeclarationExpr":8,"NameExpr":47,"FieldAccessExpr":1,"MethodCallExpr":13},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":19},"text":"public void play() {\n    try {\n        // make (and open) a sequencer, make a sequence and track\n        Sequencer sequencer = MidiSystem.getSequencer();\n        sequencer.open();\n        Sequence seq = new Sequence(Sequence.PPQ, 4);\n        Track track = seq.createTrack();\n        // now make two midi events (containing a midi message)\n        MidiEvent event = null;\n        // first make the message\n        // then stick the message into a midi event \n        // and add the event to the track\n        ShortMessage a = new ShortMessage();\n        a.setMessage(144, 1, 44, 100);\n        // <-- means at tick one, the above event happens\n        MidiEvent noteOn = new MidiEvent(a, 1);\n        track.add(noteOn);\n        ShortMessage b = new ShortMessage();\n        b.setMessage(128, 1, 44, 100);\n        // <-- means at tick one, the above event happens\n        MidiEvent noteOff = new MidiEvent(b, 16);\n        track.add(noteOff);\n        // add the events to the track\n        // add the sequence to the sequencer, set timing, and start\n        sequencer.setSequence(seq);\n        sequencer.start();\n        // new\n        Thread.sleep(1000);\n        sequencer.close();\n        System.exit(0);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"play","className":"MiniMiniMusicApp","variables":{"a":3,"b":3,"ex":2,"noteOff":1,"noteOn":1,"track":3,"event":1,"MidiSystem":1,"seq":2,"System":1,"sequencer":5,"Thread":1},"constants":{"44":2,"0":1,"144":1,"1":3,"100":2,"4":1,"null":1,"16":1,"128":1,"1000":1},"javaDoc":"","comments":"make (and open) a sequencer make a sequence and track first make the message then stick the message into a midi event and add the event to the track add the events to the track now make two midi events (containing a midi message) <-- means at tick one the above event happens <-- means at tick one the above event happens add the sequence to the sequencer set timing and start new ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getFirst":1,"getSecond":1,"firstContaining":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"Pair<String, Integer>":1},"expressions":{"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"StringLiteralExpr":6,"NameExpr":29,"FieldAccessExpr":4,"MethodCallExpr":7},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    String[] names = { \"Tom\", \"Diana\", \"Harry\" };\n    Pair<String, Integer> result = firstContaining(names, \"a\");\n    System.out.println(result.getFirst());\n    System.out.println(\"Expected: Diana\");\n    System.out.println(result.getSecond());\n    System.out.println(\"Expected: 1\");\n}\n","name":"main","className":"PairDemo","variables":{"result":3,"names":1},"constants":{"\"a\"":1,"\"Tom\"":1,"\"Expected: Diana\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Expected: 1\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]","String"],"returnType":"Pair<String, Integer>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"UnaryExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2},"text":"/**\n      Gets the first String containing a given string, together \n      with its index.\n      @param strings an array of strings\n      @param sub a string\n      @return a pair (strings[i], i) where strings[i] is the first \n      strings[i] containing str, or a pair (null, -1) if there is no\n      match.\n   */\npublic static Pair<String, Integer> firstContaining(String[] strings, String sub) {\n    for (int i = 0; i < strings.length; i++) {\n        if (strings[i].contains(sub)) {\n            return new Pair<>(strings[i], i);\n        }\n    }\n    return new Pair<>(null, -1);\n}\n","name":"firstContaining","className":"PairDemo","variables":{"strings":2,"i":6},"constants":{"0":1,"1":1,"null":1},"javaDoc":"Gets the first String containing a given string together with its index strings an array of strings sub a string a pair (strings[i] i) where strings[i] is the first strings[i] containing str or a pair (null -1) if there is no match","comments":"\n      Gets the first String containing a given string, together \n      with its index.\n      @param strings an array of strings\n      @param sub a string\n      @return a pair (strings[i], i) where strings[i] is the first \n      strings[i] containing str, or a pair (null, -1) if there is no\n      match.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["T","S"],"returnType":"Pair","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a pair containing two given elements.\n      @param firstElement the first element\n      @param secondElement the second element\n   */\npublic Pair(T firstElement, S secondElement) {\n    first = firstElement;\n    second = secondElement;\n}\n","name":"Pair","className":"Pair","variables":{"firstElement":1,"secondElement":1,"first":1,"second":1},"constants":{},"javaDoc":"Constructs a pair containing two given elements firstElement the first element secondElement the second element","comments":"\n      Constructs a pair containing two given elements.\n      @param firstElement the first element\n      @param secondElement the second element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"T","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the first element of this pair.\n      @return the first element\n   */\npublic T getFirst() {\n    return first;\n}\n","name":"getFirst","className":"Pair","variables":{"first":1},"constants":{},"javaDoc":"Gets the first element of this pair the first element","comments":"\n      Gets the first element of this pair.\n      @return the first element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"S","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the second element of this pair.\n      @return the second element\n   */\npublic S getSecond() {\n    return second;\n}\n","name":"getSecond","className":"Pair","variables":{"second":1},"constants":{},"javaDoc":"Gets the second element of this pair the second element","comments":"\n      Gets the second element of this pair.\n      @return the second element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"(\" + first + \", \" + second + \")\";\n}\n","name":"toString","className":"Pair","variables":{"first":1,"second":1},"constants":{"\")\"":1,"\"(\"":1,"\", \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"size":1,"push":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Stack<Integer>":1,"int":1,"Stack":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":17,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    Stack<Integer> countdown = new Stack<>();\n    for (int i = 0; i <= 10; i++) {\n        countdown.push(i);\n    }\n    while (countdown.size() > 0) {\n        System.out.println(countdown.pop());\n    }\n}\n","name":"main","className":"StackDemo","variables":{"countdown":4,"i":3},"constants":{"0":2,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Stack","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Stack() {\n    elements = new Object[INITIAL_SIZE];\n// elements = new E[INITIAL_SIZE] \n// is an error--cannot make a generic array\n}\n","name":"Stack","className":"Stack","variables":{"INITIAL_SIZE":1,"elements":1},"constants":{},"javaDoc":"","comments":"elements = new E[INITIAL_SIZE] is an error--cannot make a generic array ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"copyOf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":16,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public void push(E value) {\n    if (currentSize >= elements.length) {\n        elements = Arrays.copyOf(elements, 2 * elements.length);\n    }\n    elements[currentSize] = value;\n    currentSize++;\n}\n","name":"push","className":"Stack","variables":{"elements":2,"Arrays":1,"value":1,"currentSize":3},"constants":{"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"E","methodCalls":{},"annotations":["SuppressWarnings"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":3,"CastExpr":1,"UnaryExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"// Suppresses \"unchecked\" warnings inside this method\n@SuppressWarnings(\"unchecked\")\npublic E pop() {\n    currentSize--;\n    // Cast causes \"unchecked\" warning\n    return (E) elements[currentSize];\n}\n","name":"pop","className":"Stack","variables":{"elements":1,"currentSize":2},"constants":{},"javaDoc":"","comments":"Suppresses \"unchecked\" warnings inside this method Cast causes \"unchecked\" warning ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int size() {\n    return currentSize;\n}\n","name":"size","className":"Stack","variables":{"currentSize":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ArrayList<E>","ArrayList<? extends E>"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"E":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":1},"text":"public static <E> void addAll(ArrayList<E> lst, ArrayList<? extends E> other) // public static <E> void addAll(ArrayList<E> lst, ArrayList<E> other)\n// doesn't work with Student array list\n{\n    for (E e : other) {\n        lst.add(e);\n    }\n}\n","name":"addAll","className":"WildcardDemo","variables":{"other":1,"e":1,"lst":1},"constants":{},"javaDoc":"","comments":"public static <E> void addAll(ArrayList<E> lst ArrayList<E> other) doesn't work with Student array list ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ArrayList<E>"],"returnType":"E","methodCalls":{"size":1,"get":3,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"E":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":21,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static <E extends Comparable<? super E>> E max(ArrayList<E> a) // public static <E extends Comparable<E>> E max(ArrayList<E> a) \n// doesn't work with Student array list\n{\n    E largest = a.get(0);\n    for (int i = 1; i < a.size(); i++) {\n        if (a.get(i).compareTo(largest) > 0) {\n            largest = a.get(i);\n        }\n    }\n    return largest;\n}\n","name":"max","className":"WildcardDemo","variables":{"largest":3,"a":4,"i":3},"constants":{"0":2,"1":1},"javaDoc":"","comments":"public static <E extends Comparable<E>> E max(ArrayList<E> a) doesn't work with Student array list ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"addAll":1,"max":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayList<Student>":1,"ArrayList":2,"ArrayList<Person>":1},"expressions":{"ObjectCreationExpr":6,"VariableDeclarationExpr":2,"NameExpr":30,"StringLiteralExpr":7,"FieldAccessExpr":2,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    ArrayList<Student> students = new ArrayList<>();\n    students.add(new Student(\"Fred\", \"CS\"));\n    students.add(new Student(\"Ann\", \"Bio\"));\n    students.add(new Student(\"Sue\", \"CS\"));\n    ArrayList<Person> people = new ArrayList<>();\n    people.add(new Person(\"Harry\"));\n    addAll(people, students);\n    System.out.println(people);\n    System.out.println(max(students));\n}\n","name":"main","className":"WildcardDemo","variables":{"students":4,"people":2},"constants":{"\"CS\"":2,"\"Fred\"":1,"\"Bio\"":1,"\"Sue\"":1,"\"Harry\"":1,"\"Ann\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/**\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   */\npublic Student(String aName, String aMajor) {\n    super(aName);\n    major = aMajor;\n}\n","name":"Student","className":"Student","variables":{"major":1,"aName":1,"aMajor":1},"constants":{},"javaDoc":"Constructs a Student object aName the name of the student aMajor the major of the student","comments":"\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":3,"NameExpr":3,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return super.toString() + \"[major=\" + major + \"]\";\n}\n","name":"toString","className":"Student","variables":{"major":1},"constants":{"\"]\"":1,"\"[major=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Person","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a Person object\n      @param aName the name of the person\n   */\npublic Person(String aName) {\n    name = aName;\n}\n","name":"Person","className":"Person","variables":{"aName":1,"name":1},"constants":{},"javaDoc":"Constructs a Person object aName the name of the person","comments":"\n      Constructs a Person object\n      @param aName the name of the person\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \"]\";\n}\n","name":"toString","className":"Person","variables":{"name":1},"constants":{"\"[name=\"":1,"\"]\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Person"],"returnType":"int","methodCalls":{"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int compareTo(Person other) {\n    return name.compareTo(other.name);\n}\n","name":"compareTo","className":"Person","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["E[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"E":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"public static <E> void print(E[] a) {\n    for (E e : a) {\n        System.out.print(e + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"PrintDemo","variables":{"a":1,"e":2},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"public static void print(int[] a) {\n    for (int e : a) {\n        System.out.print(e + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"PrintDemo","variables":{"a":1,"e":2},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color[]":1,"int[]":1,"String[]":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"ArrayInitializerExpr":3,"StringLiteralExpr":5,"NameExpr":21,"FieldAccessExpr":4,"MethodCallExpr":3},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    String[] words = { \"Mary\", \"had\", \"a\", \"little\", \"lamb\" };\n    Color[] colors = { Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW };\n    int[] squares = { 1, 4, 9, 16, 25, 36 };\n    // Calls print<String>\n    print(words);\n    // Calls print<Color>\n    print(colors);\n    // Calls non-generic print      \n    print(squares);\n}\n","name":"main","className":"PrintDemo","variables":{"words":1,"squares":1,"colors":1},"constants":{"1":1,"\"lamb\"":1,"\"a\"":1,"25":1,"36":1,"\"little\"":1,"4":1,"16":1,"\"had\"":1,"9":1,"\"Mary\"":1},"javaDoc":"","comments":"Calls print<String> Calls print<Color> Calls non-generic print ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/**\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   */\npublic Student(String aName, String aMajor) {\n    super(aName);\n    major = aMajor;\n}\n","name":"Student","className":"Student","variables":{"major":1,"aName":1,"aMajor":1},"constants":{},"javaDoc":"Constructs a Student object aName the name of the student aMajor the major of the student","comments":"\n      Constructs a Student object.\n      @param aName the name of the student\n      @param aMajor the major of the student\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":3,"NameExpr":3,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return super.toString() + \"[major=\" + major + \"]\";\n}\n","name":"toString","className":"Student","variables":{"major":1},"constants":{"\"]\"":1,"\"[major=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      This method is called for each visited node.\n      @param data the data of the node\n   */\nvoid visit(E data);\n","name":"visit","className":"Visitor","variables":{},"constants":{},"javaDoc":"This method is called for each visited node data the data of the node","comments":"\n      This method is called for each visited node.\n      @param data the data of the node\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void visit(String data) {\n    System.out.print(data + \" \");\n}\n","name":"visit","className":"PrintVisitor","variables":{"data":1},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":5,"inorder":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"BinarySearchTree<String>":1,"BinarySearchTree":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":38,"StringLiteralExpr":7,"FieldAccessExpr":3,"MethodCallExpr":9},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    BinarySearchTree<String> names = new BinarySearchTree<>();\n    names.add(\"Romeo\");\n    names.add(\"Juliet\");\n    names.add(\"Tom\");\n    names.add(\"Dick\");\n    names.add(\"Harry\");\n    class PrintVisitor implements Visitor<String> {\n\n        public void visit(String data) {\n            System.out.print(data + \" \");\n        }\n    }\n    names.inorder(new PrintVisitor());\n    System.out.println();\n    System.out.println(\"Expected: Dick Harry Juliet Romeo Tom\");\n}\n","name":"main","className":"TreeTester","variables":{"names":7,"data":2,"PrintVisitor":1,"visit":1},"constants":{"\"Expected: Dick Harry Juliet Romeo Tom\"":1,"\"Tom\"":1,"\" \"":1,"\"Juliet\"":1,"\"Dick\"":1,"\"Harry\"":1,"\"Romeo\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void visit(Object data) {\n    System.out.println(data);\n}\n","name":"visit","className":"PrintVisitor","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":5,"inorder":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"BinarySearchTree2":1,"BinarySearchTree2<Student>":1},"expressions":{"ObjectCreationExpr":7,"VariableDeclarationExpr":1,"NameExpr":28,"StringLiteralExpr":10,"FieldAccessExpr":1,"MethodCallExpr":7},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    BinarySearchTree2<Student> students = new BinarySearchTree2<>();\n    // Can form BinarySearchTree2<Student> even though Student\n    // implements Comparable<Person> and not Comparable<Student>\n    students.add(new Student(\"Romeo\", \"Art History\"));\n    students.add(new Student(\"Juliet\", \"CS\"));\n    students.add(new Student(\"Tom\", \"Leisure Studies\"));\n    students.add(new Student(\"Diana\", \"EE\"));\n    students.add(new Student(\"Harry\", \"Biology\"));\n    class PrintVisitor implements Visitor<Object> {\n\n        public void visit(Object data) {\n            System.out.println(data);\n        }\n    }\n    // Can pass a Visitor<Object>, not just a Visitor<Student>\n    students.inorder(new PrintVisitor());\n}\n","name":"main","className":"TreeTester2","variables":{"data":1,"PrintVisitor":1,"students":7,"visit":1},"constants":{"\"CS\"":1,"\"EE\"":1,"\"Tom\"":1,"\"Biology\"":1,"\"Juliet\"":1,"\"Leisure Studies\"":1,"\"Diana\"":1,"\"Art History\"":1,"\"Harry\"":1,"\"Romeo\"":1},"javaDoc":"","comments":"Can form BinarySearchTree2<Student> even though Student implements Comparable<Person> and not Comparable<Student> Can pass a Visitor<Object> not just a Visitor<Student> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BinarySearchTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic BinarySearchTree() {\n    root = null;\n}\n","name":"BinarySearchTree","className":"BinarySearchTree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"addNode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":17,"FieldAccessExpr":3,"AssignExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(E obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n}\n","name":"add","className":"BinarySearchTree","variables":{"obj":1,"root":3,"newNode":2},"constants":{"null":3},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":3,"MethodCallExpr":1,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(E obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"BinarySearchTree","variables":{"current":4,"d":3,"root":1},"constants":{"0":2,"null":1,"true":1,"false":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"toBeRemoved.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Node":5,"int":1},"expressions":{"NullLiteralExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"BooleanLiteralExpr":2,"BinaryExpr":12,"NameExpr":88,"FieldAccessExpr":20,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":14},"statements":{"IfStmt":8,"WhileStmt":2,"BlockStmt":15,"ReturnStmt":2,"ExpressionStmt":21},"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(E obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    Node parent = null;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            parent = toBeRemoved;\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        if (// Found in root\n        parent == null) {\n            root = newChild;\n        } else if (parent.left == toBeRemoved) {\n            parent.left = newChild;\n        } else {\n            parent.right = newChild;\n        }\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallestParent = toBeRemoved;\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallestParent = smallest;\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    if (smallestParent == toBeRemoved) {\n        smallestParent.right = smallest.right;\n    } else {\n        smallestParent.left = smallest.right;\n    }\n}\n       // toBeRemoved contains obj\n\n       // If one of the children is empty, use the other\n\n","name":"remove","className":"BinarySearchTree","variables":{"parent":3,"smallestParent":3,"toBeRemoved":8,"found":4,"d":3,"newChild":6,"smallest":3,"root":2},"constants":{"0":2,"null":7,"false":1,"true":1},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child Found in root \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Visitor<E>"],"returnType":"void","methodCalls":{"inorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Prints the contents of the tree in sorted order.\n   */\npublic void inorder(Visitor<E> v) {\n    inorder(root, v);\n}\n","name":"inorder","className":"BinarySearchTree","variables":{},"constants":{},"javaDoc":"Prints the contents of the tree in sorted order","comments":"\n      Prints the contents of the tree in sorted order.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node","Visitor<E>"],"returnType":"void","methodCalls":{"visit":1,"inorder":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":19,"FieldAccessExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   */\nprivate void inorder(Node parent, Visitor<E> v) {\n    if (parent == null) {\n        return;\n    }\n    inorder(parent.left, v);\n    v.visit(parent.data);\n    inorder(parent.right, v);\n}\n","name":"inorder","className":"BinarySearchTree","variables":{"parent":1,"v":1},"constants":{"null":1},"javaDoc":"Prints a node and all of its descendants in sorted order parent the root of the subtree to print","comments":"\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":4,"BlockStmt":6,"ExpressionStmt":5},"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":2,"right":3},"constants":{"0":2,"null":2},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BinarySearchTree2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic BinarySearchTree2() {\n    root = null;\n}\n","name":"BinarySearchTree2","className":"BinarySearchTree2","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"addNode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":17,"FieldAccessExpr":3,"AssignExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(E obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n}\n","name":"add","className":"BinarySearchTree2","variables":{"obj":1,"root":3,"newNode":2},"constants":{"null":3},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":3,"MethodCallExpr":1,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(E obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"BinarySearchTree2","variables":{"current":4,"d":3,"root":1},"constants":{"0":2,"null":1,"true":1,"false":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{"toBeRemoved.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Node":5,"int":1},"expressions":{"NullLiteralExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"BooleanLiteralExpr":2,"BinaryExpr":12,"NameExpr":88,"FieldAccessExpr":20,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":14},"statements":{"IfStmt":8,"WhileStmt":2,"BlockStmt":15,"ReturnStmt":2,"ExpressionStmt":21},"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(E obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    Node parent = null;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            parent = toBeRemoved;\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        if (// Found in root\n        parent == null) {\n            root = newChild;\n        } else if (parent.left == toBeRemoved) {\n            parent.left = newChild;\n        } else {\n            parent.right = newChild;\n        }\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallestParent = toBeRemoved;\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallestParent = smallest;\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    if (smallestParent == toBeRemoved) {\n        smallestParent.right = smallest.right;\n    } else {\n        smallestParent.left = smallest.right;\n    }\n}\n       // toBeRemoved contains obj\n\n       // If one of the children is empty, use the other\n\n","name":"remove","className":"BinarySearchTree2","variables":{"parent":3,"smallestParent":3,"toBeRemoved":8,"found":4,"d":3,"newChild":6,"smallest":3,"root":2},"constants":{"0":2,"null":7,"false":1,"true":1},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child Found in root \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Visitor<? super E>"],"returnType":"void","methodCalls":{"inorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Prints the contents of the tree in sorted order.\n   */\npublic void inorder(Visitor<? super E> v) {\n    inorder(root, v);\n}\n","name":"inorder","className":"BinarySearchTree2","variables":{},"constants":{},"javaDoc":"Prints the contents of the tree in sorted order","comments":"\n      Prints the contents of the tree in sorted order.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BinarySearchTree2<T>.Node<T>","Visitor<? super T>"],"returnType":"void","methodCalls":{"visit":1,"inorder":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":19,"FieldAccessExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   */\nprivate static <T extends Comparable<? super T>> void inorder(BinarySearchTree2<T>.Node<T> parent, Visitor<? super T> v) {\n    if (parent == null) {\n        return;\n    }\n    inorder(parent.left, v);\n    v.visit(parent.data);\n    inorder(parent.right, v);\n}\n","name":"inorder","className":"BinarySearchTree2","variables":{"parent":1,"v":1},"constants":{"null":1},"javaDoc":"Prints a node and all of its descendants in sorted order parent the root of the subtree to print","comments":"\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":4,"BlockStmt":6,"ExpressionStmt":5},"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":2,"right":3},"constants":{"0":2,"null":2},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Person","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a Person object\n      @param aName the name of the person\n   */\npublic Person(String aName) {\n    name = aName;\n}\n","name":"Person","className":"Person","variables":{"aName":1,"name":1},"constants":{},"javaDoc":"Constructs a Person object aName the name of the person","comments":"\n      Constructs a Person object\n      @param aName the name of the person\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \"]\";\n}\n","name":"toString","className":"Person","variables":{"name":1},"constants":{"\"[name=\"":1,"\"]\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Person"],"returnType":"int","methodCalls":{"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int compareTo(Person other) {\n    return name.compareTo(other.name);\n}\n","name":"compareTo","className":"Person","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":2,"sum":2,"addFirst":4,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"LinkedList":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":34,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":10},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    // Here, we use the linked list class from Chapter 16\n    LinkedList numbers = new LinkedList();\n    numbers.addFirst(1);\n    numbers.addFirst(2);\n    numbers.addFirst(3);\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n    // No error message\n    numbers.addFirst(\"4\");\n    // No error\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n// ClassCastException\n}\n","name":"main","className":"UnsafeDemo","variables":{"numbers":5},"constants":{"\"4\"":1,"1":1,"2":1,"3":1,"\"Sum: \"":2},"javaDoc":"","comments":"ClassCastException Here we use the linked list class from Chapter 16 No error message No error ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["LinkedList"],"returnType":"void","methodCalls":{"next":1,"listIterator":1,"hasNext":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ListIterator":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public static void print(LinkedList lst) {\n    ListIterator iter = lst.listIterator();\n    while (iter.hasNext()) {\n        System.out.print(iter.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"UnsafeDemo","variables":{"iter":3,"lst":1},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["LinkedList"],"returnType":"int","methodCalls":{"next":1,"listIterator":1,"hasNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ListIterator":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":12,"CastExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public static int sum(LinkedList lst) {\n    int sum = 0;\n    ListIterator iter = lst.listIterator();\n    while (iter.hasNext()) {\n        sum = sum + (Integer) iter.next();\n    }\n    return sum;\n}\n","name":"sum","className":"UnsafeDemo","variables":{"iter":3,"sum":4,"lst":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Moves the iterator past the next element.\n      @return the traversed element\n   */\nObject next();\n","name":"next","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n      Moves the iterator past the next element.\n      @return the traversed element\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   */\nboolean hasNext();\n","name":"hasNext","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   */\nvoid add(Object element);\n","name":"add","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   */\nvoid remove();\n","name":"remove","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   */\nvoid set(Object element);\n","name":"set","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"LinkedList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Constructs an empty linked list.\n   */\npublic LinkedList() {\n    first = null;\n}\n","name":"LinkedList","className":"LinkedList","variables":{"first":1},"constants":{"null":1},"javaDoc":"Constructs an empty linked list","comments":" \n      Constructs an empty linked list.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"/**\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   */\npublic Object getFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    return first.data;\n}\n","name":"getFirst","className":"LinkedList","variables":{"first":1},"constants":{"null":1},"javaDoc":"Returns the first element in the linked list the first element in the linked list","comments":"\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Removes the first element in the linked list.\n      @return the removed element\n   */\npublic Object removeFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    return element;\n}\n","name":"removeFirst","className":"LinkedList","variables":{"first":2,"element":2},"constants":{"null":1},"javaDoc":"Removes the first element in the linked list the removed element","comments":"\n      Removes the first element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":10,"FieldAccessExpr":2,"AssignExpr":3},"statements":{"ExpressionStmt":4},"text":"/**\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   */\npublic void addFirst(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    first = newNode;\n}\n","name":"addFirst","className":"LinkedList","variables":{"newNode":2,"first":2,"element":1},"constants":{},"javaDoc":"Adds an element to the front of the linked list element the element to add","comments":"\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   */\npublic ListIterator listIterator() {\n    return new LinkedListIterator();\n}\n","name":"listIterator","className":"LinkedList","variables":{},"constants":{},"javaDoc":"Returns an iterator for iterating through this list an iterator for iterating through this list","comments":"\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"LinkedListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BooleanLiteralExpr":1,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n         Constructs an iterator that points to the front\n         of the linked list.\n      */\npublic LinkedListIterator() {\n    position = null;\n    previous = null;\n    isAfterNext = false;\n}\n","name":"LinkedListIterator","className":"LinkedListIterator","variables":{"previous":1,"position":1,"isAfterNext":1},"constants":{"null":2,"false":1},"javaDoc":"Constructs an iterator that points to the front of the linked list","comments":"\n         Constructs an iterator that points to the front\n         of the linked list.\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":15,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":4},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n         Moves the iterator past the next element.\n         @return the traversed element\n      */\npublic Object next() {\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    // Remember for remove\n    previous = position;\n    isAfterNext = true;\n    if (position == null) {\n        position = first;\n    } else {\n        position = position.next;\n    }\n    return position.data;\n}\n","name":"next","className":"LinkedListIterator","variables":{"previous":1,"position":4,"first":1,"isAfterNext":1},"constants":{"null":1,"true":1},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"Remember for remove \n         Moves the iterator past the next element.\n         @return the traversed element\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"BinaryExpr":3,"NameExpr":5,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      */\npublic boolean hasNext() {\n    if (position == null) {\n        return first != null;\n    } else {\n        return position.next != null;\n    }\n}\n","name":"hasNext","className":"LinkedListIterator","variables":{"position":1,"first":1},"constants":{"null":3},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"addFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":23,"FieldAccessExpr":4,"MethodCallExpr":1,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":8},"text":"/**\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      */\npublic void add(Object element) {\n    if (position == null) {\n        addFirst(element);\n        position = first;\n    } else {\n        Node newNode = new Node();\n        newNode.data = element;\n        newNode.next = position.next;\n        position.next = newNode;\n        position = newNode;\n    }\n    isAfterNext = false;\n}\n","name":"add","className":"LinkedListIterator","variables":{"newNode":3,"position":3,"first":1,"element":1,"isAfterNext":1},"constants":{"null":1,"false":1},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":14,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":4},"text":"/**\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      */\npublic void remove() {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    if (position == first) {\n        removeFirst();\n    } else {\n        previous.next = position.next;\n    }\n    position = previous;\n    isAfterNext = false;\n}\n","name":"remove","className":"LinkedListIterator","variables":{"previous":1,"position":2,"first":1,"isAfterNext":2},"constants":{"false":1},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      */\npublic void set(Object element) {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    position.data = element;\n}\n","name":"set","className":"LinkedListIterator","variables":{"isAfterNext":1,"element":1},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"print":2,"sum":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayList<Integer>":1,"ArrayList":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":34,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":10},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<>();\n    numbers.add(1);\n    numbers.add(2);\n    numbers.add(3);\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n    // Compiler error message\n    numbers.add(\"4\");\n    print(numbers);\n    System.out.println(\"Sum: \" + sum(numbers));\n}\n","name":"main","className":"UnsafeDemo2","variables":{"numbers":5},"constants":{"\"4\"":1,"1":1,"2":1,"3":1,"\"Sum: \"":2},"javaDoc":"","comments":"Compiler error message ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ArrayList<Integer>"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"hasNext":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Iterator<Integer>":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public static void print(ArrayList<Integer> lst) {\n    Iterator<Integer> iter = lst.iterator();\n    while (iter.hasNext()) {\n        System.out.print(iter.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"print","className":"UnsafeDemo2","variables":{"iter":3,"lst":1},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ArrayList<Integer>"],"returnType":"int","methodCalls":{"next":1,"iterator":1,"hasNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Iterator<Integer>":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":12,"MethodCallExpr":3,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public static int sum(ArrayList<Integer> lst) {\n    int sum = 0;\n    Iterator<Integer> iter = lst.iterator();\n    while (iter.hasNext()) {\n        // No cast needed\n        sum = sum + iter.next();\n    }\n    return sum;\n}\n","name":"sum","className":"UnsafeDemo2","variables":{"iter":3,"sum":4,"lst":1},"constants":{"0":1},"javaDoc":"","comments":"No cast needed ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["E[]"],"returnType":"E","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"E":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":2,"NameExpr":15,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static <E extends Comparable<E>> E max(E[] a) {\n    E largest = a[0];\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].compareTo(largest) > 0) {\n            largest = a[i];\n        }\n    }\n    return largest;\n}\n","name":"max","className":"MaxDemo","variables":{"largest":3,"a":3,"i":5},"constants":{"0":2,"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"max":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color[]":1,"String[]":1,"Integer[]":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"ArrayInitializerExpr":3,"StringLiteralExpr":5,"NameExpr":28,"FieldAccessExpr":6,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    String[] words = { \"Mary\", \"had\", \"a\", \"little\", \"lamb\" };\n    Color[] colors = { Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW };\n    Integer[] squares = { 1, 4, 9, 16, 25, 36 };\n    // Calls max<String>\n    System.out.println(max(words));\n    // System.out.println(max(colors)); // Error: Color is not Comparable\n    // Calls max<Integer>\n    System.out.println(max(squares));\n}\n","name":"main","className":"MaxDemo","variables":{"words":1,"squares":1,"colors":1},"constants":{"1":1,"\"lamb\"":1,"\"a\"":1,"25":1,"36":1,"\"little\"":1,"4":1,"16":1,"\"had\"":1,"9":1,"\"Mary\"":1},"javaDoc":"","comments":"System out println(max(colors)); // Error: Color is not Comparable Calls max<String> Calls max<Integer> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":1,"println":1,"nextLine":1,"hasNextLine":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"String":1,"File":2,"PrintWriter":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"StringLiteralExpr":2,"NameExpr":14,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public static void main(String[] args) throws FileNotFoundException {\n    File inFile = new File(\"test1.txt\");\n    File outFile = new File(\"output.txt\");\n    try (Scanner in = new Scanner(inFile);\n        PrintWriter out = new PrintWriter(outFile)) {\n        while (in.hasNextLine()) {\n            String result = process(in.nextLine());\n            out.println(result);\n        }\n    }\n// Both in.close() and out.close() are called here\n}\n","name":"main","className":"ClosingResources","variables":{"result":1,"outFile":2,"in":3,"inFile":2,"out":2},"constants":{"\"test1.txt\"":1,"\"output.txt\"":1},"javaDoc":"","comments":"Both in close() and out close() are called here ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"parseInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public static String process(String line) {\n    int value = Integer.parseInt(line);\n    value++;\n    return \"\" + value;\n}\n","name":"process","className":"ClosingResources","variables":{"Integer":1,"value":3},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readData":1,"getMessage":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    try {\n        int result = readData(\"fred.txt\");\n        System.out.println(\"result: \" + result);\n    } catch (IOException exception) {\n        System.out.println(exception.getMessage());\n    }\n}\n","name":"main","className":"CheckedExceptions","variables":{"result":2,"exception":2},"constants":{"\"fred.txt\"":1,"\"result: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"int","methodCalls":{"hasNextInt":1,"nextInt":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":1,"File":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":11,"MethodCallExpr":2,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public static int readData(String filename) throws FileNotFoundException {\n    File inFile = new File(filename);\n    Scanner in = new Scanner(inFile);\n    int sum = 0;\n    while (in.hasNextInt()) {\n        sum = sum + in.nextInt();\n    }\n    return sum;\n}\n","name":"readData","className":"CheckedExceptions","variables":{"filename":1,"in":3,"sum":4,"inFile":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"parseDouble":1,"trim":1,"nextLine":1,"hasNextLine":1,"length":1,"close":2,"System.out.print":2,"charAt":1,"substring":2,"printf":2},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":2,"boolean":1,"double":2,"char":1,"String":4,"File":1,"int":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":6,"VariableDeclarationExpr":13,"BooleanLiteralExpr":2,"BinaryExpr":6,"NameExpr":74,"StringLiteralExpr":6,"FieldAccessExpr":3,"CharLiteralExpr":1,"UnaryExpr":2,"MethodCallExpr":16,"AssignExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":22},"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Prompt for the input and output file names\n    Scanner console = new Scanner(System.in);\n    System.out.print(\"Input file: \");\n    String inputFileName = console.next();\n    System.out.print(\"Output file: \");\n    String outputFileName = console.next();\n    // Construct the Scanner and PrintWriter objects for reading and writing\n    File inputFile = new File(inputFileName);\n    Scanner in = new Scanner(inputFile);\n    PrintWriter out = new PrintWriter(outputFileName);\n    // Read the input and write the output\n    double total = 0;\n    // We read a line at a time since there may be spaces in the item names\n    while (in.hasNextLine()) {\n        String line = in.nextLine();\n        boolean found = false;\n        String item = \"\";\n        double price = 0;\n        for (int i = 0; !found && i < line.length(); i++) {\n            char ch = line.charAt(i);\n            if (ch == ':') {\n                found = true;\n                item = line.substring(0, i + 1);\n                price = Double.parseDouble(line.substring(i + 1).trim());\n                total = total + price;\n            }\n        }\n        // If no colon was found, we skip the line\n        if (found) {\n            out.printf(\"%-20s%10.2f\\n\", item, price);\n        }\n    }\n    out.printf(\"%-20s%10.2f\\n\", \"Total:\", total);\n    in.close();\n    out.close();\n}\n","name":"main","className":"Items","variables":{"console":3,"item":2,"outputFileName":2,"inputFileName":2,"in":4,"ch":2,"line":5,"i":5,"Double":1,"out":4,"inputFile":2,"total":3,"found":4,"price":3},"constants":{"0":4,"\"\"":1,"1":2,"\"%-20s%10.2f\\n\"":2,"':'":1,"\"Output file: \"":1,"\"Total:\"":1,"false":1,"true":1,"\"Input file: \"":1},"javaDoc":"","comments":"Prompt for the input and output file names Construct the Scanner and PrintWriter objects for reading and writing Read the input and write the output We read a line at a time since there may be spaces in the item names If no colon was found we skip the line ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":5,"StringLiteralExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    if (amount > balance) {\n        throw new IllegalArgumentException(\"Amount exceeds balance\");\n    }\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":3},"constants":{"\"Amount exceeds balance\"":1},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1,"withdraw":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":14,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Tests the methods of the BankAccount class.\n      @param args not used\n   */\npublic static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount();\n    harrysChecking.deposit(2000);\n    harrysChecking.withdraw(5000);\n    // The last statement is not executed since an exception has\n    // terminated the program\n    System.out.println(harrysChecking.getBalance());\n}\n","name":"main","className":"ThrowingExceptions","variables":{"harrysChecking":4},"constants":{"5000":1,"2000":1},"javaDoc":"Tests the methods of the BankAccount class args not used","comments":"The last statement is not executed since an exception has terminated the program \n      Tests the methods of the BankAccount class.\n      @param args not used\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"double[]","methodCalls":{"readData":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"File":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":6,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Reads a data set.\n      @param filename the name of the file holding the data\n      @return the data in the file\n   */\npublic double[] readFile(String filename) throws IOException {\n    File inFile = new File(filename);\n    try (Scanner in = new Scanner(inFile)) {\n        readData(in);\n        return data;\n    }\n}\n","name":"readFile","className":"DataSetReader","variables":{"filename":1,"data":1,"in":1,"inFile":2},"constants":{},"javaDoc":"Reads a data set filename the name of the file holding the data the data in the file","comments":"\n      Reads a data set.\n      @param filename the name of the file holding the data\n      @return the data in the file\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Scanner"],"returnType":"void","methodCalls":{"readValue":1,"hasNextInt":1,"hasNext":1,"nextInt":1},"annotations":[],"exceptions":["BadDataException"],"concepts":[],"types":{"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":18,"StringLiteralExpr":2,"UnaryExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"/**\n      Reads all data.\n      @param in the scanner that scans the data\n   */\nprivate void readData(Scanner in) throws BadDataException {\n    if (!in.hasNextInt()) {\n        throw new BadDataException(\"Length expected\");\n    }\n    int numberOfValues = in.nextInt();\n    data = new double[numberOfValues];\n    for (int i = 0; i < numberOfValues; i++) {\n        readValue(in, i);\n    }\n    if (in.hasNext()) {\n        throw new BadDataException(\"End of file expected\");\n    }\n}\n","name":"readData","className":"DataSetReader","variables":{"data":1,"in":3,"numberOfValues":3,"i":3},"constants":{"0":1,"\"Length expected\"":1,"\"End of file expected\"":1},"javaDoc":"Reads all data in the scanner that scans the data","comments":"\n      Reads all data.\n      @param in the scanner that scans the data\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Scanner","int"],"returnType":"void","methodCalls":{"hasNextDouble":1,"nextDouble":1},"annotations":[],"exceptions":["BadDataException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"ArrayAccessExpr":1,"NameExpr":8,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n      Reads one data value.\n      @param in the scanner that scans the data\n      @param i the position of the value to read\n   */\nprivate void readValue(Scanner in, int i) throws BadDataException {\n    if (!in.hasNextDouble()) {\n        throw new BadDataException(\"Data value expected\");\n    }\n    data[i] = in.nextDouble();\n}\n","name":"readValue","className":"DataSetReader","variables":{"data":1,"in":2,"i":1},"constants":{"\"Data value expected\"":1},"javaDoc":"Reads one data value in the scanner that scans the data i the position of the value to read","comments":"\n      Reads one data value.\n      @param in the scanner that scans the data\n      @param i the position of the value to read\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"printStackTrace":1,"readFile":1,"getMessage":1,"System.out.println":4},"annotations":[],"exceptions":["BadDataException","FileNotFoundException","IOException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"boolean":1,"double[]":1,"double":2,"String":1,"DataSetReader":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":7,"BooleanLiteralExpr":2,"BinaryExpr":3,"NameExpr":43,"StringLiteralExpr":4,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":8,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":6,"TryStmt":1,"ForeachStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    DataSetReader reader = new DataSetReader();\n    boolean done = false;\n    while (!done) {\n        try {\n            System.out.println(\"Please enter the file name: \");\n            String filename = in.next();\n            double[] data = reader.readFile(filename);\n            double sum = 0;\n            for (double d : data) {\n                sum = sum + d;\n            }\n            System.out.println(\"The sum is \" + sum);\n            done = true;\n        } catch (FileNotFoundException exception) {\n            System.out.println(\"File not found.\");\n        } catch (BadDataException exception) {\n            System.out.println(\"Bad data: \" + exception.getMessage());\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        }\n    }\n}\n","name":"main","className":"DataAnalyzer","variables":{"exception":5,"filename":1,"data":2,"d":2,"in":2,"reader":2,"sum":4,"done":3},"constants":{"0":1,"\"File not found.\"":1,"\"Bad data: \"":1,"\"The sum is \"":1,"\"Please enter the file name: \"":1,"false":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BadDataException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public BadDataException() {\n}\n","name":"BadDataException","className":"BadDataException","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"BadDataException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public BadDataException(String message) {\n    super(message);\n}\n","name":"BadDataException","className":"BadDataException","variables":{"message":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"lastIndexOf":1,"contains":1,"hasNext":1,"openStream":1,"indexOf":1,"substring":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Scanner":1,"String":2,"URL":1,"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":29,"FieldAccessExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"public static void main(String[] args) throws IOException {\n    String address = \"http://horstmann.com/index.html\";\n    URL pageLocation = new URL(address);\n    Scanner in = new Scanner(pageLocation.openStream());\n    while (in.hasNext()) {\n        String line = in.next();\n        if (line.contains(\"href=\\\"http://\")) {\n            int from = line.indexOf(\"\\\"\");\n            int to = line.lastIndexOf(\"\\\"\");\n            System.out.println(line.substring(from + 1, to));\n        }\n    }\n}\n","name":"main","className":"WebPageReader","variables":{"pageLocation":2,"address":2,"in":3,"line":5,"from":2,"to":1},"constants":{"1":1,"\"href=\\\"http://\"":1,"\"\\\"\"":2,"\"http://horstmann.com/index.html\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"print":1,"encrypt":1,"usage":2,"useDelimiter":1,"hasNext":1,"close":2,"charAt":3},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["FinalVariables"],"types":{"Scanner":1,"char":3,"String":3,"int":4,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":9,"ObjectCreationExpr":3,"VariableDeclarationExpr":12,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":56,"StringLiteralExpr":3,"FieldAccessExpr":1,"CharLiteralExpr":2,"UnaryExpr":3,"MethodCallExpr":12,"AssignExpr":3},"statements":{"IfStmt":5,"WhileStmt":1,"BlockStmt":9,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":21},"text":"public static void main(String[] args) throws FileNotFoundException {\n    final int DEFAULT_KEY = 3;\n    int key = DEFAULT_KEY;\n    String inFile = \"\";\n    String outFile = \"\";\n    // Number of command line arguments that are files\n    int files = 0;\n    for (int i = 0; i < args.length; i++) {\n        String arg = args[i];\n        if (arg.charAt(0) == '-') {\n            // It is a command line option\n            char option = arg.charAt(1);\n            if (option == 'd') {\n                key = -key;\n            } else {\n                usage();\n                return;\n            }\n        } else {\n            // It is a file name\n            files++;\n            if (files == 1) {\n                inFile = arg;\n            } else if (files == 2) {\n                outFile = arg;\n            }\n        }\n    }\n    if (files != 2) {\n        usage();\n        return;\n    }\n    Scanner in = new Scanner(new File(inFile));\n    // Process individual characters\n    in.useDelimiter(\"\");\n    PrintWriter out = new PrintWriter(outFile);\n    while (in.hasNext()) {\n        char from = in.next().charAt(0);\n        char to = encrypt(from, key);\n        out.print(to);\n    }\n    in.close();\n    out.close();\n}\n","name":"main","className":"CaesarCipher","variables":{"in":5,"i":4,"out":3,"args":1,"outFile":3,"arg":5,"files":5,"DEFAULT_KEY":2,"from":1,"to":1,"inFile":3,"key":3,"option":2},"constants":{"\"\"":3,"0":4,"'-'":1,"1":2,"2":2,"3":1,"'d'":1},"javaDoc":"","comments":"Number of command line arguments that are files It is a command line option It is a file name Process individual characters ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["char","int"],"returnType":"char","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":13,"NameExpr":21,"CastExpr":1,"CharLiteralExpr":6,"EnclosedExpr":1,"AssignExpr":4},"statements":{"IfStmt":4,"BlockStmt":5,"ReturnStmt":2,"ExpressionStmt":7},"text":"/**\n      Encrypts upper- and lowercase characters by shifting them\n      according to a key.\n      @param ch the letter to be encrypted\n      @param key the encryption key\n      @return the encrypted letter      \n   */\npublic static char encrypt(char ch, int key) {\n    int base = 0;\n    if ('A' <= ch && ch <= 'Z') {\n        base = 'A';\n    } else if ('a' <= ch && ch <= 'z') {\n        base = 'a';\n    } else // Not a letter\n    {\n        return ch;\n    }\n    int offset = ch - base + key;\n    // Number of letters in the Roman alphabet\n    final int LETTERS = 26;\n    if (offset >= LETTERS) {\n        offset = offset - LETTERS;\n    } else if (offset < 0) {\n        offset = offset + LETTERS;\n    }\n    return (char) (base + offset);\n}\n","name":"encrypt","className":"CaesarCipher","variables":{"LETTERS":4,"offset":8,"ch":6,"key":1,"base":5},"constants":{"0":2,"'Z'":1,"'z'":1,"26":1,"'A'":2,"'a'":2},"javaDoc":"Encrypts upper- and lowercase characters by shifting them according to a key ch the letter to be encrypted key the encryption key the encrypted letter","comments":"Not a letter Number of letters in the Roman alphabet \n      Encrypts upper- and lowercase characters by shifting them\n      according to a key.\n      @param ch the letter to be encrypted\n      @param key the encryption key\n      @return the encrypted letter      \n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Prints a message describing proper usage.\n   */\npublic static void usage() {\n    System.out.println(\"Usage: java CaesarCipher [-d] infile outfile\");\n}\n","name":"usage","className":"CaesarCipher","variables":{},"constants":{"\"Usage: java CaesarCipher [-d] infile outfile\"":1},"javaDoc":"Prints a message describing proper usage","comments":"\n      Prints a message describing proper usage.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"CountryValue","methodCalls":{"parseDouble":1,"trim":1,"isDigit":1,"isWhitespace":1,"charAt":2,"substring":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":32,"UnaryExpr":3,"MethodCallExpr":8,"AssignExpr":2},"statements":{"WhileStmt":2,"BlockStmt":2,"ExpressionStmt":6},"text":"/**\n      Constructs a CountryValue from an input line.\n      @param line a line containing a country name, followed by a value\n   */\npublic CountryValue(String line) {\n    // Locate the start of the first digit\n    int i = 0;\n    while (!Character.isDigit(line.charAt(i))) {\n        i++;\n    }\n    // Locate the end of the preceding word\n    int j = i - 1;\n    while (Character.isWhitespace(line.charAt(j))) {\n        j--;\n    }\n    // Extract the country name\n    country = line.substring(0, j + 1);\n    // Extract the value\n    value = Double.parseDouble(line.substring(i).trim());\n}\n","name":"CountryValue","className":"CountryValue","variables":{"country":1,"Character":2,"line":4,"i":3,"j":3,"value":1,"Double":1},"constants":{"0":2,"1":2},"javaDoc":"Constructs a CountryValue from an input line line a line containing a country name followed by a value","comments":"Locate the start of the first digit Locate the end of the preceding word Extract the country name Extract the value \n      Constructs a CountryValue from an input line.\n      @param line a line containing a country name, followed by a value\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the country name\n   */\npublic String getCountry() {\n    return country;\n}\n","name":"getCountry","className":"CountryValue","variables":{"country":1},"constants":{},"javaDoc":"Gets the country name the country name","comments":"\n      Gets the country name.\n      @return the country name\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the associated value.\n      @return the value associated with the country\n   */\npublic double getValue() {\n    return value;\n}\n","name":"getValue","className":"CountryValue","variables":{"value":1},"constants":{},"javaDoc":"Gets the associated value the value associated with the country","comments":"\n      Gets the associated value.\n      @return the value associated with the country\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getValue":3,"getCountry":1,"nextLine":2,"hasNextLine":2,"close":3,"printf":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":2,"double":1,"CountryValue":2,"PrintWriter":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":6,"BinaryExpr":3,"StringLiteralExpr":4,"NameExpr":38,"MethodCallExpr":12,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":11},"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Open input files\n    Scanner in1 = new Scanner(new File(\"worldpop.txt\"));\n    Scanner in2 = new Scanner(new File(\"worldarea.txt\"));\n    // Open output file\n    PrintWriter out = new PrintWriter(\"world_pop_density.txt\");\n    // Read lines from each file\n    while (in1.hasNextLine() && in2.hasNextLine()) {\n        CountryValue population = new CountryValue(in1.nextLine());\n        CountryValue area = new CountryValue(in2.nextLine());\n        // Compute and print the population density\n        double density = 0;\n        if (// Protect against division by zero\n        area.getValue() != 0) {\n            density = population.getValue() / area.getValue();\n        }\n        out.printf(\"%-40s%15.2f\\n\", population.getCountry(), density);\n    }\n    in1.close();\n    in2.close();\n    out.close();\n}\n","name":"main","className":"PopulationDensity","variables":{"area":3,"density":2,"in2":4,"in1":4,"out":3,"population":3},"constants":{"0":2,"\"worldarea.txt\"":1,"\"worldpop.txt\"":1,"\"world_pop_density.txt\"":1,"\"%-40s%15.2f\\n\"":1},"javaDoc":"","comments":"Open input files Open output file Read lines from each file Compute and print the population density Protect against division by zero ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double"],"returnType":"RecordReader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a RecordReader with a zero total.\n   */\npublic RecordReader(double aLimit) {\n    total = 0;\n    limit = aLimit;\n}\n","name":"RecordReader","className":"RecordReader","variables":{"total":1,"limit":1,"aLimit":1},"constants":{"0":1},"javaDoc":"Constructs a RecordReader with a zero total","comments":"\n      Constructs a RecordReader with a zero total.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Scanner"],"returnType":"void","methodCalls":{"next":1,"nextInt":1,"nextDouble":1,"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"String":1,"int":1},"expressions":{"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"/**\n      Reads an input record and prints the name if the current total is less \n      than the limit.\n      @param in the input stream\n   */\npublic void process(Scanner in) {\n    String name = in.next();\n    int count = in.nextInt();\n    double percent = in.nextDouble();\n    if (total < limit) {\n        System.out.print(name + \" \");\n    }\n    total = total + percent;\n}\n","name":"process","className":"RecordReader","variables":{"total":3,"in":3,"name":2,"count":1,"limit":1,"percent":2},"constants":{"\" \"":1},"javaDoc":"Reads an input record and prints the name if the current total is less than the limit in the input stream","comments":"\n      Reads an input record and prints the name if the current total is less \n      than the limit.\n      @param in the input stream\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether there are more inputs to process\n      @return true if the limit has not yet been reached\n   */\npublic boolean hasMore() {\n    return total < limit;\n}\n","name":"hasMore","className":"RecordReader","variables":{"total":1,"limit":1},"constants":{},"javaDoc":"Checks whether there are more inputs to process true if the limit has not yet been reached","comments":"\n      Checks whether there are more inputs to process\n      @return true if the limit has not yet been reached\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":2,"hasMore":2,"nextInt":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"RecordReader":2,"int":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":30,"FieldAccessExpr":2,"MethodCallExpr":7},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"public static void main(String[] args) throws FileNotFoundException {\n    try (Scanner in = new Scanner(new File(\"babynames.txt\"))) {\n        RecordReader boys = new RecordReader(LIMIT);\n        RecordReader girls = new RecordReader(LIMIT);\n        while (boys.hasMore() || girls.hasMore()) {\n            int rank = in.nextInt();\n            System.out.print(rank + \" \");\n            boys.process(in);\n            girls.process(in);\n            System.out.println();\n        }\n    }\n}\n","name":"main","className":"BabyNames","variables":{"in":2,"boys":3,"rank":2,"LIMIT":2,"girls":3},"constants":{"\" \"":1,"\"babynames.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"showOpenDialog":1,"getSelectedFile":1,"nextLine":1,"hasNextLine":2,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables"],"types":{"Scanner":1,"JFileChooser":1,"String":1,"File":1,"int":2},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":6,"BinaryExpr":5,"NameExpr":35,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":10},"text":"public static void main(String[] args) throws IOException {\n    JFileChooser chooser = new JFileChooser();\n    Scanner in = null;\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        File selectedFile = chooser.getSelectedFile();\n        in = new Scanner(selectedFile);\n        int lineNumber = 1;\n        final int MAX_LINES = 9;\n        while (in.hasNextLine() && lineNumber <= MAX_LINES) {\n            String line = in.nextLine();\n            System.out.println(lineNumber + \": \" + line);\n            lineNumber++;\n        }\n        if (in.hasNextLine()) {\n            System.out.println(\"...\");\n        }\n    }\n}\n","name":"main","className":"FileChooserDemo","variables":{"selectedFile":2,"in":5,"line":2,"MAX_LINES":2,"chooser":3,"lineNumber":4},"constants":{"1":1,"\"...\"":1,"null":2,"9":1,"\": \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"parseInt":1,"printStackTrace":1,"getMessage":1,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["NumberFormatException","IOException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"String":2,"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":31,"FieldAccessExpr":2,"MethodCallExpr":7,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    try {\n        String filename = \"test1.txt\";\n        Scanner in = new Scanner(new File(filename));\n        int sum = 0;\n        while (in.hasNext()) {\n            String input = in.next();\n            int value = Integer.parseInt(input);\n            sum = sum + value;\n        }\n        System.out.println(\"Sum: \" + sum);\n    } catch (IOException exception) {\n        exception.printStackTrace();\n    } catch (NumberFormatException exception) {\n        System.out.println(exception.getMessage());\n    }\n}\n","name":"main","className":"CatchingExceptions","variables":{"Integer":1,"exception":4,"input":1,"filename":2,"in":3,"sum":4,"value":2},"constants":{"0":1,"\"Sum: \"":1,"\"test1.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"hasNextDouble":1,"close":2,"System.out.print":2,"nextDouble":1,"printf":2},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Scanner":2,"double":2,"String":2,"File":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":8,"BinaryExpr":1,"NameExpr":45,"StringLiteralExpr":4,"FieldAccessExpr":3,"MethodCallExpr":10,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":15},"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Prompt for the input and output file names\n    Scanner console = new Scanner(System.in);\n    System.out.print(\"Input file: \");\n    String inputFileName = console.next();\n    System.out.print(\"Output file: \");\n    String outputFileName = console.next();\n    // Construct the Scanner and PrintWriter objects for reading and writing\n    File inputFile = new File(inputFileName);\n    Scanner in = new Scanner(inputFile);\n    PrintWriter out = new PrintWriter(outputFileName);\n    // Read the input and write the output\n    double total = 0;\n    while (in.hasNextDouble()) {\n        double value = in.nextDouble();\n        out.printf(\"%15.2f\\n\", value);\n        total = total + value;\n    }\n    out.printf(\"Total: %8.2f\\n\", total);\n    in.close();\n    out.close();\n}\n","name":"main","className":"Total","variables":{"console":3,"inputFile":2,"total":3,"outputFileName":2,"inputFileName":2,"in":4,"value":2,"out":4},"constants":{"0":1,"\"Output file: \"":1,"\"Total: %8.2f\\n\"":1,"\"%15.2f\\n\"":1,"\"Input file: \"":1},"javaDoc":"","comments":"Prompt for the input and output file names Construct the Scanner and PrintWriter objects for reading and writing Read the input and write the output ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["InsufficientFundsException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":5,"NameExpr":7,"StringLiteralExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    if (amount > balance) {\n        throw new InsufficientFundsException(\"withdrawal of \" + amount + \" exceeds balance of \" + balance);\n    }\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":3,"balance":4},"constants":{"\"withdrawal of \"":1,"\" exceeds balance of \"":1},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"InsufficientFundsException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public InsufficientFundsException() {\n}\n","name":"InsufficientFundsException","className":"InsufficientFundsException","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"InsufficientFundsException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public InsufficientFundsException(String message) {\n    super(message);\n}\n","name":"InsufficientFundsException","className":"InsufficientFundsException","variables":{"message":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1,"withdraw":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":14,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Tests the methods of the BankAccount class.\n      @param args not used\n   */\npublic static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount();\n    harrysChecking.deposit(2000);\n    harrysChecking.withdraw(5000);\n    // The last statement is not executed since an exception has\n    // terminated the program\n    System.out.println(harrysChecking.getBalance());\n}\n","name":"main","className":"CustomExceptions","variables":{"harrysChecking":4},"constants":{"5000":1,"2000":1},"javaDoc":"Tests the methods of the BankAccount class args not used","comments":"The last statement is not executed since an exception has terminated the program \n      Tests the methods of the BankAccount class.\n      @param args not used\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"encryptStream":1,"nextInt":1,"System.out.print":3,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"Scanner":1,"InputStream":1,"FileOutputStream":1,"OutputStream":1,"String":2,"int":1,"FileInputStream":1,"CaesarCipher":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":7,"BinaryExpr":1,"NameExpr":41,"StringLiteralExpr":4,"FieldAccessExpr":5,"MethodCallExpr":8},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Input file: \");\n    String inFile = in.next();\n    System.out.print(\"Output file: \");\n    String outFile = in.next();\n    System.out.print(\"Encryption key: \");\n    int key = in.nextInt();\n    try (InputStream inStream = new FileInputStream(inFile);\n        OutputStream outStream = new FileOutputStream(outFile)) {\n        CaesarCipher cipher = new CaesarCipher(key);\n        cipher.encryptStream(inStream, outStream);\n    } catch (IOException exception) {\n        System.out.println(\"Error processing file: \" + exception);\n    }\n}\n","name":"main","className":"CaesarEncryptor","variables":{"cipher":2,"exception":2,"outFile":2,"in":4,"inStream":1,"outStream":1,"inFile":2,"key":2},"constants":{"\"Output file: \"":1,"\"Encryption key: \"":1,"\"Error processing file: \"":1,"\"Input file: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"CaesarCipher","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a cipher object with a given key.\n      @param aKey the encryption key\n   */\npublic CaesarCipher(int aKey) {\n    key = aKey;\n}\n","name":"CaesarCipher","className":"CaesarCipher","variables":{"aKey":1,"key":1},"constants":{},"javaDoc":"Constructs a cipher object with a given key aKey the encryption key","comments":"\n      Constructs a cipher object with a given key.\n      @param aKey the encryption key\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"read":1,"encrypt":1,"write":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"boolean":1,"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":2,"BinaryExpr":1,"NameExpr":13,"UnaryExpr":2,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"/**\n      Encrypts the contents of an input stream.\n      @param in the input stream\n      @param out the output stream\n   */\npublic void encryptStream(InputStream in, OutputStream out) throws IOException {\n    boolean done = false;\n    while (!done) {\n        int next = in.read();\n        if (next == -1) {\n            done = true;\n        } else {\n            int encrypted = encrypt(next);\n            out.write(encrypted);\n        }\n    }\n}\n","name":"encryptStream","className":"CaesarCipher","variables":{"next":2,"encrypted":1,"in":1,"done":3,"out":1},"constants":{"1":1,"false":1,"true":1},"javaDoc":"Encrypts the contents of an input stream in the input stream out the output stream","comments":"\n      Encrypts the contents of an input stream.\n      @param in the input stream\n      @param out the output stream\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Encrypts a value.\n      @param b the value to encrypt (between 0 and 255)\n      @return the encrypted value\n   */\npublic int encrypt(int b) {\n    return (b + key) % 256;\n}\n","name":"encrypt","className":"CaesarCipher","variables":{"b":1,"key":1},"constants":{"256":1},"javaDoc":"Encrypts a value b the value to encrypt (between 0 and 255) the encrypted value","comments":"\n      Encrypts a value.\n      @param b the value to encrypt (between 0 and 255)\n      @return the encrypted value\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getParent":2,"resolve":2,"get":1,"toAbsolutePath":1,"replace":1,"toString":1,"getFileName":2,"System.out.print":2,"System.out.println":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"Path":7},"expressions":{"VariableDeclarationExpr":7,"BinaryExpr":7,"NameExpr":80,"StringLiteralExpr":12,"FieldAccessExpr":9,"MethodCallExpr":19},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    Path inputPath = Paths.get(\"input.txt\");\n    System.out.println(\"Relative path: \" + inputPath);\n    Path absolutePath = inputPath.toAbsolutePath();\n    System.out.println(\"Absolute path: \" + absolutePath);\n    Path parent = absolutePath.getParent();\n    System.out.println(\"Its parent: \" + parent);\n    Path sibling = parent.resolve(\"output.txt\");\n    System.out.println(\"A sibling: \" + sibling);\n    Path fileName = sibling.getFileName();\n    System.out.println(\"The sibling's file name: \" + fileName);\n    System.out.print(\"The sibling's path components: \");\n    for (Path p : sibling) {\n        System.out.print(p + \" \");\n    }\n    System.out.println();\n    Path changedExtension = sibling.getParent().resolve(sibling.getFileName().toString().replace(\".txt\", \".bak\"));\n    System.out.println(\"Changing the extension: \" + changedExtension);\n}\n","name":"main","className":"PathDemo","variables":{"p":2,"parent":3,"fileName":2,"inputPath":3,"sibling":6,"absolutePath":3,"Paths":1,"changedExtension":2},"constants":{"\"The sibling's file name: \"":1,"\" \"":1,"\"The sibling's path components: \"":1,"\"Changing the extension: \"":1,"\"Its parent: \"":1,"\".bak\"":1,"\"Relative path: \"":1,"\"input.txt\"":1,"\"A sibling: \"":1,"\".txt\"":1,"\"Absolute path: \"":1,"\"output.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   */\npublic BankAccount(int anAccountNumber) {\n    accountNumber = anAccountNumber;\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":1,"balance":1,"accountNumber":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance anAccountNumber the account number for this account","comments":"\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   */\npublic BankAccount(int anAccountNumber, double initialBalance) {\n    accountNumber = anAccountNumber;\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":1,"balance":1,"initialBalance":1,"accountNumber":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance anAccountNumber the account number for this account initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the account number of this bank account.\n      @return the account number\n   */\npublic int getAccountNumber() {\n    return accountNumber;\n}\n","name":"getAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"constants":{},"javaDoc":"Gets the account number of this bank account the account number","comments":"\n      Gets the account number of this bank account.\n      @return the account number\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankData","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a BankData object that is not associated with a file.\n   */\npublic BankData() {\n    file = null;\n}\n","name":"BankData","className":"BankData","variables":{"file":1},"constants":{"null":1},"javaDoc":"Constructs a BankData object that is not associated with a file","comments":"\n      Constructs a BankData object that is not associated with a file.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Opens the data file.\n      @param filename the name of the file containing bank\n      account information\n   */\npublic void open(String filename) throws IOException {\n    if (file != null) {\n        file.close();\n    }\n    file = new RandomAccessFile(filename, \"rw\");\n}\n","name":"open","className":"BankData","variables":{"file":3,"filename":1},"constants":{"null":1,"\"rw\"":1},"javaDoc":"Opens the data file filename the name of the file containing bank account information","comments":"\n      Opens the data file.\n      @param filename the name of the file containing bank\n      account information\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"length":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"CastExpr":1,"NameExpr":4,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the number of accounts in the file.\n      @return the number of accounts\n   */\npublic int size() throws IOException {\n    return (int) (file.length() / RECORD_SIZE);\n}\n","name":"size","className":"BankData","variables":{"file":1,"RECORD_SIZE":1},"constants":{},"javaDoc":"Gets the number of accounts in the file the number of accounts","comments":"\n      Gets the number of accounts in the file.\n      @return the number of accounts\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":1,"NameExpr":5,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Closes the data file.\n   */\npublic void close() throws IOException {\n    if (file != null) {\n        file.close();\n    }\n    file = null;\n}\n","name":"close","className":"BankData","variables":{"file":3},"constants":{"null":2},"javaDoc":"Closes the data file","comments":"\n      Closes the data file.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{"readDouble":1,"readInt":1,"seek":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"double":1,"int":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":13,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Reads a bank account record.\n      @param n the index of the account in the data file\n      @return a bank account object initialized with the file data\n   */\npublic BankAccount read(int n) throws IOException {\n    file.seek(n * RECORD_SIZE);\n    int accountNumber = file.readInt();\n    double balance = file.readDouble();\n    return new BankAccount(accountNumber, balance);\n}\n","name":"read","className":"BankData","variables":{"file":3,"RECORD_SIZE":1,"balance":2,"accountNumber":2,"n":1},"constants":{},"javaDoc":"Reads a bank account record n the index of the account in the data file a bank account object initialized with the file data","comments":"\n      Reads a bank account record.\n      @param n the index of the account in the data file\n      @return a bank account object initialized with the file data\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"size":1,"readInt":1,"seek":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":15,"UnaryExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Finds the position of a bank account with a given number.\n      @param accountNumber the number to find\n      @return the position of the account with the given number, \n      or -1 if there is no such account\n   */\npublic int find(int accountNumber) throws IOException {\n    for (int i = 0; i < size(); i++) {\n        file.seek(i * RECORD_SIZE);\n        int a = file.readInt();\n        if (a == accountNumber) {\n            return i;\n        }\n    // Found a match            \n    }\n    // No match in the entire file\n    return -1;\n}\n","name":"find","className":"BankData","variables":{"a":2,"file":2,"RECORD_SIZE":1,"i":5,"accountNumber":1},"constants":{"0":1,"1":1},"javaDoc":"Finds the position of a bank account with a given number accountNumber the number to find the position of the account with the given number or -1 if there is no such account","comments":"Found a match No match in the entire file \n      Finds the position of a bank account with a given number.\n      @param accountNumber the number to find\n      @return the position of the account with the given number, \n      or -1 if there is no such account\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","BankAccount"],"returnType":"void","methodCalls":{"writeInt":1,"getBalance":1,"getAccountNumber":1,"seek":1,"writeDouble":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":17,"MethodCallExpr":5},"statements":{"ExpressionStmt":3},"text":"/**\n      Writes a bank account record to the data file.\n      @param n the index of the account in the data file\n      @param account the account to write\n   */\npublic void write(int n, BankAccount account) throws IOException {\n    file.seek(n * RECORD_SIZE);\n    file.writeInt(account.getAccountNumber());\n    file.writeDouble(account.getBalance());\n}\n","name":"write","className":"BankData","variables":{"file":3,"RECORD_SIZE":1,"n":1,"account":2},"constants":{},"javaDoc":"Writes a bank account record to the data file n the index of the account in the data file account the account to write","comments":"\n      Writes a bank account record to the data file.\n      @param n the index of the account in the data file\n      @param account the account to write\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"read":1,"nextInt":1,"nextDouble":1,"getBalance":1,"size":1,"find":1,"deposit":1,"equalsIgnoreCase":1,"write":1,"open":1,"System.out.print":3,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"boolean":1,"BankData":1,"double":1,"BankAccount":1,"String":1,"int":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":8,"BooleanLiteralExpr":2,"BinaryExpr":2,"NameExpr":74,"StringLiteralExpr":7,"FieldAccessExpr":6,"UnaryExpr":1,"MethodCallExpr":16,"AssignExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":1,"BlockStmt":5,"ExpressionStmt":18},"text":"public static void main(String[] args) throws IOException {\n    try (Scanner in = new Scanner(System.in);\n        BankData data = new BankData()) {\n        data.open(\"bank.dat\");\n        boolean done = false;\n        while (!done) {\n            System.out.print(\"Account number: \");\n            int accountNumber = in.nextInt();\n            System.out.print(\"Amount to deposit: \");\n            double amount = in.nextDouble();\n            int position = data.find(accountNumber);\n            BankAccount account;\n            if (position >= 0) {\n                account = data.read(position);\n                account.deposit(amount);\n                System.out.println(\"New balance: \" + account.getBalance());\n            } else // Add account\n            {\n                account = new BankAccount(accountNumber, amount);\n                position = data.size();\n                System.out.println(\"Adding new account.\");\n            }\n            data.write(position, account);\n            System.out.print(\"Done? (Y/N) \");\n            String input = in.next();\n            if (input.equalsIgnoreCase(\"Y\")) {\n                done = true;\n            }\n        }\n    }\n}\n","name":"main","className":"BankSimulator","variables":{"input":2,"amount":2,"data":6,"in":4,"position":3,"accountNumber":2,"done":3,"account":5},"constants":{"0":1,"\"Done? (Y/N) \"":1,"\"Account number: \"":1,"\"Adding new account.\"":1,"\"New balance: \"":1,"false":1,"true":1,"\"Amount to deposit: \"":1,"\"bank.dat\"":1,"\"Y\"":1},"javaDoc":"","comments":"Add account ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"toLowerCase":1,"readAllLines":1,"sort":1,"toList":1,"copyOf":1,"delete":2,"getBytes":1,"filter":1,"contains":1,"size":1,"get":7,"readAllBytes":2,"limit":1,"exists":2,"toString":1,"copy":1,"lines":1,"write":3,"collect":1,"System.out.println":8},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables","ExceptionHandling"],"types":{"Path":6,"byte[]":2,"String":2,"Stream<String>":1,"long":1,"int":2,"List<String>":2},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":16,"ArrayAccessExpr":2,"BinaryExpr":27,"LambdaExpr":1,"NameExpr":182,"StringLiteralExpr":23,"UnaryExpr":1,"AssignExpr":3,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":9,"EnclosedExpr":1,"MethodCallExpr":39},"statements":{"IfStmt":2,"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ExpressionStmt":34},"text":"public static void main(String[] args) throws IOException {\n    // Getting the size of a file\n    Path input = Paths.get(\"UsefulFileOperations.java\");\n    long size = Files.size(input);\n    System.out.println(\"Size of \" + input + \": \" + size + \" bytes\");\n    // Reading all lines\n    List<String> lines = Files.readAllLines(input);\n    System.out.println(\"Line 11: \" + lines.get(10));\n    // Reading all bytes\n    byte[] bytes = Files.readAllBytes(input);\n    byte[] firstTen = Arrays.copyOf(bytes, 10);\n    System.out.println(\"First ten bytes: \" + Arrays.toString(firstTen));\n    // Writing lines\n    Collections.sort(lines);\n    Path output1 = Paths.get(input + \".sorted\");\n    Files.write(output1, lines);\n    System.out.println(\"Sorting the lines of \" + input + \" yields \" + output1);\n    // Writing bytes\n    for (int i = 0; i < bytes.length; i++) {\n        bytes[i] = (byte) (bytes[i] + 3);\n    }\n    Path output2 = Paths.get(input + \".caesar\");\n    Files.write(output2, bytes);\n    System.out.println(\"The Caesar encryption of \" + input + \" is in \" + output2);\n    // Reading a file into a string\n    String contents = new String(Files.readAllBytes(input), \"UTF-8\");\n    // Writing a string to a file\n    Path output3 = Paths.get(input + \".lowercase\");\n    contents = contents.toLowerCase();\n    Files.write(output3, contents.getBytes(\"UTF-8\"));\n    System.out.println(\"The lowercase of \" + input + \" is in \" + output3);\n    String target = \";\";\n    final int MAX_LINES = 10;\n    List<String> result = null;\n    try (Stream<String> lineStream = Files.lines(input)) {\n        result = lineStream.filter( s -> s.contains(target)).limit(MAX_LINES).collect(Collectors.toList());\n    }\n    System.out.println(\"The first ten lines containing a semicolon: \" + result);\n    // Copying and moving\n    Path output4 = Paths.get(input + \".copied\");\n    if (Files.exists(output4)) {\n        Files.delete(output4);\n    }\n    Files.copy(input, output4);\n    Path output5 = Paths.get(output4 + \".moved\");\n    if (Files.exists(output5)) {\n        Files.delete(output5);\n    }\n    Files.move(output4, output5);\n    System.out.println(input + \" was copied to \" + output4 + \" which was moved to \" + output5);\n}\n","name":"main","className":"UsefulFileOperations","variables":{"output3":2,"Collectors":1,"output4":3,"output1":2,"output2":2,"output5":2,"i":5,"lineStream":2,"target":1,"result":3,"input":10,"s":2,"size":2,"firstTen":1,"contents":4,"bytes":3,"MAX_LINES":1,"Paths":6,"Files":14,"lines":2,"Arrays":2,"Collections":1},"constants":{"\".moved\"":1,"\"Size of \"":1,"\" is in \"":2,"\"Line 11: \"":1,"\" was copied to \"":1,"\".copied\"":1,"\": \"":1,"\" which was moved to \"":1,"\".sorted\"":1,"\".caesar\"":1,"\"The Caesar encryption of \"":1,"\" bytes\"":1,"\"The lowercase of \"":1,"10":3,"\".lowercase\"":1,"\" yields \"":1,"\";\"":1,"\"First ten bytes: \"":1,"0":1,"\"UsefulFileOperations.java\"":1,"\"UTF-8\"":2,"\"The first ten lines containing a semicolon: \"":1,"3":1,"null":1,"\"Sorting the lines of \"":1},"javaDoc":"","comments":"Getting the size of a file Reading all lines Reading all bytes Writing lines Writing bytes Reading a file into a string Writing a string to a file Copying and moving ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getParent":2,"toAbsolutePath":1,"replace":2,"toList":2,"list":2,"filter":1,"contains":1,"get":1,"toString":1,"collect":2,"map":2,"getFileName":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Path":2,"Stream<Path>":2,"List<Path>":1,"List<String>":1},"expressions":{"VariableDeclarationExpr":6,"BinaryExpr":4,"LambdaExpr":3,"NameExpr":62,"StringLiteralExpr":9,"FieldAccessExpr":2,"MethodCallExpr":20},"statements":{"TryStmt":2,"BlockStmt":2,"ExpressionStmt":9},"text":"public static void main(String[] args) throws IOException {\n    Path startingDirectory = Paths.get(\"VisitingDirectories.java\").toAbsolutePath();\n    Path grandParent = startingDirectory.getParent().getParent();\n    try (Stream<Path> entries = Files.list(grandParent)) {\n        List<Path> paths = entries.collect(Collectors.toList());\n        System.out.println(\"Entries in \" + grandParent + \": \" + paths);\n    }\n    try (Stream<Path> entries = Files.list(grandParent)) {\n        List<String> result = entries.map( p -> p.getFileName().toString()).filter( s -> s.contains(\"section_\")).map( s -> s.replace(\"section_\", \"Section \").replace(\"_\", \".\")).collect(Collectors.toList());\n        System.out.println(\"Sections with sample code: \" + result);\n    }\n}\n","name":"main","className":"VisitingDirectories","variables":{"startingDirectory":2,"grandParent":2,"result":2,"p":2,"Collectors":2,"entries":4,"s":4,"paths":2,"Paths":1,"Files":2},"constants":{"\"_\"":1,"\".\"":1,"\"Sections with sample code: \"":1,"\"VisitingDirectories.java\"":1,"\"Entries in \"":1,"\": \"":1,"\"section_\"":2,"\"Section \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getParent":1,"createTempDirectory":1,"get":3,"isRegularFile":1,"exists":2,"createDirectory":1,"createTempFile":1,"delete":2,"createFile":1,"isDirectory":1,"System.out.println":6},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Path":4},"expressions":{"VariableDeclarationExpr":4,"BinaryExpr":10,"NameExpr":84,"StringLiteralExpr":12,"FieldAccessExpr":6,"MethodCallExpr":20},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) throws IOException {\n    // Creating a directory and a file inside it\n    Files.createDirectory(Paths.get(\"subdir\"));\n    Path testPath = Paths.get(\"subdir/test.txt\");\n    Files.createFile(testPath);\n    // Checking that the file exists\n    System.out.println(testPath + \" exists: \" + Files.exists(testPath));\n    // But this one doesn't exist\n    Path badPath = Paths.get(\"subdir/bad\");\n    System.out.println(badPath + \" exists: \" + Files.exists(badPath));\n    // Confirming that it's a file and not a directory\n    System.out.println(testPath + \" is a file: \" + Files.isRegularFile(testPath));\n    System.out.println(testPath + \" is a directory: \" + Files.isDirectory(testPath));\n    // Deleting what was created\n    Files.delete(testPath);\n    Files.delete(testPath.getParent());\n    Path tempFile = Files.createTempFile(\"bigjava\", \".txt\");\n    System.out.println(\"Created a temporary file \" + tempFile);\n    Path tempDir = Files.createTempDirectory(\"bigjava\");\n    System.out.println(\"Created a temporary directory \" + tempDir);\n}\n","name":"main","className":"CreatingAndDeleting","variables":{"testPath":5,"badPath":2,"tempFile":2,"tempDir":2,"Paths":3,"Files":10},"constants":{"\" is a file: \"":1,"\"subdir/test.txt\"":1,"\"subdir/bad\"":1,"\"Created a temporary file \"":1,"\"Created a temporary directory \"":1,"\" is a directory: \"":1,"\"subdir\"":1,"\" exists: \"":2,"\"bigjava\"":2,"\".txt\"":1},"javaDoc":"","comments":"Creating a directory and a file inside it Checking that the file exists But this one doesn't exist Confirming that it's a file and not a directory Deleting what was created ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   */\npublic BankAccount(int anAccountNumber) {\n    accountNumber = anAccountNumber;\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":1,"balance":1,"accountNumber":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance anAccountNumber the account number for this account","comments":"\n      Constructs a bank account with a zero balance.\n      @param anAccountNumber the account number for this account\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   */\npublic BankAccount(int anAccountNumber, double initialBalance) {\n    accountNumber = anAccountNumber;\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":1,"balance":1,"initialBalance":1,"accountNumber":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance anAccountNumber the account number for this account initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number for this account\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the account number of this bank account.\n      @return the account number\n   */\npublic int getAccountNumber() {\n    return accountNumber;\n}\n","name":"getAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"constants":{},"javaDoc":"Gets the account number of this bank account the account number","comments":"\n      Gets the account number of this bank account.\n      @return the account number\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Bank","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank with no bank accounts.\n   */\npublic Bank() {\n    accounts = new ArrayList<>();\n}\n","name":"Bank","className":"Bank","variables":{"accounts":1},"constants":{},"javaDoc":"Constructs a bank with no bank accounts","comments":"\n      Constructs a bank with no bank accounts.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BankAccount"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds an account to this bank.\n      @param a the account to add\n   */\npublic void addAccount(BankAccount a) {\n    accounts.add(a);\n}\n","name":"addAccount","className":"Bank","variables":{"accounts":1},"constants":{},"javaDoc":"Adds an account to this bank a the account to add","comments":"\n      Adds an account to this bank.\n      @param a the account to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{"getAccountNumber":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ReturnStmt":2},"text":"/**\n      Finds a bank account with a given number.\n      @param accountNumber the number to find\n      @return the account with the given number, or null if there\n      is no such account\n   */\npublic BankAccount find(int accountNumber) {\n    for (BankAccount a : accounts) {\n        if (// Found a match\n        a.getAccountNumber() == accountNumber) {\n            return a;\n        }\n    }\n    // No match in the entire array list\n    return null;\n}\n","name":"find","className":"Bank","variables":{"a":3,"accounts":1,"accountNumber":1},"constants":{"null":1},"javaDoc":"Finds a bank account with a given number accountNumber the number to find the account with the given number or null if there is no such account","comments":"Found a match No match in the entire array list \n      Finds a bank account with a given number.\n      @param accountNumber the number to find\n      @return the account with the given number, or null if there\n      is no such account\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":2,"find":2,"writeObject":1,"exists":1,"deposit":1,"getAccountNumber":2,"addAccount":2,"readObject":1,"System.out.println":2},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Bank":1,"BankAccount":1,"ObjectOutputStream":1,"File":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":7,"VariableDeclarationExpr":5,"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":52,"CastExpr":1,"FieldAccessExpr":2,"MethodCallExpr":14,"AssignExpr":3},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":2,"ExpressionStmt":12},"text":"public static void main(String[] args) throws IOException, ClassNotFoundException {\n    Bank firstBankOfJava;\n    File f = new File(\"bank.dat\");\n    if (f.exists()) {\n        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(f))) {\n            firstBankOfJava = (Bank) in.readObject();\n        }\n    } else {\n        firstBankOfJava = new Bank();\n        firstBankOfJava.addAccount(new BankAccount(1001, 20000));\n        firstBankOfJava.addAccount(new BankAccount(1015, 10000));\n    }\n    // Deposit some money\n    BankAccount a = firstBankOfJava.find(1001);\n    a.deposit(100);\n    System.out.println(a.getAccountNumber() + \": \" + a.getBalance());\n    a = firstBankOfJava.find(1015);\n    System.out.println(a.getAccountNumber() + \": \" + a.getBalance());\n    try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f))) {\n        out.writeObject(firstBankOfJava);\n    }\n}\n","name":"main","className":"SerialDemo","variables":{"a":7,"in":2,"firstBankOfJava":7,"f":4,"out":2},"constants":{"100":1,"1015":2,"20000":1,"1001":2,"10000":1,"\": \"":2,"\"bank.dat\"":1},"javaDoc":"","comments":"Deposit some money ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":8,"parseInt":1,"nextLine":1,"equals":7,"push":5,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Integer":2,"Scanner":1,"boolean":1,"String":1,"Stack<Integer>":1,"Stack":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":6,"BooleanLiteralExpr":2,"BinaryExpr":6,"NameExpr":85,"StringLiteralExpr":8,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":24,"AssignExpr":1},"statements":{"IfStmt":5,"WhileStmt":1,"BlockStmt":7,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    Stack<Integer> results = new Stack<>();\n    System.out.println(\"Enter one number or operator per line, Q to quit. \");\n    boolean done = false;\n    while (!done) {\n        String input = in.nextLine();\n        if (input.equals(\"+\")) {\n            results.push(results.pop() + results.pop());\n        } else if (input.equals(\"-\")) {\n            Integer arg2 = results.pop();\n            results.push(results.pop() - arg2);\n        } else if (input.equals(\"*\") || input.equals(\"x\")) {\n            results.push(results.pop() * results.pop());\n        } else if (input.equals(\"/\")) {\n            Integer arg2 = results.pop();\n            results.push(results.pop() / arg2);\n        } else if (input.equals(\"Q\") || input.equals(\"q\")) {\n            done = true;\n          // If the command is an operator, pop the arguments and push the result\n\n        } else {\n            // Not an operator--push the input value\n            results.push(Integer.parseInt(input));\n        }\n        System.out.println(results);\n    }\n}\n","name":"main","className":"Calculator","variables":{"Integer":1,"input":8,"arg2":4,"in":2,"results":14,"done":3},"constants":{"\"Q\"":1,"\"q\"":1,"\"/\"":1,"\"Enter one number or operator per line, Q to quit. \"":1,"\"-\"":1,"false":1,"true":1,"\"+\"":1,"\"*\"":1,"\"x\"":1},"javaDoc":"","comments":"If the command is an operator pop the arguments and push the result Not an operator--push the input value ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"Maze","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a maze from a string describing its contents.\n      @param contents strings consisting of * and spaces\n   */\npublic Maze(String[] contents) {\n    cells = contents;\n}\n","name":"Maze","className":"Maze","variables":{"cells":1,"contents":1},"constants":{},"javaDoc":"Constructs a maze from a string describing its contents contents strings consisting of and spaces","comments":"\n      Constructs a maze from a string describing its contents.\n      @param contents strings consisting of * and spaces\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"ArrayList<Path>","methodCalls":{"add":4,"extend":1,"isValid":4},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Path":1,"ArrayList":1,"ArrayList<Path>":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":53,"FieldAccessExpr":4,"MethodCallExpr":9},"statements":{"IfStmt":4,"BlockStmt":5,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n      Gets all paths emanating from a position in the maze.\n      @param row the row of the position\n      @param column the column of the position\n      @return all paths emanating from the position\n   */\npublic ArrayList<Path> pathsFrom(int row, int column) {\n    ArrayList<Path> paths = new ArrayList<>();\n    if (isValid(row - 1, column)) {\n        paths.add(new Path(row, column, Path.NORTH));\n    }\n    if (isValid(row, column + 1)) {\n        paths.add(new Path(row, column, Path.EAST));\n    }\n    if (isValid(row + 1, column)) {\n        paths.add(new Path(row, column, Path.SOUTH));\n    }\n    if (isValid(row, column - 1)) {\n        paths.add(new Path(row, column, Path.WEST));\n    }\n    for (Path p : paths) {\n        extend(p);\n    }\n    return paths;\n}\n","name":"pathsFrom","className":"Maze","variables":{"p":1,"paths":7,"column":6,"row":6},"constants":{"1":4},"javaDoc":"Gets all paths emanating from a position in the maze row the row of the position column the column of the position all paths emanating from the position","comments":"\n      Gets all paths emanating from a position in the maze.\n      @param row the row of the position\n      @param column the column of the position\n      @return all paths emanating from the position\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Path"],"returnType":"void","methodCalls":{"move":1,"getNextRow":2,"getEndingRow":1,"getEndingColumn":1,"isValid":2,"countNeighbors":1,"isExit":1,"turn":3,"getNextColumn":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":2,"BinaryExpr":2,"NameExpr":52,"UnaryExpr":3,"MethodCallExpr":14,"AssignExpr":5},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":5,"ExpressionStmt":12},"text":"/**\n      Extends this path to the next exit, intersection, or dead end.\n      @param p the path to extend\n   */\nprivate void extend(Path p) {\n    boolean done = false;\n    while (!done) {\n        p.move();\n        int row = p.getEndingRow();\n        int column = p.getEndingColumn();\n        if (isExit(row, column) || countNeighbors(row, column) != 2) {\n            // Either a straight path or a turn\n            done = true;\n        } else {\n            row = p.getNextRow();\n            column = p.getNextColumn();\n            if (!isValid(row, column)) {\n                p.turn();\n                row = p.getNextRow();\n                column = p.getNextColumn();\n                if (!isValid(row, column)) {\n                    p.turn();\n                    p.turn();\n                }\n            }\n        }\n    }\n}\n","name":"extend","className":"Maze","variables":{"p":10,"column":3,"row":3,"done":3},"constants":{"2":1,"false":1,"true":1},"javaDoc":"Extends this path to the next exit intersection or dead end p the path to extend","comments":"Either a straight path or a turn \n      Extends this path to the next exit, intersection, or dead end.\n      @param p the path to extend\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"ArrayAccessExpr":2,"BinaryExpr":11,"NameExpr":16,"FieldAccessExpr":1,"CharLiteralExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether a position is an exit.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is an exit\n   */\npublic boolean isExit(int row, int column) {\n    return (row == 0 || row == cells.length - 1 || column == 0 || column == cells[row].length() - 1) && cells[row].charAt(column) == ' ';\n}\n","name":"isExit","className":"Maze","variables":{"cells":2,"column":2,"row":4},"constants":{"0":2,"1":2,"' '":1},"javaDoc":"Checks whether a position is an exit row the row of the position column the column of the position true if the position is an exit","comments":"\n      Checks whether a position is an exit.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is an exit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{"countNeighbors":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether a position is a dead end.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is a dead end\n   */\npublic boolean isDeadEnd(int row, int column) {\n    return countNeighbors(row, column) == 1;\n}\n","name":"isDeadEnd","className":"Maze","variables":{},"constants":{"1":1},"javaDoc":"Checks whether a position is a dead end row the row of the position column the column of the position true if the position is a dead end","comments":"\n      Checks whether a position is a dead end.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is a dead end\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"ArrayAccessExpr":2,"BinaryExpr":9,"NameExpr":16,"FieldAccessExpr":1,"CharLiteralExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether a position is within the maze and not a wall.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is valid\n   */\nprivate boolean isValid(int row, int column) {\n    return 0 <= row && row < cells.length && 0 <= column && column < cells[row].length() && cells[row].charAt(column) == ' ';\n}\n","name":"isValid","className":"Maze","variables":{"cells":2,"column":2,"row":4},"constants":{"0":2,"' '":1},"javaDoc":"Checks whether a position is within the maze and not a wall row the row of the position column the column of the position true if the position is valid","comments":"\n      Checks whether a position is within the maze and not a wall.\n      @param row the row of the position\n      @param column the column of the position\n      @return true if the position is valid\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"isValid":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":21,"UnaryExpr":4,"MethodCallExpr":4},"statements":{"IfStmt":4,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Counts the neighbors of a position.\n      @param row the row of the position\n      @param column the column of the position\n      @return the number of neighbors in the four compass directions\n      that are within the maze and not walls.\n   */\nprivate int countNeighbors(int row, int column) {\n    int count = 0;\n    if (isValid(row - 1, column)) {\n        count++;\n    }\n    if (isValid(row + 1, column)) {\n        count++;\n    }\n    if (isValid(row, column - 1)) {\n        count++;\n    }\n    if (isValid(row, column + 1)) {\n        count++;\n    }\n    return count;\n}\n","name":"countNeighbors","className":"Maze","variables":{"count":6,"column":2,"row":2},"constants":{"0":1,"1":4},"javaDoc":"Counts the neighbors of a position row the row of the position column the column of the position the number of neighbors in the four compass directions that are within the maze and not walls","comments":"\n      Counts the neighbors of a position.\n      @param row the row of the position\n      @param column the column of the position\n      @return the number of neighbors in the four compass directions\n      that are within the maze and not walls.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"solve":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Maze":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayInitializerExpr":1,"StringLiteralExpr":13,"NameExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Maze maze = new Maze(new String[] { \"*****************************\", \"** ***                      *\", \"** *** * ********************\", \"** *** *         *          *\", \"** *** * *******   **** *****\", \"**     * ************** *****\", \"****** ******* *******  *****\", \"******         ******* ******\", \"*      ******* ******* ******\", \"* **** ******* **           *\", \"*    ********* ******* ******\", \"* ****         ***     ******\", \"************** **************\" });\n    solve(maze, 5, 8);\n}\n","name":"main","className":"MazeSolver","variables":{"maze":1},"constants":{"\"* ****         ***     ******\"":1,"\"******         ******* ******\"":1,"\"**     * ************** *****\"":1,"\"*      ******* ******* ******\"":1,"\"** *** * ********************\"":1,"\"* **** ******* **           *\"":1,"\"*****************************\"":1,"\"** *** *         *          *\"":1,"\"****** ******* *******  *****\"":1,"\"************** **************\"":1,"\"*    ********* ******* ******\"":1,"5":1,"\"** *** * *******   **** *****\"":1,"8":1,"\"** ***                      *\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Maze","int","int"],"returnType":"void","methodCalls":{"pop":1,"isDeadEnd":1,"size":1,"getEndingRow":1,"getEndingColumn":1,"isOpposite":1,"isExit":1,"pathsFrom":2,"push":2,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Path":3,"Stack<Path>":1,"int":2,"Stack":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":2,"NameExpr":60,"StringLiteralExpr":3,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":14},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":7,"ForeachStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n      Traverses a maze, printing out a path to the exit.\n      @param maze the maze\n      @param param the row of the starting position\n      @param param the column of the starting position\n   */\npublic static void solve(Maze maze, int row, int column) {\n    Stack<Path> s = new Stack<>();\n    for (Path p : maze.pathsFrom(row, column)) {\n        s.push(p);\n    }\n    while (s.size() > 0) {\n        Path p = s.pop();\n        System.out.println(\"Following \" + p);\n        int r = p.getEndingRow();\n        int c = p.getEndingColumn();\n        if (maze.isExit(r, c)) {\n            System.out.println(\"Exit!\");\n            return;\n        } else if (maze.isDeadEnd(r, c)) {\n            System.out.println(\"Dead end\");\n        } else {\n            for (Path p2 : maze.pathsFrom(r, c)) {\n                if (!p2.isOpposite(p)) {\n                    s.push(p2);\n                }\n            }\n        }\n    }\n}\n","name":"solve","className":"MazeSolver","variables":{"p":5,"r":1,"p2":2,"s":5,"c":1,"maze":4},"constants":{"0":1,"\"Following \"":1,"\"Dead end\"":1,"\"Exit!\"":1},"javaDoc":"Traverses a maze printing out a path to the exit maze the maze param the row of the starting position param the column of the starting position","comments":"\n      Traverses a maze, printing out a path to the exit.\n      @param maze the maze\n      @param param the row of the starting position\n      @param param the column of the starting position\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int","int"],"returnType":"Path","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"AssignExpr":6},"statements":{"ExpressionStmt":6},"text":"/**\n      Constructs a path with a given position and direction\n      @param row the starting row\n      @param column the starting column\n      @param direction the starting direction\n   */\npublic Path(int row, int column, int direction) {\n    startingRow = row;\n    startingColumn = column;\n    startingDirection = direction;\n    endingRow = row;\n    endingColumn = column;\n    endingDirection = direction;\n}\n","name":"Path","className":"Path","variables":{"startingColumn":1,"startingDirection":1,"endingDirection":1,"column":2,"endingRow":1,"row":2,"endingColumn":1,"startingRow":1,"direction":2},"constants":{},"javaDoc":"Constructs a path with a given position and direction row the starting row column the starting column direction the starting direction","comments":"\n      Constructs a path with a given position and direction\n      @param row the starting row\n      @param column the starting column\n      @param direction the starting direction\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getNextRow":1,"getNextColumn":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the ending position of this path one unit in the\n      current direction.\n   */\npublic void move() {\n    endingRow = getNextRow();\n    endingColumn = getNextColumn();\n}\n","name":"move","className":"Path","variables":{"endingRow":1,"endingColumn":1},"constants":{},"javaDoc":"Moves the ending position of this path one unit in the current direction","comments":"\n      Moves the ending position of this path one unit in the\n      current direction.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":3,"EnclosedExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Turns the ending direction of this path clockwise.\n   */\npublic void turn() {\n    final int DIRECTIONS = 4;\n    endingDirection = (endingDirection + 1) % DIRECTIONS;\n}\n","name":"turn","className":"Path","variables":{"endingDirection":2,"DIRECTIONS":2},"constants":{"1":1,"4":1},"javaDoc":"Turns the ending direction of this path clockwise","comments":"\n      Turns the ending direction of this path clockwise.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the ending row of this path.\n      @return the ending row\n   */\npublic int getEndingRow() {\n    return endingRow;\n}\n","name":"getEndingRow","className":"Path","variables":{"endingRow":1},"constants":{},"javaDoc":"Gets the ending row of this path the ending row","comments":"\n      Gets the ending row of this path.\n      @return the ending row\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the ending column of this path.\n      @return the ending column\n   */\npublic int getEndingColumn() {\n    return endingColumn;\n}\n","name":"getEndingColumn","className":"Path","variables":{"endingColumn":1},"constants":{},"javaDoc":"Gets the ending column of this path the ending column","comments":"\n      Gets the ending column of this path.\n      @return the ending column\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":3},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the next row of this path if it continues in the ending\n      direction.\n      @return the next row\n   */\npublic int getNextRow() {\n    return endingRow + ROW_OFFSETS[endingDirection];\n}\n","name":"getNextRow","className":"Path","variables":{"endingDirection":1,"ROW_OFFSETS":1,"endingRow":1},"constants":{},"javaDoc":"Gets the next row of this path if it continues in the ending direction the next row","comments":"\n      Gets the next row of this path if it continues in the ending\n      direction.\n      @return the next row\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":3},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the next column of this path if it continues in the ending\n      direction.\n      @return the next row\n   */\npublic int getNextColumn() {\n    return endingColumn + COLUMN_OFFSETS[endingDirection];\n}\n","name":"getNextColumn","className":"Path","variables":{"endingDirection":1,"endingColumn":1,"COLUMN_OFFSETS":1},"constants":{},"javaDoc":"Gets the next column of this path if it continues in the ending direction the next row","comments":"\n      Gets the next column of this path if it continues in the ending\n      direction.\n      @return the next row\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":5,"NameExpr":4,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether two directions are opposites of each other.\n      @param dir1 a direction between 0 and 3\n      @param dir2 a direction between 0 and 3\n      @return true if they are opposites (i.e. 0 and 2, 1 and 3,\n      2 and 0, or 3 and 1)\n   */\nprivate static boolean isOpposite(int dir1, int dir2) {\n    return dir1 != dir2 && (dir1 + dir2) % 2 == 0;\n}\n","name":"isOpposite","className":"Path","variables":{"dir2":2,"dir1":2},"constants":{"0":1,"2":1},"javaDoc":"Checks whether two directions are opposites of each other dir1 a direction between 0 and 3 dir2 a direction between 0 and 3 true if they are opposites (i e 0 and 2 1 and 3 2 and 0 or 3 and 1)","comments":"\n      Checks whether two directions are opposites of each other.\n      @param dir1 a direction between 0 and 3\n      @param dir2 a direction between 0 and 3\n      @return true if they are opposites (i.e. 0 and 2, 1 and 3,\n      2 and 0, or 3 and 1)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Path"],"returnType":"boolean","methodCalls":{"isOpposite":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":14,"FieldAccessExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this path is the opposite of another one.\n      @param other another path that ends where this path starts\n      @return true if other is the opposite of this path\n   */\npublic boolean isOpposite(Path other) {\n    return startingRow == other.endingRow && startingColumn == other.endingColumn && isOpposite(startingDirection, other.endingDirection);\n}\n","name":"isOpposite","className":"Path","variables":{"startingColumn":1,"startingRow":1},"constants":{},"javaDoc":"Checks whether this path is the opposite of another one other another path that ends where this path starts true if other is the opposite of this path","comments":"\n      Checks whether this path is the opposite of another one.\n      @param other another path that ends where this path starts\n      @return true if other is the opposite of this path\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":14,"StringLiteralExpr":8,"NameExpr":17,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public String toString() {\n    String result = \"(\" + startingRow + \",\" + startingColumn + \")\" + \"NESW\".charAt(startingDirection);\n    if (endingRow != startingRow || endingColumn != startingColumn) {\n        result = result + \"<->(\" + endingRow + \",\" + endingColumn + \")\" + \"NESW\".charAt(endingDirection);\n    }\n    return result;\n}\n","name":"toString","className":"Path","variables":{"result":4,"startingColumn":2,"endingRow":2,"endingColumn":2,"startingRow":2},"constants":{"\"<->(\"":1,"\"NESW\"":2,"\",\"":2,"\")\"":2,"\"(\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":3,"add":2,"addLast":4,"listIterator":1,"remove":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"LinkedList<String>":1,"ListIterator<String>":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":44,"StringLiteralExpr":7,"FieldAccessExpr":2,"MethodCallExpr":13},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    LinkedList<String> staff = new LinkedList<>();\n    staff.addLast(\"Diana\");\n    staff.addLast(\"Harry\");\n    staff.addLast(\"Romeo\");\n    staff.addLast(\"Tom\");\n    // | in the comments indicates the iterator position\n    // |DHRT\n    ListIterator<String> iterator = staff.listIterator();\n    // D|HRT\n    iterator.next();\n    // DH|RT\n    iterator.next();\n    // Add more elements after second element\n    // DHJ|RT\n    iterator.add(\"Juliet\");\n    // DHJN|RT\n    iterator.add(\"Nina\");\n    // DHJNR|T\n    iterator.next();\n    // Remove last traversed element \n    // DHJN|T\n    iterator.remove();\n    // Print all elements\n    System.out.println(staff);\n    System.out.println(\"Expected: [Diana, Harry, Juliet, Nina, Tom]\");\n}\n","name":"main","className":"ListDemo","variables":{"iterator":7,"staff":6},"constants":{"\"Nina\"":1,"\"Tom\"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Romeo\"":1,"\"Expected: [Diana, Harry, Juliet, Nina, Tom]\"":1},"javaDoc":"","comments":"| in the comments indicates the iterator position Add more elements after second element Remove last traversed element Print all elements |DHRT D|HRT DH|RT DHJ|RT DHJN|RT DHJNR|T DHJN|T ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":8,"size":1,"remove":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"PriorityQueue":1,"PriorityQueue<WorkOrder>":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":9,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":35,"StringLiteralExpr":8,"FieldAccessExpr":1,"MethodCallExpr":11},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    PriorityQueue<WorkOrder> q = new PriorityQueue<>();\n    q.add(new WorkOrder(3, \"Shampoo carpets\"));\n    q.add(new WorkOrder(7, \"Empty trash\"));\n    q.add(new WorkOrder(8, \"Water plants\"));\n    q.add(new WorkOrder(10, \"Remove pencil sharpener shavings\"));\n    q.add(new WorkOrder(6, \"Replace light bulb\"));\n    q.add(new WorkOrder(1, \"Fix broken sink\"));\n    q.add(new WorkOrder(9, \"Clean coffee maker\"));\n    q.add(new WorkOrder(2, \"Order cleaning supplies\"));\n    while (q.size() > 0) {\n        System.out.println(q.remove());\n    }\n}\n","name":"main","className":"PriorityQueueDemo","variables":{"q":11},"constants":{"\"Remove pencil sharpener shavings\"":1,"\"Order cleaning supplies\"":1,"\"Shampoo carpets\"":1,"\"Fix broken sink\"":1,"0":1,"\"Replace light bulb\"":1,"1":1,"2":1,"3":1,"6":1,"7":1,"\"Empty trash\"":1,"8":1,"9":1,"\"Water plants\"":1,"\"Clean coffee maker\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","String"],"returnType":"WorkOrder","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   */\npublic WorkOrder(int aPriority, String aDescription) {\n    priority = aPriority;\n    description = aDescription;\n}\n","name":"WorkOrder","className":"WorkOrder","variables":{"aPriority":1,"aDescription":1,"description":1,"priority":1},"constants":{},"javaDoc":"Constructs a work order with a given priority and description aPriority the priority of this work order aDescription the description of this work order","comments":"\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"priority=\" + priority + \", description=\" + description;\n}\n","name":"toString","className":"WorkOrder","variables":{"description":1,"priority":1},"constants":{"\", description=\"":1,"\"priority=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"WorkOrder":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":9,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    WorkOrder other = (WorkOrder) otherObject;\n    if (priority < other.priority) {\n        return -1;\n    } else if (priority > other.priority) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","name":"compareTo","className":"WorkOrder","variables":{"other":1,"priority":2,"otherObject":1},"constants":{"0":1,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"push":7,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Stack<String>":1,"String":1,"int":1,"Stack":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":32,"StringLiteralExpr":8,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Stack<String> commands = new Stack<>();\n    commands.push(\"Insert 'Hello'\");\n    commands.push(\"Insert ','\");\n    commands.push(\"Insert ' '\");\n    commands.push(\"Insert 'World'\");\n    commands.push(\"Insert '?'\");\n    commands.push(\"Delete '?'\");\n    commands.push(\"Insert '!'\");\n    // Now we undo the last four commands\n    for (int i = 1; i <= 4; i++) {\n        String command = commands.pop();\n        System.out.println(\"Undo \" + command);\n    }\n}\n","name":"main","className":"StackDemo","variables":{"i":3,"commands":9,"command":2},"constants":{"\"Insert 'World'\"":1,"1":1,"\"Insert 'Hello'\"":1,"4":1,"\"Undo \"":1,"\"Insert '!'\"":1,"\"Insert ' '\"":1,"\"Insert '?'\"":1,"\"Insert ','\"":1,"\"Delete '?'\"":1},"javaDoc":"","comments":"Now we undo the last four commands ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":6,"size":1,"remove":3,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Queue<String>":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":45,"StringLiteralExpr":9,"FieldAccessExpr":3,"MethodCallExpr":13},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Queue<String> jobs = new LinkedList<>();\n    jobs.add(\"Joe: Expense Report #1\");\n    jobs.add(\"Cathy: Meeting Memo\");\n    System.out.println(\"Printing \" + jobs.remove());\n    jobs.add(\"Cathy: Purchase Order #1\");\n    jobs.add(\"Joe: Expense Report #2\");\n    jobs.add(\"Joe: Weekly Report\");\n    System.out.println(\"Printing \" + jobs.remove());\n    jobs.add(\"Cathy: Purchase Order #2\");\n    while (jobs.size() > 0) {\n        System.out.println(\"Printing \" + jobs.remove());\n    }\n}\n","name":"main","className":"QueueDemo","variables":{"jobs":11},"constants":{"0":1,"\"Joe: Expense Report #1\"":1,"\"Joe: Expense Report #2\"":1,"\"Cathy: Purchase Order #2\"":1,"\"Cathy: Purchase Order #1\"":1,"\"Printing \"":3,"\"Cathy: Meeting Memo\"":1,"\"Joe: Weekly Report\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"add":6,"size":3,"push":3,"remove":2,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Stack<String>":1,"Queue<String>":1,"PriorityQueue":1,"LinkedList":1,"Stack":1,"PriorityQueue<String>":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":75,"StringLiteralExpr":12,"FieldAccessExpr":6,"MethodCallExpr":21},"statements":{"WhileStmt":3,"BlockStmt":3,"ExpressionStmt":18},"text":"public static void main(String[] args) {\n    System.out.println(\"Stack: \");\n    Stack<String> s = new Stack<>();\n    s.push(\"Tom\");\n    s.push(\"Diana\");\n    s.push(\"Harry\");\n    while (s.size() > 0) {\n        System.out.println(s.pop());\n    }\n    System.out.println(\"Queue: \");\n    Queue<String> q = new LinkedList<>();\n    q.add(\"Tom\");\n    q.add(\"Diana\");\n    q.add(\"Harry\");\n    while (q.size() > 0) {\n        System.out.println(q.remove());\n    }\n    System.out.println(\"Priority Queue: \");\n    PriorityQueue<String> pq = new PriorityQueue<>();\n    pq.add(\"Tom\");\n    pq.add(\"Diana\");\n    pq.add(\"Harry\");\n    while (pq.size() > 0) {\n        System.out.println(pq.remove());\n    }\n}\n","name":"main","className":"StackQueueDemo","variables":{"q":6,"pq":6,"s":6},"constants":{"0":3,"\"Stack: \"":1,"\"Tom\"":3,"\"Queue: \"":1,"\"Diana\"":3,"\"Harry\"":3,"\"Priority Queue: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"replace":1,"length":2,"error":5,"push":5,"precedence":2,"evaluateTop":3,"substring":1,"isOperator":1,"pop":4,"parseInt":1,"size":5,"isDigit":2,"System.out.print":1,"charAt":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Scanner":1,"boolean":1,"char":4,"Stack<Character>":1,"String":2,"Stack<Integer>":1,"int":2,"Stack":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":7,"VariableDeclarationExpr":12,"BinaryExpr":14,"BooleanLiteralExpr":2,"NameExpr":136,"StringLiteralExpr":8,"FieldAccessExpr":3,"CharLiteralExpr":4,"UnaryExpr":3,"MethodCallExpr":37,"AssignExpr":1},"statements":{"IfStmt":11,"WhileStmt":4,"BlockStmt":20,"ExpressionStmt":30},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter an expression: \");\n    String expression = in.nextLine().replace(\" \", \"\");\n    Stack<Integer> numstack = new Stack<>();\n    Stack<Character> opstack = new Stack<>();\n    int pos = 0;\n    while (pos < expression.length()) {\n        char ch = expression.charAt(pos);\n        pos++;\n        if (isOperator(ch)) {\n            if (opstack.size() == 0) {\n                opstack.push(ch);\n            } else {\n                char oldOp = opstack.pop();\n                if (precedence(ch) > precedence(oldOp)) {\n                    opstack.push(oldOp);\n                } else {\n                    evaluateTop(numstack, oldOp);\n                }\n                opstack.push(ch);\n            }\n        } else if (ch == '(') {\n            opstack.push(ch);\n        } else if (ch == ')') {\n            boolean done = false;\n            while (!done) {\n                if (opstack.size() == 0) {\n                    error(\"No matching (\");\n                }\n                char oldOp = opstack.pop();\n                if (oldOp == '(') {\n                    done = true;\n                } else {\n                    evaluateTop(numstack, oldOp);\n                }\n            }\n        } else if (Character.isDigit(ch)) {\n            int start = pos - 1;\n            while (pos < expression.length() && Character.isDigit(expression.charAt(pos))) {\n                pos++;\n            }\n            String num = expression.substring(start, pos);\n            numstack.push(Integer.parseInt(num));\n        } else {\n            error(\"Number, operator, or parenthesis expected.\");\n        }\n    }\n    while (opstack.size() > 0) {\n        char oldOp = opstack.pop();\n        if (oldOp == '(') {\n            error(\"No matching )\");\n        } else {\n            evaluateTop(numstack, oldOp);\n        }\n    }\n    if (numstack.size() == 0) {\n        error(\"Syntax error\");\n    }\n    System.out.println(numstack.pop());\n    if (numstack.size() > 0) {\n        error(\"Syntax error\");\n    }\n}\n","name":"main","className":"ExpressionCalculator","variables":{"Integer":1,"expression":6,"Character":2,"in":2,"pos":6,"ch":3,"oldOp":5,"numstack":5,"num":1,"start":1,"opstack":11,"done":3},"constants":{"\"\"":1,"\" \"":1,"')'":1,"'('":3,"\"No matching )\"":1,"false":1,"0":6,"\"Enter an expression: \"":1,"1":1,"\"No matching (\"":1,"true":1,"\"Number, operator, or parenthesis expected.\"":1,"\"Syntax error\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["char"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":7,"NameExpr":4,"CharLiteralExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n      Tests if a token is an operator.\n      @param s the token\n      @return true if s is one of: + - * / ^\n   */\npublic static boolean isOperator(char ch) {\n    return ch == '+' || ch == '-' || ch == '*' || ch == '/';\n}\n","name":"isOperator","className":"ExpressionCalculator","variables":{"ch":4},"constants":{"'-'":1,"'+'":1,"'*'":1,"'/'":1},"javaDoc":"Tests if a token is an operator s the token true if s is one of: + - / ^","comments":"\n      Tests if a token is an operator.\n      @param s the token\n      @return true if s is one of: + - * / ^\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"exit":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":9,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Prints an error message and exits.\n      @param message information about the error\n   */\npublic static void error(String message) {\n    System.out.println(\"ERROR: \" + message + \".\");\n    System.exit(1);\n}\n","name":"error","className":"ExpressionCalculator","variables":{"message":1,"System":1},"constants":{"1":1,"\"ERROR: \"":1,"\".\"":1},"javaDoc":"Prints an error message and exits message information about the error","comments":"\n      Prints an error message and exits.\n      @param message information about the error\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["char"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":6,"NameExpr":4,"CharLiteralExpr":4},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3},"text":"/**\n      Computes the precedence level of an operator.\n      @param s the operator\n      @return the precedence level (1 = lowest, 3 = highest)\n   */\npublic static int precedence(char ch) {\n    if (ch == '+' || ch == '-') {\n        return 1;\n    } else if (ch == '*' || ch == '/') {\n        return 2;\n    } else {\n        return 0;\n    }\n}\n","name":"precedence","className":"ExpressionCalculator","variables":{"ch":4},"constants":{"0":1,"'-'":1,"1":1,"2":1,"'+'":1,"'*'":1,"'/'":1},"javaDoc":"Computes the precedence level of an operator s the operator the precedence level (1 = lowest 3 = highest)","comments":"\n      Computes the precedence level of an operator.\n      @param s the operator\n      @return the precedence level (1 = lowest, 3 = highest)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Stack<Integer>","char"],"returnType":"void","methodCalls":{"pop":2,"size":2,"error":4,"push":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":11,"NameExpr":41,"StringLiteralExpr":4,"CharLiteralExpr":4,"MethodCallExpr":9,"AssignExpr":4},"statements":{"IfStmt":7,"BlockStmt":9,"ExpressionStmt":12},"text":"/** \n      Computes a new value and pushes it on the stack.\n      @param num the stack for the operands and result\n      @param op the operation to use\n   */\npublic static void evaluateTop(Stack<Integer> num, char op) {\n    if (num.size() == 0) {\n        error(\"Syntax error\");\n    }\n    int y = num.pop();\n    if (num.size() == 0) {\n        error(\"Syntax error\");\n    }\n    int x = num.pop();\n    int z = 0;\n    if (op == '*') {\n        z = x * y;\n    } else if (op == '/') {\n        if (y == 0) {\n            error(\"Divide by 0\");\n        } else {\n            z = x / y;\n        }\n    } else if (op == '+') {\n        z = x + y;\n    } else if (op == '-') {\n        z = x - y;\n    } else {\n        error(\"Syntax error\");\n    }\n    num.push(z);\n}\n","name":"evaluateTop","className":"ExpressionCalculator","variables":{"op":4,"num":5,"x":5,"y":6,"z":5},"constants":{"0":4,"'-'":1,"'+'":1,"'*'":1,"\"Divide by 0\"":1,"\"Syntax error\"":3,"'/'":1},"javaDoc":"Computes a new value and pushes it on the stack num the stack for the operands and result op the operation to use","comments":" \n      Computes a new value and pushes it on the stack.\n      @param num the stack for the operands and result\n      @param op the operation to use\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"hash":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int hashCode() {\n    return Objects.hash(name, area);\n}\n","name":"hashCode","className":"Country","variables":{"Objects":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Country":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":11,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean equals(Object otherObject) {\n    Country other = (Country) otherObject;\n    return name.equals(other.name) && area == other.area;\n}\n","name":"equals","className":"Country","variables":{"area":1,"other":1,"name":1,"otherObject":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"NameExpr":6,"StringLiteralExpr":3,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \",area=\" + area + \"]\";\n}\n","name":"toString","className":"Country","variables":{"area":1,"name":1},"constants":{"\"[name=\"":1,"\"]\"":1,"\",area=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"hashCode":3,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Set<Country>":1,"Country":3,"HashSet":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":3,"StringLiteralExpr":6,"NameExpr":42,"FieldAccessExpr":4,"MethodCallExpr":10},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Country country1 = new Country(\"Belgium\", 30510);\n    Country country2 = new Country(\"Thailand\", 514000);\n    Country country3 = new Country(\"Belgium\", 30510);\n    System.out.println(\"hash code of country1=\" + country1.hashCode());\n    System.out.println(\"hash code of country2=\" + country2.hashCode());\n    System.out.println(\"hash code of country3=\" + country3.hashCode());\n    // Add the countries to the hash set. \n    Set<Country> countries = new HashSet<>();\n    countries.add(country1);\n    countries.add(country2);\n    countries.add(country3);\n    // Print the set. Note that the set has two elements.\n    System.out.println(countries);\n}\n","name":"main","className":"HashCodePrinter","variables":{"country1":2,"countries":4,"country3":2,"country2":2},"constants":{"\"hash code of country2=\"":1,"\"Thailand\"":1,"\"hash code of country1=\"":1,"30510":2,"\"Belgium\"":2,"514000":1,"\"hash code of country3=\"":1},"javaDoc":"","comments":"Add the countries to the hash set Print the set Note that the set has two elements ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"size":2,"nextLine":1,"length":1,"System.out.print":3,"charAt":1,"push":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Scanner":1,"char":2,"Stack<Character>":1,"String":1,"int":1,"Stack":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":6,"BinaryExpr":24,"NameExpr":65,"StringLiteralExpr":5,"FieldAccessExpr":6,"CharLiteralExpr":12,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":12},"statements":{"IfStmt":5,"BlockStmt":7,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter an expression with { [ ( ) ] }: \");\n    String expression = in.nextLine();\n    Stack<Character> parens = new Stack<>();\n    for (int i = 0; i < expression.length(); i++) {\n        char ch = expression.charAt(i);\n        if (ch == '(' || ch == '[' || ch == '{') {\n            parens.push(ch);\n        } else if (ch == ')' || ch == ']' || ch == '}') {\n            if (parens.size() == 0) {\n                System.out.println(\"Not balanced.\");\n                return;\n            }\n            char open = parens.pop();\n            if (!(open == '(' && ch == ')' || open == '[' && ch == ']' || open == '{' && ch == '}')) {\n                System.out.println(\"Not balanced.\");\n                return;\n            }\n        }\n    }\n    if (parens.size() == 0) {\n        System.out.print(\"Balanced.\");\n    } else {\n        System.out.print(\"Not balanced.\");\n    }\n}\n","name":"main","className":"ParenChecker","variables":{"parens":5,"expression":3,"in":2,"ch":10,"i":3,"open":4},"constants":{"0":3,"']'":2,"'}'":2,"\"Not balanced.\"":3,"\"Balanced.\"":1,"'['":2,"'{'":2,"')'":2,"'('":2,"\"Enter an expression with { [ ( ) ] }: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"contains":1,"readWords":2,"System.out.println":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{"Set<String>":2,"String":1},"expressions":{"VariableDeclarationExpr":3,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) throws FileNotFoundException {\n    // Read the dictionary and the document\n    Set<String> dictionaryWords = readWords(\"words\");\n    Set<String> documentWords = readWords(\"alice30.txt\");\n    for (String word : documentWords) {\n        if (!dictionaryWords.contains(word)) {\n            System.out.println(word);\n        }\n    }\n}\n       // Print all words that are in the document but not the dictionary\n\n","name":"main","className":"SpellCheck","variables":{"documentWords":2,"dictionaryWords":2,"word":1},"constants":{"\"alice30.txt\"":1,"\"words\"":1},"javaDoc":"","comments":"Read the dictionary and the document Print all words that are in the document but not the dictionary ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"Set<String>","methodCalls":{"add":1,"next":1,"toLowerCase":1,"useDelimiter":1,"hasNext":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"Set<String>":1,"HashSet":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"NameExpr":16,"StringLiteralExpr":1,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Reads all words from a file.\n      @param filename the name of the file\n      @return a set with all lowercased words in the file. Here, a \n      word is a sequence of upper- and lowercase letters.\n   */\npublic static Set<String> readWords(String filename) throws FileNotFoundException {\n    Set<String> words = new HashSet<>();\n    Scanner in = new Scanner(new File(filename));\n    // Use any characters other than a-z or A-Z as delimiters\n    in.useDelimiter(\"[^a-zA-Z]+\");\n    while (in.hasNext()) {\n        words.add(in.next().toLowerCase());\n    }\n    return words;\n}\n","name":"readWords","className":"SpellCheck","variables":{"filename":1,"in":4,"words":3},"constants":{"\"[^a-zA-Z]+\"":1},"javaDoc":"Reads all words from a file filename the name of the file a set with all lowercased words in the file Here a word is a sequence of upper- and lowercase letters","comments":"Use any characters other than a-z or A-Z as delimiters \n      Reads all words from a file.\n      @param filename the name of the file\n      @return a set with all lowercased words in the file. Here, a \n      word is a sequence of upper- and lowercase letters.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"System.out.printf":1,"get":2,"hasNext":1,"clean":1,"keySet":1,"put":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["PolyMorphism"],"types":{"Integer":1,"Scanner":1,"Map<String, Integer>":1,"String":2,"TreeMap":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":34,"FieldAccessExpr":1,"MethodCallExpr":8,"AssignExpr":2},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":4,"ForeachStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) throws FileNotFoundException {\n    Map<String, Integer> frequencies = new TreeMap<>();\n    Scanner in = new Scanner(new File(\"alice30.txt\"));\n    while (in.hasNext()) {\n        String word = clean(in.next());\n        // Get the old frequency count\n        Integer count = frequencies.get(word);\n        if (count == null) {\n            count = 1;\n        } else {\n            count = count + 1;\n        }\n        frequencies.put(word, count);\n    }\n    for (String key : frequencies.keySet()) {\n        System.out.printf(\"%-20s%10d\\n\", key, frequencies.get(key));\n    }\n}\n       // Print all words and counts\n\n          // If there was none, put 1; otherwise, increment the count\n\n","name":"main","className":"WordFrequency","variables":{"in":3,"count":5,"frequencies":5,"word":1,"key":1},"constants":{"\"alice30.txt\"":1,"1":2,"null":1,"\"%-20s%10d\\n\"":1},"javaDoc":"","comments":"Print all words and counts Get the old frequency count If there was none put 1; otherwise increment the count ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"toLowerCase":1,"length":1,"charAt":1,"isLetter":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"char":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"StringLiteralExpr":1,"NameExpr":19,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Removes characters from a string that are not letters.\n      @param s a string\n      @return a string with all the letters from s\n   */\npublic static String clean(String s) {\n    String r = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        if (Character.isLetter(c)) {\n            r = r + c;\n        }\n    }\n    return r.toLowerCase();\n}\n","name":"clean","className":"WordFrequency","variables":{"r":4,"s":2,"c":2,"Character":1,"i":3},"constants":{"\"\"":1,"0":1},"javaDoc":"Removes characters from a string that are not letters s a string a string with all the letters from s","comments":"\n      Removes characters from a string that are not letters.\n      @param s a string\n      @return a string with all the letters from s\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double"],"returnType":"Event","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Event(double eventTime) {\n    time = eventTime;\n}\n","name":"Event","className":"Event","variables":{"eventTime":1,"time":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Simulation"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void process(Simulation sim) {\n}\n","name":"process","className":"Event","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getTime() {\n    return time;\n}\n","name":"getTime","className":"Event","variables":{"time":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":2,"NameExpr":8,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3},"text":"public int compareTo(Event other) {\n    if (time < other.time) {\n        return -1;\n    } else if (time > other.time) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","name":"compareTo","className":"Event","variables":{"time":2},"constants":{"0":1,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"Customer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n       Constructs a customer.\n       @param the time at which the customer entered the bank\n   */\npublic Customer(double time) {\n    arrivalTime = time;\n}\n","name":"Customer","className":"Customer","variables":{"arrivalTime":1,"time":1},"constants":{},"javaDoc":"Constructs a customer the time at which the customer entered the bank","comments":" \n       Constructs a customer.\n       @param the time at which the customer entered the bank\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the time at which the customer entered the bank.\n      @return the arrival time\n   */\ndouble getArrivalTime() {\n    return arrivalTime;\n}\n","name":"getArrivalTime","className":"Customer","variables":{"arrivalTime":1},"constants":{},"javaDoc":"Gets the time at which the customer entered the bank the arrival time","comments":"\n      Gets the time at which the customer entered the bank.\n      @return the arrival time\n   ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["double"],"returnType":"Arrival","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n      @param time the arrival time\n   */\npublic Arrival(double time) {\n    super(time);\n}\n","name":"Arrival","className":"Arrival","variables":{"time":1},"constants":{},"javaDoc":"time the arrival time","comments":"\n      @param time the arrival time\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Simulation"],"returnType":"void","methodCalls":{"add":1,"getCurrentTime":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"BankSimulation":1,"Customer":1,"double":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":9,"CastExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public void process(Simulation sim) {\n    double now = sim.getCurrentTime();\n    BankSimulation bank = (BankSimulation) sim;\n    Customer c = new Customer(now);\n    bank.add(c);\n}\n","name":"process","className":"Arrival","variables":{"bank":2,"c":1,"sim":2,"now":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"BankSimulation","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"NameExpr":5,"ArrayCreationExpr":1,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public BankSimulation(int numberOfTellers) {\n    tellers = new Customer[numberOfTellers];\n    custQueue = new LinkedList<>();\n    totalCustomers = 0;\n    totalTime = 0;\n}\n","name":"BankSimulation","className":"BankSimulation","variables":{"totalCustomers":1,"tellers":1,"custQueue":1,"totalTime":1,"numberOfTellers":1},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Customer"],"returnType":"void","methodCalls":{"add":1,"addEvent":1,"expdist":1,"addToTeller":1,"getCurrentTime":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BooleanLiteralExpr":2,"BinaryExpr":4,"NameExpr":25,"FieldAccessExpr":1,"UnaryExpr":3,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":5},"text":"/** \n       Adds a customer to the bank.\n       @param c the customer\n   */\npublic void add(Customer c) {\n    boolean addedToTeller = false;\n    for (int i = 0; !addedToTeller && i < tellers.length; i++) {\n        if (tellers[i] == null) {\n            addToTeller(i, c);\n            addedToTeller = true;\n        }\n    }\n    if (!addedToTeller) {\n        custQueue.add(c);\n    }\n    addEvent(new Arrival(getCurrentTime() + expdist(INTERARRIVAL)));\n}\n","name":"add","className":"BankSimulation","variables":{"tellers":1,"custQueue":1,"i":4,"addedToTeller":4},"constants":{"0":1,"null":1,"false":1,"true":1},"javaDoc":"Adds a customer to the bank c the customer","comments":" \n       Adds a customer to the bank.\n       @param c the customer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","Customer"],"returnType":"void","methodCalls":{"addEvent":1,"expdist":1,"getCurrentTime":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":11,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/**\n      Adds a customer to a teller and schedules the departure event.\n      @param i the teller number\n      @param c the customer\n   */\nprivate void addToTeller(int i, Customer c) {\n    tellers[i] = c;\n    addEvent(new Departure(getCurrentTime() + expdist(PROCESSING), i));\n}\n","name":"addToTeller","className":"BankSimulation","variables":{"c":1,"tellers":1,"i":2},"constants":{},"javaDoc":"Adds a customer to a teller and schedules the departure event i the teller number c the customer","comments":"\n      Adds a customer to a teller and schedules the departure event.\n      @param i the teller number\n      @param c the customer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"size":1,"getArrivalTime":1,"addToTeller":1,"getCurrentTime":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Customer":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":21,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"/** \n       Removes a customer from a teller.\n       @param i teller position\n   */\npublic void remove(int i) {\n    Customer c = tellers[i];\n    tellers[i] = null;\n    // Update statistics\n    totalCustomers++;\n    totalTime = totalTime + getCurrentTime() - c.getArrivalTime();\n    if (custQueue.size() > 0) {\n        addToTeller(i, custQueue.remove());\n    }\n}\n","name":"remove","className":"BankSimulation","variables":{"c":2,"totalCustomers":1,"tellers":2,"custQueue":2,"totalTime":2,"i":2},"constants":{"0":1,"null":1},"javaDoc":"Removes a customer from a teller i teller position","comments":"Update statistics  \n       Removes a customer from a teller.\n       @param i teller position\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":38,"StringLiteralExpr":4,"FieldAccessExpr":6,"UnaryExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":4,"ForStmt":2,"ExpressionStmt":6},"text":"/**\n      Displays tellers and queue.\n   */\npublic void display() {\n    for (int i = 0; i < tellers.length; i++) {\n        if (tellers[i] == null) {\n            System.out.print(\".\");\n        } else {\n            System.out.print(\"C\");\n        }\n    }\n    System.out.print(\"<\");\n    int q = custQueue.size();\n    for (int j = 1; j <= q; j++) {\n        System.out.print(\"C\");\n    }\n    System.out.println();\n}\n","name":"display","className":"BankSimulation","variables":{"q":2,"tellers":1,"custQueue":1,"i":4,"j":3},"constants":{"0":1,"\"C\"":2,"1":1,"null":1,"\".\"":1,"\"<\"":1},"javaDoc":"Displays tellers and queue","comments":"\n      Displays tellers and queue.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/** \n       Displays a summary of the gathered statistics.\n   */\npublic void displaySummary() {\n    double averageTime = 0;\n    if (totalCustomers > 0) {\n        averageTime = totalTime / totalCustomers;\n    }\n    System.out.println(totalCustomers + \" customers. Average time \" + averageTime + \" minutes.\");\n}\n","name":"displaySummary","className":"BankSimulation","variables":{"totalCustomers":3,"averageTime":3,"totalTime":1},"constants":{"0":2,"\" customers. Average time \"":1,"\" minutes.\"":1},"javaDoc":"Displays a summary of the gathered statistics","comments":" \n       Displays a summary of the gathered statistics.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","int"],"returnType":"Departure","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/**\n      @param time the departure time\n      @param teller the teller holding the customer\n   */\npublic Departure(double time, int teller) {\n    super(time);\n    this.teller = teller;\n}\n","name":"Departure","className":"Departure","variables":{"teller":1,"time":1},"constants":{},"javaDoc":"time the departure time teller the teller holding the customer","comments":"\n      @param time the departure time\n      @param teller the teller holding the customer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Simulation"],"returnType":"void","methodCalls":{"remove":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"BankSimulation":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void process(Simulation sim) {\n    BankSimulation bank = (BankSimulation) sim;\n    bank.remove(teller);\n}\n","name":"process","className":"Departure","variables":{"bank":2,"sim":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addEvent":1,"run":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables","PolyMorphism"],"types":{"BankSimulation":1,"Simulation":1,"double":2,"int":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":10,"MethodCallExpr":2},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    // 9 a.m.\n    final double START_TIME = 9 * 60;\n    // 5 p.m.\n    final double END_TIME = 17 * 60;\n    final int NTELLERS = 5;\n    Simulation sim = new BankSimulation(NTELLERS);\n    sim.addEvent(new Arrival(START_TIME));\n    sim.run(START_TIME, END_TIME);\n}\n","name":"main","className":"BankSimulationRunner","variables":{"START_TIME":2,"END_TIME":1,"sim":3,"NTELLERS":2},"constants":{"5":1,"17":1,"9":1,"60":2},"javaDoc":"","comments":"9 a m 5 p m ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Simulation","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a discrete event simulation.\n   */\npublic Simulation() {\n    eventQueue = new PriorityQueue<>();\n}\n","name":"Simulation","className":"Simulation","variables":{"eventQueue":1},"constants":{},"javaDoc":"Constructs a discrete event simulation","comments":"\n      Constructs a discrete event simulation.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getCurrentTime() {\n    return currentTime;\n}\n","name":"getCurrentTime","className":"Simulation","variables":{"currentTime":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"double","methodCalls":{"random":1,"log":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":7,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Compute exponentially distributed random numbers.\n      @param mean the mean of the number sequence\n      @return a random number\n   */\npublic static double expdist(double mean) {\n    return -mean * Math.log(1 - Math.random());\n}\n","name":"expdist","className":"Simulation","variables":{"mean":1,"Math":2},"constants":{"1":1},"javaDoc":"Compute exponentially distributed random numbers mean the mean of the number sequence a random number","comments":"\n      Compute exponentially distributed random numbers.\n      @param mean the mean of the number sequence\n      @return a random number\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Event"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds an event to the event queue.\n      @param evt the event to add\n   */\npublic void addEvent(Event evt) {\n    eventQueue.add(evt);\n}\n","name":"addEvent","className":"Simulation","variables":{"eventQueue":1},"constants":{},"javaDoc":"Adds an event to the event queue evt the event to add","comments":"\n      Adds an event to the event queue.\n      @param evt the event to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Displays intermediate results after each event.\n   */\npublic void display() {\n}\n","name":"display","className":"Simulation","variables":{},"constants":{},"javaDoc":"Displays intermediate results after each event","comments":"\n      Displays intermediate results after each event.\n   ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Displays summary results after the end of the simulation.\n   */\npublic void displaySummary() {\n}\n","name":"displaySummary","className":"Simulation","variables":{},"constants":{},"javaDoc":"Displays summary results after the end of the simulation","comments":"\n      Displays summary results after the end of the simulation.\n   ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{"process":1,"size":1,"getTime":1,"display":1,"displaySummary":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Event":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":21,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"public void run(double startTime, double endTime) {\n    currentTime = startTime;\n    while (eventQueue.size() > 0 && currentTime <= endTime) {\n        Event event = eventQueue.remove();\n        currentTime = event.getTime();\n        event.process(this);\n        display();\n    }\n    displaySummary();\n}\n","name":"run","className":"Simulation","variables":{"currentTime":3,"eventQueue":2,"startTime":1,"endTime":1,"event":3},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"workWith":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":14,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    System.out.println(\"Working with an ArrayList\");\n    workWith(new ArrayList<>());\n    System.out.println(\"Working with a TreeSet\");\n    workWith(new TreeSet<>());\n}\n","name":"main","className":"CollectionsDemo","variables":{},"constants":{"\"Working with a TreeSet\"":1,"\"Working with an ArrayList\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Collection<String>"],"returnType":"void","methodCalls":{"add":5,"contains":2,"System.out.print":4,"remove":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":70,"StringLiteralExpr":13,"FieldAccessExpr":8,"MethodCallExpr":17},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":13},"text":"/**\n      Shows how to work with a collection of strings.\n      @param coll a collection from the Java collections framework\n   */\npublic static void workWith(Collection<String> coll) {\n    coll.add(\"Harry\");\n    coll.add(\"Sally\");\n    coll.add(\"Fred\");\n    coll.add(\"Wilma\");\n    coll.add(\"Harry\");\n    System.out.println(coll);\n    System.out.print(\"Removing Harry and Tom: \");\n    System.out.print(coll.remove(\"Harry\") + \" \");\n    System.out.println(coll.remove(\"Tom\"));\n    System.out.print(\"Looking for Harry and Sally: \");\n    System.out.print(coll.contains(\"Harry\") + \" \");\n    System.out.println(coll.contains(\"Sally\"));\n    for (String s : coll) {\n        System.out.println(s);\n    }\n}\n","name":"workWith","className":"CollectionsDemo","variables":{"coll":10,"s":1},"constants":{"\"Fred\"":1,"\" \"":2,"\"Tom\"":1,"\"Wilma\"":1,"\"Removing Harry and Tom: \"":1,"\"Sally\"":2,"\"Harry\"":4,"\"Looking for Harry and Sally: \"":1},"javaDoc":"Shows how to work with a collection of strings coll a collection from the Java collections framework","comments":"\n      Shows how to work with a collection of strings.\n      @param coll a collection from the Java collections framework\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"get":1,"keySet":1,"put":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<String, Color>":1,"Set<String>":1,"HashMap":1,"Color":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":39,"StringLiteralExpr":5,"FieldAccessExpr":5,"MethodCallExpr":7},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Map<String, Color> favoriteColors = new HashMap<>();\n    favoriteColors.put(\"Juliet\", Color.BLUE);\n    favoriteColors.put(\"Romeo\", Color.GREEN);\n    favoriteColors.put(\"Adam\", Color.RED);\n    favoriteColors.put(\"Eve\", Color.BLUE);\n    // Print all keys and values in the map\n    Set<String> keySet = favoriteColors.keySet();\n    for (String key : keySet) {\n        Color value = favoriteColors.get(key);\n        System.out.println(key + \" : \" + value);\n    }\n}\n","name":"main","className":"MapDemo","variables":{"favoriteColors":7,"keySet":2,"value":2,"key":2},"constants":{"\"Eve\"":1,"\" : \"":1,"\"Juliet\"":1,"\"Adam\"":1,"\"Romeo\"":1},"javaDoc":"","comments":"Print all keys and values in the map ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BinaryTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic BinaryTree() {\n    root = null;\n}\n","name":"BinaryTree","className":"BinaryTree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"BinaryTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":2,"NameExpr":11,"FieldAccessExpr":3,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   */\npublic BinaryTree(Object rootData) {\n    root = new Node();\n    root.data = rootData;\n    root.left = null;\n    root.right = null;\n}\n","name":"BinaryTree","className":"BinaryTree","variables":{"root":1,"rootData":1},"constants":{"null":2},"javaDoc":"Constructs a tree with one node and no children rootData the data for the root","comments":"\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","BinaryTree","BinaryTree"],"returnType":"BinaryTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":17,"FieldAccessExpr":5,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a binary tree.\n      @param rootData the data for the root\n      @param left the left subtree\n      @param right the right subtree\n   */\npublic BinaryTree(Object rootData, BinaryTree left, BinaryTree right) {\n    root = new Node();\n    root.data = rootData;\n    root.left = left.root;\n    root.right = right.root;\n}\n","name":"BinaryTree","className":"BinaryTree","variables":{"root":1,"rootData":1},"constants":{},"javaDoc":"Constructs a binary tree rootData the data for the root left the left subtree right the right subtree","comments":"\n      Constructs a binary tree.\n      @param rootData the data for the root\n      @param left the left subtree\n      @param right the right subtree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node"],"returnType":"int","methodCalls":{"max":1,"height":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":14,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Returns the height of the subtree whose root is the given node.\n      @param n a node or null\n      @return the height of the subtree, or 0 if n is null\n   */\nprivate static int height(Node n) {\n    if (n == null) {\n        return 0;\n    } else {\n        return 1 + Math.max(height(n.left), height(n.right));\n    }\n}\n","name":"height","className":"BinaryTree","variables":{"Math":1,"n":1},"constants":{"0":1,"1":1,"null":1},"javaDoc":"Returns the height of the subtree whose root is the given node n a node or null the height of the subtree or 0 if n is null","comments":"\n      Returns the height of the subtree whose root is the given node.\n      @param n a node or null\n      @return the height of the subtree, or 0 if n is null\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"int","methodCalls":{"height":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the height of this tree.\n      @return the height\n   */\npublic int height() {\n    return height(root);\n}\n","name":"height","className":"BinaryTree","variables":{},"constants":{},"javaDoc":"Returns the height of this tree the height","comments":"\n      Returns the height of this tree.\n      @return the height\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this tree is empty.\n      @return true if this tree is empty\n   */\npublic boolean isEmpty() {\n    return root == null;\n}\n","name":"isEmpty","className":"BinaryTree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Checks whether this tree is empty true if this tree is empty","comments":"\n      Checks whether this tree is empty.\n      @return true if this tree is empty\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the data at the root of this tree.\n      @return the root data\n   */\npublic Object data() {\n    return root.data;\n}\n","name":"data","className":"BinaryTree","variables":{},"constants":{},"javaDoc":"Gets the data at the root of this tree the root data","comments":"\n      Gets the data at the root of this tree.\n      @return the root data\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BinaryTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"BinaryTree":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":7,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the left subtree of this tree.\n      @return the left child of the root\n   */\npublic BinaryTree left() {\n    BinaryTree result = new BinaryTree();\n    result.root = root.left;\n    return result;\n}\n","name":"left","className":"BinaryTree","variables":{"result":2},"constants":{},"javaDoc":"Gets the left subtree of this tree the left child of the root","comments":"\n      Gets the left subtree of this tree.\n      @return the left child of the root\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BinaryTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"BinaryTree":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":7,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the right subtree of this tree.\n      @return the right child of the root\n   */\npublic BinaryTree right() {\n    BinaryTree result = new BinaryTree();\n    result.root = root.right;\n    return result;\n}\n","name":"right","className":"BinaryTree","variables":{"result":2},"constants":{},"javaDoc":"Gets the right subtree of this tree the right child of the root","comments":"\n      Gets the right subtree of this tree.\n      @return the right child of the root\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"data":2,"left":1,"equals":3,"isEmpty":2,"toUpperCase":1,"right":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"boolean":1,"BinaryTree":3,"String":1},"expressions":{"ObjectCreationExpr":12,"VariableDeclarationExpr":6,"BooleanLiteralExpr":2,"BinaryExpr":3,"StringLiteralExpr":15,"NameExpr":52,"FieldAccessExpr":3,"UnaryExpr":3,"MethodCallExpr":13,"AssignExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":6,"ExpressionStmt":12,"DoStmt":1},"text":"public static void main(String[] args) {\n    BinaryTree questionTree = new BinaryTree(\"Is it a mammal?\", new BinaryTree(\"Does it have stripes?\", new BinaryTree(\"Is it a carnivore?\", new BinaryTree(\"It is a tiger.\"), new BinaryTree(\"It is a zebra.\")), new BinaryTree(\"It is a pig.\")), new BinaryTree(\"Does it fly?\", new BinaryTree(\"It is an eagle.\"), new BinaryTree(\"Does it swim?\", new BinaryTree(\"It is a penguin.\"), new BinaryTree(\"It is an ostrich.\"))));\n    boolean done = false;\n    Scanner in = new Scanner(System.in);\n    while (!done) {\n        BinaryTree left = questionTree.left();\n        BinaryTree right = questionTree.right();\n        if (left.isEmpty() && right.isEmpty()) {\n            System.out.println(questionTree.data());\n            done = true;\n        } else {\n            String response;\n            do {\n                System.out.print(questionTree.data() + \" (Y/N) \");\n                response = in.next().toUpperCase();\n            } while (!response.equals(\"Y\") && !response.equals(\"N\"));\n            if (response.equals(\"Y\")) {\n                questionTree = left;\n            } else {\n                questionTree = right;\n            }\n        }\n    }\n}\n","name":"main","className":"DecisionTreeDemo","variables":{"in":2,"left":3,"response":5,"questionTree":7,"right":3,"done":3},"constants":{"\"Does it swim?\"":1,"\"It is an eagle.\"":1,"\"It is an ostrich.\"":1,"false":1,"\"Y\"":2,"\"It is a zebra.\"":1,"\"Does it fly?\"":1,"\"It is a penguin.\"":1,"\"Is it a mammal?\"":1,"\" (Y/N) \"":1,"\"N\"":1,"\"It is a tiger.\"":1,"true":1,"\"Is it a carnivore?\"":1,"\"Does it have stripes?\"":1,"\"It is a pig.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"MinHeap","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an empty heap.\n   */\npublic MinHeap() {\n    elements = new ArrayList<>();\n    elements.add(null);\n}\n","name":"MinHeap","className":"MinHeap","variables":{"elements":2},"constants":{"null":1},"javaDoc":"Constructs an empty heap","comments":"\n      Constructs an empty heap.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"add":1,"getParent":2,"getParentIndex":1,"set":2,"size":1,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":29,"MethodCallExpr":8,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"/**\n      Adds a new element to this heap.\n      @param newElement the element to add\n   */\npublic void add(Comparable newElement) {\n    // Add a new leaf\n    elements.add(null);\n    int index = elements.size() - 1;\n    // Demote parents that are larger than the new element\n    while (index > 1 && getParent(index).compareTo(newElement) > 0) {\n        elements.set(index, getParent(index));\n        index = getParentIndex(index);\n    }\n    // Store the new element into the vacant slot\n    elements.set(index, newElement);\n}\n","name":"add","className":"MinHeap","variables":{"elements":4,"index":3},"constants":{"0":1,"1":2,"null":1},"javaDoc":"Adds a new element to this heap newElement the element to add","comments":"Add a new leaf Demote parents that are larger than the new element Store the new element into the vacant slot \n      Adds a new element to this heap.\n      @param newElement the element to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Comparable","methodCalls":{"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the minimum element stored in this heap.\n      @return the minimum element\n   */\npublic Comparable peek() {\n    return elements.get(1);\n}\n","name":"peek","className":"MinHeap","variables":{"elements":1},"constants":{"1":1},"javaDoc":"Gets the minimum element stored in this heap the minimum element","comments":"\n      Gets the minimum element stored in this heap.\n      @return the minimum element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Comparable","methodCalls":{"set":1,"size":1,"fixHeap":1,"get":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Comparable":2,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":18,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Removes the minimum element from this heap.\n      @return the minimum element\n   */\npublic Comparable remove() {\n    Comparable minimum = elements.get(1);\n    // Remove last element\n    int lastIndex = elements.size() - 1;\n    Comparable last = elements.remove(lastIndex);\n    if (lastIndex > 1) {\n        elements.set(1, last);\n        fixHeap();\n    }\n    return minimum;\n}\n","name":"remove","className":"MinHeap","variables":{"last":1,"elements":4,"lastIndex":2,"minimum":2},"constants":{"1":4},"javaDoc":"Removes the minimum element from this heap the minimum element","comments":"Remove last element \n      Removes the minimum element from this heap.\n      @return the minimum element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getLeftChildIndex":1,"set":2,"size":1,"get":1,"compareTo":2,"getRightChild":2,"getRightChildIndex":2,"getLeftChild":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Comparable":2,"boolean":1,"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":6,"BinaryExpr":6,"BooleanLiteralExpr":3,"NameExpr":51,"MethodCallExpr":12,"AssignExpr":5},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":6,"ExpressionStmt":13},"text":"/**\n      Turns the tree back into a heap, provided only the root \n      node violates the heap condition.\n   */\nprivate void fixHeap() {\n    Comparable root = elements.get(1);\n    int lastIndex = elements.size() - 1;\n    // Promote children of removed root while they are smaller than root      \n    int index = 1;\n    boolean more = true;\n    while (more) {\n        int childIndex = getLeftChildIndex(index);\n        if (childIndex <= lastIndex) {\n            // Get smaller child \n            // Get left child first\n            Comparable child = getLeftChild(index);\n            // Use right child instead if it is smaller\n            if (getRightChildIndex(index) <= lastIndex && getRightChild(index).compareTo(child) < 0) {\n                childIndex = getRightChildIndex(index);\n                child = getRightChild(index);\n            }\n            // Check if smaller child is smaller than root\n            if (child.compareTo(root) < 0) {\n                // Promote child\n                elements.set(index, child);\n                index = childIndex;\n            } else {\n                // Root is smaller than both children\n                more = false;\n            }\n        } else {\n            // No children\n            more = false;\n        }\n    }\n    // Store root element in vacant slot\n    elements.set(index, root);\n}\n","name":"fixHeap","className":"MinHeap","variables":{"more":4,"root":1,"elements":4,"index":2,"lastIndex":3,"childIndex":4,"child":3},"constants":{"0":2,"1":3,"true":1,"false":2},"javaDoc":"Turns the tree back into a heap provided only the root node violates the heap condition","comments":"Promote children of removed root while they are smaller than root Get smaller child Get left child first Use right child instead if it is smaller Check if smaller child is smaller than root Promote child Root is smaller than both children No children Store root element in vacant slot \n      Turns the tree back into a heap, provided only the root \n      node violates the heap condition.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this heap is empty.\n   */\npublic boolean empty() {\n    return elements.size() == 1;\n}\n","name":"empty","className":"MinHeap","variables":{"elements":1},"constants":{"1":1},"javaDoc":"Checks whether this heap is empty","comments":"\n      Checks whether this heap is empty.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   */\nprivate static int getLeftChildIndex(int index) {\n    return 2 * index;\n}\n","name":"getLeftChildIndex","className":"MinHeap","variables":{"index":1},"constants":{"2":1},"javaDoc":"Returns the index of the left child index the index of a node in this heap the index of the left child of the given node","comments":"\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   */\nprivate static int getRightChildIndex(int index) {\n    return 2 * index + 1;\n}\n","name":"getRightChildIndex","className":"MinHeap","variables":{"index":1},"constants":{"1":1,"2":1},"javaDoc":"Returns the index of the right child index the index of a node in this heap the index of the right child of the given node","comments":"\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the index of the parent.\n      @param index the index of a node in this heap\n      @return the index of the parent of the given node\n   */\nprivate static int getParentIndex(int index) {\n    return index / 2;\n}\n","name":"getParentIndex","className":"MinHeap","variables":{"index":1},"constants":{"2":1},"javaDoc":"Returns the index of the parent index the index of a node in this heap the index of the parent of the given node","comments":"\n      Returns the index of the parent.\n      @param index the index of a node in this heap\n      @return the index of the parent of the given node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["int"],"returnType":"Comparable","methodCalls":{"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the value of the left child.\n      @param index the index of a node in this heap\n      @return the value of the left child of the given node\n   */\nprivate Comparable getLeftChild(int index) {\n    return elements.get(2 * index);\n}\n","name":"getLeftChild","className":"MinHeap","variables":{"elements":1,"index":1},"constants":{"2":1},"javaDoc":"Returns the value of the left child index the index of a node in this heap the value of the left child of the given node","comments":"\n      Returns the value of the left child.\n      @param index the index of a node in this heap\n      @return the value of the left child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int"],"returnType":"Comparable","methodCalls":{"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the value of the right child.\n      @param index the index of a node in this heap\n      @return the value of the right child of the given node\n   */\nprivate Comparable getRightChild(int index) {\n    return elements.get(2 * index + 1);\n}\n","name":"getRightChild","className":"MinHeap","variables":{"elements":1,"index":1},"constants":{"1":1,"2":1},"javaDoc":"Returns the value of the right child index the index of a node in this heap the value of the right child of the given node","comments":"\n      Returns the value of the right child.\n      @param index the index of a node in this heap\n      @return the value of the right child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int"],"returnType":"Comparable","methodCalls":{"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the value of the parent.\n      @param index the index of a node in this heap\n      @return the value of the parent of the given node\n   */\nprivate Comparable getParent(int index) {\n    return elements.get(index / 2);\n}\n","name":"getParent","className":"MinHeap","variables":{"elements":1,"index":1},"constants":{"2":1},"javaDoc":"Returns the value of the parent index the index of a node in this heap the value of the parent of the given node","comments":"\n      Returns the value of the parent.\n      @param index the index of a node in this heap\n      @return the value of the parent of the given node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int","String"],"returnType":"WorkOrder","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   */\npublic WorkOrder(int aPriority, String aDescription) {\n    priority = aPriority;\n    description = aDescription;\n}\n","name":"WorkOrder","className":"WorkOrder","variables":{"aPriority":1,"aDescription":1,"description":1,"priority":1},"constants":{},"javaDoc":"Constructs a work order with a given priority and description aPriority the priority of this work order aDescription the description of this work order","comments":"\n      Constructs a work order with a given priority and description.\n      @param aPriority the priority of this work order\n      @param aDescription the description of this work order\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"priority=\" + priority + \", description=\" + description;\n}\n","name":"toString","className":"WorkOrder","variables":{"description":1,"priority":1},"constants":{"\", description=\"":1,"\"priority=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"WorkOrder":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":9,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":3,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    WorkOrder other = (WorkOrder) otherObject;\n    if (priority < other.priority) {\n        return -1;\n    }\n    if (priority > other.priority) {\n        return 1;\n    }\n    return 0;\n}\n","name":"compareTo","className":"WorkOrder","variables":{"other":1,"priority":2,"otherObject":1},"constants":{"0":1,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":8,"remove":1,"empty":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MinHeap":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":8,"VariableDeclarationExpr":1,"NameExpr":35,"StringLiteralExpr":8,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":11},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    MinHeap q = new MinHeap();\n    q.add(new WorkOrder(3, \"Shampoo carpets\"));\n    q.add(new WorkOrder(7, \"Empty trash\"));\n    q.add(new WorkOrder(8, \"Water plants\"));\n    q.add(new WorkOrder(10, \"Remove pencil sharpener shavings\"));\n    q.add(new WorkOrder(6, \"Replace light bulb\"));\n    q.add(new WorkOrder(1, \"Fix broken sink\"));\n    q.add(new WorkOrder(9, \"Clean coffee maker\"));\n    q.add(new WorkOrder(2, \"Order cleaning supplies\"));\n    while (!q.empty()) {\n        System.out.println(q.remove());\n    }\n}\n","name":"main","className":"HeapDemo","variables":{"q":11},"constants":{"\"Remove pencil sharpener shavings\"":1,"\"Order cleaning supplies\"":1,"\"Shampoo carpets\"":1,"\"Fix broken sink\"":1,"\"Replace light bulb\"":1,"1":1,"2":1,"3":1,"6":1,"7":1,"\"Empty trash\"":1,"8":1,"9":1,"\"Water plants\"":1,"\"Clean coffee maker\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":10,"print":1,"remove":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BinarySearchTree":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":50,"StringLiteralExpr":15,"FieldAccessExpr":1,"MethodCallExpr":16},"statements":{"ExpressionStmt":17},"text":"public static void main(String[] args) {\n    BinarySearchTree t = new BinarySearchTree();\n    t.add(\"D\");\n    t.add(\"B\");\n    t.add(\"A\");\n    t.add(\"C\");\n    t.add(\"F\");\n    t.add(\"E\");\n    t.add(\"I\");\n    t.add(\"G\");\n    t.add(\"H\");\n    t.add(\"J\");\n    // Removing leaf\n    t.remove(\"A\");\n    // Removing element with one child\n    t.remove(\"B\");\n    // Removing element with two children\n    t.remove(\"F\");\n    // Removing root\n    t.remove(\"D\");\n    t.print();\n    System.out.println(\"Expected: C E G H I J\");\n}\n","name":"main","className":"TreeTester","variables":{"t":16},"constants":{"\"D\"":2,"\"C\"":1,"\"B\"":2,"\"A\"":2,"\"Expected: C E G H I J\"":1,"\"J\"":1,"\"I\"":1,"\"H\"":1,"\"G\"":1,"\"F\"":2,"\"E\"":1},"javaDoc":"","comments":"Removing leaf Removing element with one child Removing element with two children Removing root ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BinarySearchTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic BinarySearchTree() {\n    root = null;\n}\n","name":"BinarySearchTree","className":"BinarySearchTree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"addNode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":17,"FieldAccessExpr":3,"AssignExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(Comparable obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n}\n","name":"add","className":"BinarySearchTree","variables":{"obj":1,"root":3,"newNode":2},"constants":{"null":3},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":3,"MethodCallExpr":1,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(Comparable obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"BinarySearchTree","variables":{"current":4,"d":3,"root":1},"constants":{"0":2,"null":1,"true":1,"false":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"toBeRemoved.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Node":5,"int":1},"expressions":{"NullLiteralExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"BooleanLiteralExpr":2,"BinaryExpr":12,"NameExpr":88,"FieldAccessExpr":20,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":14},"statements":{"IfStmt":8,"WhileStmt":2,"BlockStmt":15,"ReturnStmt":2,"ExpressionStmt":21},"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(Comparable obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    Node parent = null;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            parent = toBeRemoved;\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        if (// Found in root\n        parent == null) {\n            root = newChild;\n        } else if (parent.left == toBeRemoved) {\n            parent.left = newChild;\n        } else {\n            parent.right = newChild;\n        }\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallestParent = toBeRemoved;\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallestParent = smallest;\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    if (smallestParent == toBeRemoved) {\n        smallestParent.right = smallest.right;\n    } else {\n        smallestParent.left = smallest.right;\n    }\n}\n       // toBeRemoved contains obj\n\n       // If one of the children is empty, use the other\n\n","name":"remove","className":"BinarySearchTree","variables":{"parent":3,"smallestParent":3,"toBeRemoved":8,"found":4,"d":3,"newChild":6,"smallest":3,"root":2},"constants":{"0":2,"null":7,"false":1,"true":1},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child Found in root \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Prints the contents of the tree in sorted order.\n   */\npublic void print() {\n    print(root);\n    System.out.println();\n}\n","name":"print","className":"BinarySearchTree","variables":{},"constants":{},"javaDoc":"Prints the contents of the tree in sorted order","comments":"\n      Prints the contents of the tree in sorted order.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"print":2,"System.out.print":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":2,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":4,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   */\nprivate static void print(Node parent) {\n    if (parent == null) {\n        return;\n    }\n    print(parent.left);\n    System.out.print(parent.data + \" \");\n    print(parent.right);\n}\n","name":"print","className":"BinarySearchTree","variables":{"parent":1},"constants":{"null":1,"\" \"":1},"javaDoc":"Prints a node and all of its descendants in sorted order parent the root of the subtree to print","comments":"\n      Prints a node and all of its descendants in sorted order.\n      @param parent the root of the subtree to print\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":4,"BlockStmt":6,"ExpressionStmt":5},"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":2,"right":3},"constants":{"0":2,"null":2},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Map<Character, Integer>"],"returnType":"HuffmanTree","methodCalls":{"add":2,"size":1,"get":1,"keySet":1,"remove":3},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Node":4,"char":1,"PriorityQueue":1,"PriorityQueue<Node>":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":2,"NameExpr":52,"FieldAccessExpr":7,"MethodCallExpr":8,"AssignExpr":6},"statements":{"WhileStmt":1,"BlockStmt":2,"ForeachStmt":1,"ExpressionStmt":13},"text":"/**\n      Constructs a Huffman tree from given character frequencies.\n      @param frequencies a map whose keys are the characters to be encoded\n      and whose values are the frequencies of the characters\n   */\npublic HuffmanTree(Map<Character, Integer> frequencies) {\n    PriorityQueue<Node> nodes = new PriorityQueue<>();\n    for (char ch : frequencies.keySet()) {\n        Node newNode = new Node();\n        newNode.character = ch;\n        newNode.frequency = frequencies.get(ch);\n        nodes.add(newNode);\n    }\n    while (nodes.size() > 1) {\n        Node smallest = nodes.remove();\n        Node nextSmallest = nodes.remove();\n        Node newNode = new Node();\n        newNode.frequency = smallest.frequency + nextSmallest.frequency;\n        newNode.left = smallest;\n        newNode.right = nextSmallest;\n        nodes.add(newNode);\n    }\n    root = nodes.remove();\n}\n","name":"HuffmanTree","className":"HuffmanTree","variables":{"nextSmallest":2,"nodes":7,"ch":2,"smallest":2,"root":1,"newNode":2,"frequencies":2},"constants":{"1":1},"javaDoc":"Constructs a Huffman tree from given character frequencies frequencies a map whose keys are the characters to be encoded and whose values are the frequencies of the characters","comments":"\n      Constructs a Huffman tree from given character frequencies.\n      @param frequencies a map whose keys are the characters to be encoded\n      and whose values are the frequencies of the characters\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"length":1,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"char":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":4,"StringLiteralExpr":1,"NameExpr":30,"CharLiteralExpr":1,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":4},"statements":{"IfStmt":2,"BlockStmt":4,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"/**\n      Decodes an encoded string.\n      @param input a string made up of 0 and 1\n   */\npublic String decode(String input) {\n    String result = \"\";\n    Node n = root;\n    for (int i = 0; i < input.length(); i++) {\n        char ch = input.charAt(i);\n        if (ch == '0') {\n            n = n.left;\n        } else {\n            n = n.right;\n        }\n        if (// n is a leaf\n        n.left == null) {\n            result = result + n.character;\n            n = root;\n        }\n    }\n    return result;\n}\n","name":"decode","className":"HuffmanTree","variables":{"result":4,"input":2,"ch":2,"root":2,"i":3,"n":4},"constants":{"\"\"":1,"0":1,"null":1,"'0'":1},"javaDoc":"Decodes an encoded string input a string made up of 0 and 1","comments":"n is a leaf \n      Decodes an encoded string.\n      @param input a string made up of 0 and 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Map<Character, String>","methodCalls":{"fillEncodingMap":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<Character, String>":1,"HashMap":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public Map<Character, String> getEncodingMap() {\n    Map<Character, String> map = new HashMap<>();\n    if (root != null) {\n        root.fillEncodingMap(map, \"\");\n    }\n    return map;\n}\n","name":"getEncodingMap","className":"HuffmanTree","variables":{"root":2,"map":2},"constants":{"\"\"":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"ReturnStmt":1},"text":"public int compareTo(Node other) {\n    return frequency - other.frequency;\n}\n","name":"compareTo","className":"Node","variables":{"frequency":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Map<Character, String>","String"],"returnType":"void","methodCalls":{"fillEncodingMap":2,"put":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":3,"NameExpr":16,"StringLiteralExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public void fillEncodingMap(Map<Character, String> map, String prefix) {\n    if (// it's a leaf\n    left == null) {\n        map.put(character, prefix);\n    } else {\n        left.fillEncodingMap(map, prefix + \"0\");\n        right.fillEncodingMap(map, prefix + \"1\");\n    }\n}\n","name":"fillEncodingMap","className":"Node","variables":{"left":2,"prefix":2,"right":1,"map":1},"constants":{"\"1\"":1,"null":1,"\"0\"":1},"javaDoc":"","comments":"it's a leaf ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"encode":1,"getEncodingMap":1,"decode":1,"put":13,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<Character, String>":1,"HashMap":1,"Map<Character, Integer>":1,"HuffmanTree":1,"String":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":13,"VariableDeclarationExpr":5,"NameExpr":62,"StringLiteralExpr":1,"CharLiteralExpr":13,"FieldAccessExpr":2,"MethodCallExpr":18},"statements":{"ExpressionStmt":20},"text":"public static void main(String[] args) {\n    Map<Character, Integer> frequencyMap = new HashMap<>();\n    frequencyMap.put('A', 2089);\n    frequencyMap.put('E', 576);\n    frequencyMap.put('H', 357);\n    frequencyMap.put('I', 671);\n    frequencyMap.put('K', 849);\n    frequencyMap.put('L', 354);\n    frequencyMap.put('M', 259);\n    frequencyMap.put('N', 660);\n    frequencyMap.put('O', 844);\n    frequencyMap.put('P', 239);\n    frequencyMap.put('U', 472);\n    frequencyMap.put('W', 74);\n    frequencyMap.put('\\'', 541);\n    HuffmanTree tree = new HuffmanTree(frequencyMap);\n    Map<Character, String> encodingMap = tree.getEncodingMap();\n    String encoded = encode(\"ALOHA\", encodingMap);\n    System.out.println(encoded);\n    String decoded = tree.decode(encoded);\n    System.out.println(decoded);\n}\n","name":"main","className":"HuffmanDemo","variables":{"encodingMap":1,"tree":3,"decoded":1,"frequencyMap":15,"encoded":1},"constants":{"'N'":1,"'L'":1,"'H'":1,"472":1,"671":1,"354":1,"576":1,"357":1,"259":1,"'W'":1,"239":1,"'U'":1,"74":1,"'O'":1,"'M'":1,"'K'":1,"'I'":1,"'\\''":1,"2089":1,"'E'":1,"'A'":1,"660":1,"541":1,"\"ALOHA\"":1,"844":1,"849":1,"'P'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Map<Character, String>"],"returnType":"String","methodCalls":{"get":1,"length":1,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"char":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"StringLiteralExpr":1,"NameExpr":16,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public static String encode(String toEncode, Map<Character, String> encodingMap) {\n    String result = \"\";\n    for (int i = 0; i < toEncode.length(); i++) {\n        char ch = toEncode.charAt(i);\n        result = result + encodingMap.get(ch);\n    }\n    return result;\n}\n","name":"encode","className":"HuffmanDemo","variables":{"result":4,"ch":1,"encodingMap":1,"toEncode":2,"i":3},"constants":{"\"\"":1,"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"removalTestTemplate":1,"insertionTest":1,"removalTest":1,"testFromBook":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    testFromBook();\n    insertionTest(\"ABCDEFGHIJ\");\n    removalTest(removalTestTemplate());\n    System.out.println(\"All tests passed.\");\n}\n","name":"main","className":"RedBlackTreeTester","variables":{},"constants":{"\"ABCDEFGHIJ\"":1,"\"All tests passed.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":10,"assertEquals":1,"toString":1,"remove":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"RedBlackTree":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":47,"StringLiteralExpr":15,"MethodCallExpr":16},"statements":{"ExpressionStmt":16},"text":"/**\n      Runs the simple test from the textbook.\n   */\npublic static void testFromBook() {\n    RedBlackTree t = new RedBlackTree();\n    t.add(\"D\");\n    t.add(\"B\");\n    t.add(\"A\");\n    t.add(\"C\");\n    t.add(\"F\");\n    t.add(\"E\");\n    t.add(\"I\");\n    t.add(\"G\");\n    t.add(\"H\");\n    t.add(\"J\");\n    // Removing leaf\n    t.remove(\"A\");\n    // Removing element with one child\n    t.remove(\"B\");\n    // Removing element with two children\n    t.remove(\"F\");\n    // Removing root      \n    t.remove(\"D\");\n    assertEquals(\"C E G H I J \", t.toString());\n}\n","name":"testFromBook","className":"RedBlackTreeTester","variables":{"t":16},"constants":{"\"D\"":2,"\"C\"":1,"\"B\"":2,"\"A\"":2,"\"J\"":1,"\"I\"":1,"\"H\"":1,"\"C E G H I J \"":1,"\"G\"":1,"\"F\"":2,"\"E\"":1},"javaDoc":"Runs the simple test from the textbook","comments":"Removing leaf Removing element with one child Removing element with two children Removing root \n      Runs the simple test from the textbook.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getPermutations":1,"add":1,"length":1,"replace":1,"assertEquals":1,"toString":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"RedBlackTree":1,"PermutationGenerator":1,"String":2,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":2,"NameExpr":26,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"BlockStmt":2,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Inserts all permutations of a string into a red-black tree and checks that \n      it contains the strings afterwards.\n      @param letters a string of letters without repetition\n   */\npublic static void insertionTest(String letters) {\n    PermutationGenerator gen = new PermutationGenerator(letters);\n    for (String perm : gen.getPermutations()) {\n        RedBlackTree t = new RedBlackTree();\n        for (int i = 0; i < perm.length(); i++) {\n            String s = perm.substring(i, i + 1);\n            t.add(s);\n        }\n        assertEquals(letters, t.toString().replace(\" \", \"\"));\n    }\n}\n","name":"insertionTest","className":"RedBlackTreeTester","variables":{"gen":2,"s":1,"perm":3,"t":3,"i":4,"letters":1},"constants":{"0":1,"\"\"":1,"1":1,"\" \"":1},"javaDoc":"Inserts all permutations of a string into a red-black tree and checks that it contains the strings afterwards letters a string of letters without repetition","comments":"\n      Inserts all permutations of a string into a red-black tree and checks that \n      it contains the strings afterwards.\n      @param letters a string of letters without repetition\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["RedBlackTree"],"returnType":"void","methodCalls":{"mirror":1,"getNodes":1,"count":1,"costToRoot":2,"remove":1,"populate":1,"setLeftChild":1,"find":2,"checkRedBlack":2,"equals":1,"pow":1,"copy":1,"fullTree":2,"setRightChild":1},"annotations":[],"exceptions":["IllegalStateException"],"concepts":["ExceptionHandling"],"types":{"RedBlackTree.Node[]":1,"Integer":1,"RedBlackTree":1,"Comparable":1,"boolean":1,"RedBlackTree.Node":3,"int":7},"expressions":{"IntegerLiteralExpr":9,"ObjectCreationExpr":3,"NullLiteralExpr":3,"VariableDeclarationExpr":15,"BinaryExpr":15,"BooleanLiteralExpr":2,"NameExpr":120,"StringLiteralExpr":2,"FieldAccessExpr":14,"UnaryExpr":5,"MethodCallExpr":18,"AssignExpr":7},"statements":{"IfStmt":8,"BlockStmt":17,"TryStmt":1,"ForeachStmt":2,"ForStmt":3,"ThrowStmt":2,"ExpressionStmt":22},"text":"/**\n      Tests removal, given a template for a tree with a black node that\n      is to be deleted. All other nodes should be given all possible combinations \n      of red and black.\n      @param t the template for the test cases\n   */\npublic static void removalTest(RedBlackTree t) {\n    for (int m = 0; m <= 1; m++) {\n        // We don't recolor the root or toDelete\n        int nodesToColor = count(t.root) - 2;\n        for (int k = 0; k < Math.pow(2, nodesToColor); k++) {\n            RedBlackTree rb = new RedBlackTree();\n            if (m == 0) {\n                rb.root = copy(t.root);\n            } else {\n                rb.root = mirror(t.root);\n            }\n            RedBlackTree.Node[] nodes = getNodes(rb);\n            RedBlackTree.Node toDelete = null;\n            // Color with the bit pattern of k\n            int bits = k;\n            for (RedBlackTree.Node n : nodes) {\n                if (n == rb.root) {\n                    n.color = RedBlackTree.BLACK;\n                } else if (n.color == RedBlackTree.BLACK) {\n                    toDelete = n;\n                } else {\n                    n.color = bits % 2;\n                    bits = bits / 2;\n                }\n            }\n            // Add children to make equal costs to null\n            int targetCost = costToRoot(toDelete);\n            for (RedBlackTree.Node n : nodes) {\n                int cost = targetCost - costToRoot(n);\n                if (n.left == null) {\n                    n.setLeftChild(fullTree(cost));\n                }\n                if (n.right == null) {\n                    n.setRightChild(fullTree(cost));\n                }\n            }\n            int filledSize = populate(rb);\n            boolean good = true;\n            try {\n                checkRedBlack(rb);\n            } catch (IllegalStateException ex) {\n                good = false;\n            }\n            if (good) {\n                Comparable d = toDelete.data;\n                rb.remove(d);\n                checkRedBlack(rb);\n                for (Integer j = 0; j < filledSize; j++) {\n                    if (!rb.find(j) && !d.equals(j)) {\n                        throw new IllegalStateException(j + \" deleted\");\n                    }\n                    if (rb.find(d)) {\n                        throw new IllegalStateException(d + \" not deleted\");\n                    }\n                }\n            }\n        }\n    }\n}\n","name":"removalTest","className":"RedBlackTreeTester","variables":{"toDelete":2,"cost":1,"d":3,"targetCost":2,"bits":4,"j":4,"k":4,"Math":1,"m":4,"good":3,"n":6,"rb":4,"nodes":3,"ex":1,"filledSize":2,"nodesToColor":1},"constants":{"0":4,"1":1,"\" not deleted\"":1,"2":4,"null":3,"true":1,"false":1,"\" deleted\"":1},"javaDoc":"Tests removal given a template for a tree with a black node that is to be deleted All other nodes should be given all possible combinations of red and black t the template for the test cases","comments":"We don't recolor the root or toDelete Color with the bit pattern of k Add children to make equal costs to null \n      Tests removal, given a template for a tree with a black node that\n      is to be deleted. All other nodes should be given all possible combinations \n      of red and black.\n      @param t the template for the test cases\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"RedBlackTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"RedBlackTree.Node[]":1,"RedBlackTree":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":20,"VariableDeclarationExpr":3,"ArrayAccessExpr":19,"BinaryExpr":1,"NameExpr":50,"FieldAccessExpr":4,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":8},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":13},"text":"/**\n      Makes a template for testing removal.\n      @return a partially complete red-black tree for the test. \n      The node to be removed is black.\n   */\nprivate static RedBlackTree removalTestTemplate() {\n    RedBlackTree template = new RedBlackTree();\n    /*\n                            n7\n                           /  \\\n                          n1   n8\n                         /  \\\n                       n0    n3\n                            /  \\\n                           n2*  n5\n                                /\\\n                              n4  n6\n      */\n    RedBlackTree.Node[] n = new RedBlackTree.Node[9];\n    for (int i = 0; i < n.length; i++) {\n        n[i] = new RedBlackTree.Node();\n    }\n    template.root = n[7];\n    n[7].setLeftChild(n[1]);\n    n[7].setRightChild(n[8]);\n    n[1].setLeftChild(n[0]);\n    n[1].setRightChild(n[3]);\n    n[3].setLeftChild(n[2]);\n    n[3].setRightChild(n[5]);\n    n[5].setLeftChild(n[4]);\n    n[5].setRightChild(n[6]);\n    n[2].color = RedBlackTree.BLACK;\n    return template;\n}\n","name":"removalTestTemplate","className":"RedBlackTreeTester","variables":{"template":2,"i":4,"n":20},"constants":{"0":2,"1":3,"2":2,"3":3,"4":1,"5":3,"6":1,"7":3,"8":1,"9":1},"javaDoc":"Makes a template for testing removal a partially complete red-black tree for the test The node to be removed is black","comments":"n7 / \\ n1 n8 / \\ n0 n3 / \\ n2 n5 /\\ n4 n6 \n      Makes a template for testing removal.\n      @return a partially complete red-black tree for the test. \n      The node to be removed is black.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["RedBlackTree"],"returnType":"RedBlackTree.Node[]","methodCalls":{"getNodes":1,"count":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"RedBlackTree.Node[]":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":12,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets all nodes of this tree in sorted order.\n      @param t a red-black tree\n      @return an array of all nodes in t\n   */\nprivate static RedBlackTree.Node[] getNodes(RedBlackTree t) {\n    RedBlackTree.Node[] nodes = new RedBlackTree.Node[count(t.root)];\n    getNodes(t.root, nodes, 0);\n    return nodes;\n}\n","name":"getNodes","className":"RedBlackTreeTester","variables":{"nodes":2},"constants":{"0":1},"javaDoc":"Gets all nodes of this tree in sorted order t a red-black tree an array of all nodes in t","comments":"\n      Gets all nodes of this tree in sorted order.\n      @param t a red-black tree\n      @return an array of all nodes in t\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["RedBlackTree.Node","RedBlackTree.Node[]","int"],"returnType":"int","methodCalls":{"getNodes":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":22,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":3},"text":"/**\n      Gets all nodes of a subtree and fills them into an array.\n      @param n the root of the subtree\n      @param nodes the array into which to place the nodes\n      @param start the offset at which to start placing the nodes\n      @return the number of nodes placed\n   */\nprivate static int getNodes(RedBlackTree.Node n, RedBlackTree.Node[] nodes, int start) {\n    if (n == null) {\n        return 0;\n    }\n    int leftFilled = getNodes(n.left, nodes, start);\n    nodes[start + leftFilled] = n;\n    int rightFilled = getNodes(n.right, nodes, start + leftFilled + 1);\n    return leftFilled + 1 + rightFilled;\n}\n","name":"getNodes","className":"RedBlackTreeTester","variables":{"nodes":1,"rightFilled":2,"start":2,"leftFilled":4,"n":2},"constants":{"0":1,"1":2,"null":1},"javaDoc":"Gets all nodes of a subtree and fills them into an array n the root of the subtree nodes the array into which to place the nodes start the offset at which to start placing the nodes the number of nodes placed","comments":"\n      Gets all nodes of a subtree and fills them into an array.\n      @param n the root of the subtree\n      @param nodes the array into which to place the nodes\n      @param start the offset at which to start placing the nodes\n      @return the number of nodes placed\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":11,"FieldAccessExpr":2,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the cost from a node to a root.\n      @param n a node of a red-black tree\n      @return the number of black nodes between n and the root\n   */\nprivate static int costToRoot(RedBlackTree.Node n) {\n    int c = 0;\n    while (n != null) {\n        c = c + n.color;\n        n = n.parent;\n    }\n    return c;\n}\n","name":"costToRoot","className":"RedBlackTreeTester","variables":{"c":4,"n":2},"constants":{"0":1,"null":1},"javaDoc":"Computes the cost from a node to a root n a node of a red-black tree the number of black nodes between n and the root","comments":"\n      Computes the cost from a node to a root.\n      @param n a node of a red-black tree\n      @return the number of black nodes between n and the root\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"RedBlackTree.Node","methodCalls":{"setLeftChild":1,"copy":2,"setRightChild":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"RedBlackTree.Node":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":30,"FieldAccessExpr":6,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":5},"text":"/**\n      Copies all nodes of a red-black tree.\n      @param n the root of a red-black tree\n      @return the root node of a copy of the tree\n   */\nprivate static RedBlackTree.Node copy(RedBlackTree.Node n) {\n    if (n == null) {\n        return null;\n    }\n    RedBlackTree.Node newNode = new RedBlackTree.Node();\n    newNode.setLeftChild(copy(n.left));\n    newNode.setRightChild(copy(n.right));\n    newNode.data = n.data;\n    newNode.color = n.color;\n    return newNode;\n}\n","name":"copy","className":"RedBlackTreeTester","variables":{"newNode":4,"n":1},"constants":{"null":2},"javaDoc":"Copies all nodes of a red-black tree n the root of a red-black tree the root node of a copy of the tree","comments":"\n      Copies all nodes of a red-black tree.\n      @param n the root of a red-black tree\n      @return the root node of a copy of the tree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"RedBlackTree.Node","methodCalls":{"mirror":2,"setLeftChild":1,"setRightChild":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"RedBlackTree.Node":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":30,"FieldAccessExpr":6,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":5},"text":"/**\n      Generates the mirror image of a red-black tree\n      @param n the root of the tree to reflect\n      @return the root of the mirror image of the tree\n   */\nprivate static RedBlackTree.Node mirror(RedBlackTree.Node n) {\n    if (n == null) {\n        return null;\n    }\n    RedBlackTree.Node newNode = new RedBlackTree.Node();\n    newNode.setLeftChild(mirror(n.right));\n    newNode.setRightChild(mirror(n.left));\n    newNode.data = n.data;\n    newNode.color = n.color;\n    return newNode;\n}\n","name":"mirror","className":"RedBlackTreeTester","variables":{"newNode":4,"n":1},"constants":{"null":2},"javaDoc":"Generates the mirror image of a red-black tree n the root of the tree to reflect the root of the mirror image of the tree","comments":"\n      Generates the mirror image of a red-black tree\n      @param n the root of the tree to reflect\n      @return the root of the mirror image of the tree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["int"],"returnType":"RedBlackTree.Node","methodCalls":{"setLeftChild":1,"fullTree":2,"setRightChild":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"RedBlackTree.Node":1},"expressions":{"IntegerLiteralExpr":3,"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":20,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Makes a full tree of black nodes of a given depth.\n      @param depth the desired depth\n      @return the root node of a full black tree\n   */\nprivate static RedBlackTree.Node fullTree(int depth) {\n    if (depth <= 0) {\n        return null;\n    }\n    RedBlackTree.Node r = new RedBlackTree.Node();\n    r.color = RedBlackTree.BLACK;\n    r.setLeftChild(fullTree(depth - 1));\n    r.setRightChild(fullTree(depth - 1));\n    return r;\n}\n","name":"fullTree","className":"RedBlackTreeTester","variables":{"r":4,"depth":3},"constants":{"0":1,"1":2,"null":1},"javaDoc":"Makes a full tree of black nodes of a given depth depth the desired depth the root node of a full black tree","comments":"\n      Makes a full tree of black nodes of a given depth.\n      @param depth the desired depth\n      @return the root node of a full black tree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["RedBlackTree.Node"],"returnType":"int","methodCalls":{"count":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":11,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Counts the nodes in a tree\n      @param n the root of a red-black tree\n      @return the number of nodes in the tree\n   */\nprivate static int count(RedBlackTree.Node n) {\n    if (n == null) {\n        return 0;\n    } else {\n        return 1 + count(n.left) + count(n.right);\n    }\n}\n","name":"count","className":"RedBlackTreeTester","variables":{"n":1},"constants":{"0":1,"1":1,"null":1},"javaDoc":"Counts the nodes in a tree n the root of a red-black tree the number of nodes in the tree","comments":"\n      Counts the nodes in a tree\n      @param n the root of a red-black tree\n      @return the number of nodes in the tree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["RedBlackTree"],"returnType":"int","methodCalls":{"getNodes":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"RedBlackTree.Node[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":16,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Populates this tree with the values 0, 1, 2, ... .\n      @param t a red-black tree\n      @return the number of nodes in t\n   */\nprivate static int populate(RedBlackTree t) {\n    RedBlackTree.Node[] nodes = getNodes(t);\n    for (int i = 0; i < nodes.length; i++) {\n        nodes[i].data = new Integer(i);\n    }\n    return nodes.length;\n}\n","name":"populate","className":"RedBlackTreeTester","variables":{"nodes":2,"i":5},"constants":{"0":1},"javaDoc":"Populates this tree with the values 0 1 2 t a red-black tree the number of nodes in t","comments":"\n      Populates this tree with the values 0, 1, 2, ... .\n      @param t a red-black tree\n      @return the number of nodes in t\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["RedBlackTree"],"returnType":"void","methodCalls":{"nodes[i].data.compareTo":1,"getNodes":1,"checkRedBlack":1},"annotations":[],"exceptions":["IllegalStateException"],"concepts":["Recursion"],"types":{"RedBlackTree.Node[]":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BooleanLiteralExpr":1,"BinaryExpr":7,"NameExpr":31,"StringLiteralExpr":1,"FieldAccessExpr":6,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ThrowStmt":1,"ExpressionStmt":2},"text":"/**\n      Checks whether a red-black tree is valid and throws an exception if not.\n      @param t the tree to test\n   */\npublic static void checkRedBlack(RedBlackTree t) {\n    checkRedBlack(t.root, true);\n    // Check that it's a BST\n    RedBlackTree.Node[] nodes = getNodes(t);\n    for (int i = 0; i < nodes.length - 1; i++) {\n        if (nodes[i].data.compareTo(nodes[i + 1].data) > 0) {\n            throw new IllegalStateException(nodes[i].data + \" is larger than \" + nodes[i + 1].data);\n        }\n    }\n}\n","name":"checkRedBlack","className":"RedBlackTreeTester","variables":{"nodes":5,"i":7},"constants":{"0":2,"1":3,"true":1,"\" is larger than \"":1},"javaDoc":"Checks whether a red-black tree is valid and throws an exception if not t the tree to test","comments":"Check that it's a BST \n      Checks whether a red-black tree is valid and throws an exception if not.\n      @param t the tree to test\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["RedBlackTree.Node","boolean"],"returnType":"int","methodCalls":{"checkRedBlack":2},"annotations":[],"exceptions":["IllegalStateException"],"concepts":["Recursion"],"types":{"int":2},"expressions":{"NullLiteralExpr":4,"IntegerLiteralExpr":1,"ObjectCreationExpr":8,"VariableDeclarationExpr":2,"BinaryExpr":31,"BooleanLiteralExpr":2,"NameExpr":99,"StringLiteralExpr":13,"FieldAccessExpr":30,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":10,"BlockStmt":11,"ReturnStmt":2,"ThrowStmt":8,"ExpressionStmt":2},"text":"/**\n      Checks that the tree with the given node is a red-black tree, and throws an\n      exception if a structural error is found.\n      @param n the root of the subtree to check\n      @param isRoot true if this is the root of the tree\n      @return the black depth of this subtree \n   */\nprivate static int checkRedBlack(RedBlackTree.Node n, boolean isRoot) {\n    if (n == null) {\n        return 0;\n    }\n    int nleft = checkRedBlack(n.left, false);\n    int nright = checkRedBlack(n.right, false);\n    if (nleft != nright) {\n        throw new IllegalStateException(\"Left and right children of \" + n.data + \" have different black depths\");\n    }\n    if (n.parent == null) {\n        if (!isRoot) {\n            throw new IllegalStateException(n.data + \" is not root and has no parent\");\n        }\n        if (n.color != RedBlackTree.BLACK) {\n            throw new IllegalStateException(\"Root \" + n.data + \" is not black\");\n        }\n    } else {\n        if (isRoot) {\n            throw new IllegalStateException(n.data + \" is root and has a parent\");\n        }\n        if (n.color == RedBlackTree.RED && n.parent.color == RedBlackTree.RED) {\n            throw new IllegalStateException(\"Parent of red \" + n.data + \" is red\");\n        }\n    }\n    if (n.left != null && n.left.parent != n) {\n        throw new IllegalStateException(\"Left child of \" + n.data + \" has bad parent link\");\n    }\n    if (n.right != null && n.right.parent != n) {\n        throw new IllegalStateException(\"Right child of \" + n.data + \" has bad parent link\");\n    }\n    if (n.color != RedBlackTree.RED && n.color != RedBlackTree.BLACK) {\n        throw new IllegalStateException(n.data + \" has color \" + n.color);\n    }\n    return n.color + nleft;\n}\n","name":"checkRedBlack","className":"RedBlackTreeTester","variables":{"nright":2,"isRoot":2,"nleft":3,"n":3},"constants":{"false":2,"\" have different black depths\"":1,"\" is not root and has no parent\"":1,"\" is red\"":1,"\" has bad parent link\"":2,"\" is not black\"":1,"\"Parent of red \"":1,"\"Left child of \"":1,"0":1,"\"Left and right children of \"":1,"null":4,"\" has color \"":1,"\"Root \"":1,"\" is root and has a parent\"":1,"\"Right child of \"":1},"javaDoc":"Checks that the tree with the given node is a red-black tree and throws an exception if a structural error is found n the root of the subtree to check isRoot true if this is the root of the tree the black depth of this subtree","comments":"\n      Checks that the tree with the given node is a red-black tree, and throws an\n      exception if a structural error is found.\n      @param n the root of the subtree to check\n      @param isRoot true if this is the root of the tree\n      @return the black depth of this subtree \n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Object","Object"],"returnType":"void","methodCalls":{"equals":1},"annotations":[],"exceptions":["AssertionError"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"BinaryExpr":7,"NameExpr":8,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1},"text":"public static void assertEquals(Object expected, Object actual) {\n    if (expected == null && actual != null || !expected.equals(actual)) {\n        throw new AssertionError(\"Expected \" + expected + \" but found \" + actual);\n    }\n}\n","name":"assertEquals","className":"RedBlackTreeTester","variables":{"actual":2,"expected":3},"constants":{"null":2,"\"Expected \"":1,"\" but found \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"PermutationGenerator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a permutation generator.\n      @param aWord the word to permute\n   */\npublic PermutationGenerator(String aWord) {\n    word = aWord;\n}\n","name":"PermutationGenerator","className":"PermutationGenerator","variables":{"aWord":1,"word":1},"constants":{},"javaDoc":"Constructs a permutation generator aWord the word to permute","comments":"\n      Constructs a permutation generator.\n      @param aWord the word to permute\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ArrayList<String>","methodCalls":{"add":2,"getPermutations":1,"length":2,"substring":2,"charAt":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayList":1,"ArrayList<String>":2,"String":2,"PermutationGenerator":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":6,"BinaryExpr":5,"NameExpr":35,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":6},"text":"/**\n      Gets all permutations of a given word.\n   */\npublic ArrayList<String> getPermutations() {\n    ArrayList<String> permutations = new ArrayList<>();\n    // The empty string has a single permutation: itself\n    if (word.length() == 0) {\n        permutations.add(word);\n        return permutations;\n    }\n    // Loop through all character positions\n    for (int i = 0; i < word.length(); i++) {\n        // Form a simpler word by removing the ith character\n        String shorterWord = word.substring(0, i) + word.substring(i + 1);\n        // Generate all permutations of the simpler word\n        PermutationGenerator shorterPermutationGenerator = new PermutationGenerator(shorterWord);\n        ArrayList<String> shorterWordPermutations = shorterPermutationGenerator.getPermutations();\n        // each permutation of the simpler word, \n        for (String s : shorterWordPermutations) {\n            permutations.add(word.charAt(i) + s);\n        }\n    }\n    // Return all permutations\n    return permutations;\n}\n          // Add the removed character to the front of\n\n","name":"getPermutations","className":"PermutationGenerator","variables":{"shorterPermutationGenerator":2,"shorterWord":2,"s":2,"i":4,"shorterWordPermutations":2,"permutations":5,"word":5},"constants":{"0":3,"1":1},"javaDoc":"Gets all permutations of a given word","comments":"The empty string has a single permutation: itself Loop through all character positions Add the removed character to the front of Form a simpler word by removing the ith character Generate all permutations of the simpler word each permutation of the simpler word Return all permutations \n      Gets all permutations of a given word.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RedBlackTree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic RedBlackTree() {\n    root = null;\n}\n","name":"RedBlackTree","className":"RedBlackTree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"addNode":1,"fixAfterAdd":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"FieldAccessExpr":3,"AssignExpr":4,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   */\npublic void add(Comparable obj) {\n    Node newNode = new Node();\n    newNode.data = obj;\n    newNode.left = null;\n    newNode.right = null;\n    if (root == null) {\n        root = newNode;\n    } else {\n        root.addNode(newNode);\n    }\n    fixAfterAdd(newNode);\n}\n","name":"add","className":"RedBlackTree","variables":{"obj":1,"root":3,"newNode":2},"constants":{"null":3},"javaDoc":"Inserts a new node into the tree obj the object to insert","comments":"\n      Inserts a new node into the tree.\n      @param obj the object to insert\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"boolean","methodCalls":{"current.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":3,"MethodCallExpr":1,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   */\npublic boolean find(Comparable obj) {\n    Node current = root;\n    while (current != null) {\n        int d = current.data.compareTo(obj);\n        if (d == 0) {\n            return true;\n        } else if (d > 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n","name":"find","className":"RedBlackTree","variables":{"current":4,"d":3,"root":1},"constants":{"0":2,"null":1,"true":1,"false":1},"javaDoc":"Tries to find an object in the tree obj the object to find true if the object is contained in the tree","comments":"\n      Tries to find an object in the tree.\n      @param obj the object to find\n      @return true if the object is contained in the tree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Comparable"],"returnType":"void","methodCalls":{"fixBeforeRemove":2,"toBeRemoved.data.compareTo":1,"replaceWith":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Node":3,"int":1},"expressions":{"NullLiteralExpr":5,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BooleanLiteralExpr":2,"BinaryExpr":9,"NameExpr":70,"FieldAccessExpr":14,"UnaryExpr":2,"MethodCallExpr":5,"AssignExpr":7},"statements":{"IfStmt":5,"WhileStmt":2,"BlockStmt":10,"ReturnStmt":2,"ExpressionStmt":16},"text":"/**\n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   */\npublic void remove(Comparable obj) {\n    // Find node to be removed\n    Node toBeRemoved = root;\n    boolean found = false;\n    while (!found && toBeRemoved != null) {\n        int d = toBeRemoved.data.compareTo(obj);\n        if (d == 0) {\n            found = true;\n        } else {\n            if (d > 0) {\n                toBeRemoved = toBeRemoved.left;\n            } else {\n                toBeRemoved = toBeRemoved.right;\n            }\n        }\n    }\n    if (!found) {\n        return;\n    }\n    if (toBeRemoved.left == null || toBeRemoved.right == null) {\n        Node newChild;\n        if (toBeRemoved.left == null) {\n            newChild = toBeRemoved.right;\n        } else {\n            newChild = toBeRemoved.left;\n        }\n        fixBeforeRemove(toBeRemoved);\n        replaceWith(toBeRemoved, newChild);\n        return;\n    }\n    // Neither subtree is empty\n    // Find smallest element of the right subtree\n    Node smallest = toBeRemoved.right;\n    while (smallest.left != null) {\n        smallest = smallest.left;\n    }\n    // smallest contains smallest child in right subtree\n    // Move contents, unlink child\n    toBeRemoved.data = smallest.data;\n    fixBeforeRemove(smallest);\n    replaceWith(smallest, smallest.right);\n}\n       // toBeRemoved contains obj\n\n       // If one of the children is empty, use the other\n\n","name":"remove","className":"RedBlackTree","variables":{"toBeRemoved":4,"found":4,"d":3,"newChild":3,"smallest":2,"root":1},"constants":{"0":2,"null":5,"false":1,"true":1},"javaDoc":"Tries to remove an object from the tree Does nothing if the object is not contained in the tree obj the object to remove","comments":"Find node to be removed toBeRemoved contains obj If one of the children is empty use the other Neither subtree is empty Find smallest element of the right subtree smallest contains smallest child in right subtree Move contents unlink child \n      Tries to remove an object from the tree. Does nothing\n      if the object is not contained in the tree.\n      @param obj the object to remove\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Yields the contents of the tree in sorted order\n      @return all data items traversed in inorder, with a space after each item\n   */\npublic String toString() {\n    return toString(root);\n}\n","name":"toString","className":"RedBlackTree","variables":{},"constants":{},"javaDoc":"Yields the contents of the tree in sorted order all data items traversed in inorder with a space after each item","comments":"\n      Yields the contents of the tree in sorted order\n      @return all data items traversed in inorder, with a space after each item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node"],"returnType":"String","methodCalls":{"toString":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":4,"NameExpr":14,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2},"text":"/**\n      Yields the contents of the subtree with the given root in sorted order\n      @param parent the root of the subtree\n      @return all data items traversed in inorder, with a space after each item\n   */\nprivate static String toString(Node parent) {\n    if (parent == null) {\n        return \"\";\n    }\n    return toString(parent.left) + parent.data + \" \" + toString(parent.right);\n}\n","name":"toString","className":"RedBlackTree","variables":{"parent":1},"constants":{"\"\"":1,"null":1,"\" \"":1},"javaDoc":"Yields the contents of the subtree with the given root in sorted order parent the root of the subtree all data items traversed in inorder with a space after each item","comments":"\n      Yields the contents of the subtree with the given root in sorted order\n      @param parent the root of the subtree\n      @return all data items traversed in inorder, with a space after each item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"Node","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n         Constructs a red node with no data.\n      */\npublic Node() {\n}\n","name":"Node","className":"Node","variables":{},"constants":{},"javaDoc":"Constructs a red node with no data","comments":"\n         Constructs a red node with no data.\n      ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n         Sets the left child and updates its parent reference.\n         @param child the new left child\n      */\npublic void setLeftChild(Node child) {\n    left = child;\n    if (child != null) {\n        child.parent = this;\n    }\n}\n","name":"setLeftChild","className":"Node","variables":{"left":1,"child":2},"constants":{"null":1},"javaDoc":"Sets the left child and updates its parent reference child the new left child","comments":"\n         Sets the left child and updates its parent reference.\n         @param child the new left child\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n         Sets the right child and updates its parent reference.\n         @param child the new right child\n      */\npublic void setRightChild(Node child) {\n    right = child;\n    if (child != null) {\n        child.parent = this;\n    }\n}\n","name":"setRightChild","className":"Node","variables":{"right":1,"child":2},"constants":{"null":1},"javaDoc":"Sets the right child and updates its parent reference child the new right child","comments":"\n         Sets the right child and updates its parent reference.\n         @param child the new right child\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"addNode":2,"newNode.data.compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":28,"FieldAccessExpr":3,"ThisExpr":2,"MethodCallExpr":3,"AssignExpr":4},"statements":{"IfStmt":4,"BlockStmt":6,"ExpressionStmt":7},"text":"/**\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      */\npublic void addNode(Node newNode) {\n    int comp = newNode.data.compareTo(data);\n    if (comp < 0) {\n        if (left == null) {\n            left = newNode;\n            left.parent = this;\n        } else {\n            left.addNode(newNode);\n        }\n    } else if (comp > 0) {\n        if (right == null) {\n            right = newNode;\n            right.parent = this;\n        } else {\n            right.addNode(newNode);\n        }\n    }\n}\n","name":"addNode","className":"Node","variables":{"comp":3,"left":3,"newNode":2,"right":3},"constants":{"0":2,"null":2},"javaDoc":"Inserts a new node as a descendant of this node newNode the node to insert","comments":"\n         Inserts a new node as a descendant of this node.\n         @param newNode the node to insert\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node","Node"],"returnType":"void","methodCalls":{"toBeReplaced.parent.setLeftChild":1,"toBeReplaced.parent.setRightChild":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":2,"NameExpr":26,"FieldAccessExpr":6,"AssignExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":2,"BlockStmt":3,"ExpressionStmt":4},"text":"/**\n      Updates the parent's and replacement node's links when this node is replaced.\n      Also updates the root reference if it is replaced.\n      @param toBeReplaced the node that is to be replaced\n      @param replacement the node that replaces that node\n   */\nprivate void replaceWith(Node toBeReplaced, Node replacement) {\n    if (toBeReplaced.parent == null) {\n        replacement.parent = null;\n        root = replacement;\n    } else if (toBeReplaced == toBeReplaced.parent.left) {\n        toBeReplaced.parent.setLeftChild(replacement);\n    } else {\n        toBeReplaced.parent.setRightChild(replacement);\n    }\n}\n","name":"replaceWith","className":"RedBlackTree","variables":{"toBeReplaced":1,"root":1,"replacement":1},"constants":{"null":2},"javaDoc":"Updates the parent's and replacement node's links when this node is replaced Also updates the root reference if it is replaced toBeReplaced the node that is to be replaced replacement the node that replaces that node","comments":"\n      Updates the parent's and replacement node's links when this node is replaced.\n      Also updates the root reference if it is replaced.\n      @param toBeReplaced the node that is to be replaced\n      @param replacement the node that replaces that node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"fixDoubleRed":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":2,"NameExpr":20,"FieldAccessExpr":5,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ExpressionStmt":3},"text":"/**\n      Restores the tree to a red-black tree after a node has been added.\n      @param newNode the node that has been added\n   */\nprivate void fixAfterAdd(Node newNode) {\n    if (newNode.parent == null) {\n        newNode.color = BLACK;\n    } else {\n        newNode.color = RED;\n        if (newNode.parent.color == RED) {\n            fixDoubleRed(newNode);\n        }\n    }\n}\n","name":"fixAfterAdd","className":"RedBlackTree","variables":{"RED":2,"BLACK":1},"constants":{"null":1},"javaDoc":"Restores the tree to a red-black tree after a node has been added newNode the node that has been added","comments":"\n      Restores the tree to a red-black tree after a node has been added.\n      @param newNode the node that has been added\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"bubbleUp":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"BinaryExpr":5,"NameExpr":30,"FieldAccessExpr":9,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":3,"BlockStmt":5,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** \t\n     Fixes the tree so that it is a red-black tree after a node has been removed.\n     @param toBeRemoved the node that is to be removed\n   */\nprivate void fixBeforeRemove(Node toBeRemoved) {\n    if (toBeRemoved.color == RED) {\n        return;\n    }\n    if (// It is not a leaf\n    toBeRemoved.left != null || toBeRemoved.right != null) {\n        // Color the child black\n        if (toBeRemoved.left == null) {\n            toBeRemoved.right.color = BLACK;\n        } else {\n            toBeRemoved.left.color = BLACK;\n        }\n    } else {\n        bubbleUp(toBeRemoved.parent);\n    }\n}\n","name":"fixBeforeRemove","className":"RedBlackTree","variables":{"RED":1,"BLACK":2},"constants":{"null":3},"javaDoc":"Fixes the tree so that it is a red-black tree after a node has been removed toBeRemoved the node that is to be removed","comments":"It is not a leaf Color the child black  \t\n     Fixes the tree so that it is a red-black tree after a node has been removed.\n     @param toBeRemoved the node that is to be removed\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"bubbleUpFix":2,"bubbleUp":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":3,"NameExpr":40,"FieldAccessExpr":11,"UnaryExpr":3,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":5,"BlockStmt":6,"ReturnStmt":3,"ExpressionStmt":5},"text":"/**\n      Move a charge from two children of a parent\n      @param parent a node with two children, or null (in which case nothing is done)\n   */\nprivate void bubbleUp(Node parent) {\n    if (parent == null) {\n        return;\n    }\n    parent.color++;\n    parent.left.color--;\n    parent.right.color--;\n    if (bubbleUpFix(parent.left)) {\n        return;\n    }\n    if (bubbleUpFix(parent.right)) {\n        return;\n    }\n    if (parent.color == DOUBLE_BLACK) {\n        if (parent.parent == null) {\n            parent.color = BLACK;\n        } else {\n            bubbleUp(parent.parent);\n        }\n    }\n}\n","name":"bubbleUp","className":"RedBlackTree","variables":{"parent":1,"DOUBLE_BLACK":1,"BLACK":1},"constants":{"null":2},"javaDoc":"Move a charge from two children of a parent parent a node with two children or null (in which case nothing is done)","comments":"\n      Move a charge from two children of a parent\n      @param parent a node with two children, or null (in which case nothing is done)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Node"],"returnType":"boolean","methodCalls":{"fixNegativeRed":1,"fixDoubleRed":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":8,"BooleanLiteralExpr":4,"NameExpr":39,"FieldAccessExpr":10,"MethodCallExpr":3},"statements":{"IfStmt":4,"BlockStmt":4,"ReturnStmt":4,"ExpressionStmt":3},"text":"/**\n      Fixes a negative-red or double-red violation introduced by bubbling up.\n      @param child the child to check for negative-red or double-red violations\n      @return true if the tree was fixed\n   */\nprivate boolean bubbleUpFix(Node child) {\n    if (child.color == NEGATIVE_RED) {\n        fixNegativeRed(child);\n        return true;\n    } else if (child.color == RED) {\n        if (child.left != null && child.left.color == RED) {\n            fixDoubleRed(child.left);\n            return true;\n        }\n        if (child.right != null && child.right.color == RED) {\n            fixDoubleRed(child.right);\n            return true;\n        }\n    }\n    return false;\n}\n","name":"bubbleUpFix","className":"RedBlackTree","variables":{"RED":3,"NEGATIVE_RED":1},"constants":{"null":2,"true":3,"false":1},"javaDoc":"Fixes a negative-red or double-red violation introduced by bubbling up child the child to check for negative-red or double-red violations true if the tree was fixed","comments":"\n      Fixes a negative-red or double-red violation introduced by bubbling up.\n      @param child the child to check for negative-red or double-red violations\n      @return true if the tree was fixed\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"setLeftChild":3,"fixDoubleRed":1,"setRightChild":3,"replaceWith":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"Node":3},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":9,"NameExpr":160,"FieldAccessExpr":28,"AssignExpr":29,"MethodCallExpr":8},"statements":{"IfStmt":6,"BlockStmt":9,"ReturnStmt":1,"ExpressionStmt":40},"text":"/**\n      Fixes a \"double red\" violation.\n      @param child the child with a red parent\n   */\nprivate void fixDoubleRed(Node child) {\n    Node parent = child.parent;\n    Node grandParent = parent.parent;\n    if (grandParent == null) {\n        parent.color = BLACK;\n        return;\n    }\n    Node n1, n2, n3, t1, t2, t3, t4;\n    if (parent == grandParent.left) {\n        n3 = grandParent;\n        t4 = grandParent.right;\n        if (child == parent.left) {\n            n1 = child;\n            n2 = parent;\n            t1 = child.left;\n            t2 = child.right;\n            t3 = parent.right;\n        } else {\n            n1 = parent;\n            n2 = child;\n            t1 = parent.left;\n            t2 = child.left;\n            t3 = child.right;\n        }\n    } else {\n        n1 = grandParent;\n        t1 = grandParent.left;\n        if (child == parent.left) {\n            n2 = child;\n            n3 = parent;\n            t2 = child.left;\n            t3 = child.right;\n            t4 = parent.right;\n        } else {\n            n2 = parent;\n            n3 = child;\n            t2 = parent.left;\n            t3 = child.left;\n            t4 = child.right;\n        }\n    }\n    replaceWith(grandParent, n2);\n    n1.setLeftChild(t1);\n    n1.setRightChild(t2);\n    n2.setLeftChild(n1);\n    n2.setRightChild(n3);\n    n3.setLeftChild(t3);\n    n3.setRightChild(t4);\n    n2.color = grandParent.color - 1;\n    n1.color = BLACK;\n    n3.color = BLACK;\n    if (n2 == root) {\n        root.color = BLACK;\n    } else if (n2.color == RED && n2.parent.color == RED) {\n        fixDoubleRed(n2);\n    }\n}\n","name":"fixDoubleRed","className":"RedBlackTree","variables":{"t4":4,"parent":6,"n1":6,"n2":8,"n3":6,"grandParent":4,"RED":2,"root":1,"BLACK":4,"t1":4,"t2":5,"t3":5,"child":6},"constants":{"1":1,"null":1},"javaDoc":"Fixes a \"double red\" violation child the child with a red parent","comments":"\n      Fixes a \"double red\" violation.\n      @param child the child with a red parent\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"setLeftChild":6,"fixDoubleRed":2,"setRightChild":6,"replaceWith":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":16},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":16,"BinaryExpr":7,"NameExpr":153,"FieldAccessExpr":26,"AssignExpr":8,"MethodCallExpr":16},"statements":{"IfStmt":3,"BlockStmt":4,"ExpressionStmt":40},"text":"/**\n      Fixes a \"negative red\" violation.\n      @param negRed the negative red node\n   */\nprivate void fixNegativeRed(Node negRed) {\n    Node parent = negRed.parent;\n    Node child;\n    if (parent.left == negRed) {\n        Node n1 = negRed.left;\n        Node n2 = negRed;\n        Node n3 = negRed.right;\n        Node n4 = parent;\n        Node t1 = n3.left;\n        Node t2 = n3.right;\n        Node t3 = n4.right;\n        n1.color = RED;\n        n2.color = BLACK;\n        n4.color = BLACK;\n        replaceWith(n4, n3);\n        n3.setLeftChild(n2);\n        n3.setRightChild(n4);\n        n2.setLeftChild(n1);\n        n2.setRightChild(t1);\n        n4.setLeftChild(t2);\n        n4.setRightChild(t3);\n        child = n1;\n    } else // Mirror image\n    {\n        Node n4 = negRed.right;\n        Node n3 = negRed;\n        Node n2 = negRed.left;\n        Node n1 = parent;\n        Node t3 = n2.right;\n        Node t2 = n2.left;\n        Node t1 = n1.left;\n        n4.color = RED;\n        n3.color = BLACK;\n        n1.color = BLACK;\n        replaceWith(n1, n2);\n        n2.setRightChild(n3);\n        n2.setLeftChild(n1);\n        n3.setRightChild(n4);\n        n3.setLeftChild(t3);\n        n1.setRightChild(t2);\n        n1.setLeftChild(t1);\n        child = n4;\n    }\n    if (child.left != null && child.left.color == RED) {\n        fixDoubleRed(child.left);\n    } else if (child.right != null && child.right.color == RED) {\n        fixDoubleRed(child.right);\n    }\n}\n","name":"fixNegativeRed","className":"RedBlackTree","variables":{"RED":4,"parent":3,"n1":5,"n2":6,"negRed":3,"n3":6,"n4":5,"BLACK":4,"t1":2,"t2":2,"child":3,"t3":2},"constants":{"null":2},"javaDoc":"Fixes a \"negative red\" violation negRed the negative red node","comments":"Mirror image \n      Fixes a \"negative red\" violation.\n      @param negRed the negative red node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      */\npublic int size() {\n    int sum = 0;\n    for (Node child : children) {\n        sum = sum + child.size();\n    }\n    return 1 + sum;\n}\n","name":"size","className":"Node","variables":{"children":1,"sum":4,"child":2},"constants":{"0":1,"1":1},"javaDoc":"Computes the size of the subtree whose root is this node the number of nodes in the subtree","comments":"\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Tree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic Tree() {\n    root = null;\n}\n","name":"Tree","className":"Tree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"Tree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":8,"FieldAccessExpr":2,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   */\npublic Tree(Object rootData) {\n    root = new Node();\n    root.data = rootData;\n    root.children = new ArrayList<>();\n}\n","name":"Tree","className":"Tree","variables":{"root":1,"rootData":1},"constants":{},"javaDoc":"Constructs a tree with one node and no children rootData the data for the root","comments":"\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Tree"],"returnType":"void","methodCalls":{"root.children.add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds a subtree as the last child of the root.\n   */\npublic void addSubtree(Tree subtree) {\n    root.children.add(subtree.root);\n}\n","name":"addSubtree","className":"Tree","variables":{},"constants":{},"javaDoc":"Adds a subtree as the last child of the root","comments":"\n      Adds a subtree as the last child of the root.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   */\npublic int size() {\n    if (root == null) {\n        return 0;\n    } else {\n        return root.size();\n    }\n}\n","name":"size","className":"Tree","variables":{"root":2},"constants":{"0":1,"null":1},"javaDoc":"Computes the size of this tree the number of nodes in the tree","comments":"\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addSubtree":3,"size":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Tree":4},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":1,"StringLiteralExpr":5,"NameExpr":20,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Tree t1 = new Tree(\"Anne\");\n    Tree t2 = new Tree(\"Peter\");\n    t1.addSubtree(t2);\n    Tree t3 = new Tree(\"Zara\");\n    t1.addSubtree(t3);\n    Tree t4 = new Tree(\"Savannah\");\n    t2.addSubtree(t4);\n    System.out.println(\"Size: \" + t1.size());\n}\n","name":"main","className":"TreeDemo","variables":{"t4":1,"t1":4,"t2":2,"t3":1},"constants":{"\"Anne\"":1,"\"Peter\"":1,"\"Size: \"":1,"\"Savannah\"":1,"\"Zara\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    HeapSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"HeapSortDemo","variables":{"HeapSorter":1,"a":1,"Arrays":2,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"fixHeap":2,"swap":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":22,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    int n = a.length - 1;\n    for (int i = (n - 1) / 2; i >= 0; i--) {\n        fixHeap(a, i, n);\n    }\n    while (n > 0) {\n        ArrayUtil.swap(a, 0, n);\n        n--;\n        fixHeap(a, 0, n);\n    }\n}\n","name":"sort","className":"HeapSorter","variables":{"i":3,"n":4,"ArrayUtil":1},"constants":{"0":4,"1":2,"2":1},"javaDoc":"Sorts an array using selection sort a the array to sort","comments":"\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{"getLeftChildIndex":1,"getRightChildIndex":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":4},"expressions":{"VariableDeclarationExpr":5,"ArrayAccessExpr":7,"BooleanLiteralExpr":3,"BinaryExpr":5,"NameExpr":34,"MethodCallExpr":2,"AssignExpr":6},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":6,"ExpressionStmt":11},"text":"/**\n      Ensures the heap property for a subtree, provided its\n      children already fulfill the heap property.\n      @param a the array to sort\n      @param rootIndex the index of the subtree to be fixed\n      @param lastIndex the last valid index of the tree that \n      contains the subtree to be fixed\n   */\nprivate static void fixHeap(int[] a, int rootIndex, int lastIndex) {\n    // Remove root\n    int rootValue = a[rootIndex];\n    // Promote children while they are larger than the root      \n    int index = rootIndex;\n    boolean more = true;\n    while (more) {\n        int childIndex = getLeftChildIndex(index);\n        if (childIndex <= lastIndex) {\n            // Use right child instead if it is larger\n            int rightChildIndex = getRightChildIndex(index);\n            if (rightChildIndex <= lastIndex && a[rightChildIndex] > a[childIndex]) {\n                childIndex = rightChildIndex;\n            }\n            if (a[childIndex] > rootValue) {\n                // Promote child\n                a[index] = a[childIndex];\n                index = childIndex;\n            } else {\n                // Root value is larger than both children\n                more = false;\n            }\n        } else {\n            // No children\n            more = false;\n        }\n    }\n    // Store root value in vacant slot\n    a[index] = rootValue;\n}\n","name":"fixHeap","className":"HeapSorter","variables":{"a":7,"rootValue":3,"more":4,"rootIndex":2,"index":4,"childIndex":7,"lastIndex":2,"rightChildIndex":4},"constants":{"true":1,"false":2},"javaDoc":"Ensures the heap property for a subtree provided its children already fulfill the heap property a the array to sort rootIndex the index of the subtree to be fixed lastIndex the last valid index of the tree that contains the subtree to be fixed","comments":"Promote children while they are larger than the root Remove root Use right child instead if it is larger Promote child Root value is larger than both children No children Store root value in vacant slot \n      Ensures the heap property for a subtree, provided its\n      children already fulfill the heap property.\n      @param a the array to sort\n      @param rootIndex the index of the subtree to be fixed\n      @param lastIndex the last valid index of the tree that \n      contains the subtree to be fixed\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   */\nprivate static int getLeftChildIndex(int index) {\n    return 2 * index + 1;\n}\n","name":"getLeftChildIndex","className":"HeapSorter","variables":{"index":1},"constants":{"1":1,"2":1},"javaDoc":"Returns the index of the left child index the index of a node in this heap the index of the left child of the given node","comments":"\n      Returns the index of the left child.\n      @param index the index of a node in this heap\n      @return the index of the left child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   */\nprivate static int getRightChildIndex(int index) {\n    return 2 * index + 2;\n}\n","name":"getRightChildIndex","className":"HeapSorter","variables":{"index":1},"constants":{"2":2},"javaDoc":"Returns the index of the right child index the index of a node in this heap the index of the right child of the given node","comments":"\n      Returns the index of the right child.\n      @param index the index of a node in this heap\n      @return the index of the right child of the given node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      */\npublic int size() {\n    int sum = 0;\n    for (Node child : children) {\n        sum = sum + child.size();\n    }\n    return 1 + sum;\n}\n","name":"size","className":"Node","variables":{"children":1,"sum":4,"child":2},"constants":{"0":1,"1":1},"javaDoc":"Computes the size of the subtree whose root is this node the number of nodes in the subtree","comments":"\n         Computes the size of the subtree whose root is this node.\n         @return the number of nodes in the subtree\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Tree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an empty tree.\n   */\npublic Tree() {\n    root = null;\n}\n","name":"Tree","className":"Tree","variables":{"root":1},"constants":{"null":1},"javaDoc":"Constructs an empty tree","comments":"\n      Constructs an empty tree.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"Tree","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":8,"FieldAccessExpr":2,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   */\npublic Tree(Object rootData) {\n    root = new Node();\n    root.data = rootData;\n    root.children = new LinkedList<>();\n}\n","name":"Tree","className":"Tree","variables":{"root":1,"rootData":1},"constants":{},"javaDoc":"Constructs a tree with one node and no children rootData the data for the root","comments":"\n      Constructs a tree with one node and no children.\n      @param rootData the data for the root\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Tree"],"returnType":"void","methodCalls":{"root.children.add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds a subtree as the last child of the root.\n   */\npublic void addSubtree(Tree subtree) {\n    root.children.add(subtree.root);\n}\n","name":"addSubtree","className":"Tree","variables":{},"constants":{},"javaDoc":"Adds a subtree as the last child of the root","comments":"\n      Adds a subtree as the last child of the root.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   */\npublic int size() {\n    if (root == null) {\n        return 0;\n    } else {\n        return root.size();\n    }\n}\n","name":"size","className":"Tree","variables":{"root":2},"constants":{"0":1,"null":1},"javaDoc":"Computes the size of this tree the number of nodes in the tree","comments":"\n      Computes the size of this tree.\n      @return the number of nodes in the tree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n         This method is called for each visited node.\n         @param data the data of the node\n      */\nvoid visit(Object data);\n","name":"visit","className":"Visitor","variables":{},"constants":{},"javaDoc":"This method is called for each visited node data the data of the node","comments":"\n         This method is called for each visited node.\n         @param data the data of the node\n      ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Visitor"],"returnType":"void","methodCalls":{"preorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Traverses this tree in preorder.\n      @param v the visitor to be invoked at each node\n   */\npublic void preorder(Visitor v) {\n    preorder(root, v);\n}\n","name":"preorder","className":"Tree","variables":{},"constants":{},"javaDoc":"Traverses this tree in preorder v the visitor to be invoked at each node","comments":"\n      Traverses this tree in preorder.\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node","Visitor"],"returnType":"void","methodCalls":{"visit":1,"preorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"Node":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":14,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Traverses the tree with a given root in preorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   */\nprivate static void preorder(Node n, Visitor v) {\n    if (n == null) {\n        return;\n    }\n    v.visit(n.data);\n    for (Node c : n.children) {\n        preorder(c, v);\n    }\n}\n","name":"preorder","className":"Tree","variables":{"c":1,"v":1,"n":1},"constants":{"null":1},"javaDoc":"Traverses the tree with a given root in preorder n the root of the tree v the visitor to be invoked at each node","comments":"\n      Traverses the tree with a given root in preorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Visitor"],"returnType":"void","methodCalls":{"postorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Traverses this tree in postorder.\n      @param v the visitor to be invoked at each node\n   */\npublic void postorder(Visitor v) {\n    postorder(root, v);\n}\n","name":"postorder","className":"Tree","variables":{},"constants":{},"javaDoc":"Traverses this tree in postorder v the visitor to be invoked at each node","comments":"\n      Traverses this tree in postorder.\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node","Visitor"],"returnType":"void","methodCalls":{"visit":1,"postorder":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"Node":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":14,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Traverses the tree with a given root in postorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   */\nprivate static void postorder(Node n, Visitor v) {\n    if (n == null) {\n        return;\n    }\n    for (Node c : n.children) {\n        postorder(c, v);\n    }\n    v.visit(n.data);\n}\n","name":"postorder","className":"Tree","variables":{"c":1,"v":1,"n":1},"constants":{"null":1},"javaDoc":"Traverses the tree with a given root in postorder n the root of the tree v the visitor to be invoked at each node","comments":"\n      Traverses the tree with a given root in postorder.\n      @param n the root of the tree\n      @param v the visitor to be invoked at each node\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Node"],"returnType":"BreadthFirstIterator","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n         Constructs an iterator for a given tree.\n         @param root the root of the tree\n      */\npublic BreadthFirstIterator(Node root) {\n    q = new LinkedList<>();\n    if (root != null) {\n        q.add(root);\n    }\n}\n","name":"BreadthFirstIterator","className":"BreadthFirstIterator","variables":{"q":2,"root":1},"constants":{"null":1},"javaDoc":"Constructs an iterator for a given tree root the root of the tree","comments":"\n         Constructs an iterator for a given tree.\n         @param root the root of the tree\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean hasNext() {\n    return q.size() > 0;\n}\n","name":"hasNext","className":"BreadthFirstIterator","variables":{"q":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"add":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":2},"expressions":{"VariableDeclarationExpr":2,"NameExpr":13,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public Object next() {\n    Node n = q.remove();\n    for (Node c : n.children) {\n        q.add(c);\n    }\n    return n.data;\n}\n","name":"next","className":"BreadthFirstIterator","variables":{"q":2,"c":1,"n":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ThrowStmt":1},"text":"public void remove() {\n    throw new UnsupportedOperationException();\n}\n","name":"remove","className":"BreadthFirstIterator","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Iterator iterator() {\n    return new BreadthFirstIterator(root);\n}\n","name":"iterator","className":"Tree","variables":{"root":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"length":1,"toString":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":12,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"public void visit(Object data) {\n    System.out.println(data);\n    if (data.toString().length() <= 5) {\n        counter++;\n    }\n}\n","name":"visit","className":"ShortNameCounter","variables":{"data":1,"counter":1},"constants":{"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"addSubtree":3,"iterator":1,"length":2,"toString":2,"hasNext":1,"preorder":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["InnerMethod","InnerClass"],"types":{"Iterator":1,"Tree":4,"ShortNameCounter":1,"Object":1,"int":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":8,"BinaryExpr":4,"StringLiteralExpr":6,"NameExpr":67,"FieldAccessExpr":5,"UnaryExpr":2,"MethodCallExpr":15},"statements":{"IfStmt":2,"WhileStmt":1,"TypeDeclarationStmt":1,"BlockStmt":4,"ExpressionStmt":18},"text":"public static void main(String[] args) {\n    Tree t1 = new Tree(\"Anne\");\n    Tree t2 = new Tree(\"Peter\");\n    t1.addSubtree(t2);\n    Tree t3 = new Tree(\"Zara\");\n    t1.addSubtree(t3);\n    Tree t4 = new Tree(\"Savannah\");\n    t2.addSubtree(t4);\n    // Count short names with visitor\n    class ShortNameCounter implements Tree.Visitor {\n\n        public int counter = 0;\n\n        public void visit(Object data) {\n            System.out.println(data);\n            if (data.toString().length() <= 5) {\n                counter++;\n            }\n        }\n    }\n    ShortNameCounter v = new ShortNameCounter();\n    t1.preorder(v);\n    System.out.println(\"Short names: \" + v.counter);\n    // Count short names with iterator\n    Iterator iter = t1.iterator();\n    int counter = 0;\n    while (iter.hasNext()) {\n        Object data = iter.next();\n        System.out.println(data);\n        if (data.toString().length() <= 5) {\n            counter++;\n        }\n    }\n    System.out.println(\"Short names: \" + counter);\n}\n","name":"main","className":"TraversalDemo","variables":{"t4":1,"data":4,"v":1,"ShortNameCounter":1,"iter":3,"counter":5,"visit":1,"t1":5,"t2":2,"t3":1},"constants":{"\"Anne\"":1,"0":2,"\"Peter\"":1,"5":2,"\"Short names: \"":2,"\"Savannah\"":1,"\"Zara\"":1},"javaDoc":"","comments":"Count short names with visitor Count short names with iterator ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":25,"StringLiteralExpr":1,"FieldAccessExpr":3,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":2,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    int[] values = new int[10];\n    for (int i = 0; i < values.length; i++) {\n        values[i] = i * i;\n    }\n    // In this loop, we don't need the index value. \n    // The enhanced for loop simplifies the code.\n       // In this loop, we need the index value, so we can't use\n\n       // an enhanced for loop.\n\n    int total = 0;\n    for (int element : values) {\n        System.out.println(element);\n        total = total + element;\n    }\n    System.out.println(\"Sum: \" + total);\n}\n","name":"main","className":"EnhancedForLoopDemo","variables":{"total":4,"values":3,"i":6,"element":2},"constants":{"0":2,"\"Sum: \"":1,"10":1},"javaDoc":"","comments":"In this loop we need the index value so we can't use an enhanced for loop In this loop we don't need the index value The enhanced for loop simplifies the code ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":3},"expressions":{"IntegerLiteralExpr":11,"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"ArrayAccessExpr":4,"BinaryExpr":3,"NameExpr":27,"FieldAccessExpr":3,"UnaryExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    int[] values = { 9, 13, 21, 4, 11, 7, 1, 3 };\n    int i = 0;\n    int j = values.length / 2;\n    while (i < values.length / 2) {\n        // Swap values at positions i and j\n        int temp = values[i];\n        values[i] = values[j];\n        values[j] = temp;\n        i++;\n        j++;\n    }\n    System.out.println(Arrays.toString(values));\n}\n","name":"main","className":"SwapHalves","variables":{"temp":2,"values":5,"i":5,"j":4,"Arrays":1},"constants":{"11":1,"0":1,"1":1,"13":1,"2":2,"3":1,"4":1,"7":1,"9":1,"21":1},"javaDoc":"","comments":"Swap values at positions i and j ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":3,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int[][]":1,"String[]":1,"int":5},"expressions":{"IntegerLiteralExpr":29,"VariableDeclarationExpr":7,"ArrayInitializerExpr":10,"ArrayAccessExpr":5,"BinaryExpr":3,"StringLiteralExpr":12,"NameExpr":37,"FieldAccessExpr":4,"UnaryExpr":2,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    final int COUNTRIES = 8;\n    final int MEDALS = 3;\n    String[] countries = { \"Canada\", \"Italy\", \"Germany\", \"Japan\", \"Kazakhstan\", \"Russia\", \"South Korea\", \"United States\" };\n    int[][] counts = { { 0, 3, 0 }, { 0, 0, 1 }, { 0, 0, 1 }, { 1, 0, 0 }, { 0, 0, 1 }, { 3, 1, 1 }, { 0, 1, 0 }, { 1, 0, 1 } };\n    System.out.println(\"        Country    Gold  Silver  Bronze   Total\");\n    // Print countries, counts, and row totals\n    for (int i = 0; i < COUNTRIES; i++) {\n        // Process the ith row\n        System.out.printf(\"%15s\", countries[i]);\n        int total = 0;\n        // Print each row element and update the row total\n        for (int j = 0; j < MEDALS; j++) {\n            System.out.printf(\"%8d\", counts[i][j]);\n            total = total + counts[i][j];\n        }\n        // Display the row total and print a new line\n        System.out.printf(\"%8d\\n\", total);\n    }\n}\n","name":"main","className":"Medals","variables":{"total":3,"COUNTRIES":2,"counts":3,"i":6,"j":5,"countries":2,"MEDALS":2},"constants":{"\"Kazakhstan\"":1,"\"%8d\"":1,"\"Germany\"":1,"\"South Korea\"":1,"0":16,"1":9,"3":3,"\"%15s\"":1,"\"United States\"":1,"\"        Country    Gold  Silver  Bronze   Total\"":1,"\"Italy\"":1,"8":1,"\"Canada\"":1,"\"%8d\\n\"":1,"\"Japan\"":1,"\"Russia\"":1},"javaDoc":"","comments":"Print countries counts and row totals Process the ith row Print each row element and update the row total Display the row total and print a new line ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"hasNextDouble":1,"nextDouble":1,"System.out.print":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Scanner":1,"double[]":1,"double":1,"int":4},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":7,"ArrayAccessExpr":6,"BinaryExpr":6,"NameExpr":55,"StringLiteralExpr":2,"FieldAccessExpr":6,"ArrayCreationExpr":1,"UnaryExpr":3,"MethodCallExpr":6,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ForStmt":2,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    final int LENGTH = 100;\n    double[] values = new double[LENGTH];\n    int currentSize = 0;\n    // Read inputs\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble() && currentSize < values.length) {\n        values[currentSize] = in.nextDouble();\n        currentSize++;\n    }\n    // Find the largest value\n    double largest = values[0];\n    for (int i = 1; i < currentSize; i++) {\n        if (values[i] > largest) {\n            largest = values[i];\n        }\n    }\n    for (int i = 0; i < currentSize; i++) {\n        System.out.print(values[i]);\n        if (values[i] == largest) {\n            System.out.print(\" <== largest value\");\n        }\n        System.out.println();\n    }\n}\n       // Print all values, marking the largest\n\n","name":"main","className":"LargestInArray","variables":{"largest":4,"in":3,"LENGTH":2,"values":7,"i":10,"currentSize":6},"constants":{"0":3,"\"Please enter values, Q to quit:\"":1,"\" <== largest value\"":1,"100":1,"1":1},"javaDoc":"","comments":"Read inputs Find the largest value Print all values marking the largest ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   */\npublic Student(int capacity) {\n    scores = new double[capacity];\n    scoresSize = 0;\n}\n","name":"Student","className":"Student","variables":{"scoresSize":1,"scores":1,"capacity":1},"constants":{"0":1},"javaDoc":"Constructs a student with no scores and a maximum number of scores @capacity the maximum number of scores for this student","comments":"\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":8,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   */\npublic boolean addScore(double score) {\n    if (scoresSize < scores.length) {\n        scores[scoresSize] = score;\n        scoresSize++;\n        return true;\n    } else {\n        return false;\n    }\n}\n","name":"addScore","className":"Student","variables":{"scoresSize":3,"score":1,"scores":1},"constants":{"true":1,"false":1},"javaDoc":"Adds a score for this student score the score to add true if the score was added false if there was no room to add the score","comments":"\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   */\npublic double sum() {\n    double total = 0;\n    for (int i = 0; i < scoresSize; i++) {\n        total = total + scores[i];\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"scoresSize":1,"total":4,"scores":1,"i":4},"constants":{"0":2},"javaDoc":"Computes the sum of the scores of this student the sum of the scores","comments":"\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":12,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   */\npublic double minimum() {\n    if (scoresSize == 0) {\n        return 0;\n    }\n    double smallest = scores[0];\n    for (int i = 1; i < scoresSize; i++) {\n        if (scores[i] < smallest) {\n            smallest = scores[i];\n        }\n    }\n    return smallest;\n}\n","name":"minimum","className":"Student","variables":{"scoresSize":2,"scores":3,"smallest":4,"i":5},"constants":{"0":3,"1":1},"javaDoc":"Gets the minimum score of this student the minimum score or 0 if there are no scores","comments":"\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sum":1,"minimum":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":5,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped.\n   */\npublic double finalScore() {\n    if (scoresSize == 0) {\n        return 0;\n    } else {\n        return sum() - minimum();\n    }\n}\n","name":"finalScore","className":"Student","variables":{"scoresSize":1},"constants":{"0":2},"javaDoc":"Gets the final score for this student the sum of the scores with the lowest score dropped","comments":"\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"finalScore":1,"addScore":1,"hasNextDouble":1,"nextDouble":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Student":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":30,"StringLiteralExpr":3,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    Student fred = new Student(100);\n    System.out.println(\"Please enter values, Q to quit:\");\n    while (in.hasNextDouble()) {\n        if (!fred.addScore(in.nextDouble())) {\n            System.out.println(\"Too many scores.\");\n            return;\n        }\n    }\n    System.out.println(\"Final score: \" + fred.finalScore());\n}\n","name":"main","className":"ScoreAnalyzer","variables":{"in":3,"fred":3},"constants":{"\"Please enter values, Q to quit:\"":1,"100":1,"\"Too many scores.\"":1,"\"Final score: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"Dice","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":2,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Dice(int sides) {\n    // counters[0] is not used\n    counters = new int[sides + 1];\n}\n","name":"Dice","className":"Dice","variables":{"counters":1,"sides":1},"constants":{"1":1},"javaDoc":"","comments":"counters[0] is not used ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"hasNextInt":1,"nextInt":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":27,"StringLiteralExpr":2,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"public void countInputs() {\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextInt()) {\n        int value = in.nextInt();\n        if (1 <= value && value <= counters.length) {\n            counters[value]++;\n        } else {\n            System.out.println(value + \" is not a valid input.\");\n        }\n    }\n}\n          // Increment the counter for the input value\n\n","name":"countInputs","className":"Dice","variables":{"counters":1,"in":3,"value":5},"constants":{"\"Please enter values, Q to quit:\"":1,"1":1,"\" is not a valid input.\"":1},"javaDoc":"","comments":"Increment the counter for the input value ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"public void printCounters() {\n    for (int i = 1; i < counters.length; i++) {\n        System.out.printf(\"%2d: %4d\\n\", i, counters[i]);\n    }\n}\n","name":"printCounters","className":"Dice","variables":{"counters":1,"i":4},"constants":{"1":1,"\"%2d: %4d\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"countInputs":1,"printCounters":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Dice":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    final int SIDES = 6;\n    Dice dice = new Dice(SIDES);\n    dice.countInputs();\n    dice.printCounters();\n}\n","name":"main","className":"DiceAnalyzer","variables":{"dice":3,"SIDES":2},"constants":{"6":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":3,"System.out.print":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int[][]":1,"String[]":1,"int":7},"expressions":{"IntegerLiteralExpr":49,"VariableDeclarationExpr":9,"ArrayInitializerExpr":8,"ArrayAccessExpr":5,"BinaryExpr":5,"StringLiteralExpr":11,"NameExpr":58,"FieldAccessExpr":7,"UnaryExpr":4,"MethodCallExpr":7,"AssignExpr":1},"statements":{"BlockStmt":4,"ForStmt":4,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    final int ROWS = 6;\n    final int COLUMNS = 7;\n    int[][] populations = { { 106, 107, 111, 133, 221, 767, 1766 }, { 502, 635, 809, 947, 1402, 3634, 5268 }, { 2, 2, 2, 6, 13, 30, 46 }, { 163, 203, 276, 408, 547, 729, 628 }, { 2, 7, 26, 82, 172, 307, 392 }, { 16, 24, 38, 74, 167, 511, 809 } };\n    String[] continents = { \"Africa\", \"Asia\", \"Australia\", \"Europe\", \"North America\", \"South America\" };\n    System.out.println(\"                Year 1750 1800 1850 1900 1950 2000 2050\");\n    for (int i = 0; i < ROWS; i++) {\n        // Print the ith row\n        System.out.printf(\"%20s\", continents[i]);\n        for (int j = 0; j < COLUMNS; j++) {\n            System.out.printf(\"%5d\", populations[i][j]);\n        }\n        // Start a new line at the end of the row\n        System.out.println();\n    }\n    // Print column totals\n    System.out.print(\"               World\");\n    for (int j = 0; j < COLUMNS; j++) {\n        int total = 0;\n        for (int i = 0; i < ROWS; i++) {\n            total = total + populations[i][j];\n        }\n        System.out.printf(\"%5d\", total);\n    }\n    System.out.println();\n}\n       // Print population data\n\n","name":"main","className":"WorldPopulation","variables":{"total":3,"i":9,"COLUMNS":3,"j":8,"populations":3,"continents":2,"ROWS":3},"constants":{"46":1,"\"Africa\"":1,"5268":1,"392":1,"111":1,"276":1,"511":1,"635":1,"3634":1,"13":1,"16":1,"\"Europe\"":1,"163":1,"0":5,"2":4,"167":1,"203":1,"\"%20s\"":1,"6":2,"7":2,"767":1,"408":1,"\"Australia\"":1,"729":1,"\"South America\"":1,"809":2,"24":1,"26":1,"172":1,"133":1,"\"Asia\"":1,"30":1,"74":1,"\"North America\"":1,"\"%5d\"":2,"\"                Year 1750 1800 1850 1900 1950 2000 2050\"":1,"38":1,"\"               World\"":1,"221":1,"1766":1,"1402":1,"106":1,"502":1,"107":1,"547":1,"82":1,"307":1,"947":1,"628":1},"javaDoc":"","comments":"Print population data Print column totals Print the ith row Start a new line at the end of the row ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":4,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Scanner":1,"boolean":1,"int[]":3,"String[]":1,"int":8},"expressions":{"IntegerLiteralExpr":12,"ObjectCreationExpr":1,"VariableDeclarationExpr":14,"ArrayAccessExpr":7,"BinaryExpr":13,"NameExpr":102,"StringLiteralExpr":10,"UnaryExpr":8,"AssignExpr":4,"ArrayInitializerExpr":1,"BooleanLiteralExpr":2,"FieldAccessExpr":15,"ArrayCreationExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":8,"ForStmt":5,"ExpressionStmt":24},"text":"public static void main(String[] args) {\n    // An array of five values, initialized in a loop\n    int[] values = new int[5];\n    for (int i = 0; i < values.length; i++) {\n        values[i] = 2 * i;\n    }\n    // An array of four strings, with initial values specified\n    String[] names = { \"Fred\", \"Amy\", \"Cindy\", \"Henry\" };\n    for (int i = 0; i < values.length; i++) {\n        System.out.print(values[i] + \" \");\n    }\n    System.out.println();\n    for (int i = 0; i < names.length; i++) {\n        System.out.print(names[i] + \" \");\n    }\n    System.out.println();\n    // When you copy an array variable, you get another reference \n    // to the same array. (See Section 7.1.2.)\n    int[] copy = values;\n       // These loops print the elements in both arrays\n\n    values[0] = 42;\n    for (int i = 0; i < copy.length; i++) {\n        System.out.print(copy[i] + \" \");\n    }\n    System.out.println();\n    // Here, we read numbers into a partially filled array.\n    // (See Section 7.1.4.)\n    System.out.println(\"Enter scores, -1 to quit: \");\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    int currentSize = 0;\n    final int LENGTH = 100;\n    int[] scores = new int[LENGTH];\n    while (!done && currentSize < LENGTH) {\n        int score = in.nextInt();\n        if (score == -1) {\n            done = true;\n        } else {\n          // We change values[0], which is the same as copy[0]\n\n            scores[currentSize] = score;\n            currentSize++;\n        }\n    }\n    System.out.println(\"You entered the following scores:\");\n    for (int i = 0; i < currentSize; i++) {\n        System.out.print(scores[i] + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"ArrayDemo","variables":{"score":3,"names":2,"in":2,"scores":3,"values":5,"LENGTH":3,"i":21,"copy":2,"done":3,"currentSize":5},"constants":{"\"You entered the following scores:\"":1,"\"Fred\"":1,"\"Enter scores, -1 to quit: \"":1,"\"Cindy\"":1,"\" \"":4,"false":1,"\"Amy\"":1,"0":7,"100":1,"1":1,"2":1,"5":1,"true":1,"42":1,"\"Henry\"":1},"javaDoc":"","comments":"An array of five values initialized in a loop An array of four strings with initial values specified These loops print the elements in both arrays When you copy an array variable you get another reference to the same array (See Section 7 1 2 ) We change values[0] which is the same as copy[0] Here we read numbers into a partially filled array (See Section 7 1 4 ) ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pick":1,"show":2,"getSampleValues":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"SoundClip":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":21,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    SoundClip clip = new SoundClip();\n    clip.pick();\n    clip.show();\n    int[] samples = clip.getSampleValues();\n    for (int i = 0; i < samples.length; i++) {\n        samples[i] = 3 * samples[i];\n    }\n    clip.show();\n}\n       // In this example, we don't need the sample rate.\n\n       // If you do, call clip.getSampleRate();\n\n","name":"main","className":"SoundClipDemo","variables":{"i":5,"clip":5,"samples":3},"constants":{"0":1,"3":1},"javaDoc":"","comments":"In this example we don't need the sample rate If you do call clip getSampleRate(); ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int[] getSampleValues() {\n    return samples;\n}\n","name":"getSampleValues","className":"SoundClip","variables":{"samples":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getSampleRate() {\n    return sampleRate;\n}\n","name":"getSampleRate","className":"SoundClip","variables":{"sampleRate":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showOpenDialog":1,"load":1,"getSelectedFile":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":11,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Displays a file chooser for picking a clip.\n   */\npublic void pick() {\n    JFileChooser chooser = new JFileChooser(\".\");\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        load(chooser.getSelectedFile());\n    }\n}\n","name":"pick","className":"SoundClip","variables":{"chooser":3},"constants":{"null":1,"\".\"":1},"javaDoc":"Displays a file chooser for picking a clip","comments":"\n      Displays a file chooser for picking a clip.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"SoundClipFrame":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Shows a frame with the sample values and a Play button\n   */\npublic void show() {\n    if (samples != null) {\n        JFrame frame = new SoundClipFrame();\n        frame.setVisible(true);\n    }\n}\n","name":"show","className":"SoundClip","variables":{"samples":1,"frame":2},"constants":{"null":1,"true":1},"javaDoc":"Shows a frame with the sample values and a Play button","comments":"\n      Shows a frame with the sample values and a Play button\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["File"],"returnType":"void","methodCalls":{"getSignedInt2":1,"read":1,"getUnsignedInt2":4,"getMessage":1,"getUnsignedInt4":1,"error":5},"annotations":[],"exceptions":["Exception"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"InputStream":1,"FileInputStream":1,"int":7},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":12,"VariableDeclarationExpr":8,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":48,"StringLiteralExpr":4,"CastExpr":1,"UnaryExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":13,"AssignExpr":4},"statements":{"IfStmt":4,"TryStmt":1,"BlockStmt":8,"ForStmt":2,"ExpressionStmt":15},"text":"/**\n      Loads a picture from a given source. \n      @param source the image source.\n      @return true if the file was loaded successfully\n   */\nprivate void load(File source) {\n    try {\n        InputStream in = new FileInputStream(source);\n        for (int i = 0; i < HEADER_SIZE; i++) {\n            int b = in.read();\n            if (b == -1) {\n                error(\"Premature end of file\");\n            }\n            header[i] = (byte) b;\n        }\n        int formatType = getUnsignedInt2(20);\n        if (formatType != 1) {\n            error(\"Not an uncompressed sound file.\");\n        }\n        int numChannels = getUnsignedInt2(22);\n        if (numChannels != 1) {\n            error(\"Not a mono sound file.\");\n        }\n        sampleRate = getUnsignedInt2(24);\n        int bitsPerSample = getUnsignedInt2(34);\n        if (bitsPerSample != 16) {\n            error(\"Not a 16 bit sound file.\");\n        }\n        // Read data size and allocate data array\n        // 2 bytes per data\n        int dataSize = getUnsignedInt4(40) / 2;\n        samples = new int[dataSize];\n        // Read sound data\n        for (int i = 0; i < dataSize; i++) {\n            samples[i] = getSignedInt2(in);\n        }\n    } catch (Exception ex) {\n        error(ex.getMessage());\n    }\n}\n","name":"load","className":"SoundClip","variables":{"numChannels":2,"b":3,"in":2,"i":8,"dataSize":3,"source":1,"sampleRate":1,"samples":2,"bitsPerSample":2,"ex":2,"HEADER_SIZE":1,"header":1,"formatType":2},"constants":{"22":1,"34":1,"24":1,"16":1,"\"Not a 16 bit sound file.\"":1,"\"Not a mono sound file.\"":1,"0":2,"1":3,"2":1,"\"Not an uncompressed sound file.\"":1,"40":1,"\"Premature end of file\"":1,"20":1},"javaDoc":"Loads a picture from a given source source the image source true if the file was loaded successfully","comments":"Read data size and allocate data array 2 bytes per data Read sound data \n      Loads a picture from a given source. \n      @param source the image source.\n      @return true if the file was loaded successfully\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"showMessageDialog":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"private void error(String message) {\n    JOptionPane.showMessageDialog(null, message);\n}\n","name":"error","className":"SoundClip","variables":{"JOptionPane":1},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":5},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Gets a byte from the header as an unsigned value.\n      @param offset the offset from the start of the header\n      @return the integer\n   */\nprivate int getUnsignedInt1(int offset) {\n    int result = header[offset];\n    if (result >= 0) {\n        return result;\n    } else {\n        return result + 256;\n    }\n}\n","name":"getUnsignedInt1","className":"SoundClip","variables":{"result":4,"offset":1,"header":1},"constants":{"0":1,"256":1},"javaDoc":"Gets a byte from the header as an unsigned value offset the offset from the start of the header the integer","comments":"\n      Gets a byte from the header as an unsigned value.\n      @param offset the offset from the start of the header\n      @return the integer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"getUnsignedInt1":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":12,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Gets an unsigned 4-byte integer from the header\n      @param offset the offset from the start of the header\n      @return the integer \n   */\nprivate int getUnsignedInt4(int offset) {\n    int result = 0;\n    int base = 1;\n    for (int i = 0; i < 4; i++) {\n        result = result + getUnsignedInt1(offset + i) * base;\n        base = base * 256;\n    }\n    return result;\n}\n","name":"getUnsignedInt4","className":"SoundClip","variables":{"result":4,"offset":1,"i":4,"base":4},"constants":{"0":2,"1":1,"256":1,"4":1},"javaDoc":"Gets an unsigned 4-byte integer from the header offset the offset from the start of the header the integer","comments":"\n      Gets an unsigned 4-byte integer from the header\n      @param offset the offset from the start of the header\n      @return the integer \n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"getUnsignedInt1":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Gets an unsigned 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   */\nprivate int getUnsignedInt2(int offset) {\n    return getUnsignedInt1(offset) + 256 * getUnsignedInt1(offset + 1);\n}\n","name":"getUnsignedInt2","className":"SoundClip","variables":{"offset":1},"constants":{"1":1,"256":1},"javaDoc":"Gets an unsigned 2-byte integer from a random access file in the file the integer","comments":"\n      Gets an unsigned 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["InputStream"],"returnType":"int","methodCalls":{"read":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":12,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Gets a signed 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   */\nprivate static int getSignedInt2(InputStream in) throws IOException {\n    int lo = in.read();\n    int hi = in.read();\n    int result = lo + 256 * hi;\n    if (result >= 32768) {\n        result = result - 65536;\n    }\n    return result;\n}\n","name":"getSignedInt2","className":"SoundClip","variables":{"result":5,"hi":2,"lo":2,"in":2},"constants":{"256":1,"65536":1,"32768":1},"javaDoc":"Gets a signed 2-byte integer from a random access file in the file the integer","comments":"\n      Gets a signed 2-byte integer from a random access file.\n      @param in the file\n      @return the integer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":5,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"@Override\npublic void windowClosing(WindowEvent event) {\n    frames--;\n    if (frames == 0)\n        System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"frames":2,"System":1},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getHeight":1,"min":1,"max":1,"getWidth":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":7},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":7,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":41,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":5,"AssignExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public void paintComponent(Graphics graph) {\n    int increment = samples.length / getWidth();\n    final int LARGEST = 32767;\n    int x = 0;\n    for (int i = 0; i < samples.length; i = i + increment) {\n        int value = samples[i];\n        value = Math.min(LARGEST, value);\n        value = Math.max(-LARGEST, value);\n        int height = getHeight() / 2;\n        int y = height - samples[i] * height / LARGEST;\n        graph.drawLine(x, y, x, height);\n        x++;\n    }\n}\n","name":"paintComponent","className":"","variables":{"LARGEST":3,"x":2,"increment":2,"i":6,"y":1,"Math":2,"value":3,"samples":2,"graph":1,"height":3},"constants":{"0":2,"2":1,"32767":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"play":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    play();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"SoundClipFrame","methodCalls":{"add":3,"play":1,"addWindowListener":1,"exit":1,"getHeight":1,"min":1,"max":1,"addActionListener":1,"getWidth":1,"drawLine":1,"copyOf":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"JPanel":1,"JComponent":1,"JButton":1,"int":10},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":9,"VariableDeclarationExpr":13,"ArrayAccessExpr":2,"BinaryExpr":10,"NameExpr":95,"StringLiteralExpr":1,"MarkerAnnotationExpr":1,"UnaryExpr":5,"AssignExpr":4,"FieldAccessExpr":6,"ThisExpr":2,"MethodCallExpr":14},"statements":{"IfStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":28},"text":"public SoundClipFrame() {\n    frames++;\n    offsets++;\n    samples = Arrays.copyOf(SoundClip.this.samples, SoundClip.this.samples.length);\n    addWindowListener(new WindowAdapter() {\n\n        @Override\n        public void windowClosing(WindowEvent event) {\n            frames--;\n            if (frames == 0)\n                System.exit(0);\n        }\n    });\n    final int FRAME_WIDTH = 800;\n    final int FRAME_HEIGHT = 200;\n    final int OFFSET_WIDTH = 100;\n    setBounds(offsets * OFFSET_WIDTH, offsets * OFFSET_WIDTH, FRAME_WIDTH, FRAME_HEIGHT);\n    JComponent component = new JComponent() {\n\n        public void paintComponent(Graphics graph) {\n            int increment = samples.length / getWidth();\n            final int LARGEST = 32767;\n            int x = 0;\n            for (int i = 0; i < samples.length; i = i + increment) {\n                int value = samples[i];\n                value = Math.min(LARGEST, value);\n                value = Math.max(-LARGEST, value);\n                int height = getHeight() / 2;\n                int y = height - samples[i] * height / LARGEST;\n                graph.drawLine(x, y, x, height);\n                x++;\n            }\n        }\n    };\n    add(component);\n    JPanel panel = new JPanel();\n    JButton button = new JButton(\"Play\");\n    button.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent event) {\n            play();\n        }\n    });\n    panel.add(button);\n    add(panel, BorderLayout.SOUTH);\n}\n","name":"SoundClipFrame","className":"SoundClipFrame","variables":{"increment":2,"Math":2,"System":1,"button":2,"actionPerformed":1,"windowClosing":1,"LARGEST":3,"event":2,"panel":2,"Override":1,"value":3,"OFFSET_WIDTH":3,"height":3,"frames":3,"FRAME_HEIGHT":1,"paintComponent":1,"i":6,"samples":3,"graph":2,"component":1,"FRAME_WIDTH":1,"offsets":3,"x":2,"y":1,"Arrays":1,"SoundClip":2},"constants":{"0":4,"100":1,"200":1,"2":1,"\"Play\"":1,"800":1,"32767":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getAudioInputStream":1,"getClip":1,"start":1,"getMessage":1,"error":1,"open":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"Clip":1,"int":3},"expressions":{"IntegerLiteralExpr":10,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayAccessExpr":5,"BinaryExpr":13,"NameExpr":47,"UnaryExpr":2,"AssignExpr":4,"CastExpr":2,"FieldAccessExpr":2,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":5,"TryStmt":1,"ForStmt":2,"ExpressionStmt":10},"text":"private void play() {\n    byte[] out = new byte[HEADER_SIZE + 2 * samples.length];\n    for (int i = 0; i < HEADER_SIZE; i++) {\n        out[i] = header[i];\n    }\n    for (int i = 0; i < samples.length; i++) {\n        int value = samples[i];\n        if (value < 0) {\n            value = value + 65536;\n        }\n        out[HEADER_SIZE + 2 * i] = (byte) (value % 256);\n        out[HEADER_SIZE + 2 * i + 1] = (byte) (value / 256);\n    }\n    try {\n        Clip clip = AudioSystem.getClip();\n        clip.open(AudioSystem.getAudioInputStream(new ByteArrayInputStream(out)));\n        clip.start();\n    } catch (Exception ex) {\n        error(ex.getMessage());\n    }\n}\n","name":"play","className":"SoundClipFrame","variables":{"ex":2,"AudioSystem":2,"HEADER_SIZE":4,"i":11,"header":1,"value":6,"samples":1,"clip":3,"out":5},"constants":{"0":3,"1":1,"2":3,"256":2,"65536":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Student() {\n    scores = new ArrayList<Double>();\n}\n","name":"Student","className":"Student","variables":{"scores":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n   */\npublic void addScore(double score) {\n    scores.add(score);\n}\n","name":"addScore","className":"Student","variables":{"scores":1},"constants":{},"javaDoc":"Adds a score for this student score the score to add","comments":"\n      Adds a score for this student.\n      @param score the score to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":2,"get":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":19,"UnaryExpr":2,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   */\npublic int minimumPosition() {\n    if (scores.size() == 0) {\n        return -1;\n    }\n    int smallestPosition = 0;\n    for (int i = 1; i < scores.size(); i++) {\n        if (scores.get(i) < scores.get(smallestPosition)) {\n            smallestPosition = i;\n        }\n    }\n    return smallestPosition;\n}\n","name":"minimumPosition","className":"Student","variables":{"smallestPosition":3,"scores":4,"i":4},"constants":{"0":2,"1":2},"javaDoc":"Gets the position of the minimum score the position of the smallest element of values or -1 if there are no scores","comments":"\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":5,"AssignExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the sum of the scores\n      @return the total score\n   */\npublic double sum() {\n    double total = 0;\n    for (double score : scores) {\n        total = total + score;\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"score":2,"total":4,"scores":1},"constants":{"0":1},"javaDoc":"Computes the sum of the scores the total score","comments":"\n      Computes the sum of the scores\n      @return the total score\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   */\npublic void removeScore(int pos) {\n    scores.remove(pos);\n/*\n        Alternatively, for a more efficient implementation,\n        follow Section 7.3.6:\n        int lastPosition = scores.size() - 1;\n        scores.set(pos, scores.get(lastPosition));\n        scores.remove(lastPosition);\n      */\n}\n","name":"removeScore","className":"Student","variables":{"scores":1},"constants":{},"javaDoc":"Removes a score at a given position pos the position of the score to remove","comments":"Alternatively for a more efficient implementation follow Section 7 3 6: int lastPosition = scores size() - 1; scores set(pos scores get(lastPosition)); scores remove(lastPosition); \n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"size":1,"get":3,"hasNextDouble":1,"nextDouble":1,"System.out.print":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":2,"ArrayList<Double>":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":3,"NameExpr":54,"StringLiteralExpr":2,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":11,"AssignExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    ArrayList<Double> values = new ArrayList<Double>();\n    // Read inputs\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble()) {\n        values.add(in.nextDouble());\n    }\n    // Find the largest value\n    double largest = values.get(0);\n    for (int i = 1; i < values.size(); i++) {\n        if (values.get(i) > largest) {\n            largest = values.get(i);\n        }\n    }\n    for (double element : values) {\n        System.out.print(element);\n        if (element == largest) {\n            System.out.print(\" <== largest value\");\n        }\n        System.out.println();\n    }\n}\n       // Print all values, marking the largest\n\n","name":"main","className":"LargestInArrayList","variables":{"largest":4,"in":3,"values":7,"i":3,"element":2},"constants":{"\"Please enter values, Q to quit:\"":1,"0":1,"\" <== largest value\"":1,"1":1},"javaDoc":"","comments":"Read inputs Find the largest value Print all values marking the largest ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addScore":1,"minimumPosition":1,"sum":1,"hasNextDouble":1,"nextDouble":1,"removeScore":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"Student":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":39,"StringLiteralExpr":3,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Student fred = new Student();\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble()) {\n        fred.addScore(in.nextDouble());\n    }\n    int pos = fred.minimumPosition();\n    if (pos == -1) {\n        System.out.println(\"At least one score is required.\");\n    } else {\n        fred.removeScore(pos);\n        double total = fred.sum();\n        System.out.println(\"Final score: \" + total);\n    }\n}\n","name":"main","className":"ScoreAnalyzer","variables":{"total":2,"in":3,"pos":2,"fred":5},"constants":{"\"Please enter values, Q to quit:\"":1,"1":1,"\"At least one score is required.\"":1,"\"Final score: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   */\npublic Student(int capacity) {\n    scores = new double[capacity];\n    scoresSize = 0;\n}\n","name":"Student","className":"Student","variables":{"scoresSize":1,"scores":1,"capacity":1},"constants":{"0":1},"javaDoc":"Constructs a student with no scores and a maximum number of scores @capacity the maximum number of scores for this student","comments":"\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":8,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   */\npublic boolean addScore(double score) {\n    if (scoresSize < scores.length) {\n        scores[scoresSize] = score;\n        scoresSize++;\n        return true;\n    } else {\n        return false;\n    }\n}\n","name":"addScore","className":"Student","variables":{"scoresSize":3,"score":1,"scores":1},"constants":{"true":1,"false":1},"javaDoc":"Adds a score for this student score the score to add true if the score was added false if there was no room to add the score","comments":"\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   */\npublic double sum() {\n    double total = 0;\n    for (int i = 0; i < scoresSize; i++) {\n        total = total + scores[i];\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"scoresSize":1,"total":4,"scores":1,"i":4},"constants":{"0":2},"javaDoc":"Computes the sum of the scores of this student the sum of the scores","comments":"\n      Computes the sum of the scores of this student.\n      @return the sum of the scores\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":12,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   */\npublic double minimum() {\n    if (scoresSize == 0) {\n        return 0;\n    }\n    double smallest = scores[0];\n    for (int i = 1; i < scoresSize; i++) {\n        if (scores[i] < smallest) {\n            smallest = scores[i];\n        }\n    }\n    return smallest;\n}\n","name":"minimum","className":"Student","variables":{"scoresSize":2,"scores":3,"smallest":4,"i":5},"constants":{"0":3,"1":1},"javaDoc":"Gets the minimum score of this student the minimum score or 0 if there are no scores","comments":"\n      Gets the minimum score of this student.\n      @return the minimum score, or 0 if there are no scores.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sum":1,"minimum":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":7,"MethodCallExpr":2},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3},"text":"/**\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped if \n      there are at least two scores, or 0 if there are no scores.\n   */\npublic double finalScore() {\n    if (scoresSize == 0) {\n        return 0;\n    } else if (scoresSize == 1) {\n        return scores[0];\n    } else {\n        return sum() - minimum();\n    }\n}\n","name":"finalScore","className":"Student","variables":{"scoresSize":2,"scores":1},"constants":{"0":3,"1":1},"javaDoc":"Gets the final score for this student the sum of the scores with the lowest score dropped if there are at least two scores or 0 if there are no scores","comments":"\n      Gets the final score for this student.\n      @return the sum of the scores, with the lowest score dropped if \n      there are at least two scores, or 0 if there are no scores.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"finalScore":1,"addScore":1,"hasNextDouble":1,"nextDouble":2,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"Student":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":34,"StringLiteralExpr":3,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    double expected = in.nextDouble();\n    Student fred = new Student(100);\n    while (in.hasNextDouble()) {\n        if (!fred.addScore(in.nextDouble())) {\n            System.out.println(\"Too many scores.\");\n            return;\n        }\n    }\n    System.out.println(\"Final score: \" + fred.finalScore());\n    System.out.println(\"Expected: \" + expected);\n}\n","name":"main","className":"ScoreTester","variables":{"in":4,"expected":2,"fred":3},"constants":{"100":1,"\"Too many scores.\"":1,"\"Final score: \"":1,"\"Expected: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"finalScore":1,"addScore":3,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Student":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Student fred = new Student(100);\n    fred.addScore(10);\n    fred.addScore(20);\n    fred.addScore(5);\n    System.out.println(\"Final score: \" + fred.finalScore());\n    System.out.println(\"Expected: 30\");\n}\n","name":"main","className":"ScoreTester1","variables":{"fred":5},"constants":{"100":1,"5":1,"\"Expected: 30\"":1,"\"Final score: \"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   */\npublic Student(int capacity) {\n    scores = new double[capacity];\n    scoresSize = 0;\n}\n","name":"Student","className":"Student","variables":{"scoresSize":1,"scores":1,"capacity":1},"constants":{"0":1},"javaDoc":"Constructs a student with no scores and a maximum number of scores @capacity the maximum number of scores for this student","comments":"\n      Constructs a student with no scores and a maximum number of scores.\n      @capacity the maximum number of scores for this student\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":8,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   */\npublic boolean addScore(double score) {\n    if (scoresSize < scores.length) {\n        scores[scoresSize] = score;\n        scoresSize++;\n        return true;\n    } else {\n        return false;\n    }\n}\n","name":"addScore","className":"Student","variables":{"scoresSize":3,"score":1,"scores":1},"constants":{"true":1,"false":1},"javaDoc":"Adds a score for this student score the score to add true if the score was added false if there was no room to add the score","comments":"\n      Adds a score for this student.\n      @param score the score to add\n      @return true if the score was added, false if there was no room to add the score\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":11,"UnaryExpr":2,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   */\npublic int minimumPosition() {\n    if (scoresSize == 0) {\n        return -1;\n    }\n    int smallestPosition = 0;\n    for (int i = 1; i < scoresSize; i++) {\n        if (scores[i] < scores[smallestPosition]) {\n            smallestPosition = i;\n        }\n    }\n    return smallestPosition;\n}\n","name":"minimumPosition","className":"Student","variables":{"scoresSize":2,"smallestPosition":4,"scores":2,"i":5},"constants":{"0":2,"1":2},"javaDoc":"Gets the position of the minimum score the position of the smallest element of values or -1 if there are no scores","comments":"\n      Gets the position of the minimum score.\n      @return the position of the smallest element of values, or -1\n      if there are no scores.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the sum of the scores\n      @return the total score\n   */\npublic double sum() {\n    double total = 0;\n    for (int i = 0; i < scoresSize; i++) {\n        total = total + scores[i];\n    }\n    return total;\n}\n","name":"sum","className":"Student","variables":{"scoresSize":1,"total":4,"scores":1,"i":4},"constants":{"0":2},"javaDoc":"Computes the sum of the scores the total score","comments":"\n      Computes the sum of the scores\n      @return the total score\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":5,"UnaryExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   */\npublic void removeScore(int pos) {\n    // Remove the element at this position--see Section 7.3.6\n    scores[pos] = scores[scoresSize - 1];\n    scoresSize--;\n}\n","name":"removeScore","className":"Student","variables":{"scoresSize":2,"scores":2,"pos":1},"constants":{"1":1},"javaDoc":"Removes a score at a given position pos the position of the score to remove","comments":"Remove the element at this position--see Section 7 3 6 \n      Removes a score at a given position.\n      @param pos the position of the score to remove\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addScore":1,"minimumPosition":1,"sum":1,"hasNextDouble":1,"nextDouble":1,"removeScore":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"Student":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":44,"StringLiteralExpr":4,"FieldAccessExpr":5,"UnaryExpr":2,"MethodCallExpr":10},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Student fred = new Student(100);\n    System.out.println(\"Please enter values, Q to quit:\");\n    Scanner in = new Scanner(System.in);\n    while (in.hasNextDouble()) {\n        if (!fred.addScore(in.nextDouble())) {\n            System.out.println(\"Too many scores.\");\n            return;\n        }\n    }\n    int pos = fred.minimumPosition();\n    if (pos == -1) {\n        System.out.println(\"At least one score is required.\");\n    } else {\n        fred.removeScore(pos);\n        double total = fred.sum();\n        System.out.println(\"Final score: \" + total);\n    }\n}\n","name":"main","className":"ScoreAnalyzer","variables":{"total":2,"in":3,"pos":2,"fred":5},"constants":{"\"Please enter values, Q to quit:\"":1,"100":1,"1":1,"\"Too many scores.\"":1,"\"At least one score is required.\"":1,"\"Final score: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextDouble":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Random":1,"double":4,"int":3},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":1,"VariableDeclarationExpr":8,"DoubleLiteralExpr":1,"BinaryExpr":12,"NameExpr":25,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":4,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    final int TRIES = 10000;\n    Random generator = new Random();\n    int hits = 0;\n    for (int i = 1; i <= TRIES; i++) {\n        // Generate two random numbers between -1 and 1\n        double r = generator.nextDouble();\n        double x = -1 + 2 * r;\n        r = generator.nextDouble();\n        double y = -1 + 2 * r;\n        if (x * x + y * y <= 1) {\n            hits++;\n        }\n    }\n    /*\n         The ratio hits / tries is approximately the same as the ratio \n         circle area / square area = pi / 4\n      */\n    double piEstimate = 4.0 * hits / TRIES;\n    System.out.println(\"Estimate for pi: \" + piEstimate);\n}\n          // Check whether the point lies in the unit circle\n\n","name":"main","className":"MonteCarlo","variables":{"hits":3,"r":4,"x":3,"generator":3,"i":3,"y":3,"piEstimate":2,"TRIES":3},"constants":{"0":1,"1":4,"\"Estimate for pi: \"":1,"2":2,"4.0":1,"10000":1},"javaDoc":"","comments":"The ratio hits / tries is approximately the same as the ratio circle area / square area = pi / 4 Generate two random numbers between -1 and 1 Check whether the point lies in the unit circle ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"countSyllables":1,"endsWith":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Word":1,"String":1,"int":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":26,"StringLiteralExpr":4,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"BlockStmt":1,"ExpressionStmt":7,"DoStmt":1},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.println(\"Enter a sentence ending in a period.\");\n    String input;\n    do {\n        input = in.next();\n        Word w = new Word(input);\n        int syllables = w.countSyllables();\n        System.out.println(\"Syllables in \" + input + \": \" + syllables);\n    } while (!input.endsWith(\".\"));\n}\n","name":"main","className":"SyllableCounter","variables":{"input":5,"in":2,"w":2,"syllables":2},"constants":{"\"Syllables in \"":1,"\".\"":1,"\"Enter a sentence ending in a period.\"":1,"\": \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"Word","methodCalls":{"length":2,"isLetter":2,"charAt":2,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":31,"UnaryExpr":4,"MethodCallExpr":7,"AssignExpr":1},"statements":{"WhileStmt":2,"BlockStmt":2,"ExpressionStmt":5},"text":"/**\n      Constructs a word by removing leading and trailing non-\n      letter characters, such as punctuation marks.\n      @param s the input string\n   */\npublic Word(String s) {\n    int i = 0;\n    while (i < s.length() && !Character.isLetter(s.charAt(i))) {\n        i++;\n    }\n    int j = s.length() - 1;\n    while (j > i && !Character.isLetter(s.charAt(j))) {\n        j--;\n    }\n    text = s.substring(i, j);\n}\n","name":"Word","className":"Word","variables":{"s":5,"Character":2,"i":4,"j":3,"text":1},"constants":{"0":1,"1":1},"javaDoc":"Constructs a word by removing leading and trailing non- letter characters such as punctuation marks s the input string","comments":"\n      Constructs a word by removing leading and trailing non-\n      letter characters, such as punctuation marks.\n      @param s the input string\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the text of the word, after removal of the\n      leading and trailing non-letter characters.\n      @return the text of the word\n   */\npublic String getText() {\n    return text;\n}\n","name":"getText","className":"Word","variables":{"text":1},"constants":{},"javaDoc":"Returns the text of the word after removal of the leading and trailing non-letter characters the text of the word","comments":"\n      Returns the text of the word, after removal of the\n      leading and trailing non-letter characters.\n      @return the text of the word\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"length":1,"indexOf":1,"charAt":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"char":1,"String":1,"int":3},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":6,"BinaryExpr":8,"BooleanLiteralExpr":2,"NameExpr":29,"StringLiteralExpr":1,"CharLiteralExpr":2,"UnaryExpr":4,"MethodCallExpr":4,"AssignExpr":3},"statements":{"IfStmt":5,"BlockStmt":6,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":10},"text":"/**\n      Counts the syllables in the word.\n      @return the syllable count\n   */\npublic int countSyllables() {\n    int count = 0;\n    int end = text.length() - 1;\n    // The empty string has no syllables\n    if (end < 0) {\n        return 0;\n    }\n    // An e at the end of the word doesn't count as a vowel\n    char ch = text.charAt(end);\n    if (ch == 'e' || ch == 'E') {\n        end--;\n    }\n    boolean insideVowelGroup = false;\n    for (int i = 0; i <= end; i++) {\n        ch = text.charAt(i);\n        String vowels = \"aeiouyAEIOUY\";\n        if (vowels.indexOf(ch) >= 0) {\n            // ch is a vowel\n            if (!insideVowelGroup) {\n                // Start of new vowel group\n                count++;\n                insideVowelGroup = true;\n            }\n        }\n    }\n    // Every word has at least one syllable\n    if (count == 0) {\n        count = 1;\n    }\n    return count;\n}\n","name":"countSyllables","className":"Word","variables":{"vowels":2,"ch":4,"count":5,"i":3,"end":4,"insideVowelGroup":3,"text":3},"constants":{"0":6,"1":2,"false":1,"true":1,"'e'":1,"'E'":1,"\"aeiouyAEIOUY\"":1},"javaDoc":"Counts the syllables in the word the syllable count","comments":"The empty string has no syllables An e at the end of the word doesn't count as a vowel ch is a vowel Start of new vowel group Every word has at least one syllable \n      Counts the syllables in the word.\n      @return the syllable count\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":1,"nextDouble":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":3,"int":1},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":6,"NameExpr":32,"StringLiteralExpr":3,"FieldAccessExpr":4,"UnaryExpr":3,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    double sum = 0;\n    int count = 0;\n    double salary = 0;\n    System.out.print(\"Enter salaries, -1 to finish: \");\n    Scanner in = new Scanner(System.in);\n    while (salary != -1) {\n        salary = in.nextDouble();\n        if (salary != -1) {\n            sum = sum + salary;\n            count++;\n        }\n    }\n    if (count > 0) {\n        double average = sum / count;\n        System.out.println(\"Average salary: \" + average);\n       // Process data until the sentinel is entered \n\n    } else {\n        System.out.println(\"No data\");\n    }\n}\n       // Compute and print the average\n\n","name":"main","className":"SentinelDemo","variables":{"average":2,"in":2,"count":4,"sum":4,"salary":5},"constants":{"0":4,"1":2,"\"Average salary: \"":1,"\"Enter salaries, -1 to finish: \"":1,"\"No data\"":1},"javaDoc":"","comments":"Process data until the sentinel is entered Compute and print the average ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"cast":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Die":1,"int":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Die d = new Die(6);\n    final int TRIES = 10;\n    for (int i = 1; i <= TRIES; i++) {\n        int n = d.cast();\n        System.out.print(n + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"DieSimulator","variables":{"d":2,"i":3,"n":2,"TRIES":2},"constants":{"1":1,"\" \"":1,"6":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"Die","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a die with a given number of sides.\n      @param s the number of sides, e.g. 6 for a normal die\n   */\npublic Die(int s) {\n    sides = s;\n    generator = new Random();\n}\n","name":"Die","className":"Die","variables":{"s":1,"sides":1,"generator":1},"constants":{},"javaDoc":"Constructs a die with a given number of sides s the number of sides e g 6 for a normal die","comments":"\n      Constructs a die with a given number of sides.\n      @param s the number of sides, e.g. 6 for a normal die\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Simulates a throw of the die\n      @return the face of the die \n   */\npublic int cast() {\n    return 1 + generator.nextInt(sides);\n}\n","name":"cast","className":"Die","variables":{"generator":1},"constants":{"1":1},"javaDoc":"Simulates a throw of the die the face of the die","comments":"\n      Simulates a throw of the die\n      @return the face of the die \n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"waitYears":1,"System.out.printf":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":3,"int":1,"Investment":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    final double INITIAL_BALANCE = 10000;\n    final double RATE = 5;\n    final int YEARS = 20;\n    Investment invest = new Investment(INITIAL_BALANCE, RATE);\n    invest.waitYears(YEARS);\n    double balance = invest.getBalance();\n    System.out.printf(\"The balance after %d years is %.2f\\n\", YEARS, balance);\n}\n","name":"main","className":"InvestmentRunner","variables":{"YEARS":1,"balance":1,"RATE":2,"invest":3,"INITIAL_BALANCE":2},"constants":{"\"The balance after %d years is %.2f\\n\"":1,"5":1,"10000":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"Investment","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":5,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   */\npublic Investment(double aBalance, double aRate) {\n    balance = aBalance;\n    rate = aRate;\n    year = 0;\n}\n","name":"Investment","className":"Investment","variables":{"balance":1,"rate":1,"year":1,"aBalance":1,"aRate":1},"constants":{"0":1},"javaDoc":"Constructs an Investment object from a starting balance and interest rate aBalance the starting balance aRate the interest rate in percent","comments":"\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   */\npublic void waitForBalance(double targetBalance) {\n    while (balance < targetBalance) {\n        year++;\n        double interest = balance * rate / 100;\n        balance = balance + interest;\n    }\n}\n","name":"waitForBalance","className":"Investment","variables":{"targetBalance":1,"balance":4,"year":1,"interest":2,"rate":1},"constants":{"100":1},"javaDoc":"Keeps accumulating interest until a target balance has been reached targetBalance the desired balance","comments":"\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":11,"UnaryExpr":1,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"/**\n      Keeps accumulating interest for a given number of years.\n      @param numberOfYears the number of years to wait\n   */\npublic void waitYears(int numberOfYears) {\n    for (int i = 1; i <= numberOfYears; i++) {\n        double interest = balance * rate / 100;\n        balance = balance + interest;\n    }\n    year = year + numberOfYears;\n}\n","name":"waitYears","className":"Investment","variables":{"balance":3,"interest":2,"rate":1,"year":2,"numberOfYears":2,"i":3},"constants":{"1":1,"100":1},"javaDoc":"Keeps accumulating interest for a given number of years numberOfYears the number of years to wait","comments":"\n      Keeps accumulating interest for a given number of years.\n      @param numberOfYears the number of years to wait\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current investment balance.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"Investment","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current investment balance the current balance","comments":"\n      Gets the current investment balance.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   */\npublic int getYears() {\n    return year;\n}\n","name":"getYears","className":"Investment","variables":{"year":1},"constants":{},"javaDoc":"Gets the number of years this investment has accumulated interest the number of years since the start of the investment","comments":"\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":1,"charAt":1,"substring":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"char":1,"String":3,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":6,"StringLiteralExpr":1,"NameExpr":28,"CharLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    String creditCardNumber = \"4123-5678-9012-3450\";\n    int i = 0;\n    while (i < creditCardNumber.length()) {\n        char ch = creditCardNumber.charAt(i);\n        if (ch == ' ' || ch == '-') {\n            // Remove the character at position i\n            String before = creditCardNumber.substring(0, i);\n            String after = creditCardNumber.substring(i + 1);\n            creditCardNumber = before + after;\n        } else {\n            i++;\n        }\n    }\n    System.out.println(creditCardNumber);\n}\n","name":"main","className":"CCNumber","variables":{"ch":3,"before":2,"creditCardNumber":6,"i":4,"after":2},"constants":{"0":2,"'-'":1,"1":1,"\"4123-5678-9012-3450\"":1,"' '":1},"javaDoc":"","comments":"Remove the character at position i ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getHeight":1,"getRed":1,"getGreen":1,"setColorAt":1,"load":1,"getColorAt":1,"getWidth":1,"getBlue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Picture":1,"Color":2,"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":5,"VariableDeclarationExpr":5,"BinaryExpr":5,"NameExpr":33,"StringLiteralExpr":1,"UnaryExpr":2,"MethodCallExpr":8},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Picture pic = new Picture();\n    pic.load(\"queen-mary.png\");\n    for (int x = 0; x < pic.getWidth(); x++) {\n        for (int y = 0; y < pic.getHeight(); y++) {\n            Color original = pic.getColorAt(x, y);\n            Color negative = new Color(255 - original.getRed(), 255 - original.getGreen(), 255 - original.getBlue());\n            pic.setColorAt(x, y, negative);\n        }\n    }\n}\n","name":"main","className":"Negative","variables":{"negative":1,"original":4,"x":3,"y":3,"pic":6},"constants":{"0":2,"255":3,"\"queen-mary.png\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Picture","methodCalls":{"add":1,"setVisible":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"BooleanLiteralExpr":1,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"/**\n      Constructs a picture with no image.\n   */\npublic Picture() {\n    frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    label = new JLabel(\"(No image)\");\n    frame.add(label);\n    frame.pack();\n    frame.setVisible(true);\n}\n","name":"Picture","className":"Picture","variables":{"label":1,"frame":5},"constants":{"\"(No image)\"":1,"true":1},"javaDoc":"Constructs a picture with no image","comments":"\n      Constructs a picture with no image.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Picture","methodCalls":{"setIcon":1,"add":1,"setVisible":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":4,"BooleanLiteralExpr":1,"NameExpr":28,"StringLiteralExpr":1,"FieldAccessExpr":2,"AssignExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":8},"text":"/**\n      Constructs a picture with a given width and height.\n      @param width the desired width\n      @param height the desired height\n   */\npublic Picture(int width, int height) {\n    frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    label = new JLabel(\"\");\n    image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n    label.setIcon(new ImageIcon(image));\n    frame.add(label);\n    frame.pack();\n    frame.setVisible(true);\n}\n","name":"Picture","className":"Picture","variables":{"image":2,"width":1,"label":2,"frame":5,"height":1},"constants":{"\"\"":1,"true":1},"javaDoc":"Constructs a picture with a given width and height width the desired width height the desired height","comments":"\n      Constructs a picture with a given width and height.\n      @param width the desired width\n      @param height the desired height\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getWidth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the width of this picture.\n      @return the width\n   */\npublic int getWidth() {\n    return image.getWidth();\n}\n","name":"getWidth","className":"Picture","variables":{"image":1},"constants":{},"javaDoc":"Gets the width of this picture the width","comments":"\n      Gets the width of this picture.\n      @return the width\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getHeight":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the height of this picture.\n      @return the height\n   */\npublic int getHeight() {\n    return image.getHeight();\n}\n","name":"getHeight","className":"Picture","variables":{"image":1},"constants":{},"javaDoc":"Gets the height of this picture the height","comments":"\n      Gets the height of this picture.\n      @return the height\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"read":2,"printStackTrace":1,"startsWith":1,"setImage":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedImage":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":26,"StringLiteralExpr":1,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":4,"MethodCallExpr":6},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n   */\npublic void load(String source) {\n    try {\n        this.source = source;\n        BufferedImage img;\n        if (source.startsWith(\"http://\"))\n            img = ImageIO.read(new URL(source).openStream());\n        else\n            img = ImageIO.read(new File(source));\n        setImage(img);\n    } catch (Exception ex) {\n        this.source = null;\n        ex.printStackTrace();\n    }\n}\n","name":"load","className":"Picture","variables":{"img":3,"ex":2,"source":4,"ImageIO":2},"constants":{"null":1,"\"http://\"":1},"javaDoc":"Loads a picture from a given source source the image source If the source starts with http:// it is a URL otherwise a filename","comments":"\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"load":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Reloads this picture, undoing any manipulations.\n   */\npublic void reload() {\n    load(source);\n}\n","name":"reload","className":"Picture","variables":{},"constants":{},"javaDoc":"Reloads this picture undoing any manipulations","comments":"\n      Reloads this picture, undoing any manipulations.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showOpenDialog":1,"load":1,"getSelectedFile":1,"getAbsolutePath":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":13,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Displays a file chooser for picking a picture.\n   */\npublic void pick() {\n    JFileChooser chooser = new JFileChooser(\".\");\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        load(chooser.getSelectedFile().getAbsolutePath());\n    }\n}\n","name":"pick","className":"Picture","variables":{"chooser":3},"constants":{"null":1,"\".\"":1},"javaDoc":"Displays a file chooser for picking a picture","comments":"\n      Displays a file chooser for picking a picture.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BufferedImage"],"returnType":"void","methodCalls":{"setIcon":1,"pack":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"private void setImage(BufferedImage image) {\n    this.image = image;\n    label.setIcon(new ImageIcon(image));\n    label.setText(\" \");\n    frame.pack();\n}\n","name":"setImage","className":"Picture","variables":{"image":2,"label":2,"frame":1},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int","int"],"returnType":"Color","methodCalls":{"getColorModel":1,"getDataElements":1,"getRaster":1,"getRGB":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ColorModel":1,"Raster":1,"int":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"NameExpr":15,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   */\npublic Color getColorAt(int x, int y) {\n    Raster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    int argb = model.getRGB(raster.getDataElements(x, y, null));\n    return new Color(argb, true);\n}\n","name":"getColorAt","className":"Picture","variables":{"image":2,"argb":2,"raster":2,"model":2},"constants":{"null":1,"true":1},"javaDoc":"Gets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) the color of the pixel at position (x y)","comments":"\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","Color"],"returnType":"void","methodCalls":{"getColorModel":1,"getDataElements":1,"setDataElements":1,"repaint":1,"getRaster":1,"getRGB":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"WritableRaster":1,"ColorModel":1,"Object":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":21,"MethodCallExpr":6},"statements":{"ExpressionStmt":5},"text":"/**\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   */\npublic void setColorAt(int x, int y, Color c) {\n    WritableRaster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    Object colorData = model.getDataElements(c.getRGB(), null);\n    raster.setDataElements(x, y, colorData);\n    label.repaint();\n}\n","name":"setColorAt","className":"Picture","variables":{"image":2,"c":1,"colorData":1,"raster":2,"model":2,"label":1},"constants":{"null":1},"javaDoc":"Sets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) c the color for the pixel at position (x y)","comments":"\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getYears":1,"waitForBalance":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":2,"int":1,"Investment":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    final double INITIAL_BALANCE = 10000;\n    final double RATE = 5;\n    Investment invest = new Investment(INITIAL_BALANCE, RATE);\n    invest.waitForBalance(2 * INITIAL_BALANCE);\n    int years = invest.getYears();\n    System.out.println(\"The investment doubled after \" + years + \" years\");\n}\n","name":"main","className":"InvestmentRunner","variables":{"RATE":2,"invest":3,"INITIAL_BALANCE":3,"years":2},"constants":{"2":1,"5":1,"10000":1,"\" years\"":1,"\"The investment doubled after \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"Investment","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":5,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   */\npublic Investment(double aBalance, double aRate) {\n    balance = aBalance;\n    rate = aRate;\n    year = 0;\n}\n","name":"Investment","className":"Investment","variables":{"balance":1,"rate":1,"year":1,"aBalance":1,"aRate":1},"constants":{"0":1},"javaDoc":"Constructs an Investment object from a starting balance and interest rate aBalance the starting balance aRate the interest rate in percent","comments":"\n      Constructs an Investment object from a starting balance and\n      interest rate.\n      @param aBalance the starting balance\n      @param aRate the interest rate in percent\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   */\npublic void waitForBalance(double targetBalance) {\n    while (balance < targetBalance) {\n        year++;\n        double interest = balance * rate / 100;\n        balance = balance + interest;\n    }\n}\n","name":"waitForBalance","className":"Investment","variables":{"targetBalance":1,"balance":4,"year":1,"interest":2,"rate":1},"constants":{"100":1},"javaDoc":"Keeps accumulating interest until a target balance has been reached targetBalance the desired balance","comments":"\n      Keeps accumulating interest until a target balance has\n      been reached.\n      @param targetBalance the desired balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current investment balance.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"Investment","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current investment balance the current balance","comments":"\n      Gets the current investment balance.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   */\npublic int getYears() {\n    return year;\n}\n","name":"getYears","className":"Investment","variables":{"year":1},"constants":{},"javaDoc":"Gets the number of years this investment has accumulated interest the number of years since the start of the investment","comments":"\n      Gets the number of years this investment has accumulated\n      interest.\n      @return the number of years since the start of the investment\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":2,"System.out.print":2,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"boolean":2,"int":7},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":8,"VariableDeclarationExpr":10,"DoubleLiteralExpr":1,"BooleanLiteralExpr":5,"BinaryExpr":14,"NameExpr":87,"StringLiteralExpr":8,"FieldAccessExpr":9,"UnaryExpr":4,"MethodCallExpr":10,"AssignExpr":11},"statements":{"IfStmt":7,"WhileStmt":1,"BlockStmt":10,"ExpressionStmt":31},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter input: \");\n    int input = in.nextInt();\n    // The largest input\n    int min = input;\n    // The smallest input\n    int max = input;\n    // The number of inputs\n    int count = 1;\n    // The sum of the inputs\n    int sum = input;\n    // Set to true if we found at least one negative input\n    boolean foundNegative = false;\n    // The count of negative inputs\n    int negatives;\n    // The position of the first negative input\n    int firstNegative = 0;\n    if (input < 0) {\n        foundNegative = true;\n        firstNegative = 1;\n        negatives = 1;\n    } else {\n        negatives = 0;\n    }\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"Enter input, 0 to quit: \");\n        input = in.nextInt();\n        if (// Zero is the sentinel value\n        input == 0) {\n            done = true;\n        } else {\n            // Computing sum and average\n            sum = sum + input;\n            count++;\n            if (// Determining minimum and maximum\n            input < min) {\n                min = input;\n            } else if (input > max) {\n                max = input;\n            }\n            if (// Counting matches\n            input < 0) {\n                negatives++;\n                if (// Finding first match\n                !foundNegative) {\n                    foundNegative = true;\n                    firstNegative = count;\n                }\n            }\n        }\n    }\n    System.out.println(\"Minimum: \" + min);\n    System.out.println(\"Maximum: \" + max);\n    System.out.println(\"Sum: \" + sum);\n    System.out.println(\"Average: \" + sum * 1.0 / count);\n    System.out.println(\"Negative values: \" + negatives);\n    if (foundNegative) {\n        System.out.println(\"First negative: \" + firstNegative);\n    }\n}\n","name":"main","className":"LoopAlgorithms","variables":{"input":13,"min":4,"negatives":5,"in":3,"max":4,"count":4,"sum":5,"foundNegative":5,"done":3,"firstNegative":4},"constants":{"\"First negative: \"":1,"false":2,"\"Sum: \"":1,"\"Minimum: \"":1,"\"Negative values: \"":1,"\"Average: \"":1,"0":5,"\"Enter input, 0 to quit: \"":1,"1":3,"1.0":1,"true":3,"\"Enter input: \"":1,"\"Maximum: \"":1},"javaDoc":"","comments":"The largest input The smallest input The number of inputs The sum of the inputs Set to true if we found at least one negative input The count of negative inputs The position of the first negative input Zero is the sentinel value Computing sum and average Determining minimum and maximum Counting matches Finding first match ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":3,"pow":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":2,"int":4},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":6,"BinaryExpr":4,"NameExpr":48,"StringLiteralExpr":4,"FieldAccessExpr":6,"UnaryExpr":4,"MethodCallExpr":7},"statements":{"BlockStmt":4,"ForStmt":4,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    final int NMAX = 4;\n    final double XMAX = 10;\n    for (int n = 1; n <= NMAX; n++) {\n        System.out.printf(\"%10d\", n);\n    }\n    System.out.println();\n    for (int n = 1; n <= NMAX; n++) {\n        System.out.printf(\"%10s\", \"x \");\n    }\n    System.out.println();\n       // Print table header\n\n    for (double x = 1; x <= XMAX; x++) {\n        for (int n = 1; n <= NMAX; n++) {\n            System.out.printf(\"%10.0f\", Math.pow(x, n));\n        }\n        System.out.println();\n    }\n}\n       // Print table body\n\n          // Print table row\n\n","name":"main","className":"PowerTable","variables":{"NMAX":4,"XMAX":2,"x":3,"Math":1,"n":9},"constants":{"1":4,"4":1,"\"%10s\"":1,"\"%10d\"":1,"\"%10.0f\"":1,"\"x \"":1,"10":1},"javaDoc":"","comments":"Print table header Print table body Print table row ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sqrt":1,"System.out.print":1,"nextDouble":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":23,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ExpressionStmt":6,"DoStmt":1},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    double value;\n    do {\n        System.out.print(\"Enter a number >= 0: \");\n        value = in.nextDouble();\n    } while (value < 0);\n    double root = Math.sqrt(value);\n    System.out.println(\"The square root of the number is \" + root);\n}\n","name":"main","className":"DoLoop","variables":{"in":2,"root":2,"Math":1,"value":3},"constants":{"0":1,"\"The square root of the number is \"":1,"\"Enter a number >= 0: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseDouble":1,"showMessageDialog":1,"showInputDialog":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":2,"String":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"DoubleLiteralExpr":1,"BinaryExpr":4,"NameExpr":14,"StringLiteralExpr":2,"EnclosedExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    String input = JOptionPane.showInputDialog(\"Enter price:\");\n    double price = Double.parseDouble(input);\n    final double TAX_RATE = 8.5;\n    price = price * (1 + TAX_RATE / 100);\n    JOptionPane.showMessageDialog(null, \"Price after tax: \" + price);\n}\n","name":"main","className":"OptionPaneDemo","variables":{"input":1,"price":4,"TAX_RATE":2,"JOptionPane":2,"Double":1},"constants":{"1":1,"100":1,"\"Price after tax: \"":1,"null":1,"\"Enter price:\"":1,"8.5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"round":1,"System.out.print":4,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["Casting","FinalVariables"],"types":{"double":4,"int":4},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":8,"DoubleLiteralExpr":2,"BinaryExpr":4,"NameExpr":54,"StringLiteralExpr":4,"CastExpr":2,"FieldAccessExpr":8,"MethodCallExpr":9},"statements":{"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    int cansPerPack = 6;\n    // Liters in a 12-ounce can\n    final double CAN_VOLUME = 0.355;\n    double totalVolume = cansPerPack * CAN_VOLUME;\n    double pricePerPack = 2.59;\n    double pricePerLiter = pricePerPack / totalVolume;\n    System.out.print(\"Price per liter: \");\n    System.out.println(pricePerLiter);\n    // The integer part of the price gives the whole dollars.\n    int dollars = (int) pricePerLiter;\n    System.out.print(\"Dollars: \");\n    System.out.println(dollars);\n    // Multiply by 100 and round to the nearest integer to get the \n    // price in pennies.\n    int pennies = (int) Math.round(pricePerLiter * 100);\n    System.out.print(\"Pennies: \");\n    System.out.println(pennies);\n    // The cents are the last two digits of this value.\n    int cents = pennies % 100;\n    System.out.print(\"Cents: \");\n    System.out.println(cents);\n}\n","name":"main","className":"PriceDemo","variables":{"totalVolume":2,"pennies":2,"pricePerPack":2,"cents":1,"dollars":1,"CAN_VOLUME":2,"Math":1,"pricePerLiter":3,"cansPerPack":2},"constants":{"\"Price per liter: \"":1,"100":2,"\"Cents: \"":1,"6":1,"2.59":1,"\"Dollars: \"":1,"\"Pennies: \"":1,"0.355":1},"javaDoc":"","comments":"The integer part of the price gives the whole dollars Multiply by 100 and round to the nearest integer to get the price in pennies The cents are the last two digits of this value Liters in a 12-ounce can ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"System.out.print":2,"substring":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":31,"StringLiteralExpr":3,"FieldAccessExpr":4,"MethodCallExpr":7},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    // Get the names of the couple\n    System.out.print(\"Enter your first name: \");\n    String first = in.next();\n    System.out.print(\"Enter your significant other's first name: \");\n    String second = in.next();\n    // Compute and display the inscription\n    String initials = first.substring(0, 1) + \"&\" + second.substring(0, 1);\n    System.out.println(initials);\n}\n","name":"main","className":"Initials","variables":{"in":3,"initials":1,"first":2,"second":2},"constants":{"0":2,"1":2,"\"Enter your first name: \"":1,"\"Enter your significant other's first name: \"":1,"\"&\"":1},"javaDoc":"","comments":"Get the names of the couple Compute and display the inscription ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":2,"System.out.print":2,"nextDouble":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Scanner":1,"double":7},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":8,"DoubleLiteralExpr":1,"BinaryExpr":3,"NameExpr":46,"StringLiteralExpr":4,"FieldAccessExpr":7,"EnclosedExpr":1,"MethodCallExpr":8},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    // Read price per pack\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Please enter the price for a six-pack: \");\n    double packPrice = in.nextDouble();\n    // Read price per bottle\n    System.out.print(\"Please enter the price for a two-liter bottle: \");\n    double bottlePrice = in.nextDouble();\n    final double CANS_PER_PACK = 6;\n    // 12 oz. = 0.355 l \n    final double CAN_VOLUME = 0.355;\n    final double BOTTLE_VOLUME = 2;\n    // Compute and print price per liter\n    double packPricePerLiter = packPrice / (CANS_PER_PACK * CAN_VOLUME);\n    double bottlePricePerLiter = bottlePrice / BOTTLE_VOLUME;\n    System.out.printf(\"Pack price per liter:   %8.2f\", packPricePerLiter);\n    System.out.println();\n    System.out.printf(\"Bottle price per liter: %8.2f\", bottlePricePerLiter);\n    System.out.println();\n}\n","name":"main","className":"Volume","variables":{"bottlePricePerLiter":1,"in":3,"bottlePrice":2,"CANS_PER_PACK":2,"packPricePerLiter":1,"CAN_VOLUME":2,"packPrice":2,"BOTTLE_VOLUME":2},"constants":{"\"Please enter the price for a two-liter bottle: \"":1,"\"Bottle price per liter: %8.2f\"":1,"2":1,"6":1,"\"Pack price per liter:   %8.2f\"":1,"\"Please enter the price for a six-pack: \"":1,"0.355":1},"javaDoc":"","comments":"Read price per pack Read price per bottle Compute and print price per liter 12 oz = 0 355 l ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":2,"nextInt":2,"System.out.print":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Scanner":1,"int":7},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":8,"BinaryExpr":5,"NameExpr":51,"StringLiteralExpr":4,"FieldAccessExpr":7,"MethodCallExpr":8,"AssignExpr":1},"statements":{"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    final int PENNIES_PER_DOLLAR = 100;\n    final int PENNIES_PER_QUARTER = 25;\n    System.out.print(\"Enter bill value (1 = $1 bill, 5 = $5 bill, etc.): \");\n    int billValue = in.nextInt();\n    System.out.print(\"Enter item price in pennies: \");\n    int itemPrice = in.nextInt();\n    // Compute change due\n    int changeDue = PENNIES_PER_DOLLAR * billValue - itemPrice;\n    int dollarCoins = changeDue / PENNIES_PER_DOLLAR;\n    changeDue = changeDue % PENNIES_PER_DOLLAR;\n    int quarters = changeDue / PENNIES_PER_QUARTER;\n    // Print change due\n    System.out.printf(\"Dollar coins: %6d\", dollarCoins);\n    System.out.println();\n    System.out.printf(\"Quarters:     %6d\", quarters);\n    System.out.println();\n}\n","name":"main","className":"VendingMachine","variables":{"dollarCoins":1,"in":3,"PENNIES_PER_DOLLAR":4,"quarters":1,"billValue":2,"changeDue":5,"itemPrice":2,"PENNIES_PER_QUARTER":2},"constants":{"100":1,"25":1,"\"Quarters:     %6d\"":1,"\"Enter bill value (1 = $1 bill, 5 = $5 bill, etc.): \"":1,"\"Enter item price in pennies: \"":1,"\"Dollar coins: %6d\"":1},"javaDoc":"","comments":"Compute change due Print change due ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getVolume":2,"getSurfaceArea":1,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"Pyramid":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"NameExpr":39,"StringLiteralExpr":3,"FieldAccessExpr":6,"MethodCallExpr":9},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Pyramid sample = new Pyramid(10, 10);\n    System.out.println(sample.getVolume());\n    System.out.println(\"Expected: 333.33\");\n    System.out.println(sample.getSurfaceArea());\n    System.out.println(\"Expected: 224\");\n    Pyramid gizeh = new Pyramid(146, 230);\n    System.out.println(gizeh.getVolume());\n    /* \n         The following estimate is from \n         http://en.wikipedia.org/wiki/Great_Pyramid_of_Giza, citing\n         Levy, Janey (2005). The Great Pyramid of Giza: \n         Measuring Length, Area, Volume, and Angles. Rosen \n         Publishing Group. ISBN 1404260595.\n      */\n    System.out.println(\"Expected: 2500000\");\n}\n","name":"main","className":"PyramidTester","variables":{"gizeh":2,"sample":3},"constants":{"146":1,"\"Expected: 224\"":1,"\"Expected: 333.33\"":1,"\"Expected: 2500000\"":1,"10":2,"230":1},"javaDoc":"","comments":"The following estimate is from http://en wikipedia org/wiki/Great_Pyramid_of_Giza citing Levy Janey (2005) The Great Pyramid of Giza: Measuring Length Area Volume and Angles Rosen Publishing Group ISBN 1404260595 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"Pyramid","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a pyramid with a given height and baselength.\n      @param height the height\n      @param baseLength the length of one of the sides of the square base\n   */\npublic Pyramid(double height, double baseLength) {\n    this.height = height;\n    this.baseLength = baseLength;\n}\n","name":"Pyramid","className":"Pyramid","variables":{"baseLength":1,"height":1},"constants":{},"javaDoc":"Constructs a pyramid with a given height and baselength height the height baseLength the length of one of the sides of the square base","comments":"\n      Constructs a pyramid with a given height and baselength.\n      @param height the height\n      @param baseLength the length of one of the sides of the square base\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":3,"NameExpr":3},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the volume of this pyramid.\n      @return the volume\n   */\npublic double getVolume() {\n    return height * baseLength * baseLength / 3;\n}\n","name":"getVolume","className":"Pyramid","variables":{"baseLength":2,"height":1},"constants":{"3":1},"javaDoc":"Gets the volume of this pyramid the volume","comments":"\n      Gets the volume of this pyramid.\n      @return the volume\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":6,"NameExpr":9,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Gets the surface area of this pyramid.\n      @return the surface area, not including the base\n   */\npublic double getSurfaceArea() {\n    double sideLength = Math.sqrt(height * height + baseLength * baseLength / 4);\n    return 2 * baseLength * sideLength;\n}\n","name":"getSurfaceArea","className":"Pyramid","variables":{"sideLength":2,"Math":1,"baseLength":3,"height":2},"constants":{"2":1,"4":1},"javaDoc":"Gets the surface area of this pyramid the surface area not including the base","comments":"\n      Gets the surface area of this pyramid.\n      @return the surface area, not including the base\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sqrt":1,"pow":2,"System.out.print":5,"nextDouble":5,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":9},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":10,"BinaryExpr":6,"NameExpr":67,"StringLiteralExpr":6,"FieldAccessExpr":7,"MethodCallExpr":14},"statements":{"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Distance to item along x-axis: \");\n    double xDistance = in.nextDouble();\n    System.out.print(\"Distance to item along y-axis: \");\n    double yDistance = in.nextDouble();\n    System.out.print(\"Length of segment 1: \");\n    double segment1Length = in.nextDouble();\n    System.out.print(\"Speed along segment 1: \");\n    double segment1Speed = in.nextDouble();\n    System.out.print(\"Speed along segment 2: \");\n    double segment2Speed = in.nextDouble();\n    double segment1Time = segment1Length / segment1Speed;\n    double segment2Length = Math.sqrt(Math.pow(xDistance - segment1Length, 2) + Math.pow(yDistance, 2));\n    double segment2Time = segment2Length / segment2Speed;\n    double totalTime = segment1Time + segment2Time;\n    System.out.println(\"Total time: \" + totalTime);\n}\n","name":"main","className":"TravelTime","variables":{"xDistance":2,"segment1Time":2,"segment2Length":2,"in":6,"totalTime":2,"yDistance":1,"segment2Time":2,"segment1Speed":2,"Math":3,"segment1Length":3,"segment2Speed":2},"constants":{"\"Total time: \"":1,"2":2,"\"Length of segment 1: \"":1,"\"Distance to item along x-axis: \"":1,"\"Distance to item along y-axis: \"":1,"\"Speed along segment 1: \"":1,"\"Speed along segment 2: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"constants":{"0":2},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":1,"purchase":2},"constants":{},"javaDoc":"Records the purchase price of an item amount the price of the purchased item","comments":"\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":8,"NameExpr":10,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Processes the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   */\npublic void receivePayment(int dollars, int quarters, int dimes, int nickels, int pennies) {\n    payment = dollars + quarters * QUARTER_VALUE + dimes * DIME_VALUE + nickels * NICKEL_VALUE + pennies * PENNY_VALUE;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"NICKEL_VALUE":1,"dimes":1,"nickels":1,"quarters":1,"pennies":1,"payment":1,"dollars":1,"QUARTER_VALUE":1,"DIME_VALUE":1,"PENNY_VALUE":1},"constants":{},"javaDoc":"Processes the payment received from the customer dollars the number of dollars in the payment quarters the number of quarters in the payment dimes the number of dimes in the payment nickels the number of nickels in the payment pennies the number of pennies in the payment","comments":"\n      Processes the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":5,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"constants":{"0":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":4,"receivePayment":2,"giveChange":2,"System.out.print":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"CashRegister":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":10,"VariableDeclarationExpr":1,"DoubleLiteralExpr":4,"NameExpr":54,"StringLiteralExpr":4,"FieldAccessExpr":6,"MethodCallExpr":14},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(0.75);\n    register.recordPurchase(1.50);\n    register.receivePayment(2, 0, 5, 0, 0);\n    System.out.print(\"Change: \");\n    System.out.println(register.giveChange());\n    System.out.println(\"Expected: 0.25\");\n    register.recordPurchase(2.25);\n    register.recordPurchase(19.25);\n    register.receivePayment(23, 2, 0, 0, 0);\n    System.out.print(\"Change: \");\n    System.out.println(register.giveChange());\n    System.out.println(\"Expected: 2.0\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"register":9},"constants":{"0":6,"23":1,"2":2,"19.25":1,"5":1,"\"Expected: 2.0\"":1,"2.25":1,"0.75":1,"\"Change: \"":2,"1.50":1,"\"Expected: 0.25\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":2,"System.out.print":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"int":4},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":6,"DoubleLiteralExpr":1,"BinaryExpr":10,"NameExpr":38,"StringLiteralExpr":4,"FieldAccessExpr":5,"EnclosedExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Total width: \");\n    int totalWidth = in.nextInt();\n    System.out.print(\"Tile width: \");\n    int tileWidth = in.nextInt();\n    int numberOfPairs = (totalWidth - tileWidth) / (2 * tileWidth);\n    int numberOfTiles = 1 + 2 * numberOfPairs;\n    double gap = (totalWidth - numberOfTiles * tileWidth) / 2.0;\n    System.out.println(\"Number of tiles: \" + numberOfTiles);\n    System.out.println(\"Gap at each end: \" + gap);\n}\n","name":"main","className":"Tiles","variables":{"in":3,"gap":2,"numberOfPairs":2,"numberOfTiles":3,"tileWidth":4,"totalWidth":3},"constants":{"1":1,"\"Tile width: \"":1,"2":2,"\"Gap at each end: \"":1,"2.0":1,"\"Number of tiles: \"":1,"\"Total width: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"abs":1,"sqrt":1,"System.out.printf":3,"equals":1,"compareTo":1,"System.out.print":3,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":3,"String":4,"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":10,"DoubleLiteralExpr":2,"BinaryExpr":12,"NameExpr":89,"StringLiteralExpr":16,"FieldAccessExpr":10,"UnaryExpr":1,"MethodCallExpr":14,"AssignExpr":3},"statements":{"IfStmt":7,"BlockStmt":9,"ExpressionStmt":23},"text":"public static void main(String[] args) {\n    // Integers \n    int m = 2;\n    int n = 4;\n    if (m * m == n) {\n        System.out.println(\"2 times 2 is four.\");\n    }\n    // Floating-point numbers\n    double x = Math.sqrt(2);\n    double y = 2.0;\n    if (x * x == y) {\n        System.out.println(\"sqrt(2) times sqrt(2) is 2\");\n    } else {\n        System.out.printf(\"sqrt(2) times sqrt(2) is not four but %.18f\\n\", x * x);\n    }\n    final double EPSILON = 1E-14;\n    if (Math.abs(x * x - y) < EPSILON) {\n        System.out.println(\"sqrt(2) times sqrt(2) is approximately 2\");\n    }\n    // Strings\n    String s = \"120\";\n    String t = \"20\";\n    int result = s.compareTo(t);\n    String comparison;\n    if (result < 0) {\n        comparison = \"comes before\";\n    } else if (result > 0) {\n        comparison = \"comes after\";\n    } else {\n        comparison = \"is the same as\";\n    }\n    System.out.printf(\"The string \\\"%s\\\" %s the string \\\"%s\\\"\\n\", s, comparison, t);\n    String u = \"1\" + t;\n    System.out.printf(\"The strings \\\"%s\\\" and \\\"%s\\\" are \", s, u);\n    if (s != u) {\n        System.out.print(\"not \");\n    }\n    System.out.print(\"identical. They are \");\n    if (!s.equals(u)) {\n        System.out.print(\"not \");\n    }\n    System.out.println(\"equal.\");\n}\n","name":"main","className":"Compare","variables":{"result":3,"s":4,"comparison":4,"t":2,"u":2,"x":7,"y":3,"Math":2,"m":3,"n":2,"EPSILON":2},"constants":{"\"comes before\"":1,"\"120\"":1,"\"comes after\"":1,"\"equal.\"":1,"\"is the same as\"":1,"\"identical. They are \"":1,"\"sqrt(2) times sqrt(2) is 2\"":1,"1E-14":1,"0":2,"\"The strings \\\"%s\\\" and \\\"%s\\\" are \"":1,"2":2,"\"20\"":1,"\"1\"":1,"4":1,"2.0":1,"\"sqrt(2) times sqrt(2) is not four but %.18f\\n\"":1,"\"not \"":2,"\"sqrt(2) times sqrt(2) is approximately 2\"":1,"\"2 times 2 is four.\"":1,"\"The string \\\"%s\\\" %s the string \\\"%s\\\"\\n\"":1},"javaDoc":"","comments":"Integers Floating-point numbers Strings ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"System.out.printf":1,"equals":3,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"String":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":39,"StringLiteralExpr":6,"FieldAccessExpr":4,"MethodCallExpr":8,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":4,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.println(\"Enter the state or province: \");\n    String state = in.next();\n    System.out.println(\"Enter the country: \");\n    String country = in.next();\n    double shippingCost;\n    if (country.equals(\"USA\")) {\n        if (// See Section 5.7 for the || (or) operator\n        state.equals(\"AK\") || state.equals(\"HI\")) {\n            shippingCost = 10;\n        } else {\n            shippingCost = 5;\n        }\n    } else {\n        shippingCost = 10;\n    }\n    System.out.printf(\"Shipping cost to %s, %s: $%.2f\\n\", state, country, shippingCost);\n}\n","name":"main","className":"Shipping","variables":{"country":2,"shippingCost":4,"in":3,"state":3},"constants":{"5":1,"\"Shipping cost to %s, %s: $%.2f\\n\"":1,"\"USA\"":1,"\"AK\"":1,"\"Enter the state or province: \"":1,"\"Enter the country: \"":1,"\"HI\"":1,"10":2},"javaDoc":"","comments":"See Section 5 7 for the || (or) operator ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double"],"returnType":"Earthquake","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an Earthquake object.\n      @param magnitude the magnitude on the Richter scale\n   */\npublic Earthquake(double magnitude) {\n    richter = magnitude;\n}\n","name":"Earthquake","className":"Earthquake","variables":{"richter":1,"magnitude":1},"constants":{},"javaDoc":"Constructs an Earthquake object magnitude the magnitude on the Richter scale","comments":"\n      Constructs an Earthquake object.\n      @param magnitude the magnitude on the Richter scale\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":4,"BinaryExpr":4,"NameExpr":10,"StringLiteralExpr":5,"AssignExpr":5},"statements":{"IfStmt":4,"BlockStmt":5,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n      Gets a description of the effect of the earthquake.\n      @return the description of the effect\n   */\npublic String getDescription() {\n    String description;\n    if (richter >= 8.0) {\n        description = \"Most structures fall\";\n    } else if (richter >= 7.0) {\n        description = \"Many buildings destroyed\";\n    } else if (richter >= 6.0) {\n        description = \"Many buildings considerably damaged, some collapse\";\n    } else if (richter >= 4.5) {\n        description = \"Damage to poorly constructed buildings\";\n    } else {\n        description = \"No destruction of buildings\";\n    }\n    return description;\n}\n","name":"getDescription","className":"Earthquake","variables":{"richter":4,"description":7},"constants":{"\"Many buildings destroyed\"":1,"\"Damage to poorly constructed buildings\"":1,"\"Most structures fall\"":1,"\"Many buildings considerably damaged, some collapse\"":1,"\"No destruction of buildings\"":1,"6.0":1,"7.0":1,"8.0":1,"4.5":1},"javaDoc":"Gets a description of the effect of the earthquake the description of the effect","comments":"\n      Gets a description of the effect of the earthquake.\n      @return the description of the effect\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getDescription":1,"System.out.print":1,"nextDouble":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Earthquake":1,"double":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter a magnitude on the Richter scale: \");\n    double magnitude = in.nextDouble();\n    Earthquake quake = new Earthquake(magnitude);\n    System.out.println(quake.getDescription());\n}\n","name":"main","className":"EarthquakeRunner","variables":{"in":2,"quake":2,"magnitude":2},"constants":{"\"Enter a magnitude on the Richter scale: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":1,"System.out.print":1,"nextDouble":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"DoubleLiteralExpr":2,"BinaryExpr":2,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Original price before discount: \");\n    double originalPrice = in.nextDouble();\n    double discountRate;\n    if (originalPrice < 128) {\n        discountRate = 0.92;\n    } else {\n        discountRate = 0.84;\n    }\n    double discountedPrice = discountRate * originalPrice;\n    System.out.printf(\"Discounted price: %.2f\\n\", discountedPrice);\n}\n","name":"main","className":"Sale","variables":{"discountRate":4,"originalPrice":3,"discountedPrice":1,"in":2},"constants":{"0.92":1,"\"Original price before discount: \"":1,"128":1,"0.84":1,"\"Discounted price: %.2f\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"length":3,"System.out.print":1,"substring":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":2,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":7,"VariableDeclarationExpr":5,"BinaryExpr":7,"NameExpr":36,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":7,"AssignExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter a string: \");\n    String str = in.next();\n    int position;\n    int length;\n    if (str.length() % 2 == 1) {\n        position = str.length() / 2;\n        length = 1;\n    } else {\n        position = str.length() / 2 - 1;\n        length = 2;\n    }\n    String result = str.substring(position, position + length);\n    System.out.println(\"Middle: \" + result);\n}\n","name":"main","className":"Middle","variables":{"str":5,"result":2,"in":2,"length":4,"position":4},"constants":{"1":3,"2":4,"\"Middle: \"":1,"\"Enter a string: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Floor: \");\n    int floor = in.nextInt();\n    // Adjust floor if necessary\n    int actualFloor;\n    if (floor > 13) {\n        actualFloor = floor - 1;\n    } else {\n        actualFloor = floor;\n    }\n    System.out.println(\"The elevator will travel to the actual floor \" + actualFloor);\n}\n","name":"main","className":"ElevatorSimulation","variables":{"actualFloor":4,"in":2,"floor":4},"constants":{"1":1,"13":1,"\"Floor: \"":1,"\"The elevator will travel to the actual floor \"":1},"javaDoc":"","comments":"Adjust floor if necessary ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextDouble":2,"System.out.print":1,"System.out.println":8},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"DoubleLiteralExpr":2,"BinaryExpr":19,"NameExpr":70,"StringLiteralExpr":9,"FieldAccessExpr":10,"UnaryExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":5,"BlockStmt":8,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.println(\"Enter two numbers (such as 3.5 4.5): \");\n    double x = in.nextDouble();\n    double y = in.nextDouble();\n    if (x == y) {\n        System.out.println(\"They are the same.\");\n    } else {\n        System.out.print(\"The first number is \");\n        if (x > y) {\n            System.out.println(\"larger\");\n        } else {\n            System.out.println(\"smaller\");\n        }\n        if (-0.01 < x - y && x - y < 0.01) {\n            System.out.println(\"The numbers are close together\");\n        }\n        if (x == y + 1 || x == y - 1) {\n            System.out.println(\"The numbers are one apart\");\n        }\n        if (x > 0 && y > 0 || x < 0 && y < 0) {\n            System.out.println(\"The numbers have the same sign\");\n        } else {\n            System.out.println(\"The numbers have different signs\");\n        }\n    }\n}\n","name":"main","className":"Compare2","variables":{"in":3,"x":9,"y":9},"constants":{"\"The first number is \"":1,"0":4,"1":2,"\"Enter two numbers (such as 3.5 4.5): \"":1,"\"The numbers have different signs\"":1,"0.01":2,"\"larger\"":1,"\"The numbers are close together\"":1,"\"They are the same.\"":1,"\"The numbers are one apart\"":1,"\"smaller\"":1,"\"The numbers have the same sign\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"hasNextInt":1,"nextInt":1,"System.out.print":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":7,"NameExpr":42,"StringLiteralExpr":5,"FieldAccessExpr":6,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":4,"BlockStmt":6,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Floor: \");\n    if (in.hasNextInt()) {\n        // Now we know that the user entered an integer\n        int floor = in.nextInt();\n        if (floor == 13) {\n            System.out.println(\"Error: There is no thirteenth floor.\");\n        } else if (floor <= 0 || floor > 20) {\n            System.out.println(\"Error: The floor must be between 1 and 20.\");\n        } else {\n            // Now we know that the input is valid\n            int actualFloor = floor;\n            if (floor > 13) {\n                actualFloor = floor - 1;\n            }\n            System.out.println(\"The elevator will travel to the actual floor \" + actualFloor);\n        }\n    } else {\n        System.out.println(\"Error: Not an integer.\");\n    }\n}\n","name":"main","className":"ElevatorSimulation2","variables":{"actualFloor":3,"in":3,"floor":7},"constants":{"0":1,"1":1,"13":2,"\"Error: There is no thirteenth floor.\"":1,"\"Floor: \"":1,"\"Error: The floor must be between 1 and 20.\"":1,"\"Error: Not an integer.\"":1,"20":1,"\"The elevator will travel to the actual floor \"":1},"javaDoc":"","comments":"Now we know that the user entered an integer Now we know that the input is valid ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"equals":1,"getTax":1,"System.out.print":2,"nextDouble":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"double":1,"String":1,"int":1,"TaxReturn":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":1,"NameExpr":40,"StringLiteralExpr":4,"FieldAccessExpr":6,"MethodCallExpr":7,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Please enter your income: \");\n    double income = in.nextDouble();\n    System.out.print(\"Are you married? (Y/N) \");\n    String input = in.next();\n    int status;\n    if (input.equals(\"Y\")) {\n        status = TaxReturn.MARRIED;\n    } else {\n        status = TaxReturn.SINGLE;\n    }\n    TaxReturn aTaxReturn = new TaxReturn(income, status);\n    System.out.println(\"Tax: \" + aTaxReturn.getTax());\n}\n","name":"main","className":"TaxCalculator","variables":{"income":2,"input":2,"aTaxReturn":2,"in":3,"status":4},"constants":{"\"Are you married? (Y/N) \"":1,"\"Please enter your income: \"":1,"\"Tax: \"":1,"\"Y\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","int"],"returnType":"TaxReturn","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a TaxReturn object for a given income and \n      marital status.\n      @param anIncome the taxpayer income\n      @param aStatus either SINGLE or MARRIED\n   */\npublic TaxReturn(double anIncome, int aStatus) {\n    income = anIncome;\n    status = aStatus;\n}\n","name":"TaxReturn","className":"TaxReturn","variables":{"income":1,"anIncome":1,"aStatus":1,"status":1},"constants":{},"javaDoc":"Constructs a TaxReturn object for a given income and marital status anIncome the taxpayer income aStatus either SINGLE or MARRIED","comments":"\n      Constructs a TaxReturn object for a given income and \n      marital status.\n      @param anIncome the taxpayer income\n      @param aStatus either SINGLE or MARRIED\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":12,"NameExpr":28,"EnclosedExpr":2,"AssignExpr":6},"statements":{"IfStmt":3,"BlockStmt":6,"ReturnStmt":1,"ExpressionStmt":8},"text":"public double getTax() {\n    double tax1 = 0;\n    double tax2 = 0;\n    if (status == SINGLE) {\n        if (income <= RATE1_SINGLE_LIMIT) {\n            tax1 = RATE1 * income;\n        } else {\n            tax1 = RATE1 * RATE1_SINGLE_LIMIT;\n            tax2 = RATE2 * (income - RATE1_SINGLE_LIMIT);\n        }\n    } else {\n        if (income <= RATE1_MARRIED_LIMIT) {\n            tax1 = RATE1 * income;\n        } else {\n            tax1 = RATE1 * RATE1_MARRIED_LIMIT;\n            tax2 = RATE2 * (income - RATE1_MARRIED_LIMIT);\n        }\n    }\n    return tax1 + tax2;\n}\n","name":"getTax","className":"TaxReturn","variables":{"tax1":6,"income":6,"RATE2":2,"tax2":4,"SINGLE":1,"RATE1":4,"RATE1_MARRIED_LIMIT":3,"RATE1_SINGLE_LIMIT":3,"status":1},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"BinaryExpr":2,"NameExpr":30,"StringLiteralExpr":4,"FieldAccessExpr":6,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    // Prints 7\n    System.out.println(3 + 4);\n    // Prints \"Hello World!\" in two lines\n    System.out.println(\"Hello\");\n    System.out.println(\"World!\");\n    // Prints 00 but doesn't start a new line\n    System.out.print(\"00\");\n    // Prints 7 and starts a new line\n    System.out.println(3 + 4);\n    System.out.println(\"Goodbye\");\n}\n","name":"main","className":"PrintTester","variables":{},"constants":{"\"Hello\"":1,"\"00\"":1,"3":2,"4":2,"\"Goodbye\"":1,"\"World!\"":1},"javaDoc":"","comments":"Prints 7 Prints \"Hello World!\" in two lines Prints 00 but doesn't start a new line Prints 7 and starts a new line ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":5,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    System.out.println(1 / 0);\n// A run-time exception. The program terminates.\n}\n","name":"main","className":"Error3","variables":{},"constants":{"0":1,"1":1},"javaDoc":"","comments":"A run-time exception The program terminates ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    System.out.println(\"Hello, Word!\");\n// A run-time error. The program doesn't do what it should.\n}\n","name":"main","className":"Error2","variables":{},"constants":{"\"Hello, Word!\"":1},"javaDoc":"","comments":"A run-time error The program doesn't do what it should ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.ou.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    // A compile-time error. \n    System.ou.println(\"Hello, World!\");\n}\n","name":"main","className":"Error1","variables":{},"constants":{"\"Hello, World!\"":1},"javaDoc":"","comments":"A compile-time error ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    // Display a greeting in the console window\n    System.out.println(\"Hello, World!\");\n}\n","name":"main","className":"HelloPrinter","variables":{},"constants":{"\"Hello, World!\"":1},"javaDoc":"","comments":"Display a greeting in the console window ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"CalculatorFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new CalculatorFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"Calculator\");\n    frame.setVisible(true);\n}\n","name":"main","className":"CalculatorViewer","variables":{"frame":4},"constants":{"\"Calculator\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"CalculatorFrame","methodCalls":{"add":1,"createButtonPanel":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public CalculatorFrame() {\n    display = new JLabel(\"0\");\n    add(display, BorderLayout.NORTH);\n    createButtonPanel();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"CalculatorFrame","className":"CalculatorFrame","variables":{"display":1},"constants":{"\"0\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":17,"setLayout":1,"makeDigitButton":11,"makeOperatorButton":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":89,"StringLiteralExpr":16,"FieldAccessExpr":1,"MethodCallExpr":34},"statements":{"ExpressionStmt":19},"text":"/**\n      Creates the button panel.\n   */\nprivate void createButtonPanel() {\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 4));\n    buttonPanel.add(makeDigitButton(\"7\"));\n    buttonPanel.add(makeDigitButton(\"8\"));\n    buttonPanel.add(makeDigitButton(\"9\"));\n    buttonPanel.add(makeOperatorButton(\"/\"));\n    buttonPanel.add(makeDigitButton(\"4\"));\n    buttonPanel.add(makeDigitButton(\"5\"));\n    buttonPanel.add(makeDigitButton(\"6\"));\n    buttonPanel.add(makeOperatorButton(\"*\"));\n    buttonPanel.add(makeDigitButton(\"1\"));\n    buttonPanel.add(makeDigitButton(\"2\"));\n    buttonPanel.add(makeDigitButton(\"3\"));\n    buttonPanel.add(makeOperatorButton(\"-\"));\n    buttonPanel.add(makeDigitButton(\"0\"));\n    buttonPanel.add(makeDigitButton(\".\"));\n    buttonPanel.add(makeOperatorButton(\"=\"));\n    buttonPanel.add(makeOperatorButton(\"+\"));\n    add(buttonPanel, BorderLayout.CENTER);\n}\n","name":"createButtonPanel","className":"CalculatorFrame","variables":{"buttonPanel":18},"constants":{"\"=\"":1,"\"9\"":1,"\"8\"":1,"\"7\"":1,"\"6\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"\"1\"":1,"4":2,"\"0\"":1,"\"/\"":1,"\".\"":1,"\"-\"":1,"\"+\"":1,"\"*\"":1},"javaDoc":"Creates the button panel","comments":"\n      Creates the button panel.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"DigitButtonListener","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      */\npublic DigitButtonListener(String aDigit) {\n    digit = aDigit;\n}\n","name":"DigitButtonListener","className":"DigitButtonListener","variables":{"aDigit":1,"digit":1},"constants":{},"javaDoc":"Constructs a listener whose actionPerformed method adds a digit to the display aDigit the digit to add","comments":"\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    display.setText(display.getText() + digit);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"display":2,"digit":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":7,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   */\npublic JButton makeDigitButton(String digit) {\n    JButton button = new JButton(digit);\n    ActionListener listener = new DigitButtonListener(digit);\n    button.addActionListener(listener);\n    return button;\n}\n","name":"makeDigitButton","className":"CalculatorFrame","variables":{"button":3,"listener":1,"digit":2},"constants":{},"javaDoc":"Makes a button representing a digit of a calculator digit the digit of the calculator the button of the calculator","comments":"\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"JButton":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calcalator\n   */\npublic JButton makeOperatorButton(String op) {\n    JButton button = new JButton(op);\n    return button;\n}\n","name":"makeOperatorButton","className":"CalculatorFrame","variables":{"button":2,"op":1},"constants":{},"javaDoc":"Makes a button representing an operator of a calculator op the operator of the calculator the button of the calcalator","comments":"\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calcalator\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"InvestmentFrame3":1,"JFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new InvestmentFrame3();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer3","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"InvestmentFrame3","methodCalls":{"createPanel":1,"setEditable":1,"setSize":1,"createButton":1,"setText":1,"createTextField":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":22,"StringLiteralExpr":1,"AssignExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":8},"text":"public InvestmentFrame3() {\n    balance = INITIAL_BALANCE;\n    resultArea = new JTextArea(AREA_ROWS, AREA_COLUMNS);\n    resultArea.setText(balance + \"\\n\");\n    resultArea.setEditable(false);\n    createTextField();\n    createButton();\n    createPanel();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"InvestmentFrame3","className":"InvestmentFrame3","variables":{"AREA_ROWS":1,"balance":2,"AREA_COLUMNS":1,"resultArea":3,"INITIAL_BALANCE":1},"constants":{"false":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":2,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":4},"text":"private void createTextField() {\n    rateLabel = new JLabel(\"Interest Rate: \");\n    final int FIELD_WIDTH = 10;\n    rateField = new JTextField(FIELD_WIDTH);\n    rateField.setText(\"\" + DEFAULT_RATE);\n}\n","name":"createTextField","className":"InvestmentFrame3","variables":{"rateLabel":1,"DEFAULT_RATE":1,"FIELD_WIDTH":2,"rateField":2},"constants":{"\"\"":1,"\"Interest Rate: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"getText":1,"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":15,"StringLiteralExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent event) {\n    double rate = Double.parseDouble(rateField.getText());\n    double interest = balance * rate / 100;\n    balance = balance + interest;\n    resultArea.append(balance + \"\\n\");\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"balance":4,"rate":2,"interest":2,"rateField":1,"resultArea":1,"Double":1},"constants":{"100":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"AddInterestListener":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":5,"StringLiteralExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"private void createButton() {\n    button = new JButton(\"Add Interest\");\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n}\n","name":"createButton","className":"InvestmentFrame3","variables":{"button":2,"listener":1},"constants":{"\"Add Interest\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"JScrollPane":1,"JPanel":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":20,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"private void createPanel() {\n    JPanel panel = new JPanel();\n    panel.add(rateLabel);\n    panel.add(rateField);\n    panel.add(button);\n    JScrollPane scrollPane = new JScrollPane(resultArea);\n    panel.add(scrollPane);\n    add(panel);\n}\n","name":"createPanel","className":"InvestmentFrame3","variables":{"scrollPane":1,"resultArea":1,"panel":5},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"ColorFrame","methodCalls":{"add":1,"createControlPanel":1,"setSize":1,"setSampleColor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":15,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public ColorFrame() {\n    colorPanel = new JPanel();\n    add(colorPanel, BorderLayout.CENTER);\n    createControlPanel();\n    setSampleColor();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"ColorFrame","className":"ColorFrame","variables":{"colorPanel":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ChangeEvent"],"returnType":"void","methodCalls":{"setSampleColor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void stateChanged(ChangeEvent event) {\n    setSampleColor();\n}\n","name":"stateChanged","className":"ColorListener","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":7,"setLayout":1,"addChangeListener":3},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JPanel":1,"ColorListener":1,"ChangeListener":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":11,"VariableDeclarationExpr":2,"NameExpr":45,"StringLiteralExpr":3,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":11},"statements":{"ExpressionStmt":16},"text":"public void createControlPanel() {\n    ChangeListener listener = new ColorListener();\n    redSlider = new JSlider(0, 255, 255);\n    redSlider.addChangeListener(listener);\n    greenSlider = new JSlider(0, 255, 175);\n    greenSlider.addChangeListener(listener);\n    blueSlider = new JSlider(0, 255, 175);\n    blueSlider.addChangeListener(listener);\n    JPanel controlPanel = new JPanel();\n    controlPanel.setLayout(new GridLayout(3, 2));\n    controlPanel.add(new JLabel(\"Red\"));\n    controlPanel.add(redSlider);\n    controlPanel.add(new JLabel(\"Green\"));\n    controlPanel.add(greenSlider);\n    controlPanel.add(new JLabel(\"Blue\"));\n    controlPanel.add(blueSlider);\n    add(controlPanel, BorderLayout.SOUTH);\n}\n","name":"createControlPanel","className":"ColorFrame","variables":{"controlPanel":8,"greenSlider":2,"redSlider":2,"listener":1,"blueSlider":2},"constants":{"0":3,"\"Green\"":1,"255":4,"2":1,"3":1,"\"Red\"":1,"175":2,"\"Blue\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getValue":3,"repaint":1,"setBackground":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":18,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"/**\n      Reads the slider values and sets the panel to\n      the selected color.\n   */\npublic void setSampleColor() {\n    // Read slider values\n    int red = redSlider.getValue();\n    int green = greenSlider.getValue();\n    int blue = blueSlider.getValue();\n    // Set panel background to selected color\n    colorPanel.setBackground(new Color(red, green, blue));\n    colorPanel.repaint();\n}\n","name":"setSampleColor","className":"ColorFrame","variables":{"red":2,"colorPanel":2,"green":2,"blue":2,"greenSlider":1,"redSlider":1,"blueSlider":1},"constants":{},"javaDoc":"Reads the slider values and sets the panel to the selected color","comments":"Read slider values Set panel background to selected color \n      Reads the slider values and sets the panel to\n      the selected color.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ColorFrame":1,"JFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new ColorFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ColorViewer","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"FilledFrame":1,"JFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new FilledFrame();\n    frame.setTitle(\"A frame with two components\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"FilledFrameViewer2","variables":{"frame":4},"constants":{"true":1,"\"A frame with two components\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"FilledFrame","methodCalls":{"createComponents":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public FilledFrame() {\n    createComponents();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"FilledFrame","className":"FilledFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"NameExpr":13,"StringLiteralExpr":2,"AssignExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":6},"text":"private void createComponents() {\n    button = new JButton(\"Click me!\");\n    label = new JLabel(\"Hello, World!\");\n    JPanel panel = new JPanel();\n    panel.add(button);\n    panel.add(label);\n    add(panel);\n}\n","name":"createComponents","className":"FilledFrame","variables":{"button":1,"label":1,"panel":3},"constants":{"\"Hello, World!\"":1,"\"Click me!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"FontFrame","methodCalls":{"add":1,"setLabelFont":1,"createControlPanel":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"/**\n      Constructs the frame.\n   */\npublic FontFrame() {\n    // Construct text sample\n    label = new JLabel(\"Big Java\");\n    add(label, BorderLayout.CENTER);\n    // This listener is shared among all components\n    listener = new ChoiceListener();\n    createControlPanel();\n    setLabelFont();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"FontFrame","className":"FontFrame","variables":{"listener":1,"label":1},"constants":{"\"Big Java\"":1},"javaDoc":"Constructs the frame","comments":"Construct text sample This listener is shared among all components \n      Constructs the frame.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    setLabelFont();\n}\n","name":"actionPerformed","className":"ChoiceListener","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":4,"createCheckBoxes":1,"createComboBox":1,"setLayout":1,"createRadioButtons":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":4},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"NameExpr":27,"FieldAccessExpr":1,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"/**\n      Creates the control panel to change the font.\n   */\npublic void createControlPanel() {\n    JPanel facenamePanel = createComboBox();\n    JPanel sizeGroupPanel = createCheckBoxes();\n    JPanel styleGroupPanel = createRadioButtons();\n    // Line up component panels\n    JPanel controlPanel = new JPanel();\n    controlPanel.setLayout(new GridLayout(3, 1));\n    controlPanel.add(facenamePanel);\n    controlPanel.add(sizeGroupPanel);\n    controlPanel.add(styleGroupPanel);\n    // Add panels to content pane\n    add(controlPanel, BorderLayout.SOUTH);\n}\n","name":"createControlPanel","className":"FontFrame","variables":{"controlPanel":5,"facenamePanel":1,"styleGroupPanel":1,"sizeGroupPanel":1},"constants":{"1":1,"3":1},"javaDoc":"Creates the control panel to change the font","comments":"Line up component panels Add panels to content pane \n      Creates the control panel to change the font.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":1,"addItem":3,"setEditable":1,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":22,"StringLiteralExpr":3,"AssignExpr":1,"MethodCallExpr":6},"statements":{"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Creates the combo box with the font style choices.\n      @return the panel containing the combo box\n   */\npublic JPanel createComboBox() {\n    facenameCombo = new JComboBox();\n    facenameCombo.addItem(\"Serif\");\n    facenameCombo.addItem(\"SansSerif\");\n    facenameCombo.addItem(\"Monospaced\");\n    facenameCombo.setEditable(true);\n    facenameCombo.addActionListener(listener);\n    JPanel panel = new JPanel();\n    panel.add(facenameCombo);\n    return panel;\n}\n","name":"createComboBox","className":"FontFrame","variables":{"facenameCombo":6,"panel":3},"constants":{"\"SansSerif\"":1,"true":1,"\"Monospaced\"":1,"\"Serif\"":1},"javaDoc":"Creates the combo box with the font style choices the panel containing the combo box","comments":"\n      Creates the combo box with the font style choices.\n      @return the panel containing the combo box\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":2,"setBorder":1,"addActionListener":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":5,"VariableDeclarationExpr":1,"NameExpr":22,"StringLiteralExpr":3,"AssignExpr":2,"MethodCallExpr":5},"statements":{"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Creates the check boxes for selecting bold and italic styles.\n      @return the panel containing the check boxes\n   */\npublic JPanel createCheckBoxes() {\n    italicCheckBox = new JCheckBox(\"Italic\");\n    italicCheckBox.addActionListener(listener);\n    boldCheckBox = new JCheckBox(\"Bold\");\n    boldCheckBox.addActionListener(listener);\n    JPanel panel = new JPanel();\n    panel.add(italicCheckBox);\n    panel.add(boldCheckBox);\n    panel.setBorder(new TitledBorder(new EtchedBorder(), \"Style\"));\n    return panel;\n}\n","name":"createCheckBoxes","className":"FontFrame","variables":{"panel":5,"italicCheckBox":2,"boldCheckBox":2},"constants":{"\"Bold\"":1,"\"Style\"":1,"\"Italic\"":1},"javaDoc":"Creates the check boxes for selecting bold and italic styles the panel containing the check boxes","comments":"\n      Creates the check boxes for selecting bold and italic styles.\n      @return the panel containing the check boxes\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":6,"setSelected":1,"setBorder":1,"addActionListener":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"ButtonGroup":1},"expressions":{"ObjectCreationExpr":7,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":46,"StringLiteralExpr":4,"AssignExpr":3,"MethodCallExpr":11},"statements":{"ReturnStmt":1,"ExpressionStmt":16},"text":"/**\n      Creates the radio buttons to select the font size.\n      @return the panel containing the radio buttons\n   */\npublic JPanel createRadioButtons() {\n    smallButton = new JRadioButton(\"Small\");\n    smallButton.addActionListener(listener);\n    mediumButton = new JRadioButton(\"Medium\");\n    mediumButton.addActionListener(listener);\n    largeButton = new JRadioButton(\"Large\");\n    largeButton.addActionListener(listener);\n    largeButton.setSelected(true);\n    // Add radio buttons to button group\n    ButtonGroup group = new ButtonGroup();\n    group.add(smallButton);\n    group.add(mediumButton);\n    group.add(largeButton);\n    JPanel panel = new JPanel();\n    panel.add(smallButton);\n    panel.add(mediumButton);\n    panel.add(largeButton);\n    panel.setBorder(new TitledBorder(new EtchedBorder(), \"Size\"));\n    return panel;\n}\n","name":"createRadioButtons","className":"FontFrame","variables":{"mediumButton":2,"largeButton":3,"panel":6,"smallButton":2,"group":4},"constants":{"\"Medium\"":1,"true":1,"\"Size\"":1,"\"Large\"":1,"\"Small\"":1},"javaDoc":"Creates the radio buttons to select the font size the panel containing the radio buttons","comments":"Add radio buttons to button group \n      Creates the radio buttons to select the font size.\n      @return the panel containing the radio buttons\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"isSelected":5,"setFont":1,"repaint":1,"getSelectedItem":1},"annotations":[],"exceptions":[],"concepts":["Casting","FinalVariables"],"types":{"String":1,"int":5},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":2,"CastExpr":1,"NameExpr":43,"FieldAccessExpr":2,"MethodCallExpr":8,"AssignExpr":5},"statements":{"IfStmt":5,"BlockStmt":5,"ExpressionStmt":13},"text":"/**\n      Gets user choice for font name, style, and size\n      and sets the font of the text sample.\n   */\npublic void setLabelFont() {\n    // Get font name   \n    String facename = (String) facenameCombo.getSelectedItem();\n    // Get font style\n    int style = 0;\n    if (italicCheckBox.isSelected()) {\n        style = style + Font.ITALIC;\n    }\n    if (boldCheckBox.isSelected()) {\n        style = style + Font.BOLD;\n    }\n    // Get font size   \n    int size = 0;\n    final int SMALL_SIZE = 24;\n    final int MEDIUM_SIZE = 36;\n    final int LARGE_SIZE = 48;\n    if (smallButton.isSelected()) {\n        size = SMALL_SIZE;\n    } else if (mediumButton.isSelected()) {\n        size = MEDIUM_SIZE;\n    } else if (largeButton.isSelected()) {\n        size = LARGE_SIZE;\n    }\n    // Set font of text field\n    label.setFont(new Font(facename, style, size));\n    label.repaint();\n}\n","name":"setLabelFont","className":"FontFrame","variables":{"SMALL_SIZE":2,"facenameCombo":1,"label":2,"LARGE_SIZE":2,"facename":2,"smallButton":1,"mediumButton":1,"largeButton":1,"size":5,"style":6,"MEDIUM_SIZE":2,"italicCheckBox":1,"boldCheckBox":1},"constants":{"0":2,"24":1,"36":1,"48":1},"javaDoc":"Gets user choice for font name style and size and sets the font of the text sample","comments":"Get font style Get font size Set font of text field Get font name \n      Gets user choice for font name, style, and size\n      and sets the font of the text sample.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"FontFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new FontFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"FontViewer\");\n    frame.setVisible(true);\n}\n","name":"main","className":"FontViewer","variables":{"frame":4},"constants":{"true":1,"\"FontViewer\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"CalculatorFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new CalculatorFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"Calculator\");\n    frame.setVisible(true);\n}\n","name":"main","className":"CalculatorViewer","variables":{"frame":4},"constants":{"\"Calculator\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"CalculatorFrame","methodCalls":{"add":1,"createControlPanel":1,"createButtonPanel":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":18,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":8},"text":"public CalculatorFrame() {\n    createButtonPanel();\n    createControlPanel();\n    display = new JLabel(\"0\");\n    add(display, BorderLayout.NORTH);\n    lastValue = 0;\n    lastOperator = \"=\";\n    startNewValue = true;\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"CalculatorFrame","className":"CalculatorFrame","variables":{"lastValue":1,"lastOperator":1,"display":1,"startNewValue":1},"constants":{"0":1,"\"0\"":1,"\"=\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":17,"setLayout":1,"makeDigitButton":11,"makeOperatorButton":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":89,"StringLiteralExpr":16,"FieldAccessExpr":1,"MethodCallExpr":34},"statements":{"ExpressionStmt":19},"text":"/**\n      Creates the control panel with the text field \n      and buttons on the frame.\n   */\nprivate void createButtonPanel() {\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 4));\n    buttonPanel.add(makeDigitButton(\"7\"));\n    buttonPanel.add(makeDigitButton(\"8\"));\n    buttonPanel.add(makeDigitButton(\"9\"));\n    buttonPanel.add(makeOperatorButton(\"/\"));\n    buttonPanel.add(makeDigitButton(\"4\"));\n    buttonPanel.add(makeDigitButton(\"5\"));\n    buttonPanel.add(makeDigitButton(\"6\"));\n    buttonPanel.add(makeOperatorButton(\"*\"));\n    buttonPanel.add(makeDigitButton(\"1\"));\n    buttonPanel.add(makeDigitButton(\"2\"));\n    buttonPanel.add(makeDigitButton(\"3\"));\n    buttonPanel.add(makeOperatorButton(\"-\"));\n    buttonPanel.add(makeDigitButton(\"0\"));\n    buttonPanel.add(makeDigitButton(\".\"));\n    buttonPanel.add(makeOperatorButton(\"=\"));\n    buttonPanel.add(makeOperatorButton(\"+\"));\n    add(buttonPanel, BorderLayout.CENTER);\n}\n","name":"createButtonPanel","className":"CalculatorFrame","variables":{"buttonPanel":18},"constants":{"\"=\"":1,"\"9\"":1,"\"8\"":1,"\"7\"":1,"\"6\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"\"1\"":1,"4":2,"\"0\"":1,"\"/\"":1,"\".\"":1,"\"-\"":1,"\"+\"":1,"\"*\"":1},"javaDoc":"Creates the control panel with the text field and buttons on the frame","comments":"\n      Creates the control panel with the text field \n      and buttons on the frame.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"tan":1,"log":2,"getText":1,"cos":1,"equals":8,"isSelected":3,"sin":1,"pow":1,"toRadians":1,"getSelectedItem":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":1,"double":2,"String":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":88,"CastExpr":1,"StringLiteralExpr":9,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":22,"AssignExpr":9},"statements":{"IfStmt":8,"BlockStmt":8,"ExpressionStmt":14},"text":"public void actionPerformed(ActionEvent event) {\n    double value = Double.parseDouble(display.getText());\n    String mathOp = (String) mathOpCombo.getSelectedItem();\n    double base = 10;\n    if (baseeButton.isSelected()) {\n        base = Math.E;\n    } else if (base2Button.isSelected()) {\n        base = 2;\n    }\n    boolean radian = radianCheckBox.isSelected();\n    if (!radian && (mathOp.equals(\"sin\") || mathOp.equals(\"cos\") || mathOp.equals(\"tan\"))) {\n        value = Math.toRadians(value);\n    }\n    if (mathOp.equals(\"sin\")) {\n        value = Math.sin(value);\n    } else if (mathOp.equals(\"cos\")) {\n        value = Math.cos(value);\n    } else if (mathOp.equals(\"tan\")) {\n        value = Math.tan(value);\n    } else if (mathOp.equals(\"log\")) {\n        value = Math.log(value) / Math.log(base);\n    } else if (mathOp.equals(\"exp\")) {\n        value = Math.pow(base, value);\n    }\n    display.setText(\"\" + value);\n    startNewValue = true;\n}\n","name":"actionPerformed","className":"MathOpListener","variables":{"base2Button":1,"mathOp":9,"display":2,"baseeButton":1,"startNewValue":1,"mathOpCombo":1,"Math":7,"value":8,"Double":1,"base":3,"radian":2,"radianCheckBox":1},"constants":{"\"cos\"":2,"\"\"":1,"\"log\"":1,"2":1,"\"tan\"":2,"\"sin\"":2,"true":1,"\"exp\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JPanel","methodCalls":{"add":6,"setSelected":1,"setBorder":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"ButtonGroup":1},"expressions":{"ObjectCreationExpr":7,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":34,"StringLiteralExpr":4,"AssignExpr":3,"MethodCallExpr":8},"statements":{"ReturnStmt":1,"ExpressionStmt":13},"text":"private JPanel createBaseButtons() {\n    baseeButton = new JRadioButton(\"e\");\n    base10Button = new JRadioButton(\"10\");\n    base2Button = new JRadioButton(\"2\");\n    baseeButton.setSelected(true);\n    ButtonGroup group = new ButtonGroup();\n    group.add(baseeButton);\n    group.add(base10Button);\n    group.add(base2Button);\n    JPanel basePanel = new JPanel();\n    basePanel.add(baseeButton);\n    basePanel.add(base10Button);\n    basePanel.add(base2Button);\n    basePanel.setBorder(new TitledBorder(new EtchedBorder(), \"Base\"));\n    return basePanel;\n}\n","name":"createBaseButtons","className":"CalculatorFrame","variables":{"base10Button":1,"base2Button":1,"baseeButton":2,"basePanel":6,"group":4},"constants":{"\"10\"":1,"\"2\"":1,"true":1,"\"Base\"":1,"\"e\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5,"addItem":5,"setSelected":1,"addActionListener":1,"createBaseButtons":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":5,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":47,"StringLiteralExpr":7,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":13},"statements":{"ExpressionStmt":16},"text":"private void createControlPanel() {\n    radianCheckBox = new JCheckBox(\"Radian\");\n    radianCheckBox.setSelected(true);\n    mathOpCombo = new JComboBox();\n    mathOpCombo.addItem(\"sin\");\n    mathOpCombo.addItem(\"cos\");\n    mathOpCombo.addItem(\"tan\");\n    mathOpCombo.addItem(\"log\");\n    mathOpCombo.addItem(\"exp\");\n    mathOpButton = new JButton(\"Apply\");\n    mathOpButton.addActionListener(new MathOpListener());\n    JPanel controlPanel = new JPanel();\n    controlPanel.add(radianCheckBox);\n    controlPanel.add(createBaseButtons());\n    controlPanel.add(mathOpCombo);\n    controlPanel.add(mathOpButton);\n    add(controlPanel, BorderLayout.SOUTH);\n}\n","name":"createControlPanel","className":"CalculatorFrame","variables":{"controlPanel":5,"mathOpButton":2,"mathOpCombo":6,"radianCheckBox":2},"constants":{"\"Radian\"":1,"\"cos\"":1,"\"log\"":1,"\"tan\"":1,"true":1,"\"sin\"":1,"\"exp\"":1,"\"Apply\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["double","double","String"],"returnType":"double","methodCalls":{"equals":4},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":21,"StringLiteralExpr":4,"MethodCallExpr":4},"statements":{"IfStmt":4,"BlockStmt":5,"ReturnStmt":5},"text":"/**\n      Combines two values with an operator.\n      @param value1 the first value\n      @param value2 the second value\n      @param op an operator (+, -, *, /, or =)\n   */\npublic double calculate(double value1, double value2, String op) {\n    if (op.equals(\"+\")) {\n        return value1 + value2;\n    } else if (op.equals(\"-\")) {\n        return value1 - value2;\n    } else if (op.equals(\"*\")) {\n        return value1 * value2;\n    } else if (op.equals(\"/\")) {\n        return value1 / value2;\n    } else // \"=\"\n    {\n        return value2;\n    }\n}\n","name":"calculate","className":"CalculatorFrame","variables":{"op":4,"value2":5,"value1":4},"constants":{"\"/\"":1,"\"-\"":1,"\"+\"":1,"\"*\"":1},"javaDoc":"Combines two values with an operator value1 the first value value2 the second value op an operator (+ - / or =)","comments":"\"=\" \n      Combines two values with an operator.\n      @param value1 the first value\n      @param value2 the second value\n      @param op an operator (+, -, *, /, or =)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"DigitButtonListener","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      */\npublic DigitButtonListener(String aDigit) {\n    digit = aDigit;\n}\n","name":"DigitButtonListener","className":"DigitButtonListener","variables":{"aDigit":1,"digit":1},"constants":{},"javaDoc":"Constructs a listener whose actionPerformed method adds a digit to the display aDigit the digit to add","comments":"\n         Constructs a listener whose actionPerformed method adds a digit\n         to the display.\n         @param aDigit the digit to add\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":1,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent event) {\n    if (startNewValue) {\n        display.setText(\"\");\n        startNewValue = false;\n    }\n    display.setText(display.getText() + digit);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"startNewValue":2,"display":3,"digit":1},"constants":{"\"\"":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":7,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   */\npublic JButton makeDigitButton(String digit) {\n    JButton button = new JButton(digit);\n    ActionListener listener = new DigitButtonListener(digit);\n    button.addActionListener(listener);\n    return button;\n}\n","name":"makeDigitButton","className":"CalculatorFrame","variables":{"button":3,"listener":1,"digit":2},"constants":{},"javaDoc":"Makes a button representing a digit of a calculator digit the digit of the calculator the button of the calculator","comments":"\n      Makes a button representing a digit of a calculator.\n      @param digit the digit of the calculator\n      @return the button of the calculator\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"OperatorButtonListener","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n         Constructs a listener whose actionPerformed method\n         schedules an operator for execution.\n      */\npublic OperatorButtonListener(String anOperator) {\n    operator = anOperator;\n}\n","name":"OperatorButtonListener","className":"OperatorButtonListener","variables":{"anOperator":1,"operator":1},"constants":{},"javaDoc":"Constructs a listener whose actionPerformed method schedules an operator for execution","comments":"\n         Constructs a listener whose actionPerformed method\n         schedules an operator for execution.\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"getText":1,"calculate":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":20,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent event) {\n    if (!startNewValue) {\n        double value = Double.parseDouble(display.getText());\n        lastValue = calculate(lastValue, value, lastOperator);\n        display.setText(\"\" + lastValue);\n        startNewValue = true;\n    }\n    lastOperator = operator;\n}\n","name":"actionPerformed","className":"OperatorButtonListener","variables":{"lastValue":2,"lastOperator":1,"startNewValue":2,"display":2,"value":1,"Double":1,"operator":1},"constants":{"\"\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"JButton","methodCalls":{"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"JButton":1,"OperatorButtonListener":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":7,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calculator\n   */\npublic JButton makeOperatorButton(String op) {\n    JButton button = new JButton(op);\n    ActionListener listener = new OperatorButtonListener(op);\n    button.addActionListener(listener);\n    return button;\n}\n","name":"makeOperatorButton","className":"CalculatorFrame","variables":{"button":3,"op":2,"listener":1},"constants":{},"javaDoc":"Makes a button representing an operator of a calculator op the operator of the calculator the button of the calculator","comments":"\n      Makes a button representing an operator of a calculator.\n      @param op the operator of the calculator\n      @return the button of the calculator\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"InvestmentFrame2":1,"JFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new InvestmentFrame2();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer2","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"InvestmentFrame2","methodCalls":{"createPanel":1,"setSize":1,"createButton":1,"createTextField":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":14,"StringLiteralExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public InvestmentFrame2() {\n    balance = INITIAL_BALANCE;\n    resultLabel = new JLabel(\"Balance: \" + balance);\n    createTextField();\n    createButton();\n    createPanel();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"InvestmentFrame2","className":"InvestmentFrame2","variables":{"balance":2,"INITIAL_BALANCE":1,"resultLabel":1},"constants":{"\"Balance: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":2,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":4},"text":"private void createTextField() {\n    rateLabel = new JLabel(\"Interest Rate: \");\n    final int FIELD_WIDTH = 10;\n    rateField = new JTextField(FIELD_WIDTH);\n    rateField.setText(\"\" + DEFAULT_RATE);\n}\n","name":"createTextField","className":"InvestmentFrame2","variables":{"rateLabel":1,"DEFAULT_RATE":1,"FIELD_WIDTH":2,"rateField":2},"constants":{"\"\"":1,"\"Interest Rate: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseDouble":1,"getText":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":15,"StringLiteralExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent event) {\n    double rate = Double.parseDouble(rateField.getText());\n    double interest = balance * rate / 100;\n    balance = balance + interest;\n    resultLabel.setText(\"Balance: \" + balance);\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"balance":4,"rate":2,"interest":2,"rateField":1,"Double":1,"resultLabel":1},"constants":{"100":1,"\"Balance: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"AddInterestListener":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":5,"StringLiteralExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"private void createButton() {\n    button = new JButton(\"Add Interest\");\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n}\n","name":"createButton","className":"InvestmentFrame2","variables":{"button":2,"listener":1},"constants":{"\"Add Interest\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":19,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"private void createPanel() {\n    JPanel panel = new JPanel();\n    panel.add(rateLabel);\n    panel.add(rateField);\n    panel.add(button);\n    panel.add(resultLabel);\n    add(panel);\n}\n","name":"createPanel","className":"InvestmentFrame2","variables":{"panel":5},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"FontFrame2":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new FontFrame2();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setTitle(\"FontViewer\");\n    frame.setVisible(true);\n}\n","name":"main","className":"FontViewer2","variables":{"frame":4},"constants":{"true":1,"\"FontViewer\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"FontFrame2","methodCalls":{"add":3,"setJMenuBar":1,"setLabelFont":1,"setSize":1,"createFileMenu":1,"createFontMenu":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JMenuBar":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":32,"StringLiteralExpr":2,"FieldAccessExpr":2,"AssignExpr":4,"MethodCallExpr":8},"statements":{"ExpressionStmt":11},"text":"/**\n      Constructs the frame.\n   */\npublic FontFrame2() {\n    // Construct text sample     \n    label = new JLabel(\"Big Java\");\n    add(label, BorderLayout.CENTER);\n    // Construct menu      \n    JMenuBar menuBar = new JMenuBar();\n    setJMenuBar(menuBar);\n    menuBar.add(createFileMenu());\n    menuBar.add(createFontMenu());\n    facename = \"Serif\";\n    fontsize = 24;\n    fontstyle = Font.PLAIN;\n    setLabelFont();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"FontFrame2","className":"FontFrame2","variables":{"menuBar":3,"fontstyle":1,"fontsize":1,"label":1,"facename":1},"constants":{"\"Big Java\"":1,"24":1,"\"Serif\"":1},"javaDoc":"Constructs the frame","comments":"Construct text sample Construct menu \n      Constructs the frame.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"ExitItemListener","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":1,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"ExitItemListener":1,"JMenuItem":1,"JMenu":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"StringLiteralExpr":2,"NameExpr":9,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Creates the File menu.\n      @return the menu\n   */\npublic JMenu createFileMenu() {\n    JMenu menu = new JMenu(\"File\");\n    JMenuItem exitItem = new JMenuItem(\"Exit\");\n    ActionListener listener = new ExitItemListener();\n    exitItem.addActionListener(listener);\n    menu.add(exitItem);\n    return menu;\n}\n","name":"createFileMenu","className":"FontFrame2","variables":{"exitItem":2,"listener":1,"menu":3},"constants":{"\"File\"":1,"\"Exit\"":1},"javaDoc":"Creates the File menu the menu","comments":"\n      Creates the File menu.\n      @return the menu\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":3,"createStyleMenu":1,"createSizeMenu":1,"createFaceMenu":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JMenu":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":16,"MethodCallExpr":6},"statements":{"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Creates the Font submenu.\n      @return the menu\n   */\npublic JMenu createFontMenu() {\n    JMenu menu = new JMenu(\"Font\");\n    menu.add(createFaceMenu());\n    menu.add(createSizeMenu());\n    menu.add(createStyleMenu());\n    return menu;\n}\n","name":"createFontMenu","className":"FontFrame2","variables":{"menu":5},"constants":{"\"Font\"":1},"javaDoc":"Creates the Font submenu the menu","comments":"\n      Creates the Font submenu.\n      @return the menu\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":3,"createFaceItem":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"JMenu":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":4,"NameExpr":16,"MethodCallExpr":6},"statements":{"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Creates the Face submenu.\n      @return the menu\n   */\npublic JMenu createFaceMenu() {\n    JMenu menu = new JMenu(\"Face\");\n    menu.add(createFaceItem(\"Serif\"));\n    menu.add(createFaceItem(\"SansSerif\"));\n    menu.add(createFaceItem(\"Monospaced\"));\n    return menu;\n}\n","name":"createFaceMenu","className":"FontFrame2","variables":{"menu":5},"constants":{"\"SansSerif\"":1,"\"Monospaced\"":1,"\"Serif\"":1,"\"Face\"":1},"javaDoc":"Creates the Face submenu the menu","comments":"\n      Creates the Face submenu.\n      @return the menu\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":2,"createSizeItem":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"JMenu":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"StringLiteralExpr":3,"NameExpr":11,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Creates the Size submenu.\n      @return the menu\n   */\npublic JMenu createSizeMenu() {\n    JMenu menu = new JMenu(\"Size\");\n    menu.add(createSizeItem(\"Smaller\", -1));\n    menu.add(createSizeItem(\"Larger\", 1));\n    return menu;\n}\n","name":"createSizeMenu","className":"FontFrame2","variables":{"menu":4},"constants":{"1":2,"\"Larger\"":1,"\"Size\"":1,"\"Smaller\"":1},"javaDoc":"Creates the Size submenu the menu","comments":"\n      Creates the Size submenu.\n      @return the menu\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":4,"createStyleItem":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"JMenu":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":5,"NameExpr":36,"FieldAccessExpr":5,"MethodCallExpr":8},"statements":{"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Creates the Style submenu.\n      @return the menu\n   */\npublic JMenu createStyleMenu() {\n    JMenu menu = new JMenu(\"Style\");\n    menu.add(createStyleItem(\"Plain\", Font.PLAIN));\n    menu.add(createStyleItem(\"Bold\", Font.BOLD));\n    menu.add(createStyleItem(\"Italic\", Font.ITALIC));\n    menu.add(createStyleItem(\"Bold Italic\", Font.BOLD + Font.ITALIC));\n    return menu;\n}\n","name":"createStyleMenu","className":"FontFrame2","variables":{"menu":6},"constants":{"\"Bold\"":1,"\"Style\"":1,"\"Bold Italic\"":1,"\"Italic\"":1,"\"Plain\"":1},"javaDoc":"Creates the Style submenu the menu","comments":"\n      Creates the Style submenu.\n      @return the menu\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent event) {\n    facename = name;\n    setLabelFont();\n}\n","name":"actionPerformed","className":"FaceItemListener","variables":{"name":1,"facename":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"JMenuItem","methodCalls":{"setLabelFont":1,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"JMenuItem":1,"FaceItemListener":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":14,"AssignExpr":1,"MethodCallExpr":2},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Creates a menu item to change the font face and set its action listener.\n      @param name the name of the font face\n      @return the menu item\n   */\npublic JMenuItem createFaceItem(final String name) {\n    class FaceItemListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            facename = name;\n            setLabelFont();\n        }\n    }\n    JMenuItem item = new JMenuItem(name);\n    ActionListener listener = new FaceItemListener();\n    item.addActionListener(listener);\n    return item;\n}\n","name":"createFaceItem","className":"FontFrame2","variables":{"actionPerformed":1,"item":3,"name":2,"listener":1,"event":1,"FaceItemListener":1,"facename":1},"constants":{},"javaDoc":"Creates a menu item to change the font face and set its action listener name the name of the font face the menu item","comments":"\n      Creates a menu item to change the font face and set its action listener.\n      @param name the name of the font face\n      @return the menu item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":5,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent event) {\n    fontsize = fontsize + increment;\n    setLabelFont();\n}\n","name":"actionPerformed","className":"SizeItemListener","variables":{"fontsize":2,"increment":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"JMenuItem","methodCalls":{"setLabelFont":1,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"SizeItemListener":1,"ActionListener":1,"JMenuItem":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":15,"AssignExpr":1,"MethodCallExpr":2},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Creates a menu item to change the font size\n      and set its action listener.\n      @param name the name of the menu item\n      @param increment the amount by which to change the size\n      @return the menu item\n   */\npublic JMenuItem createSizeItem(String name, final int increment) {\n    class SizeItemListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            fontsize = fontsize + increment;\n            setLabelFont();\n        }\n    }\n    JMenuItem item = new JMenuItem(name);\n    ActionListener listener = new SizeItemListener();\n    item.addActionListener(listener);\n    return item;\n}\n","name":"createSizeItem","className":"FontFrame2","variables":{"actionPerformed":1,"SizeItemListener":1,"item":3,"name":1,"listener":1,"fontsize":2,"increment":1,"event":1},"constants":{},"javaDoc":"Creates a menu item to change the font size and set its action listener name the name of the menu item increment the amount by which to change the size the menu item","comments":"\n      Creates a menu item to change the font size\n      and set its action listener.\n      @param name the name of the menu item\n      @param increment the amount by which to change the size\n      @return the menu item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setLabelFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent event) {\n    fontstyle = style;\n    setLabelFont();\n}\n","name":"actionPerformed","className":"StyleItemListener","variables":{"fontstyle":1,"style":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"JMenuItem","methodCalls":{"setLabelFont":1,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"StyleItemListener":1,"JMenuItem":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":14,"AssignExpr":1,"MethodCallExpr":2},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Creates a menu item to change the font style\n      and set its action listener.\n      @param name the name of the menu item\n      @param style the new font style\n      @return the menu item\n   */\npublic JMenuItem createStyleItem(String name, final int style) {\n    class StyleItemListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            fontstyle = style;\n            setLabelFont();\n        }\n    }\n    JMenuItem item = new JMenuItem(name);\n    ActionListener listener = new StyleItemListener();\n    item.addActionListener(listener);\n    return item;\n}\n","name":"createStyleItem","className":"FontFrame2","variables":{"actionPerformed":1,"item":3,"fontstyle":1,"StyleItemListener":1,"name":1,"listener":1,"style":1,"event":1},"constants":{},"javaDoc":"Creates a menu item to change the font style and set its action listener name the name of the menu item style the new font style the menu item","comments":"\n      Creates a menu item to change the font style\n      and set its action listener.\n      @param name the name of the menu item\n      @param style the new font style\n      @return the menu item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Font":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Sets the font of the text sample.\n   */\npublic void setLabelFont() {\n    Font f = new Font(facename, fontstyle, fontsize);\n    label.setFont(f);\n}\n","name":"setLabelFont","className":"FontFrame2","variables":{"fontstyle":1,"f":1,"fontsize":1,"label":1,"facename":1},"constants":{},"javaDoc":"Sets the font of the text sample","comments":"\n      Sets the font of the text sample.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":2,"translate":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Rectangle":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":2,"CastExpr":1,"NameExpr":12,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"public void paintComponent(Graphics g) {\n    // Recover Graphics2D\n    Graphics2D g2 = (Graphics2D) g;\n    // Construct a rectangle and draw it\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    g2.draw(box);\n    // Move rectangle 15 units to the right and 25 units down\n    box.translate(15, 25);\n    // Draw moved rectangle\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent","variables":{"g":1,"box":2,"g2":3},"constants":{"25":1,"15":1,"5":1,"30":1,"20":1,"10":1},"javaDoc":"","comments":"Recover Graphics2D Construct a rectangle and draw it Move rectangle 15 units to the right and 25 units down Draw moved rectangle ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"RectangleComponent":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setTitle(\"Two rectangles\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    RectangleComponent component = new RectangleComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer","variables":{"component":1,"frame":6},"constants":{"300":1,"\"Two rectangles\"":1,"400":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":2,"translate":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Rectangle":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":2,"CastExpr":1,"NameExpr":12,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"public void paintComponent(Graphics g) {\n    // Recover Graphics2D\n    Graphics2D g2 = (Graphics2D) g;\n    // Construct a rectangle and draw it\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    g2.draw(box);\n    // Move rectangle 15 units to the right and 25 units down\n    box.translate(15, 25);\n    // Draw moved rectangle\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent","variables":{"g":1,"box":2,"g2":3},"constants":{"25":1,"15":1,"5":1,"30":1,"20":1,"10":1},"javaDoc":"","comments":"Recover Graphics2D Construct a rectangle and draw it Move rectangle 15 units to the right and 25 units down Draw moved rectangle ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":4,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":49,"StringLiteralExpr":4,"FieldAccessExpr":8,"MethodCallExpr":8,"AssignExpr":3},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    // Declares width and initializes it with 10\n    int width = 10;\n    System.out.print(\"width: \");\n    System.out.println(width);\n    // Changes width to 20\n    width = 20;\n    System.out.print(\"width: \");\n    System.out.println(width);\n    int height = 20;\n    // The right hand side can be an expression\n    width = height + 10;\n    System.out.print(\"width: \");\n    System.out.println(width);\n    // The same variable can occur on both sides\n    width = width + 10;\n    System.out.print(\"width: \");\n    System.out.println(width);\n}\n","name":"main","className":"VariableDemo","variables":{"width":5,"height":2},"constants":{"\"width: \"":4,"20":2,"10":3},"javaDoc":"","comments":"Declares width and initializes it with 10 Changes width to 20 The right hand side can be an expression The same variable can occur on both sides ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getWidth":1,"System.out.print":4,"translate":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"Rectangle":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":2,"NameExpr":50,"StringLiteralExpr":4,"FieldAccessExpr":8,"MethodCallExpr":10},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    System.out.print(\"box: \");\n    System.out.println(box);\n    // getWidth is an accessor method\n    double width = box.getWidth();\n    System.out.print(\"width: \");\n    System.out.println(width);\n    // Calling an accessor doesn't change the object\n    System.out.print(\"box: \");\n    System.out.println(box);\n    // translate is a mutator method\n    box.translate(15, 25);\n    // Calling a mutator changes the object.\n    System.out.print(\"box: \");\n    System.out.println(box);\n}\n","name":"main","className":"AccessorMutatorDemo","variables":{"width":1,"box":3},"constants":{"\"width: \"":1,"\"box: \"":3,"25":1,"15":1,"5":1,"30":1,"20":1,"10":1},"javaDoc":"","comments":"getWidth is an accessor method Calling an accessor doesn't change the object translate is a mutator method Calling a mutator changes the object ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":15,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setTitle(\"An empty frame\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"EmptyFrameViewer","variables":{"frame":5},"constants":{"300":1,"400":1,"true":1,"\"An empty frame\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":2,"replace":1,"System.out.print":3,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2,"int":1},"expressions":{"VariableDeclarationExpr":3,"StringLiteralExpr":7,"NameExpr":48,"FieldAccessExpr":7,"MethodCallExpr":10,"AssignExpr":1},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    String greeting = \"Hello, World!\";\n    System.out.println(greeting);\n    // greeting is the argument in this call to the println method\n    int numberOfCharacters = greeting.length();\n    // The length method returns a value\n    System.out.print(\"numberOfCharacters: \");\n    System.out.println(numberOfCharacters);\n    // You can use the return value of one method as an argument of another method\n    System.out.print(\"greeting.length(): \");\n    System.out.println(greeting.length());\n    // The replace method has two arguments\n    String river = \"Mississippi\";\n    river = river.replace(\"issipp\", \"our\");\n    System.out.print(\"river: \");\n    System.out.println(river);\n}\n","name":"main","className":"MethodDemo","variables":{"greeting":3,"numberOfCharacters":1,"river":3},"constants":{"\"numberOfCharacters: \"":1,"\"Mississippi\"":1,"\"river: \"":1,"\"issipp\"":1,"\"Hello, World!\"":1,"\"our\"":1,"\"greeting.length(): \"":1},"javaDoc":"","comments":"The length method returns a value You can use the return value of one method as an argument of another method greeting is the argument in this call to the println method The replace method has two arguments ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":3,"draw":2,"fill":2,"translate":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Line2D.Double":1,"Ellipse2D.Double":1,"Rectangle":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":16,"VariableDeclarationExpr":4,"CastExpr":1,"NameExpr":41,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":9},"statements":{"ExpressionStmt":13},"text":"public void paintComponent(Graphics g) {\n    // Recover Graphics2D \n    Graphics2D g2 = (Graphics2D) g;\n    // Draw the head\n    Ellipse2D.Double head = new Ellipse2D.Double(5, 10, 100, 150);\n    g2.draw(head);\n    // Draw the eyes\n    g2.setColor(Color.GREEN);\n    Rectangle eye = new Rectangle(25, 70, 15, 15);\n    g2.fill(eye);\n    eye.translate(50, 0);\n    g2.fill(eye);\n    // Draw the mouth\n    Line2D.Double mouth = new Line2D.Double(30, 110, 80, 110);\n    g2.setColor(Color.RED);\n    g2.draw(mouth);\n    // Draw the greeting\n    g2.setColor(Color.BLUE);\n    g2.drawString(\"Hello, World!\", 5, 175);\n}\n","name":"paintComponent","className":"FaceComponent","variables":{"head":1,"eye":2,"mouth":1,"g":1,"g2":9},"constants":{"25":1,"15":2,"\"Hello, World!\"":1,"150":1,"175":1,"0":1,"110":2,"100":1,"5":2,"80":1,"70":1,"50":1,"30":1,"10":1},"javaDoc":"","comments":"Recover Graphics2D Draw the head Draw the eyes Draw the mouth Draw the greeting ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"FaceComponent":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(150, 250);\n    frame.setTitle(\"An Alien Face\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    FaceComponent component = new FaceComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"FaceViewer","variables":{"component":1,"frame":6},"constants":{"\"An Alien Face\"":1,"true":1,"150":1,"250":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"daysFrom":1,"toString":1,"System.out.print":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Day":2,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"NameExpr":28,"StringLiteralExpr":2,"FieldAccessExpr":4,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Day jamesGoslingsBirthday = new Day(1955, 5, 19);\n    Day today = new Day();\n    System.out.print(\"Today: \");\n    System.out.println(today.toString());\n    int daysAlive = today.daysFrom(jamesGoslingsBirthday);\n    System.out.print(\"Days alive: \");\n    System.out.println(daysAlive);\n}\n","name":"main","className":"DaysAlivePrinter","variables":{"daysAlive":1,"jamesGoslingsBirthday":1,"today":3},"constants":{"5":1,"\"Days alive: \"":1,"19":1,"\"Today: \"":1,"1955":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Day","methodCalls":{"get":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"GregorianCalendar":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":21,"FieldAccessExpr":3,"AssignExpr":3,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a day object representing today's date.\n   */\npublic Day() {\n    GregorianCalendar today = new GregorianCalendar();\n    year = today.get(GregorianCalendar.YEAR);\n    month = today.get(GregorianCalendar.MONTH) + 1;\n    date = today.get(GregorianCalendar.DAY_OF_MONTH);\n}\n","name":"Day","className":"Day","variables":{"date":1,"month":1,"year":1,"today":4},"constants":{"1":1},"javaDoc":"Constructs a day object representing today's date","comments":"\n      Constructs a day object representing today's date.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"Day","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a day with a given year, month, and day\n      of the Julian/Gregorian calendar. The Julian calendar\n      is used for all days before October 15, 1582\n      @param aYear a year != 0\n      @param aMonth a month between 1 and 12\n      @param aDate a date between 1 and 31\n   */\npublic Day(int aYear, int aMonth, int aDate) {\n    year = aYear;\n    month = aMonth;\n    date = aDate;\n}\n","name":"Day","className":"Day","variables":{"date":1,"month":1,"year":1,"aMonth":1,"aDate":1,"aYear":1},"constants":{},"javaDoc":"Constructs a day with a given year month and day of the Julian/Gregorian calendar The Julian calendar is used for all days before October 15 1582 aYear a year != 0 aMonth a month between 1 and 12 aDate a date between 1 and 31","comments":"\n      Constructs a day with a given year, month, and day\n      of the Julian/Gregorian calendar. The Julian calendar\n      is used for all days before October 15, 1582\n      @param aYear a year != 0\n      @param aMonth a month between 1 and 12\n      @param aDate a date between 1 and 31\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the year of this day.\n      @return the year\n   */\npublic int getYear() {\n    return year;\n}\n","name":"getYear","className":"Day","variables":{"year":1},"constants":{},"javaDoc":"Returns the year of this day the year","comments":"\n      Returns the year of this day.\n      @return the year\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the month of this day.\n      @return the month\n   */\npublic int getMonth() {\n    return month;\n}\n","name":"getMonth","className":"Day","variables":{"month":1},"constants":{},"javaDoc":"Returns the month of this day the month","comments":"\n      Returns the month of this day.\n      @return the month\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns the day of the month of this day.\n      @return the day of the month\n   */\npublic int getDate() {\n    return date;\n}\n","name":"getDate","className":"Day","variables":{"date":1},"constants":{},"javaDoc":"Returns the day of the month of this day the day of the month","comments":"\n      Returns the day of the month of this day.\n      @return the day of the month\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Day","methodCalls":{"nextDay":1,"previousDay":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Day":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":13,"UnaryExpr":2,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":2},"statements":{"WhileStmt":2,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Returns a day that is a certain number of days away from\n      this day.\n      @param n the number of days, can be negative\n      @return a day that is n days away from this one\n   */\npublic Day addDays(int n) {\n    Day result = this;\n    while (n > 0) {\n        result = result.nextDay();\n        n--;\n    }\n    while (n < 0) {\n        result = result.previousDay();\n        n++;\n    }\n    return result;\n}\n","name":"addDays","className":"Day","variables":{"result":6,"n":4},"constants":{"0":2},"javaDoc":"Returns a day that is a certain number of days away from this day n the number of days can be negative a day that is n days away from this one","comments":"\n      Returns a day that is a certain number of days away from\n      this day.\n      @param n the number of days, can be negative\n      @return a day that is n days away from this one\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Day"],"returnType":"int","methodCalls":{"compareTo":2,"previousDay":1,"nextDay":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Day":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":19,"UnaryExpr":2,"ThisExpr":1,"MethodCallExpr":4,"AssignExpr":2},"statements":{"WhileStmt":2,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n      Returns the number of days between this day and another\n      day.\n      @param other the other day\n      @return the number of days that this day is away from \n      the other (larger than 0 if this day comes later than <code>other</code>)\n   */\npublic int daysFrom(Day other) {\n    int n = 0;\n    Day d = this;\n    while (d.compareTo(other) > 0) {\n        d = d.previousDay();\n        n++;\n    }\n    while (d.compareTo(other) < 0) {\n        d = d.nextDay();\n        n--;\n    }\n    return n;\n}\n","name":"daysFrom","className":"Day","variables":{"d":7,"n":4},"constants":{"0":3},"javaDoc":"Returns the number of days between this day and another day other the other day the number of days that this day is away from the other (larger than 0 if this day comes later than <code>other</code>)","comments":"\n      Returns the number of days between this day and another\n      day.\n      @param other the other day\n      @return the number of days that this day is away from \n      the other (larger than 0 if this day comes later than <code>other</code>)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return String.format(\"%04d-%02d-%02d\", year, month, date);\n}\n","name":"toString","className":"Day","variables":{"String":1},"constants":{"\"%04d-%02d-%02d\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Day"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"BinaryExpr":5,"NameExpr":20,"FieldAccessExpr":5,"UnaryExpr":2},"statements":{"IfStmt":4,"ReturnStmt":5},"text":"/**\n      Compares this day with another day.\n      @param other the other day\n      @return a positive number if this day comes after the\n      other day, a negative number if this day comes before\n      the other day, and zero if the days are the same\n   */\nprivate int compareTo(Day other) {\n    if (year > other.year)\n        return 1;\n    if (year < other.year)\n        return -1;\n    if (month > other.month)\n        return 1;\n    if (month < other.month)\n        return -1;\n    return date - other.date;\n}\n","name":"compareTo","className":"Day","variables":{"date":1,"month":2,"year":2},"constants":{"1":4},"javaDoc":"Compares this day with another day other the other day a positive number if this day comes after the other day a negative number if this day comes before the other day and zero if the days are the same","comments":"\n      Compares this day with another day.\n      @param other the other day\n      @return a positive number if this day comes after the\n      other day, a negative number if this day comes before\n      the other day, and zero if the days are the same\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"Day","methodCalls":{"daysPerMonth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":8,"NameExpr":29,"UnaryExpr":4,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":4,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":10},"text":"/**\n      Computes the next day.\n      @return the day following this day\n   */\nprivate Day nextDay() {\n    int y = year;\n    int m = month;\n    int d = date;\n    if (y == GREGORIAN_START_YEAR && m == GREGORIAN_START_MONTH && d == JULIAN_END_DAY)\n        d = GREGORIAN_START_DAY;\n    else if (d < daysPerMonth(y, m))\n        d++;\n    else {\n        d = 1;\n        m++;\n        if (m > DECEMBER) {\n            m = JANUARY;\n            y++;\n            if (y == 0)\n                y++;\n        }\n    }\n    return new Day(y, m, d);\n}\n","name":"nextDay","className":"Day","variables":{"date":1,"JANUARY":1,"month":1,"d":7,"year":1,"GREGORIAN_START_MONTH":1,"GREGORIAN_START_DAY":1,"DECEMBER":1,"y":6,"m":6,"JULIAN_END_DAY":1,"GREGORIAN_START_YEAR":1},"constants":{"0":1,"1":1},"javaDoc":"Computes the next day the day following this day","comments":"\n      Computes the next day.\n      @return the day following this day\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"Day","methodCalls":{"daysPerMonth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":8,"NameExpr":29,"UnaryExpr":4,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":4,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":10},"text":"/**\n      Computes the previous day.\n      @return the day preceding this day\n   */\nprivate Day previousDay() {\n    int y = year;\n    int m = month;\n    int d = date;\n    if (y == GREGORIAN_START_YEAR && m == GREGORIAN_START_MONTH && d == GREGORIAN_START_DAY)\n        d = JULIAN_END_DAY;\n    else if (d > 1)\n        d--;\n    else {\n        m--;\n        if (m < JANUARY) {\n            m = DECEMBER;\n            y--;\n            if (y == 0)\n                y--;\n        }\n        d = daysPerMonth(y, m);\n    }\n    return new Day(y, m, d);\n}\n","name":"previousDay","className":"Day","variables":{"date":1,"JANUARY":1,"month":1,"d":7,"year":1,"GREGORIAN_START_MONTH":1,"GREGORIAN_START_DAY":1,"DECEMBER":1,"y":6,"m":6,"JULIAN_END_DAY":1,"GREGORIAN_START_YEAR":1},"constants":{"0":1,"1":1},"javaDoc":"Computes the previous day the day preceding this day","comments":"\n      Computes the previous day.\n      @return the day preceding this day\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"isLeapYear":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":9,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Gets the days in a given month.\n      @param y the year\n      @param m the month\n      @return the last day in the given month\n   */\nprivate static int daysPerMonth(int y, int m) {\n    int days = DAYS_PER_MONTH[m - 1];\n    if (m == FEBRUARY && isLeapYear(y))\n        days++;\n    return days;\n}\n","name":"daysPerMonth","className":"Day","variables":{"days":3,"FEBRUARY":1,"m":2,"DAYS_PER_MONTH":1},"constants":{"1":1},"javaDoc":"Gets the days in a given month y the year m the month the last day in the given month","comments":"\n      Gets the days in a given month.\n      @param y the year\n      @param m the month\n      @return the last day in the given month\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":6,"BinaryExpr":8,"BooleanLiteralExpr":2,"NameExpr":5,"EnclosedExpr":2},"statements":{"IfStmt":2,"ReturnStmt":3},"text":"/**\n      Tests if a year is a leap year.\n      @param y the year\n      @return true if y is a leap year\n   */\nprivate static boolean isLeapYear(int y) {\n    if (y % 4 != 0)\n        return false;\n    if (y < GREGORIAN_START_YEAR)\n        return true;\n    return (y % 100 != 0) || (y % 400 == 0);\n}\n","name":"isLeapYear","className":"Day","variables":{"y":4,"GREGORIAN_START_YEAR":1},"constants":{"0":3,"100":1,"4":1,"400":1,"false":1,"true":1},"javaDoc":"Tests if a year is a leap year y the year true if y is a leap year","comments":"\n      Tests if a year is a leap year.\n      @param y the year\n      @return true if y is a leap year\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"daysFrom":1,"getYear":1,"addDays":1,"getDate":1,"getMonth":1,"System.out.println":8},"annotations":[],"exceptions":[],"concepts":[],"types":{"Day":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"NameExpr":56,"StringLiteralExpr":4,"FieldAccessExpr":8,"MethodCallExpr":13},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    // February 15, 2010\n    Day today = new Day(2010, 2, 15);\n    Day later = today.addDays(30);\n    System.out.println(later.getYear());\n    System.out.println(\"Expected: 2010\");\n    System.out.println(later.getMonth());\n    System.out.println(\"Expected: 3\");\n    System.out.println(later.getDate());\n    System.out.println(\"Expected: 13\");\n    System.out.println(later.daysFrom(today));\n    System.out.println(\"Expected: 30\");\n}\n","name":"main","className":"DayTester","variables":{"later":5,"today":2},"constants":{"2":1,"15":1,"\"Expected: 3\"":1,"\"Expected: 2010\"":1,"\"Expected: 30\"":1,"2010":1,"\"Expected: 13\"":1,"30":1},"javaDoc":"","comments":"February 15 2010 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"load":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Picture":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Picture pic = new Picture();\n    pic.load(\"queen-mary.png\");\n}\n","name":"main","className":"PictureDemo","variables":{"pic":2},"constants":{"\"queen-mary.png\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"border":1,"getHeight":1,"move":1,"load":1,"scale":1,"getWidth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Picture":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":20,"StringLiteralExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Picture pic = new Picture();\n    pic.load(\"queen-mary.png\");\n    int newWidth = pic.getWidth() - 40;\n    int newHeight = pic.getHeight() - 40;\n    pic.scale(newWidth, newHeight);\n    pic.move(20, 20);\n    pic.border(10);\n}\n","name":"main","className":"BorderMaker","variables":{"newWidth":1,"newHeight":1,"pic":7},"constants":{"\"queen-mary.png\"":1,"40":2,"20":2,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Picture","methodCalls":{"add":1,"setVisible":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"BooleanLiteralExpr":1,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"/**\n      Constructs a blank picture.\n   */\npublic Picture() {\n    frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    label = new JLabel(\"(No image)\");\n    frame.add(label);\n    frame.pack();\n    frame.setVisible(true);\n}\n","name":"Picture","className":"Picture","variables":{"label":1,"frame":5},"constants":{"\"(No image)\"":1,"true":1},"javaDoc":"Constructs a blank picture","comments":"\n      Constructs a blank picture.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getWidth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the width of this picture.\n      @return the width\n    */\npublic int getWidth() {\n    return image.getWidth();\n}\n","name":"getWidth","className":"Picture","variables":{"image":1},"constants":{},"javaDoc":"Gets the width of this picture the width","comments":"\n      Gets the width of this picture.\n      @return the width\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getHeight":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the height of this picture.\n      @return the height\n    */\npublic int getHeight() {\n    return image.getHeight();\n}\n","name":"getHeight","className":"Picture","variables":{"image":1},"constants":{},"javaDoc":"Gets the height of this picture the height","comments":"\n      Gets the height of this picture.\n      @return the height\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"read":2,"printStackTrace":1,"startsWith":1,"setImage":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedImage":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":26,"StringLiteralExpr":1,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":4,"MethodCallExpr":6},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n    */\npublic void load(String source) {\n    try {\n        this.source = source;\n        BufferedImage img;\n        if (source.startsWith(\"http://\"))\n            img = ImageIO.read(new URL(source).openStream());\n        else\n            img = ImageIO.read(new File(source));\n        setImage(img);\n    } catch (Exception ex) {\n        this.source = null;\n        ex.printStackTrace();\n    }\n}\n","name":"load","className":"Picture","variables":{"img":3,"ex":2,"source":4,"ImageIO":2},"constants":{"null":1,"\"http://\"":1},"javaDoc":"Loads a picture from a given source source the image source If the source starts with http:// it is a URL otherwise a filename","comments":"\n      Loads a picture from a given source. \n      @param source the image source. If the source starts\n      with http://, it is a URL, otherwise, a filename.\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"load":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Reloads this picture, undoing any manipulations.\n    */\npublic void reload() {\n    load(source);\n}\n","name":"reload","className":"Picture","variables":{},"constants":{},"javaDoc":"Reloads this picture undoing any manipulations","comments":"\n      Reloads this picture, undoing any manipulations.\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showOpenDialog":1,"load":1,"getSelectedFile":1,"getAbsolutePath":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":13,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n      Displays a file chooser for picking a picture.\n    */\npublic void pick() {\n    JFileChooser chooser = new JFileChooser(\".\");\n    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n        load(chooser.getSelectedFile().getAbsolutePath());\n    }\n}\n","name":"pick","className":"Picture","variables":{"chooser":3},"constants":{"null":1,"\".\"":1},"javaDoc":"Displays a file chooser for picking a picture","comments":"\n      Displays a file chooser for picking a picture.\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"filter":1,"getTranslateInstance":1,"getHeight":1,"getWidth":1,"setImage":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"BufferedImageOp":1,"BufferedImage":1,"AffineTransformOp":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":4},"text":"/**\n      Moves this picture by the given amount in x- and y-direction. \n      @param dx the offset in the x-direction\n      @param dy the offset in the y-direction\n    */\npublic void move(int dx, int dy) {\n    BufferedImageOp op = new AffineTransformOp(AffineTransform.getTranslateInstance(dx, dy), AffineTransformOp.TYPE_BILINEAR);\n    BufferedImage filteredImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);\n    op.filter(image, filteredImage);\n    setImage(filteredImage);\n}\n","name":"move","className":"Picture","variables":{"op":2,"image":2,"AffineTransform":1,"filteredImage":1},"constants":{},"javaDoc":"Moves this picture by the given amount in x- and y-direction dx the offset in the x-direction dy the offset in the y-direction","comments":"\n      Moves this picture by the given amount in x- and y-direction. \n      @param dx the offset in the x-direction\n      @param dy the offset in the y-direction\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"filter":1,"getHeight":2,"getWidth":2,"getScaleInstance":1,"setImage":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"BufferedImageOp":1,"double":2,"BufferedImage":1,"AffineTransformOp":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"DoubleLiteralExpr":2,"BinaryExpr":4,"NameExpr":33,"FieldAccessExpr":2,"MethodCallExpr":7},"statements":{"ExpressionStmt":6},"text":"/**\n      Scales this picture to a new size. If the new size is smaller \n      than the old size, the remainder is filled with transparent \n      pixels. If it is larger, it is clipped.\n      @param newWidth the new width of the picture\n      @param newHeight the new height of the picture\n   */\npublic void scale(int newWidth, int newHeight) {\n    double dx = newWidth * 1.0 / image.getWidth();\n    double dy = newHeight * 1.0 / image.getHeight();\n    BufferedImageOp op = new AffineTransformOp(AffineTransform.getScaleInstance(dx, dy), AffineTransformOp.TYPE_BILINEAR);\n    BufferedImage filteredImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);\n    op.filter(image, filteredImage);\n    setImage(filteredImage);\n}\n","name":"scale","className":"Picture","variables":{"image":4,"op":2,"dx":1,"newWidth":1,"dy":1,"newHeight":1,"AffineTransform":1,"filteredImage":1},"constants":{"1.0":2},"javaDoc":"Scales this picture to a new size If the new size is smaller than the old size the remainder is filled with transparent pixels If it is larger it is clipped newWidth the new width of the picture newHeight the new height of the picture","comments":"\n      Scales this picture to a new size. If the new size is smaller \n      than the old size, the remainder is filled with transparent \n      pixels. If it is larger, it is clipped.\n      @param newWidth the new width of the picture\n      @param newHeight the new height of the picture\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getHeight":2,"setColorAt":4,"getWidth":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":4},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":4,"BinaryExpr":9,"NameExpr":52,"FieldAccessExpr":4,"UnaryExpr":4,"MethodCallExpr":8},"statements":{"BlockStmt":4,"ForStmt":4,"ExpressionStmt":4},"text":"/**\n      Adds a black border to the image.\n      @param width the border width\n   */\npublic void border(int width) {\n    for (int x = 0; x < width; x++) {\n        for (int y = 0; y < image.getHeight(); y++) {\n            setColorAt(x, y, Color.BLACK);\n            setColorAt(image.getWidth() - 1 - x, y, Color.BLACK);\n        }\n    }\n    for (int y = 0; y < width; y++) {\n        for (int x = width; x < image.getWidth() - width; x++) {\n            setColorAt(x, y, Color.BLACK);\n            setColorAt(x, image.getHeight() - 1 - y, Color.BLACK);\n        }\n    }\n}\n","name":"border","className":"Picture","variables":{"image":4,"x":7,"width":4,"y":7},"constants":{"0":3,"1":2},"javaDoc":"Adds a black border to the image width the border width","comments":"\n      Adds a black border to the image.\n      @param width the border width\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Color","methodCalls":{"getColorModel":1,"getDataElements":1,"getRaster":1,"getRGB":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ColorModel":1,"Raster":1,"int":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"NameExpr":15,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   */\npublic Color getColorAt(int x, int y) {\n    Raster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    int argb = model.getRGB(raster.getDataElements(x, y, null));\n    return new Color(argb, true);\n}\n","name":"getColorAt","className":"Picture","variables":{"image":2,"argb":2,"raster":2,"model":2},"constants":{"null":1,"true":1},"javaDoc":"Gets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) the color of the pixel at position (x y)","comments":"\n      Gets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @return the color of the pixel at position (x, y)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","Color"],"returnType":"void","methodCalls":{"getColorModel":1,"getDataElements":1,"setDataElements":1,"repaint":1,"getRaster":1,"getRGB":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"WritableRaster":1,"ColorModel":1,"Object":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":21,"MethodCallExpr":6},"statements":{"ExpressionStmt":5},"text":"/**\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   */\npublic void setColorAt(int x, int y, Color c) {\n    WritableRaster raster = image.getRaster();\n    ColorModel model = image.getColorModel();\n    Object colorData = model.getDataElements(c.getRGB(), null);\n    raster.setDataElements(x, y, colorData);\n    label.repaint();\n}\n","name":"setColorAt","className":"Picture","variables":{"image":2,"c":1,"colorData":1,"raster":2,"model":2,"label":1},"constants":{"null":1},"javaDoc":"Sets the color of a pixel x the column index (between 0 and getWidth() - 1) y the row index (between 0 and getHeight() - 1) c the color for the pixel at position (x y)","comments":"\n      Sets the color of a pixel.\n      @param x the column index (between 0 and getWidth() - 1)\n      @param y the row index (between 0 and getHeight() - 1)\n      @param c the color for the pixel at position (x, y)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BufferedImage"],"returnType":"void","methodCalls":{"setIcon":1,"getHeight":1,"setSize":1,"getWidth":1,"pack":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":22,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":5},"text":"private void setImage(BufferedImage image) {\n    this.image = image;\n    label.setIcon(new ImageIcon(image));\n    label.setText(\"\");\n    label.setSize(image.getWidth(), image.getHeight());\n    frame.pack();\n}\n","name":"setImage","className":"Picture","variables":{"image":4,"label":3,"frame":1},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"translate":1,"System.out.print":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"NameExpr":39,"StringLiteralExpr":4,"FieldAccessExpr":6,"MethodCallExpr":9},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    // Move the rectangle\n    box.translate(15, 25);\n    // Print information about the moved rectangle \n    System.out.print(\"x: \");\n    System.out.println(box.getX());\n    System.out.println(\"Expected: 20\");\n    System.out.print(\"y: \");\n    System.out.println(box.getY());\n    System.out.println(\"Expected: 35\");\n}\n","name":"main","className":"MoveTester","variables":{"box":4},"constants":{"\"x: \"":1,"25":1,"\"y: \"":1,"15":1,"5":1,"\"Expected: 20\"":1,"\"Expected: 35\"":1,"30":1,"20":1,"10":1},"javaDoc":"","comments":"Move the rectangle Print information about the moved rectangle ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":8,"translate":1,"System.out.println":10},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":2,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":8,"VariableDeclarationExpr":4,"NameExpr":104,"StringLiteralExpr":10,"FieldAccessExpr":18,"MethodCallExpr":19,"AssignExpr":1},"statements":{"ExpressionStmt":24},"text":"public static void main(String[] args) {\n    // Declare two object variables and copy the first into the second\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    Rectangle box2 = box;\n    // Both variables refer to the same object\n    System.out.print(\"box: \");\n    System.out.println(box);\n    System.out.print(\"box2: \");\n    System.out.println(box2);\n    System.out.println(\"Mutating box2\");\n    box2.translate(15, 25);\n    // Both variables refer to the mutated object\n    System.out.print(\"box: \");\n    System.out.println(box);\n    System.out.print(\"box2: \");\n    System.out.println(box2);\n    // Declare two number variables and copy the first into the second\n    int luckyNumber = 13;\n    int luckyNumber2 = luckyNumber;\n    System.out.print(\"luckyNumber: \");\n    System.out.println(luckyNumber);\n    System.out.print(\"luckyNumber2: \");\n    System.out.println(luckyNumber2);\n    System.out.println(\"Changing luckyNumber2\");\n    luckyNumber2 = 12;\n    // Only the second number changes.\n    System.out.print(\"luckyNumber: \");\n    System.out.println(luckyNumber);\n    System.out.print(\"luckyNumber2: \");\n    System.out.println(luckyNumber2);\n}\n","name":"main","className":"CopyDemo","variables":{"luckyNumber2":2,"luckyNumber":2,"box2":2,"box":2},"constants":{"12":1,"13":1,"25":1,"15":1,"\"luckyNumber2: \"":2,"\"luckyNumber: \"":2,"\"box: \"":2,"\"Mutating box2\"":1,"\"box2: \"":2,"5":1,"\"Changing luckyNumber2\"":1,"30":1,"20":1,"10":1},"javaDoc":"","comments":"Declare two object variables and copy the first into the second Both variables refer to the same object Both variables refer to the mutated object Declare two number variables and copy the first into the second Only the second number changes ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":2,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":8,"VariableDeclarationExpr":1,"NameExpr":28,"StringLiteralExpr":2,"FieldAccessExpr":5,"MethodCallExpr":5,"AssignExpr":1},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    // Constructs and prints a rectangle\n    System.out.println(new Rectangle(5, 10, 20, 30));\n    // Constructs a rectangle and saves it in a variable\n    Rectangle box = new Rectangle(5, 10, 20, 30);\n    System.out.print(\"box: \");\n    System.out.println(box);\n    // The constructor with no arguments\n    box = new Rectangle();\n    System.out.print(\"box: \");\n    System.out.println(box);\n}\n","name":"main","className":"ConstructorDemo","variables":{"box":2},"constants":{"\"box: \"":2,"5":2,"30":2,"20":2,"10":2},"javaDoc":"","comments":"Constructs and prints a rectangle Constructs a rectangle and saves it in a variable The constructor with no arguments ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":1,"parse":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"ArrayList<LineItem>":1,"LineItem":1,"ItemListParser":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) throws Exception {\n    ItemListParser parser = new ItemListParser();\n    ArrayList<LineItem> items = parser.parse(\"items.xml\");\n    for (LineItem anItem : items) {\n        System.out.println(anItem.format());\n    }\n}\n","name":"main","className":"ItemListParserDemo","variables":{"parser":2,"anItem":2,"items":2},"constants":{"\"items.xml\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Product","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   */\npublic Product(String aDescription, double aPrice) {\n    description = aDescription;\n    price = aPrice;\n}\n","name":"Product","className":"Product","variables":{"aDescription":1,"price":1,"description":1,"aPrice":1},"constants":{},"javaDoc":"Constructs a product from a description and a price aDescription the product description aPrice the product price","comments":"\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product description.\n      @return the description\n   */\npublic String getDescription() {\n    return description;\n}\n","name":"getDescription","className":"Product","variables":{"description":1},"constants":{},"javaDoc":"Gets the product description the description","comments":"\n      Gets the product description.\n      @return the description\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product price.\n      @return the unit price\n   */\npublic double getPrice() {\n    return price;\n}\n","name":"getPrice","className":"Product","variables":{"price":1},"constants":{},"javaDoc":"Gets the product price the unit price","comments":"\n      Gets the product price.\n      @return the unit price\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ItemListParser","methodCalls":{"newDocumentBuilder":1,"newXPath":1,"newInstance":2},"annotations":[],"exceptions":["ParserConfigurationException"],"concepts":[],"types":{"XPathFactory":1,"DocumentBuilderFactory":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":14,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a parser that can parse item lists.\n   */\npublic ItemListParser() throws ParserConfigurationException {\n    DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();\n    builder = dbfactory.newDocumentBuilder();\n    XPathFactory xpfactory = XPathFactory.newInstance();\n    path = xpfactory.newXPath();\n}\n","name":"ItemListParser","className":"ItemListParser","variables":{"xpfactory":2,"XPathFactory":1,"path":1,"DocumentBuilderFactory":1,"dbfactory":2,"builder":1},"constants":{},"javaDoc":"Constructs a parser that can parse item lists","comments":"\n      Constructs a parser that can parse item lists.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"ArrayList<LineItem>","methodCalls":{"parseInt":2,"parseDouble":1,"add":1,"parse":1,"evaluate":4},"annotations":[],"exceptions":["XPathExpressionException","IOException","SAXException"],"concepts":["PolyMorphism"],"types":{"ArrayList<LineItem>":1,"double":1,"ArrayList":1,"Product":1,"LineItem":1,"String":1,"Document":1,"File":1,"int":3},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":10,"BinaryExpr":7,"NameExpr":45,"StringLiteralExpr":7,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"/**\n      Parses an XML file containing an item list.\n      @param fileName the name of the file\n      @return an array list containing all items in the XML file\n   */\npublic ArrayList<LineItem> parse(String fileName) throws SAXException, IOException, XPathExpressionException {\n    File f = new File(fileName);\n    Document doc = builder.parse(f);\n    ArrayList<LineItem> items = new ArrayList<>();\n    int itemCount = Integer.parseInt(path.evaluate(\"count(/items/item)\", doc));\n    for (int i = 1; i <= itemCount; i++) {\n        String description = path.evaluate(\"/items/item[\" + i + \"]/product/description\", doc);\n        double price = Double.parseDouble(path.evaluate(\"/items/item[\" + i + \"]/product/price\", doc));\n        Product pr = new Product(description, price);\n        int quantity = Integer.parseInt(path.evaluate(\"/items/item[\" + i + \"]/quantity\", doc));\n        LineItem it = new LineItem(pr, quantity);\n        items.add(it);\n    }\n    return items;\n}\n","name":"parse","className":"ItemListParser","variables":{"fileName":1,"pr":2,"quantity":2,"f":1,"i":6,"description":2,"it":1,"Double":1,"itemCount":2,"Integer":2,"path":4,"price":2,"builder":1,"doc":1,"items":3},"constants":{"1":1,"\"]/product/price\"":1,"\"count(/items/item)\"":1,"\"]/product/description\"":1,"\"/items/item[\"":3,"\"]/quantity\"":1},"javaDoc":"Parses an XML file containing an item list fileName the name of the file an array list containing all items in the XML file","comments":"\n      Parses an XML file containing an item list.\n      @param fileName the name of the file\n      @return an array list containing all items in the XML file\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Product","int"],"returnType":"LineItem","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   */\npublic LineItem(Product aProduct, int aQuantity) {\n    theProduct = aProduct;\n    quantity = aQuantity;\n}\n","name":"LineItem","className":"LineItem","variables":{"quantity":1,"aProduct":1,"aQuantity":1,"theProduct":1},"constants":{},"javaDoc":"Constructs an item from the product and quantity aProduct the product aQuantity the item quantity","comments":"\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes the total cost of this line item.\n      @return the total price\n   */\npublic double getTotalPrice() {\n    return theProduct.getPrice() * quantity;\n}\n","name":"getTotalPrice","className":"LineItem","variables":{"quantity":1,"theProduct":1},"constants":{},"javaDoc":"Computes the total cost of this line item the total price","comments":"\n      Computes the total cost of this line item.\n      @return the total price\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1,"getTotalPrice":1,"getDescription":1,"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n      Formats this item.\n      @return a formatted string of this item\n   */\npublic String format() {\n    return String.format(\"%-30s%8.2f%5d%8.2f\", theProduct.getDescription(), theProduct.getPrice(), quantity, getTotalPrice());\n}\n","name":"format","className":"LineItem","variables":{"String":1,"theProduct":2},"constants":{"\"%-30s%8.2f%5d%8.2f\"":1},"javaDoc":"Formats this item a formatted string of this item","comments":"\n      Formats this item.\n      @return a formatted string of this item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","double"],"returnType":"Product","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   */\npublic Product(String aDescription, double aPrice) {\n    description = aDescription;\n    price = aPrice;\n}\n","name":"Product","className":"Product","variables":{"aDescription":1,"price":1,"description":1,"aPrice":1},"constants":{},"javaDoc":"Constructs a product from a description and a price aDescription the product description aPrice the product price","comments":"\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product description.\n      @return the description\n   */\npublic String getDescription() {\n    return description;\n}\n","name":"getDescription","className":"Product","variables":{"description":1},"constants":{},"javaDoc":"Gets the product description the description","comments":"\n      Gets the product description.\n      @return the description\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product price.\n      @return the unit price\n   */\npublic double getPrice() {\n    return price;\n}\n","name":"getPrice","className":"Product","variables":{"price":1},"constants":{},"javaDoc":"Gets the product price the unit price","comments":"\n      Gets the product price.\n      @return the unit price\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"writeToString":1,"build":1,"getImplementation":1,"createLSSerializer":1,"getFeature":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","PolyMorphism"],"types":{"ArrayList<LineItem>":1,"ItemListBuilder":1,"DOMImplementationLS":1,"ArrayList":1,"DOMImplementation":1,"LSSerializer":1,"String":1,"Document":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"DoubleLiteralExpr":2,"NameExpr":29,"StringLiteralExpr":4,"CastExpr":1,"FieldAccessExpr":1,"MethodCallExpr":8},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) throws Exception {\n    ArrayList<LineItem> items = new ArrayList<>();\n    items.add(new LineItem(new Product(\"Toaster\", 29.95), 3));\n    items.add(new LineItem(new Product(\"Hair dryer\", 24.95), 1));\n    ItemListBuilder builder = new ItemListBuilder();\n    Document doc = builder.build(items);\n    DOMImplementation impl = doc.getImplementation();\n    DOMImplementationLS implLS = (DOMImplementationLS) impl.getFeature(\"LS\", \"3.0\");\n    LSSerializer ser = implLS.createLSSerializer();\n    String out = ser.writeToString(doc);\n    System.out.println(out);\n}\n","name":"main","className":"ItemListBuilderDemo","variables":{"impl":2,"ser":2,"implLS":2,"builder":2,"doc":2,"items":3,"out":1},"constants":{"24.95":1,"1":1,"3":1,"\"Hair dryer\"":1,"29.95":1,"\"3.0\"":1,"\"LS\"":1,"\"Toaster\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Product","int"],"returnType":"LineItem","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   */\npublic LineItem(Product aProduct, int aQuantity) {\n    theProduct = aProduct;\n    quantity = aQuantity;\n}\n","name":"LineItem","className":"LineItem","variables":{"quantity":1,"aProduct":1,"aQuantity":1,"theProduct":1},"constants":{},"javaDoc":"Constructs an item from the product and quantity aProduct the product aQuantity the item quantity","comments":"\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes the total cost of this line item.\n      @return the total price\n   */\npublic double getTotalPrice() {\n    return theProduct.getPrice() * quantity;\n}\n","name":"getTotalPrice","className":"LineItem","variables":{"quantity":1,"theProduct":1},"constants":{},"javaDoc":"Computes the total cost of this line item the total price","comments":"\n      Computes the total cost of this line item.\n      @return the total price\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Product","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product that this item describes.\n      @return the product\n   */\npublic Product getProduct() {\n    return theProduct;\n}\n","name":"getProduct","className":"LineItem","variables":{"theProduct":1},"constants":{},"javaDoc":"Gets the product that this item describes the product","comments":"\n      Gets the product that this item describes.\n      @return the product\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the quantity of the product that this item describes.\n      @return the quantity\n   */\npublic int getQuantity() {\n    return quantity;\n}\n","name":"getQuantity","className":"LineItem","variables":{"quantity":1},"constants":{},"javaDoc":"Gets the quantity of the product that this item describes the quantity","comments":"\n      Gets the quantity of the product that this item describes.\n      @return the quantity\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1,"getTotalPrice":1,"getDescription":1,"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n      Formats this item.\n      @return a formatted string of this item\n   */\npublic String format() {\n    return String.format(\"%-30s%8.2f%5d%8.2f\", theProduct.getDescription(), theProduct.getPrice(), quantity, getTotalPrice());\n}\n","name":"format","className":"LineItem","variables":{"String":1,"theProduct":2},"constants":{"\"%-30s%8.2f%5d%8.2f\"":1},"javaDoc":"Formats this item a formatted string of this item","comments":"\n      Formats this item.\n      @return a formatted string of this item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ItemListBuilder","methodCalls":{"newDocumentBuilder":1,"newInstance":1},"annotations":[],"exceptions":["ParserConfigurationException"],"concepts":[],"types":{"DocumentBuilderFactory":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":7,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an item list builder.\n   */\npublic ItemListBuilder() throws ParserConfigurationException {\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    builder = factory.newDocumentBuilder();\n}\n","name":"ItemListBuilder","className":"ItemListBuilder","variables":{"factory":2,"DocumentBuilderFactory":1,"builder":1},"constants":{},"javaDoc":"Constructs an item list builder","comments":"\n      Constructs an item list builder.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ArrayList<LineItem>"],"returnType":"Document","methodCalls":{"appendChild":1,"createItems":1,"newDocument":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":11,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Builds a DOM document for an array list of items.\n      @param items the items\n      @return a DOM document describing the items\n   */\npublic Document build(ArrayList<LineItem> items) {\n    doc = builder.newDocument();\n    doc.appendChild(createItems(items));\n    return doc;\n}\n","name":"build","className":"ItemListBuilder","variables":{"builder":1,"doc":3},"constants":{},"javaDoc":"Builds a DOM document for an array list of items items the items a DOM document describing the items","comments":"\n      Builds a DOM document for an array list of items.\n      @param items the items\n      @return a DOM document describing the items\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ArrayList<LineItem>"],"returnType":"Element","methodCalls":{"appendChild":1,"createItem":1,"createElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Element":1,"LineItem":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Builds a DOM element for an array list of items.\n      @param items the items\n      @return a DOM element describing the items\n   */\nprivate Element createItems(ArrayList<LineItem> items) {\n    Element e = doc.createElement(\"items\");\n    for (LineItem anItem : items) {\n        e.appendChild(createItem(anItem));\n    }\n    return e;\n}\n","name":"createItems","className":"ItemListBuilder","variables":{"e":3,"anItem":1,"doc":1,"items":1},"constants":{"\"items\"":1},"javaDoc":"Builds a DOM element for an array list of items items the items a DOM element describing the items","comments":"\n      Builds a DOM element for an array list of items.\n      @param items the items\n      @return a DOM element describing the items\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["LineItem"],"returnType":"Element","methodCalls":{"appendChild":2,"getProduct":1,"createTextElement":1,"getQuantity":1,"createProduct":1,"createElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Element":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":3,"MethodCallExpr":7},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Builds a DOM element for an item.\n      @param anItem the item\n      @return a DOM element describing the item\n   */\nprivate Element createItem(LineItem anItem) {\n    Element e = doc.createElement(\"item\");\n    e.appendChild(createProduct(anItem.getProduct()));\n    e.appendChild(createTextElement(\"quantity\", \"\" + anItem.getQuantity()));\n    return e;\n}\n","name":"createItem","className":"ItemListBuilder","variables":{"e":4,"anItem":2,"doc":1},"constants":{"\"quantity\"":1,"\"\"":1,"\"item\"":1},"javaDoc":"Builds a DOM element for an item anItem the item a DOM element describing the item","comments":"\n      Builds a DOM element for an item.\n      @param anItem the item\n      @return a DOM element describing the item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Product"],"returnType":"Element","methodCalls":{"appendChild":2,"createTextElement":2,"createElement":1,"getDescription":1,"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Element":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":4,"MethodCallExpr":7},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Builds a DOM element for a product.\n      @param p the product\n      @return a DOM element describing the product\n   */\nprivate Element createProduct(Product p) {\n    Element e = doc.createElement(\"product\");\n    e.appendChild(createTextElement(\"description\", p.getDescription()));\n    e.appendChild(createTextElement(\"price\", \"\" + p.getPrice()));\n    return e;\n}\n","name":"createProduct","className":"ItemListBuilder","variables":{"p":2,"e":4,"doc":1},"constants":{"\"\"":1,"\"price\"":1,"\"product\"":1,"\"description\"":1},"javaDoc":"Builds a DOM element for a product p the product a DOM element describing the product","comments":"\n      Builds a DOM element for a product.\n      @param p the product\n      @return a DOM element describing the product\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String","String"],"returnType":"Element","methodCalls":{"appendChild":1,"createTextNode":1,"createElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Element":1,"Text":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":13,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"private Element createTextElement(String name, String text) {\n    Text t = doc.createTextNode(text);\n    Element e = doc.createElement(name);\n    e.appendChild(t);\n    return e;\n}\n","name":"createTextElement","className":"ItemListBuilder","variables":{"t":1,"e":3,"doc":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":1,"comparing":3,"sort":2,"parse":1,"toList":1,"sorted":1,"thenComparing":1,"get":1,"toString":2,"lines":1,"collect":1,"map":1,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"List<Country>":1,"String[]":1,"Stream<String>":1,"Comparator<String>":1},"expressions":{"VariableDeclarationExpr":4,"LambdaExpr":2,"NameExpr":69,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodReferenceExpr":3,"TypeExpr":3,"MethodCallExpr":20},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) throws IOException {\n    Comparator<String> comp = Comparator.comparing( t -> t.length());\n    String[] words = \"how much wood could a wood chuck chuck\".split(\" \");\n    Arrays.sort(words, comp);\n    System.out.println(Arrays.toString(words));\n    Arrays.sort(words, Comparator.comparing(String::length));\n    System.out.println(Arrays.toString(words));\n    try (Stream<String> lines = Files.lines(Paths.get(\"../population.txt\"))) {\n        List<Country> result = lines.map( line -> Country.parse(line)).sorted(Comparator.comparing(Country::getContinent).thenComparing(Country::getName)).collect(Collectors.toList());\n        System.out.println(result);\n    }\n}\n","name":"main","className":"ComparatorDemo","variables":{"result":1,"comp":1,"Collectors":1,"t":2,"line":1,"words":1,"Country":1,"Paths":1,"Arrays":4,"lines":2,"Files":1,"Comparator":3},"constants":{"\"../population.txt\"":1,"\" \"":1,"\"how much wood could a wood chuck chuck\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"Country","methodCalls":{"parseInt":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Country":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":2,"AssignExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":5},"text":"public static Country parse(String line) {\n    String[] fields = line.split(\"\\\\|\");\n    Country country = new Country();\n    country.name = fields[0];\n    country.continent = fields[1];\n    country.population = Integer.parseInt(fields[2]);\n    return country;\n}\n","name":"parse","className":"Country","variables":{"Integer":1,"country":2,"line":1,"fields":4},"constants":{"0":1,"1":1,"\"\\\\|\"":1,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getContinent() {\n    return continent;\n}\n","name":"getContinent","className":"Country","variables":{"continent":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getPopulation() {\n    return population;\n}\n","name":"getPopulation","className":"Country","variables":{"population":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":3,"StringLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return name + \"|\" + continent + \"|\" + population;\n}\n","name":"toString","className":"Country","variables":{"continent":1,"name":1,"population":1},"constants":{"\"|\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"stream":1,"of":3,"get":1,"show":5,"lines":1},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"Stream<Integer>":1,"ArrayList":1,"Stream<String>":2,"Integer[]":1,"List<String>":1},"expressions":{"IntegerLiteralExpr":12,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayInitializerExpr":1,"NameExpr":42,"StringLiteralExpr":13,"MethodCallExpr":13,"AssignExpr":2},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] args) throws IOException {\n    Stream<String> words = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\");\n    show(\"A stream of individually specified words\", words);\n    Stream<Integer> digits = Stream.of(3, 1, 4, 1, 5, 9);\n    show(\"A stream of individually specified digits\", digits);\n    Integer[] digitArray = { 3, 1, 4, 1, 5, 9 };\n    digits = Stream.of(digitArray);\n    show(\"A stream of digits from an array\", digits);\n    List<String> wordList = new ArrayList<>();\n    // Populate wordList\n    wordList.add(\"Hello\");\n    wordList.add(\"World\");\n    words = wordList.stream();\n    show(\"A stream of words from a list\", words);\n    try (Stream<String> lines = Files.lines(Paths.get(\"../countries.txt\"))) {\n        show(\"A stream of lines from a file\", lines);\n    }\n}\n","name":"main","className":"Streams","variables":{"wordList":4,"words":2,"digitArray":1,"Stream":3,"digits":2,"Paths":1,"lines":1,"Files":1},"constants":{"\"Hello\"":1,"\"a\"":1,"\"little\"":1,"\"../countries.txt\"":1,"\"A stream of lines from a file\"":1,"\"World\"":1,"\"Mary\"":1,"\"A stream of words from a list\"":1,"1":4,"\"lamb\"":1,"3":2,"4":2,"5":2,"\"A stream of individually specified digits\"":1,"\"had\"":1,"9":2,"\"A stream of individually specified words\"":1,"\"A stream of digits from an array\"":1},"javaDoc":"","comments":"Populate wordList ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"List<T>":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":53,"StringLiteralExpr":3,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Streams","variables":{"Collectors":1,"stream":1,"values":4,"caption":1,"i":4,"Math":1,"SHOW_LIMIT":3},"constants":{"0":2,"1":1,"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":2,"sorted":2,"of":4,"length":6,"show":4,"distinct":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Stream<String>":3,"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"LambdaExpr":4,"BinaryExpr":4,"NameExpr":69,"StringLiteralExpr":12,"MethodCallExpr":24,"AssignExpr":3},"statements":{"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).filter( w -> w.length() > 4);\n    show(\"Filtering with a simple lambda expression\", words);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).filter((String w) -> w.length() > 4);\n    show(\"Filtering with a lambda expression with parameter type\", words);\n    Stream<String> distinctWords = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).distinct();\n    Stream<String> sortedWords = distinctWords.sorted(( s,  t) -> s.length() - t.length());\n    show(\"Sorting with a lambda expression with two parameters\", sortedWords);\n    distinctWords = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).distinct();\n    sortedWords = distinctWords.sorted(( v,  w) -> {\n        int first = v.length();\n        int second = w.length();\n        return first - second;\n    });\n    show(\"Sorting with a complex lambda expression\", sortedWords);\n}\n","name":"main","className":"Streams","variables":{"sortedWords":2,"s":2,"t":2,"v":2,"w":6,"distinctWords":4,"words":2,"Stream":4,"first":2,"second":2},"constants":{"\" \"":4,"4":2,"\"Filtering with a simple lambda expression\"":1,"\"Filtering with a lambda expression with parameter type\"":1,"\"how much wood could a wood chuck chuck\"":4,"\"Sorting with a lambda expression with two parameters\"":1,"\"Sorting with a complex lambda expression\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"List<T>":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":53,"StringLiteralExpr":3,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Streams","variables":{"Collectors":1,"stream":1,"values":4,"caption":1,"i":4,"Math":1,"SHOW_LIMIT":3},"constants":{"0":2,"1":1,"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"random":1,"show":4,"generate":2,"isPrime":1,"iterate":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Stream<Integer>":4},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":4,"LambdaExpr":5,"BinaryExpr":4,"NameExpr":36,"StringLiteralExpr":4,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":11,"AssignExpr":1},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    Stream<Integer> ones = Stream.generate(() -> 1);\n    show(\"An infinite stream of ones\", ones);\n    Stream<Integer> dieTosses = Stream.generate(() -> 1 + (int) (6 * Math.random()));\n    show(\"An infinite stream of random numbers\", dieTosses);\n    Stream<Integer> integers = Stream.iterate(0,  n -> n + 1);\n    show(\"An infinite stream of integers\", integers);\n    integers = Stream.iterate(0,  n -> n + 1);\n    Stream<Integer> primes = integers.filter( n -> isPrime(n));\n    show(\"An infinite stream of primes\", primes);\n}\n","name":"main","className":"Infinite","variables":{"primes":1,"ones":1,"Stream":4,"dieTosses":1,"Math":1,"n":5,"integers":3},"constants":{"0":2,"1":4,"\"An infinite stream of ones\"":1,"\"An infinite stream of primes\"":1,"6":1,"\"An infinite stream of integers\"":1,"\"An infinite stream of random numbers\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"boolean","methodCalls":{"filter":1,"count":1,"limit":1,"iterate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"BinaryExpr":4,"LambdaExpr":2,"NameExpr":13,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public static boolean isPrime(int number) {\n    return Stream.iterate(1,  n -> n + 1).limit(number).filter( n -> number % n == 0).count() == 2;\n}\n","name":"isPrime","className":"Infinite","variables":{"number":1,"Stream":1,"n":4},"constants":{"0":1,"1":2,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"List<T>":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":53,"StringLiteralExpr":3,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Infinite","variables":{"Collectors":1,"stream":1,"values":4,"caption":1,"i":4,"Math":1,"SHOW_LIMIT":3},"constants":{"0":2,"1":1,"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"of":1,"ifPresent":1,"get":1,"length":1,"isPresent":1,"findFirst":1,"orElse":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Optional<String>":1,"Stream<String>":1,"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"LambdaExpr":2,"BinaryExpr":4,"NameExpr":45,"StringLiteralExpr":13,"FieldAccessExpr":4,"MethodCallExpr":12},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"Zimbabwe\", \"Namibia\", \"Uganda\", \"Botswana\", \"Madagascar\", \"Mozambique\", // \"Ivory Coast\",\n    \"Swaziland\", \"Togo\");\n    Optional<String> optResult = words.filter( w -> w.length() > 10).findFirst();\n    // Using orElse\n    String first = optResult.orElse(\"(None)\");\n    System.out.println(\"The first country with more than ten characters: \" + first);\n    // Using ifPresent\n    optResult.ifPresent( v -> System.out.println(\"The first country with more than ten characters: \" + v));\n    // Using isPresent/get\n    if (optResult.isPresent()) {\n        System.out.println(\"The first country with more than ten characters: \" + optResult.get());\n    } else {\n        System.out.println(\"None of these countries has more than ten characters\");\n    }\n}\n","name":"main","className":"OptionalDemo","variables":{"optResult":5,"v":2,"w":2,"words":2,"Stream":1,"first":2},"constants":{"\"None of these countries has more than ten characters\"":1,"\"Uganda\"":1,"\"Botswana\"":1,"\"Togo\"":1,"\"Madagascar\"":1,"\"The first country with more than ten characters: \"":3,"\"Namibia\"":1,"\"Mozambique\"":1,"\"(None)\"":1,"\"Zimbabwe\"":1,"10":1},"javaDoc":"","comments":"\"Ivory Coast\" Using orElse Using ifPresent Using isPresent/get ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":4,"toSet":1,"joining":1,"contains":4,"of":4,"toArray":1,"toString":1,"toList":1,"collect":3,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Set<String>":1,"Stream<String>":1,"String[]":1,"String":1,"List<String>":1},"expressions":{"VariableDeclarationExpr":5,"LambdaExpr":4,"BinaryExpr":4,"NameExpr":83,"StringLiteralExpr":29,"FieldAccessExpr":4,"MethodReferenceExpr":1,"TypeExpr":1,"MethodCallExpr":24,"AssignExpr":3},"statements":{"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    Stream<String> stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    String[] result1 = stream.toArray(String[]::new);\n    System.out.println(\"Converting to an array: \" + Arrays.toString(result1));\n    stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    List<String> result2 = stream.collect(Collectors.toList());\n    System.out.println(\"Collecting to a list: \" + result2);\n    stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    Set<String> result3 = stream.collect(Collectors.toSet());\n    System.out.println(\"Collecting to a set: \" + result3);\n    stream = Stream.of(\"Mary\", \"had\", \"a\", \"little\", \"lamb\").filter( w -> w.contains(\"a\"));\n    String result4 = stream.collect(Collectors.joining(\", \"));\n    System.out.println(\"Joining with commas: \" + result4);\n}\n","name":"main","className":"Streams","variables":{"Collectors":3,"stream":8,"w":8,"Stream":4,"Arrays":1,"result4":2,"result3":2,"result2":2,"result1":1},"constants":{"\"Collecting to a list: \"":1,"\"lamb\"":4,"\"a\"":8,"\"little\"":4,"\"had\"":4,"\"Converting to an array: \"":1,"\"Collecting to a set: \"":1,"\"Mary\"":4,"\", \"":1,"\"Joining with commas: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"filter":2,"contains":1,"nextLine":1,"hasNextLine":1,"length":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"ArrayList":1,"List<String>":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"LambdaExpr":1,"BinaryExpr":3,"StringLiteralExpr":4,"NameExpr":33,"FieldAccessExpr":2,"MethodCallExpr":9,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../countries.txt\"));\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNextLine()) {\n        wordList.add(in.nextLine());\n    }\n    List<String> filtered = filter(wordList,  w -> w.length() > 10);\n    System.out.println(\"Long country names: \" + filtered);\n    filtered = filter(wordList, contains(\" and \"));\n    System.out.println(\"Countries with and in their name: \" + filtered);\n}\n","name":"main","className":"HigherOrderFunctions","variables":{"filtered":4,"in":3,"wordList":2,"w":2},"constants":{"\" and \"":1,"\"../countries.txt\"":1,"\"Countries with and in their name: \"":1,"\"Long country names: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["List<T>","Predicate<T>"],"returnType":"List<T>","methodCalls":{"add":1,"test":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"T":1,"ArrayList":1,"List<T>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":10,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static <T> List<T> filter(List<T> values, Predicate<T> p) {\n    List<T> result = new ArrayList<>();\n    for (T value : values) {\n        if (p.test(value)) {\n            result.add(value);\n        }\n    }\n    return result;\n}\n","name":"filter","className":"HigherOrderFunctions","variables":{"result":3,"p":1,"values":1,"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"Predicate<String>","methodCalls":{"indexOf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"LambdaExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public static Predicate<String> contains(String target) {\n    return  s -> s.indexOf(target) >= 0;\n}\n","name":"contains","className":"HigherOrderFunctions","variables":{"s":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"joining":1,"max":1,"count":1,"range":2,"sum":1,"findFirst":2,"orElse":4,"mapToObj":1,"filter":3,"min":1,"of":6,"toArray":1,"toString":1,"map":1,"collect":1,"System.out.println":9,"codePoints":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double[]":1,"double":4,"int[]":1,"String":2,"int":2,"long":1,"OptionalDouble":1},"expressions":{"IntegerLiteralExpr":15,"VariableDeclarationExpr":12,"ArrayAccessExpr":1,"LambdaExpr":5,"BinaryExpr":11,"NameExpr":148,"StringLiteralExpr":9,"CharLiteralExpr":1,"UnaryExpr":1,"AssignExpr":1,"ArrayInitializerExpr":1,"DoubleLiteralExpr":2,"FieldAccessExpr":12,"MethodCallExpr":38},"statements":{"ExpressionStmt":27},"text":"public static void main(String[] args) {\n    int n = 10;\n    int[] squares = IntStream.range(0, n).map( i -> i * i).toArray();\n    System.out.println(Arrays.toString(squares));\n    double[] values = { 32, 54, 67.5, 29, 35, 80, 115, 44.5, 100, 65 };\n    double total = DoubleStream.of(values).sum();\n    double average = DoubleStream.of(values).average().orElse(0);\n    double largest = DoubleStream.of(values).max().orElse(Double.MIN_VALUE);\n    double smallest = DoubleStream.of(values).min().orElse(Double.MAX_VALUE);\n    System.out.println(\"total: \" + total);\n    System.out.println(\"average: \" + average);\n    System.out.println(\"largest: \" + largest);\n    System.out.println(\"smallest: \" + smallest);\n    String str = \"How much wood could a woodchuck chuck?\";\n    long spaces = str.codePoints().filter( ch -> ch == ' ').count();\n    System.out.println(\"spaces: \" + spaces);\n    String result = DoubleStream.of(values).mapToObj( v -> \"\" + v).collect(Collectors.joining(\" | \"));\n    System.out.println(result);\n    OptionalDouble result2 = DoubleStream.of(values).filter( v -> v > 100).findFirst();\n    System.out.println(result2);\n    n = values.length;\n    int pos = IntStream.range(0, n).filter( i -> values[i] == 100).findFirst().orElse(-1);\n    System.out.println(\"pos: \" + pos);\n}\n","name":"main","className":"CommonAlgorithmsRevisited","variables":{"average":2,"largest":2,"Collectors":1,"ch":2,"smallest":2,"values":2,"squares":1,"i":5,"n":2,"str":2,"result":1,"total":2,"pos":2,"v":4,"spaces":2,"DoubleStream":6,"Arrays":1,"IntStream":2,"result2":1},"constants":{"\"\"":1,"35":1,"29":1,"\"How much wood could a woodchuck chuck?\"":1,"\"pos: \"":1,"' '":1,"\" | \"":1,"0":3,"\"smallest: \"":1,"67.5":1,"100":3,"1":1,"115":1,"\"largest: \"":1,"\"total: \"":1,"80":1,"\"average: \"":1,"\"spaces: \"":1,"10":1,"32":1,"54":1,"44.5":1,"65":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getPopulation":6,"average":1,"groupingBy":2,"compare":1,"distinct":2,"parse":1,"toList":5,"orElse":1,"filter":3,"sorted":1,"stream":8,"findAny":1,"mapToInt":1,"get":1,"equals":1,"ifPresent":1,"limit":1,"lines":1,"map":3,"collect":7,"averagingInt":1,"getContinent":5,"System.out.println":8},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Stream<Country>":2,"Map<String, Double>":1,"Optional<Country>":1,"double":1,"Map<String, List<Country>>":1,"List<Country>":2,"Stream<String>":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":11,"LambdaExpr":12,"BinaryExpr":10,"NameExpr":191,"StringLiteralExpr":10,"FieldAccessExpr":8,"MethodCallExpr":62},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":30},"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../population.txt\"))) {\n        Stream<Country> countries = lines.map( line -> Country.parse(line));\n        List<Country> countryList = countries.collect(Collectors.toList());\n        Stream<Country> africanCountries = countryList.stream().filter( c -> c.getContinent().equals(\"Africa\"));\n        System.out.println(\"African countries: \" + africanCountries.collect(Collectors.toList()));\n        Stream<String> continents = countryList.stream().map( c -> c.getContinent()).distinct();\n        System.out.println(\"Continents: \" + continents.collect(Collectors.toList()));\n        Stream<String> continentsWithPopulousCountries = countryList.stream().filter( c -> c.getPopulation() >= 100_000_000).map( c -> c.getContinent()).distinct();\n        System.out.println(\"Continents with populous countries: \" + continentsWithPopulousCountries.collect(Collectors.toList()));\n        Optional<Country> aPopulousCountry = countryList.stream().filter( country -> country.getPopulation() > 100_000_000).findAny();\n        aPopulousCountry.ifPresent( c -> System.out.println(\"A populous country: \" + c));\n        List<Country> mostPopulous = countryList.stream().sorted(( c,  d) -> Double.compare(d.getPopulation(), c.getPopulation())).limit(10).collect(Collectors.toList());\n        System.out.println(\"Ten most populous countries: \" + mostPopulous);\n        double average = countryList.stream().mapToInt( country -> country.getPopulation()).average().orElse(0);\n        System.out.println(\"Average population of all countries: \" + average);\n        Map<String, List<Country>> countriesByContinent = countryList.stream().collect(Collectors.groupingBy( c -> c.getContinent()));\n        System.out.println(\"Countries by continent: \" + countriesByContinent);\n        Map<String, Double> averagePopulationByContinent = countryList.stream().collect(Collectors.groupingBy( c -> c.getContinent(), Collectors.averagingInt( c -> c.getPopulation())));\n        System.out.println(\"Average population by continent: \" + averagePopulationByContinent);\n    }\n}\n","name":"main","className":"Countries","variables":{"Collectors":8,"country":4,"average":2,"c":18,"d":2,"aPopulousCountry":2,"line":1,"mostPopulous":2,"averagePopulationByContinent":2,"countries":2,"countryList":9,"africanCountries":2,"Double":1,"continents":2,"continentsWithPopulousCountries":2,"Country":1,"Paths":1,"lines":2,"Files":1,"countriesByContinent":2},"constants":{"\"../population.txt\"":1,"100_000_000":2,"\"Average population by continent: \"":1,"\"Africa\"":1,"\"Continents with populous countries: \"":1,"\"Average population of all countries: \"":1,"\"African countries: \"":1,"0":1,"\"Countries by continent: \"":1,"\"Ten most populous countries: \"":1,"\"A populous country: \"":1,"\"Continents: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"Country","methodCalls":{"parseInt":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Country":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":2,"AssignExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":5},"text":"public static Country parse(String line) {\n    String[] fields = line.split(\"\\\\|\");\n    Country country = new Country();\n    country.name = fields[0];\n    country.continent = fields[1];\n    country.population = Integer.parseInt(fields[2]);\n    return country;\n}\n","name":"parse","className":"Country","variables":{"Integer":1,"country":2,"line":1,"fields":4},"constants":{"0":1,"1":1,"\"\\\\|\"":1,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getContinent() {\n    return continent;\n}\n","name":"getContinent","className":"Country","variables":{"continent":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getPopulation() {\n    return population;\n}\n","name":"getPopulation","className":"Country","variables":{"population":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return name;\n}\n","name":"toString","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"next":1,"filter":1,"size":1,"stream":2,"parallel":1,"forEach":1,"count":1,"length":2,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"ArrayList":2,"long":1,"List<String>":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"LambdaExpr":2,"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":47,"FieldAccessExpr":2,"MethodCallExpr":15},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":10},"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../words.txt\"));\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNext()) {\n        wordList.add(in.next());\n    }\n    long count = wordList.stream().filter( w -> w.length() > 10).count();\n    System.out.println(\"count: \" + count);\n    List<String> longWords = new ArrayList<>();\n    // The following code will probably throw an exception\n    wordList.stream().parallel().forEach( w -> {\n        if (w.length() > 10) {\n            longWords.add(w);\n        }\n    });\n    // If the program made it until here, the size will\n    // probably be wrong\n    System.out.println(\"longWords.size(): \" + longWords.size());\n}\n","name":"main","className":"Horror","variables":{"in":3,"wordList":4,"w":4,"count":2,"longWords":3},"constants":{"\"count: \"":1,"\"../words.txt\"":1,"10":2,"\"longWords.size(): \"":1},"javaDoc":"","comments":"If the program made it until here the size will The following code will probably throw an exception probably be wrong ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"max":1,"count":1,"length":1,"comparing":2,"toList":2,"orElse":2,"filter":11,"min":1,"get":5,"endsWith":5,"limit":1,"hasFiveVowels":5,"lines":5,"collect":2,"System.out.println":5},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Stream<String>":5,"String":2,"long":1,"List<String>":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":10,"LambdaExpr":11,"BinaryExpr":6,"NameExpr":148,"StringLiteralExpr":17,"FieldAccessExpr":5,"MethodReferenceExpr":2,"TypeExpr":2,"UnaryExpr":5,"MethodCallExpr":49},"statements":{"TryStmt":5,"BlockStmt":5,"ExpressionStmt":21},"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        long count = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).count();\n        System.out.println(\"Number of words with all five vowels: \" + count);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        List<String> examples = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).limit(20).collect(Collectors.toList());\n        System.out.println(\"20 words with all five vowels: \" + examples);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        String shortest = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).min(Comparator.comparing(String::length)).orElse(\"\");\n        System.out.println(\"Shortest: \" + shortest);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        List<String> allShortest = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).filter( w -> w.length() == 7).collect(Collectors.toList());\n        System.out.println(\"All of that length: \" + allShortest);\n    }\n    try (Stream<String> lines = Files.lines(Paths.get(\"../words.txt\"))) {\n        String longest = lines.filter( w -> !w.endsWith(\"'s\")).filter( w -> hasFiveVowels(w)).max(Comparator.comparing(String::length)).orElse(\"\");\n        System.out.println(\"Longest: \" + longest);\n    }\n}\n","name":"main","className":"Words","variables":{"Collectors":2,"longest":2,"examples":2,"w":17,"count":2,"allShortest":2,"Paths":5,"lines":10,"Files":5,"shortest":2,"Comparator":2},"constants":{"\"\"":2,"\"Number of words with all five vowels: \"":1,"\"'s\"":5,"\"All of that length: \"":1,"\"Longest: \"":1,"7":1,"\"20 words with all five vowels: \"":1,"\"Shortest: \"":1,"\"../words.txt\"":5,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"filter":1,"toLowerCase":1,"count":1,"distinct":1,"codePoints":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":10,"LambdaExpr":1,"NameExpr":16,"CharLiteralExpr":5,"MethodCallExpr":5},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public static boolean hasFiveVowels(String word) {\n    return word.toLowerCase().codePoints().filter( c -> c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').distinct().count() == 5;\n}\n","name":"hasFiveVowels","className":"Words","variables":{"c":6,"word":1},"constants":{"'i'":1,"5":1,"'e'":1,"'u'":1,"'a'":1,"'o'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"List<Movie>","methodCalls":{"add":1,"parseInt":1,"nextLine":5,"hasNextLine":1,"getList":3,"getString":2},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"Scanner":1,"List<Movie>":1,"ArrayList":1,"String":5},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":7,"NameExpr":41,"MethodCallExpr":13},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":7},"text":"public static List<Movie> readMovies(String filename) throws IOException {\n    List<Movie> movies = new ArrayList<>();\n    try (Scanner in = new Scanner(new File(filename))) {\n        while (in.hasNextLine()) {\n            String nameLine = in.nextLine();\n            String yearLine = in.nextLine();\n            String directorsLine = in.nextLine();\n            String producersLine = in.nextLine();\n            String actorsLine = in.nextLine();\n            movies.add(new Movie(getString(nameLine), Integer.parseInt(getString(yearLine)), getList(directorsLine), getList(producersLine), getList(actorsLine)));\n        }\n    }\n    return movies;\n}\n","name":"readMovies","className":"Movies","variables":{"movies":3,"Integer":1,"filename":1,"in":7,"yearLine":1,"actorsLine":1,"directorsLine":1,"producersLine":1,"nameLine":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"trim":1,"indexOf":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"private static String getString(String line) {\n    int colon = line.indexOf(\":\");\n    return line.substring(colon + 1).trim();\n}\n","name":"getString","className":"Movies","variables":{"line":2,"colon":2},"constants":{"1":1,"\":\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String"],"returnType":"List<String>","methodCalls":{"split":1,"of":1,"getString":1,"toList":1,"collect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":13,"StringLiteralExpr":1,"MethodCallExpr":5},"statements":{"ReturnStmt":1},"text":"private static List<String> getList(String line) {\n    return Stream.of(getString(line).split(\", \")).collect(Collectors.toList());\n/* Alternative without streams:\n      ArrayList<String> result = new ArrayList<>();\n      for (String s : getString(line).split(\", \"))\n      {\n         result.add(s);\n      }\n      return result;\n      */\n}\n","name":"getList","className":"Movies","variables":{"Collectors":1,"Stream":1},"constants":{"\", \"":1},"javaDoc":"","comments":"Alternative without streams: ArrayList<String> result = new ArrayList<>(); for (String s : getString(line) split(\" \")) { result add(s); } return result; ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"groupingBy":2,"toList":2,"substring":1,"remove":1,"getActors":4,"getTitle":4,"readMovies":1,"stream":9,"ifPresent":1,"get":3,"map":3,"System.out.println":10,"counting":1,"getKey":1,"intersect":1,"max":3,"entrySet":1,"count":3,"comparing":1,"orElse":1,"filter":5,"getValue":1,"commonActorAndDirector":1,"size":8,"mapToInt":1,"getDirectors":3,"collect":4,"startsWith":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"List<Movie>":1,"Map<String, Long>":1,"Map<String, List<Movie>>":1,"String":1,"long":1,"int":1,"List<String>":2},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":8,"LambdaExpr":14,"BinaryExpr":14,"NameExpr":232,"StringLiteralExpr":14,"FieldAccessExpr":10,"MethodCallExpr":78,"AssignExpr":1},"statements":{"ExpressionStmt":34},"text":"public static void main(String[] args) throws IOException {\n    List<Movie> movieList = readMovies(\"movies.txt\");\n    List<String> result1 = movieList.stream().map( m -> m.getTitle()).filter( t -> t.startsWith(\"X\")).collect(Collectors.toList());\n    System.out.println(\"Movies that start with X: \" + result1);\n    long count = movieList.stream().map( m -> intersect(m.getDirectors(), m.getActors())).filter( l -> l.size() > 0).count();\n    System.out.println(\"Movies in which directors are actors: \" + count);\n    count = movieList.stream().filter( m -> commonActorAndDirector(m)).count();\n    System.out.println(\"Movies in which directors are actors: \" + count);\n    int result2 = movieList.stream().mapToInt( m -> m.getActors().size()).max().orElse(0);\n    System.out.println(\"The most actors in a movie: \" + result2);\n    movieList.stream().max(( a,  b) -> a.getActors().size() - b.getActors().size()).ifPresent( m -> System.out.println(\"Movie with most actors: \" + m));\n    /* Alternative: \n      movieList.stream()\n         .max(Comparator.comparing(m -> m.getActors().size()))\n\t     .ifPresent(m -> System.out.println(\"Movie with most actors: \" + m));\n      */\n    Map<String, Long> firstLetters = movieList.stream().collect(Collectors.groupingBy( m -> m.getTitle().substring(0, 1), Collectors.counting()));\n    System.out.println(\"Movies by first letter: \" + firstLetters);\n    System.out.println(\"Movies starting with The: \" + movieList.stream().filter( m -> m.getTitle().startsWith(\"The \")).count());\n    Map<String, List<Movie>> moviesByDirector = movieList.stream().filter( m -> m.getDirectors().size() > 0).collect(Collectors.groupingBy( m -> m.getDirectors().get(0)));\n    moviesByDirector.remove(\"\");\n    System.out.println(\"Directors in the database: \" + moviesByDirector.size());\n    String mostProlificDirector = Collections.max(moviesByDirector.entrySet(), Comparator.comparing( e -> e.getValue().size())).getKey();\n    System.out.println(mostProlificDirector + \" directed \" + moviesByDirector.get(mostProlificDirector).size() + \" movies:\");\n    List<String> titles = moviesByDirector.get(mostProlificDirector).stream().map( m -> m.getTitle()).collect(Collectors.toList());\n    System.out.println(titles);\n}\n","name":"main","className":"Movies","variables":{"Collectors":5,"a":2,"b":2,"e":2,"firstLetters":2,"count":4,"movieList":9,"titles":1,"l":2,"m":20,"Comparator":1,"moviesByDirector":6,"t":2,"mostProlificDirector":2,"Collections":1,"result2":2,"result1":2},"constants":{"\"\"":1,"\"The \"":1,"\" directed \"":1,"\"The most actors in a movie: \"":1,"\"Movie with most actors: \"":1,"\"X\"":1,"\"Movies by first letter: \"":1,"0":5,"\"Movies that start with X: \"":1,"1":1,"\"movies.txt\"":1,"\"Directors in the database: \"":1,"\" movies:\"":1,"\"Movies in which directors are actors: \"":2,"\"Movies starting with The: \"":1},"javaDoc":"","comments":"Alternative: movieList stream() max(Comparator comparing(m -> m getActors() size())) ifPresent(m -> System out println(\"Movie with most actors: \" + m)); ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Movie"],"returnType":"boolean","methodCalls":{"contains":1,"getActors":1,"stream":1,"getDirectors":1,"anyMatch":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"LambdaExpr":1,"NameExpr":13,"MethodCallExpr":5},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public static boolean commonActorAndDirector(Movie m) {\n    return m.getDirectors().stream().anyMatch( d -> m.getActors().contains(d));\n}\n","name":"commonActorAndDirector","className":"Movies","variables":{"d":1,"m":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Collection<String>","Collection<String>"],"returnType":"Set<String>","methodCalls":{"retainAll":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Set<String>":1,"HashSet":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public static Set<String> intersect(Collection<String> a, Collection<String> b) {\n    Set<String> intersection = new HashSet<>(a);\n    intersection.retainAll(b);\n    return intersection;\n}\n","name":"intersect","className":"Movies","variables":{"a":1,"intersection":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["List<String>"],"returnType":"boolean","methodCalls":{"lastIndexOf":1,"sorted":1,"stream":2,"equals":1,"toList":2,"collect":2,"map":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"List<String>":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"LambdaExpr":1,"BinaryExpr":1,"NameExpr":29,"StringLiteralExpr":1,"MethodCallExpr":11},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public static boolean isSorted(List<String> names) {\n    List<String> lastNames = names.stream().map( n -> n.substring(n.lastIndexOf(\" \") + 1)).collect(Collectors.toList());\n    return lastNames.equals(lastNames.stream().sorted().collect(Collectors.toList()));\n}\n","name":"isSorted","className":"Movies","variables":{"Collectors":2,"names":1,"lastNames":3,"n":3},"constants":{"1":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int","List<String>","List<String>","List<String>"],"returnType":"Movie","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":15,"FieldAccessExpr":5,"ThisExpr":5,"AssignExpr":5},"statements":{"ExpressionStmt":5},"text":"public Movie(String title, int year, List<String> directors, List<String> producers, List<String> actors) {\n    this.title = title;\n    this.year = year;\n    this.directors = directors;\n    this.producers = producers;\n    this.actors = actors;\n}\n","name":"Movie","className":"Movie","variables":{"actors":1,"year":1,"directors":1,"title":1,"producers":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public List<String> getActors() {\n    return actors;\n}\n","name":"getActors","className":"Movie","variables":{"actors":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public List<String> getDirectors() {\n    return directors;\n}\n","name":"getDirectors","className":"Movie","variables":{"directors":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public List<String> getProducers() {\n    return producers;\n}\n","name":"getProducers","className":"Movie","variables":{"producers":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getTitle() {\n    return title;\n}\n","name":"getTitle","className":"Movie","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getYear() {\n    return year;\n}\n","name":"getYear","className":"Movie","variables":{"year":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":9,"StringLiteralExpr":5,"NameExpr":5},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"Name: \" + title + \"\\nYear: \" + year + \"\\nDirected by: \" + directors + \"\\nProduced by: \" + producers + \"\\nActors: \" + actors;\n}\n","name":"toString","className":"Movie","variables":{"actors":1,"year":1,"directors":1,"title":1,"producers":1},"constants":{"\"\\nProduced by: \"":1,"\"\\nYear: \"":1,"\"\\nDirected by: \"":1,"\"\\nActors: \"":1,"\"Name: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"encode":2,"getJsonObject":1,"size":2,"createReader":1,"getJsonArray":1,"getString":1,"printFilm":1,"openStream":1,"readObject":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"JsonArray":1,"boolean":1,"InputStream":1,"JsonReader":1,"JsonObject":1,"String":5,"URL":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":12,"ArrayAccessExpr":1,"BinaryExpr":25,"NameExpr":47,"StringLiteralExpr":26,"ConditionalExpr":1,"UnaryExpr":3,"AssignExpr":2,"NullLiteralExpr":2,"BooleanLiteralExpr":1,"EnclosedExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] args) throws Exception {\n    String apiKey = args[0];\n    String urlString = \"https://www.googleapis.com/freebase/v1/mqlread\";\n    String query = \"[{\" + \"  \\\"type\\\": \\\"/film/film\\\",\" + \"  \\\"name\\\": null,\" + \"  \\\"initial_release_date\\\": null,\" + \"  \\\"directed_by\\\": [],\" + \"  \\\"produced_by\\\": [],\" + \"  \\\"starring\\\": [{\" + \"    \\\"actor\\\": []\" + \"  }],\" + \"  \\\"country\\\": [{\" + \"    \\\"id\\\": \\\"/en/united_states\\\"\" + \"  }],\" + \"  \\\"genre\\\": [{\" + \"    \\\"id\\\": \\\"/en/drama\\\"\" + \"  }]\" + \"}]\";\n    String cursor = null;\n    boolean done = false;\n    while (!done) {\n        String request = \"?query=\" + URLEncoder.encode(query, \"UTF-8\") + \"&key=\" + apiKey + \"&cursor\" + (cursor == null ? \"\" : \"=\" + URLEncoder.encode(cursor, \"UTF-8\"));\n        URL url = new URL(urlString + request);\n        try (InputStream in = url.openStream()) {\n            JsonReader reader = Json.createReader(in);\n            JsonObject contents = reader.readObject();\n            JsonArray result = contents.getJsonArray(\"result\");\n            for (int k = 0; k < result.size(); k++) {\n                printFilm(result.getJsonObject(k));\n            }\n            done = result.size() < 100;\n            if (!done) {\n                cursor = contents.getString(\"cursor\");\n            }\n        }\n    }\n}\n","name":"main","className":"Freebase","variables":{"cursor":3,"request":2,"apiKey":2,"in":1,"reader":2,"query":1,"urlString":2,"Json":1,"k":3,"done":4,"url":2,"args":1,"result":4,"contents":3,"URLEncoder":2},"constants":{"\"\"":1,"\"    \\\"id\\\": \\\"/en/drama\\\"\"":1,"\"  \\\"name\\\": null,\"":1,"\"  \\\"type\\\": \\\"/film/film\\\",\"":1,"\"[{\"":1,"\"result\"":1,"\"}]\"":1,"\"  \\\"genre\\\": [{\"":1,"\"    \\\"id\\\": \\\"/en/united_states\\\"\"":1,"\"  }]\"":1,"\"  \\\"produced_by\\\": [],\"":1,"\"?query=\"":1,"\"  \\\"directed_by\\\": [],\"":1,"\"&key=\"":1,"\"&cursor\"":1,"\"=\"":1,"false":1,"\"  \\\"country\\\": [{\"":1,"0":2,"100":1,"\"  \\\"starring\\\": [{\"":1,"\"UTF-8\"":2,"\"  }],\"":2,"null":2,"\"https://www.googleapis.com/freebase/v1/mqlread\"":1,"\"  \\\"initial_release_date\\\": null,\"":1,"\"    \\\"actor\\\": []\"":1,"\"cursor\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","List<JsonValue>"],"returnType":"StringBuilder","methodCalls":{"size":1,"get":1,"replace":1,"toString":1,"append":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuilder":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":28,"StringLiteralExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"public static StringBuilder format(String title, List<JsonValue> array) {\n    StringBuilder result = new StringBuilder();\n    result.append(title);\n    result.append(\": \");\n    for (int i = 0; i < array.size(); i++) {\n        if (i > 0) {\n            result.append(\", \");\n        }\n        result.append(array.get(i).toString().replace(\",\", \" \"));\n    }\n    return result;\n}\n","name":"format","className":"Freebase","variables":{"result":6,"array":2,"i":4},"constants":{"0":2,"\" \"":1,"\",\"":1,"\": \"":1,"\", \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["JsonObject"],"returnType":"void","methodCalls":{"getJsonObject":1,"size":1,"addAll":1,"get":1,"getJsonArray":4,"replace":1,"format":3,"toString":1,"getString":1,"substring":1,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"List<JsonValue>":1,"JsonArray":1,"ArrayList":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":67,"StringLiteralExpr":13,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":20},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"public static void printFilm(JsonObject film) {\n    System.out.println(\"Name: \" + film.getString(\"name\"));\n    System.out.println(\"Year: \" + film.get(\"initial_release_date\").toString().replace(\"\\\"\", \"\").substring(0, 4));\n    System.out.println(format(\"Directed by\", film.getJsonArray(\"directed_by\")));\n    System.out.println(format(\"Produced by\", film.getJsonArray(\"produced_by\")));\n    List<JsonValue> actors = new ArrayList<>();\n    JsonArray jactors = film.getJsonArray(\"starring\");\n    for (int i = 0; i < jactors.size(); i++) {\n        actors.addAll(jactors.getJsonObject(i).getJsonArray(\"actor\"));\n    }\n    System.out.println(format(\"Actors\", actors));\n}\n","name":"printFilm","className":"Freebase","variables":{"actors":2,"i":3,"film":5,"jactors":3},"constants":{"\"\"":1,"\"Actors\"":1,"\"Produced by\"":1,"\"Year: \"":1,"\"\\\"\"":1,"\"actor\"":1,"\"Name: \"":1,"\"directed_by\"":1,"\"initial_release_date\"":1,"0":2,"\"produced_by\"":1,"4":1,"\"name\"":1,"\"starring\"":1,"\"Directed by\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sorted":2,"of":5,"toUpperCase":1,"show":6,"limit":2,"toArray":1,"toString":1,"map":3,"generate":1,"iterate":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Stream<Double>":1,"Stream<String>":1,"String[]":1,"Stream<BankAccount>":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"DoubleLiteralExpr":12,"LambdaExpr":2,"BinaryExpr":2,"NameExpr":81,"StringLiteralExpr":15,"FieldAccessExpr":1,"MethodReferenceExpr":6,"TypeExpr":6,"MethodCallExpr":28,"AssignExpr":4},"statements":{"ExpressionStmt":17},"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).map( w -> w.toUpperCase());\n    show(\"Mapping to uppercase with a lambda expression\", words);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).map(String::toUpperCase);\n    show(\"Mapping to uppercase with a method reference\", words);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).sorted(String::compareTo);\n    show(\"Sorting strings with a method reference\", words);\n    Stream<Double> numbers = Stream.of(32.0, 54.0, 67.5, 29.0, 35.0, 80.0, 115.0, 44.5, 100.0, 65.0).sorted(Double::compare);\n    show(\"Sorting numbers with a method reference\", numbers);\n    Stream<BankAccount> accounts = Stream.generate(BankAccount::new).limit(5);\n    show(\"Constructing accounts with a constructor reference\", accounts);\n    accounts = Stream.iterate(0.0,  n -> n + 1000.0).map(BankAccount::new).limit(5);\n    show(\"Mapping with a constructor reference\", accounts);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \"));\n    String[] array = words.toArray(String[]::new);\n    System.out.println(\"Using toArray with an array constructor reference: \" + Arrays.toString(array));\n}\n","name":"main","className":"MethodReferences","variables":{"array":1,"w":2,"words":5,"numbers":1,"Stream":7,"accounts":2,"Arrays":1,"n":2},"constants":{"80.0":1,"\"Sorting numbers with a method reference\"":1,"\" \"":4,"\"Constructing accounts with a constructor reference\"":1,"\"Using toArray with an array constructor reference: \"":1,"67.5":1,"0.0":1,"35.0":1,"5":2,"\"how much wood could a wood chuck chuck\"":4,"32.0":1,"\"Mapping to uppercase with a lambda expression\"":1,"\"Mapping to uppercase with a method reference\"":1,"65.0":1,"54.0":1,"1000.0":1,"100.0":1,"\"Mapping with a constructor reference\"":1,"29.0":1,"115.0":1,"\"Sorting strings with a method reference\"":1,"44.5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"List<T>":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":53,"StringLiteralExpr":3,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"MethodReferences","variables":{"Collectors":1,"stream":1,"values":4,"caption":1,"i":4,"Math":1,"SHOW_LIMIT":3},"constants":{"0":2,"1":1,"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"BankAccount[balance=\" + balance + \"]\";\n}\n","name":"toString","className":"BankAccount","variables":{"balance":1},"constants":{"\"]\"":1,"\"BankAccount[balance=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"filter":1,"nextLine":1,"stream":1,"hasNextLine":1,"length":2,"count":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"ArrayList":1,"String":1,"long":1,"List<String>":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":4,"LambdaExpr":1,"StringLiteralExpr":3,"NameExpr":37,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":10,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ForeachStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../countries.txt\"));\n    // This file contains one country name per line\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNextLine()) {\n        wordList.add(in.nextLine());\n    }\n    // Now wordList is a list of country names\n    // Traditional loop for counting the long words\n    long count = 0;\n    for (String w : wordList) {\n        if (w.length() > 10) {\n            count++;\n        }\n    }\n    System.out.println(\"Long words: \" + count);\n    // The same computation with streams\n    count = wordList.stream().filter( w -> w.length() > 10).count();\n    System.out.println(\"Long words: \" + count);\n}\n","name":"main","className":"StreamDemo","variables":{"in":3,"wordList":4,"w":4,"count":5},"constants":{"0":1,"\"../countries.txt\"":1,"\"Long words: \"":2,"10":2},"javaDoc":"","comments":"Now wordList is a list of country names This file contains one country name per line Traditional loop for counting the long words The same computation with streams ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"next":1,"max":1,"length":3,"hasNext":1,"orElse":1,"allMatch":1,"filter":2,"contains":1,"stream":3,"parallel":1,"findAny":1,"ifPresent":1,"endsWith":1,"System.out.print":1,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"Scanner":1,"Optional<String>":1,"boolean":1,"ArrayList":1,"Stream<String>":1,"String":1,"List<String>":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"LambdaExpr":5,"BinaryExpr":4,"StringLiteralExpr":7,"NameExpr":78,"FieldAccessExpr":4,"MethodCallExpr":23,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":18},"text":"public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new File(\"../words.txt\"));\n    List<String> wordList = new ArrayList<>();\n    while (in.hasNext()) {\n        wordList.add(in.next());\n    }\n    Stream<String> words = wordList.stream();\n    String result = words.parallel().filter( w -> w.length() > 10).filter( w -> w.endsWith(\"y\")).findAny().orElse(\"None found\");\n    // Note the use of findAny. Run this program several times\n    // and check whether the result changes\n    System.out.println(\"A word ending in y: \" + result);\n    words = wordList.stream();\n    Optional<String> result2 = words.max(( v,  w) -> v.length() - w.length());\n    System.out.print(\"The longest word: \");\n    result2.ifPresent( w -> System.out.println(w));\n    words = wordList.stream();\n    boolean result3 = words.allMatch( w -> w.contains(\"e\"));\n    System.out.println(\"All words contain an e: \" + result3);\n}\n","name":"main","className":"TerminalOperations","variables":{"result":2,"in":3,"wordList":5,"v":2,"w":9,"words":6,"result3":2,"result2":2},"constants":{"\"None found\"":1,"\"A word ending in y: \"":1,"\"All words contain an e: \"":1,"\"y\"":1,"\"The longest word: \"":1,"\"../words.txt\"":1,"10":1,"\"e\"":1},"javaDoc":"","comments":"Note the use of findAny Run this program several times and check whether the result changes ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"max":2,"length":3,"range":4,"sum":3,"orElse":2,"mapToObj":1,"substring":1,"ints":1,"sqrt":1,"mapToInt":2,"of":4,"toArray":6,"limit":1,"toString":6,"map":1,"System.out.println":11,"mapToDouble":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Random":1,"double":1,"int[]":1,"DoubleStream":1,"Stream<String>":2,"String":1,"IntStream":3,"int":2},"expressions":{"IntegerLiteralExpr":27,"ObjectCreationExpr":1,"VariableDeclarationExpr":12,"BinaryExpr":12,"LambdaExpr":5,"NameExpr":183,"StringLiteralExpr":18,"MethodReferenceExpr":1,"TypeExpr":1,"AssignExpr":5,"ArrayInitializerExpr":1,"FieldAccessExpr":11,"MethodCallExpr":53},"statements":{"ExpressionStmt":33},"text":"public static void main(String[] args) {\n    IntStream stream = IntStream.of(3, 1, 4, 1, 5, 9);\n    System.out.println(\"The sum of a stream of ints: \" + stream.sum());\n    int[] values = { 3, 1, 4, 1, 5, 9 };\n    stream = IntStream.of(values);\n    System.out.println(\"The sum of a stream of ints from an array: \" + stream.sum());\n    stream = IntStream.range(1, 101);\n    System.out.println(\"The sum of a range: \" + stream.sum());\n    Random generator = new Random();\n    IntStream dieTosses = generator.ints(1, 7);\n    System.out.println(\"Twenty random die tosses: \" + Arrays.toString(dieTosses.limit(20).toArray()));\n    IntStream codePoints = \"Hello\".codePoints();\n    System.out.println(\"The Unicode code points of the string Hello: \" + Arrays.toString(codePoints.toArray()));\n    Stream<String> words = Stream.of(\"Hello\", \"World\");\n    stream = words.mapToInt( w -> w.length());\n    System.out.println(\"Mapping objects to ints: \" + Arrays.toString(stream.toArray()));\n    stream = IntStream.range(0, 20).map( n -> Math.max(n, 10));\n    System.out.println(\"Mapping ints to ints: \" + Arrays.toString(stream.toArray()));\n    String river = \"Mississippi\";\n    int n = river.length();\n    Stream<String> prefixes = IntStream.range(0, n).mapToObj( i -> river.substring(0, i + 1));\n    System.out.println(\"Mapping ints to objects: \" + Arrays.toString(prefixes.toArray(String[]::new)));\n    DoubleStream roots = IntStream.range(0, 20).mapToDouble( i -> Math.sqrt(i));\n    System.out.println(\"Mapping ints to doubles: \" + Arrays.toString(roots.toArray()));\n    words = Stream.of(\"Goodbye\", \"World\");\n    double average = words.mapToInt( w -> w.length()).average().orElse(0);\n    System.out.println(\"Computing an average of ints: \" + average);\n    int max = \"World\".codePoints().max().orElse(0);\n    System.out.println(\"Computing a maximum of ints: \" + max);\n}\n","name":"main","className":"PrimitiveStreams","variables":{"average":2,"max":2,"values":1,"words":4,"generator":2,"i":3,"roots":2,"Math":2,"n":2,"prefixes":2,"stream":10,"w":4,"Stream":2,"river":3,"dieTosses":2,"Arrays":6,"IntStream":6,"codePoints":2},"constants":{"\"Goodbye\"":1,"\"The sum of a range: \"":1,"\"World\"":3,"\"Computing a maximum of ints: \"":1,"\"The Unicode code points of the string Hello: \"":1,"\"Mapping ints to ints: \"":1,"\"Twenty random die tosses: \"":1,"10":1,"\"Hello\"":2,"\"Mapping ints to doubles: \"":1,"\"Mapping ints to objects: \"":1,"0":6,"1":7,"\"The sum of a stream of ints from an array: \"":1,"\"The sum of a stream of ints: \"":1,"101":1,"3":2,"4":2,"5":2,"\"Computing an average of ints: \"":1,"7":1,"\"Mississippi\"":1,"9":2,"\"Mapping objects to ints: \"":1,"20":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"sorted":1,"of":6,"toLowerCase":3,"equals":1,"show":6,"length":1,"distinct":2,"map":6,"replaceAll":2,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Stream<Integer>":1,"Stream<String>":6},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"LambdaExpr":7,"NameExpr":96,"StringLiteralExpr":32,"MethodCallExpr":33,"AssignExpr":5},"statements":{"ExpressionStmt":25},"text":"public static void main(String[] args) {\n    Stream<String> words = Stream.of(\"A\", \"Tale\", \"of\", \"Two\", \"Cities\");\n    Stream<String> lowerCaseWords = words.map( w -> w.toLowerCase());\n    show(\"Mapping to lowercase: \", lowerCaseWords);\n    lowerCaseWords = Stream.of(\"A\", \"Tale\", \"of\", \"Two\", \"Cities\").map( w -> w.toLowerCase());\n    Stream<String> consonantsOnly = lowerCaseWords.map( w -> w.replaceAll(\"[aeiou]\", \"\"));\n    show(\"Removing vowels\", consonantsOnly);\n    consonantsOnly = Stream.of(\"A\", \"Tale\", \"of\", \"Two\", \"Cities\").map( w -> w.toLowerCase()).map( w -> w.replaceAll(\"[aeiou]\", \"\"));\n    Stream<Integer> consonantCount = consonantsOnly.map( w -> w.length());\n    show(\"Counting consonants\", consonantCount);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \"));\n    Stream<String> cWords = words.filter( w -> w.substring(0, 1).equals(\"c\"));\n    show(\"Words with c\", cWords);\n    words = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \"));\n    Stream<String> distinctWords = words.distinct();\n    show(\"Distinct words\", distinctWords);\n    distinctWords = Stream.of(\"how much wood could a wood chuck chuck\".split(\" \")).distinct();\n    Stream<String> sortedWords = distinctWords.sorted();\n    show(\"Sorted words\", sortedWords);\n}\n","name":"main","className":"Streams","variables":{"sortedWords":1,"consonantCount":1,"w":14,"distinctWords":3,"words":6,"consonantsOnly":3,"Stream":6,"lowerCaseWords":3,"cWords":1},"constants":{"\"\"":2,"\"c\"":1,"\"A\"":3,"\"Mapping to lowercase: \"":1,"\"[aeiou]\"":2,"\" \"":3,"\"Distinct words\"":1,"\"Tale\"":3,"\"Counting consonants\"":1,"\"Sorted words\"":1,"0":1,"1":1,"\"Words with c\"":1,"\"how much wood could a wood chuck chuck\"":3,"\"of\"":3,"\"Cities\"":3,"\"Removing vowels\"":1,"\"Two\"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Stream<T>"],"returnType":"void","methodCalls":{"min":1,"size":2,"get":1,"limit":1,"toList":1,"collect":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"List<T>":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":53,"StringLiteralExpr":3,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   */\npublic static <T> void show(String caption, Stream<T> stream) {\n    final int SHOW_LIMIT = 10;\n    List<T> values = stream.limit(SHOW_LIMIT + 1).collect(Collectors.toList());\n    System.out.print(caption + \": \");\n    for (int i = 0; i < Math.min(SHOW_LIMIT, values.size()); i++) {\n        if (i > 0) {\n            System.out.print(\", \");\n        }\n        System.out.print(values.get(i));\n    }\n    if (values.size() > SHOW_LIMIT) {\n        System.out.print(\", ...\");\n    }\n    System.out.println();\n}\n","name":"show","className":"Streams","variables":{"Collectors":1,"stream":1,"values":4,"caption":1,"i":4,"Math":1,"SHOW_LIMIT":3},"constants":{"0":2,"1":1,"\": \"":1,"\", ...\"":1,"\", \"":1,"10":1},"javaDoc":"Displays the first ten values in a stream followed by if there are additional values caption the caption preceding the values stream the stream to be displayed (which is consumed in the process)","comments":"\n      Displays the first ten values in a stream, followed by ...\n      if there are additional values.\n      @param caption the caption preceding the values\n      @param stream the stream to be displayed (which is consumed\n      in the process)\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"get":1,"limit":1,"length":1,"distinct":1,"toList":1,"lines":1,"collect":1,"map":2,"substring":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Stream<String>":1,"List<String>":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"LambdaExpr":3,"BinaryExpr":2,"NameExpr":35,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":12},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../countries.txt\"))) {\n        // Read the lines\n        List<String> result = lines.filter(// Keep only long words\n         w -> w.length() > 10).map(// Truncate to seven characters\n         w -> w.substring(0, 7)).map(// Add ellipses\n         w -> w + \"...\").distinct().limit(// Keep only the first twenty\n        20).collect(// Collect into a list\n        Collectors.toList());\n        System.out.println(result);\n    }\n}\n                         // Remove duplicates\n\n","name":"main","className":"StreamDemo","variables":{"result":1,"Collectors":1,"w":6,"Paths":1,"lines":2,"Files":1},"constants":{"0":1,"\"...\"":1,"\"../countries.txt\"":1,"7":1,"10":1},"javaDoc":"","comments":"Read the lines Keep only long words Truncate to seven characters Add ellipses Remove duplicates Keep only the first twenty Collect into a list ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"counting":1,"groupingBy":4,"toSet":1,"maxBy":1,"of":4,"length":2,"collect":4,"substring":4,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Map<String, Long>":1,"Map<String, List<String>>":1,"String[]":1,"Map<String, Set<String>>":1,"Map<String, Optional<String>>":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":5,"BinaryExpr":6,"LambdaExpr":5,"StringLiteralExpr":7,"NameExpr":89,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":26},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    String[] words = (\"how much wood would a woodchuck chuck \" + \"if a woodchuck could chuck wood\").split(\" \");\n    Map<String, List<String>> groups = Stream.of(words).collect(Collectors.groupingBy( w -> w.substring(0, 1)));\n    System.out.println(\"Lists by first letter: \" + groups);\n    Map<String, Set<String>> groupOfSets = Stream.of(words).collect(Collectors.groupingBy(// The function for extracting the keys\n     w -> w.substring(0, 1), // The group collector\n    Collectors.toSet()));\n    System.out.println(\"Sets by first letter: \" + groupOfSets);\n    Map<String, Long> groupCounts = Stream.of(words).collect(Collectors.groupingBy( w -> w.substring(0, 1), Collectors.counting()));\n    System.out.println(\"Counts by first letter: \" + groupCounts);\n    Map<String, Optional<String>> groupLongest = Stream.of(words).collect(Collectors.groupingBy(// The function for extracting the keys\n     w -> w.substring(0, 1), Collectors.maxBy(( v,  w) -> v.length() - w.length())));\n    // The comparator function\n    System.out.println(\"Longest word by first letter: \" + groupLongest);\n}\n","name":"main","className":"GroupDemo","variables":{"Collectors":7,"v":2,"w":10,"words":1,"groups":2,"Stream":4,"groupOfSets":2,"groupCounts":2,"groupLongest":2},"constants":{"0":4,"1":4,"\"Counts by first letter: \"":1,"\" \"":1,"\"if a woodchuck could chuck wood\"":1,"\"Longest word by first letter: \"":1,"\"how much wood would a woodchuck chuck \"":1,"\"Lists by first letter: \"":1,"\"Sets by first letter: \"":1},"javaDoc":"","comments":"The function for extracting the keys The group collector The function for extracting the keys The comparator function ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getPopulation":1,"groupingBy":1,"get":1,"parse":1,"lines":1,"map":1,"collect":1,"getContinent":1,"summingLong":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Stream<Country>":1,"Map<String, Long>":1,"Stream<String>":1},"expressions":{"VariableDeclarationExpr":3,"LambdaExpr":3,"BinaryExpr":1,"NameExpr":34,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":10},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) throws IOException {\n    try (Stream<String> lines = Files.lines(Paths.get(\"../population.txt\"))) {\n        Stream<Country> countries = lines.map( line -> Country.parse(line));\n        Map<String, Long> groupSum = countries.collect(Collectors.groupingBy(// The function for extracting the keys\n         c -> c.getContinent(), Collectors.summingLong(// The function for getting the summands\n         c -> c.getPopulation())));\n        System.out.println(\"Population per continent: \" + groupSum);\n    }\n}\n","name":"main","className":"GroupDemo2","variables":{"Collectors":2,"groupSum":2,"c":4,"line":1,"Country":1,"Paths":1,"countries":2,"lines":2,"Files":1},"constants":{"\"../population.txt\"":1,"\"Population per continent: \"":1},"javaDoc":"","comments":"The function for extracting the keys The function for getting the summands ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"Country","methodCalls":{"parseInt":1,"split":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Country":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":2,"AssignExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":5},"text":"public static Country parse(String line) {\n    String[] fields = line.split(\"\\\\|\");\n    Country country = new Country();\n    country.name = fields[0];\n    country.continent = fields[1];\n    country.population = Integer.parseInt(fields[2]);\n    return country;\n}\n","name":"parse","className":"Country","variables":{"Integer":1,"country":2,"line":1,"fields":4},"constants":{"0":1,"1":1,"\"\\\\|\"":1,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getContinent() {\n    return continent;\n}\n","name":"getContinent","className":"Country","variables":{"continent":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getPopulation() {\n    return population;\n}\n","name":"getPopulation","className":"Country","variables":{"population":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":3,"StringLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return name + \"|\" + continent + \"|\" + population;\n}\n","name":"toString","className":"Country","variables":{"continent":1,"name":1,"population":1},"constants":{"\"|\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"moveRectangleTo":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void mousePressed(MouseEvent event) {\n    int x = event.getX();\n    int y = event.getY();\n    scene.moveRectangleTo(x, y);\n}\n","name":"mousePressed","className":"MousePressListener","variables":{"x":1,"y":1,"event":2,"scene":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Do-nothing methods\npublic void mouseReleased(MouseEvent event) {\n}\n","name":"mouseReleased","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","comments":" Do-nothing methods","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseClicked(MouseEvent event) {\n}\n","name":"mouseClicked","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseEntered(MouseEvent event) {\n}\n","name":"mouseEntered","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseExited(MouseEvent event) {\n}\n","name":"mouseExited","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"getKeyStrokeForEvent":1,"equals":4,"replace":1,"toString":1,"moveRectangleBy":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":1,"NameExpr":32,"StringLiteralExpr":6,"UnaryExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":5},"text":"public void keyPressed(KeyEvent event) {\n    String key = KeyStroke.getKeyStrokeForEvent(event).toString().replace(\"pressed \", \"\");\n    if (key.equals(\"DOWN\")) {\n        scene.moveRectangleBy(0, 1);\n    } else if (key.equals(\"UP\")) {\n        scene.moveRectangleBy(0, -1);\n    } else if (key.equals(\"LEFT\")) {\n        scene.moveRectangleBy(-1, 0);\n    } else if (key.equals(\"RIGHT\")) {\n        scene.moveRectangleBy(1, 0);\n    }\n}\n","name":"keyPressed","className":"KeyStrokeListener","variables":{"KeyStroke":1,"key":5,"scene":4},"constants":{"\"\"":1,"0":4,"1":4,"\"UP\"":1,"\"DOWN\"":1,"\"pressed \"":1,"\"LEFT\"":1,"\"RIGHT\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void keyTyped(KeyEvent event) {\n}\n","name":"keyTyped","className":"KeyStrokeListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void keyReleased(KeyEvent event) {\n}\n","name":"keyReleased","className":"KeyStrokeListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame3","methodCalls":{"add":1,"setSize":1,"addKeyListener":1,"setFocusable":1,"addMouseListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"MouseListener":1,"MousePressListener":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":18,"AssignExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public RectangleFrame3() {\n    scene = new RectangleComponent3();\n    add(scene);\n    MouseListener listener = new MousePressListener();\n    scene.addMouseListener(listener);\n    scene.addKeyListener(new KeyStrokeListener());\n    scene.setFocusable(true);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"RectangleFrame3","className":"RectangleFrame3","variables":{"listener":1,"scene":4},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RectangleComponent3","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public RectangleComponent3() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent3","className":"RectangleComponent3","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"constants":{},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Graphics2D":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent3","variables":{"g":1,"g2":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"setLocation":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   */\npublic void moveRectangleTo(int x, int y) {\n    box.setLocation(x, y);\n    repaint();\n}\n","name":"moveRectangleTo","className":"RectangleComponent3","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle to the given location x the x-position of the new location y the y-position of the new location","comments":"\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"repaint":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   */\npublic void moveRectangleBy(int dx, int dy) {\n    box.translate(dx, dy);\n    repaint();\n}\n","name":"moveRectangleBy","className":"RectangleComponent3","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle by a given amount dx the amount to move in the x-direction dy the amount to move in the y-direction","comments":"\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"RectangleFrame3":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame3();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer3","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"compare":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"BankAccount":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    BankAccount other = (BankAccount) otherObject;\n    return Double.compare(balance, other.balance);\n}\n","name":"compareTo","className":"BankAccount","variables":{"other":1,"Double":1,"otherObject":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"BankAccount[balance=\" + balance + \"]\";\n}\n","name":"toString","className":"BankAccount","variables":{"balance":1},"constants":{"\"]\"":1,"\"BankAccount[balance=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":2,"sort":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Comparable[]":2},"expressions":{"IntegerLiteralExpr":14,"ObjectCreationExpr":6,"VariableDeclarationExpr":2,"ArrayAccessExpr":6,"NameExpr":32,"StringLiteralExpr":6,"FieldAccessExpr":2,"ArrayCreationExpr":2,"AssignExpr":6,"MethodCallExpr":6},"statements":{"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    Comparable[] accounts = new Comparable[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    Arrays.sort(accounts);\n    System.out.println(Arrays.toString(accounts));\n    Comparable[] people = new Comparable[3];\n    people[0] = new Person(\"James\", \"Gosling\", 42);\n    people[2] = new Person(\"Alonzo\", \"Church\", 30510);\n    people[1] = new Person(\"John\", \"Mauchly\", 1729);\n    Arrays.sort(people);\n    System.out.println(Arrays.toString(people));\n}\n","name":"main","className":"ComparableDemo","variables":{"accounts":4,"Arrays":4,"people":4},"constants":{"\"James\"":1,"2000":1,"\"Mauchly\"":1,"0":3,"1":2,"2":2,"30510":1,"3":2,"10000":1,"\"Alonzo\"":1,"1729":1,"\"Gosling\"":1,"42":1,"\"Church\"":1,"\"John\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","int"],"returnType":"Person","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":3,"ThisExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public Person(String first, String last, int id) {\n    this.first = first;\n    this.last = last;\n    this.id = id;\n}\n","name":"Person","className":"Person","variables":{"last":1,"id":1,"first":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":6,"StringLiteralExpr":4,"NameExpr":3},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"Person[first=\" + first + \",last=\" + last + \",id=\" + id + \"]\";\n}\n","name":"toString","className":"Person","variables":{"last":1,"id":1,"first":1},"constants":{"\",last=\"":1,"\"]\"":1,"\",id=\"":1,"\"Person[first=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Person":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"CastExpr":1,"NameExpr":5,"FieldAccessExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    Person other = (Person) otherObject;\n    return id - other.id;\n}\n","name":"compareTo","className":"Person","variables":{"other":1,"id":1,"otherObject":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Computes the measure of the object.\n      @return the measure\n   */\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"constants":{},"javaDoc":"Computes the measure of the object the measure","comments":"\n      Computes the measure of the object.\n      @return the measure\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Measurable","Measurable"],"returnType":"Measurable","methodCalls":{"getMeasure":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"public static Measurable larger(Measurable obj1, Measurable obj2) {\n    if (obj1.getMeasure() > obj2.getMeasure()) {\n        return obj1;\n    } else {\n        return obj2;\n    }\n}\n","name":"larger","className":"ConversionTester","variables":{"obj2":2,"obj1":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"larger":1,"getName":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Measurable":1,"Country":3,"String":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":19,"CastExpr":1,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Country uruguay = new Country(\"Uruguay\", 176220);\n    Country thailand = new Country(\"Thailand\", 513120);\n    Measurable max = larger(uruguay, thailand);\n    Country maxCountry = (Country) max;\n    String name = maxCountry.getName();\n    System.out.println(\"Country with larger area: \" + name);\n    System.out.println(\"Expected: Thailand\");\n}\n","name":"main","className":"ConversionTester","variables":{"maxCountry":2,"max":2,"thailand":1,"name":2,"uruguay":1},"constants":{"\"Thailand\"":1,"513120":1,"\"Country with larger area: \"":1,"\"Expected: Thailand\"":1,"\"Uruguay\"":1,"176220":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return balance;\n}\n","name":"getMeasure","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// An abstract method\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"constants":{},"javaDoc":"","comments":" An abstract method","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Measurable[]"],"returnType":"// A static method\ndouble","methodCalls":{"getMeasure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Measurable":1,"double":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":13,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"static // A static method\ndouble average(// A static method\nMeasurable[] objects) {\n    double sum = 0;\n    for (Measurable obj : objects) {\n        sum = sum + obj.getMeasure();\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Measurable","variables":{"obj":2,"objects":1,"sum":4},"constants":{"0":3},"javaDoc":"","comments":"A static method A static method A static method ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2,"Measurable[]":2},"expressions":{"IntegerLiteralExpr":14,"ObjectCreationExpr":6,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":7,"FieldAccessExpr":4,"ArrayCreationExpr":2,"AssignExpr":6,"MethodCallExpr":6},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    // Calling the static average method\n    // with an array of BankAccount objects\n    Measurable[] accounts = new Measurable[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    double averageBalance = Measurable.average(accounts);\n    System.out.println(\"Average balance: \" + averageBalance);\n    System.out.println(\"Expected: 4000\");\n    // Calling the static average method\n    // with an array of Country objects\n    Measurable[] countries = new Measurable[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    double averageArea = Measurable.average(countries);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 239950\");\n}\n","name":"main","className":"MeasurableTester","variables":{"Measurable":2,"accounts":4,"countries":4,"averageBalance":2,"averageArea":2},"constants":{"\"Average balance: \"":1,"\"Thailand\"":1,"513120":1,"\"Belgium\"":1,"\"Expected: 239950\"":1,"2000":1,"\"Uruguay\"":1,"\"Expected: 4000\"":1,"0":3,"1":2,"2":2,"30510":1,"\"Average area: \"":1,"3":2,"10000":1,"176220":1},"javaDoc":"","comments":"Calling the static average method with an array of BankAccount objects Calling the static average method with an array of Country objects ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object[]","Measurer"],"returnType":"double","methodCalls":{"measure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"Object":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":14,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   */\npublic static double average(Object[] objects, Measurer meas) {\n    double sum = 0;\n    for (Object obj : objects) {\n        sum = sum + meas.measure(obj);\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":1,"objects":1,"meas":1,"sum":4},"constants":{"0":3},"javaDoc":"Computes the average of the measures of the given objects objects an array of objects meas the measurer for the objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   */\ndouble measure(Object anObject);\n","name":"measure","className":"Measurer","variables":{},"constants":{},"javaDoc":"Computes the measure of an object anObject the object to be measured the measure","comments":"\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{"getHeight":1,"getWidth":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"double":1,"Rectangle":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":1,"CastExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public double measure(Object anObject) {\n    Rectangle aRectangle = (Rectangle) anObject;\n    double area = aRectangle.getWidth() * aRectangle.getHeight();\n    return area;\n}\n","name":"measure","className":"AreaMeasurer","variables":{"area":2,"aRectangle":3,"anObject":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"getHeight":1,"getWidth":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["Casting","InnerMethod","PolyMorphism","InnerClass"],"types":{"Measurer":1,"double":2,"Rectangle":1,"Rectangle[]":1,"AreaMeasurer":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":12,"VariableDeclarationExpr":5,"ArrayInitializerExpr":1,"BinaryExpr":2,"NameExpr":28,"CastExpr":1,"StringLiteralExpr":2,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":5},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    class AreaMeasurer implements Measurer {\n\n        public double measure(Object anObject) {\n            Rectangle aRectangle = (Rectangle) anObject;\n            double area = aRectangle.getWidth() * aRectangle.getHeight();\n            return area;\n        }\n    }\n    Measurer areaMeas = new AreaMeasurer();\n    Rectangle[] rects = new Rectangle[] { new Rectangle(5, 10, 20, 30), new Rectangle(10, 20, 30, 40), new Rectangle(20, 30, 5, 15) };\n    double averageArea = Data.average(rects, areaMeas);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 625\");\n}\n","name":"main","className":"MeasurerTester","variables":{"area":2,"measure":1,"aRectangle":3,"anObject":2,"AreaMeasurer":1,"areaMeas":1,"rects":1,"Data":1,"averageArea":2},"constants":{"\"Average area: \"":1,"15":1,"\"Expected: 625\"":1,"5":2,"40":1,"30":3,"20":3,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    System.out.println(\"I was clicked.\");\n}\n","name":"actionPerformed","className":"ClickListener","variables":{},"constants":{"\"I was clicked.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"addActionListener":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ActionListener":1,"JFrame":1,"JButton":1,"ClickListener":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    JButton button = new JButton(\"Click me!\");\n    frame.add(button);\n    ActionListener listener = new ClickListener();\n    button.addActionListener(listener);\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ButtonViewer","variables":{"button":2,"listener":1,"frame":5},"constants":{"true":1,"\"Click me!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"name":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Named":1,"User":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":13,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    Named user = new User(\"Amy\", \"Smith\");\n    System.out.println(\"Name: \" + user.name());\n    // And not \"(NONE)\"\n    System.out.println(\"Expected: Amy Smith\");\n}\n","name":"main","className":"ConflictingDefaultMethodsTester","variables":{"user":2},"constants":{"\"Expected: Amy Smith\"":1,"\"Smith\"":1,"\"Amy\"":1,"\"Name: \"":1},"javaDoc":"","comments":"And not \"(NONE)\" ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"default String name() {\n    return \"(NONE)\";\n}\n","name":"name","className":"Named","variables":{},"constants":{"\"(NONE)\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String","String"],"returnType":"User","methodCalls":{"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":9,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"public User(String first, String last) {\n    super(first, last);\n    username = (first.substring(0, 1) + last).toLowerCase();\n}\n","name":"User","className":"User","variables":{"last":2,"first":2,"username":1},"constants":{"0":1,"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"Person","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Person(String firstName, String lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n","name":"Person","className":"Person","variables":{"firstName":1,"lastName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"firstName":1,"lastName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String name() {\n    return firstName() + \" \" + lastName();\n}\n","name":"name","className":"Person","variables":{},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String firstName() {\n    return firstName;\n}\n","name":"firstName","className":"Person","variables":{"firstName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String lastName() {\n    return lastName;\n}\n","name":"lastName","className":"Person","variables":{"lastName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"addActionListener":1,"setDefaultCloseOperation":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"JButton":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"LambdaExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":2,"NameExpr":26,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    JButton button = new JButton(\"Click me!\");\n    frame.add(button);\n    button.addActionListener((ActionEvent event) -> System.out.println(\"I was clicked.\"));\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ButtonViewer","variables":{"button":2,"event":1,"frame":5},"constants":{"\"I was clicked.\"":1,"true":1,"\"Click me!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"void addScore(int studentId, double score);\n","name":"addScore","className":"IGradeBook","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"double getAverageScore(int studentId);\n","name":"getAverageScore","className":"IGradeBook","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"void save(String filename);\n","name":"save","className":"IGradeBook","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"void load(String filename);\n","name":"load","className":"IGradeBook","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"MockGradeBook","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public MockGradeBook() {\n    scores = new ArrayList<Double>();\n}\n","name":"MockGradeBook","className":"MockGradeBook","variables":{"scores":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void addScore(int studentId, double score) {\n    // Ignore studentId\n    scores.add(score);\n}\n","name":"addScore","className":"MockGradeBook","variables":{"scores":1},"constants":{},"javaDoc":"","comments":"Ignore studentId ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":8,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public double getAverageScore(int studentId) {\n    double total = 0;\n    for (double x : scores) {\n        total = total + x;\n    }\n    return total / scores.size();\n}\n","name":"getAverageScore","className":"MockGradeBook","variables":{"total":4,"scores":2,"x":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void save(String filename) {\n// Do nothing\n}\n","name":"save","className":"MockGradeBook","variables":{},"constants":{},"javaDoc":"","comments":"Do nothing ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":4},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":4,"NameExpr":12,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void load(String filename) {\n    // Add sample scores\n    scores.add(1.0);\n    scores.add(7.0);\n    scores.add(2.0);\n    scores.add(9.0);\n}\n","name":"load","className":"MockGradeBook","variables":{"scores":4},"constants":{"1.0":1,"2.0":1,"7.0":1,"9.0":1},"javaDoc":"","comments":"Add sample scores ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":3,"load":1,"getAverageScore":1,"equals":5,"addScore":1,"toUpperCase":1,"save":1,"nextInt":2,"System.out.print":6,"nextDouble":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Scanner":1,"boolean":1,"MockGradeBook":1,"IGradeBook":1,"double":1,"String":3,"int":2},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":9,"BooleanLiteralExpr":2,"BinaryExpr":3,"NameExpr":93,"StringLiteralExpr":13,"FieldAccessExpr":8,"UnaryExpr":1,"MethodCallExpr":23,"AssignExpr":1},"statements":{"IfStmt":5,"WhileStmt":1,"BlockStmt":6,"ExpressionStmt":20},"text":"public static void main(String[] args) {\n    IGradeBook gradeBook = new MockGradeBook();\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"L)oad A)dd aV)erage S)ave Q)uit: \");\n        String command = in.next().toUpperCase();\n        if (command.equals(\"L\")) {\n            System.out.print(\"Filename: \");\n            String filename = in.next();\n            gradeBook.load(filename);\n        } else if (command.equals(\"S\")) {\n            System.out.print(\"Filename: \");\n            String filename = in.next();\n            gradeBook.save(filename);\n        } else if (command.equals(\"A\")) {\n            System.out.print(\"ID: \");\n            int id = in.nextInt();\n            System.out.print(\"Score: \");\n            double score = in.nextDouble();\n            gradeBook.addScore(id, score);\n        } else if (command.equals(\"V\")) {\n            System.out.print(\"ID: \");\n            int id = in.nextInt();\n            System.out.println(\"Average for \" + id + \": \" + gradeBook.getAverageScore(id));\n        } else if (command.equals(\"Q\")) {\n            done = true;\n        }\n    }\n}\n","name":"main","className":"GradingProgram","variables":{"score":1,"filename":2,"in":7,"id":3,"done":3,"gradeBook":5,"command":6},"constants":{"\"A\"":1,"false":1,"\": \"":1,"\"Filename: \"":2,"\"Score: \"":1,"\"V\"":1,"\"S\"":1,"\"Q\"":1,"\"Average for \"":1,"\"ID: \"":2,"\"L\"":1,"true":1,"\"L)oad A)dd aV)erage S)ave Q)uit: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return balance;\n}\n","name":"getMeasure","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// An abstract method\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"constants":{},"javaDoc":"","comments":" An abstract method","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Measurable"],"returnType":"boolean","methodCalls":{"getMeasure":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"default boolean smallerThan(Measurable other) {\n    return getMeasure() < other.getMeasure();\n}\n","name":"smallerThan","className":"Measurable","variables":{"other":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Measurable[]":1},"expressions":{"IntegerLiteralExpr":11,"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":7,"BinaryExpr":2,"NameExpr":31,"StringLiteralExpr":7,"FieldAccessExpr":4,"ArrayCreationExpr":1,"AssignExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Measurable[] countries = new Measurable[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    System.out.println(\"Uruguay is smaller than Thailand: \" + countries[0].smallerThan(countries[1]));\n    System.out.println(\"Expected: true\");\n    System.out.println(\"Uruguay is smaller than Belgium: \" + countries[0].smallerThan(countries[2]));\n    System.out.println(\"Expected: false\");\n}\n","name":"main","className":"MeasurableTester","variables":{"countries":8},"constants":{"\"Thailand\"":1,"513120":1,"\"Belgium\"":1,"\"Uruguay is smaller than Belgium: \"":1,"\"Uruguay\"":1,"0":3,"1":2,"2":2,"30510":1,"3":1,"\"Uruguay is smaller than Thailand: \"":1,"\"Expected: true\"":1,"176220":1,"\"Expected: false\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"name":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Named":1,"User":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":13,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    Named user = new User(\"Amy\", \"Smith\");\n    System.out.println(\"Name: \" + user.name());\n    System.out.println(\"Expected: asmith\");\n}\n","name":"main","className":"ConflictingDefaultMethodsTester","variables":{"user":2},"constants":{"\"Smith\"":1,"\"Amy\"":1,"\"Name: \"":1,"\"Expected: asmith\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"default String name() {\n    return \"(NONE)\";\n}\n","name":"name","className":"Named","variables":{},"constants":{"\"(NONE)\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String","String"],"returnType":"User","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public User(String first, String last) {\n    this.first = first;\n    this.last = last;\n}\n","name":"User","className":"User","variables":{"last":1,"first":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":6,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"// This method MUST be implemented to resolve the conflict.\npublic String name() {\n    // Here, we provide a different implementation.\n    return (first.substring(0, 1) + last).toLowerCase();\n// You could have also called one of the default methods:\n// return Person.super.name();\n}\n","name":"name","className":"User","variables":{"last":1,"first":1},"constants":{"0":1,"1":1},"javaDoc":"","comments":"You could have also called one of the default methods: return Person super name(); Here we provide a different implementation  This method MUST be implemented to resolve the conflict.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String firstName() {\n    return first;\n}\n","name":"firstName","className":"User","variables":{"first":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String lastName() {\n    return last;\n}\n","name":"lastName","className":"User","variables":{"last":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"firstName":1,"lastName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"default String name() {\n    return firstName() + \" \" + lastName();\n}\n","name":"name","className":"Person","variables":{},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"String firstName();\n","name":"firstName","className":"Person","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"String lastName();\n","name":"lastName","className":"Person","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"BankAccount":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":9,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":3,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    BankAccount other = (BankAccount) otherObject;\n    if (balance < other.balance) {\n        return -1;\n    }\n    if (balance > other.balance) {\n        return 1;\n    }\n    return 0;\n}\n","name":"compareTo","className":"BankAccount","variables":{"other":1,"balance":2,"otherObject":1},"constants":{"0":1,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount[]":1,"int":1},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":2,"NameExpr":31,"StringLiteralExpr":2,"FieldAccessExpr":4,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    BankAccount[] accounts = new BankAccount[3];\n    accounts[0] = new BankAccount(10000);\n    accounts[1] = new BankAccount(0);\n    accounts[2] = new BankAccount(2000);\n    Arrays.sort(accounts);\n    for (int i = 0; i < accounts.length; i++) {\n        System.out.print(accounts[i].getBalance() + \" \");\n    }\n    System.out.println();\n    System.out.println(\"Expected: 0.0 2000.0 10000.0\");\n}\n","name":"main","className":"ComparableTester","variables":{"i":4,"accounts":5,"Arrays":1},"constants":{"0":3,"1":1,"2":1,"3":1,"\" \"":1,"10000":1,"2000":1,"\"Expected: 0.0 2000.0 10000.0\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"RectangleFrame2":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame2();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer2","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"RectangleComponent2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public RectangleComponent2() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent2","className":"RectangleComponent2","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"constants":{},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Graphics2D":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent2","variables":{"g":1,"g2":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"setLocation":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   */\npublic void moveRectangleTo(int x, int y) {\n    box.setLocation(x, y);\n    repaint();\n}\n","name":"moveRectangleTo","className":"RectangleComponent2","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle to the given location x the x-position of the new location y the y-position of the new location","comments":"\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"moveRectangleTo":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void mousePressed(MouseEvent event) {\n    int x = event.getX();\n    int y = event.getY();\n    scene.moveRectangleTo(x, y);\n}\n","name":"mousePressed","className":"MousePressListener","variables":{"x":1,"y":1,"event":2,"scene":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Do-nothing methods\npublic void mouseReleased(MouseEvent event) {\n}\n","name":"mouseReleased","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","comments":" Do-nothing methods","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseClicked(MouseEvent event) {\n}\n","name":"mouseClicked","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseEntered(MouseEvent event) {\n}\n","name":"mouseEntered","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseExited(MouseEvent event) {\n}\n","name":"mouseExited","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame2","methodCalls":{"add":1,"setSize":1,"addMouseListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"MouseListener":1,"MousePressListener":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":12,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"public RectangleFrame2() {\n    scene = new RectangleComponent2();\n    add(scene);\n    MouseListener listener = new MousePressListener();\n    scene.addMouseListener(listener);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"RectangleFrame2","className":"RectangleFrame2","variables":{"listener":1,"scene":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"random":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"CastExpr":1,"NameExpr":6,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int next() {\n    return (int) (Integer.MAX_VALUE * Math.random());\n}\n","name":"next","className":"RandomSequence","variables":{"Math":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":2,"display":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LastDigitDistribution":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"NameExpr":17,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    LastDigitDistribution dist1 = new LastDigitDistribution();\n    dist1.process(new SquareSequence(), 1000);\n    dist1.display();\n    System.out.println();\n    LastDigitDistribution dist2 = new LastDigitDistribution();\n    dist2.process(new RandomSequence(), 1000);\n    dist2.display();\n}\n","name":"main","className":"SequenceDemo","variables":{"dist1":3,"dist2":3},"constants":{"1000":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"int next();\n","name":"next","className":"Sequence","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"UnaryExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int next() {\n    n++;\n    return n * n;\n}\n","name":"next","className":"SquareSequence","variables":{"n":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"LastDigitDistribution","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a distribution whose counters are set to zero.\n   */\npublic LastDigitDistribution() {\n    counters = new int[10];\n}\n","name":"LastDigitDistribution","className":"LastDigitDistribution","variables":{"counters":1},"constants":{"10":1},"javaDoc":"Constructs a distribution whose counters are set to zero","comments":"\n      Constructs a distribution whose counters are set to zero.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Sequence","int"],"returnType":"void","methodCalls":{"next":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":9,"UnaryExpr":2,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"/**\n      Processes values from this sequence.\n      @param seq the sequence from which to obtain the values\n      @param valuesToProcess the number of values to process\n   */\npublic void process(Sequence seq, int valuesToProcess) {\n    for (int i = 1; i <= valuesToProcess; i++) {\n        int value = seq.next();\n        int lastDigit = value % 10;\n        counters[lastDigit]++;\n    }\n}\n","name":"process","className":"LastDigitDistribution","variables":{"counters":1,"lastDigit":2,"i":3,"valuesToProcess":1,"value":2,"seq":1},"constants":{"1":1,"10":1},"javaDoc":"Processes values from this sequence seq the sequence from which to obtain the values valuesToProcess the number of values to process","comments":"\n      Processes values from this sequence.\n      @param seq the sequence from which to obtain the values\n      @param valuesToProcess the number of values to process\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"/**\n      Displays the counter values of this distribution.\n   */\npublic void display() {\n    for (int i = 0; i < counters.length; i++) {\n        System.out.println(i + \": \" + counters[i]);\n    }\n}\n","name":"display","className":"LastDigitDistribution","variables":{"counters":1,"i":5},"constants":{"0":1,"\": \"":1},"javaDoc":"Displays the counter values of this distribution","comments":"\n      Displays the counter values of this distribution.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return balance;\n}\n","name":"getMeasure","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Measurable[]"],"returnType":"double","methodCalls":{"getMeasure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Measurable":1,"double":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":13,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of Measurable objects\n      @return the average of the measures\n   */\npublic static double average(Measurable[] objects) {\n    double sum = 0;\n    for (Measurable obj : objects) {\n        sum = sum + obj.getMeasure();\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":2,"objects":1,"sum":4},"constants":{"0":3},"javaDoc":"Computes the average of the measures of the given objects objects an array of Measurable objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of Measurable objects\n      @return the average of the measures\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Computes the measure of the object.\n      @return the measure\n   */\ndouble getMeasure();\n","name":"getMeasure","className":"Measurable","variables":{},"constants":{},"javaDoc":"Computes the measure of the object the measure","comments":"\n      Computes the measure of the object.\n      @return the measure\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2,"Measurable[]":2},"expressions":{"IntegerLiteralExpr":14,"ObjectCreationExpr":6,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":7,"FieldAccessExpr":4,"ArrayCreationExpr":2,"AssignExpr":6,"MethodCallExpr":6},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    // Calling the average method with an array of BankAccount objects\n    Measurable[] accounts = new Measurable[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    double averageBalance = Data.average(accounts);\n    System.out.println(\"Average balance: \" + averageBalance);\n    System.out.println(\"Expected: 4000\");\n    // Calling the average method with an array of Country objects\n    Measurable[] countries = new Measurable[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    double averageArea = Data.average(countries);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 239950\");\n}\n","name":"main","className":"MeasurableTester","variables":{"Data":2,"accounts":4,"countries":4,"averageBalance":2,"averageArea":2},"constants":{"\"Average balance: \"":1,"\"Thailand\"":1,"513120":1,"\"Belgium\"":1,"\"Expected: 239950\"":1,"2000":1,"\"Uruguay\"":1,"\"Expected: 4000\"":1,"0":3,"1":2,"2":2,"30510":1,"\"Average area: \"":1,"3":2,"10000":1,"176220":1},"javaDoc":"","comments":"Calling the average method with an array of BankAccount objects Calling the average method with an array of Country objects ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"moveRectangleTo":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void mousePressed(MouseEvent event) {\n    int x = event.getX();\n    int y = event.getY();\n    scene.moveRectangleTo(x, y);\n}\n","name":"mousePressed","className":"MousePressListener","variables":{"x":1,"y":1,"event":2,"scene":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Do-nothing methods\npublic void mouseReleased(MouseEvent event) {\n}\n","name":"mouseReleased","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","comments":" Do-nothing methods","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseClicked(MouseEvent event) {\n}\n","name":"mouseClicked","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseEntered(MouseEvent event) {\n}\n","name":"mouseEntered","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseExited(MouseEvent event) {\n}\n","name":"mouseExited","className":"MousePressListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"getKeyStrokeForEvent":1,"equals":4,"replace":1,"toString":1,"moveRectangleBy":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":1,"NameExpr":32,"StringLiteralExpr":6,"UnaryExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":5},"text":"public void keyPressed(KeyEvent event) {\n    String key = KeyStroke.getKeyStrokeForEvent(event).toString().replace(\"pressed \", \"\");\n    if (key.equals(\"DOWN\")) {\n        scene.moveRectangleBy(0, 1);\n    } else if (key.equals(\"UP\")) {\n        scene.moveRectangleBy(0, -1);\n    } else if (key.equals(\"LEFT\")) {\n        scene.moveRectangleBy(-1, 0);\n    } else if (key.equals(\"RIGHT\")) {\n        scene.moveRectangleBy(1, 0);\n    }\n}\n","name":"keyPressed","className":"KeyStrokeListener","variables":{"KeyStroke":1,"key":5,"scene":4},"constants":{"\"\"":1,"0":4,"1":4,"\"UP\"":1,"\"DOWN\"":1,"\"pressed \"":1,"\"LEFT\"":1,"\"RIGHT\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void keyTyped(KeyEvent event) {\n}\n","name":"keyTyped","className":"KeyStrokeListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void keyReleased(KeyEvent event) {\n}\n","name":"keyReleased","className":"KeyStrokeListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame3","methodCalls":{"add":1,"setSize":1,"addKeyListener":1,"setFocusable":1,"addMouseListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"MouseListener":1,"MousePressListener":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":18,"AssignExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public RectangleFrame3() {\n    scene = new RectangleComponent3();\n    add(scene);\n    MouseListener listener = new MousePressListener();\n    scene.addMouseListener(listener);\n    scene.addKeyListener(new KeyStrokeListener());\n    scene.setFocusable(true);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"RectangleFrame3","className":"RectangleFrame3","variables":{"listener":1,"scene":4},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RectangleComponent3","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public RectangleComponent3() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent3","className":"RectangleComponent3","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"constants":{},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Graphics2D":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent3","variables":{"g":1,"g2":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"setLocation":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   */\npublic void moveRectangleTo(int x, int y) {\n    box.setLocation(x, y);\n    repaint();\n}\n","name":"moveRectangleTo","className":"RectangleComponent3","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle to the given location x the x-position of the new location y the y-position of the new location","comments":"\n      Moves the rectangle to the given location.\n      @param x the x-position of the new location\n      @param y the y-position of the new location\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"repaint":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   */\npublic void moveRectangleBy(int dx, int dy) {\n    box.translate(dx, dy);\n    repaint();\n}\n","name":"moveRectangleBy","className":"RectangleComponent3","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle by a given amount dx the amount to move in the x-direction dy the amount to move in the y-direction","comments":"\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"RectangleFrame3":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame3();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer3","variables":{"frame":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getBalance":2,"deposit":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":14,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent event) {\n    double interest = account.getBalance() * INTEREST_RATE / 100;\n    account.deposit(interest);\n    label.setText(\"balance: \" + account.getBalance());\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"interest":1,"INTEREST_RATE":1,"label":1,"account":3},"constants":{"100":1,"\"balance: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"setVisible":1,"getBalance":3,"setSize":1,"addActionListener":1,"deposit":1,"setDefaultCloseOperation":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables","PolyMorphism","InnerClass"],"types":{"JPanel":1,"ActionListener":1,"JFrame":1,"double":1,"AddInterestListener":1,"JButton":1,"JLabel":1,"BankAccount":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":4,"BooleanLiteralExpr":1,"StringLiteralExpr":3,"NameExpr":52,"FieldAccessExpr":1,"MethodCallExpr":12},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    // The button to trigger the calculation\n    JButton button = new JButton(\"Add Interest\");\n    // The application adds interest to this bank account\n    final BankAccount account = new BankAccount(INITIAL_BALANCE);\n    // The label for displaying the results\n    final JLabel label = new JLabel(\"balance: \" + account.getBalance());\n    // The panel that holds the user interface components\n    JPanel panel = new JPanel();\n    panel.add(button);\n    panel.add(label);\n    frame.add(panel);\n    class AddInterestListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            double interest = account.getBalance() * INTEREST_RATE / 100;\n            account.deposit(interest);\n            label.setText(\"balance: \" + account.getBalance());\n        }\n    }\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer2","variables":{"button":2,"actionPerformed":1,"interest":1,"AddInterestListener":1,"INTEREST_RATE":1,"listener":1,"label":2,"INITIAL_BALANCE":1,"panel":3,"event":1,"account":5,"frame":5},"constants":{"100":1,"true":1,"\"Add Interest\"":1,"\"balance: \"":2},"javaDoc":"","comments":"The button to trigger the calculation The application adds interest to this bank account The label for displaying the results The panel that holds the user interface components ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object[]","Measurer"],"returnType":"double","methodCalls":{"measure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"Object":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":14,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   */\npublic static double average(Object[] objects, Measurer meas) {\n    double sum = 0;\n    for (Object obj : objects) {\n        sum = sum + meas.measure(obj);\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":1,"objects":1,"meas":1,"sum":4},"constants":{"0":3},"javaDoc":"Computes the average of the measures of the given objects objects an array of objects meas the measurer for the objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   */\ndouble measure(Object anObject);\n","name":"measure","className":"Measurer","variables":{},"constants":{},"javaDoc":"Computes the measure of an object anObject the object to be measured the measure","comments":"\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{"getHeight":1,"getWidth":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"double":1,"Rectangle":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":1,"CastExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public double measure(Object anObject) {\n    Rectangle aRectangle = (Rectangle) anObject;\n    double area = aRectangle.getWidth() * aRectangle.getHeight();\n    return area;\n}\n","name":"measure","className":"AreaMeasurer","variables":{"area":2,"aRectangle":3,"anObject":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Measurer":1,"double":1,"Rectangle[]":1,"AreaMeasurer":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":12,"VariableDeclarationExpr":3,"ArrayInitializerExpr":1,"BinaryExpr":1,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Measurer areaMeas = new AreaMeasurer();\n    Rectangle[] rects = new Rectangle[] { new Rectangle(5, 10, 20, 30), new Rectangle(10, 20, 30, 40), new Rectangle(20, 30, 5, 15) };\n    double averageArea = Data.average(rects, areaMeas);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 625\");\n}\n","name":"main","className":"MeasurerTester","variables":{"areaMeas":1,"rects":1,"Data":1,"averageArea":2},"constants":{"\"Average area: \"":1,"15":1,"\"Expected: 625\"":1,"5":2,"40":1,"30":3,"20":3,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object[]","Measurer"],"returnType":"double","methodCalls":{"measure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"Object":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":14,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   */\npublic static double average(Object[] objects, Measurer meas) {\n    double sum = 0;\n    for (Object obj : objects) {\n        sum = sum + meas.measure(obj);\n    }\n    if (objects.length > 0) {\n        return sum / objects.length;\n    } else {\n        return 0;\n    }\n}\n","name":"average","className":"Data","variables":{"obj":1,"objects":1,"meas":1,"sum":4},"constants":{"0":3},"javaDoc":"Computes the average of the measures of the given objects objects an array of objects meas the measurer for the objects the average of the measures","comments":"\n      Computes the average of the measures of the given objects.\n      @param objects an array of objects\n      @param meas the measurer for the objects\n      @return the average of the measures\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   */\ndouble measure(Object anObject);\n","name":"measure","className":"Measurer","variables":{},"constants":{},"javaDoc":"Computes the measure of an object anObject the object to be measured the measure","comments":"\n      Computes the measure of an object.\n      @param anObject the object to be measured\n      @return the measure\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"average":2,"getHeight":1,"getWidth":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Measurer":1,"double":2,"Rectangle[]":1,"Rectangle":1,"BankAccount[]":1},"expressions":{"IntegerLiteralExpr":19,"ObjectCreationExpr":6,"VariableDeclarationExpr":6,"ArrayAccessExpr":3,"LambdaExpr":2,"BinaryExpr":3,"NameExpr":44,"StringLiteralExpr":4,"AssignExpr":3,"ArrayInitializerExpr":1,"CastExpr":2,"FieldAccessExpr":4,"EnclosedExpr":1,"ArrayCreationExpr":2,"MethodCallExpr":9},"statements":{"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    BankAccount[] accounts = new BankAccount[3];\n    accounts[0] = new BankAccount(0);\n    accounts[1] = new BankAccount(10000);\n    accounts[2] = new BankAccount(2000);\n    double averageBalance = Data.average(accounts, (Object obj) -> ((BankAccount) obj).getBalance());\n    System.out.println(\"Average balance: \" + averageBalance);\n    System.out.println(\"Expected: 4000\");\n    Rectangle[] rects = new Rectangle[] { new Rectangle(5, 10, 20, 30), new Rectangle(10, 20, 30, 40), new Rectangle(20, 30, 5, 15) };\n    Measurer areaMeas = (Object obj) -> {\n        Rectangle r = (Rectangle) obj;\n        return r.getWidth() * r.getHeight();\n    };\n    double averageArea = Data.average(rects, areaMeas);\n    System.out.println(\"Average area: \" + averageArea);\n    System.out.println(\"Expected: 625\");\n}\n","name":"main","className":"MeasurerTester","variables":{"r":3,"obj":4,"Data":2,"rects":1,"areaMeas":1,"accounts":4,"averageBalance":2,"averageArea":2},"constants":{"\"Average balance: \"":1,"15":1,"\"Expected: 625\"":1,"2000":1,"\"Expected: 4000\"":1,"0":2,"1":1,"2":1,"\"Average area: \"":1,"3":1,"5":2,"10000":1,"40":1,"30":3,"20":3,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"RectangleFrame":1,"JFrame":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JFrame frame = new RectangleFrame();\n    frame.setTitle(\"An animated rectangle\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"RectangleViewer","variables":{"frame":4},"constants":{"true":1,"\"An animated rectangle\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"RectangleComponent","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public RectangleComponent() {\n    // The rectangle that the paintComponent method draws \n    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);\n}\n","name":"RectangleComponent","className":"RectangleComponent","variables":{"BOX_Y":1,"BOX_X":1,"box":1,"BOX_HEIGHT":1,"BOX_WIDTH":1},"constants":{},"javaDoc":"","comments":"The rectangle that the paintComponent method draws ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Graphics2D":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.draw(box);\n}\n","name":"paintComponent","className":"RectangleComponent","variables":{"g":1,"g2":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"repaint":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   */\npublic void moveRectangleBy(int dx, int dy) {\n    box.translate(dx, dy);\n    repaint();\n}\n","name":"moveRectangleBy","className":"RectangleComponent","variables":{"box":1},"constants":{},"javaDoc":"Moves the rectangle by a given amount dx the amount to move in the x-direction dy the amount to move in the y-direction","comments":"\n      Moves the rectangle by a given amount. \n      @param dx the amount to move in the x-direction \n      @param dy the amount to move in the y-direction \n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"moveRectangleBy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    scene.moveRectangleBy(1, 1);\n}\n","name":"actionPerformed","className":"TimerListener","variables":{"scene":1},"constants":{"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RectangleFrame","methodCalls":{"add":1,"setSize":1,"start":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables","PolyMorphism"],"types":{"ActionListener":1,"Timer":1,"TimerListener":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":13,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":7},"text":"public RectangleFrame() {\n    scene = new RectangleComponent();\n    add(scene);\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    ActionListener listener = new TimerListener();\n    // Milliseconds between timer ticks\n    final int DELAY = 100;\n    Timer t = new Timer(DELAY, listener);\n    t.start();\n}\n","name":"RectangleFrame","className":"RectangleFrame","variables":{"t":2,"listener":2,"DELAY":2,"scene":1},"constants":{"100":1},"javaDoc":"","comments":"Milliseconds between timer ticks ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    double newBalance = balance + amount;\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    double newBalance = balance - amount;\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getBalance":2,"deposit":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent event) {\n    // The listener method accesses the account variable\n    // from the surrounding block\n    double interest = account.getBalance() * INTEREST_RATE / 100;\n    account.deposit(interest);\n    System.out.println(\"balance: \" + account.getBalance());\n}\n","name":"actionPerformed","className":"AddInterestListener","variables":{"interest":1,"INTEREST_RATE":1,"account":3},"constants":{"100":1,"\"balance: \"":1},"javaDoc":"","comments":"The listener method accesses the account variable from the surrounding block ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"getBalance":2,"setSize":1,"addActionListener":1,"deposit":1,"setDefaultCloseOperation":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"JFrame":1,"double":1,"AddInterestListener":1,"JButton":1,"BankAccount":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":3,"BooleanLiteralExpr":1,"StringLiteralExpr":2,"NameExpr":43,"FieldAccessExpr":2,"MethodCallExpr":9},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    // The button to trigger the calculation\n    JButton button = new JButton(\"Add Interest\");\n    frame.add(button);\n    // The application adds interest to this bank account\n    final BankAccount account = new BankAccount(INITIAL_BALANCE);\n    class AddInterestListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            // The listener method accesses the account variable\n            // from the surrounding block\n            double interest = account.getBalance() * INTEREST_RATE / 100;\n            account.deposit(interest);\n            System.out.println(\"balance: \" + account.getBalance());\n        }\n    }\n    ActionListener listener = new AddInterestListener();\n    button.addActionListener(listener);\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"InvestmentViewer1","variables":{"button":2,"actionPerformed":1,"interest":1,"AddInterestListener":1,"INTEREST_RATE":1,"listener":1,"INITIAL_BALANCE":1,"event":1,"account":4,"frame":5},"constants":{"100":1,"true":1,"\"Add Interest\"":1,"\"balance: \"":1},"javaDoc":"","comments":"The button to trigger the calculation The application adds interest to this bank account The listener method accesses the account variable from the surrounding block ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n// implementation—filled in later\n}\n","name":"BankAccount","className":"BankAccount","variables":{},"constants":{},"javaDoc":"Constructs a bank account with a zero balance","comments":"implementation—filled in later \n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n// implementation—filled in later\n}\n","name":"BankAccount","className":"BankAccount","variables":{},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"implementation—filled in later \n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n// implementation—filled in later\n}\n","name":"deposit","className":"BankAccount","variables":{},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"implementation—filled in later \n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n// implementation—filled in later\n}\n","name":"withdraw","className":"BankAccount","variables":{},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"implementation—filled in later \n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    // implementation—filled in later\n    return 0;\n}\n","name":"getBalance","className":"BankAccount","variables":{},"constants":{"0":1},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"implementation—filled in later \n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"CashRegister","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":4,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a cash register with no money in it.\n      @param rate the tax rate for taxable purchases\n   */\npublic CashRegister(double rate) {\n    taxRate = rate;\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"taxRate":1,"rate":1,"purchase":1,"payment":1},"constants":{"0":2},"javaDoc":"Constructs a cash register with no money in it rate the tax rate for taxable purchases","comments":"\n      Constructs a cash register with no money in it.\n      @param rate the tax rate for taxable purchases\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the sale of a tax-free item.\n      @param amount the price of the item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":1,"purchase":2},"constants":{},"javaDoc":"Records the sale of a tax-free item amount the price of the item","comments":"\n      Records the sale of a tax-free item.\n      @param amount the price of the item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the sale of a taxable item.\n      @param amount the price of the item\n   */\npublic void recordTaxablePurchase(double amount) {\n    taxablePurchase = taxablePurchase + amount;\n}\n","name":"recordTaxablePurchase","className":"CashRegister","variables":{"amount":1,"taxablePurchase":2},"constants":{},"javaDoc":"Records the sale of a taxable item amount the price of the item","comments":"\n      Records the sale of a taxable item.\n      @param amount the price of the item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   */\npublic void receivePayment(double amount) {\n    payment = payment + amount;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"amount":1,"payment":2},"constants":{},"javaDoc":"Processes a payment received from the customer amount the amount of the payment","comments":"\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Processes the sales tax due.\n      @return the sales tax due\n   */\npublic double getSalesTax() {\n    return taxablePurchase * taxRate / 100;\n}\n","name":"getSalesTax","className":"CashRegister","variables":{"taxRate":1,"taxablePurchase":1},"constants":{"100":1},"javaDoc":"Processes the sales tax due the sales tax due","comments":"\n      Processes the sales tax due.\n      @return the sales tax due\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":6,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase - get;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"get":1,"purchase":2,"payment":2},"constants":{"0":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":2,"receivePayment":1,"giveChange":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"CashRegister":1,"double":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"DoubleLiteralExpr":2,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(29.50);\n    register.recordPurchase(9.25);\n    register.receivePayment(50);\n    double change = register.giveChange();\n    System.out.println(change);\n    System.out.println(\"Expected: 11.25\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"change":1,"register":5},"constants":{"9.25":1,"29.50":1,"50":1,"\"Expected: 11.25\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getValue":2,"click":3,"System.out.print":2,"resetTo":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Counter":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":41,"StringLiteralExpr":2,"FieldAccessExpr":4,"MethodCallExpr":10,"AssignExpr":1},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Counter tally = new Counter();\n    tally.click();\n    tally.click();\n    // Sets result to 2\n    int result = tally.getValue();\n    System.out.print(\"result: \");\n    System.out.println(result);\n    tally.resetTo(10);\n    tally.click();\n    // Sets result to 11\n    result = tally.getValue();\n    System.out.print(\"result: \");\n    System.out.println(result);\n}\n","name":"main","className":"CounterDemo","variables":{"result":2,"tally":7},"constants":{"\"result: \"":2,"10":1},"javaDoc":"","comments":"Sets result to 2 Sets result to 11 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Advances the value of this counter by 1.\n   */\npublic void click() {\n    int updatedValue = value + 1;\n    // updatedValue is a local variable\n    value = updatedValue;\n// updatedValue is forgotten here\n}\n","name":"click","className":"Counter","variables":{"value":2,"updatedValue":2},"constants":{"1":1},"javaDoc":"Advances the value of this counter by 1","comments":"updatedValue is forgotten here updatedValue is a local variable \n      Advances the value of this counter by 1.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Resets the value of this counter to a given value.\n   */\npublic void resetTo(int newValue) // newValue is a parameter variable\n// newValue is initialized with the argument of a method call\n{\n    value = newValue;\n// newValue is forgotten here     \n}\n","name":"resetTo","className":"Counter","variables":{"newValue":1,"value":1},"constants":{},"javaDoc":"Resets the value of this counter to a given value","comments":"newValue is a parameter variable newValue is initialized with the argument of a method call newValue is forgotten here \n      Resets the value of this counter to a given value.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current value of this counter.\n      @return the current value\n   */\npublic int getValue() {\n    return value;\n}\n","name":"getValue","className":"Counter","variables":{"value":1},"constants":{},"javaDoc":"Gets the current value of this counter the current value","comments":"\n      Gets the current value of this counter.\n      @return the current value\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"ItalianFlag":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    ItalianFlag flag = new ItalianFlag(100, 100, 90);\n    flag.draw(g2);\n}\n","name":"paintComponent","className":"ItalianFlagComponent","variables":{"flag":2,"g":1,"g2":1},"constants":{"100":2,"90":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"ItalianFlag","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public ItalianFlag(int x, int y, int aWidth) {\n    xLeft = x;\n    yTop = y;\n    width = aWidth;\n}\n","name":"ItalianFlag","className":"ItalianFlag","variables":{"xLeft":1,"yTop":1,"aWidth":1,"x":1,"width":1,"y":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D"],"returnType":"void","methodCalls":{"setColor":3,"draw":2,"fill":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Line2D.Double":2,"Rectangle":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":18,"VariableDeclarationExpr":4,"BinaryExpr":25,"NameExpr":57,"FieldAccessExpr":3,"MethodCallExpr":7},"statements":{"ExpressionStmt":11},"text":"public void draw(Graphics2D g2) {\n    Rectangle leftRectangle = new Rectangle(xLeft, yTop, width / 3, width * 2 / 3);\n    Rectangle rightRectangle = new Rectangle(xLeft + 2 * width / 3, yTop, width / 3, width * 2 / 3);\n    Line2D.Double topLine = new Line2D.Double(xLeft + width / 3, yTop, xLeft + width * 2 / 3, yTop);\n    Line2D.Double bottomLine = new Line2D.Double(xLeft + width / 3, yTop + width * 2 / 3, xLeft + width * 2 / 3, yTop + width * 2 / 3);\n    g2.setColor(Color.GREEN);\n    g2.fill(leftRectangle);\n    g2.setColor(Color.RED);\n    g2.fill(rightRectangle);\n    g2.setColor(Color.BLACK);\n    g2.draw(topLine);\n    g2.draw(bottomLine);\n}\n","name":"draw","className":"ItalianFlag","variables":{"xLeft":6,"rightRectangle":1,"topLine":1,"leftRectangle":1,"yTop":6,"width":11,"g2":7,"bottomLine":1},"constants":{"2":7,"3":11},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"ItalianFlagComponent":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":16,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    ItalianFlagComponent component = new ItalianFlagComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"ItalianFlagViewer","variables":{"component":1,"frame":5},"constants":{"300":1,"400":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"constants":{"0":2},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the sale of an item.\n      @param amount the price of the item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":1,"purchase":2},"constants":{},"javaDoc":"Records the sale of an item amount the price of the item","comments":"\n      Records the sale of an item.\n      @param amount the price of the item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   */\npublic void receivePayment(double amount) {\n    payment = payment + amount;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"amount":1,"payment":2},"constants":{},"javaDoc":"Processes a payment received from the customer amount the amount of the payment","comments":"\n      Processes a payment received from the customer.\n      @param amount the amount of the payment\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":5,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"constants":{"0":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":2,"receivePayment":1,"giveChange":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"CashRegister":1,"double":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"DoubleLiteralExpr":2,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(29.50);\n    register.recordPurchase(9.25);\n    register.receivePayment(50);\n    double change = register.giveChange();\n    System.out.println(change);\n    System.out.println(\"Expected: 11.25\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"change":1,"register":5},"constants":{"9.25":1,"29.50":1,"50":1,"\"Expected: 11.25\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Menu","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":2,"StringLiteralExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a menu with no options.\n   */\npublic Menu() {\n    menuText = \"\";\n    optionCount = 0;\n}\n","name":"Menu","className":"Menu","variables":{"menuText":1,"optionCount":1},"constants":{"\"\"":1,"0":1},"javaDoc":"Constructs a menu with no options","comments":"\n      Constructs a menu with no options.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":5,"NameExpr":6,"StringLiteralExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Adds an option to the end of this menu.\n      @param option the option to add\n   */\npublic void addOption(String option) {\n    optionCount = optionCount + 1;\n    menuText = menuText + optionCount + \") \" + option + \"\\n\";\n}\n","name":"addOption","className":"Menu","variables":{"optionCount":3,"menuText":2,"option":1},"constants":{"1":1,"\") \"":1,"\"\\n\"":1},"javaDoc":"Adds an option to the end of this menu option the option to add","comments":"\n      Adds an option to the end of this menu.\n      @param option the option to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Displays the menu on the console.\n   */\npublic void display() {\n    System.out.println(menuText);\n}\n","name":"display","className":"Menu","variables":{},"constants":{},"javaDoc":"Displays the menu on the console","comments":"\n      Displays the menu on the console.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addOption":4,"display":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Menu":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":15,"StringLiteralExpr":4,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Menu mainMenu = new Menu();\n    mainMenu.addOption(\"Open new account\");\n    mainMenu.addOption(\"Log into existing account\");\n    mainMenu.addOption(\"Help\");\n    mainMenu.addOption(\"Quit\");\n    mainMenu.display();\n}\n","name":"main","className":"MenuDemo","variables":{"mainMenu":6},"constants":{"\"Open new account\"":1,"\"Quit\"":1,"\"Help\"":1,"\"Log into existing account\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getValue":1,"click":2,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Counter":1,"int":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Counter tally = new Counter();\n    tally.click();\n    tally.click();\n    // Sets result to 2\n    int result = tally.getValue();\n    System.out.print(\"result: \");\n    System.out.println(result);\n}\n","name":"main","className":"CounterDemo","variables":{"result":1,"tally":4},"constants":{"\"result: \"":1},"javaDoc":"","comments":"Sets result to 2 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current value of this counter.\n      @return the current value\n   */\npublic int getValue() {\n    return value;\n}\n","name":"getValue","className":"Counter","variables":{"value":1},"constants":{},"javaDoc":"Gets the current value of this counter the current value","comments":"\n      Gets the current value of this counter.\n      @return the current value\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Advances the value of this counter by 1.\n   */\npublic void click() {\n    value = value + 1;\n}\n","name":"click","className":"Counter","variables":{"value":2},"constants":{"1":1},"javaDoc":"Advances the value of this counter by 1","comments":"\n      Advances the value of this counter by 1.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Resets the value of this counter to 0.\n   */\npublic void reset() {\n    value = 0;\n}\n","name":"reset","className":"Counter","variables":{"value":1},"constants":{"0":1},"javaDoc":"Resets the value of this counter to 0","comments":"\n      Resets the value of this counter to 0.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Counter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a counter with a given value\n   */\npublic Counter(int value) {\n    this.value = value;\n// this. resolves the conflict between an instance variable\n// and a local variable with the same name\n}\n","name":"Counter","className":"Counter","variables":{"value":1},"constants":{},"javaDoc":"Constructs a counter with a given value","comments":"this resolves the conflict between an instance variable and a local variable with the same name \n      Constructs a counter with a given value\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Counter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public Counter() {\n    this(0);\n// Invokes the Counter(int value) constructor with value = 0\n}\n","name":"Counter","className":"Counter","variables":{},"constants":{"0":1},"javaDoc":"","comments":"Invokes the Counter(int value) constructor with value = 0 ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Advances the value of this counter by 1.\n   */\npublic void click() {\n    this.value = this.value + 1;\n// Using this makes it clear that the instance variable is updated\n}\n","name":"click","className":"Counter","variables":{},"constants":{"1":1},"javaDoc":"Advances the value of this counter by 1","comments":"Using this makes it clear that the instance variable is updated \n      Advances the value of this counter by 1.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getValue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the previous value of this counter.\n      @return the previous value\n   */\npublic int getPrevious() {\n    return getValue() - 1;\n// When you call a method without an object, it is invoked\n// on the this reference, i.e this.getValue().\n}\n","name":"getPrevious","className":"Counter","variables":{},"constants":{"1":1},"javaDoc":"Gets the previous value of this counter the previous value","comments":"When you call a method without an object it is invoked on the this reference i e this getValue() \n      Gets the previous value of this counter.\n      @return the previous value\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current value of this counter.\n      @return the current value\n   */\npublic int getValue() {\n    return value;\n// Or, if you prefer, return this.value;\n}\n","name":"getValue","className":"Counter","variables":{"value":1},"constants":{},"javaDoc":"Gets the current value of this counter the current value","comments":"Or if you prefer return this value; \n      Gets the current value of this counter.\n      @return the current value\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"CarComponent":1,"JFrame":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    frame.setSize(300, 400);\n    frame.setTitle(\"Two cars\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    CarComponent component = new CarComponent();\n    frame.add(component);\n    frame.setVisible(true);\n}\n","name":"main","className":"CarViewer","variables":{"component":1,"frame":6},"constants":{"300":1,"400":1,"true":1,"\"Two cars\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"Car","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a car with a given top left corner.\n      @param x the x coordinate of the top left corner\n      @param y the y coordinate of the top left corner\n   */\npublic Car(int x, int y) {\n    xLeft = x;\n    yTop = y;\n}\n","name":"Car","className":"Car","variables":{"xLeft":1,"yTop":1,"x":1,"y":1},"constants":{},"javaDoc":"Constructs a car with a given top left corner x the x coordinate of the top left corner y the y coordinate of the top left corner","comments":"\n      Constructs a car with a given top left corner.\n      @param x the x coordinate of the top left corner\n      @param y the y coordinate of the top left corner\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D"],"returnType":"void","methodCalls":{"draw":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"Line2D.Double":3,"Rectangle":1,"Ellipse2D.Double":2,"Point2D.Double":4},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":17,"VariableDeclarationExpr":10,"BinaryExpr":11,"NameExpr":44,"MethodCallExpr":6},"statements":{"ExpressionStmt":16},"text":"/**\n      Draws the car.\n      @param g2 the graphics context\n   */\npublic void draw(Graphics2D g2) {\n    Rectangle body = new Rectangle(xLeft, yTop + 10, 60, 10);\n    Ellipse2D.Double frontTire = new Ellipse2D.Double(xLeft + 10, yTop + 20, 10, 10);\n    Ellipse2D.Double rearTire = new Ellipse2D.Double(xLeft + 40, yTop + 20, 10, 10);\n    // The bottom of the front windshield\n    Point2D.Double r1 = new Point2D.Double(xLeft + 10, yTop + 10);\n    // The front of the roof\n    Point2D.Double r2 = new Point2D.Double(xLeft + 20, yTop);\n    // The rear of the roof\n    Point2D.Double r3 = new Point2D.Double(xLeft + 40, yTop);\n    // The bottom of the rear windshield\n    Point2D.Double r4 = new Point2D.Double(xLeft + 50, yTop + 10);\n    Line2D.Double frontWindshield = new Line2D.Double(r1, r2);\n    Line2D.Double roofTop = new Line2D.Double(r2, r3);\n    Line2D.Double rearWindshield = new Line2D.Double(r3, r4);\n    g2.draw(body);\n    g2.draw(frontTire);\n    g2.draw(rearTire);\n    g2.draw(frontWindshield);\n    g2.draw(roofTop);\n    g2.draw(rearWindshield);\n}\n","name":"draw","className":"Car","variables":{"xLeft":7,"r2":3,"r3":3,"r4":2,"rearTire":1,"yTop":7,"rearWindshield":1,"g2":6,"body":1,"frontTire":1,"frontWindshield":1,"roofTop":1,"r1":2},"constants":{"60":1,"50":1,"40":2,"20":3,"10":10},"javaDoc":"Draws the car g2 the graphics context","comments":"The bottom of the front windshield The front of the roof The rear of the roof The bottom of the rear windshield \n      Draws the car.\n      @param g2 the graphics context\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getHeight":1,"getWidth":1,"draw":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Car":2,"int":2,"Graphics2D":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"BinaryExpr":2,"CastExpr":1,"NameExpr":15,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"public void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    Car car1 = new Car(0, 0);\n    int x = getWidth() - 60;\n    int y = getHeight() - 30;\n    Car car2 = new Car(x, y);\n    car1.draw(g2);\n    car2.draw(g2);\n}\n","name":"paintComponent","className":"CarComponent","variables":{"car2":2,"car1":2,"g":1,"x":2,"y":2,"g2":1},"constants":{"0":2,"60":1,"30":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1,"withdraw":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"/**\n      Tests the methods of the BankAccount class.\n      @param args not used\n   */\npublic static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount();\n    harrysChecking.deposit(2000);\n    harrysChecking.withdraw(500);\n    System.out.println(harrysChecking.getBalance());\n    System.out.println(\"Expected: 1500\");\n}\n","name":"main","className":"BankAccountTester","variables":{"harrysChecking":4},"constants":{"500":1,"2000":1,"\"Expected: 1500\"":1},"javaDoc":"Tests the methods of the BankAccount class args not used","comments":"\n      Tests the methods of the BankAccount class.\n      @param args not used\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"isPalindrome":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":2,"StringLiteralExpr":4,"NameExpr":28,"FieldAccessExpr":4,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    String sentence1 = \"Madam, I'm Adam!\";\n    System.out.println(sentence1);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence1));\n    String sentence2 = \"Sir, I'm Eve!\";\n    System.out.println(sentence2);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence2));\n}\n","name":"main","className":"Palindromes","variables":{"sentence1":1,"sentence2":1},"constants":{"\"Madam, I'm Adam!\"":1,"\"Palindrome: \"":2,"\"Sir, I'm Eve!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"isPalindrome":1,"length":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   */\npublic static boolean isPalindrome(String text) {\n    return isPalindrome(text, 0, text.length() - 1);\n}\n","name":"isPalindrome","className":"Palindromes","variables":{"text":1},"constants":{"0":1,"1":1},"javaDoc":"Tests whether a text is a palindrome text a string that is being checked true if text is a palindrome false otherwise","comments":"\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int","int"],"returnType":"boolean","methodCalls":{"isPalindrome":3,"toLowerCase":2,"charAt":2,"isLetter":3},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"char":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":7,"BooleanLiteralExpr":2,"NameExpr":45,"UnaryExpr":1,"MethodCallExpr":10},"statements":{"IfStmt":4,"BlockStmt":7,"ReturnStmt":5,"ExpressionStmt":2},"text":"/**\n      Tests whether a substring is a palindrome.\n      @param text a string that is being checked\n      @param start the index of the first character of the substring\n      @param end the index of the last character of the substring\n      @return true if the substring is a palindrome\n   */\npublic static boolean isPalindrome(String text, int start, int end) {\n    // Separate case for substrings of length 0 and 1.\n    if (start >= end) {\n        return true;\n    } else {\n        // Get first and last characters, converted to lowercase.\n        char first = Character.toLowerCase(text.charAt(start));\n        char last = Character.toLowerCase(text.charAt(end));\n        if (Character.isLetter(first) && Character.isLetter(last)) {\n            if (first == last) {\n                // Test substring that doesn’t contain the matching letters.\n                return isPalindrome(text, start + 1, end - 1);\n            } else {\n                return false;\n            }\n        } else if (!Character.isLetter(last)) {\n            // Test substring that doesn’t contain the last character.\n            return isPalindrome(text, start, end - 1);\n        } else {\n            // Test substring that doesn’t contain the first character.\n            return isPalindrome(text, start + 1, end);\n        }\n    }\n}\n","name":"isPalindrome","className":"Palindromes","variables":{"Character":5,"last":2,"start":3,"end":3,"text":2,"first":2},"constants":{"1":4,"true":1,"false":1},"javaDoc":"Tests whether a substring is a palindrome text a string that is being checked start the index of the first character of the substring end the index of the last character of the substring true if the substring is a palindrome","comments":"Separate case for substrings of length 0 and 1 Get first and last characters converted to lowercase Test substring that doesn’t contain the matching letters Test substring that doesn’t contain the last character Test substring that doesn’t contain the first character \n      Tests whether a substring is a palindrome.\n      @param text a string that is being checked\n      @param start the index of the first character of the substring\n      @param end the index of the last character of the substring\n      @return true if the substring is a palindrome\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"Evaluator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an evaluator.\n      @param anExpression a string containing the expression\n      to be evaluated\n   */\npublic Evaluator(String anExpression) {\n    tokenizer = new ExpressionTokenizer(anExpression);\n}\n","name":"Evaluator","className":"Evaluator","variables":{"anExpression":1,"tokenizer":1},"constants":{},"javaDoc":"Constructs an evaluator anExpression a string containing the expression to be evaluated","comments":"\n      Constructs an evaluator.\n      @param anExpression a string containing the expression\n      to be evaluated\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"nextToken":1,"peekToken":1,"getTermValue":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"String":1,"int":2},"expressions":{"VariableDeclarationExpr":4,"BooleanLiteralExpr":2,"BinaryExpr":3,"NameExpr":28,"StringLiteralExpr":3,"UnaryExpr":1,"MethodCallExpr":7,"AssignExpr":3},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Evaluates the expression.\n      @return the value of the expression.\n   */\npublic int getExpressionValue() {\n    int value = getTermValue();\n    boolean done = false;\n    while (!done) {\n        String next = tokenizer.peekToken();\n        if (\"+\".equals(next) || \"-\".equals(next)) {\n            // Discard \"+\" or \"-\"\n            tokenizer.nextToken();\n            int value2 = getTermValue();\n            if (\"+\".equals(next)) {\n                value = value + value2;\n            } else {\n                value = value - value2;\n            }\n        } else {\n            done = true;\n        }\n    }\n    return value;\n}\n","name":"getExpressionValue","className":"Evaluator","variables":{"next":1,"value2":3,"value":6,"done":3,"tokenizer":2},"constants":{"\"-\"":1,"false":1,"true":1,"\"+\"":2},"javaDoc":"Evaluates the expression the value of the expression","comments":"Discard \"+\" or \"-\" \n      Evaluates the expression.\n      @return the value of the expression.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getFactorValue":2,"nextToken":1,"peekToken":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"String":1,"int":2},"expressions":{"VariableDeclarationExpr":4,"BooleanLiteralExpr":2,"BinaryExpr":3,"NameExpr":28,"StringLiteralExpr":3,"UnaryExpr":1,"MethodCallExpr":7,"AssignExpr":3},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Evaluates the next term found in the expression.\n      @return the value of the term\n   */\npublic int getTermValue() {\n    int value = getFactorValue();\n    boolean done = false;\n    while (!done) {\n        String next = tokenizer.peekToken();\n        if (\"*\".equals(next) || \"/\".equals(next)) {\n            tokenizer.nextToken();\n            int value2 = getFactorValue();\n            if (\"*\".equals(next)) {\n                value = value * value2;\n            } else {\n                value = value / value2;\n            }\n        } else {\n            done = true;\n        }\n    }\n    return value;\n}\n","name":"getTermValue","className":"Evaluator","variables":{"next":1,"value2":3,"value":6,"done":3,"tokenizer":2},"constants":{"\"/\"":1,"false":1,"true":1,"\"*\"":2},"javaDoc":"Evaluates the next term found in the expression the value of the term","comments":"\n      Evaluates the next term found in the expression.\n      @return the value of the term\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"parseInt":1,"nextToken":3,"peekToken":1,"getExpressionValue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":23,"StringLiteralExpr":1,"MethodCallExpr":7,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n      Evaluates the next factor found in the expression.\n      @return the value of the factor\n   */\npublic int getFactorValue() {\n    int value;\n    String next = tokenizer.peekToken();\n    if (\"(\".equals(next)) {\n        // Discard \"(\"\n        tokenizer.nextToken();\n        value = getExpressionValue();\n        // Discard \")\"\n        tokenizer.nextToken();\n    } else {\n        value = Integer.parseInt(tokenizer.nextToken());\n    }\n    return value;\n}\n","name":"getFactorValue","className":"Evaluator","variables":{"next":1,"Integer":1,"value":4,"tokenizer":4},"constants":{"\"(\"":1},"javaDoc":"Evaluates the next factor found in the expression the value of the factor","comments":"Discard \"(\" Discard \")\" \n      Evaluates the next factor found in the expression.\n      @return the value of the factor\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"ExpressionTokenizer","methodCalls":{"nextToken":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":6,"AssignExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a tokenizer.\n      @param anInput the string to tokenize\n   */\npublic ExpressionTokenizer(String anInput) {\n    input = anInput;\n    start = 0;\n    end = 0;\n    // Find the first token\n    nextToken();\n}\n","name":"ExpressionTokenizer","className":"ExpressionTokenizer","variables":{"input":1,"anInput":1,"start":1,"end":1},"constants":{"0":2},"javaDoc":"Constructs a tokenizer anInput the string to tokenize","comments":"Find the first token \n      Constructs a tokenizer.\n      @param anInput the string to tokenize\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"length":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":9,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Peeks at the next token without consuming it.\n      @return the next token or null if there are no more tokens\n   */\npublic String peekToken() {\n    if (start >= input.length()) {\n        return null;\n    } else {\n        return input.substring(start, end);\n    }\n}\n","name":"peekToken","className":"ExpressionTokenizer","variables":{"input":2,"start":1},"constants":{"null":1},"javaDoc":"Peeks at the next token without consuming it the next token or null if there are no more tokens","comments":"\n      Peeks at the next token without consuming it.\n      @return the next token or null if there are no more tokens\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"peekToken":1,"length":2,"isDigit":2,"charAt":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":33,"UnaryExpr":1,"MethodCallExpr":7,"AssignExpr":3},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":5},"text":"/**\n      Gets the next token and moves the tokenizer to the following token.\n      @return the next token or null if there are no more tokens\n   */\npublic String nextToken() {\n    String r = peekToken();\n    start = end;\n    if (start >= input.length()) {\n        return r;\n    }\n    if (Character.isDigit(input.charAt(start))) {\n        end = start + 1;\n        while (end < input.length() && Character.isDigit(input.charAt(end))) {\n            end++;\n        }\n    } else {\n        end = start + 1;\n    }\n    return r;\n}\n","name":"nextToken","className":"ExpressionTokenizer","variables":{"input":4,"r":3,"Character":2,"start":4,"end":5},"constants":{"1":2},"javaDoc":"Gets the next token and moves the tokenizer to the following token the next token or null if there are no more tokens","comments":"\n      Gets the next token and moves the tokenizer to the following token.\n      @return the next token or null if there are no more tokens\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"getExpressionValue":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":1,"Evaluator":1,"int":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter an expression: \");\n    String input = in.nextLine();\n    Evaluator e = new Evaluator(input);\n    int value = e.getExpressionValue();\n    System.out.println(input + \"=\" + value);\n}\n","name":"main","className":"ExpressionCalculator","variables":{"input":3,"in":2,"e":2,"value":2},"constants":{"\"Enter an expression: \"":1,"\"=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"solve":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    solve(new PartialSolution(0));\n}\n","name":"main","className":"EightQueens","variables":{},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["PartialSolution"],"returnType":"void","methodCalls":{"extend":1,"examine":1,"solve":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"PartialSolution":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":23,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":3,"ForeachStmt":1,"ExpressionStmt":3},"text":"/**\n      Prints all solutions to the problem that can be extended from \n      a given partial solution.\n      @param sol the partial solution\n   */\npublic static void solve(PartialSolution sol) {\n    int exam = sol.examine();\n    if (exam == PartialSolution.ACCEPT) {\n        System.out.println(sol);\n    } else if (exam == PartialSolution.CONTINUE) {\n        for (PartialSolution p : sol.extend()) {\n            solve(p);\n        }\n    }\n}\n","name":"solve","className":"EightQueens","variables":{"exam":3,"p":1,"sol":2},"constants":{},"javaDoc":"Prints all solutions to the problem that can be extended from a given partial solution sol the partial solution","comments":"\n      Prints all solutions to the problem that can be extended from \n      a given partial solution.\n      @param sol the partial solution\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"PartialSolution","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a partial solution of a given size.\n      @param size the size\n   */\npublic PartialSolution(int size) {\n    queens = new Queen[size];\n}\n","name":"PartialSolution","className":"PartialSolution","variables":{"size":1,"queens":1},"constants":{},"javaDoc":"Constructs a partial solution of a given size size the size","comments":"\n      Constructs a partial solution of a given size.\n      @param size the size\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":24,"FieldAccessExpr":3,"UnaryExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":2,"BlockStmt":5,"ForStmt":2,"ReturnStmt":3},"text":"/**\n      Examines a partial solution.\n      @return one of ACCEPT, ABANDON, CONTINUE\n   */\npublic int examine() {\n    for (int i = 0; i < queens.length; i++) {\n        for (int j = i + 1; j < queens.length; j++) {\n            if (queens[i].attacks(queens[j])) {\n                return ABANDON;\n            }\n        }\n    }\n    if (queens.length == NQUEENS) {\n        return ACCEPT;\n    } else {\n        return CONTINUE;\n    }\n}\n","name":"examine","className":"PartialSolution","variables":{"CONTINUE":1,"ACCEPT":1,"ABANDON":1,"i":5,"j":4,"queens":2,"NQUEENS":1},"constants":{"0":1,"1":1},"javaDoc":"Examines a partial solution one of ACCEPT ABANDON CONTINUE","comments":"\n      Examines a partial solution.\n      @return one of ACCEPT, ABANDON, CONTINUE\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"PartialSolution[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"PartialSolution[]":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":3,"NameExpr":30,"FieldAccessExpr":4,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":3},"statements":{"BlockStmt":2,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Yields all extensions of this partial solution.\n      @return an array of partial solutions that extend this solution.\n   */\npublic PartialSolution[] extend() {\n    // Generate a new solution for each column\n    PartialSolution[] result = new PartialSolution[NQUEENS];\n    for (int i = 0; i < result.length; i++) {\n        int size = queens.length;\n        // The new solution has one more row than this one\n        result[i] = new PartialSolution(size + 1);\n        // Copy this solution into the new one\n        for (int j = 0; j < size; j++) {\n            result[i].queens[j] = queens[j];\n        }\n        // Append the new queen into the ith column\n        result[i].queens[size] = new Queen(size, i);\n    }\n    return result;\n}\n","name":"extend","className":"PartialSolution","variables":{"result":5,"size":5,"i":7,"j":5,"queens":1,"NQUEENS":1},"constants":{"0":2,"1":1},"javaDoc":"Yields all extensions of this partial solution an array of partial solutions that extend this solution","comments":"Generate a new solution for each column The new solution has one more row than this one Copy this solution into the new one Append the new queen into the ith column \n      Yields all extensions of this partial solution.\n      @return an array of partial solutions that extend this solution.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return Arrays.toString(queens);\n}\n","name":"toString","className":"PartialSolution","variables":{"Arrays":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Queen","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a queen at a given position.\n      @param r the row \n      @param c the column\n   */\npublic Queen(int r, int c) {\n    row = r;\n    column = c;\n}\n","name":"Queen","className":"Queen","variables":{"r":1,"c":1,"column":1,"row":1},"constants":{},"javaDoc":"Constructs a queen at a given position r the row c the column","comments":"\n      Constructs a queen at a given position.\n      @param r the row \n      @param c the column\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Queen"],"returnType":"boolean","methodCalls":{"abs":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":7,"NameExpr":22,"FieldAccessExpr":4,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this queen attacks another.\n      @param other the other queen\n      @return true if this and the other queen are in the same\n      row, column, or diagonal.\n   */\npublic boolean attacks(Queen other) {\n    return row == other.row || column == other.column || Math.abs(row - other.row) == Math.abs(column - other.column);\n}\n","name":"attacks","className":"Queen","variables":{"column":2,"row":2,"Math":2},"constants":{},"javaDoc":"Checks whether this queen attacks another other the other queen true if this and the other queen are in the same row column or diagonal","comments":"\n      Checks whether this queen attacks another.\n      @param other the other queen\n      @return true if this and the other queen are in the same\n      row, column, or diagonal.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":4,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"\" + \"abcdefgh\".charAt(column) + (row + 1);\n}\n","name":"toString","className":"Queen","variables":{"row":1},"constants":{"\"\"":1,"1":1,"\"abcdefgh\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"fib":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":2,"long":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":24,"StringLiteralExpr":3,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter n: \");\n    int n = in.nextInt();\n    for (int i = 1; i <= n; i++) {\n        long f = fib(i);\n        System.out.println(\"fib(\" + i + \") = \" + f);\n    }\n}\n","name":"main","className":"RecursiveFib","variables":{"in":2,"f":2,"i":4,"n":2},"constants":{"1":1,"\") = \"":1,"\"fib(\"":1,"\"Enter n: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"long","methodCalls":{"fib":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":4,"BinaryExpr":4,"NameExpr":7,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   */\npublic static long fib(int n) {\n    if (n <= 2) {\n        return 1;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n","name":"fib","className":"RecursiveFib","variables":{"n":3},"constants":{"1":2,"2":2},"javaDoc":"Computes a Fibonacci number n an integer the nth Fibonacci number","comments":"\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"isPalindrome":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":2,"StringLiteralExpr":4,"NameExpr":28,"FieldAccessExpr":4,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    String sentence1 = \"Madam, I'm Adam!\";\n    System.out.println(sentence1);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence1));\n    String sentence2 = \"Sir, I'm Eve!\";\n    System.out.println(sentence2);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence2));\n}\n","name":"main","className":"LoopPalindromes","variables":{"sentence1":1,"sentence2":1},"constants":{"\"Madam, I'm Adam!\"":1,"\"Palindrome: \"":2,"\"Sir, I'm Eve!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"toLowerCase":2,"length":1,"charAt":2,"isLetter":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"char":2,"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":4,"BooleanLiteralExpr":2,"NameExpr":41,"UnaryExpr":6,"MethodCallExpr":9},"statements":{"IfStmt":4,"WhileStmt":1,"BlockStmt":6,"ReturnStmt":2,"ExpressionStmt":8},"text":"/**\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   */\npublic static boolean isPalindrome(String text) {\n    int start = 0;\n    int end = text.length() - 1;\n    while (start < end) {\n        char first = Character.toLowerCase(text.charAt(start));\n        char last = Character.toLowerCase(text.charAt(end));\n        if (Character.isLetter(first) && Character.isLetter(last)) {\n            // Both are letters.\n            if (first == last) {\n                start++;\n                end--;\n            } else {\n                return false;\n            }\n        }\n        if (!Character.isLetter(last)) {\n            end--;\n        }\n        if (!Character.isLetter(first)) {\n            start++;\n        }\n    }\n    return true;\n}\n","name":"isPalindrome","className":"LoopPalindromes","variables":{"Character":6,"last":2,"start":4,"end":4,"text":3,"first":2},"constants":{"0":1,"1":1,"false":1,"true":1},"javaDoc":"Tests whether a text is a palindrome text a string that is being checked true if text is a palindrome false otherwise","comments":"Both are letters \n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"fib":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":2,"long":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":24,"StringLiteralExpr":3,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter n: \");\n    int n = in.nextInt();\n    for (int i = 1; i <= n; i++) {\n        long f = fib(i);\n        System.out.println(\"fib(\" + i + \") = \" + f);\n    }\n}\n","name":"main","className":"LoopFib","variables":{"in":2,"f":2,"i":4,"n":2},"constants":{"1":1,"\") = \"":1,"\"fib(\"":1,"\"Enter n: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"long","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":3,"int":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":12,"UnaryExpr":1,"AssignExpr":3},"statements":{"IfStmt":1,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":6},"text":"/**\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   */\npublic static long fib(int n) {\n    if (n <= 2) {\n        return 1;\n    } else {\n        long olderValue = 1;\n        long oldValue = 1;\n        long newValue = 1;\n        for (int i = 3; i <= n; i++) {\n            newValue = oldValue + olderValue;\n            olderValue = oldValue;\n            oldValue = newValue;\n        }\n        return newValue;\n    }\n}\n","name":"fib","className":"LoopFib","variables":{"newValue":4,"i":3,"oldValue":4,"n":2,"olderValue":3},"constants":{"1":4,"2":1,"3":1},"javaDoc":"Computes a Fibonacci number n an integer the nth Fibonacci number","comments":"\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.print":1,"fib":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int":1,"long":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter n: \");\n    int n = in.nextInt();\n    long f = fib(n);\n    System.out.println(\"fib(\" + n + \") = \" + f);\n}\n","name":"main","className":"RecursiveFibTracer","variables":{"in":2,"f":2,"n":2},"constants":{"\") = \"":1,"\"fib(\"":1,"\"Enter n: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"long","methodCalls":{"fib":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"long":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":8,"NameExpr":23,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   */\npublic static long fib(int n) {\n    System.out.println(\"Entering fib: n = \" + n);\n    long f;\n    if (n <= 2) {\n        f = 1;\n    } else {\n        f = fib(n - 1) + fib(n - 2);\n    }\n    System.out.println(\"Exiting fib: n = \" + n + \" return value = \" + f);\n    return f;\n}\n","name":"fib","className":"RecursiveFibTracer","variables":{"f":5,"n":5},"constants":{"1":2,"2":2,"\"Exiting fib: n = \"":1,"\" return value = \"":1,"\"Entering fib: n = \"":1},"javaDoc":"Computes a Fibonacci number n an integer the nth Fibonacci number","comments":"\n      Computes a Fibonacci number.\n      @param n an integer\n      @return the nth Fibonacci number\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"isPalindrome":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":2,"StringLiteralExpr":4,"NameExpr":28,"FieldAccessExpr":4,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    String sentence1 = \"Madam, I'm Adam!\";\n    System.out.println(sentence1);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence1));\n    String sentence2 = \"Sir, I'm Eve!\";\n    System.out.println(sentence2);\n    System.out.println(\"Palindrome: \" + isPalindrome(sentence2));\n}\n","name":"main","className":"Palindromes","variables":{"sentence1":1,"sentence2":1},"constants":{"\"Madam, I'm Adam!\"":1,"\"Palindrome: \"":2,"\"Sir, I'm Eve!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"isPalindrome":3,"toLowerCase":2,"length":1,"charAt":2,"isLetter":3,"substring":3},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"char":2,"String":3,"int":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":6,"BinaryExpr":6,"BooleanLiteralExpr":2,"NameExpr":51,"UnaryExpr":1,"MethodCallExpr":14},"statements":{"IfStmt":4,"BlockStmt":7,"ReturnStmt":5,"ExpressionStmt":6},"text":"/**\n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   */\npublic static boolean isPalindrome(String text) {\n    int length = text.length();\n    // Separate case for shortest strings. \n    if (length <= 1) {\n        return true;\n    } else {\n        // Get first and last characters, converted to lowercase. \n        char first = Character.toLowerCase(text.charAt(0));\n        char last = Character.toLowerCase(text.charAt(length - 1));\n        if (Character.isLetter(first) && Character.isLetter(last)) {\n            // Both are letters. \n            if (first == last) {\n                // Remove both first and last character. \n                String shorter = text.substring(1, length - 1);\n                return isPalindrome(shorter);\n            } else {\n                return false;\n            }\n        } else if (!Character.isLetter(last)) {\n            // Remove last character. \n            String shorter = text.substring(0, length - 1);\n            return isPalindrome(shorter);\n        } else {\n            // Remove first character. \n            String shorter = text.substring(1);\n            return isPalindrome(shorter);\n        }\n    }\n}\n","name":"isPalindrome","className":"Palindromes","variables":{"Character":5,"last":2,"length":5,"text":6,"first":2,"shorter":3},"constants":{"0":2,"1":6,"true":1,"false":1},"javaDoc":"Tests whether a text is a palindrome text a string that is being checked true if text is a palindrome false otherwise","comments":"Separate case for shortest strings Get first and last characters converted to lowercase Both are letters Remove both first and last character Remove last character Remove first character \n      Tests whether a text is a palindrome.\n      @param text a string that is being checked\n      @return true if text is a palindrome, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"find":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"File":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":2,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    File startingDirectory = new File(\"/home/myname\");\n    find(startingDirectory, \".java\");\n}\n","name":"main","className":"FileFinder2","variables":{"startingDirectory":1},"constants":{"\".java\"":1,"\"/home/myname\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["File","String"],"returnType":"void","methodCalls":{"find":1,"endsWith":1,"toString":1,"listFiles":1,"isDirectory":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"String":1,"File":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":23,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":2,"BlockStmt":4,"ForeachStmt":1,"ExpressionStmt":3},"text":"/**\n      Prints all files whose names end in a given extension.\n      @param aFile a file or directory\n      @param extension a file extension (such as \".java\")\n   */\npublic static void find(File aFile, String extension) {\n    if (aFile.isDirectory()) {\n        for (File child : aFile.listFiles()) {\n            find(child, extension);\n        }\n    } else {\n        String fileName = aFile.toString();\n        if (fileName.endsWith(extension)) {\n            System.out.println(fileName);\n        }\n    }\n}\n","name":"find","className":"FileFinder2","variables":{"fileName":2,"aFile":3,"child":1},"constants":{},"javaDoc":"Prints all files whose names end in a given extension aFile a file or directory extension a file extension (such as \" java\")","comments":"\n      Prints all files whose names end in a given extension.\n      @param aFile a file or directory\n      @param extension a file extension (such as \".java\")\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["File"],"returnType":"FileFinder","methodCalls":{"listFiles":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a file finder for a given directory tree.\n      @param startingDirectory the starting directory of the tree\n   */\npublic FileFinder(File startingDirectory) {\n    children = startingDirectory.listFiles();\n}\n","name":"FileFinder","className":"FileFinder","variables":{"startingDirectory":1,"children":1},"constants":{},"javaDoc":"Constructs a file finder for a given directory tree startingDirectory the starting directory of the tree","comments":"\n      Constructs a file finder for a given directory tree.\n      @param startingDirectory the starting directory of the tree\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"find":1,"endsWith":1,"toString":1,"isDirectory":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"FileFinder":1,"File":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":2,"BlockStmt":3,"ForeachStmt":1,"ExpressionStmt":4},"text":"/**\n      Prints all files whose names end in a given extension.\n      @param extension a file extension (such as \".java\")\n   */\npublic void find(String extension) {\n    for (File child : children) {\n        String fileName = child.toString();\n        if (child.isDirectory()) {\n            FileFinder finder = new FileFinder(child);\n            finder.find(extension);\n        } else if (fileName.endsWith(extension)) {\n            System.out.println(fileName);\n        }\n    }\n}\n","name":"find","className":"FileFinder","variables":{"fileName":2,"children":1,"child":4,"finder":2},"constants":{},"javaDoc":"Prints all files whose names end in a given extension extension a file extension (such as \" java\")","comments":"\n      Prints all files whose names end in a given extension.\n      @param extension a file extension (such as \".java\")\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"find":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"FileFinder":1,"File":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"StringLiteralExpr":2,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    File startingDirectory = new File(\"/home/myname\");\n    FileFinder finder = new FileFinder(startingDirectory);\n    finder.find(\".java\");\n}\n","name":"main","className":"FileFinderDemo","variables":{"startingDirectory":2,"finder":2},"constants":{"\".java\"":1,"\"/home/myname\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"Tower","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":8,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Constructs a tower holding a given number of disks of decreasing size.\n      @param ndisks the number of disks\n   */\npublic Tower(int ndisks) {\n    disks = new ArrayList<Integer>();\n    for (int d = ndisks; d >= 1; d--) {\n        disks.add(d);\n    }\n}\n","name":"Tower","className":"Tower","variables":{"disks":2,"d":3,"ndisks":1},"constants":{"1":1},"javaDoc":"Constructs a tower holding a given number of disks of decreasing size ndisks the number of disks","comments":"\n      Constructs a tower holding a given number of disks of decreasing size.\n      @param ndisks the number of disks\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"size":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n      Removes the top disk from this tower.\n      @return the size of the removed disk\n   */\npublic int remove() {\n    return disks.remove(disks.size() - 1);\n}\n","name":"remove","className":"Tower","variables":{"disks":2},"constants":{"1":1},"javaDoc":"Removes the top disk from this tower the size of the removed disk","comments":"\n      Removes the top disk from this tower.\n      @return the size of the removed disk\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"add":1,"size":2,"get":1},"annotations":[],"exceptions":["IllegalStateException"],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"BinaryExpr":4,"NameExpr":14,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n      Adds a disk to this tower.\n      @param size the size of the disk to add\n   */\npublic void add(int size) {\n    if (disks.size() > 0 && disks.get(disks.size() - 1) < size) {\n        throw new IllegalStateException(\"Disk is too large\");\n    }\n    disks.add(size);\n}\n","name":"add","className":"Tower","variables":{"disks":4,"size":1},"constants":{"0":1,"\"Disk is too large\"":1,"1":1},"javaDoc":"Adds a disk to this tower size the size of the disk to add","comments":"\n      Adds a disk to this tower.\n      @param size the size of the disk to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return disks.toString();\n}\n","name":"toString","className":"Tower","variables":{"disks":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    move(5, 1, 3);\n}\n","name":"main","className":"TowersOfHanoiInstructions","variables":{},"constants":{"1":1,"3":1,"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int","int"],"returnType":"void","methodCalls":{"move":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":8,"NameExpr":20,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n      Print instructions for moving a pile of disks from one peg to another.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   */\npublic static void move(int disks, int from, int to) {\n    if (disks > 0) {\n        int other = 6 - from - to;\n        move(disks - 1, from, other);\n        System.out.println(\"Move disk from peg \" + from + \" to \" + to);\n        move(disks - 1, other, to);\n    }\n}\n","name":"move","className":"TowersOfHanoiInstructions","variables":{"other":1,"disks":3,"from":2,"to":2},"constants":{"0":1,"1":2,"\"Move disk from peg \"":1,"\" to \"":1,"6":1},"javaDoc":"Print instructions for moving a pile of disks from one peg to another disks the number of disks to move from the peg from which to move the disks to the peg to which to move the disks","comments":"\n      Print instructions for moving a pile of disks from one peg to another.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"TowersOfHanoi":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    final int NDISKS = 5;\n    TowersOfHanoi towers = new TowersOfHanoi(NDISKS);\n    towers.move(NDISKS, 0, 2);\n}\n","name":"main","className":"TowersOfHanoiDemo","variables":{"NDISKS":2,"towers":2},"constants":{"0":1,"2":1,"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"TowersOfHanoi","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":3,"ArrayAccessExpr":3,"NameExpr":5,"ArrayCreationExpr":1,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a puzzle in which the first tower has a given number of disks.\n      @param ndisks the number of disks\n   */\npublic TowersOfHanoi(int ndisks) {\n    towers = new Tower[3];\n    towers[0] = new Tower(ndisks);\n    towers[1] = new Tower(0);\n    towers[2] = new Tower(0);\n}\n","name":"TowersOfHanoi","className":"TowersOfHanoi","variables":{"towers":4,"ndisks":1},"constants":{"0":3,"1":1,"2":1,"3":1},"javaDoc":"Constructs a puzzle in which the first tower has a given number of disks ndisks the number of disks","comments":"\n      Constructs a puzzle in which the first tower has a given number of disks.\n      @param ndisks the number of disks\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"void","methodCalls":{"move":2,"toString":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":30,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"/**\n      Moves a pile of disks from one peg to another and displays the movement.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   */\npublic void move(int disks, int from, int to) {\n    if (disks > 0) {\n        int other = 3 - from - to;\n        move(disks - 1, from, other);\n        towers[to].add(towers[from].remove());\n        System.out.println(Arrays.toString(towers));\n        move(disks - 1, other, to);\n    }\n}\n","name":"move","className":"TowersOfHanoi","variables":{"other":1,"disks":3,"from":2,"to":2,"Arrays":1,"towers":2},"constants":{"0":1,"1":2,"3":1},"javaDoc":"Moves a pile of disks from one peg to another and displays the movement disks the number of disks to move from the peg from which to move the disks to the peg to which to move the disks","comments":"\n      Moves a pile of disks from one peg to another and displays the movement.\n      @param disks the number of disks to move\n      @param from the peg from which to move the disks\n      @param to the peg to which to move the disks\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Triangle","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a triangular shape.\n      @param aWidth the width (and height) of the triangle\n   */\npublic Triangle(int aWidth) {\n    width = aWidth;\n}\n","name":"Triangle","className":"Triangle","variables":{"aWidth":1,"width":1},"constants":{},"javaDoc":"Constructs a triangular shape aWidth the width (and height) of the triangle","comments":"\n      Constructs a triangular shape.\n      @param aWidth the width (and height) of the triangle\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getArea":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Triangle":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":8,"MethodCallExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3,"ExpressionStmt":2},"text":"/**\n      Computes the area of the triangle.\n      @return the area\n   */\npublic int getArea() {\n    if (width <= 0) {\n        return 0;\n    } else if (width == 1) {\n        return 1;\n    } else {\n        Triangle smallerTriangle = new Triangle(width - 1);\n        int smallerArea = smallerTriangle.getArea();\n        return smallerArea + width;\n    }\n}\n","name":"getArea","className":"Triangle","variables":{"width":4,"smallerTriangle":2,"smallerArea":2},"constants":{"0":2,"1":3},"javaDoc":"Computes the area of the triangle the area","comments":"\n      Computes the area of the triangle.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getArea":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Triangle":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":14,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    Triangle t = new Triangle(10);\n    int area = t.getArea();\n    System.out.println(\"Area: \" + area);\n    System.out.println(\"Expected: 55\");\n}\n","name":"main","className":"TriangleTester","variables":{"area":2,"t":2},"constants":{"\"Area: \"":1,"\"Expected: 55\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"permutations":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    for (String s : permutations(\"eat\")) {\n        System.out.println(s);\n    }\n}\n","name":"main","className":"Permutations","variables":{"s":1},"constants":{"\"eat\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"ArrayList<String>","methodCalls":{"add":2,"length":2,"permutations":1,"substring":2,"charAt":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"ArrayList<String>":2,"String":2,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"BinaryExpr":5,"NameExpr":34,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":4,"ForeachStmt":1,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Gets all permutations of a given word.\n      @param word the string to permute\n      @return a list of all permutations\n   */\npublic static ArrayList<String> permutations(String word) {\n    ArrayList<String> result = new ArrayList<String>();\n    // The empty string has a single permutation: itself\n    if (word.length() == 0) {\n        result.add(word);\n        return result;\n    } else {\n        // Loop through all character positions\n        for (int i = 0; i < word.length(); i++) {\n            // Form a shorter word by removing the ith character\n            String shorter = word.substring(0, i) + word.substring(i + 1);\n            // Generate all permutations of the simpler word\n            ArrayList<String> shorterPermutations = permutations(shorter);\n            // each permutation of the simpler word, \n            for (String s : shorterPermutations) {\n                result.add(word.charAt(i) + s);\n            }\n        }\n        // Return all permutations\n        return result;\n    }\n}\n             // Add the removed character to the front of\n\n","name":"permutations","className":"Permutations","variables":{"result":5,"s":2,"i":4,"word":5,"shorterPermutations":2,"shorter":1},"constants":{"0":3,"1":1},"javaDoc":"Gets all permutations of a given word word the string to permute a list of all permutations","comments":"The empty string has a single permutation: itself Loop through all character positions Add the removed character to the front of Form a shorter word by removing the ith character Generate all permutations of the simpler word each permutation of the simpler word Return all permutations \n      Gets all permutations of a given word.\n      @param word the string to permute\n      @return a list of all permutations\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","String"],"returnType":"Coin","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a coin.\n      @param aValue the monetary value of the coin\n      @param aName the name of the coin\n   */\npublic Coin(double aValue, String aName) {\n    value = aValue;\n    name = aName;\n}\n","name":"Coin","className":"Coin","variables":{"aName":1,"name":1,"value":1,"aValue":1},"constants":{},"javaDoc":"Constructs a coin aValue the monetary value of the coin aName the name of the coin","comments":"\n      Constructs a coin.\n      @param aValue the monetary value of the coin\n      @param aName the name of the coin\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the coin value.\n      @return the value\n   */\npublic double getValue() {\n    return value;\n}\n","name":"getValue","className":"Coin","variables":{"value":1},"constants":{},"javaDoc":"Gets the coin value the value","comments":"\n      Gets the coin value.\n      @return the value\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the coin name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Coin","variables":{"name":1},"constants":{},"javaDoc":"Gets the coin name the name","comments":"\n      Gets the coin name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"constants":{"0":2},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":1,"purchase":2},"constants":{},"javaDoc":"Records the purchase price of an item amount the price of the purchased item","comments":"\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","Coin"],"returnType":"void","methodCalls":{"getValue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Enters the payment received from the customer.\n      @param coinCount the number of coins received\n      @param coinType the type of coin that was received\n   */\npublic void receivePayment(int coinCount, Coin coinType) {\n    payment = payment + coinCount * coinType.getValue();\n}\n","name":"receivePayment","className":"CashRegister","variables":{"coinType":1,"payment":2,"coinCount":1},"constants":{},"javaDoc":"Enters the payment received from the customer coinCount the number of coins received coinType the type of coin that was received","comments":"\n      Enters the payment received from the customer.\n      @param coinCount the number of coins received\n      @param coinType the type of coin that was received\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":5,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"constants":{"0":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"recordPurchase":2,"receivePayment":2,"giveChange":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Coin":2,"CashRegister":1,"double":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"DoubleLiteralExpr":4,"StringLiteralExpr":3,"NameExpr":28,"FieldAccessExpr":2,"MethodCallExpr":7},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    final Coin DOLLAR = new Coin(1.0, \"Dollar\");\n    final Coin QUARTER = new Coin(0.25, \"Quarter\");\n    CashRegister register = new CashRegister();\n    register.recordPurchase(1.95);\n    register.recordPurchase(1.40);\n    register.receivePayment(3, DOLLAR);\n    register.receivePayment(2, QUARTER);\n    double change = register.giveChange();\n    System.out.println(change);\n    System.out.println(\"Expected: 0.15\");\n}\n","name":"main","className":"CashRegisterTester","variables":{"QUARTER":1,"change":1,"DOLLAR":1,"register":6},"constants":{"2":1,"1.0":1,"3":1,"0.25":1,"\"Quarter\"":1,"\"Dollar\"":1,"\"Expected: 0.15\"":1,"1.95":1,"1.40":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"StringLiteralExpr":1},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n}\n","name":"main","className":"Gallery1","variables":{"PICTURES":1,"MAX_WIDTH":1,"GAP":1,"pic":1},"constants":{"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"getMaxX":1,"getBounds":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":2,"int":3},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":2,"VariableDeclarationExpr":5,"StringLiteralExpr":2,"NameExpr":8,"MethodCallExpr":3},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    Picture pic2 = new Picture(\"picture2.jpg\");\n    pic2.move(pic.getBounds().getMaxX(), 0);\n}\n","name":"main","className":"Gallery2","variables":{"PICTURES":1,"MAX_WIDTH":1,"GAP":1,"pic":2,"pic2":2},"constants":{"0":1,"\"picture2.jpg\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"getMaxX":1,"getBounds":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":2,"double":1,"int":4},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":2,"VariableDeclarationExpr":7,"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":16,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    for (int i = 2; i <= PICTURES; i++) {\n        Picture previous = pic;\n        pic = new Picture(\"picture\" + i + \".jpg\");\n        double x = previous.getBounds().getMaxX() + GAP;\n        pic.move(x, 0);\n    }\n}\n","name":"main","className":"Gallery4","variables":{"PICTURES":2,"previous":2,"MAX_WIDTH":1,"GAP":2,"x":1,"i":4,"pic":4},"constants":{"0":1,"2":1,"\".jpg\"":1,"\"picture\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":1,"getMaxX":1,"getBounds":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":2,"double":1,"int":3},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":2,"VariableDeclarationExpr":6,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":10,"MethodCallExpr":3},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    Picture pic2 = new Picture(\"picture2.jpg\");\n    double x = pic.getBounds().getMaxX() + GAP;\n    pic2.move(x, 0);\n}\n","name":"main","className":"Gallery3","variables":{"PICTURES":1,"MAX_WIDTH":1,"GAP":2,"x":1,"pic":2,"pic2":2},"constants":{"0":1,"\"picture2.jpg\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"Picture","methodCalls":{"setIcon":2,"read":2,"printStackTrace":1,"getPreferredSize":1,"show":1,"getInstance":1,"setBounds":1,"startsWith":1,"setText":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Dimension":1,"BufferedImage":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":48,"StringLiteralExpr":2,"FieldAccessExpr":3,"ThisExpr":2,"AssignExpr":3,"MethodCallExpr":12},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":11},"text":"/**\n      Constructs a picture from a given file or URL.\n      @param source the filename or URL\n   */\npublic Picture(String source) {\n    try {\n        this.source = source;\n        BufferedImage image;\n        if (source.startsWith(\"http://\")) {\n            image = ImageIO.read(new URL(source).openStream());\n        } else {\n            image = ImageIO.read(new File(source));\n        }\n        label.setIcon(new ImageIcon(image));\n        label.setText(\"\");\n        Dimension dim = label.getPreferredSize();\n        label.setBounds(0, 0, dim.width, dim.height);\n    } catch (Exception ex) {\n        label.setIcon(null);\n        ex.printStackTrace();\n    }\n    Canvas.getInstance().show(this);\n}\n","name":"Picture","className":"Picture","variables":{"image":4,"ex":2,"Canvas":1,"dim":1,"source":4,"label":5,"ImageIO":2},"constants":{"\"\"":1,"0":2,"null":1,"\"http://\"":1},"javaDoc":"Constructs a picture from a given file or URL source the filename or URL","comments":"\n      Constructs a picture from a given file or URL.\n      @param source the filename or URL\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Rectangle","methodCalls":{"round":2,"getBounds":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":15,"CastExpr":2,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Returns the bounds of this picture\n      @return the rectangle that contains the picture\n   */\npublic Rectangle getBounds() {\n    Rectangle r = label.getBounds();\n    r.translate((int) Math.round(x), (int) Math.round(y));\n    return r;\n}\n","name":"getBounds","className":"Picture","variables":{"r":3,"label":1,"Math":2},"constants":{},"javaDoc":"Returns the bounds of this picture the rectangle that contains the picture","comments":"\n      Returns the bounds of this picture\n      @return the rectangle that contains the picture\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{"getInstance":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Moves this picture by a given amount.\n      @param dx the amount by which to move in x-direction\n      @param dy the amount by which to move in y-direction\n   */\npublic void move(double dx, double dy) {\n    x += dx;\n    y += dy;\n    Canvas.getInstance().repaint();\n}\n","name":"move","className":"Picture","variables":{"dx":1,"dy":1,"Canvas":1,"x":1,"y":1},"constants":{},"javaDoc":"Moves this picture by a given amount dx the amount by which to move in x-direction dy the amount by which to move in y-direction","comments":"\n      Moves this picture by a given amount.\n      @param dx the amount by which to move in x-direction\n      @param dy the amount by which to move in y-direction\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"Picture[source=\" + source + \",bounds=\" + getBounds() + \"]\";\n}\n","name":"toString","className":"Picture","variables":{"source":1},"constants":{"\"]\"":1,"\",bounds=\"":1,"\"Picture[source=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D"],"returnType":"void","methodCalls":{"paint":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"private void paintShape(Graphics2D g2) {\n    g2.translate(x, y);\n    label.paint(g2);\n}\n","name":"paintShape","className":"Picture","variables":{"g2":1,"label":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getHeight":1,"setColor":1,"create":1,"dispose":1,"getWidth":1,"fillRect":1,"paintShape":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Picture":1,"Graphics2D":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"NameExpr":28,"CastExpr":1,"FieldAccessExpr":3,"MethodCallExpr":7},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":5},"text":"public void paintComponent(Graphics g) {\n    g.setColor(java.awt.Color.WHITE);\n    g.fillRect(0, 0, getWidth(), getHeight());\n    for (Picture s : pictures) {\n        Graphics2D g2 = (Graphics2D) g.create();\n        s.paintShape(g2);\n        g2.dispose();\n    }\n}\n","name":"paintComponent","className":"CanvasComponent","variables":{"s":2,"g":3,"g2":2,"pictures":1},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"getX":1,"getHeight":1,"getY":1,"max":2,"getWidth":1,"getBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Picture":1,"Rectangle":1,"int":2},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":30,"CastExpr":2,"MethodCallExpr":7,"AssignExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"public Dimension getPreferredSize() {\n    int maxx = MIN_SIZE;\n    int maxy = MIN_SIZE;\n    for (Picture s : pictures) {\n        Rectangle r = s.getBounds();\n        maxx = (int) Math.max(maxx, r.getX() + r.getWidth());\n        maxy = (int) Math.max(maxy, r.getY() + r.getHeight());\n    }\n    return new Dimension(maxx, maxy);\n}\n","name":"getPreferredSize","className":"CanvasComponent","variables":{"MIN_SIZE":2,"r":5,"s":2,"maxy":3,"maxx":3,"Math":2,"pictures":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"getState":1,"printStackTrace":1,"saveToDisk":1},"annotations":[],"exceptions":["Exception"],"concepts":["FinalVariables","ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":18,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":4},"text":"public void run() {\n    try {\n        final int DELAY = 10;\n        while (currentThread.getState() != Thread.State.TERMINATED) {\n            Thread.sleep(DELAY);\n        }\n        saveToDisk(SAVEFILE);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"run","className":"","variables":{"currentThread":1,"ex":2,"DELAY":1,"Thread":1},"constants":{"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Canvas","methodCalls":{"add":1,"setVisible":1,"currentThread":1,"getProperty":2,"printStackTrace":1,"start":1,"saveToDisk":1,"pack":1,"sleep":1,"contains":1,"getState":1,"setLocation":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"String":1,"int":1,"Thread":2},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":56,"StringLiteralExpr":4,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":14,"AssignExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":7,"TryStmt":1,"ExpressionStmt":14},"text":"private Canvas() {\n    if (System.getProperty(\"com.horstmann.codecheck\") == null) {\n        frame = new JFrame();\n        if (!System.getProperty(\"java.class.path\").contains(\"bluej\")) {\n            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        }\n        frame.add(component);\n        frame.pack();\n        frame.setLocation(LOCATION_OFFSET, LOCATION_OFFSET);\n        frame.setVisible(true);\n    } else {\n        final String SAVEFILE = \"canvas.png\";\n        final Thread currentThread = Thread.currentThread();\n        Thread watcherThread = new Thread() {\n\n            public void run() {\n                try {\n                    final int DELAY = 10;\n                    while (currentThread.getState() != Thread.State.TERMINATED) {\n                        Thread.sleep(DELAY);\n                    }\n                    saveToDisk(SAVEFILE);\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        };\n        watcherThread.start();\n    }\n}\n","name":"Canvas","className":"Canvas","variables":{"currentThread":2,"ex":2,"watcherThread":2,"run":1,"SAVEFILE":1,"DELAY":1,"System":2,"frame":6,"Thread":2},"constants":{"\"com.horstmann.codecheck\"":1,"\"bluej\"":1,"null":1,"\"java.class.path\"":1,"true":1,"\"canvas.png\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"Canvas","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public static Canvas getInstance() {\n    return canvas;\n}\n","name":"getInstance","className":"Canvas","variables":{"canvas":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Picture"],"returnType":"void","methodCalls":{"add":1,"contains":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"public void show(Picture s) {\n    if (!pictures.contains(s)) {\n        pictures.add(s);\n    }\n    repaint();\n}\n","name":"show","className":"Canvas","variables":{"pictures":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getHeight":2,"getPreferredSize":1,"getWidth":2,"repaint":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Dimension":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":22,"MethodCallExpr":7},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":1,"ExpressionStmt":3},"text":"public void repaint() {\n    if (frame == null) {\n        return;\n    }\n    Dimension dim = component.getPreferredSize();\n    if (dim.getWidth() > component.getWidth() || dim.getHeight() > component.getHeight()) {\n        frame.pack();\n    } else {\n        frame.repaint();\n    }\n}\n","name":"repaint","className":"Canvas","variables":{"component":3,"dim":3,"frame":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"lastIndexOf":1,"setColor":2,"getPreferredSize":1,"paintComponent":1,"javax.swing.JOptionPane.showMessageDialog":1,"getMessage":1,"dispose":1,"getGraphics":1,"fill":1,"System.err.println":1,"write":1,"substring":1},"annotations":[],"exceptions":["Throwable"],"concepts":["Casting","ExceptionHandling"],"types":{"java.awt.Rectangle":1,"Dimension":1,"String":1,"BufferedImage":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":2,"NameExpr":80,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":14,"CharLiteralExpr":1,"MethodCallExpr":13},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":13},"text":"public void saveToDisk(String fileName) {\n    try {\n        Dimension dim = component.getPreferredSize();\n        java.awt.Rectangle rect = new java.awt.Rectangle(0, 0, dim.width, dim.height);\n        BufferedImage image = new BufferedImage(rect.width, rect.height, BufferedImage.TYPE_INT_RGB);\n        Graphics2D g = (Graphics2D) image.getGraphics();\n        g.setColor(java.awt.Color.WHITE);\n        g.fill(rect);\n        g.setColor(java.awt.Color.BLACK);\n        component.paintComponent(g);\n        String extension = fileName.substring(fileName.lastIndexOf('.') + 1);\n        ImageIO.write(image, extension, new File(fileName));\n        g.dispose();\n    } catch (Throwable e) {\n        javax.swing.JOptionPane.showMessageDialog(null, e.getMessage());\n        System.err.println(\"Was unable to save the image to \" + fileName);\n    }\n}\n","name":"saveToDisk","className":"Canvas","variables":{"rect":1,"image":2,"component":2,"extension":1,"fileName":4,"e":2,"g":5,"dim":1,"ImageIO":1},"constants":{"0":2,"'.'":1,"\"Was unable to save the image to \"":1,"1":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":2,"getY":1,"max":1,"getMaxX":1,"getMaxY":1,"getWidth":1,"getBounds":4},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":2,"double":2,"int":4},"expressions":{"IntegerLiteralExpr":7,"ObjectCreationExpr":2,"VariableDeclarationExpr":8,"BinaryExpr":7,"StringLiteralExpr":3,"NameExpr":42,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    double maxY = 0;\n    for (int i = 2; i <= 20; i++) {\n        maxY = Math.max(maxY, pic.getBounds().getMaxY());\n        Picture previous = pic;\n        pic = new Picture(\"picture\" + i + \".jpg\");\n        double x = previous.getBounds().getMaxX() + GAP;\n        if (x + pic.getBounds().getWidth() < MAX_WIDTH) {\n            pic.move(x, previous.getBounds().getY());\n        } else {\n            pic.move(0, maxY + GAP);\n        }\n    }\n}\n","name":"main","className":"Gallery6","variables":{"PICTURES":1,"previous":3,"MAX_WIDTH":2,"maxY":3,"GAP":3,"x":2,"i":4,"pic":7,"Math":1},"constants":{"0":2,"2":1,"\".jpg\"":1,"\"picture\"":1,"720":1,"\"picture1.jpg\"":1,"20":2,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"move":2,"getY":1,"max":1,"getMaxX":1,"getMaxY":1,"getWidth":1,"getBounds":4},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Picture":2,"double":2,"int":4},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":2,"VariableDeclarationExpr":8,"BinaryExpr":7,"StringLiteralExpr":3,"NameExpr":43,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    final int MAX_WIDTH = 720;\n    final int GAP = 10;\n    final int PICTURES = 20;\n    Picture pic = new Picture(\"picture1.jpg\");\n    double maxY = 0;\n    for (int i = 2; i <= PICTURES; i++) {\n        maxY = Math.max(maxY, pic.getBounds().getMaxY());\n        Picture previous = pic;\n        pic = new Picture(\"picture\" + i + \".jpg\");\n        double x = previous.getBounds().getMaxX() + GAP;\n        if (x + pic.getBounds().getWidth() < MAX_WIDTH) {\n            pic.move(x, previous.getBounds().getY());\n        } else {\n            pic.move(0, maxY + GAP);\n            return;\n        }\n    }\n}\n","name":"main","className":"Gallery5","variables":{"PICTURES":2,"previous":3,"MAX_WIDTH":2,"maxY":3,"GAP":3,"x":2,"i":4,"pic":7,"Math":1},"constants":{"0":2,"2":1,"\".jpg\"":1,"\"picture\"":1,"720":1,"\"picture1.jpg\"":1,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":6,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Transfers money from this account and tries to add it\n      @param amount the amount of money to transfer\n      @param otherBalance balance to add the amount to\n   */\nvoid transfer(double amount, double otherBalance) {\n    balance = balance - amount;\n    otherBalance = otherBalance + amount;\n// Won’t update the argument\n}\n","name":"transfer","className":"BankAccount","variables":{"amount":2,"balance":2,"otherBalance":2},"constants":{},"javaDoc":"Transfers money from this account and tries to add it amount the amount of money to transfer otherBalance balance to add the amount to","comments":"Won’t update the argument \n      Transfers money from this account and tries to add it\n      @param amount the amount of money to transfer\n      @param otherBalance balance to add the amount to\n   ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["double","BankAccount"],"returnType":"void","methodCalls":{"deposit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Transfers money from this account to another.\n      @param amount the amount of money to transfer\n      @param otherAccount account to add the amount to\n   */\npublic void transfer(double amount, BankAccount otherAccount) {\n    balance = balance - amount;\n    otherAccount.deposit(amount);\n}\n","name":"transfer","className":"BankAccount","variables":{"amount":1,"otherAccount":1,"balance":2},"constants":{},"javaDoc":"Transfers money from this account to another amount the amount of money to transfer otherAccount account to add the amount to","comments":"\n      Transfers money from this account to another.\n      @param amount the amount of money to transfer\n      @param otherAccount account to add the amount to\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","BankAccount"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":9,"FieldAccessExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"public void transfer2(double amount, BankAccount otherAccount) {\n    balance = balance - amount;\n    double newBalance = otherAccount.balance + amount;\n    // Won’t work\n    otherAccount = new BankAccount(newBalance);\n}\n","name":"transfer2","className":"BankAccount","variables":{"amount":2,"otherAccount":1,"balance":2,"newBalance":2},"constants":{},"javaDoc":"","comments":"Won’t work ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"transfer":2,"getBalance":4,"transfer2":1,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"BankAccount":3},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":7,"VariableDeclarationExpr":4,"BinaryExpr":6,"NameExpr":56,"StringLiteralExpr":6,"FieldAccessExpr":6,"MethodCallExpr":13},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    BankAccount harrysChecking = new BankAccount(2500);\n    double savingsBalance = 1000;\n    System.out.println(\"Before: \" + savingsBalance);\n    harrysChecking.transfer(500, savingsBalance);\n    System.out.println(\"After: \" + savingsBalance);\n    BankAccount harrysSavings = new BankAccount(1000);\n    System.out.println(\"Before: \" + harrysSavings.getBalance());\n    harrysChecking.transfer(500, harrysSavings);\n    System.out.println(\"After: \" + harrysSavings.getBalance());\n    BankAccount savingsAccount = new BankAccount(1000);\n    System.out.println(\"Before: \" + savingsAccount.getBalance());\n    harrysChecking.transfer2(500, savingsAccount);\n    System.out.println(\"After: \" + savingsAccount.getBalance());\n}\n","name":"main","className":"CallByValueDemo","variables":{"harrysChecking":4,"savingsBalance":3,"savingsAccount":3,"harrysSavings":3},"constants":{"2500":1,"500":3,"\"After: \"":3,"1000":3,"\"Before: \"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   */\npublic static double percentOf(double percentage, double amount) {\n    return (percentage / 100) * amount;\n}\n","name":"percentOf","className":"Financial","variables":{"amount":1,"percentage":1},"constants":{"100":1},"javaDoc":"Computes a percentage of an amount percentage the percentage to apply amount the amount to which the percentage is applied the requested percentage of the amount","comments":"\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Adds a percentage to an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the sum of the amount and the requested percentage\n   */\npublic static double addPercentTo(double percentage, double amount) {\n    return (1 + percentage / 100) * amount;\n}\n","name":"addPercentTo","className":"Financial","variables":{"amount":1,"percentage":1},"constants":{"1":1,"100":1},"javaDoc":"Adds a percentage to an amount percentage the percentage to apply amount the amount to which the percentage is applied the sum of the amount and the requested percentage","comments":"\n      Adds a percentage to an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the sum of the amount and the requested percentage\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":1,"percentOf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":3},"expressions":{"VariableDeclarationExpr":3,"DoubleLiteralExpr":2,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    double price = 9.95;\n    double taxRate = 8.25;\n    double tax = Financial.percentOf(price, taxRate);\n    System.out.printf(\"Tax: %.2f\\n\", tax);\n}\n","name":"main","className":"PackageDemo","variables":{"taxRate":1,"price":1,"Financial":1,"tax":1},"constants":{"8.25":1,"\"Tax: %.2f\\n\"":1,"9.95":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"public void eat() {\n    System.out.println(\"Yum!\");\n    hungry = NOT_HUNGRY;\n}\n","name":"eat","className":"Fish","variables":{"hungry":1,"NOT_HUNGRY":1},"constants":{"\"Yum!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public void move() {\n    if (hungry == VERY_HUNGRY) {\n        System.out.println(\"Looking for food\");\n    } else {\n        System.out.println(\"Looking for love\");\n        hungry++;\n    }\n}\n","name":"move","className":"Fish","variables":{"hungry":2,"VERY_HUNGRY":1},"constants":{"\"Looking for love\"":1,"\"Looking for food\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Student(int anId) {\n    id = anId;\n}\n","name":"Student","className":"Student","variables":{"anId":1,"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getId() {\n    return id;\n}\n","name":"getId","className":"Student","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// No setId method\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Student","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"length":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":5,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":1},"text":"public void setName(String newName) {\n    if (newName.length() > 0) {\n        name = newName;\n    }\n}\n","name":"setName","className":"Student","variables":{"newName":2,"name":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":4},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":12,"UnaryExpr":4},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":8},"text":"public void moveOneUnit() {\n    final int NORTH = 0;\n    final int EAST = 1;\n    final int SOUTH = 2;\n    final int WEST = 3;\n    if (direction == NORTH) {\n        row--;\n    } else if (direction == EAST) {\n        column++;\n    } else if (direction == SOUTH) {\n        row++;\n    } else if (direction == WEST) {\n        column--;\n    }\n}\n","name":"moveOneUnit","className":"Bug","variables":{"NORTH":2,"WEST":2,"column":2,"SOUTH":2,"row":2,"EAST":2,"direction":4},"constants":{"0":1,"1":1,"2":1,"3":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public void turnRight() {\n    int DIRECTIONS = 4;\n    direction++;\n    if (direction == DIRECTIONS) {\n        direction = 0;\n    }\n}\n","name":"turnRight","className":"Bug","variables":{"DIRECTIONS":2,"direction":3},"constants":{"0":1,"4":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getRow() {\n    return row;\n}\n","name":"getRow","className":"Bug","variables":{"row":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getColumn() {\n    return column;\n}\n","name":"getColumn","className":"Bug","variables":{"column":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void move(double distanceMoved) {\n    distanceFromTerminus = distanceFromTerminus + distanceMoved;\n}\n","name":"move","className":"Train","variables":{"distanceFromTerminus":2,"distanceMoved":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getPosition() {\n    return distanceFromTerminus;\n}\n","name":"getPosition","className":"Train","variables":{"distanceFromTerminus":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"recordPurchase":2,"assertEquals":1,"receivePayment":1,"giveChange":1},"annotations":["Test"],"exceptions":[],"concepts":[],"types":{"CashRegister":1,"double":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"DoubleLiteralExpr":3,"NameExpr":17,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"@Test\npublic void twoPurchases() {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(0.75);\n    register.recordPurchase(1.50);\n    register.receivePayment(2, 0, 5, 0, 0);\n    double expected = 0.25;\n    Assert.assertEquals(expected, register.giveChange(), EPSILON);\n}\n","name":"twoPurchases","className":"CashRegisterTest","variables":{"Assert":1,"expected":1,"register":5},"constants":{"0":3,"2":1,"5":1,"0.25":1,"0.75":1,"1.50":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"recordPurchase":2,"assertEquals":1,"receivePayment":1,"giveChange":1},"annotations":["Test"],"exceptions":[],"concepts":[],"types":{"CashRegister":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"DoubleLiteralExpr":2,"NameExpr":16,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"@Test\npublic void testZeroBalance() {\n    CashRegister register = new CashRegister();\n    register.recordPurchase(2.25);\n    register.recordPurchase(19.25);\n    register.receivePayment(21, 2, 0, 0, 0);\n    Assert.assertEquals(0, register.giveChange(), EPSILON);\n}\n","name":"testZeroBalance","className":"CashRegisterTest","variables":{"Assert":1,"register":5},"constants":{"0":4,"2":1,"19.25":1,"2.25":1,"21":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"CashRegister","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a cash register with no money in it.\n   */\npublic CashRegister() {\n    purchase = 0;\n    payment = 0;\n}\n","name":"CashRegister","className":"CashRegister","variables":{"purchase":1,"payment":1},"constants":{"0":2},"javaDoc":"Constructs a cash register with no money in it","comments":"\n      Constructs a cash register with no money in it.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   */\npublic void recordPurchase(double amount) {\n    purchase = purchase + amount;\n}\n","name":"recordPurchase","className":"CashRegister","variables":{"amount":1,"purchase":2},"constants":{},"javaDoc":"Records the purchase price of an item amount the price of the purchased item","comments":"\n      Records the purchase price of an item.\n      @param amount the price of the purchased item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":8,"NameExpr":10,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Enters the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   */\npublic void receivePayment(int dollars, int quarters, int dimes, int nickels, int pennies) {\n    payment = dollars + quarters * QUARTER_VALUE + dimes * DIME_VALUE + nickels * NICKEL_VALUE + pennies * PENNY_VALUE;\n}\n","name":"receivePayment","className":"CashRegister","variables":{"NICKEL_VALUE":1,"dimes":1,"nickels":1,"quarters":1,"pennies":1,"payment":1,"dollars":1,"QUARTER_VALUE":1,"DIME_VALUE":1,"PENNY_VALUE":1},"constants":{},"javaDoc":"Enters the payment received from the customer dollars the number of dollars in the payment quarters the number of quarters in the payment dimes the number of dimes in the payment nickels the number of nickels in the payment pennies the number of pennies in the payment","comments":"\n      Enters the payment received from the customer.\n      @param dollars the number of dollars in the payment\n      @param quarters the number of quarters in the payment\n      @param dimes the number of dimes in the payment\n      @param nickels the number of nickels in the payment\n      @param pennies the number of pennies in the payment\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":5,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   */\npublic double giveChange() {\n    double change = payment - purchase;\n    purchase = 0;\n    payment = 0;\n    return change;\n}\n","name":"giveChange","className":"CashRegister","variables":{"change":2,"purchase":2,"payment":2},"constants":{"0":2},"javaDoc":"Computes the change due and resets the machine for the next customer the change due to the customer","comments":"\n      Computes the change due and resets the machine for the next customer.\n      @return the change due to the customer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    lastAssignedNumber++;\n    accountNumber = lastAssignedNumber;\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"lastAssignedNumber":2,"balance":1,"accountNumber":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Deposits money into this account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into this account amount the amount to deposit","comments":"\n      Deposits money into this account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":8,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"/**\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   */\npublic void withdraw(double amount) {\n    if (amount > balance) {\n        balance = balance - OVERDRAFT_FEE;\n    } else {\n        balance = balance - amount;\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":5,"OVERDRAFT_FEE":1},"constants":{},"javaDoc":"Makes a withdrawal from this account or charges a penalty if sufficient funds are not available amount the amount of the withdrawal","comments":"\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"percentOf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds interest to this account.\n      @param rate the interest rate in percent\n   */\npublic void addInterest(double rate) {\n    balance = balance + Financial.percentOf(rate, balance);\n}\n","name":"addInterest","className":"BankAccount","variables":{"balance":2,"Financial":1},"constants":{},"javaDoc":"Adds interest to this account rate the interest rate in percent","comments":"\n      Adds interest to this account.\n      @param rate the interest rate in percent\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of this account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of this account the current balance","comments":"\n      Gets the current balance of this account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   */\npublic static double percentOf(double percentage, double amount) {\n    return (percentage / 100) * amount;\n}\n","name":"percentOf","className":"Financial","variables":{"amount":1,"percentage":1},"constants":{"100":1},"javaDoc":"Computes a percentage of an amount percentage the percentage to apply amount the amount to which the percentage is applied the requested percentage of the amount","comments":"\n      Computes a percentage of an amount. \n      @param percentage the percentage to apply\n      @param amount the amount to which the percentage is applied\n      @return the requested percentage of the amount \n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"TimeBean","methodCalls":{"getTimeInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Initializes the formatter.\n   */\npublic TimeBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n}\n","name":"TimeBean","className":"TimeBean","variables":{"DateFormat":1,"timeFormatter":1},"constants":{},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"Date":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Read-only time property.\n      @return the formatted time\n   */\npublic String getTime() {\n    Date time = new Date();\n    String timeString = timeFormatter.format(time);\n    return timeString;\n}\n","name":"getTime","className":"TimeBean","variables":{"timeString":2,"time":1,"timeFormatter":1},"constants":{},"javaDoc":"Read-only time property the formatted time","comments":"\n      Read-only time property.\n      @return the formatted time\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"TimeZoneBean","methodCalls":{"getTimeInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Initializes the formatter.\n   */\npublic TimeZoneBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n    cities = new ArrayList<>();\n}\n","name":"TimeZoneBean","className":"TimeZoneBean","variables":{"cities":1,"DateFormat":1,"timeFormatter":1},"constants":{},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   */\npublic void setCityToAdd(String city) {\n    cityToAdd = city;\n}\n","name":"setCityToAdd","className":"TimeZoneBean","variables":{"city":1,"cityToAdd":1},"constants":{},"javaDoc":"Setter for cityToAdd property city the city to add to the list of cities","comments":"\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   */\npublic String getCityToAdd() {\n    return cityToAdd;\n}\n","name":"getCityToAdd","className":"TimeZoneBean","variables":{"cityToAdd":1},"constants":{},"javaDoc":"Getter for cityToAdd property the city to add to the list of cities","comments":"\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   */\npublic void setCityToRemove(String city) {\n    cityToRemove = city;\n}\n","name":"setCityToRemove","className":"TimeZoneBean","variables":{"city":1,"cityToRemove":1},"constants":{},"javaDoc":"Setter for the cityToRemove property city the city to remove from the list of cities","comments":"\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   */\npublic String getCityToRemove() {\n    return cityToRemove;\n}\n","name":"getCityToRemove","className":"TimeZoneBean","variables":{"cityToRemove":1},"constants":{},"javaDoc":"Getter for the cityToRemove property the city to remove from the list of cities","comments":"\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Map<String, String>","methodCalls":{"size":1,"getTimeZone":1,"get":1,"setTimeZone":1,"format":1,"put":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<String, String>":1,"TimeZone":1,"String":3,"TreeMap":1,"Date":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":5,"NameExpr":33,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":6,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"/**\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   */\npublic Map<String, String> getCitiesAndTimes() {\n    Date time = new Date();\n    Map<String, String> result = new TreeMap<>();\n    for (int i = 0; i < cities.size(); i++) {\n        String city = cities.get(i);\n        String label = city + \": \";\n        TimeZone zone = getTimeZone(city);\n        if (zone != null) {\n            timeFormatter.setTimeZone(zone);\n            String timeString = timeFormatter.format(time);\n            label = label + timeString;\n        } else {\n            label = label + \"unavailable\";\n        }\n        result.put(label, city);\n    }\n    return result;\n}\n","name":"getCitiesAndTimes","className":"TimeZoneBean","variables":{"result":3,"cities":2,"city":2,"zone":2,"timeString":2,"i":3,"time":1,"label":5,"timeFormatter":2},"constants":{"0":1,"null":1,"\"unavailable\"":1,"\": \"":1},"javaDoc":"Read-only citiesAndTimes property a map containing the cities and formatted times","comments":"\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"add":1,"getTimeZone":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"TimeZone":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":3,"MethodCallExpr":2,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Action for adding a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   */\npublic String addCity() {\n    TimeZone zone = getTimeZone(cityToAdd);\n    if (zone == null) {\n        return \"error\";\n    }\n    cities.add(cityToAdd);\n    cityToRemove = cityToAdd;\n    cityToAdd = \"\";\n    return \"next\";\n}\n","name":"addCity","className":"TimeZoneBean","variables":{"cities":1,"zone":2,"cityToAdd":2,"cityToRemove":1},"constants":{"\"\"":1,"null":1,"\"error\"":1,"\"next\"":1},"javaDoc":"Action for adding a city \"next\" if time zone information is available for the city \"error\" otherwise","comments":"\n      Action for adding a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"size":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Action for removing a city.\n      @return null if there are more cities to remove, \"index\" otherwise\n   */\npublic String removeCity() {\n    cities.remove(cityToRemove);\n    if (cities.size() > 0) {\n        return null;\n    } else {\n        return \"index\";\n    }\n}\n","name":"removeCity","className":"TimeZoneBean","variables":{"cities":2},"constants":{"0":1,"null":1,"\"index\"":1},"javaDoc":"Action for removing a city null if there are more cities to remove \"index\" otherwise","comments":"\n      Action for removing a city.\n      @return null if there are more cities to remove, \"index\" otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"TimeZone","methodCalls":{"getTimeZone":2,"Logger.global.info":1,"getAvailableIDs":1,"timeZoneIDmatch":1,"getZoneNameFromDB":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"String[]":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":32,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":2,"BlockStmt":5,"TryStmt":1,"ForStmt":1,"ReturnStmt":3,"ExpressionStmt":3},"text":"/**\n      Looks up the time zone for a city\n      @param city the city for which to find the time zone\n      @return the time zone or null if no match is found\n   */\nprivate TimeZone getTimeZone(String city) {\n    String[] ids = TimeZone.getAvailableIDs();\n    for (int i = 0; i < ids.length; i++) {\n        if (timeZoneIDmatch(ids[i], city)) {\n            return TimeZone.getTimeZone(ids[i]);\n        }\n    }\n    try {\n        String id = getZoneNameFromDB(city);\n        if (id != null) {\n            return TimeZone.getTimeZone(id);\n        }\n    } catch (Exception ex) {\n        Logger.global.info(\"Caught in TimeZone.getTimeZone: \" + ex);\n    }\n    return null;\n}\n","name":"getTimeZone","className":"TimeZoneBean","variables":{"TimeZone":3,"ex":2,"ids":3,"i":5,"id":2},"constants":{"0":1,"null":2,"\"Caught in TimeZone.getTimeZone: \"":1},"javaDoc":"Looks up the time zone for a city city the city for which to find the time zone the time zone or null if no match is found","comments":"\n      Looks up the time zone for a city\n      @param city the city for which to find the time zone\n      @return the time zone or null if no match is found\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"next":1,"getConnection":1,"setString":1,"Logger.global.info":1,"prepareStatement":1,"getString":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"Connection":1,"ResultSet":1,"PreparedStatement":1},"expressions":{"NullLiteralExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":25,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":2,"BlockStmt":4,"TryStmt":1,"ReturnStmt":3,"ExpressionStmt":4},"text":"private String getZoneNameFromDB(String city) throws SQLException {\n    if (source == null) {\n        Logger.global.info(\"No database connection\");\n        return null;\n    }\n    try (Connection conn = source.getConnection()) {\n        PreparedStatement stat = conn.prepareStatement(\"SELECT Zone FROM CityZone WHERE City=?\");\n        stat.setString(1, city);\n        ResultSet result = stat.executeQuery();\n        if (result.next()) {\n            return result.getString(1);\n        } else {\n            return null;\n        }\n    }\n}\n","name":"getZoneNameFromDB","className":"TimeZoneBean","variables":{"result":3,"conn":2,"stat":3,"source":2},"constants":{"1":2,"null":3,"\"No database connection\"":1,"\"SELECT Zone FROM CityZone WHERE City=?\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String","String"],"returnType":"boolean","methodCalls":{"equals":1,"replace":1,"indexOf":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"CharLiteralExpr":3,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Checks whether a time zone ID matches a city\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param city the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   */\nprivate static boolean timeZoneIDmatch(String id, String city) {\n    String idCity = id.substring(id.indexOf('/') + 1);\n    return idCity.replace('_', ' ').equals(city);\n}\n","name":"timeZoneIDmatch","className":"TimeZoneBean","variables":{"idCity":2,"id":2},"constants":{"1":1,"' '":1,"'/'":1,"'_'":1},"javaDoc":"Checks whether a time zone ID matches a city id the time zone ID (e g \"America/Los_Angeles\") city the city to match (e g \"Los Angeles\") true if the ID and city match","comments":"\n      Checks whether a time zone ID matches a city\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param city the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"TimeZoneBean","methodCalls":{"getTimeInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Initializes the formatter.\n   */\npublic TimeZoneBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n    cities = new ArrayList<>();\n}\n","name":"TimeZoneBean","className":"TimeZoneBean","variables":{"cities":1,"DateFormat":1,"timeFormatter":1},"constants":{},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   */\npublic void setCityToAdd(String city) {\n    cityToAdd = city;\n}\n","name":"setCityToAdd","className":"TimeZoneBean","variables":{"city":1,"cityToAdd":1},"constants":{},"javaDoc":"Setter for cityToAdd property city the city to add to the list of cities","comments":"\n      Setter for cityToAdd property.\n      @param city the city to add to the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   */\npublic String getCityToAdd() {\n    return cityToAdd;\n}\n","name":"getCityToAdd","className":"TimeZoneBean","variables":{"cityToAdd":1},"constants":{},"javaDoc":"Getter for cityToAdd property the city to add to the list of cities","comments":"\n      Getter for cityToAdd property.\n      @return the city to add to the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   */\npublic void setCityToRemove(String city) {\n    cityToRemove = city;\n}\n","name":"setCityToRemove","className":"TimeZoneBean","variables":{"city":1,"cityToRemove":1},"constants":{},"javaDoc":"Setter for the cityToRemove property city the city to remove from the list of cities","comments":"\n      Setter for the cityToRemove property.\n      @param city the city to remove from the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   */\npublic String getCityToRemove() {\n    return cityToRemove;\n}\n","name":"getCityToRemove","className":"TimeZoneBean","variables":{"cityToRemove":1},"constants":{},"javaDoc":"Getter for the cityToRemove property the city to remove from the list of cities","comments":"\n      Getter for the cityToRemove property.\n      @return the city to remove from the list of cities\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Map<String, String>","methodCalls":{"size":1,"getTimeZone":1,"get":1,"setTimeZone":1,"format":1,"put":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<String, String>":1,"TimeZone":1,"String":3,"TreeMap":1,"Date":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":5,"NameExpr":33,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":6,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"/**\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   */\npublic Map<String, String> getCitiesAndTimes() {\n    Date time = new Date();\n    Map<String, String> result = new TreeMap<>();\n    for (int i = 0; i < cities.size(); i++) {\n        String city = cities.get(i);\n        String label = city + \": \";\n        TimeZone zone = getTimeZone(city);\n        if (zone != null) {\n            timeFormatter.setTimeZone(zone);\n            String timeString = timeFormatter.format(time);\n            label = label + timeString;\n        } else {\n            label = label + \"unavailable\";\n        }\n        result.put(label, city);\n    }\n    return result;\n}\n","name":"getCitiesAndTimes","className":"TimeZoneBean","variables":{"result":3,"cities":2,"city":2,"zone":2,"timeString":2,"i":3,"time":1,"label":5,"timeFormatter":2},"constants":{"0":1,"null":1,"\"unavailable\"":1,"\": \"":1},"javaDoc":"Read-only citiesAndTimes property a map containing the cities and formatted times","comments":"\n      Read-only citiesAndTimes property.\n      @return a map containing the cities and formatted times\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"add":1,"getTimeZone":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"TimeZone":1},"expressions":{"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":2,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n      Action for adding a city.\n      @return null\n   */\npublic String addCity() {\n    TimeZone zone = getTimeZone(cityToAdd);\n    if (zone == null) {\n        return null;\n    }\n    cities.add(cityToAdd);\n    cityToRemove = cityToAdd;\n    cityToAdd = \"\";\n    return null;\n}\n","name":"addCity","className":"TimeZoneBean","variables":{"cities":1,"zone":2,"cityToAdd":2,"cityToRemove":1},"constants":{"\"\"":1,"null":3},"javaDoc":"Action for adding a city null","comments":"\n      Action for adding a city.\n      @return null\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Action for removing a city.\n      @return null\n   */\npublic String removeCity() {\n    cities.remove(cityToRemove);\n    return null;\n}\n","name":"removeCity","className":"TimeZoneBean","variables":{"cities":1},"constants":{"null":1},"javaDoc":"Action for removing a city null","comments":"\n      Action for removing a city.\n      @return null\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"TimeZone","methodCalls":{"getTimeZone":1,"getAvailableIDs":1,"timeZoneIDmatch":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":18,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   */\nprivate static TimeZone getTimeZone(String aCity) {\n    String[] ids = TimeZone.getAvailableIDs();\n    for (int i = 0; i < ids.length; i++) {\n        if (timeZoneIDmatch(ids[i], aCity)) {\n            return TimeZone.getTimeZone(ids[i]);\n        }\n    }\n    return null;\n}\n","name":"getTimeZone","className":"TimeZoneBean","variables":{"TimeZone":2,"ids":3,"i":5},"constants":{"0":1,"null":1},"javaDoc":"Looks up the time zone for a city aCity the city for which to find the time zone the time zone or null if no match is found","comments":"\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String","String"],"returnType":"boolean","methodCalls":{"equals":1,"replace":1,"indexOf":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"CharLiteralExpr":3,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   */\nprivate static boolean timeZoneIDmatch(String id, String aCity) {\n    String idCity = id.substring(id.indexOf('/') + 1);\n    return idCity.replace('_', ' ').equals(aCity);\n}\n","name":"timeZoneIDmatch","className":"TimeZoneBean","variables":{"idCity":2,"id":2},"constants":{"1":1,"' '":1,"'/'":1,"'_'":1},"javaDoc":"Checks whether a time zone ID matches a city id the time zone ID (e g \"America/Los_Angeles\") aCity the city to match (e g \"Los Angeles\") true if the ID and city match","comments":"\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"TimeZoneBean","methodCalls":{"getTimeInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Initializes the formatter.\n   */\npublic TimeZoneBean() {\n    timeFormatter = DateFormat.getTimeInstance();\n}\n","name":"TimeZoneBean","className":"TimeZoneBean","variables":{"DateFormat":1,"timeFormatter":1},"constants":{},"javaDoc":"Initializes the formatter","comments":"\n      Initializes the formatter.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Setter for city property.\n      @param aCity the city for which to report the local time\n   */\npublic void setCity(String aCity) {\n    city = aCity;\n}\n","name":"setCity","className":"TimeZoneBean","variables":{"city":1,"aCity":1},"constants":{},"javaDoc":"Setter for city property aCity the city for which to report the local time","comments":"\n      Setter for city property.\n      @param aCity the city for which to report the local time\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Getter for city property.\n      @return the city for which to report the local time\n   */\npublic String getCity() {\n    return city;\n}\n","name":"getCity","className":"TimeZoneBean","variables":{"city":1},"constants":{},"javaDoc":"Getter for city property the city for which to report the local time","comments":"\n      Getter for city property.\n      @return the city for which to report the local time\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"setTimeZone":1,"format":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"Date":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":3},"text":"/**\n      Read-only time property.\n      @return the formatted time\n   */\npublic String getTime() {\n    if (zone == null) {\n        return \"not available\";\n    }\n    timeFormatter.setTimeZone(zone);\n    Date time = new Date();\n    String timeString = timeFormatter.format(time);\n    return timeString;\n}\n","name":"getTime","className":"TimeZoneBean","variables":{"zone":1,"timeString":2,"time":1,"timeFormatter":2},"constants":{"null":1,"\"not available\"":1},"javaDoc":"Read-only time property the formatted time","comments":"\n      Read-only time property.\n      @return the formatted time\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getTimeZone":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":5,"StringLiteralExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Action for checking a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   */\npublic String checkCity() {\n    zone = getTimeZone(city);\n    if (zone == null) {\n        return \"error\";\n    }\n    return \"next\";\n}\n","name":"checkCity","className":"TimeZoneBean","variables":{"zone":2},"constants":{"null":1,"\"error\"":1,"\"next\"":1},"javaDoc":"Action for checking a city \"next\" if time zone information is available for the city \"error\" otherwise","comments":"\n      Action for checking a city.\n      @return \"next\" if time zone information is available for the city,\n      \"error\" otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"TimeZone","methodCalls":{"getTimeZone":1,"getAvailableIDs":1,"timeZoneIDmatch":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":18,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   */\nprivate static TimeZone getTimeZone(String aCity) {\n    String[] ids = TimeZone.getAvailableIDs();\n    for (int i = 0; i < ids.length; i++) {\n        if (timeZoneIDmatch(ids[i], aCity)) {\n            return TimeZone.getTimeZone(ids[i]);\n        }\n    }\n    return null;\n}\n","name":"getTimeZone","className":"TimeZoneBean","variables":{"TimeZone":2,"ids":3,"i":5},"constants":{"0":1,"null":1},"javaDoc":"Looks up the time zone for a city aCity the city for which to find the time zone the time zone or null if no match is found","comments":"\n      Looks up the time zone for a city.\n      @param aCity the city for which to find the time zone\n      @return the time zone or null if no match is found\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String","String"],"returnType":"boolean","methodCalls":{"equals":1,"replace":1,"indexOf":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"CharLiteralExpr":3,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   */\nprivate static boolean timeZoneIDmatch(String id, String aCity) {\n    String idCity = id.substring(id.indexOf('/') + 1);\n    return idCity.replace('_', ' ').equals(aCity);\n}\n","name":"timeZoneIDmatch","className":"TimeZoneBean","variables":{"idCity":2,"id":2},"constants":{"1":1,"' '":1,"'/'":1,"'_'":1},"javaDoc":"Checks whether a time zone ID matches a city id the time zone ID (e g \"America/Los_Angeles\") aCity the city to match (e g \"Los Angeles\") true if the ID and city match","comments":"\n      Checks whether a time zone ID matches a city.\n      @param id the time zone ID (e.g. \"America/Los_Angeles\")\n      @param aCity the city to match (e.g. \"Los Angeles\")\n      @return true if the ID and city match\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setAnswer":1,"addChoice":4,"addQuestion":2,"presentQuestions":1,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Quiz":1,"Question":1,"ChoiceQuestion":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"BooleanLiteralExpr":4,"NameExpr":32,"StringLiteralExpr":7,"MethodCallExpr":10},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    Question first = new Question();\n    first.setText(\"Who was the inventor of Java?\");\n    first.setAnswer(\"James Gosling\");\n    ChoiceQuestion second = new ChoiceQuestion();\n    second.setText(\"In which country was the inventor of Java born?\");\n    second.addChoice(\"Australia\", false);\n    second.addChoice(\"Canada\", true);\n    second.addChoice(\"Denmark\", false);\n    second.addChoice(\"United States\", false);\n    Quiz q = new Quiz();\n    q.addQuestion(first);\n    q.addQuestion(second);\n    q.presentQuestions();\n}\n","name":"main","className":"QuizDemo","variables":{"q":4,"first":3,"second":6},"constants":{"\"Who was the inventor of Java?\"":1,"\"In which country was the inventor of Java born?\"":1,"\"Denmark\"":1,"\"United States\"":1,"\"James Gosling\"":1,"false":3,"true":1,"\"Canada\"":1,"\"Australia\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Quiz","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a quiz with no questions.\n   */\npublic Quiz() {\n    questions = new ArrayList<Question>();\n}\n","name":"Quiz","className":"Quiz","variables":{"questions":1},"constants":{},"javaDoc":"Constructs a quiz with no questions","comments":"\n      Constructs a quiz with no questions.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Question"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds a question to this quiz.\n      @param q the question\n   */\npublic void addQuestion(Question q) {\n    questions.add(q);\n}\n","name":"addQuestion","className":"Quiz","variables":{"questions":1},"constants":{},"javaDoc":"Adds a question to this quiz q the question","comments":"\n      Adds a question to this quiz.\n      @param q the question\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"display":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Question":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":24,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":5},"text":"/**\n      Presents the questions to the user and checks the response.\n   */\npublic void presentQuestions() {\n    Scanner in = new Scanner(System.in);\n    for (Question q : questions) {\n        q.display();\n        System.out.print(\"Your answer: \");\n        String response = in.nextLine();\n        System.out.println(q.checkAnswer(response));\n    }\n}\n","name":"presentQuestions","className":"Quiz","variables":{"q":3,"in":2,"response":1,"questions":1},"constants":{"\"Your answer: \"":1},"javaDoc":"Presents the questions to the user and checks the response","comments":"\n      Presents the questions to the user and checks the response.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"constants":{"\"\"":2},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":1},"constants":{},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":1},"constants":{},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":1},"constants":{},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"constants":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ChoiceQuestion","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a choice question with no choices.\n   */\npublic ChoiceQuestion() {\n    choices = new ArrayList<String>();\n}\n","name":"ChoiceQuestion","className":"ChoiceQuestion","variables":{"choices":1},"constants":{},"javaDoc":"Constructs a choice question with no choices","comments":"\n      Constructs a choice question with no choices.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","boolean"],"returnType":"void","methodCalls":{"add":1,"size":1,"setAnswer":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   */\npublic void addChoice(String choice, boolean correct) {\n    choices.add(choice);\n    if (correct) {\n        // Convert choices.size() to string\n        String choiceString = \"\" + choices.size();\n        setAnswer(choiceString);\n    }\n}\n","name":"addChoice","className":"ChoiceQuestion","variables":{"correct":1,"choiceString":1,"choices":2},"constants":{"\"\"":1},"javaDoc":"Adds an answer choice to this question choice the choice to add correct true if this is the correct choice false otherwise","comments":"Convert choices size() to string \n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"SuperExpr":1,"BinaryExpr":4,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public void display() {\n    // Display the question text\n    super.display();\n    // Display the answer choices\n    for (int i = 0; i < choices.size(); i++) {\n        int choiceNumber = i + 1;\n        System.out.println(choiceNumber + \": \" + choices.get(i));\n    }\n}\n","name":"display","className":"ChoiceQuestion","variables":{"choiceNumber":2,"i":4,"choices":2},"constants":{"0":1,"1":1,"\": \"":1},"javaDoc":"","comments":"Display the question text Display the answer choices ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Address"],"returnType":"Invoice","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an invoice.\n      @param anAddress the billing address\n   */\npublic Invoice(Address anAddress) {\n    items = new ArrayList<LineItem>();\n    billingAddress = anAddress;\n}\n","name":"Invoice","className":"Invoice","variables":{"anAddress":1,"billingAddress":1,"items":1},"constants":{},"javaDoc":"Constructs an invoice anAddress the billing address","comments":"\n      Constructs an invoice.\n      @param anAddress the billing address\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Product","int"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LineItem":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Adds a charge for a product to this invoice.\n      @param aProduct the product that the customer ordered\n      @param quantity the quantity of the product\n   */\npublic void add(Product aProduct, int quantity) {\n    LineItem anItem = new LineItem(aProduct, quantity);\n    items.add(anItem);\n}\n","name":"add","className":"Invoice","variables":{"quantity":1,"aProduct":1,"anItem":1,"items":1},"constants":{},"javaDoc":"Adds a charge for a product to this invoice aProduct the product that the customer ordered quantity the quantity of the product","comments":"\n      Adds a charge for a product to this invoice.\n      @param aProduct the product that the customer ordered\n      @param quantity the quantity of the product\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":4,"getAmountDue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LineItem":1,"String":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":5,"StringLiteralExpr":8,"NameExpr":20,"MethodCallExpr":5,"AssignExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Formats the invoice.\n      @return the formatted invoice\n   */\npublic String format() {\n    String r = \"                     I N V O I C E\\n\\n\" + billingAddress.format() + String.format(\"\\n\\n%-30s%8s%5s%8s\\n\", \"Description\", \"Price\", \"Qty\", \"Total\");\n    for (LineItem item : items) {\n        r = r + item.format() + \"\\n\";\n    }\n    r = r + String.format(\"\\nAMOUNT DUE: $%8.2f\", getAmountDue());\n    return r;\n}\n","name":"format","className":"Invoice","variables":{"r":6,"item":2,"billingAddress":1,"String":2,"items":1},"constants":{"\"Price\"":1,"\"Description\"":1,"\"\\nAMOUNT DUE: $%8.2f\"":1,"\"                     I N V O I C E\\n\\n\"":1,"\"Qty\"":1,"\"\\n\\n%-30s%8s%5s%8s\\n\"":1,"\"Total\"":1,"\"\\n\"":1},"javaDoc":"Formats the invoice the formatted invoice","comments":"\n      Formats the invoice.\n      @return the formatted invoice\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getTotalPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"LineItem":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the total amount due.\n      @return the amount due\n   */\nprivate double getAmountDue() {\n    double amountDue = 0;\n    for (LineItem item : items) {\n        amountDue = amountDue + item.getTotalPrice();\n    }\n    return amountDue;\n}\n","name":"getAmountDue","className":"Invoice","variables":{"amountDue":4,"item":2,"items":1},"constants":{"0":1},"javaDoc":"Computes the total amount due the amount due","comments":"\n      Computes the total amount due.\n      @return the amount due\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"format":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Invoice":1,"Address":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"DoubleLiteralExpr":3,"StringLiteralExpr":8,"NameExpr":18,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Address samsAddress = new Address(\"Sam's Small Appliances\", \"100 Main Street\", \"Anytown\", \"CA\", \"98765\");\n    Invoice samsInvoice = new Invoice(samsAddress);\n    samsInvoice.add(new Product(\"Toaster\", 29.95), 3);\n    samsInvoice.add(new Product(\"Hair dryer\", 24.95), 1);\n    samsInvoice.add(new Product(\"Car vacuum\", 19.99), 2);\n    System.out.println(samsInvoice.format());\n}\n","name":"main","className":"InvoicePrinter","variables":{"samsInvoice":5,"samsAddress":2},"constants":{"\"Hair dryer\"":1,"\"Anytown\"":1,"\"98765\"":1,"\"Car vacuum\"":1,"19.99":1,"\"100 Main Street\"":1,"\"Toaster\"":1,"24.95":1,"1":1,"\"CA\"":1,"2":1,"3":1,"29.95":1,"\"Sam's Small Appliances\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Product","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   */\npublic Product(String aDescription, double aPrice) {\n    description = aDescription;\n    price = aPrice;\n}\n","name":"Product","className":"Product","variables":{"aDescription":1,"price":1,"description":1,"aPrice":1},"constants":{},"javaDoc":"Constructs a product from a description and a price aDescription the product description aPrice the product price","comments":"\n      Constructs a product from a description and a price.\n      @param aDescription the product description\n      @param aPrice the product price\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product description.\n      @return the description\n   */\npublic String getDescription() {\n    return description;\n}\n","name":"getDescription","className":"Product","variables":{"description":1},"constants":{},"javaDoc":"Gets the product description the description","comments":"\n      Gets the product description.\n      @return the description\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the product price.\n      @return the unit price\n   */\npublic double getPrice() {\n    return price;\n}\n","name":"getPrice","className":"Product","variables":{"price":1},"constants":{},"javaDoc":"Gets the product price the unit price","comments":"\n      Gets the product price.\n      @return the unit price\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","String","String","String"],"returnType":"Address","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"AssignExpr":5},"statements":{"ExpressionStmt":5},"text":"/**\n      Constructs a mailing address. \n      @param aName the recipient name\n      @param aStreet the street\n      @param aCity the city\n      @param aState the two-letter state code\n      @param aZip the ZIP postal code\n   */\npublic Address(String aName, String aStreet, String aCity, String aState, String aZip) {\n    name = aName;\n    street = aStreet;\n    city = aCity;\n    state = aState;\n    zip = aZip;\n}\n","name":"Address","className":"Address","variables":{"zip":1,"aStreet":1,"city":1,"street":1,"aName":1,"name":1,"aCity":1,"state":1,"aState":1,"aZip":1},"constants":{},"javaDoc":"Constructs a mailing address aName the recipient name aStreet the street aCity the city aState the two-letter state code aZip the ZIP postal code","comments":"\n      Constructs a mailing address. \n      @param aName the recipient name\n      @param aStreet the street\n      @param aCity the city\n      @param aState the two-letter state code\n      @param aZip the ZIP postal code\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":8,"NameExpr":5,"StringLiteralExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n      Formats the address.\n      @return the address as a string with three lines\n   */\npublic String format() {\n    return name + \"\\n\" + street + \"\\n\" + city + \", \" + state + \" \" + zip;\n}\n","name":"format","className":"Address","variables":{"zip":1,"city":1,"street":1,"name":1,"state":1},"constants":{"\" \"":1,"\", \"":1,"\"\\n\"":2},"javaDoc":"Formats the address the address as a string with three lines","comments":"\n      Formats the address.\n      @return the address as a string with three lines\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Product","int"],"returnType":"LineItem","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   */\npublic LineItem(Product aProduct, int aQuantity) {\n    theProduct = aProduct;\n    quantity = aQuantity;\n}\n","name":"LineItem","className":"LineItem","variables":{"quantity":1,"aProduct":1,"aQuantity":1,"theProduct":1},"constants":{},"javaDoc":"Constructs an item from the product and quantity aProduct the product aQuantity the item quantity","comments":"\n      Constructs an item from the product and quantity.\n      @param aProduct the product\n      @param aQuantity the item quantity\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes the total cost of this line item.\n      @return the total price\n   */\npublic double getTotalPrice() {\n    return theProduct.getPrice() * quantity;\n}\n","name":"getTotalPrice","className":"LineItem","variables":{"quantity":1,"theProduct":1},"constants":{},"javaDoc":"Computes the total cost of this line item the total price","comments":"\n      Computes the total cost of this line item.\n      @return the total price\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"format":1,"getTotalPrice":1,"getDescription":1,"getPrice":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n      Formats this item.\n      @return a formatted string of this item\n   */\npublic String format() {\n    return String.format(\"%-30s%8.2f%5d%8.2f\", theProduct.getDescription(), theProduct.getPrice(), quantity, getTotalPrice());\n}\n","name":"format","className":"LineItem","variables":{"String":1,"theProduct":2},"constants":{"\"%-30s%8.2f%5d%8.2f\"":1},"javaDoc":"Formats this item a formatted string of this item","comments":"\n      Formats this item.\n      @return a formatted string of this item\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Deposits money into the account.\n      @param amount the amount of money to withdraw\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Deposits money into the account amount the amount of money to withdraw","comments":" \n      Deposits money into the account.\n      @param amount the amount of money to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Withdraws money from the account.\n      @param amount the amount of money to deposit\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Withdraws money from the account amount the amount of money to deposit","comments":" \n      Withdraws money from the account.\n      @param amount the amount of money to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the account balance.\n      @return the account balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the account balance the account balance","comments":" \n      Gets the account balance.\n      @return the account balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"showMessageDialog":1,"readCustomers":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"Bank":1,"JFrame":1,"ATM":1,"ATMFrame":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    ATM theATM;\n    try {\n        Bank theBank = new Bank();\n        theBank.readCustomers(\"customers.txt\");\n        theATM = new ATM(theBank);\n    } catch (IOException e) {\n        JOptionPane.showMessageDialog(null, \"Error opening accounts file.\");\n        return;\n    }\n    JFrame frame = new ATMFrame(theATM);\n    frame.setTitle(\"First National Bank of Java\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ATMViewer","variables":{"theATM":3,"theBank":3,"e":1,"JOptionPane":1,"frame":4},"constants":{"\"customers.txt\"":1,"\"Error opening accounts file.\"":1,"null":1,"true":1,"\"First National Bank of Java\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"selectAccount":2,"back":3,"nextInt":2,"nextDouble":2,"setCustomerNumber":1,"getState":1,"getBalance":1,"readCustomers":1,"reset":1,"deposit":1,"equalsIgnoreCase":6,"System.out.print":6,"selectCustomer":1,"System.out.println":4,"withdraw":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"Bank":1,"double":2,"ATM":1,"String":2,"int":3},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":10,"BooleanLiteralExpr":1,"BinaryExpr":5,"NameExpr":156,"StringLiteralExpr":17,"FieldAccessExpr":17,"MethodCallExpr":35,"AssignExpr":1},"statements":{"IfStmt":10,"WhileStmt":1,"TryStmt":1,"BlockStmt":15,"ReturnStmt":1,"ExpressionStmt":32},"text":"public static void main(String[] args) {\n    ATM theATM;\n    try {\n        Bank theBank = new Bank();\n        theBank.readCustomers(\"customers.txt\");\n        theATM = new ATM(theBank);\n    } catch (IOException e) {\n        System.out.println(\"Error opening accounts file.\");\n        return;\n    }\n    Scanner in = new Scanner(System.in);\n    while (true) {\n        int state = theATM.getState();\n        if (state == ATM.START) {\n            System.out.print(\"Enter customer number: \");\n            int number = in.nextInt();\n            theATM.setCustomerNumber(number);\n        } else if (state == ATM.PIN) {\n            System.out.print(\"Enter PIN: \");\n            int pin = in.nextInt();\n            theATM.selectCustomer(pin);\n        } else if (state == ATM.ACCOUNT) {\n            System.out.print(\"A=Checking, B=Savings, C=Quit: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                theATM.selectAccount(ATM.CHECKING);\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                theATM.selectAccount(ATM.SAVINGS);\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.reset();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        } else if (state == ATM.TRANSACT) {\n            System.out.println(\"Balance=\" + theATM.getBalance());\n            System.out.print(\"A=Deposit, B=Withdrawal, C=Cancel: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.deposit(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.withdraw(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.back();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        }\n    }\n}\n","name":"main","className":"ATMSimulator","variables":{"number":1,"amount":2,"theATM":14,"theBank":3,"pin":1,"e":1,"in":7,"state":5,"command":8},"constants":{"\"customers.txt\"":1,"\"Error opening accounts file.\"":1,"\"Enter customer number: \"":1,"\"Illegal input!\"":2,"\"C\"":2,"\"B\"":2,"\"A\"":2,"\"A=Checking, B=Savings, C=Quit: \"":1,"\"Balance=\"":1,"\"A=Deposit, B=Withdrawal, C=Cancel: \"":1,"true":1,"\"Amount: \"":2,"\"Enter PIN: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"Customer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":6,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n      Constructs a customer with a given number and PIN.\n      @param aNumber the customer number\n      @param aPin the personal identification number\n   */\npublic Customer(int aNumber, int aPin) {\n    customerNumber = aNumber;\n    pin = aPin;\n    checkingAccount = new BankAccount();\n    savingsAccount = new BankAccount();\n}\n","name":"Customer","className":"Customer","variables":{"aNumber":1,"pin":1,"savingsAccount":1,"checkingAccount":1,"aPin":1,"customerNumber":1},"constants":{},"javaDoc":"Constructs a customer with a given number and PIN aNumber the customer number aPin the personal identification number","comments":"\n      Constructs a customer with a given number and PIN.\n      @param aNumber the customer number\n      @param aPin the personal identification number\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":4},"statements":{"ReturnStmt":1},"text":"/** \n      Tests if this customer matches a customer number \n      and PIN.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return true if the customer number and PIN match\n   */\npublic boolean match(int aNumber, int aPin) {\n    return customerNumber == aNumber && pin == aPin;\n}\n","name":"match","className":"Customer","variables":{"aNumber":1,"pin":1,"aPin":1,"customerNumber":1},"constants":{},"javaDoc":"Tests if this customer matches a customer number and PIN aNumber a customer number aPin a personal identification number true if the customer number and PIN match","comments":" \n      Tests if this customer matches a customer number \n      and PIN.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return true if the customer number and PIN match\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the checking account of this customer.\n      @return the checking account\n   */\npublic BankAccount getCheckingAccount() {\n    return checkingAccount;\n}\n","name":"getCheckingAccount","className":"Customer","variables":{"checkingAccount":1},"constants":{},"javaDoc":"Gets the checking account of this customer the checking account","comments":" \n      Gets the checking account of this customer.\n      @return the checking account\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the savings account of this customer.\n      @return the checking account\n   */\npublic BankAccount getSavingsAccount() {\n    return savingsAccount;\n}\n","name":"getSavingsAccount","className":"Customer","variables":{"savingsAccount":1},"constants":{},"javaDoc":"Gets the savings account of this customer the checking account","comments":" \n      Gets the savings account of this customer.\n      @return the checking account\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Bank","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank with no customers.\n   */\npublic Bank() {\n    customers = new ArrayList<Customer>();\n}\n","name":"Bank","className":"Bank","variables":{"customers":1},"constants":{},"javaDoc":"Constructs a bank with no customers","comments":"\n      Constructs a bank with no customers.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"addCustomer":1,"hasNext":1,"nextInt":2,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Scanner":1,"Customer":1,"int":2},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":4,"NameExpr":18,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"/**\n      Reads the customer numbers and pins.\n      @param filename the name of the customer file\n   */\npublic void readCustomers(String filename) throws IOException {\n    Scanner in = new Scanner(new File(filename));\n    while (in.hasNext()) {\n        int number = in.nextInt();\n        int pin = in.nextInt();\n        Customer c = new Customer(number, pin);\n        addCustomer(c);\n    }\n    in.close();\n}\n","name":"readCustomers","className":"Bank","variables":{"number":2,"filename":1,"c":1,"pin":2,"in":5},"constants":{},"javaDoc":"Reads the customer numbers and pins filename the name of the customer file","comments":"\n      Reads the customer numbers and pins.\n      @param filename the name of the customer file\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Customer"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Adds a customer to the bank.\n      @param c the customer to add\n   */\npublic void addCustomer(Customer c) {\n    customers.add(c);\n}\n","name":"addCustomer","className":"Bank","variables":{"customers":1},"constants":{},"javaDoc":"Adds a customer to the bank c the customer to add","comments":"\n      Adds a customer to the bank.\n      @param c the customer to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Customer","methodCalls":{"match":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Customer":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ReturnStmt":2},"text":"/** \n      Finds a customer in the bank.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return the matching customer, or null if no customer \n      matches\n   */\npublic Customer findCustomer(int aNumber, int aPin) {\n    for (Customer c : customers) {\n        if (c.match(aNumber, aPin)) {\n            return c;\n        }\n    }\n    return null;\n}\n","name":"findCustomer","className":"Bank","variables":{"c":3,"customers":1},"constants":{"null":1},"javaDoc":"Finds a customer in the bank aNumber a customer number aPin a personal identification number the matching customer or null if no customer matches","comments":" \n      Finds a customer in the bank.\n      @param aNumber a customer number\n      @param aPin a personal identification number\n      @return the matching customer, or null if no customer \n      matches\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Bank"],"returnType":"ATM","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   */\npublic ATM(Bank aBank) {\n    theBank = aBank;\n    reset();\n}\n","name":"ATM","className":"ATM","variables":{"theBank":1,"aBank":1},"constants":{},"javaDoc":"Constructs an ATM for a given bank aBank the bank to which this ATM connects","comments":"\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Resets the ATM to the initial state.\n   */\npublic void reset() {\n    customerNumber = -1;\n    currentAccount = null;\n    state = START;\n}\n","name":"reset","className":"ATM","variables":{"START":1,"currentAccount":1,"state":1,"customerNumber":1},"constants":{"1":1,"null":1},"javaDoc":"Resets the ATM to the initial state","comments":"\n      Resets the ATM to the initial state.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   */\npublic void setCustomerNumber(int number) {\n    customerNumber = number;\n    state = PIN;\n}\n","name":"setCustomerNumber","className":"ATM","variables":{"number":1,"PIN":1,"state":1,"customerNumber":1},"constants":{},"javaDoc":"Sets the current customer number and sets state to PIN (Precondition: state is START) number the customer number","comments":" \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"findCustomer":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":11,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   */\npublic void selectCustomer(int pin) {\n    currentCustomer = theBank.findCustomer(customerNumber, pin);\n    if (currentCustomer == null) {\n        state = START;\n    } else {\n        state = ACCOUNT;\n    }\n}\n","name":"selectCustomer","className":"ATM","variables":{"ACCOUNT":1,"currentCustomer":2,"theBank":1,"START":1,"state":2},"constants":{"null":1},"javaDoc":"Finds customer in bank If found sets state to ACCOUNT else to START (Precondition: state is PIN) pin the PIN of the current customer","comments":" \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getCheckingAccount":1,"getSavingsAccount":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":12,"AssignExpr":3,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   */\npublic void selectAccount(int account) {\n    if (account == CHECKING) {\n        currentAccount = currentCustomer.getCheckingAccount();\n    } else {\n        currentAccount = currentCustomer.getSavingsAccount();\n    }\n    state = TRANSACT;\n}\n","name":"selectAccount","className":"ATM","variables":{"currentCustomer":2,"TRANSACT":1,"CHECKING":1,"currentAccount":2,"state":1,"account":1},"constants":{},"javaDoc":"Sets current account to checking or savings Sets state to TRANSACT (Precondition: state is ACCOUNT or TRANSACT) account one of CHECKING or SAVINGS","comments":" \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"withdraw":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   */\npublic void withdraw(double value) {\n    currentAccount.withdraw(value);\n}\n","name":"withdraw","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Withdraws amount from current account (Precondition: state is TRANSACT) value the amount to withdraw","comments":" \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"deposit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   */\npublic void deposit(double value) {\n    currentAccount.deposit(value);\n}\n","name":"deposit","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Deposits amount to current account (Precondition: state is TRANSACT) value the amount to deposit","comments":" \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getBalance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   */\npublic double getBalance() {\n    return currentAccount.getBalance();\n}\n","name":"getBalance","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Gets the balance of the current account (Precondition: state is TRANSACT) the balance","comments":" \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":12,"AssignExpr":3},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":3},"text":"/**\n      Moves back to the previous state.\n   */\npublic void back() {\n    if (state == TRANSACT) {\n        state = ACCOUNT;\n    } else if (state == ACCOUNT) {\n        state = PIN;\n    } else if (state == PIN) {\n        state = START;\n    }\n}\n","name":"back","className":"ATM","variables":{"ACCOUNT":2,"TRANSACT":1,"PIN":2,"START":1,"state":6},"constants":{},"javaDoc":"Moves back to the previous state","comments":"\n      Moves back to the previous state.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current state of this ATM.\n      @return the current state\n   */\npublic int getState() {\n    return state;\n}\n","name":"getState","className":"ATM","variables":{"state":1},"constants":{},"javaDoc":"Gets the current state of this ATM the current state","comments":"\n      Gets the current state of this ATM.\n      @return the current state\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    display.setText(\"\");\n}\n","name":"actionPerformed","className":"ClearButtonListener","variables":{"display":1},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"KeyPad","methodCalls":{"add":3,"addActionListener":1,"addButton":11,"setLayout":2,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"ClearButtonListener":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":50,"StringLiteralExpr":15,"MethodCallExpr":18,"AssignExpr":3},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":22},"text":"/**\n      Constructs the keypad panel.\n   */\npublic KeyPad() {\n    setLayout(new BorderLayout());\n    // Add display field\n    display = new JTextField();\n    add(display, \"North\");\n    // Make button panel\n    buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 3));\n    // Add digit buttons\n    addButton(\"7\");\n    addButton(\"8\");\n    addButton(\"9\");\n    addButton(\"4\");\n    addButton(\"5\");\n    addButton(\"6\");\n    addButton(\"1\");\n    addButton(\"2\");\n    addButton(\"3\");\n    addButton(\"0\");\n    addButton(\".\");\n    // Add clear entry button\n    clearButton = new JButton(\"CE\");\n    buttonPanel.add(clearButton);\n    class ClearButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            display.setText(\"\");\n        }\n    }\n    ActionListener listener = new ClearButtonListener();\n    clearButton.addActionListener(new ClearButtonListener());\n    add(buttonPanel, \"Center\");\n}\n","name":"KeyPad","className":"KeyPad","variables":{"actionPerformed":1,"clearButton":2,"display":2,"buttonPanel":3,"listener":1,"ClearButtonListener":1,"event":1},"constants":{"\"North\"":1,"\"\"":1,"\"9\"":1,"\"8\"":1,"\"Center\"":1,"\"7\"":1,"\"6\"":1,"\"CE\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"3":1,"\"1\"":1,"4":1,"\"0\"":1,"\".\"":1},"javaDoc":"Constructs the keypad panel","comments":"Add display field Make button panel Add digit buttons Add clear entry button \n      Constructs the keypad panel.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":2,"equals":1,"indexOf":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":3,"NameExpr":15,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    // Don't add two decimal points\n    if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n        return;\n    }\n    // Append label text to button\n    display.setText(display.getText() + label);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"display":3,"label":2},"constants":{"1":1,"\".\"":2},"javaDoc":"","comments":"Don't add two decimal points Append label text to button ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"getText":2,"equals":1,"addActionListener":1,"indexOf":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":28,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"TypeDeclarationStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Adds a button to the button panel \n      @param label the button label\n   */\nprivate void addButton(final String label) {\n    class DigitButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            // Don't add two decimal points\n            if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n                return;\n            }\n            // Append label text to button\n            display.setText(display.getText() + label);\n        }\n    }\n    JButton button = new JButton(label);\n    buttonPanel.add(button);\n    ActionListener listener = new DigitButtonListener();\n    button.addActionListener(listener);\n}\n","name":"addButton","className":"KeyPad","variables":{"button":2,"actionPerformed":1,"DigitButtonListener":1,"display":3,"buttonPanel":1,"listener":1,"label":3,"event":1},"constants":{"1":1,"\".\"":2},"javaDoc":"Adds a button to the button panel label the button label","comments":"Don't add two decimal points Append label text to button \n      Adds a button to the button panel \n      @param label the button label\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"double","methodCalls":{"parseDouble":1,"getText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   */\npublic double getValue() {\n    return Double.parseDouble(display.getText());\n}\n","name":"getValue","className":"KeyPad","variables":{"display":1,"Double":1},"constants":{},"javaDoc":"Gets the value that the user entered the value in the text field of the keypad","comments":" \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Clears the display. \n   */\npublic void clear() {\n    display.setText(\"\");\n}\n","name":"clear","className":"KeyPad","variables":{"display":1},"constants":{"\"\"":1},"javaDoc":"Clears the display","comments":" \n      Clears the display. \n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ATM"],"returnType":"ATMFrame","methodCalls":{"add":6,"showState":1,"setSize":1,"addActionListener":3,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":45,"StringLiteralExpr":3,"AssignExpr":6,"MethodCallExpr":12},"statements":{"ExpressionStmt":19},"text":"/**\n      Constructs the user interface of the ATM frame.\n   */\npublic ATMFrame(ATM anATM) {\n    theATM = anATM;\n    // Construct components\n    pad = new KeyPad();\n    display = new JTextArea(4, 20);\n    aButton = new JButton(\"  A  \");\n    aButton.addActionListener(new AButtonListener());\n    bButton = new JButton(\"  B  \");\n    bButton.addActionListener(new BButtonListener());\n    cButton = new JButton(\"  C  \");\n    cButton.addActionListener(new CButtonListener());\n    // Add components\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.add(aButton);\n    buttonPanel.add(bButton);\n    buttonPanel.add(cButton);\n    setLayout(new FlowLayout());\n    add(pad);\n    add(display);\n    add(buttonPanel);\n    showState();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"ATMFrame","className":"ATMFrame","variables":{"aButton":2,"pad":1,"theATM":1,"anATM":1,"display":1,"buttonPanel":4,"cButton":2,"bButton":2},"constants":{"\"  C  \"":1,"\"  B  \"":1,"4":1,"\"  A  \"":1,"20":1},"javaDoc":"Constructs the user interface of the ATM frame","comments":"Add components Construct components \n      Constructs the user interface of the ATM frame.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getState":1,"getBalance":1,"clear":1,"setText":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":8,"NameExpr":37,"StringLiteralExpr":7,"FieldAccessExpr":4,"MethodCallExpr":7},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":6},"text":"/** \n      Updates display message.\n   */\npublic void showState() {\n    int state = theATM.getState();\n    pad.clear();\n    if (state == ATM.START) {\n        display.setText(\"Enter customer number\\nA = OK\");\n    } else if (state == ATM.PIN) {\n        display.setText(\"Enter PIN\\nA = OK\");\n    } else if (state == ATM.ACCOUNT) {\n        display.setText(\"Select Account\\n\" + \"A = Checking\\nB = Savings\\nC = Exit\");\n    } else if (state == ATM.TRANSACT) {\n        display.setText(\"Balance = \" + theATM.getBalance() + \"\\nEnter amount and select transaction\\n\" + \"A = Withdraw\\nB = Deposit\\nC = Cancel\");\n    }\n}\n","name":"showState","className":"ATMFrame","variables":{"pad":1,"theATM":2,"display":4,"state":5},"constants":{"\"Select Account\\n\"":1,"\"Balance = \"":1,"\"A = Withdraw\\nB = Deposit\\nC = Cancel\"":1,"\"Enter PIN\\nA = OK\"":1,"\"A = Checking\\nB = Savings\\nC = Exit\"":1,"\"\\nEnter amount and select transaction\\n\"":1,"\"Enter customer number\\nA = OK\"":1},"javaDoc":"Updates display message","comments":" \n      Updates display message.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setCustomerNumber":1,"showState":1,"getValue":3,"getState":1,"selectAccount":1,"back":1,"selectCustomer":1,"withdraw":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":48,"CastExpr":2,"FieldAccessExpr":5,"MethodCallExpr":10},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":7},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.START) {\n        theATM.setCustomerNumber((int) pad.getValue());\n    } else if (state == ATM.PIN) {\n        theATM.selectCustomer((int) pad.getValue());\n    } else if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.CHECKING);\n    } else if (state == ATM.TRANSACT) {\n        theATM.withdraw(pad.getValue());\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"AButtonListener","variables":{"pad":3,"theATM":6,"state":5},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getValue":1,"getState":1,"selectAccount":1,"deposit":1,"back":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":28,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.SAVINGS);\n    } else if (state == ATM.TRANSACT) {\n        theATM.deposit(pad.getValue());\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"BButtonListener","variables":{"pad":1,"theATM":4,"state":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getState":1,"reset":1,"back":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":19,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.reset();\n    } else if (state == ATM.TRANSACT) {\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"CButtonListener","variables":{"theATM":3,"state":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"openConnection":1,"hasNextLine":1,"getResponseCode":1,"getResponseMessage":1,"getInputStream":1,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["Casting"],"types":{"Scanner":1,"HttpURLConnection":1,"InputStream":1,"String":3,"URL":1,"URLConnection":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"VariableDeclarationExpr":9,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":50,"StringLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":5,"AssignExpr":2,"MethodCallExpr":9},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":14},"text":"public static void main(String[] args) throws IOException {\n    // Get command line arguments\n    String urlString;\n    if (args.length == 1) {\n        urlString = args[0];\n    } else {\n        urlString = \"http://horstmann.com/\";\n        System.out.println(\"Using \" + urlString);\n    }\n    // Open connection\n    URL u = new URL(urlString);\n    URLConnection connection = u.openConnection();\n    // Check if response code is HTTP_OK (200)\n    HttpURLConnection httpConnection = (HttpURLConnection) connection;\n    int code = httpConnection.getResponseCode();\n    String message = httpConnection.getResponseMessage();\n    System.out.println(code + \" \" + message);\n    if (code != HttpURLConnection.HTTP_OK) {\n        return;\n    }\n    // Read server response\n    InputStream instream = connection.getInputStream();\n    Scanner in = new Scanner(instream);\n    while (in.hasNextLine()) {\n        String input = in.nextLine();\n        System.out.println(input);\n    }\n}\n","name":"main","className":"URLGet","variables":{"args":1,"input":1,"code":3,"u":2,"in":3,"urlString":5,"connection":3,"httpConnection":3,"instream":2,"message":2},"constants":{"0":1,"1":1,"\" \"":1,"\"Using \"":1,"\"http://horstmann.com/\"":1},"javaDoc":"","comments":"Get command line arguments Open connection Check if response code is HTTP_OK (200) Read server response ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":1,"flush":1,"nextLine":1,"hasNextLine":1,"getOutputStream":1,"getInputStream":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables","ExceptionHandling"],"types":{"Scanner":1,"InputStream":1,"OutputStream":1,"String":4,"int":1,"Socket":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":3,"VariableDeclarationExpr":10,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":45,"StringLiteralExpr":7,"FieldAccessExpr":3,"AssignExpr":4,"MethodCallExpr":8},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":17},"text":"public static void main(String[] args) throws IOException {\n    // Get command-line arguments\n    String host;\n    String resource;\n    if (args.length == 2) {\n        host = args[0];\n        resource = args[1];\n    } else {\n        System.out.println(\"Getting / from horstmann.com\");\n        host = \"horstmann.com\";\n        resource = \"/\";\n    }\n    // Open socket\n    final int HTTP_PORT = 80;\n    try (Socket s = new Socket(host, HTTP_PORT)) {\n        // Get streams\n        InputStream instream = s.getInputStream();\n        OutputStream outstream = s.getOutputStream();\n        // Turn streams into scanners and writers\n        Scanner in = new Scanner(instream);\n        PrintWriter out = new PrintWriter(outstream);\n        // Send command\n        String command = \"GET \" + resource + \" HTTP/1.1\\n\" + \"Host: \" + host + \"\\n\\n\";\n        out.print(command);\n        out.flush();\n        while (in.hasNextLine()) {\n            String input = in.nextLine();\n            System.out.println(input);\n        }\n    }\n// The try-with-resources statement closes the socket\n}\n          // Read server response\n\n","name":"main","className":"WebGet","variables":{"args":2,"input":1,"s":3,"outstream":2,"resource":4,"in":3,"host":5,"HTTP_PORT":2,"instream":2,"command":1,"out":3},"constants":{"0":1,"1":1,"2":1,"\"\\n\\n\"":1,"\"/\"":1,"80":1,"\"Getting / from horstmann.com\"":1,"\"horstmann.com\"":1,"\"GET \"":1,"\" HTTP/1.1\\n\"":1,"\"Host: \"":1},"javaDoc":"","comments":"Get command-line arguments Open socket The try-with-resources statement closes the socket Get streams Turn streams into scanners and writers Send command Read server response ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":1,"System.out.println":2,"accept":1},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables"],"types":{"BankService":1,"Bank":1,"ServerSocket":1,"int":2,"Socket":1,"Thread":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":4,"VariableDeclarationExpr":7,"BooleanLiteralExpr":1,"NameExpr":21,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) throws IOException {\n    final int ACCOUNTS_LENGTH = 10;\n    Bank bank = new Bank(ACCOUNTS_LENGTH);\n    final int SBAP_PORT = 8888;\n    ServerSocket server = new ServerSocket(SBAP_PORT);\n    System.out.println(\"Waiting for clients to connect...\");\n    while (true) {\n        Socket s = server.accept();\n        System.out.println(\"Client connected.\");\n        BankService service = new BankService(s, bank);\n        Thread t = new Thread(service);\n        t.start();\n    }\n}\n","name":"main","className":"BankServer","variables":{"server":2,"bank":2,"s":2,"SBAP_PORT":2,"t":2,"service":2,"ACCOUNTS_LENGTH":2},"constants":{"\"Waiting for clients to connect...\"":1,"true":1,"8888":1,"\"Client connected.\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n    balanceChangeLock = new ReentrantLock();\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"balanceChangeLock":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   */\npublic BankAccount(double initialBalance) {\n    balance = initialBalance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"initialBalance":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance initialBalance the initial balance","comments":"\n      Constructs a bank account with a given balance.\n      @param initialBalance the initial balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"unlock":1,"lock":1},"annotations":[],"exceptions":[],"concepts":["ExceptionHandling"],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"MethodCallExpr":2,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balanceChangeLock.lock();\n    try {\n        double newBalance = balance + amount;\n        balance = newBalance;\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2,"balanceChangeLock":2},"constants":{},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"unlock":1,"lock":1},"annotations":[],"exceptions":[],"concepts":["ExceptionHandling"],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"MethodCallExpr":2,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    balanceChangeLock.lock();\n    try {\n        double newBalance = balance - amount;\n        balance = newBalance;\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2,"newBalance":2,"balanceChangeLock":2},"constants":{},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Bank","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":9,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Constructs a bank account with a given number of accounts.\n      @param size the number of accounts\n   */\npublic Bank(int size) {\n    accounts = new BankAccount[size];\n    for (int i = 0; i < accounts.length; i++) {\n        accounts[i] = new BankAccount();\n    }\n}\n","name":"Bank","className":"Bank","variables":{"size":1,"i":4,"accounts":2},"constants":{"0":1},"javaDoc":"Constructs a bank account with a given number of accounts size the number of accounts","comments":"\n      Constructs a bank account with a given number of accounts.\n      @param size the number of accounts\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{"deposit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Deposits money into a bank account.\n      @param accountNumber the account number\n      @param amount the amount to deposit\n   */\npublic void deposit(int accountNumber, double amount) {\n    BankAccount account = accounts[accountNumber];\n    account.deposit(amount);\n}\n","name":"deposit","className":"Bank","variables":{"accounts":1,"accountNumber":1,"account":2},"constants":{},"javaDoc":"Deposits money into a bank account accountNumber the account number amount the amount to deposit","comments":"\n      Deposits money into a bank account.\n      @param accountNumber the account number\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","double"],"returnType":"void","methodCalls":{"withdraw":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Withdraws money from a bank account.\n      @param accountNumber the account number\n      @param amount the amount to withdraw\n   */\npublic void withdraw(int accountNumber, double amount) {\n    BankAccount account = accounts[accountNumber];\n    account.withdraw(amount);\n}\n","name":"withdraw","className":"Bank","variables":{"accounts":1,"accountNumber":1,"account":2},"constants":{},"javaDoc":"Withdraws money from a bank account accountNumber the account number amount the amount to withdraw","comments":"\n      Withdraws money from a bank account.\n      @param accountNumber the account number\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{"getBalance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BankAccount":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Gets the balance of a bank account.\n      @param accountNumber the account number\n      @return the account balance\n   */\npublic double getBalance(int accountNumber) {\n    BankAccount account = accounts[accountNumber];\n    return account.getBalance();\n}\n","name":"getBalance","className":"Bank","variables":{"accounts":1,"accountNumber":1,"account":2},"constants":{},"javaDoc":"Gets the balance of a bank account accountNumber the account number the account balance","comments":"\n      Gets the balance of a bank account.\n      @param accountNumber the account number\n      @return the account balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":3,"flush":3,"nextLine":2,"getOutputStream":1,"getInputStream":1,"System.out.println":5},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables","ExceptionHandling"],"types":{"Scanner":1,"InputStream":1,"OutputStream":1,"String":2,"int":1,"Socket":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":3,"VariableDeclarationExpr":8,"BinaryExpr":8,"StringLiteralExpr":12,"NameExpr":69,"FieldAccessExpr":5,"MethodCallExpr":15,"AssignExpr":3},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":21},"text":"public static void main(String[] args) throws IOException {\n    final int SBAP_PORT = 8888;\n    try (Socket s = new Socket(\"localhost\", SBAP_PORT)) {\n        InputStream instream = s.getInputStream();\n        OutputStream outstream = s.getOutputStream();\n        Scanner in = new Scanner(instream);\n        PrintWriter out = new PrintWriter(outstream);\n        String command = \"DEPOSIT 3 1000\";\n        System.out.println(\"Sending: \" + command);\n        out.print(command + \"\\n\");\n        out.flush();\n        String response = in.nextLine();\n        System.out.println(\"Receiving: \" + response);\n        command = \"WITHDRAW 3 500\";\n        System.out.println(\"Sending: \" + command);\n        out.print(command + \"\\n\");\n        out.flush();\n        response = in.nextLine();\n        System.out.println(\"Receiving: \" + response);\n        command = \"QUIT\";\n        System.out.println(\"Sending: \" + command);\n        out.print(command + \"\\n\");\n        out.flush();\n    }\n}\n","name":"main","className":"BankClient","variables":{"s":3,"outstream":2,"SBAP_PORT":2,"in":3,"response":4,"instream":2,"command":9,"out":7},"constants":{"\"localhost\"":1,"\"QUIT\"":1,"\"DEPOSIT 3 1000\"":1,"\"WITHDRAW 3 500\"":1,"8888":1,"\"Receiving: \"":2,"\"Sending: \"":3,"\"\\n\"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Socket","Bank"],"returnType":"BankService","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a service object that processes commands\n      from a socket for a bank.\n      @param aSocket the socket\n      @param aBank the bank\n   */\npublic BankService(Socket aSocket, Bank aBank) {\n    s = aSocket;\n    bank = aBank;\n}\n","name":"BankService","className":"BankService","variables":{"bank":1,"s":1,"aBank":1,"aSocket":1},"constants":{},"javaDoc":"Constructs a service object that processes commands from a socket for a bank aSocket the socket aBank the bank","comments":"\n      Constructs a service object that processes commands\n      from a socket for a bank.\n      @param aSocket the socket\n      @param aBank the bank\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"doService":1,"printStackTrace":1,"getOutputStream":1,"getInputStream":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":16,"AssignExpr":2,"MethodCallExpr":5},"statements":{"TryStmt":2,"BlockStmt":4,"ExpressionStmt":5},"text":"public void run() {\n    try {\n        try {\n            in = new Scanner(s.getInputStream());\n            out = new PrintWriter(s.getOutputStream());\n            doService();\n        } finally {\n            s.close();\n        }\n    } catch (IOException exception) {\n        exception.printStackTrace();\n    }\n}\n","name":"run","className":"BankService","variables":{"exception":2,"s":3,"in":1,"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"next":1,"equals":1,"hasNext":1,"executeCommand":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n      Executes all commands until the QUIT command or the\n      end of input.\n   */\npublic void doService() throws IOException {\n    while (true) {\n        if (!in.hasNext()) {\n            return;\n        }\n        String command = in.next();\n        if (command.equals(\"QUIT\")) {\n            return;\n        } else {\n            executeCommand(command);\n        }\n    }\n}\n","name":"doService","className":"BankService","variables":{"in":2,"command":2},"constants":{"\"QUIT\"":1,"true":1},"javaDoc":"Executes all commands until the QUIT command or the end of input","comments":"\n      Executes all commands until the QUIT command or the\n      end of input.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":2,"getBalance":1,"flush":2,"equals":3,"deposit":1,"nextInt":1,"nextDouble":2,"withdraw":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2,"int":1},"expressions":{"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":45,"StringLiteralExpr":5,"UnaryExpr":1,"MethodCallExpr":13},"statements":{"IfStmt":3,"BlockStmt":3,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n      Executes a single command.\n      @param command the command to execute\n   */\npublic void executeCommand(String command) {\n    int account = in.nextInt();\n    if (command.equals(\"DEPOSIT\")) {\n        double amount = in.nextDouble();\n        bank.deposit(account, amount);\n    } else if (command.equals(\"WITHDRAW\")) {\n        double amount = in.nextDouble();\n        bank.withdraw(account, amount);\n    } else if (!command.equals(\"BALANCE\")) {\n        out.println(\"Invalid command\");\n        out.flush();\n        return;\n    }\n    out.println(account + \" \" + bank.getBalance(account));\n    out.flush();\n}\n","name":"executeCommand","className":"BankService","variables":{"amount":2,"bank":3,"in":3,"account":2,"command":3,"out":4},"constants":{"\"Invalid command\"":1,"\"WITHDRAW\"":1,"\" \"":1,"\"BALANCE\"":1,"\"DEPOSIT\"":1},"javaDoc":"Executes a single command command the command to execute","comments":"\n      Executes a single command.\n      @param command the command to execute\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int","int"],"returnType":"int","methodCalls":{"search":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":23,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":3,"BlockStmt":5,"ReturnStmt":4,"ExpressionStmt":1},"text":"/**\n      Finds a value in a range of a sorted array, using the binary\n      search algorithm.\n      @param a the array in which to search\n      @param low the low index of the range\n      @param high the high index of the range\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   */\npublic static int search(int[] a, int low, int high, int value) {\n    if (low <= high) {\n        int mid = (low + high) / 2;\n        if (a[mid] == value) {\n            return mid;\n        } else if (a[mid] < value) {\n            return search(a, mid + 1, high, value);\n        } else {\n            return search(a, low, mid - 1, value);\n        }\n    } else {\n        return -1;\n    }\n}\n","name":"search","className":"BinarySearcher","variables":{"a":2,"high":2,"low":2,"mid":6,"value":2},"constants":{"1":3,"2":1},"javaDoc":"Finds a value in a range of a sorted array using the binary search algorithm a the array in which to search low the low index of the range high the high index of the range value the value to find the index at which the value occurs or -1 if it does not occur in the array","comments":"\n      Finds a value in a range of a sorted array, using the binary\n      search algorithm.\n      @param a the array in which to search\n      @param low the low index of the range\n      @param high the high index of the range\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"search":1,"randomIntArray":1,"toString":1,"sort":1,"nextInt":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"boolean":1,"int[]":1,"int":2},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"BooleanLiteralExpr":2,"BinaryExpr":3,"NameExpr":44,"StringLiteralExpr":2,"FieldAccessExpr":5,"UnaryExpr":2,"MethodCallExpr":8,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    Arrays.sort(a);\n    System.out.println(Arrays.toString(a));\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"Enter number to search for, -1 to quit: \");\n        int n = in.nextInt();\n        if (n == -1) {\n            done = true;\n        } else {\n            int pos = BinarySearcher.search(a, 0, a.length - 1, n);\n            System.out.println(\"Found in position \" + pos);\n        }\n    }\n}\n","name":"main","className":"BinarySearchDemo","variables":{"a":1,"BinarySearcher":1,"in":2,"pos":2,"Arrays":2,"done":3,"n":2,"ArrayUtil":1},"constants":{"0":1,"100":1,"1":2,"\"Enter number to search for, -1 to quit: \"":1,"false":1,"true":1,"\"Found in position \"":1,"20":1},"javaDoc":"","comments":"Construct random array ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"constants":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":6,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"constants":{"true":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":9,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{"false":1},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":8,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"constants":{"0":1,"false":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"stop":1,"start":1,"nextInt":1,"sort":1,"System.out.print":1,"getElapsedTime":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int[]":1,"int":1,"StopWatch":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":33,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter array size: \");\n    int n = in.nextInt();\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(n, 100);\n    // Use stopwatch to time selection sort\n    StopWatch timer = new StopWatch();\n    timer.start();\n    SelectionSorter.sort(a);\n    timer.stop();\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"SelectionSortTimer","variables":{"a":1,"timer":4,"in":2,"SelectionSorter":1,"n":1,"ArrayUtil":1},"constants":{"100":1,"\" milliseconds\"":1,"\"Enter array size: \"":1,"\"Elapsed time: \"":1},"javaDoc":"","comments":"Construct random array Use stopwatch to time selection sort ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"swap":1,"minimumPosition":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":15,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        int minPos = minimumPosition(a, i);\n        ArrayUtil.swap(a, minPos, i);\n    }\n}\n","name":"sort","className":"SelectionSorter","variables":{"i":3,"minPos":1,"ArrayUtil":1},"constants":{"0":1,"1":1},"javaDoc":"Sorts an array using selection sort a the array to sort","comments":"\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":14,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   */\nprivate static int minimumPosition(int[] a, int from) {\n    int minPos = from;\n    for (int i = from + 1; i < a.length; i++) {\n        if (a[i] < a[minPos]) {\n            minPos = i;\n        }\n    }\n    return minPos;\n}\n","name":"minimumPosition","className":"SelectionSorter","variables":{"a":2,"minPos":4,"i":5,"from":2},"constants":{"1":1},"javaDoc":"Finds the smallest element in a tail range of the array a the array to sort from the first position in a to compare the position of the smallest element in the range a[from] a[a length - 1]","comments":"\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":3,"comparing":2,"toString":3,"sort":3,"getArea":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Country[]":1,"String[]":1},"expressions":{"IntegerLiteralExpr":7,"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"LambdaExpr":3,"BinaryExpr":1,"StringLiteralExpr":14,"NameExpr":61,"AssignExpr":4,"ArrayInitializerExpr":2,"FieldAccessExpr":3,"ArrayCreationExpr":2,"MethodCallExpr":15},"statements":{"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    String[] words = { \"Mary\", \"had\", \"a\", \"little\", \"lamb\" };\n    Arrays.sort(words, ( v,  w) -> v.length() - w.length());\n    System.out.println(Arrays.toString(words));\n    words = new String[] { \"Its\", \"fleece\", \"was\", \"white\", \"as\", \"snow\" };\n    Arrays.sort(words, Comparator.comparing( w -> w.length()));\n    System.out.println(Arrays.toString(words));\n    Country[] countries = new Country[3];\n    countries[0] = new Country(\"Uruguay\", 176220);\n    countries[1] = new Country(\"Thailand\", 513120);\n    countries[2] = new Country(\"Belgium\", 30510);\n    Arrays.sort(countries, Comparator.comparing( c -> c.getArea()));\n    System.out.println(Arrays.toString(countries));\n}\n","name":"main","className":"ComparatorDemo","variables":{"c":2,"v":2,"w":4,"words":2,"countries":4,"Arrays":6,"Comparator":2},"constants":{"\"Thailand\"":1,"\"a\"":1,"513120":1,"\"Belgium\"":1,"\"little\"":1,"\"Mary\"":1,"\"Uruguay\"":1,"\"was\"":1,"\"snow\"":1,"0":1,"1":1,"\"lamb\"":1,"2":1,"30510":1,"3":1,"\"white\"":1,"\"fleece\"":1,"\"had\"":1,"176220":1,"\"Its\"":1,"\"as\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public double getMeasure() {\n    return area;\n}\n","name":"getMeasure","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"Country[name=\" + name + \",area=\" + area + \"]\";\n}\n","name":"toString","className":"Country","variables":{"area":1,"name":1},"constants":{"\"]\"":1,"\",area=\"":1,"\"Country[name=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"merge":1,"sort":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int[]":2,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"ArrayAccessExpr":4,"BinaryExpr":6,"NameExpr":44,"FieldAccessExpr":7,"ArrayCreationExpr":2,"UnaryExpr":2,"AssignExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":3,"ReturnStmt":1,"ForStmt":2,"ExpressionStmt":7},"text":"/**\n      Sorts an array, using merge sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    if (a.length <= 1) {\n        return;\n    }\n    int[] first = new int[a.length / 2];\n    int[] second = new int[a.length - first.length];\n    // Copy the first half of a into first, the second half into second\n    for (int i = 0; i < first.length; i++) {\n        first[i] = a[i];\n    }\n    for (int i = 0; i < second.length; i++) {\n        second[i] = a[first.length + i];\n    }\n    sort(first);\n    sort(second);\n    merge(first, second, a);\n}\n","name":"sort","className":"MergeSorter","variables":{"a":2,"i":10,"first":2,"second":2},"constants":{"0":2,"1":1,"2":1},"javaDoc":"Sorts an array using merge sort a the array to sort","comments":"Copy the first half of a into first the second half into second \n      Sorts an array, using merge sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int[]","int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":10,"BinaryExpr":6,"NameExpr":43,"FieldAccessExpr":4,"UnaryExpr":7,"AssignExpr":4},"statements":{"IfStmt":1,"WhileStmt":3,"BlockStmt":5,"ExpressionStmt":14},"text":"/**\n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   */\nprivate static void merge(int[] first, int[] second, int[] a) {\n    // Next element to consider in the first array\n    int iFirst = 0;\n    // Next element to consider in the second array\n    int iSecond = 0;\n    // Next open position in a\n    int j = 0;\n    // the smaller element into a\n    while (iFirst < first.length && iSecond < second.length) {\n        if (first[iFirst] < second[iSecond]) {\n            a[j] = first[iFirst];\n            iFirst++;\n        } else {\n            a[j] = second[iSecond];\n            iSecond++;\n        }\n        j++;\n    }\n    // Copy any remaining entries of the first array\n    while (iFirst < first.length) {\n        a[j] = first[iFirst];\n        iFirst++;\n        j++;\n    }\n    // Copy any remaining entries of the second half\n    while (iSecond < second.length) {\n        a[j] = second[iSecond];\n        iSecond++;\n        j++;\n    }\n}\n       // As long as neither iFirst nor iSecond is past the end, move\n\n       // Note that only one of the two loops below copies entries\n\n","name":"merge","className":"MergeSorter","variables":{"a":4,"iSecond":8,"j":8,"first":3,"iFirst":8,"second":3},"constants":{"0":3},"javaDoc":"Merges two sorted arrays into an array first the first sorted array second the second sorted array a the array into which to merge first and second","comments":"As long as neither iFirst nor iSecond is past the end move Note that only one of the two loops below copies entries Next element to consider in the first array Next element to consider in the second array Next open position in a the smaller element into a Copy any remaining entries of the first array Copy any remaining entries of the second half \n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"stop":1,"start":1,"nextInt":1,"sort":1,"System.out.print":1,"getElapsedTime":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"int[]":1,"int":1,"StopWatch":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":33,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter array size: \");\n    int n = in.nextInt();\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(n, 100);\n    // Use stopwatch to time merge sort\n    StopWatch timer = new StopWatch();\n    timer.start();\n    MergeSorter.sort(a);\n    timer.stop();\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"MergeSortTimer","variables":{"a":1,"timer":4,"in":2,"MergeSorter":1,"n":1,"ArrayUtil":1},"constants":{"100":1,"\" milliseconds\"":1,"\"Enter array size: \"":1,"\"Elapsed time: \"":1},"javaDoc":"","comments":"Construct random array Use stopwatch to time merge sort ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"constants":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":6,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"constants":{"true":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":9,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{"false":1},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":8,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"constants":{"0":1,"false":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"search":1,"randomIntArray":1,"toString":1,"nextInt":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"boolean":1,"int[]":1,"int":2},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"BooleanLiteralExpr":2,"BinaryExpr":2,"NameExpr":37,"StringLiteralExpr":2,"FieldAccessExpr":4,"UnaryExpr":2,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"Enter number to search for, -1 to quit: \");\n        int n = in.nextInt();\n        if (n == -1) {\n            done = true;\n        } else {\n            int pos = LinearSearcher.search(a, n);\n            System.out.println(\"Found in position \" + pos);\n        }\n    }\n}\n","name":"main","className":"LinearSearchDemo","variables":{"a":1,"in":2,"pos":2,"Arrays":1,"done":3,"n":2,"LinearSearcher":1,"ArrayUtil":1},"constants":{"100":1,"1":1,"\"Enter number to search for, -1 to quit: \"":1,"false":1,"true":1,"\"Found in position \"":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":9,"FieldAccessExpr":1,"UnaryExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2},"text":"/**\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   */\npublic static int search(int[] a, int value) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] == value) {\n            return i;\n        }\n    }\n    return -1;\n}\n","name":"search","className":"LinearSearcher","variables":{"a":1,"i":5,"value":1},"constants":{"0":1,"1":1},"javaDoc":"Finds a value in an array using the linear search algorithm a the array to search value the value to find the index at which the value occurs or -1 if it does not occur in the array","comments":"\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    QuickSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"QuickSortDemo","variables":{"a":1,"QuickSorter":1,"Arrays":2,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sorts an array, using quick sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    sort(a, 0, a.length - 1);\n}\n","name":"sort","className":"QuickSorter","variables":{},"constants":{"0":1,"1":1},"javaDoc":"Sorts an array using quick sort a the array to sort","comments":"\n      Sorts an array, using quick sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{"partition":1,"sort":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":17,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Sorts a portion of an array, using quick sort.\n      @param a the array to sort\n      @param from the first index of the portion to be sorted\n      @param to the last index of the portion to be sorted\n   */\npublic static void sort(int[] a, int from, int to) {\n    if (from >= to) {\n        return;\n    }\n    int p = partition(a, from, to);\n    sort(a, from, p);\n    sort(a, p + 1, to);\n}\n","name":"sort","className":"QuickSorter","variables":{"p":2,"from":1,"to":1},"constants":{"1":1},"javaDoc":"Sorts a portion of an array using quick sort a the array to sort from the first index of the portion to be sorted to the last index of the portion to be sorted","comments":"\n      Sorts a portion of an array, using quick sort.\n      @param a the array to sort\n      @param from the first index of the portion to be sorted\n      @param to the last index of the portion to be sorted\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"int","methodCalls":{"swap":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":6,"NameExpr":25,"UnaryExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"WhileStmt":3,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Partitions a portion of an array.\n      @param a the array to partition\n      @param from the first index of the portion to be partitioned\n      @param to the last index of the portion to be partitioned\n      @return the last index of the first partition\n   */\nprivate static int partition(int[] a, int from, int to) {\n    int pivot = a[from];\n    int i = from - 1;\n    int j = to + 1;\n    while (i < j) {\n        i++;\n        while (a[i] < pivot) {\n            i++;\n        }\n        j--;\n        while (a[j] > pivot) {\n            j--;\n        }\n        if (i < j) {\n            ArrayUtil.swap(a, i, j);\n        }\n    }\n    return j;\n}\n","name":"partition","className":"QuickSorter","variables":{"a":3,"pivot":3,"i":6,"from":2,"j":7,"to":1,"ArrayUtil":1},"constants":{"1":2},"javaDoc":"Partitions a portion of an array a the array to partition from the first index of the portion to be partitioned to the last index of the portion to be partitioned the last index of the first partition","comments":"\n      Partitions a portion of an array.\n      @param a the array to partition\n      @param from the first index of the portion to be partitioned\n      @param to the last index of the portion to be partitioned\n      @return the last index of the first partition\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"stop":3,"equals":1,"start":3,"reset":2,"nextInt":1,"sort":3,"copyOf":2,"System.out.print":1,"getElapsedTime":3,"System.out.println":3},"annotations":[],"exceptions":["IllegalStateException"],"concepts":[],"types":{"Scanner":1,"int[]":3,"int":1,"StopWatch":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":6,"NameExpr":94,"StringLiteralExpr":8,"FieldAccessExpr":7,"UnaryExpr":1,"MethodCallExpr":23},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":21},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter array size: \");\n    int n = in.nextInt();\n    // Construct random array\n    int[] a = ArrayUtil.randomIntArray(n, 100);\n    int[] a2 = Arrays.copyOf(a, a.length);\n    int[] a3 = Arrays.copyOf(a, a.length);\n    // Use stopwatch to time selection sort\n    StopWatch timer = new StopWatch();\n    timer.start();\n    ShellSorter.sort(a);\n    timer.stop();\n    System.out.println(\"Elapsed time with Shell sort: \" + timer.getElapsedTime() + \" milliseconds\");\n    timer.reset();\n    timer.start();\n    Arrays.sort(a2);\n    timer.stop();\n    System.out.println(\"Elapsed time with Arrays.sort: \" + timer.getElapsedTime() + \" milliseconds\");\n    if (!Arrays.equals(a, a2)) {\n        throw new IllegalStateException(\"Incorrect sort result\");\n    }\n    timer.reset();\n    timer.start();\n    InsertionSorter.sort(a3);\n    timer.stop();\n    System.out.println(\"Elapsed time with insertion sort: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"ShellSortTimer","variables":{"a":1,"a2":1,"timer":12,"a3":1,"ShellSorter":1,"in":2,"Arrays":4,"n":1,"InsertionSorter":1,"ArrayUtil":1},"constants":{"100":1,"\"Elapsed time with insertion sort: \"":1,"\"Incorrect sort result\"":1,"\" milliseconds\"":3,"\"Elapsed time with Shell sort: \"":1,"\"Enter array size: \"":1,"\"Elapsed time with Arrays.sort: \"":1},"javaDoc":"","comments":"Construct random array Use stopwatch to time selection sort ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"constants":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":6,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"constants":{"true":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":9,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{"false":1},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":8,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"constants":{"0":1,"false":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    ShellSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"ShellSortDemo","variables":{"a":1,"ShellSorter":1,"Arrays":2,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":5,"BinaryExpr":6,"NameExpr":20,"FieldAccessExpr":1,"UnaryExpr":2,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 1; i < a.length; i++) {\n        int next = a[i];\n        // Move all larger elements up\n        int j = i;\n        while (j > 0 && a[j - 1] > next) {\n            a[j] = a[j - 1];\n            j--;\n        }\n        // Insert the element\n        a[j] = next;\n    }\n}\n","name":"sort","className":"InsertionSorter","variables":{"next":3,"a":5,"i":5,"j":7},"constants":{"0":1,"1":3},"javaDoc":"Sorts an array using insertion sort a the array to sort","comments":"Move all larger elements up Insert the element \n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"add":1,"size":1,"insertionSort":1,"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArrayList<Integer>":1,"int":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":4,"BinaryExpr":6,"NameExpr":28,"FieldAccessExpr":1,"UnaryExpr":2,"MethodCallExpr":4,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":3,"ForStmt":2,"ExpressionStmt":6},"text":"/**\n      Sorts an array, using Shell sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    // Generate the sequence values\n    ArrayList<Integer> columns = new ArrayList<Integer>();\n    int c = 1;\n    while (c < a.length) {\n        columns.add(c);\n        c = 3 * c + 1;\n    }\n    // For each column count, sort all columns\n    for (int s = columns.size() - 1; s >= 0; s--) {\n        c = columns.get(s);\n        for (int k = 0; k < c; k++) {\n            insertionSort(a, k, c);\n        }\n    }\n}\n","name":"sort","className":"ShellSorter","variables":{"c":6,"s":3,"columns":4,"k":3},"constants":{"0":2,"1":3,"3":1},"javaDoc":"Sorts an array using Shell sort a the array to sort","comments":"Generate the sequence values For each column count sort all columns \n      Sorts an array, using Shell sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"VariableDeclarationExpr":3,"ArrayAccessExpr":5,"BinaryExpr":9,"NameExpr":29,"FieldAccessExpr":1,"AssignExpr":4},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Sorts a column, using insertion sort.\n      @param a the array to sort\n      @param k the index of the first element in the column\n      @param c the gap between elements in the column\n   */\npublic static void insertionSort(int[] a, int k, int c) {\n    for (int i = k + c; i < a.length; i = i + c) {\n        int next = a[i];\n        // Move all larger elements up\n        int j = i;\n        while (j >= c && a[j - c] > next) {\n            a[j] = a[j - c];\n            j = j - c;\n        }\n        // Insert the element\n        a[j] = next;\n    }\n}\n","name":"insertionSort","className":"ShellSorter","variables":{"next":3,"a":5,"c":6,"i":6,"j":8,"k":1},"constants":{},"javaDoc":"Sorts a column using insertion sort a the array to sort k the index of the first element in the column c the gap between elements in the column","comments":"Move all larger elements up Insert the element \n      Sorts a column, using insertion sort.\n      @param a the array to sort\n      @param k the index of the first element in the column\n      @param c the gap between elements in the column\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    InsertionSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"InsertionSortDemo","variables":{"a":1,"Arrays":2,"InsertionSorter":1,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":5,"BinaryExpr":6,"NameExpr":20,"FieldAccessExpr":1,"UnaryExpr":2,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 1; i < a.length; i++) {\n        int next = a[i];\n        // Move all larger elements up\n        int j = i;\n        while (j > 0 && a[j - 1] > next) {\n            a[j] = a[j - 1];\n            j--;\n        }\n        // Insert the element\n        a[j] = next;\n    }\n}\n","name":"sort","className":"InsertionSorter","variables":{"next":3,"a":5,"i":5,"j":7},"constants":{"0":1,"1":3},"javaDoc":"Sorts an array using insertion sort a the array to sort","comments":"Move all larger elements up Insert the element \n      Sorts an array, using insertion sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    SelectionSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"SelectionSortDemo","variables":{"a":1,"SelectionSorter":1,"Arrays":2,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"swap":1,"minimumPosition":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":15,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/**\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n        int minPos = minimumPosition(a, i);\n        ArrayUtil.swap(a, minPos, i);\n    }\n}\n","name":"sort","className":"SelectionSorter","variables":{"i":3,"minPos":1,"ArrayUtil":1},"constants":{"0":1,"1":1},"javaDoc":"Sorts an array using selection sort a the array to sort","comments":"\n      Sorts an array, using selection sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":14,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   */\nprivate static int minimumPosition(int[] a, int from) {\n    int minPos = from;\n    for (int i = from + 1; i < a.length; i++) {\n        if (a[i] < a[minPos]) {\n            minPos = i;\n        }\n    }\n    return minPos;\n}\n","name":"minimumPosition","className":"SelectionSorter","variables":{"a":2,"minPos":4,"i":5,"from":2},"constants":{"1":1},"javaDoc":"Finds the smallest element in a tail range of the array a the array to sort from the first position in a to compare the position of the smallest element in the range a[from] a[a length - 1]","comments":"\n      Finds the smallest element in a tail range of the array.\n      @param a the array to sort\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from] . . . a[a.length - 1]\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"StopWatch","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   */\npublic StopWatch() {\n    reset();\n}\n","name":"StopWatch","className":"StopWatch","variables":{},"constants":{},"javaDoc":"Constructs a stopwatch that is in the stopped state and has no time accumulated","comments":"\n      Constructs a stopwatch that is in the stopped state\n      and has no time accumulated.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":6,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Starts the stopwatch. Time starts accumulating now.\n   */\npublic void start() {\n    if (isRunning) {\n        return;\n    }\n    isRunning = true;\n    startTime = System.currentTimeMillis();\n}\n","name":"start","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"System":1},"constants":{"true":1},"javaDoc":"Starts the stopwatch Time starts accumulating now","comments":"\n      Starts the stopwatch. Time starts accumulating now.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":9,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   */\npublic void stop() {\n    if (!isRunning) {\n        return;\n    }\n    isRunning = false;\n    long endTime = System.currentTimeMillis();\n    elapsedTime = elapsedTime + endTime - startTime;\n}\n","name":"stop","className":"StopWatch","variables":{"isRunning":2,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{"false":1},"javaDoc":"Stops the stopwatch Time stops accumulating and is is added to the elapsed time","comments":"\n      Stops the stopwatch. Time stops accumulating and is\n      is added to the elapsed time.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":8,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n      Returns the total elapsed time.\n      @return the total elapsed time\n   */\npublic long getElapsedTime() {\n    if (isRunning) {\n        long endTime = System.currentTimeMillis();\n        return elapsedTime + endTime - startTime;\n    } else {\n        return elapsedTime;\n    }\n}\n","name":"getElapsedTime","className":"StopWatch","variables":{"isRunning":1,"startTime":1,"endTime":2,"System":1,"elapsedTime":2},"constants":{},"javaDoc":"Returns the total elapsed time the total elapsed time","comments":"\n      Returns the total elapsed time.\n      @return the total elapsed time\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Stops the watch and resets the elapsed time to 0.\n   */\npublic void reset() {\n    elapsedTime = 0;\n    isRunning = false;\n}\n","name":"reset","className":"StopWatch","variables":{"isRunning":1,"elapsedTime":1},"constants":{"0":1,"false":1},"javaDoc":"Stops the watch and resets the elapsed time to 0","comments":"\n      Stops the watch and resets the elapsed time to 0.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"size":1,"stop":2,"get":2,"start":2,"mostFrequent2":1,"mostFrequent1":1,"reset":1,"shuffle":1,"getElapsedTime":2,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArrayList<Integer>":1,"int[]":1,"int":6,"StopWatch":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":5,"VariableDeclarationExpr":9,"ArrayAccessExpr":2,"BinaryExpr":10,"NameExpr":101,"StringLiteralExpr":6,"FieldAccessExpr":8,"UnaryExpr":4,"ArrayCreationExpr":1,"MethodCallExpr":20,"AssignExpr":3},"statements":{"BlockStmt":4,"ForStmt":4,"ExpressionStmt":21},"text":"public static void main(String[] args) {\n    ArrayList<Integer> values = new ArrayList<Integer>();\n    int k = 300;\n    // Adds one times 1, two times 2, three times 3, ... , k times k\n    for (int i = 1; i <= k; i++) {\n        for (int j = 1; j <= i; j++) {\n            values.add(i);\n        }\n    }\n    // This method shuffles the array list randomly\n    Collections.shuffle(values);\n    StopWatch timer = new StopWatch();\n    int[] a = new int[values.size()];\n    // of the algorithm\n    for (int i = 0; i < a.length; i++) {\n        a[i] = values.get(i);\n    }\n    timer.start();\n    int result = mostFrequent1(a);\n    timer.stop();\n    System.out.println(result);\n    System.out.println(\"Expected: \" + k);\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n    // Copies the same values and runs the second version     \n    for (int i = 0; i < a.length; i++) {\n        a[i] = values.get(i);\n    }\n    timer.reset();\n    timer.start();\n       // Copies the values into an array and runs the first version\n\n    result = mostFrequent2(a);\n    timer.stop();\n    System.out.println(result);\n    System.out.println(\"Expected: \" + k);\n    System.out.println(\"Elapsed time: \" + timer.getElapsedTime() + \" milliseconds\");\n}\n","name":"main","className":"MostFrequent","variables":{"result":2,"timer":8,"a":3,"values":5,"i":12,"j":3,"k":4,"Collections":1},"constants":{"0":2,"1":2,"300":1,"\" milliseconds\"":2,"\"Expected: \"":2,"\"Elapsed time: \"":2},"javaDoc":"","comments":"Copies the values into an array and runs the first version Adds one times 1 two times 2 three times 3 k times k This method shuffles the array list randomly of the algorithm Copies the same values and runs the second version ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{"search":1,"max":1,"count":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":3},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":3,"BinaryExpr":1,"NameExpr":24,"FieldAccessExpr":2,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   */\npublic static int mostFrequent1(int[] a) {\n    int[] counts = new int[a.length];\n    for (// O(n*n)\n    int i = 0; // O(n*n)\n    i < a.length; // O(n*n)\n    i++) {\n        // O(n) in each iteration\n        counts[i] = count(a, a[i]);\n    }\n    // O(n)\n    int highestFrequency = max(counts);\n    // O(n)\n    int highestFrequencyIndex = search(counts, highestFrequency);\n    return a[highestFrequencyIndex];\n}\n","name":"mostFrequent1","className":"MostFrequent","variables":{"a":2,"counts":2,"i":5,"highestFrequencyIndex":2,"highestFrequency":1},"constants":{"0":1},"javaDoc":"Returns the most frequently occurring value in an array a an array the most frequently occurring value in a","comments":"O(n n) O(n n) O(n n) O(n) in each iteration O(n) O(n) \n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{"search":1,"max":1,"sort":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":4},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":5,"ArrayAccessExpr":4,"BinaryExpr":6,"NameExpr":34,"FieldAccessExpr":3,"ArrayCreationExpr":1,"UnaryExpr":2,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   */\npublic static int mostFrequent2(int[] a) {\n    // O(n log(n))\n    Arrays.sort(a);\n    int[] counts = new int[a.length];\n    int count = 0;\n    for (// O(n)\n    int i = 0; // O(n)\n    i < a.length; // O(n)\n    i++) {\n        count++;\n        if (i == a.length - 1 || a[i] != a[i + 1]) {\n            counts[i] = count;\n            count = 0;\n        }\n    }\n    // O(n)\n    int highestFrequency = max(counts);\n    // O(n)\n    int highestFrequencyIndex = search(counts, highestFrequency);\n    return a[highestFrequencyIndex];\n}\n","name":"mostFrequent2","className":"MostFrequent","variables":{"a":3,"counts":2,"count":4,"i":7,"highestFrequencyIndex":2,"Arrays":1,"highestFrequency":1},"constants":{"0":3,"1":2},"javaDoc":"Returns the most frequently occurring value in an array a an array the most frequently occurring value in a","comments":"O(n log(n)) O(n) O(n) O(n) O(n) O(n) \n      Returns the most frequently occurring value in an array.\n      @param a an array\n      @return the most frequently occurring value in a\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":10,"FieldAccessExpr":1,"UnaryExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Counts how often a value occurs in an array.\n      @param a the array\n      @param value the value to count\n      @return the number of occurrences of value in a\n   */\npublic static int count(int[] a, int value) {\n    int count = 0;\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] == value) {\n            count++;\n        }\n    }\n    return count;\n}\n","name":"count","className":"MostFrequent","variables":{"a":1,"count":3,"i":4,"value":1},"constants":{"0":2},"javaDoc":"Counts how often a value occurs in an array a the array value the value to count the number of occurrences of value in a","comments":"\n      Counts how often a value occurs in an array.\n      @param a the array\n      @param value the value to count\n      @return the number of occurrences of value in a\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":2,"NameExpr":13,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Computes the largest value of an array.\n      @param a the array\n      @return the largest value in a\n   */\npublic static int max(int[] values) {\n    int largest = values[0];\n    for (int i = 1; i < values.length; i++) {\n        if (values[i] > largest) {\n            largest = values[i];\n        }\n    }\n    return largest;\n}\n","name":"max","className":"MostFrequent","variables":{"largest":4,"values":3,"i":5},"constants":{"0":1,"1":1},"javaDoc":"Computes the largest value of an array a the array the largest value in a","comments":"\n      Computes the largest value of an array.\n      @param a the array\n      @return the largest value in a\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":9,"FieldAccessExpr":1,"UnaryExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2},"text":"/**\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   */\npublic static int search(int[] a, int value) {\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] == value) {\n            return i;\n        }\n    }\n    return -1;\n}\n","name":"search","className":"MostFrequent","variables":{"a":1,"i":5,"value":1},"constants":{"0":1,"1":1},"javaDoc":"Finds a value in an array using the linear search algorithm a the array to search value the value to find the index at which the value occurs or -1 if it does not occur in the array","comments":"\n      Finds a value in an array, using the linear search \n      algorithm.\n      @param a the array to search\n      @param value the value to find\n      @return the index at which the value occurs, or -1\n      if it does not occur in the array\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","double"],"returnType":"Country","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   */\npublic Country(String aName, double anArea) {\n    name = aName;\n    area = anArea;\n}\n","name":"Country","className":"Country","variables":{"area":1,"aName":1,"name":1,"anArea":1},"constants":{},"javaDoc":"Constructs a country aName the name of the country anArea the area of the country","comments":"\n      Constructs a country.\n      @param aName the name of the country\n      @param anArea the area of the country\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the country name.\n      @return the name\n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Country","variables":{"name":1},"constants":{},"javaDoc":"Gets the country name the name","comments":"\n      Gets the country name.\n      @return the name\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the area of the country.\n      @return the area\n   */\npublic double getArea() {\n    return area;\n}\n","name":"getArea","className":"Country","variables":{"area":1},"constants":{},"javaDoc":"Gets the area of the country the area","comments":"\n      Gets the area of the country.\n      @return the area\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Country":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":9,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3,"ExpressionStmt":1},"text":"public int compareTo(Object otherObject) {\n    Country other = (Country) otherObject;\n    if (area < other.area) {\n        return -1;\n    } else if (area == other.area) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n","name":"compareTo","className":"Country","variables":{"area":2,"other":1,"otherObject":1},"constants":{"0":1,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"NameExpr":6,"StringLiteralExpr":3,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return getClass().getName() + \"[name=\" + name + \",area=\" + area + \"]\";\n}\n","name":"toString","className":"Country","variables":{"area":1,"name":1},"constants":{"\"[name=\"":1,"\"]\"":1,"\",area=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"toString":1,"sort":2,"binarySearch":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArrayList<Country>":1,"Country":3,"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":21,"ObjectCreationExpr":4,"VariableDeclarationExpr":6,"ArrayInitializerExpr":1,"BinaryExpr":3,"NameExpr":56,"StringLiteralExpr":5,"FieldAccessExpr":4,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":12,"AssignExpr":1},"statements":{"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    int[] values = { 1, 4, 9, 1, 6, 2, 5, 3, 6, 4, 9, 6, 4, 8, 1 };\n    Arrays.sort(values);\n    System.out.println(Arrays.toString(values));\n    int pos = Arrays.binarySearch(values, 4);\n    System.out.println(\"Position of 4: \" + pos);\n    pos = Arrays.binarySearch(values, 7);\n    System.out.println(\"Position for inserting 7: \" + (-pos - 1));\n    Country country1 = new Country(\"Belgium\", 30510);\n    Country country2 = new Country(\"Thailand\", 514000);\n    Country country3 = new Country(\"Uruguay\", 176220);\n    ArrayList<Country> countries = new ArrayList<Country>();\n    countries.add(country1);\n    countries.add(country2);\n    countries.add(country3);\n    Collections.sort(countries);\n    System.out.println(countries);\n}\n","name":"main","className":"JavaLibraryDemo","variables":{"pos":4,"values":1,"country1":1,"countries":4,"Arrays":4,"Collections":1,"country3":1,"country2":1},"constants":{"\"Thailand\"":1,"\"Belgium\"":1,"514000":1,"\"Position of 4: \"":1,"\"Uruguay\"":1,"1":4,"2":1,"\"Position for inserting 7: \"":1,"30510":1,"3":1,"4":4,"5":1,"6":3,"7":1,"8":1,"9":2,"176220":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"merge":1,"sort":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int[]":2,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"ArrayAccessExpr":4,"BinaryExpr":6,"NameExpr":44,"FieldAccessExpr":7,"ArrayCreationExpr":2,"UnaryExpr":2,"AssignExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":3,"ReturnStmt":1,"ForStmt":2,"ExpressionStmt":7},"text":"/**\n      Sorts an array, using merge sort.\n      @param a the array to sort\n   */\npublic static void sort(int[] a) {\n    if (a.length <= 1) {\n        return;\n    }\n    int[] first = new int[a.length / 2];\n    int[] second = new int[a.length - first.length];\n    // Copy the first half of a into first, the second half into second\n    for (int i = 0; i < first.length; i++) {\n        first[i] = a[i];\n    }\n    for (int i = 0; i < second.length; i++) {\n        second[i] = a[first.length + i];\n    }\n    sort(first);\n    sort(second);\n    merge(first, second, a);\n}\n","name":"sort","className":"MergeSorter","variables":{"a":2,"i":10,"first":2,"second":2},"constants":{"0":2,"1":1,"2":1},"javaDoc":"Sorts an array using merge sort a the array to sort","comments":"Copy the first half of a into first the second half into second \n      Sorts an array, using merge sort.\n      @param a the array to sort\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int[]","int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":10,"BinaryExpr":6,"NameExpr":43,"FieldAccessExpr":4,"UnaryExpr":7,"AssignExpr":4},"statements":{"IfStmt":1,"WhileStmt":3,"BlockStmt":5,"ExpressionStmt":14},"text":"/**\n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   */\nprivate static void merge(int[] first, int[] second, int[] a) {\n    // Next element to consider in the first array\n    int iFirst = 0;\n    // Next element to consider in the second array\n    int iSecond = 0;\n    // Next open position in a\n    int j = 0;\n    // the smaller element into a\n    while (iFirst < first.length && iSecond < second.length) {\n        if (first[iFirst] < second[iSecond]) {\n            a[j] = first[iFirst];\n            iFirst++;\n        } else {\n            a[j] = second[iSecond];\n            iSecond++;\n        }\n        j++;\n    }\n    // Copy any remaining entries of the first array\n    while (iFirst < first.length) {\n        a[j] = first[iFirst];\n        iFirst++;\n        j++;\n    }\n    // Copy any remaining entries of the second half\n    while (iSecond < second.length) {\n        a[j] = second[iSecond];\n        iSecond++;\n        j++;\n    }\n}\n       // As long as neither iFirst nor iSecond is past the end, move\n\n       // Note that only one of the two loops below copies entries\n\n","name":"merge","className":"MergeSorter","variables":{"a":4,"iSecond":8,"j":8,"first":3,"iFirst":8,"second":3},"constants":{"0":3},"javaDoc":"Merges two sorted arrays into an array first the first sorted array second the second sorted array a the array into which to merge first and second","comments":"As long as neither iFirst nor iSecond is past the end move Note that only one of the two loops below copies entries Next element to consider in the first array Next element to consider in the second array Next open position in a the smaller element into a Copy any remaining entries of the first array Copy any remaining entries of the second half \n      Merges two sorted arrays into an array\n      @param first the first sorted array\n      @param second the second sorted array\n      @param a the array into which to merge first and second\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomIntArray":1,"toString":2,"sort":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":25,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int[] a = ArrayUtil.randomIntArray(20, 100);\n    System.out.println(Arrays.toString(a));\n    MergeSorter.sort(a);\n    System.out.println(Arrays.toString(a));\n}\n","name":"main","className":"MergeSortDemo","variables":{"a":1,"Arrays":2,"MergeSorter":1,"ArrayUtil":1},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createStatement":1,"init":1,"getConnection":1,"nextLine":1,"hasNextLine":1,"getResultSet":1,"showResultSet":1,"execute":1,"System.out.println":2},"annotations":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"boolean":1,"Statement":1,"Connection":1,"ResultSet":1,"String":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":3,"VariableDeclarationExpr":6,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":53,"StringLiteralExpr":2,"FieldAccessExpr":6,"MethodCallExpr":10,"AssignExpr":2},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":9,"TryStmt":3,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) throws SQLException, IOException, ClassNotFoundException {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". ExecSQL propertiesFile [SQLcommandFile]\");\n        return;\n    }\n    SimpleDataSource.init(args[0]);\n    Scanner in;\n    if (args.length > 1) {\n        in = new Scanner(new File(args[1]));\n    } else {\n        in = new Scanner(System.in);\n    }\n    try (Connection conn = SimpleDataSource.getConnection();\n        Statement stat = conn.createStatement()) {\n        while (in.hasNextLine()) {\n            String line = in.nextLine();\n            try {\n                boolean hasResultSet = stat.execute(line);\n                if (hasResultSet) {\n                    try (ResultSet result = stat.getResultSet()) {\n                        showResultSet(result);\n                    }\n                }\n            } catch (SQLException ex) {\n                System.out.println(ex);\n            }\n        }\n    }\n}\n","name":"main","className":"ExecSQL","variables":{"args":2,"result":1,"conn":2,"stat":3,"ex":1,"in":5,"hasResultSet":2,"SimpleDataSource":2,"line":1},"constants":{"0":2,"\"Usage: java -classpath driver_class_path\"":1,"1":2,"\". ExecSQL propertiesFile [SQLcommandFile]\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ResultSet"],"returnType":"void","methodCalls":{"next":1,"getColumnLabel":1,"getColumnCount":1,"getString":1,"getMetaData":1,"System.out.print":4,"System.out.println":2},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"ResultSetMetaData":1,"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":55,"StringLiteralExpr":2,"FieldAccessExpr":6,"UnaryExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ForStmt":2,"ExpressionStmt":8},"text":"/**\n      Prints a result set.\n      @param result the result set\n   */\npublic static void showResultSet(ResultSet result) throws SQLException {\n    ResultSetMetaData metaData = result.getMetaData();\n    int columnCount = metaData.getColumnCount();\n    for (int i = 1; i <= columnCount; i++) {\n        if (i > 1) {\n            System.out.print(\", \");\n        }\n        System.out.print(metaData.getColumnLabel(i));\n    }\n    System.out.println();\n    while (result.next()) {\n        for (int i = 1; i <= columnCount; i++) {\n            if (i > 1) {\n                System.out.print(\", \");\n            }\n            System.out.print(result.getString(i));\n        }\n        System.out.println();\n    }\n}\n","name":"showResultSet","className":"ExecSQL","variables":{"result":3,"metaData":3,"i":8,"columnCount":3},"constants":{"1":4,"\", \"":2},"javaDoc":"Prints a result set result the result set","comments":"\n      Prints a result set.\n      @param result the result set\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":6,"MethodCallExpr":6,"AssignExpr":5},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":10},"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":1,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"constants":{},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"init":1,"getConnection":1,"printStackTrace":3,"System.out.println":4,"addInvoice":1},"annotations":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"Connection":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":49,"StringLiteralExpr":5,"FieldAccessExpr":7,"MethodCallExpr":10},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String args[]) {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". InvoiceEntry propertiesFile\");\n        return;\n    }\n    try {\n        SimpleDataSource.init(args[0]);\n        try (Connection conn = SimpleDataSource.getConnection();\n            Scanner in = new Scanner(System.in)) {\n            addInvoice(in, conn);\n        }\n    } catch (SQLException ex) {\n        System.out.println(\"Database error\");\n        ex.printStackTrace();\n    } catch (ClassNotFoundException ex) {\n        System.out.println(\"Error loading database driver\");\n        ex.printStackTrace();\n    } catch (IOException ex) {\n        System.out.println(\"Error loading database properties\");\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"InvoiceEntry","variables":{"args":1,"conn":1,"ex":6,"in":1,"SimpleDataSource":2},"constants":{"0":2,"\"Usage: java -classpath driver_class_path\"":1,"\". InvoiceEntry propertiesFile\"":1,"\"Error loading database driver\"":1,"\"Database error\"":1,"\"Error loading database properties\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Scanner","Connection"],"returnType":"void","methodCalls":{"nextLine":1,"listProducts":1,"showInvoice":1,"addLineItem":1,"prepareStatement":1,"nextInt":1,"setInt":2,"findProduct":1,"newCustomer":1,"equals":2,"getNewId":1,"executeUpdate":1,"System.out.println":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"boolean":1,"PreparedStatement":1,"String":1,"int":3},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":6,"BooleanLiteralExpr":2,"NameExpr":57,"StringLiteralExpr":7,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":15,"AssignExpr":1},"statements":{"IfStmt":3,"WhileStmt":1,"TryStmt":1,"BlockStmt":6,"ExpressionStmt":13},"text":"public static void addInvoice(Scanner in, Connection conn) throws SQLException {\n    int customerNumber = newCustomer(conn, in);\n    int id = getNewId(conn, \"Invoice\");\n    try (PreparedStatement stat = conn.prepareStatement(\"INSERT INTO Invoice VALUES (?, ?, 0)\")) {\n        stat.setInt(1, id);\n        stat.setInt(2, customerNumber);\n        stat.executeUpdate();\n    }\n    boolean done = false;\n    while (!done) {\n        String productCode = nextLine(in, \"Product code (D=Done, L=List)\");\n        if (productCode.equals(\"D\")) {\n            done = true;\n        } else if (productCode.equals(\"L\")) {\n            listProducts(conn);\n        } else if (findProduct(conn, productCode)) {\n            int quantity = nextInt(in, \"Quantity\");\n            addLineItem(conn, id, productCode, quantity);\n        } else {\n            System.out.println(\"Invalid product code.\");\n        }\n    }\n    showInvoice(conn, id);\n}\n","name":"addInvoice","className":"InvoiceEntry","variables":{"stat":4,"conn":1,"productCode":3,"quantity":1,"id":1,"customerNumber":1,"done":3},"constants":{"\"D\"":1,"1":1,"2":1,"\"Quantity\"":1,"\"Invoice\"":1,"\"Product code (D=Done, L=List)\"":1,"\"Invalid product code.\"":1,"false":1,"true":1,"\"L\"":1,"\"INSERT INTO Invoice VALUES (?, ?, 0)\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Connection","Scanner"],"returnType":"int","methodCalls":{"setString":5,"nextLine":5,"prepareStatement":1,"getNewId":1,"setInt":1,"executeUpdate":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"PreparedStatement":1,"String":5,"int":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":7,"NameExpr":49,"StringLiteralExpr":7,"MethodCallExpr":14},"statements":{"TryStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":13},"text":"/**\n      Prompts the user for the customer information and creates a new customer.\n      @param conn the database connection\n      @param in the scanner\n      @return the ID of the new customer\n   */\nprivate static int newCustomer(Connection conn, Scanner in) throws SQLException {\n    String name = nextLine(in, \"Name\");\n    String address = nextLine(in, \"Street address\");\n    String city = nextLine(in, \"City\");\n    String state = nextLine(in, \"State\");\n    String zip = nextLine(in, \"Zip\");\n    int id = getNewId(conn, \"Customer\");\n    try (PreparedStatement stat = conn.prepareStatement(\"INSERT INTO Customer VALUES (?, ?, ?, ?, ?, ?)\")) {\n        stat.setInt(1, id);\n        stat.setString(2, name);\n        stat.setString(3, address);\n        stat.setString(4, city);\n        stat.setString(5, state);\n        stat.setString(6, zip);\n        stat.executeUpdate();\n    }\n    return id;\n}\n","name":"newCustomer","className":"InvoiceEntry","variables":{"zip":1,"stat":8,"conn":1,"address":1,"city":1,"name":1,"state":1,"id":2},"constants":{"\"Customer\"":1,"\"INSERT INTO Customer VALUES (?, ?, ?, ?, ?, ?)\"":1,"\"Name\"":1,"\"Zip\"":1,"1":1,"2":1,"\"City\"":1,"3":1,"4":1,"\"Street address\"":1,"\"State\"":1,"5":1,"6":1},"javaDoc":"Prompts the user for the customer information and creates a new customer conn the database connection in the scanner the ID of the new customer","comments":"\n      Prompts the user for the customer information and creates a new customer.\n      @param conn the database connection\n      @param in the scanner\n      @return the ID of the new customer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Connection","String"],"returnType":"boolean","methodCalls":{"next":1,"setString":1,"prepareStatement":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"boolean":1,"ResultSet":1,"PreparedStatement":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"NameExpr":15,"StringLiteralExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Finds a product in the database.\n      @param conn the database connection\n      @param code the product code to search\n      @return true if there is a product with the given code\n   */\nprivate static boolean findProduct(Connection conn, String code) throws SQLException {\n    boolean found = false;\n    try (PreparedStatement stat = conn.prepareStatement(\"SELECT * FROM Product WHERE Product_Code = ?\")) {\n        stat.setString(1, code);\n        ResultSet result = stat.executeQuery();\n        found = result.next();\n    }\n    return found;\n}\n","name":"findProduct","className":"InvoiceEntry","variables":{"result":2,"stat":3,"conn":1,"found":3},"constants":{"1":1,"\"SELECT * FROM Product WHERE Product_Code = ?\"":1,"false":1},"javaDoc":"Finds a product in the database conn the database connection code the product code to search true if there is a product with the given code","comments":"\n      Finds a product in the database.\n      @param conn the database connection\n      @param code the product code to search\n      @return true if there is a product with the given code\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Connection","int","String","int"],"returnType":"void","methodCalls":{"setString":1,"prepareStatement":1,"setInt":2,"executeUpdate":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"PreparedStatement":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"NameExpr":18,"StringLiteralExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n      Adds a line item to the database\n      @param conn the database connection\n      @param id the invoice ID\n      @param code the product code\n      @param quantity the quantity to order\n   */\nprivate static void addLineItem(Connection conn, int id, String code, int quantity) throws SQLException {\n    try (PreparedStatement stat = conn.prepareStatement(\"INSERT INTO LineItem VALUES (?, ?, ?)\")) {\n        stat.setInt(1, id);\n        stat.setString(2, code);\n        stat.setInt(3, quantity);\n        stat.executeUpdate();\n    }\n}\n","name":"addLineItem","className":"InvoiceEntry","variables":{"stat":5,"conn":1},"constants":{"\"INSERT INTO LineItem VALUES (?, ?, ?)\"":1,"1":1,"2":1,"3":1},"javaDoc":"Adds a line item to the database conn the database connection id the invoice ID code the product code quantity the quantity to order","comments":"\n      Adds a line item to the database\n      @param conn the database connection\n      @param id the invoice ID\n      @param code the product code\n      @param quantity the quantity to order\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Connection"],"returnType":"void","methodCalls":{"createStatement":1,"next":1,"getString":2,"executeQuery":1,"System.out.println":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"Statement":1,"ResultSet":1,"String":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/**\n      Lists all products in the database.\n      @param conn the database connection\n   */\nprivate static void listProducts(Connection conn) throws SQLException {\n    try (Statement stat = conn.createStatement()) {\n        ResultSet result = stat.executeQuery(\"SELECT Product_Code, Description FROM Product\");\n        while (result.next()) {\n            String code = result.getString(1);\n            String description = result.getString(2);\n            System.out.println(code + \" \" + description);\n        }\n    }\n}\n","name":"listProducts","className":"InvoiceEntry","variables":{"result":4,"stat":2,"conn":1,"code":2,"description":2},"constants":{"1":1,"2":1,"\" \"":1,"\"SELECT Product_Code, Description FROM Product\"":1},"javaDoc":"Lists all products in the database conn the database connection","comments":"\n      Lists all products in the database.\n      @param conn the database connection\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Connection","String"],"returnType":"int","methodCalls":{"createStatement":1,"next":1,"getInt":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"Statement":1,"ResultSet":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":16,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Gets a new ID for a table. This method should be called from\n      inside a transaction that also creates the new row with this ID.\n      The ID field should have name table_Number and type INTEGER.\n      @param table the table name\n      @return a new ID that has not yet been used.\n   */\nprivate static int getNewId(Connection conn, String table) throws SQLException {\n    int max = -1;\n    try (Statement stat = conn.createStatement()) {\n        ResultSet result = stat.executeQuery(\"SELECT max(\" + table + \"_Number) FROM \" + table);\n        result.next();\n        max = result.getInt(1) + 1;\n    }\n    return max;\n}\n","name":"getNewId","className":"InvoiceEntry","variables":{"result":3,"stat":2,"conn":1,"max":3,"table":2},"constants":{"1":3,"\"SELECT max(\"":1,"\"_Number) FROM \"":1},"javaDoc":"Gets a new ID for a table This method should be called from inside a transaction that also creates the new row with this ID The ID field should have name table_Number and type INTEGER table the table name a new ID that has not yet been used","comments":"\n      Gets a new ID for a table. This method should be called from\n      inside a transaction that also creates the new row with this ID.\n      The ID field should have name table_Number and type INTEGER.\n      @param table the table name\n      @return a new ID that has not yet been used.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Connection","int"],"returnType":"void","methodCalls":{"next":2,"getInt":1,"trim":2,"prepareStatement":2,"getString":7,"setInt":2,"executeQuery":2,"System.out.println":4},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"ResultSet":2,"PreparedStatement":2,"String":2,"int":1},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":7,"BinaryExpr":15,"NameExpr":77,"StringLiteralExpr":13,"FieldAccessExpr":4,"MethodCallExpr":22},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":3,"ExpressionStmt":12},"text":"/**\n      Shows an invoice.\n      @param conn the database connection\n      @param id the invoice ID\n   */\nprivate static void showInvoice(Connection conn, int id) throws SQLException {\n    try (PreparedStatement stat = conn.prepareStatement(\"SELECT Customer.Name, Customer.Address, \" + \"Customer.City, Customer.State, Customer.Zip \" + \"FROM Customer, Invoice \" + \"WHERE Customer.Customer_Number = Invoice.Customer_Number \" + \"AND Invoice.Invoice_Number = ?\")) {\n        stat.setInt(1, id);\n        ResultSet result = stat.executeQuery();\n        result.next();\n        System.out.println(result.getString(1));\n        System.out.println(result.getString(2));\n        System.out.println(result.getString(3).trim() + \", \" + result.getString(4) + \" \" + result.getString(5));\n    }\n    try (PreparedStatement stat = conn.prepareStatement(\"SELECT Product.Product_Code, Product.Description, LineItem.Quantity \" + \"FROM Product, LineItem \" + \"WHERE Product.Product_Code = LineItem.Product_Code \" + \"AND LineItem.Invoice_Number = ?\")) {\n        stat.setInt(1, id);\n        ResultSet result = stat.executeQuery();\n        while (result.next()) {\n            String code = result.getString(1);\n            String description = result.getString(2).trim();\n            int qty = result.getInt(3);\n            System.out.println(qty + \" x \" + code + \" \" + description);\n        }\n    }\n}\n","name":"showInvoice","className":"InvoiceEntry","variables":{"result":12,"stat":6,"conn":2,"code":2,"qty":2,"description":2},"constants":{"\" \"":2,"\"WHERE Product.Product_Code = LineItem.Product_Code \"":1,"\"FROM Customer, Invoice \"":1,"\"FROM Product, LineItem \"":1,"1":4,"2":2,"3":2,"\" x \"":1,"\"SELECT Customer.Name, Customer.Address, \"":1,"4":1,"\"AND Invoice.Invoice_Number = ?\"":1,"5":1,"\"SELECT Product.Product_Code, Product.Description, LineItem.Quantity \"":1,"\"WHERE Customer.Customer_Number = Invoice.Customer_Number \"":1,"\"AND LineItem.Invoice_Number = ?\"":1,"\"Customer.City, Customer.State, Customer.Zip \"":1,"\", \"":1},"javaDoc":"Shows an invoice conn the database connection id the invoice ID","comments":"\n      Shows an invoice.\n      @param conn the database connection\n      @param id the invoice ID\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Scanner","String"],"returnType":"String","methodCalls":{"nextLine":1,"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Prompts the user and reads a line from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the string that the user entered\n   */\nprivate static String nextLine(Scanner in, String prompt) {\n    System.out.print(prompt + \": \");\n    return in.nextLine();\n}\n","name":"nextLine","className":"InvoiceEntry","variables":{"in":1,"prompt":1},"constants":{"\": \"":1},"javaDoc":"Prompts the user and reads a line from a scanner in the scanner prompt the prompt the string that the user entered","comments":"\n      Prompts the user and reads a line from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the string that the user entered\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Scanner","String"],"returnType":"int","methodCalls":{"nextLine":1,"nextInt":1,"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Prompts the user and reads an integer from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the integer that the user entered\n   */\nprivate static int nextInt(Scanner in, String prompt) {\n    System.out.print(prompt + \": \");\n    int result = in.nextInt();\n    // Consume newline\n    in.nextLine();\n    return result;\n}\n","name":"nextInt","className":"InvoiceEntry","variables":{"result":2,"in":2,"prompt":1},"constants":{"\": \"":1},"javaDoc":"Prompts the user and reads an integer from a scanner in the scanner prompt the prompt the integer that the user entered","comments":"Consume newline \n      Prompts the user and reads an integer from a scanner.\n      @param in the scanner\n      @param prompt the prompt\n      @return the integer that the user entered\n   ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":6,"MethodCallExpr":6,"AssignExpr":5},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":10},"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":1,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"constants":{},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createStatement":1,"next":1,"init":1,"getConnection":1,"getString":1,"execute":3,"System.out.println":2,"executeQuery":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Statement":1,"Connection":1,"ResultSet":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":44,"StringLiteralExpr":7,"FieldAccessExpr":4,"MethodCallExpr":11},"statements":{"IfStmt":1,"BlockStmt":2,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) throws Exception {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". TestDB propertiesFile\");\n        return;\n    }\n    SimpleDataSource.init(args[0]);\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        Statement stat = conn.createStatement();\n        stat.execute(\"CREATE TABLE Test (Name VARCHAR(20))\");\n        stat.execute(\"INSERT INTO Test VALUES ('Romeo')\");\n        ResultSet result = stat.executeQuery(\"SELECT * FROM Test\");\n        result.next();\n        System.out.println(result.getString(\"Name\"));\n        stat.execute(\"DROP TABLE Test\");\n    }\n}\n","name":"main","className":"TestDB","variables":{"args":1,"result":3,"conn":2,"stat":5,"SimpleDataSource":2},"constants":{"0":2,"\"Usage: java -classpath driver_class_path\"":1,"\"SELECT * FROM Test\"":1,"\". TestDB propertiesFile\"":1,"\"INSERT INTO Test VALUES ('Romeo')\"":1,"\"Name\"":1,"\"CREATE TABLE Test (Name VARCHAR(20))\"":1,"\"DROP TABLE Test\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number\n   */\npublic BankAccount(int anAccountNumber) {\n    accountNumber = anAccountNumber;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"anAccountNumber":1,"accountNumber":1},"constants":{},"javaDoc":"Constructs a bank account with a given balance anAccountNumber the account number","comments":"\n      Constructs a bank account with a given balance.\n      @param anAccountNumber the account number\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"setDouble":1,"getConnection":1,"prepareStatement":1,"setInt":1,"executeUpdate":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"Connection":1,"PreparedStatement":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":3,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n      Deposits money into a bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        PreparedStatement stat = conn.prepareStatement(\"UPDATE Account\" + \" SET Balance = Balance + ?\" + \" WHERE Account_Number = ?\");\n        stat.setDouble(1, amount);\n        stat.setInt(2, accountNumber);\n        stat.executeUpdate();\n    }\n}\n","name":"deposit","className":"BankAccount","variables":{"conn":2,"stat":4,"SimpleDataSource":1},"constants":{"1":1,"2":1,"\" WHERE Account_Number = ?\"":1,"\"UPDATE Account\"":1,"\" SET Balance = Balance + ?\"":1},"javaDoc":"Deposits money into a bank account amount the amount to deposit","comments":"\n      Deposits money into a bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"setDouble":1,"getConnection":1,"prepareStatement":1,"setInt":1,"executeUpdate":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"Connection":1,"PreparedStatement":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":3,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n      Withdraws money from a bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        PreparedStatement stat = conn.prepareStatement(\"UPDATE Account\" + \" SET Balance = Balance - ?\" + \" WHERE Account_Number = ?\");\n        stat.setDouble(1, amount);\n        stat.setInt(2, accountNumber);\n        stat.executeUpdate();\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"conn":2,"stat":4,"SimpleDataSource":1},"constants":{"1":1,"2":1,"\" WHERE Account_Number = ?\"":1,"\"UPDATE Account\"":1,"\" SET Balance = Balance - ?\"":1},"javaDoc":"Withdraws money from a bank account amount the amount to withdraw","comments":"\n      Withdraws money from a bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"next":1,"getConnection":1,"getDouble":1,"prepareStatement":1,"setInt":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"double":1,"Connection":1,"ResultSet":1,"PreparedStatement":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"NameExpr":21,"StringLiteralExpr":1,"MethodCallExpr":6,"AssignExpr":1},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Gets the balance of a bank account.\n      @return the account balance\n   */\npublic double getBalance() throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        double balance = 0;\n        PreparedStatement stat = conn.prepareStatement(\"SELECT Balance FROM Account WHERE Account_Number = ?\");\n        stat.setInt(1, accountNumber);\n        ResultSet result = stat.executeQuery();\n        if (result.next()) {\n            balance = result.getDouble(1);\n        }\n        return balance;\n    }\n}\n","name":"getBalance","className":"BankAccount","variables":{"result":3,"conn":2,"stat":3,"balance":3,"SimpleDataSource":1},"constants":{"0":1,"1":2,"\"SELECT Balance FROM Account WHERE Account_Number = ?\"":1},"javaDoc":"Gets the balance of a bank account the account balance","comments":"\n      Gets the balance of a bank account.\n      @return the account balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"init":1,"showMessageDialog":3,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"Bank":1,"JFrame":1,"ATM":1,"ATMFrame":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":3,"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":31,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":5,"TryStmt":1,"ReturnStmt":3,"ExpressionStmt":11},"text":"public static void main(String[] args) throws IOException, ClassNotFoundException {\n    if (args.length == 0) {\n        JOptionPane.showMessageDialog(null, \"Usage: ATMViewer propertiesFile\");\n        return;\n    } else {\n        try {\n            SimpleDataSource.init(args[0]);\n        } catch (IOException exception) {\n            JOptionPane.showMessageDialog(null, \"Can't connect to database\");\n            return;\n        } catch (ClassNotFoundException exception) {\n            JOptionPane.showMessageDialog(null, \"Can't connect to database\");\n            return;\n        }\n    }\n    ATM theATM;\n    Bank theBank = new Bank();\n    theATM = new ATM(theBank);\n    JFrame frame = new ATMFrame(theATM);\n    frame.setTitle(\"First National Bank of Java\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}\n","name":"main","className":"ATMViewer","variables":{"args":1,"exception":2,"theATM":3,"theBank":2,"SimpleDataSource":1,"JOptionPane":3,"frame":4},"constants":{"0":2,"\"Can't connect to database\"":2,"null":3,"\"Usage: ATMViewer propertiesFile\"":1,"true":1,"\"First National Bank of Java\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":2,"init":1,"selectAccount":2,"back":3,"nextInt":2,"nextDouble":2,"setCustomerNumber":1,"getState":1,"getBalance":1,"reset":1,"deposit":1,"equalsIgnoreCase":6,"System.out.print":6,"selectCustomer":1,"System.out.println":4,"withdraw":1},"annotations":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"concepts":[],"types":{"Scanner":1,"Bank":1,"double":2,"ATM":1,"String":2,"int":3},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":10,"ArrayAccessExpr":1,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":159,"StringLiteralExpr":16,"FieldAccessExpr":18,"MethodCallExpr":35},"statements":{"IfStmt":11,"WhileStmt":1,"BlockStmt":15,"ReturnStmt":1,"ExpressionStmt":31},"text":"public static void main(String[] args) throws IOException, SQLException, ClassNotFoundException {\n    if (args.length == 0) {\n        System.out.println(\"Usage: ATMTester propertiesFile\");\n        return;\n    } else {\n        SimpleDataSource.init(args[0]);\n    }\n    Bank theBank = new Bank();\n    ATM theATM = new ATM(theBank);\n    Scanner in = new Scanner(System.in);\n    while (true) {\n        int state = theATM.getState();\n        if (state == ATM.START) {\n            System.out.print(\"Enter account number: \");\n            int number = in.nextInt();\n            theATM.setCustomerNumber(number);\n        } else if (state == ATM.PIN) {\n            System.out.print(\"Enter PIN: \");\n            int pin = in.nextInt();\n            theATM.selectCustomer(pin);\n        } else if (state == ATM.ACCOUNT) {\n            System.out.print(\"A=Checking, B=Savings, C=Quit: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                theATM.selectAccount(ATM.CHECKING);\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                theATM.selectAccount(ATM.SAVINGS);\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.reset();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        } else if (state == ATM.TRANSACT) {\n            System.out.println(\"Balance=\" + theATM.getBalance());\n            System.out.print(\"A=Deposit, B=Withdrawal, C=Cancel: \");\n            String command = in.next();\n            if (command.equalsIgnoreCase(\"A\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.deposit(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"B\")) {\n                System.out.print(\"Amount: \");\n                double amount = in.nextDouble();\n                theATM.withdraw(amount);\n                theATM.back();\n            } else if (command.equalsIgnoreCase(\"C\")) {\n                theATM.back();\n            } else {\n                System.out.println(\"Illegal input!\");\n            }\n        }\n    }\n}\n","name":"main","className":"ATMSimulator","variables":{"args":1,"number":1,"amount":2,"theATM":13,"theBank":2,"pin":1,"in":7,"SimpleDataSource":1,"state":5,"command":8},"constants":{"\"Usage: ATMTester propertiesFile\"":1,"\"Enter account number: \"":1,"\"Illegal input!\"":2,"\"C\"":2,"\"B\"":2,"\"A\"":2,"\"A=Checking, B=Savings, C=Quit: \"":1,"\"Balance=\"":1,"0":2,"\"A=Deposit, B=Withdrawal, C=Cancel: \"":1,"true":1,"\"Amount: \"":2,"\"Enter PIN: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int","int"],"returnType":"Customer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a customer with a given number and PIN.\n      @param aCustomerNumber the customer number\n      @param checkingAccountNumber the checking account number\n      @param savingsAccountNumber the savings account number\n   */\npublic Customer(int aCustomerNumber, int checkingAccountNumber, int savingsAccountNumber) {\n    customerNumber = aCustomerNumber;\n    checkingAccount = new BankAccount(checkingAccountNumber);\n    savingsAccount = new BankAccount(savingsAccountNumber);\n}\n","name":"Customer","className":"Customer","variables":{"savingsAccountNumber":1,"savingsAccount":1,"checkingAccountNumber":1,"checkingAccount":1,"customerNumber":1,"aCustomerNumber":1},"constants":{},"javaDoc":"Constructs a customer with a given number and PIN aCustomerNumber the customer number checkingAccountNumber the checking account number savingsAccountNumber the savings account number","comments":"\n      Constructs a customer with a given number and PIN.\n      @param aCustomerNumber the customer number\n      @param checkingAccountNumber the checking account number\n      @param savingsAccountNumber the savings account number\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the checking account of this customer.\n      @return the checking account\n   */\npublic BankAccount getCheckingAccount() {\n    return checkingAccount;\n}\n","name":"getCheckingAccount","className":"Customer","variables":{"checkingAccount":1},"constants":{},"javaDoc":"Gets the checking account of this customer the checking account","comments":" \n      Gets the checking account of this customer.\n      @return the checking account\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the savings account of this customer.\n      @return the savings account\n   */\npublic BankAccount getSavingsAccount() {\n    return savingsAccount;\n}\n","name":"getSavingsAccount","className":"Customer","variables":{"savingsAccount":1},"constants":{},"javaDoc":"Gets the savings account of this customer the savings account","comments":" \n      Gets the savings account of this customer.\n      @return the savings account\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Customer","methodCalls":{"next":1,"getConnection":1,"getInt":3,"prepareStatement":1,"setInt":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"Customer":1,"Connection":1,"ResultSet":1,"PreparedStatement":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":29,"StringLiteralExpr":4,"MethodCallExpr":8,"AssignExpr":1},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Finds a customer with a given number and PIN.\n      @param customerNumber the customer number\n      @param pin the personal identification number\n      @return the matching customer, or null if none found\n   */\npublic Customer findCustomer(int customerNumber, int pin) throws SQLException {\n    try (Connection conn = SimpleDataSource.getConnection()) {\n        Customer c = null;\n        PreparedStatement stat = conn.prepareStatement(\"SELECT * FROM BankCustomer WHERE Customer_Number = ?\");\n        stat.setInt(1, customerNumber);\n        ResultSet result = stat.executeQuery();\n        if (result.next() && pin == result.getInt(\"PIN\")) {\n            c = new Customer(customerNumber, result.getInt(\"Checking_Account_Number\"), result.getInt(\"Savings_Account_Number\"));\n        }\n        return c;\n    }\n}\n","name":"findCustomer","className":"Bank","variables":{"result":5,"conn":2,"stat":3,"c":3,"pin":1,"SimpleDataSource":1,"customerNumber":1},"constants":{"1":1,"\"Savings_Account_Number\"":1,"null":1,"\"Checking_Account_Number\"":1,"\"SELECT * FROM BankCustomer WHERE Customer_Number = ?\"":1,"\"PIN\"":1},"javaDoc":"Finds a customer with a given number and PIN customerNumber the customer number pin the personal identification number the matching customer or null if none found","comments":"\n      Finds a customer with a given number and PIN.\n      @param customerNumber the customer number\n      @param pin the personal identification number\n      @return the matching customer, or null if none found\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Bank"],"returnType":"ATM","methodCalls":{"reset":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   */\npublic ATM(Bank aBank) {\n    theBank = aBank;\n    reset();\n}\n","name":"ATM","className":"ATM","variables":{"theBank":1,"aBank":1},"constants":{},"javaDoc":"Constructs an ATM for a given bank aBank the bank to which this ATM connects","comments":"\n      Constructs an ATM for a given bank.\n      @param aBank the bank to which this ATM connects\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Resets the ATM to the initial state.\n   */\npublic void reset() {\n    customerNumber = -1;\n    currentAccount = null;\n    state = START;\n}\n","name":"reset","className":"ATM","variables":{"START":1,"currentAccount":1,"state":1,"customerNumber":1},"constants":{"1":1,"null":1},"javaDoc":"Resets the ATM to the initial state","comments":"\n      Resets the ATM to the initial state.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   */\npublic void setCustomerNumber(int number) {\n    customerNumber = number;\n    state = PIN;\n}\n","name":"setCustomerNumber","className":"ATM","variables":{"number":1,"PIN":1,"state":1,"customerNumber":1},"constants":{},"javaDoc":"Sets the current customer number and sets state to PIN (Precondition: state is START) number the customer number","comments":" \n      Sets the current customer number \n      and sets state to PIN. \n      (Precondition: state is START)\n      @param number the customer number.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"findCustomer":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":11,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   */\npublic void selectCustomer(int pin) throws SQLException {\n    currentCustomer = theBank.findCustomer(customerNumber, pin);\n    if (currentCustomer == null) {\n        state = START;\n    } else {\n        state = ACCOUNT;\n    }\n}\n","name":"selectCustomer","className":"ATM","variables":{"ACCOUNT":1,"currentCustomer":2,"theBank":1,"START":1,"state":2},"constants":{"null":1},"javaDoc":"Finds customer in bank If found sets state to ACCOUNT else to START (Precondition: state is PIN) pin the PIN of the current customer","comments":" \n      Finds customer in bank.\n      If found sets state to ACCOUNT, else to START.\n      (Precondition: state is PIN)\n      @param pin the PIN of the current customer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getCheckingAccount":1,"getSavingsAccount":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":12,"AssignExpr":3,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   */\npublic void selectAccount(int account) {\n    if (account == CHECKING) {\n        currentAccount = currentCustomer.getCheckingAccount();\n    } else {\n        currentAccount = currentCustomer.getSavingsAccount();\n    }\n    state = TRANSACT;\n}\n","name":"selectAccount","className":"ATM","variables":{"currentCustomer":2,"TRANSACT":1,"CHECKING":1,"currentAccount":2,"state":1,"account":1},"constants":{},"javaDoc":"Sets current account to checking or savings Sets state to TRANSACT (Precondition: state is ACCOUNT or TRANSACT) account one of CHECKING or SAVINGS","comments":" \n      Sets current account to checking or savings. Sets \n      state to TRANSACT. \n      (Precondition: state is ACCOUNT or TRANSACT)\n      @param account one of CHECKING or SAVINGS\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"withdraw":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   */\npublic void withdraw(double value) throws SQLException {\n    currentAccount.withdraw(value);\n}\n","name":"withdraw","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Withdraws amount from current account (Precondition: state is TRANSACT) value the amount to withdraw","comments":" \n      Withdraws amount from current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"deposit":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   */\npublic void deposit(double value) throws SQLException {\n    currentAccount.deposit(value);\n}\n","name":"deposit","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Deposits amount to current account (Precondition: state is TRANSACT) value the amount to deposit","comments":" \n      Deposits amount to current account. \n      (Precondition: state is TRANSACT)\n      @param value the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"getBalance":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   */\npublic double getBalance() throws SQLException {\n    return currentAccount.getBalance();\n}\n","name":"getBalance","className":"ATM","variables":{"currentAccount":1},"constants":{},"javaDoc":"Gets the balance of the current account (Precondition: state is TRANSACT) the balance","comments":" \n      Gets the balance of the current account. \n      (Precondition: state is TRANSACT)\n      @return the balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":12,"AssignExpr":3},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":3},"text":"/**\n      Moves back to the previous state.\n   */\npublic void back() {\n    if (state == TRANSACT) {\n        state = ACCOUNT;\n    } else if (state == ACCOUNT) {\n        state = PIN;\n    } else if (state == PIN) {\n        state = START;\n    }\n}\n","name":"back","className":"ATM","variables":{"ACCOUNT":2,"TRANSACT":1,"PIN":2,"START":1,"state":6},"constants":{},"javaDoc":"Moves back to the previous state","comments":"\n      Moves back to the previous state.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current state of this ATM.\n      @return the current state\n   */\npublic int getState() {\n    return state;\n}\n","name":"getState","className":"ATM","variables":{"state":1},"constants":{},"javaDoc":"Gets the current state of this ATM the current state","comments":"\n      Gets the current state of this ATM.\n      @return the current state\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    display.setText(\"\");\n}\n","name":"actionPerformed","className":"ClearButtonListener","variables":{"display":1},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"KeyPad","methodCalls":{"add":3,"addActionListener":1,"addButton":11,"setLayout":2,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"ClearButtonListener":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":50,"StringLiteralExpr":15,"MethodCallExpr":18,"AssignExpr":3},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":22},"text":"/**\n      Constructs the keypad panel.\n   */\npublic KeyPad() {\n    setLayout(new BorderLayout());\n    // Add display field\n    display = new JTextField();\n    add(display, \"North\");\n    // Make button panel\n    buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridLayout(4, 3));\n    // Add digit buttons\n    addButton(\"7\");\n    addButton(\"8\");\n    addButton(\"9\");\n    addButton(\"4\");\n    addButton(\"5\");\n    addButton(\"6\");\n    addButton(\"1\");\n    addButton(\"2\");\n    addButton(\"3\");\n    addButton(\"0\");\n    addButton(\".\");\n    // Add clear entry button\n    clearButton = new JButton(\"CE\");\n    buttonPanel.add(clearButton);\n    class ClearButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            display.setText(\"\");\n        }\n    }\n    ActionListener listener = new ClearButtonListener();\n    clearButton.addActionListener(new ClearButtonListener());\n    add(buttonPanel, \"Center\");\n}\n","name":"KeyPad","className":"KeyPad","variables":{"actionPerformed":1,"clearButton":2,"display":2,"buttonPanel":3,"listener":1,"ClearButtonListener":1,"event":1},"constants":{"\"North\"":1,"\"\"":1,"\"9\"":1,"\"8\"":1,"\"Center\"":1,"\"7\"":1,"\"6\"":1,"\"CE\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"3":1,"\"1\"":1,"4":1,"\"0\"":1,"\".\"":1},"javaDoc":"Constructs the keypad panel","comments":"Add display field Make button panel Add digit buttons Add clear entry button \n      Constructs the keypad panel.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":2,"equals":1,"indexOf":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":3,"NameExpr":15,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    // Don't add two decimal points\n    if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n        return;\n    }\n    // Append label text to button\n    display.setText(display.getText() + label);\n}\n","name":"actionPerformed","className":"DigitButtonListener","variables":{"display":3,"label":2},"constants":{"1":1,"\".\"":2},"javaDoc":"","comments":"Don't add two decimal points Append label text to button ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"getText":2,"equals":1,"addActionListener":1,"indexOf":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism","InnerClass"],"types":{"ActionListener":1,"DigitButtonListener":1,"JButton":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":28,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"TypeDeclarationStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Adds a button to the button panel.\n      @param label the button label\n   */\nprivate void addButton(final String label) {\n    class DigitButtonListener implements ActionListener {\n\n        public void actionPerformed(ActionEvent event) {\n            // Don't add two decimal points\n            if (label.equals(\".\") && display.getText().indexOf(\".\") != -1) {\n                return;\n            }\n            // Append label text to button\n            display.setText(display.getText() + label);\n        }\n    }\n    JButton button = new JButton(label);\n    buttonPanel.add(button);\n    ActionListener listener = new DigitButtonListener();\n    button.addActionListener(listener);\n}\n","name":"addButton","className":"KeyPad","variables":{"button":2,"actionPerformed":1,"DigitButtonListener":1,"display":3,"buttonPanel":1,"listener":1,"label":3,"event":1},"constants":{"1":1,"\".\"":2},"javaDoc":"Adds a button to the button panel label the button label","comments":"Don't add two decimal points Append label text to button \n      Adds a button to the button panel.\n      @param label the button label\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"double","methodCalls":{"parseDouble":1,"getText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   */\npublic double getValue() {\n    return Double.parseDouble(display.getText());\n}\n","name":"getValue","className":"KeyPad","variables":{"display":1,"Double":1},"constants":{},"javaDoc":"Gets the value that the user entered the value in the text field of the keypad","comments":" \n      Gets the value that the user entered. \n      @return the value in the text field of the keypad\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Clears the dislay. \n   */\npublic void clear() {\n    display.setText(\"\");\n}\n","name":"clear","className":"KeyPad","variables":{"display":1},"constants":{"\"\"":1},"javaDoc":"Clears the dislay","comments":" \n      Clears the dislay. \n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":6,"MethodCallExpr":6,"AssignExpr":5},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":10},"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":1,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"constants":{},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ATM"],"returnType":"ATMFrame","methodCalls":{"add":6,"showState":1,"setSize":1,"addActionListener":3,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":45,"StringLiteralExpr":3,"AssignExpr":6,"MethodCallExpr":12},"statements":{"ExpressionStmt":19},"text":"/**\n      Constructs the user interface of the ATM frame.\n   */\npublic ATMFrame(ATM anATM) {\n    theATM = anATM;\n    // Construct components\n    pad = new KeyPad();\n    display = new JTextArea(4, 20);\n    aButton = new JButton(\"  A  \");\n    aButton.addActionListener(new AButtonListener());\n    bButton = new JButton(\"  B  \");\n    bButton.addActionListener(new BButtonListener());\n    cButton = new JButton(\"  C  \");\n    cButton.addActionListener(new CButtonListener());\n    // Add components\n    JPanel buttonPanel = new JPanel();\n    buttonPanel.add(aButton);\n    buttonPanel.add(bButton);\n    buttonPanel.add(cButton);\n    setLayout(new FlowLayout());\n    add(pad);\n    add(display);\n    add(buttonPanel);\n    showState();\n    setSize(FRAME_WIDTH, FRAME_HEIGHT);\n}\n","name":"ATMFrame","className":"ATMFrame","variables":{"aButton":2,"pad":1,"theATM":1,"anATM":1,"display":1,"buttonPanel":4,"cButton":2,"bButton":2},"constants":{"\"  C  \"":1,"\"  B  \"":1,"4":1,"\"  A  \"":1,"20":1},"javaDoc":"Constructs the user interface of the ATM frame","comments":"Construct components Add components \n      Constructs the user interface of the ATM frame.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getState":1,"getBalance":1,"showMessageDialog":1,"clear":1,"setText":4},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":8,"NameExpr":40,"StringLiteralExpr":8,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"IfStmt":4,"BlockStmt":6,"TryStmt":1,"ExpressionStmt":7},"text":"/** \n      Updates display message.\n   */\npublic void showState() {\n    int state = theATM.getState();\n    pad.clear();\n    if (state == ATM.START) {\n        display.setText(\"Enter customer number\\nA = OK\");\n    } else if (state == ATM.PIN) {\n        display.setText(\"Enter PIN\\nA = OK\");\n    } else if (state == ATM.ACCOUNT) {\n        display.setText(\"Select Account\\n\" + \"A = Checking\\nB = Savings\\nC = Exit\");\n    } else if (state == ATM.TRANSACT) {\n        try {\n            display.setText(\"Balance = \" + theATM.getBalance() + \"\\nEnter amount and select transaction\\n\" + \"A = Withdraw\\nB = Deposit\\nC = Cancel\");\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n    }\n}\n","name":"showState","className":"ATMFrame","variables":{"exception":1,"pad":1,"theATM":2,"display":4,"state":5,"JOptionPane":1},"constants":{"\"Select Account\\n\"":1,"null":1,"\"Balance = \"":1,"\"A = Withdraw\\nB = Deposit\\nC = Cancel\"":1,"\"Enter PIN\\nA = OK\"":1,"\"A = Checking\\nB = Savings\\nC = Exit\"":1,"\"\\nEnter amount and select transaction\\n\"":1,"\"Enter customer number\\nA = OK\"":1,"\"Database error\"":1},"javaDoc":"Updates display message","comments":" \n      Updates display message.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setCustomerNumber":1,"showState":1,"getValue":3,"getState":1,"showMessageDialog":2,"selectAccount":1,"back":1,"selectCustomer":1,"withdraw":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":54,"CastExpr":2,"StringLiteralExpr":2,"FieldAccessExpr":5,"MethodCallExpr":12},"statements":{"IfStmt":4,"BlockStmt":8,"TryStmt":2,"ExpressionStmt":9},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.START) {\n        theATM.setCustomerNumber((int) pad.getValue());\n    } else if (state == ATM.PIN) {\n        try {\n            theATM.selectCustomer((int) pad.getValue());\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n    } else if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.CHECKING);\n    } else if (state == ATM.TRANSACT) {\n        try {\n            theATM.withdraw(pad.getValue());\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"AButtonListener","variables":{"exception":2,"pad":3,"theATM":6,"state":5,"JOptionPane":2},"constants":{"null":2,"\"Database error\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getValue":1,"getState":1,"selectAccount":1,"showMessageDialog":1,"deposit":1,"back":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":31,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":7},"statements":{"IfStmt":2,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":6},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.selectAccount(ATM.SAVINGS);\n    } else if (state == ATM.TRANSACT) {\n        try {\n            theATM.deposit(pad.getValue());\n        } catch (SQLException exception) {\n            JOptionPane.showMessageDialog(null, \"Database error\");\n        }\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"BButtonListener","variables":{"exception":1,"pad":1,"theATM":4,"state":3,"JOptionPane":1},"constants":{"null":1,"\"Database error\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showState":1,"getState":1,"reset":1,"back":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":19,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent event) {\n    int state = theATM.getState();\n    if (state == ATM.ACCOUNT) {\n        theATM.reset();\n    } else if (state == ATM.TRANSACT) {\n        theATM.back();\n    }\n    showState();\n}\n","name":"actionPerformed","className":"CButtonListener","variables":{"theATM":3,"state":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createStatement":1,"init":1,"getConnection":1,"nextLine":1,"hasNextLine":1,"getResultSet":1,"showResultSet":1,"execute":1,"System.out.println":2},"annotations":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"boolean":1,"Statement":1,"Connection":1,"ResultSet":1,"String":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":3,"VariableDeclarationExpr":6,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":53,"StringLiteralExpr":2,"FieldAccessExpr":6,"MethodCallExpr":10,"AssignExpr":2},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":9,"TryStmt":3,"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) throws SQLException, IOException, ClassNotFoundException {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java -classpath driver_class_path\" + File.pathSeparator + \". ExecSQL propertiesFile [SQLcommandFile]\");\n        return;\n    }\n    SimpleDataSource.init(args[0]);\n    Scanner in;\n    if (args.length > 1) {\n        in = new Scanner(new File(args[1]));\n    } else {\n        in = new Scanner(System.in);\n    }\n    try (Connection conn = SimpleDataSource.getConnection();\n        Statement stat = conn.createStatement()) {\n        while (in.hasNextLine()) {\n            String line = in.nextLine();\n            try {\n                boolean hasResultSet = stat.execute(line);\n                if (hasResultSet) {\n                    try (ResultSet result = stat.getResultSet()) {\n                        showResultSet(result);\n                    }\n                }\n            } catch (SQLException ex) {\n                System.out.println(ex);\n            }\n        }\n    }\n}\n","name":"main","className":"ExecSQL","variables":{"args":2,"result":1,"conn":2,"stat":3,"ex":1,"in":5,"hasResultSet":2,"SimpleDataSource":2,"line":1},"constants":{"0":2,"\"Usage: java -classpath driver_class_path\"":1,"1":2,"\". ExecSQL propertiesFile [SQLcommandFile]\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ResultSet"],"returnType":"void","methodCalls":{"next":1,"getColumnLabel":1,"getColumnCount":1,"getString":1,"getMetaData":1,"System.out.print":4,"System.out.println":2},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"ResultSetMetaData":1,"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":55,"StringLiteralExpr":2,"FieldAccessExpr":6,"UnaryExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ForStmt":2,"ExpressionStmt":8},"text":"/**\n      Prints a result set.\n      @param result the result set\n   */\npublic static void showResultSet(ResultSet result) throws SQLException {\n    ResultSetMetaData metaData = result.getMetaData();\n    int columnCount = metaData.getColumnCount();\n    for (int i = 1; i <= columnCount; i++) {\n        if (i > 1) {\n            System.out.print(\", \");\n        }\n        System.out.print(metaData.getColumnLabel(i));\n    }\n    System.out.println();\n    while (result.next()) {\n        for (int i = 1; i <= columnCount; i++) {\n            if (i > 1) {\n                System.out.print(\", \");\n            }\n            System.out.print(result.getString(i));\n        }\n        System.out.println();\n    }\n}\n","name":"showResultSet","className":"ExecSQL","variables":{"result":3,"metaData":3,"i":8,"columnCount":3},"constants":{"1":4,"\", \"":2},"javaDoc":"Prints a result set result the result set","comments":"\n      Prints a result set.\n      @param result the result set\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getProperty":4,"load":1,"forName":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"String":1,"Properties":1,"FileInputStream":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":6,"MethodCallExpr":6,"AssignExpr":5},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":10},"text":"/**\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   */\npublic static void init(String fileName) throws IOException, ClassNotFoundException {\n    Properties props = new Properties();\n    FileInputStream in = new FileInputStream(fileName);\n    props.load(in);\n    String driver = props.getProperty(\"jdbc.driver\");\n    url = props.getProperty(\"jdbc.url\");\n    username = props.getProperty(\"jdbc.username\");\n    if (username == null) {\n        username = \"\";\n    }\n    password = props.getProperty(\"jdbc.password\");\n    if (password == null) {\n        password = \"\";\n    }\n    if (driver != null) {\n        Class.forName(driver);\n    }\n}\n","name":"init","className":"SimpleDataSource","variables":{"fileName":1,"password":3,"driver":2,"in":1,"Class":1,"url":1,"props":6,"username":3},"constants":{"\"\"":2,"\"jdbc.driver\"":1,"null":3,"\"jdbc.url\"":1,"\"jdbc.password\"":1,"\"jdbc.username\"":1},"javaDoc":"Initializes the data source fileName the name of the property file that contains the database driver URL username and password","comments":"\n      Initializes the data source.\n      @param fileName the name of the property file that \n      contains the database driver, URL, username, and password\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Connection","methodCalls":{"getConnection":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets a connection to the database.\n      @return the database connection\n   */\npublic static Connection getConnection() throws SQLException {\n    return DriverManager.getConnection(url, username, password);\n}\n","name":"getConnection","className":"SimpleDataSource","variables":{"DriverManager":1},"constants":{},"javaDoc":"Gets a connection to the database the database connection","comments":"\n      Gets a connection to the database.\n      @return the database connection\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{"newCondition":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"NameExpr":6,"AssignExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n    balanceChangeLock = new ReentrantLock();\n    sufficientFundsCondition = balanceChangeLock.newCondition();\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"sufficientFundsCondition":1,"balanceChangeLock":2},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"signalAll":1,"unlock":1,"lock":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["ExceptionHandling"],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":25,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":5,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    balanceChangeLock.lock();\n    try {\n        System.out.print(\"Depositing \" + amount);\n        double newBalance = balance + amount;\n        System.out.println(\", new balance is \" + newBalance);\n        balance = newBalance;\n        sufficientFundsCondition.signalAll();\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":3,"sufficientFundsCondition":1,"balanceChangeLock":2},"constants":{"\", new balance is \"":1,"\"Depositing \"":1},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"unlock":1,"await":1,"lock":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":27,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":5,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":7},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) throws InterruptedException {\n    balanceChangeLock.lock();\n    try {\n        while (balance < amount) {\n            sufficientFundsCondition.await();\n        }\n        System.out.print(\"Withdrawing \" + amount);\n        double newBalance = balance - amount;\n        System.out.println(\", new balance is \" + newBalance);\n        balance = newBalance;\n    } finally {\n        balanceChangeLock.unlock();\n    }\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":3,"balance":3,"sufficientFundsCondition":1,"newBalance":3,"balanceChangeLock":2},"constants":{"\"Withdrawing \"":1,"\", new balance is \"":1},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BankAccount","double","int"],"returnType":"WithdrawRunnable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   */\npublic WithdrawRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"WithdrawRunnable","className":"WithdrawRunnable","variables":{"amount":1,"aCount":1,"count":1,"anAccount":1,"anAmount":1,"account":1},"constants":{},"javaDoc":"Constructs a withdraw runnable anAccount the account from which to withdraw money anAmount the amount to withdraw in each repetition aCount the number of repetitions","comments":"\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"withdraw":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.withdraw(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"WithdrawRunnable","variables":{"exception":1,"count":1,"i":3,"account":1,"Thread":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"DepositRunnable":1,"WithdrawRunnable":1,"double":1,"BankAccount":1,"int":3,"Thread":2},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":9,"BinaryExpr":1,"NameExpr":17,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    BankAccount account = new BankAccount();\n    final double AMOUNT = 100;\n    final int REPETITIONS = 100;\n    final int THREADS = 100;\n    for (int i = 1; i <= THREADS; i++) {\n        DepositRunnable d = new DepositRunnable(account, AMOUNT, REPETITIONS);\n        WithdrawRunnable w = new WithdrawRunnable(account, AMOUNT, REPETITIONS);\n        Thread dt = new Thread(d);\n        Thread wt = new Thread(w);\n        dt.start();\n        wt.start();\n    }\n}\n","name":"main","className":"BankAccountThreadRunner","variables":{"dt":2,"d":2,"AMOUNT":3,"THREADS":2,"w":2,"i":3,"REPETITIONS":3,"wt":2,"account":3},"constants":{"100":3,"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["BankAccount","double","int"],"returnType":"DepositRunnable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   */\npublic DepositRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"DepositRunnable","className":"DepositRunnable","variables":{"amount":1,"aCount":1,"count":1,"anAccount":1,"anAmount":1,"account":1},"constants":{},"javaDoc":"Constructs a deposit runnable anAccount the account into which to deposit money anAmount the amount to deposit in each repetition aCount the number of repetitions","comments":"\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"deposit":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.deposit(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"DepositRunnable","variables":{"exception":1,"count":1,"i":3,"account":1,"Thread":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int[]","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   */\npublic static int[] randomIntArray(int length, int n) {\n    int[] a = new int[length];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = generator.nextInt(n);\n    }\n    return a;\n}\n","name":"randomIntArray","className":"ArrayUtil","variables":{"a":3,"length":1,"i":4,"generator":1},"constants":{"0":1},"javaDoc":"Creates an array filled with random values length the length of the array n the number of possible random values an array filled with length numbers between 0 and n - 1","comments":"\n      Creates an array filled with random values.\n      @param length the length of the array\n      @param n the number of possible random values\n      @return an array filled with length numbers between\n      0 and n - 1\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":4,"NameExpr":9,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   */\npublic static void swap(int[] a, int i, int j) {\n    int temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n}\n","name":"swap","className":"ArrayUtil","variables":{"a":4,"temp":2,"i":2,"j":2},"constants":{},"javaDoc":"Swaps two entries of an array a the array i the first position to swap j the second position to swap","comments":"\n      Swaps two entries of an array.\n      @param a the array\n      @param i the first position to swap\n      @param j the second position to swap\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"SelectionSortComponent","methodCalls":{"randomIntArray":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":5,"ThisExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs the component.\n   */\npublic SelectionSortComponent() {\n    int[] values = ArrayUtil.randomIntArray(30, 300);\n    sorter = new SelectionSorter(values, this);\n}\n","name":"SelectionSortComponent","className":"SelectionSortComponent","variables":{"sorter":1,"values":2,"ArrayUtil":1},"constants":{"300":1,"30":1},"javaDoc":"Constructs the component","comments":"\n      Constructs the component.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"draw":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void paintComponent(Graphics g) {\n    sorter.draw(g);\n}\n","name":"paintComponent","className":"SelectionSortComponent","variables":{"sorter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":1},"text":"public void run() {\n    try {\n        sorter.sort();\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"AnimationRunnable","variables":{"exception":1,"sorter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"start":1,"sort":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["InnerMethod","PolyMorphism","InnerClass","ExceptionHandling"],"types":{"AnimationRunnable":1,"Runnable":1,"Thread":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":11,"MethodCallExpr":2},"statements":{"TypeDeclarationStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":4},"text":"/**\n      Starts a new animation thread.\n   */\npublic void startAnimation() {\n    class AnimationRunnable implements Runnable {\n\n        public void run() {\n            try {\n                sorter.sort();\n            } catch (InterruptedException exception) {\n            }\n        }\n    }\n    Runnable r = new AnimationRunnable();\n    Thread t = new Thread(r);\n    t.start();\n}\n","name":"startAnimation","className":"SelectionSortComponent","variables":{"exception":1,"r":2,"sorter":1,"t":2,"AnimationRunnable":1,"run":1},"constants":{},"javaDoc":"Starts a new animation thread","comments":"\n      Starts a new animation thread.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int[]","JComponent"],"returnType":"SelectionSorter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a selection sorter.\n      @param anArray the array to sort\n      @param aComponent the component to be repainted when the animation \n      pauses\n   */\npublic SelectionSorter(int[] anArray, JComponent aComponent) {\n    a = anArray;\n    sortStateLock = new ReentrantLock();\n    component = aComponent;\n}\n","name":"SelectionSorter","className":"SelectionSorter","variables":{"a":1,"component":1,"sortStateLock":1,"anArray":1,"aComponent":1},"constants":{},"javaDoc":"Constructs a selection sorter anArray the array to sort aComponent the component to be repainted when the animation pauses","comments":"\n      Constructs a selection sorter.\n      @param anArray the array to sort\n      @param aComponent the component to be repainted when the animation \n      pauses\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"unlock":1,"swap":1,"minimumPosition":1,"lock":1,"pause":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":24,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"/**\n      Sorts the array managed by this selection sorter.\n   */\npublic void sort() throws InterruptedException {\n    for (int i = 0; i < a.length - 1; i++) {\n        int minPos = minimumPosition(i);\n        sortStateLock.lock();\n        try {\n            ArrayUtil.swap(a, minPos, i);\n            // For animation\n            alreadySorted = i;\n        } finally {\n            sortStateLock.unlock();\n        }\n        pause(2);\n    }\n}\n","name":"sort","className":"SelectionSorter","variables":{"sortStateLock":2,"alreadySorted":1,"i":4,"minPos":1,"ArrayUtil":1},"constants":{"0":1,"1":1,"2":1},"javaDoc":"Sorts the array managed by this selection sorter","comments":"For animation \n      Sorts the array managed by this selection sorter.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"unlock":1,"lock":1,"pause":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":24,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n      Finds the smallest element in a tail range of the array\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from]...a[a.length - 1]\n   */\nprivate int minimumPosition(int from) throws InterruptedException {\n    int minPos = from;\n    for (int i = from + 1; i < a.length; i++) {\n        sortStateLock.lock();\n        try {\n            if (a[i] < a[minPos]) {\n                minPos = i;\n            }\n            // For animation\n            markedPosition = i;\n        } finally {\n            sortStateLock.unlock();\n        }\n        pause(2);\n    }\n    return minPos;\n}\n","name":"minimumPosition","className":"SelectionSorter","variables":{"a":2,"sortStateLock":2,"minPos":4,"i":6,"from":2,"markedPosition":1},"constants":{"1":1,"2":1},"javaDoc":"Finds the smallest element in a tail range of the array from the first position in a to compare the position of the smallest element in the range a[from] a[a length - 1]","comments":"For animation \n      Finds the smallest element in a tail range of the array\n      @param from the first position in a to compare\n      @return the position of the smallest element in the\n      range a[from]...a[a.length - 1]\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":3,"unlock":1,"lock":1,"getWidth":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":["ExceptionHandling"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":48,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":6,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n      Draws the current state of the sorting algorithm.\n      @param g the graphics context\n   */\npublic void draw(Graphics g) {\n    sortStateLock.lock();\n    try {\n        int deltaX = component.getWidth() / a.length;\n        for (int i = 0; i < a.length; i++) {\n            if (i == markedPosition) {\n                g.setColor(Color.RED);\n            } else if (i <= alreadySorted) {\n                g.setColor(Color.BLUE);\n            } else {\n                g.setColor(Color.BLACK);\n            }\n            g.drawLine(i * deltaX, 0, i * deltaX, a[i]);\n        }\n    } finally {\n        sortStateLock.unlock();\n    }\n}\n","name":"draw","className":"SelectionSorter","variables":{"a":1,"component":1,"sortStateLock":2,"deltaX":3,"g":4,"alreadySorted":1,"i":8,"markedPosition":1},"constants":{"0":2},"javaDoc":"Draws the current state of the sorting algorithm g the graphics context","comments":"\n      Draws the current state of the sorting algorithm.\n      @param g the graphics context\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"sleep":1,"repaint":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Pauses the animation.\n      @param steps the number of steps to pause\n   */\npublic void pause(int steps) throws InterruptedException {\n    component.repaint();\n    Thread.sleep(steps * DELAY);\n}\n","name":"pause","className":"SelectionSorter","variables":{"component":1,"steps":1,"DELAY":1,"Thread":1},"constants":{},"javaDoc":"Pauses the animation steps the number of steps to pause","comments":"\n      Pauses the animation.\n      @param steps the number of steps to pause\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setDefaultCloseOperation":1,"startAnimation":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"JFrame":1,"int":2,"SelectionSortComponent":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"NameExpr":24,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    JFrame frame = new JFrame();\n    final int FRAME_WIDTH = 300;\n    final int FRAME_HEIGHT = 400;\n    frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    final SelectionSortComponent component = new SelectionSortComponent();\n    frame.add(component, BorderLayout.CENTER);\n    frame.setVisible(true);\n    component.startAnimation();\n}\n","name":"main","className":"SelectionSortViewer","variables":{"component":2,"FRAME_WIDTH":1,"FRAME_HEIGHT":1,"frame":5},"constants":{"300":1,"400":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with a zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with a zero balance","comments":"\n      Constructs a bank account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":4},"text":"/**\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   */\npublic void deposit(double amount) {\n    System.out.print(\"Depositing \" + amount);\n    double newBalance = balance + amount;\n    System.out.println(\", new balance is \" + newBalance);\n    balance = newBalance;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":3},"constants":{"\", new balance is \"":1,"\"Depositing \"":1},"javaDoc":"Deposits money into the bank account amount the amount to deposit","comments":"\n      Deposits money into the bank account.\n      @param amount the amount to deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":4},"text":"/**\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   */\npublic void withdraw(double amount) {\n    System.out.print(\"Withdrawing \" + amount);\n    double newBalance = balance - amount;\n    System.out.println(\", new balance is \" + newBalance);\n    balance = newBalance;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":2,"balance":2,"newBalance":3},"constants":{"\"Withdrawing \"":1,"\", new balance is \"":1},"javaDoc":"Withdraws money from the bank account amount the amount to withdraw","comments":"\n      Withdraws money from the bank account.\n      @param amount the amount to withdraw\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of the bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of the bank account the current balance","comments":"\n      Gets the current balance of the bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BankAccount","double","int"],"returnType":"WithdrawRunnable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   */\npublic WithdrawRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"WithdrawRunnable","className":"WithdrawRunnable","variables":{"amount":1,"aCount":1,"count":1,"anAccount":1,"anAmount":1,"account":1},"constants":{},"javaDoc":"Constructs a withdraw runnable anAccount the account from which to withdraw money anAmount the amount to withdraw in each repetition aCount the number of repetitions","comments":"\n      Constructs a withdraw runnable.\n      @param anAccount the account from which to withdraw money\n      @param anAmount the amount to withdraw in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"withdraw":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.withdraw(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"WithdrawRunnable","variables":{"exception":1,"count":1,"i":3,"account":1,"Thread":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"DepositRunnable":1,"WithdrawRunnable":1,"double":1,"BankAccount":1,"int":3,"Thread":2},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":9,"BinaryExpr":1,"NameExpr":17,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    BankAccount account = new BankAccount();\n    final double AMOUNT = 100;\n    final int REPETITIONS = 100;\n    final int THREADS = 100;\n    for (int i = 1; i <= THREADS; i++) {\n        DepositRunnable d = new DepositRunnable(account, AMOUNT, REPETITIONS);\n        WithdrawRunnable w = new WithdrawRunnable(account, AMOUNT, REPETITIONS);\n        Thread dt = new Thread(d);\n        Thread wt = new Thread(w);\n        dt.start();\n        wt.start();\n    }\n}\n","name":"main","className":"BankAccountThreadRunner","variables":{"dt":2,"d":2,"AMOUNT":3,"THREADS":2,"w":2,"i":3,"REPETITIONS":3,"wt":2,"account":3},"constants":{"100":3,"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["BankAccount","double","int"],"returnType":"DepositRunnable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   */\npublic DepositRunnable(BankAccount anAccount, double anAmount, int aCount) {\n    account = anAccount;\n    amount = anAmount;\n    count = aCount;\n}\n","name":"DepositRunnable","className":"DepositRunnable","variables":{"amount":1,"aCount":1,"count":1,"anAccount":1,"anAmount":1,"account":1},"constants":{},"javaDoc":"Constructs a deposit runnable anAccount the account into which to deposit money anAmount the amount to deposit in each repetition aCount the number of repetitions","comments":"\n      Constructs a deposit runnable.\n      @param anAccount the account into which to deposit money\n      @param anAmount the amount to deposit in each repetition\n      @param aCount the number of repetitions\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"deposit":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        for (int i = 1; i <= count; i++) {\n            account.deposit(amount);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"DepositRunnable","variables":{"exception":1,"count":1,"i":3,"account":1,"Thread":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"GreetingRunnable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs the runnable object.\n      @param aGreeting the greeting to display\n   */\npublic GreetingRunnable(String aGreeting) {\n    greeting = aGreeting;\n}\n","name":"GreetingRunnable","className":"GreetingRunnable","variables":{"greeting":1,"aGreeting":1},"constants":{},"javaDoc":"Constructs the runnable object aGreeting the greeting to display","comments":"\n      Constructs the runnable object.\n      @param aGreeting the greeting to display\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":1,"Date":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":14,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":3},"text":"public void run() {\n    try {\n        for (int i = 1; i <= REPETITIONS; i++) {\n            Date now = new Date();\n            System.out.println(now + \" \" + greeting);\n            Thread.sleep(DELAY);\n        }\n    } catch (InterruptedException exception) {\n    }\n}\n","name":"run","className":"GreetingRunnable","variables":{"exception":1,"now":2,"greeting":1,"i":3,"REPETITIONS":1,"Thread":1},"constants":{"1":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"start":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"GreetingRunnable":2,"Thread":2},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":4,"StringLiteralExpr":2,"NameExpr":8,"MethodCallExpr":2},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    GreetingRunnable r1 = new GreetingRunnable(\"Hello\");\n    GreetingRunnable r2 = new GreetingRunnable(\"Goodbye\");\n    Thread t1 = new Thread(r1);\n    Thread t2 = new Thread(r2);\n    t1.start();\n    t2.start();\n}\n","name":"main","className":"GreetingThreadRunner","variables":{"r2":2,"t1":2,"t2":2,"r1":2},"constants":{"\"Hello\"":1,"\"Goodbye\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getNumberOfTires() {\n    return numberOfTires;\n}\n","name":"getNumberOfTires","className":"Vehicle","variables":{"numberOfTires":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setNumberOfTires(int newValue) {\n    numberOfTires = newValue;\n}\n","name":"setNumberOfTires","className":"Vehicle","variables":{"newValue":1,"numberOfTires":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getDescription() {\n    return \"A vehicle with \" + numberOfTires + \" tires\";\n}\n","name":"getDescription","className":"Vehicle","variables":{"numberOfTires":1},"constants":{"\"A vehicle with \"":1,"\" tires\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Car","methodCalls":{"setNumberOfTires":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"public Car() {\n    // Use the public interface to access the instance variable of the superclass\n    // same as this.setNumberOfTires(4)\n    setNumberOfTires(4);\n    licensePlateNumber = \"??????\";\n}\n","name":"Car","className":"Car","variables":{"licensePlateNumber":1},"constants":{"4":1,"\"??????\"":1},"javaDoc":"","comments":"Use the public interface to access the instance variable of the superclass same as this setNumberOfTires(4) ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// This method is added to the subclass\npublic void setLicensePlateNumber(String newValue) {\n    licensePlateNumber = newValue;\n}\n","name":"setLicensePlateNumber","className":"Car","variables":{"newValue":1,"licensePlateNumber":1},"constants":{},"javaDoc":"","comments":" This method is added to the subclass","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// This method overrides a method from the superclass\npublic String getDescription() {\n    return \"A car with license plate \" + licensePlateNumber;\n}\n","name":"getDescription","className":"Car","variables":{"licensePlateNumber":1},"constants":{"\"A car with license plate \"":1},"javaDoc":"","comments":" This method overrides a method from the superclass","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Car"],"returnType":"void","methodCalls":{"getNumberOfTires":1,"getDescription":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":2},"text":"public static void print(Car c) {\n    System.out.println(c.getDescription());\n    System.out.println(\"Tires: \" + c.getNumberOfTires());\n}\n","name":"print","className":"CarDemo","variables":{"c":2},"constants":{"\"Tires: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":2,"setLicensePlateNumber":1,"setNumberOfTires":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Car":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Car aPlainCar = new Car();\n    print(aPlainCar);\n    Car aLimo = new Car();\n    aLimo.setLicensePlateNumber(\"W00H00\");\n    aLimo.setNumberOfTires(8);\n    print(aLimo);\n}\n","name":"main","className":"CarDemo","variables":{"aPlainCar":1,"aLimo":3},"constants":{"8":1,"\"W00H00\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getNumberOfTires() {\n    return numberOfTires;\n}\n","name":"getNumberOfTires","className":"Vehicle","variables":{"numberOfTires":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setNumberOfTires(int newValue) {\n    numberOfTires = newValue;\n}\n","name":"setNumberOfTires","className":"Vehicle","variables":{"newValue":1,"numberOfTires":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getClass":1,"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return getClass().getName() + \"[numberOfTires=\" + numberOfTires + \"]\";\n// This is a good way of implementing toString in a superclass--see Special Topic 9.6\n}\n","name":"toString","className":"Vehicle","variables":{"numberOfTires":1},"constants":{"\"]\"":1,"\"[numberOfTires=\"":1},"javaDoc":"","comments":"This is a good way of implementing toString in a superclass--see Special Topic 9 6 ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Car","methodCalls":{"setNumberOfTires":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"public Car() {\n    setNumberOfTires(4);\n    licensePlateNumber = \"??????\";\n}\n","name":"Car","className":"Car","variables":{"licensePlateNumber":1},"constants":{"4":1,"\"??????\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setLicensePlateNumber(String newValue) {\n    licensePlateNumber = newValue;\n}\n","name":"setLicensePlateNumber","className":"Car","variables":{"newValue":1,"licensePlateNumber":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":3,"NameExpr":3,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return super.toString() + \"[licensePlateNumber=\" + licensePlateNumber + \"]\";\n// This is a good way of implementing toString in a subclass--see Special Topic 9.6\n}\n","name":"toString","className":"Car","variables":{"licensePlateNumber":1},"constants":{"\"]\"":1,"\"[licensePlateNumber=\"":1},"javaDoc":"","comments":"This is a good way of implementing toString in a subclass--see Special Topic 9 6 ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Vehicle","String"],"returnType":"void","methodCalls":{"setLicensePlateNumber":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Car":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":12,"CastExpr":1,"FieldAccessExpr":1,"InstanceOfExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public static void process(Vehicle v, String plateNumber) {\n    // This example shows the syntax of instanceof and casting\n    if (v instanceof Car) {\n        // Vehicle has no setLicensePlateNumber method--must cast\n        Car c = (Car) v;\n        c.setLicensePlateNumber(plateNumber);\n    }\n    // calls v.toString()\n    System.out.println(v);\n}\n","name":"process","className":"VehicleDemo","variables":{"c":2,"v":2},"constants":{},"javaDoc":"","comments":"This example shows the syntax of instanceof and casting Vehicle has no setLicensePlateNumber method--must cast calls v toString() ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":3,"setNumberOfTires":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Vehicle":2,"Car":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":11,"StringLiteralExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Vehicle aCar = new Car();\n    process(aCar, \"XYX123\");\n    Vehicle aLimo = new Car();\n    aLimo.setNumberOfTires(8);\n    process(aLimo, \"W00H00\");\n    process(new Motorcycle(), \"MT1729\");\n}\n","name":"main","className":"VehicleDemo","variables":{"aLimo":2,"aCar":1},"constants":{"\"MT1729\"":1,"8":1,"\"W00H00\"":1,"\"XYX123\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Motorcycle","methodCalls":{"setNumberOfTires":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public Motorcycle() {\n    setNumberOfTires(2);\n}\n","name":"Motorcycle","className":"Motorcycle","variables":{},"constants":{"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addChoice":8,"presentQuestion":2,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"ChoiceQuestion":2},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":8,"NameExpr":36,"StringLiteralExpr":10,"MethodCallExpr":12},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    ChoiceQuestion first = new ChoiceQuestion();\n    first.setText(\"What was the original name of the Java language?\");\n    first.addChoice(\"*7\", false);\n    first.addChoice(\"Duke\", false);\n    first.addChoice(\"Oak\", true);\n    first.addChoice(\"Gosling\", false);\n    ChoiceQuestion second = new ChoiceQuestion();\n    second.setText(\"In which country was the inventor of Java born?\");\n    second.addChoice(\"Australia\", false);\n    second.addChoice(\"Canada\", true);\n    second.addChoice(\"Denmark\", false);\n    second.addChoice(\"United States\", false);\n    presentQuestion(first);\n    presentQuestion(second);\n}\n","name":"main","className":"QuestionDemo2","variables":{"first":6,"second":6},"constants":{"\"In which country was the inventor of Java born?\"":1,"\"*7\"":1,"\"Denmark\"":1,"\"United States\"":1,"\"What was the original name of the Java language?\"":1,"false":6,"true":2,"\"Canada\"":1,"\"Duke\"":1,"\"Australia\"":1,"\"Gosling\"":1,"\"Oak\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ChoiceQuestion"],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"display":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"/**\n      Presents a question to the user and checks the response.\n      @param q the question\n   */\npublic static void presentQuestion(ChoiceQuestion q) {\n    q.display();\n    System.out.print(\"Your answer: \");\n    Scanner in = new Scanner(System.in);\n    String response = in.nextLine();\n    System.out.println(q.checkAnswer(response));\n}\n","name":"presentQuestion","className":"QuestionDemo2","variables":{"q":2,"in":2,"response":1},"constants":{"\"Your answer: \"":1},"javaDoc":"Presents a question to the user and checks the response q the question","comments":"\n      Presents a question to the user and checks the response.\n      @param q the question\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"constants":{"\"\"":2},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":1},"constants":{},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":1},"constants":{},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":1},"constants":{},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"constants":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ChoiceQuestion","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a choice question with no choices.\n   */\npublic ChoiceQuestion() {\n    choices = new ArrayList<String>();\n}\n","name":"ChoiceQuestion","className":"ChoiceQuestion","variables":{"choices":1},"constants":{},"javaDoc":"Constructs a choice question with no choices","comments":"\n      Constructs a choice question with no choices.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","boolean"],"returnType":"void","methodCalls":{"add":1,"size":1,"setAnswer":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   */\npublic void addChoice(String choice, boolean correct) {\n    choices.add(choice);\n    if (correct) {\n        // Convert choices.size() to string\n        String choiceString = \"\" + choices.size();\n        setAnswer(choiceString);\n    }\n}\n","name":"addChoice","className":"ChoiceQuestion","variables":{"correct":1,"choiceString":1,"choices":2},"constants":{"\"\"":1},"javaDoc":"Adds an answer choice to this question choice the choice to add correct true if this is the correct choice false otherwise","comments":"Convert choices size() to string \n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"SuperExpr":1,"BinaryExpr":4,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public void display() {\n    // Display the question text\n    super.display();\n    // Display the answer choices\n    for (int i = 0; i < choices.size(); i++) {\n        int choiceNumber = i + 1;\n        System.out.println(choiceNumber + \": \" + choices.get(i));\n    }\n}\n","name":"display","className":"ChoiceQuestion","variables":{"choiceNumber":2,"i":4,"choices":2},"constants":{"0":1,"1":1,"\": \"":1},"javaDoc":"","comments":"Display the question text Display the answer choices ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a bank account with zero balance.\n   */\npublic BankAccount() {\n    balance = 0;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1},"constants":{"0":1},"javaDoc":"Constructs a bank account with zero balance","comments":"\n      Constructs a bank account with zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Makes a deposit into this account.\n      @param amount the amount of the deposit\n   */\npublic void deposit(double amount) {\n    balance = balance + amount;\n}\n","name":"deposit","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Makes a deposit into this account amount the amount of the deposit","comments":"\n      Makes a deposit into this account.\n      @param amount the amount of the deposit\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   */\npublic void withdraw(double amount) {\n    balance = balance - amount;\n}\n","name":"withdraw","className":"BankAccount","variables":{"amount":1,"balance":2},"constants":{},"javaDoc":"Makes a withdrawal from this account or charges a penalty if sufficient funds are not available amount the amount of the withdrawal","comments":"\n      Makes a withdrawal from this account, or charges a penalty if\n      sufficient funds are not available.\n      @param amount the amount of the withdrawal\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Carries out the end of month processing that is appropriate\n      for this account.\n   */\npublic void monthEnd() {\n}\n","name":"monthEnd","className":"BankAccount","variables":{},"constants":{},"javaDoc":"Carries out the end of month processing that is appropriate for this account","comments":"\n      Carries out the end of month processing that is appropriate\n      for this account.\n   ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the current balance of this bank account.\n      @return the current balance\n   */\npublic double getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"Gets the current balance of this bank account the current balance","comments":"\n      Gets the current balance of this bank account.\n      @return the current balance\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"SavingsAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a savings account with a zero balance.\n   */\npublic SavingsAccount() {\n    interestRate = 0;\n    minBalance = 0;\n}\n","name":"SavingsAccount","className":"SavingsAccount","variables":{"interestRate":1,"minBalance":1},"constants":{"0":2},"javaDoc":"Constructs a savings account with a zero balance","comments":"\n      Constructs a savings account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the interest rate for this account.\n      @param rate the monthly interest rate in percent\n   */\npublic void setInterestRate(double rate) {\n    interestRate = rate;\n}\n","name":"setInterestRate","className":"SavingsAccount","variables":{"interestRate":1,"rate":1},"constants":{},"javaDoc":"Sets the interest rate for this account rate the monthly interest rate in percent","comments":"\n      Sets the interest rate for this account.\n      @param rate the monthly interest rate in percent\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"getBalance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":1,"NameExpr":9,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public void withdraw(double amount) {\n    super.withdraw(amount);\n    double balance = getBalance();\n    if (balance < minBalance) {\n        minBalance = balance;\n    }\n}\n","name":"withdraw","className":"SavingsAccount","variables":{"minBalance":2,"balance":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getBalance":1,"deposit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":8,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"public void monthEnd() {\n    double interest = minBalance * interestRate / 100;\n    deposit(interest);\n    minBalance = getBalance();\n}\n","name":"monthEnd","className":"SavingsAccount","variables":{"interestRate":1,"minBalance":2,"interest":1},"constants":{"100":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"equals":5,"setInterestRate":1,"nextInt":1,"System.out.print":2,"nextDouble":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Scanner":1,"SavingsAccount":1,"boolean":1,"double":1,"BankAccount[]":1,"String":1,"int":5},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":3,"VariableDeclarationExpr":11,"ArrayAccessExpr":7,"BinaryExpr":9,"NameExpr":99,"StringLiteralExpr":9,"UnaryExpr":4,"AssignExpr":3,"DoubleLiteralExpr":1,"BooleanLiteralExpr":2,"FieldAccessExpr":9,"ArrayCreationExpr":1,"MethodCallExpr":18},"statements":{"IfStmt":4,"WhileStmt":1,"BlockStmt":9,"ForStmt":3,"ExpressionStmt":19},"text":"public static void main(String[] args) {\n    // Create accounts\n    final int ACCOUNTS_SIZE = 10;\n    BankAccount[] accounts = new BankAccount[ACCOUNTS_SIZE];\n    for (int i = 0; i < accounts.length / 2; i++) {\n        accounts[i] = new CheckingAccount();\n    }\n    for (int i = accounts.length / 2; i < accounts.length; i++) {\n        SavingsAccount account = new SavingsAccount();\n        account.setInterestRate(0.75);\n        accounts[i] = account;\n    }\n    // Execute commands\n    Scanner in = new Scanner(System.in);\n    boolean done = false;\n    while (!done) {\n        System.out.print(\"D)eposit  W)ithdraw  M)onth end  Q)uit: \");\n        String input = in.next();\n        if (// Deposit or withdrawal\n        input.equals(\"D\") || input.equals(\"W\")) {\n            System.out.print(\"Enter account number and amount: \");\n            int num = in.nextInt();\n            double amount = in.nextDouble();\n            if (input.equals(\"D\")) {\n                accounts[num].deposit(amount);\n            } else {\n                accounts[num].withdraw(amount);\n            }\n            System.out.println(\"Balance: \" + accounts[num].getBalance());\n        } else if (// Month end processing\n        input.equals(\"M\")) {\n            for (int n = 0; n < accounts.length; n++) {\n                accounts[n].monthEnd();\n                System.out.println(n + \" \" + accounts[n].getBalance());\n            }\n        } else if (input.equals(\"Q\")) {\n            done = true;\n        }\n    }\n}\n","name":"main","className":"AccountDemo","variables":{"ACCOUNTS_SIZE":2,"input":6,"amount":1,"in":4,"num":4,"i":8,"accounts":8,"done":3,"account":3,"n":6},"constants":{"\"D\"":2,"\" \"":1,"false":1,"0.75":1,"\"W\"":1,"\"Balance: \"":1,"0":2,"2":2,"\"Q\"":1,"\"D)eposit  W)ithdraw  M)onth end  Q)uit: \"":1,"\"M\"":1,"true":1,"\"Enter account number and amount: \"":1,"10":1},"javaDoc":"","comments":"Create accounts Execute commands Deposit or withdrawal Month end processing ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"CheckingAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a checking account with a zero balance.\n   */\npublic CheckingAccount() {\n    withdrawals = 0;\n}\n","name":"CheckingAccount","className":"CheckingAccount","variables":{"withdrawals":1},"constants":{"0":1},"javaDoc":"Constructs a checking account with a zero balance","comments":"\n      Constructs a checking account with a zero balance.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"SuperExpr":2,"BinaryExpr":1,"NameExpr":9,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public void withdraw(double amount) {\n    final int FREE_WITHDRAWALS = 3;\n    final int WITHDRAWAL_FEE = 1;\n    super.withdraw(amount);\n    withdrawals++;\n    if (withdrawals > FREE_WITHDRAWALS) {\n        super.withdraw(WITHDRAWAL_FEE);\n    }\n}\n","name":"withdraw","className":"CheckingAccount","variables":{"FREE_WITHDRAWALS":2,"WITHDRAWAL_FEE":1,"withdrawals":2},"constants":{"1":1,"3":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void monthEnd() {\n    withdrawals = 0;\n}\n","name":"monthEnd","className":"CheckingAccount","variables":{"withdrawals":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getName":1,"nextInt":1,"weeklyPay":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Employee":1,"Employee[]":1,"int":1},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":4,"VariableDeclarationExpr":4,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":27,"StringLiteralExpr":6,"FieldAccessExpr":3,"ArrayCreationExpr":1,"AssignExpr":3,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Employee[] staff = new Employee[3];\n    staff[0] = new HourlyEmployee(\"Morgan, Harry\", 30);\n    staff[1] = new SalariedEmployee(\"Lin, Sally\", 52000);\n    staff[2] = new Manager(\"Smith, Mary\", 104000, 50);\n    Scanner in = new Scanner(System.in);\n    for (Employee e : staff) {\n        System.out.print(\"Hours worked by \" + e.getName() + \": \");\n        int hours = in.nextInt();\n        System.out.println(\"Salary: \" + e.weeklyPay(hours));\n    }\n}\n","name":"main","className":"SalaryDemo","variables":{"hours":1,"in":2,"e":3,"staff":5},"constants":{"\"Smith, Mary\"":1,"104000":1,"\": \"":1,"0":1,"1":1,"\"Lin, Sally\"":1,"52000":1,"2":1,"3":1,"\"Morgan, Harry\"":1,"\"Salary: \"":1,"50":1,"30":1,"\"Hours worked by \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","double","double"],"returnType":"Manager","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/**\n      Constructs a manager with a given name, annual salary and weekly bonus.\n      @param name the name of this employee\n      @param salary the annual salary\n      @param bonus the weekly bonus\n    */\npublic Manager(String name, double salary, double bonus) {\n    super(name, salary);\n    weeklyBonus = bonus;\n}\n","name":"Manager","className":"Manager","variables":{"bonus":1,"name":1,"weeklyBonus":1,"salary":1},"constants":{},"javaDoc":"Constructs a manager with a given name annual salary and weekly bonus name the name of this employee salary the annual salary bonus the weekly bonus","comments":"\n      Constructs a manager with a given name, annual salary and weekly bonus.\n      @param name the name of this employee\n      @param salary the annual salary\n      @param bonus the weekly bonus\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public double weeklyPay(int hoursWorked) {\n    return super.weeklyPay(hoursWorked) + weeklyBonus;\n}\n","name":"weeklyPay","className":"Manager","variables":{"weeklyBonus":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Employee","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1,"StringLiteralExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs an employee with an empty name.\n   */\npublic Employee() {\n    name = \"\";\n}\n","name":"Employee","className":"Employee","variables":{"name":1},"constants":{"\"\"":1},"javaDoc":"Constructs an employee with an empty name","comments":"\n      Constructs an employee with an empty name.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the name of this employee.\n      @param employeeName the new name \n   */\npublic void setName(String employeeName) {\n    name = employeeName;\n}\n","name":"setName","className":"Employee","variables":{"employeeName":1,"name":1},"constants":{},"javaDoc":"Sets the name of this employee employeeName the new name","comments":"\n      Sets the name of this employee.\n      @param employeeName the new name \n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the name of this employee.\n      @return the name \n   */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"Employee","variables":{"name":1},"constants":{},"javaDoc":"Gets the name of this employee the name","comments":"\n      Gets the name of this employee.\n      @return the name \n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Computes the pay for one week of work.\n      @param hoursWorked the number of hours worked in the week\n      @return the pay for the given number of hours\n   */\npublic double weeklyPay(int hoursWorked) {\n    return 0;\n}\n","name":"weeklyPay","className":"Employee","variables":{},"constants":{"0":1},"javaDoc":"Computes the pay for one week of work hoursWorked the number of hours worked in the week the pay for the given number of hours","comments":"\n      Computes the pay for one week of work.\n      @param hoursWorked the number of hours worked in the week\n      @return the pay for the given number of hours\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","double"],"returnType":"SalariedEmployee","methodCalls":{"setName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a salaried employee with a given name and annual salary.\n      @param name the name of this employee\n      @param salary the annual salary\n    */\npublic SalariedEmployee(String name, double salary) {\n    setName(name);\n    annualSalary = salary;\n}\n","name":"SalariedEmployee","className":"SalariedEmployee","variables":{"annualSalary":1,"salary":1},"constants":{},"javaDoc":"Constructs a salaried employee with a given name and annual salary name the name of this employee salary the annual salary","comments":"\n      Constructs a salaried employee with a given name and annual salary.\n      @param name the name of this employee\n      @param salary the annual salary\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public double weeklyPay(int hoursWorked) {\n    final int WEEKS_PER_YEAR = 52;\n    return annualSalary / WEEKS_PER_YEAR;\n}\n","name":"weeklyPay","className":"SalariedEmployee","variables":{"annualSalary":1,"WEEKS_PER_YEAR":2},"constants":{"52":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","double"],"returnType":"HourlyEmployee","methodCalls":{"setName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs an hourly employee with a given name and weekly wage.\n      @param name the name of this employee\n      @param wage the hourly wage \n   */\npublic HourlyEmployee(String name, double wage) {\n    setName(name);\n    hourlyWage = wage;\n}\n","name":"HourlyEmployee","className":"HourlyEmployee","variables":{"hourlyWage":1,"wage":1},"constants":{},"javaDoc":"Constructs an hourly employee with a given name and weekly wage name the name of this employee wage the hourly wage","comments":"\n      Constructs an hourly employee with a given name and weekly wage.\n      @param name the name of this employee\n      @param wage the hourly wage \n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":6,"NameExpr":8,"EnclosedExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public double weeklyPay(int hoursWorked) {\n    double pay = hoursWorked * hourlyWage;\n    if (hoursWorked > 40) {\n        // Add overtime\n        pay = pay + ((hoursWorked - 40) * 0.5) * hourlyWage;\n    }\n    return pay;\n}\n","name":"weeklyPay","className":"HourlyEmployee","variables":{"hourlyWage":2,"pay":4,"hoursWorked":3},"constants":{"0.5":1,"40":2},"javaDoc":"","comments":"Add overtime ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"setAnswer":1,"display":1,"System.out.print":1,"setText":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"Question":1,"String":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"NameExpr":29,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":7},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    Question q = new Question();\n    q.setText(\"Who was the inventor of Java?\");\n    q.setAnswer(\"James Gosling\");\n    q.display();\n    System.out.print(\"Your answer: \");\n    String response = in.nextLine();\n    System.out.println(q.checkAnswer(response));\n}\n","name":"main","className":"QuestionDemo1","variables":{"q":5,"in":2,"response":1},"constants":{"\"Who was the inventor of Java?\"":1,"\"Your answer: \"":1,"\"James Gosling\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"constants":{"\"\"":2},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":1},"constants":{},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":1},"constants":{},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":1},"constants":{},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"constants":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setAnswer":1,"addChoice":4,"presentQuestion":2,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Question":1,"ChoiceQuestion":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":4,"NameExpr":27,"StringLiteralExpr":7,"MethodCallExpr":9},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Question first = new Question();\n    first.setText(\"Who was the inventor of Java?\");\n    first.setAnswer(\"James Gosling\");\n    ChoiceQuestion second = new ChoiceQuestion();\n    second.setText(\"In which country was the inventor of Java born?\");\n    second.addChoice(\"Australia\", false);\n    second.addChoice(\"Canada\", true);\n    second.addChoice(\"Denmark\", false);\n    second.addChoice(\"United States\", false);\n    presentQuestion(first);\n    presentQuestion(second);\n}\n","name":"main","className":"QuestionDemo3","variables":{"first":3,"second":6},"constants":{"\"Who was the inventor of Java?\"":1,"\"In which country was the inventor of Java born?\"":1,"\"Denmark\"":1,"\"United States\"":1,"\"James Gosling\"":1,"false":3,"true":1,"\"Canada\"":1,"\"Australia\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Question"],"returnType":"void","methodCalls":{"checkAnswer":1,"nextLine":1,"display":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"/**\n      Presents a question to the user and checks the response.\n      @param q the question\n   */\npublic static void presentQuestion(Question q) {\n    q.display();\n    System.out.print(\"Your answer: \");\n    Scanner in = new Scanner(System.in);\n    String response = in.nextLine();\n    System.out.println(q.checkAnswer(response));\n}\n","name":"presentQuestion","className":"QuestionDemo3","variables":{"q":2,"in":2,"response":1},"constants":{"\"Your answer: \"":1},"javaDoc":"Presents a question to the user and checks the response q the question","comments":"\n      Presents a question to the user and checks the response.\n      @param q the question\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Question","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a question with empty question and answer.\n   */\npublic Question() {\n    text = \"\";\n    answer = \"\";\n}\n","name":"Question","className":"Question","variables":{"answer":1,"text":1},"constants":{"\"\"":2},"javaDoc":"Constructs a question with empty question and answer","comments":"\n      Constructs a question with empty question and answer.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the question text.\n      @param questionText the text of this question\n   */\npublic void setText(String questionText) {\n    text = questionText;\n}\n","name":"setText","className":"Question","variables":{"text":1,"questionText":1},"constants":{},"javaDoc":"Sets the question text questionText the text of this question","comments":"\n      Sets the question text.\n      @param questionText the text of this question\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Sets the answer for this question.\n      @param correctResponse the answer\n   */\npublic void setAnswer(String correctResponse) {\n    answer = correctResponse;\n}\n","name":"setAnswer","className":"Question","variables":{"answer":1,"correctResponse":1},"constants":{},"javaDoc":"Sets the answer for this question correctResponse the answer","comments":"\n      Sets the answer for this question.\n      @param correctResponse the answer\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   */\npublic boolean checkAnswer(String response) {\n    return response.equals(answer);\n}\n","name":"checkAnswer","className":"Question","variables":{"response":1},"constants":{},"javaDoc":"Checks a given response for correctness response the response to check true if the response was correct false otherwise","comments":"\n      Checks a given response for correctness.\n      @param response the response to check\n      @return true if the response was correct, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Displays this question.\n   */\npublic void display() {\n    System.out.println(text);\n}\n","name":"display","className":"Question","variables":{},"constants":{},"javaDoc":"Displays this question","comments":"\n      Displays this question.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ChoiceQuestion","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n      Constructs a choice question with no choices.\n   */\npublic ChoiceQuestion() {\n    choices = new ArrayList<String>();\n}\n","name":"ChoiceQuestion","className":"ChoiceQuestion","variables":{"choices":1},"constants":{},"javaDoc":"Constructs a choice question with no choices","comments":"\n      Constructs a choice question with no choices.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","boolean"],"returnType":"void","methodCalls":{"add":1,"size":1,"setAnswer":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   */\npublic void addChoice(String choice, boolean correct) {\n    choices.add(choice);\n    if (correct) {\n        // Convert choices.size() to string\n        String choiceString = \"\" + choices.size();\n        setAnswer(choiceString);\n    }\n}\n","name":"addChoice","className":"ChoiceQuestion","variables":{"correct":1,"choiceString":1,"choices":2},"constants":{"\"\"":1},"javaDoc":"Adds an answer choice to this question choice the choice to add correct true if this is the correct choice false otherwise","comments":"Convert choices size() to string \n      Adds an answer choice to this question.\n      @param choice the choice to add\n      @param correct true if this is the correct choice, false otherwise\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"SuperExpr":1,"BinaryExpr":4,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public void display() {\n    // Display the question text\n    super.display();\n    // Display the answer choices\n    for (int i = 0; i < choices.size(); i++) {\n        int choiceNumber = i + 1;\n        System.out.println(choiceNumber + \": \" + choices.get(i));\n    }\n}\n","name":"display","className":"ChoiceQuestion","variables":{"choiceNumber":2,"i":4,"choices":2},"constants":{"0":1,"1":1,"\": \"":1},"javaDoc":"","comments":"Display the question text Display the answer choices ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ArrayList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":3,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n      Constructs an empty array list.\n   */\npublic ArrayList() {\n    final int INITIAL_SIZE = 10;\n    elements = new Object[INITIAL_SIZE];\n    currentSize = 0;\n}\n","name":"ArrayList","className":"ArrayList","variables":{"INITIAL_SIZE":2,"elements":1,"currentSize":1},"constants":{"0":1,"10":1},"javaDoc":"Constructs an empty array list","comments":"\n      Constructs an empty array list.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the size of this array list.\n      @return the size\n   */\npublic int size() {\n    return currentSize;\n}\n","name":"size","className":"ArrayList","variables":{"currentSize":1},"constants":{},"javaDoc":"Gets the size of this array list the size","comments":"\n      Gets the size of this array list.\n      @return the size\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":3,"NameExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1},"text":"/**\n      Throws an IndexOutOfBoundsException if the checked index is out of bounds\n      @param n the index to check\n   */\nprivate void checkBounds(int n) {\n    if (n < 0 || n >= currentSize) {\n        throw new IndexOutOfBoundsException();\n    }\n}\n","name":"checkBounds","className":"ArrayList","variables":{"n":2,"currentSize":1},"constants":{"0":1},"javaDoc":"Throws an IndexOutOfBoundsException if the checked index is out of bounds n the index to check","comments":"\n      Throws an IndexOutOfBoundsException if the checked index is out of bounds\n      @param n the index to check\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"checkBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n      Gets the element at a given position.\n      @param pos the position\n      @return the element at pos\n   */\npublic Object get(int pos) {\n    checkBounds(pos);\n    return elements[pos];\n}\n","name":"get","className":"ArrayList","variables":{"pos":1,"elements":1},"constants":{},"javaDoc":"Gets the element at a given position pos the position the element at pos","comments":"\n      Gets the element at a given position.\n      @param pos the position\n      @return the element at pos\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"checkBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":6,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n      Sets the element at a given position.\n      @param pos the position\n      @param element the new value\n   */\npublic void set(int pos, Object element) {\n    checkBounds(pos);\n    elements[pos] = element;\n}\n","name":"set","className":"ArrayList","variables":{"pos":1,"elements":1,"element":1},"constants":{},"javaDoc":"Sets the element at a given position pos the position element the new value","comments":"\n      Sets the element at a given position.\n      @param pos the position\n      @param element the new value\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"checkBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":15,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Removes the element at a given position.\n      @param pos the position\n      @return the removed element\n   */\npublic Object remove(int pos) {\n    checkBounds(pos);\n    Object removed = elements[pos];\n    for (int i = pos + 1; i < currentSize; i++) {\n        elements[i - 1] = elements[i];\n    }\n    currentSize--;\n    return removed;\n}\n","name":"remove","className":"ArrayList","variables":{"removed":2,"pos":2,"elements":3,"i":5,"currentSize":2},"constants":{"1":2},"javaDoc":"Removes the element at a given position pos the position the removed element","comments":"\n      Removes the element at a given position.\n      @param pos the position\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"boolean","methodCalls":{"checkBounds":1,"growIfNecessary":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":3,"BooleanLiteralExpr":1,"NameExpr":17,"UnaryExpr":2,"MethodCallExpr":2,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n      Adds an element after a given position.\n      @param pos the position\n      @param newElement the element to add\n   */\npublic boolean add(int pos, Object newElement) {\n    growIfNecessary();\n    currentSize++;\n    checkBounds(pos);\n    for (int i = currentSize - 1; i > pos; i--) {\n        elements[i] = elements[i - 1];\n    }\n    elements[pos] = newElement;\n    return true;\n}\n","name":"add","className":"ArrayList","variables":{"pos":2,"elements":3,"i":5,"newElement":1,"currentSize":2},"constants":{"1":2,"true":1},"javaDoc":"Adds an element after a given position pos the position newElement the element to add","comments":"\n      Adds an element after a given position.\n      @param pos the position\n      @param newElement the element to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"growIfNecessary":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Adds an element after the end of the array list\n      @param newElement the element to add\n   */\npublic boolean addLast(Object newElement) {\n    growIfNecessary();\n    currentSize++;\n    elements[currentSize - 1] = newElement;\n    return true;\n}\n","name":"addLast","className":"ArrayList","variables":{"elements":1,"newElement":1,"currentSize":2},"constants":{"1":1,"true":1},"javaDoc":"Adds an element after the end of the array list newElement the element to add","comments":"\n      Adds an element after the end of the array list\n      @param newElement the element to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object[]":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":18,"FieldAccessExpr":3,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"/**\n      Grows the elements array if the current size equals the capacity.\n   */\nprivate void growIfNecessary() {\n    if (currentSize == elements.length) {\n        Object[] newElements = new Object[2 * elements.length];\n        for (int i = 0; i < elements.length; i++) {\n            newElements[i] = elements[i];\n        }\n        elements = newElements;\n    }\n}\n","name":"growIfNecessary","className":"ArrayList","variables":{"elements":2,"i":5,"newElements":3,"currentSize":1},"constants":{"0":1,"2":1},"javaDoc":"Grows the elements array if the current size equals the capacity","comments":"\n      Grows the elements array if the current size equals the capacity.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"addLast":3,"size":1,"get":1,"remove":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArrayList":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":32,"StringLiteralExpr":4,"FieldAccessExpr":1,"UnaryExpr":2,"MethodCallExpr":8},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    ArrayList staff = new ArrayList();\n    staff.addLast(\"Diana\");\n    staff.addLast(\"Harry\");\n    for (int i = 1; i <= 10; i++) {\n        staff.addLast(\"Tom\" + i);\n    }\n    staff.add(0, \"Juliet\");\n    staff.remove(1);\n    for (int i = 0; i < staff.size(); i++) {\n        System.out.println(staff.get(i));\n    }\n}\n","name":"main","className":"ArrayListDemo","variables":{"i":7,"staff":8},"constants":{"0":2,"1":2,"\"Tom\"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"CircularArrayQueue","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"NameExpr":5,"ArrayCreationExpr":1,"AssignExpr":4},"statements":{"ExpressionStmt":5},"text":"/**\n      Constructs an empty queue.\n   */\npublic CircularArrayQueue() {\n    final int INITIAL_SIZE = 10;\n    elements = new Object[INITIAL_SIZE];\n    currentSize = 0;\n    head = 0;\n    tail = 0;\n}\n","name":"CircularArrayQueue","className":"CircularArrayQueue","variables":{"head":1,"INITIAL_SIZE":2,"tail":1,"elements":1,"currentSize":1},"constants":{"0":3,"10":1},"javaDoc":"Constructs an empty queue","comments":"\n      Constructs an empty queue.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this queue is empty.\n      @return true if this queue is empty\n   */\npublic boolean empty() {\n    return currentSize == 0;\n}\n","name":"empty","className":"CircularArrayQueue","variables":{"currentSize":1},"constants":{"0":1},"javaDoc":"Checks whether this queue is empty true if this queue is empty","comments":"\n      Checks whether this queue is empty.\n      @return true if this queue is empty\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"growIfNecessary":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":11,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":4},"text":"/**\n      Adds an element to the tail of this queue.\n      @param newElement the element to add\n   */\npublic void add(Object newElement) {\n    growIfNecessary();\n    currentSize++;\n    elements[tail] = newElement;\n    tail = (tail + 1) % elements.length;\n}\n","name":"add","className":"CircularArrayQueue","variables":{"tail":3,"elements":1,"newElement":1,"currentSize":1},"constants":{"1":1},"javaDoc":"Adds an element to the tail of this queue newElement the element to add","comments":"\n      Adds an element to the tail of this queue.\n      @param newElement the element to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":10,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n      Removes an element from the head of this queue.\n      @return the removed element\n   */\npublic Object remove() {\n    if (currentSize == 0) {\n        throw new NoSuchElementException();\n    }\n    Object removed = elements[head];\n    head = (head + 1) % elements.length;\n    currentSize--;\n    return removed;\n}\n","name":"remove","className":"CircularArrayQueue","variables":{"head":3,"removed":2,"elements":1,"currentSize":2},"constants":{"0":1,"1":1},"javaDoc":"Removes an element from the head of this queue the removed element","comments":"\n      Removes an element from the head of this queue.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object[]":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":25,"FieldAccessExpr":4,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n      Grows the element array if the current size equals the capacity.\n   */\nprivate void growIfNecessary() {\n    if (currentSize == elements.length) {\n        Object[] newElements = new Object[2 * elements.length];\n        for (int i = 0; i < elements.length; i++) {\n            newElements[i] = elements[(head + i) % elements.length];\n        }\n        elements = newElements;\n        head = 0;\n        tail = currentSize;\n    }\n}\n","name":"growIfNecessary","className":"CircularArrayQueue","variables":{"head":2,"tail":1,"elements":2,"i":5,"newElements":3,"currentSize":2},"constants":{"0":2,"2":1},"javaDoc":"Grows the element array if the current size equals the capacity","comments":"\n      Grows the element array if the current size equals the capacity.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"remove":1,"empty":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"CircularArrayQueue":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    CircularArrayQueue q = new CircularArrayQueue();\n    q.add(\"Tom\");\n    q.add(\"Diana\");\n    q.add(\"Harry\");\n    while (!q.empty()) {\n        System.out.println(q.remove());\n    }\n}\n","name":"main","className":"QueueDemo","variables":{"q":6},"constants":{"\"Tom\"":1,"\"Diana\"":1,"\"Harry\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":4,"add":2,"addLast":4,"previous":1,"listIterator":2,"hasNext":1,"remove":1,"System.out.print":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"ListIterator":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":66,"StringLiteralExpr":7,"FieldAccessExpr":4,"MethodCallExpr":19,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    LinkedList staff = new LinkedList();\n    staff.addLast(\"Diana\");\n    staff.addLast(\"Harry\");\n    staff.addLast(\"Romeo\");\n    staff.addLast(\"Tom\");\n    // | in the comments indicates the iterator position\n    // |DHRT\n    ListIterator iterator = staff.listIterator();\n    // D|HRT\n    iterator.next();\n    // DH|RT\n    iterator.next();\n    // Add more elements after second element\n    // DHJ|RT\n    iterator.add(\"Juliet\");\n    // DHJN|RT\n    iterator.add(\"Nina\");\n    // DHJNR|T\n    System.out.println(iterator.next());\n    // DHJN|RT\n    System.out.println(iterator.previous());\n    // Remove last traversed element \n    // DHJN|T\n    iterator.remove();\n    // Print all elements\n    iterator = staff.listIterator();\n    while (iterator.hasNext()) {\n        System.out.print(iterator.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"ListDemo","variables":{"iterator":11,"staff":7},"constants":{"\"Nina\"":1,"\"Tom\"":1,"\" \"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Romeo\"":1},"javaDoc":"","comments":"| in the comments indicates the iterator position Add more elements after second element Remove last traversed element Print all elements |DHRT D|HRT DH|RT DHJ|RT DHJN|RT DHJNR|T DHJN|RT DHJN|T ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Moves the iterator past the next element.\n      @return the traversed element\n   */\nObject next();\n","name":"next","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n      Moves the iterator past the next element.\n      @return the traversed element\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   */\nboolean hasNext();\n","name":"hasNext","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Moves the iterator after the previous element.\n      @return the traversed element\n   */\nObject previous();\n","name":"previous","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Moves the iterator after the previous element the traversed element","comments":"\n      Moves the iterator after the previous element.\n      @return the traversed element\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Tests if there is an element before the iterator position.\n      @return true if there is an element before the iterator position\n   */\nboolean hasPrevious();\n","name":"hasPrevious","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Tests if there is an element before the iterator position true if there is an element before the iterator position","comments":"\n      Tests if there is an element before the iterator position.\n      @return true if there is an element before the iterator position\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   */\nvoid add(Object element);\n","name":"add","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   */\nvoid remove();\n","name":"remove","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   */\nvoid set(Object element);\n","name":"set","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"LinkedList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n      Constructs an empty linked list.\n   */\npublic LinkedList() {\n    first = null;\n    last = null;\n}\n","name":"LinkedList","className":"LinkedList","variables":{"last":1,"first":1},"constants":{"null":2},"javaDoc":"Constructs an empty linked list","comments":" \n      Constructs an empty linked list.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"/**\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   */\npublic Object getFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    return first.data;\n}\n","name":"getFirst","className":"LinkedList","variables":{"first":1},"constants":{"null":1},"javaDoc":"Returns the first element in the linked list the first element in the linked list","comments":"\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"NullLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":14,"FieldAccessExpr":3,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Removes the first element in the linked list.\n      @return the removed element\n   */\npublic Object removeFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    if (// List is now empty\n    first == null) // List is now empty\n    {\n        last = null;\n    } else {\n        first.previous = null;\n    }\n    return element;\n}\n","name":"removeFirst","className":"LinkedList","variables":{"last":1,"first":3,"element":2},"constants":{"null":4},"javaDoc":"Removes the first element in the linked list the removed element","comments":"List is now empty List is now empty \n      Removes the first element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"FieldAccessExpr":4,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   */\npublic void addFirst(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    newNode.previous = null;\n    if (first == null) {\n        last = newNode;\n    } else {\n        first.previous = newNode;\n    }\n    first = newNode;\n}\n","name":"addFirst","className":"LinkedList","variables":{"last":1,"newNode":4,"first":3,"element":1},"constants":{"null":2},"javaDoc":"Adds an element to the front of the linked list element the element to add","comments":"\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"/**\n      Returns the last element in the linked list.\n      @return the last element in the linked list\n   */\npublic Object getLast() {\n    if (last == null) {\n        throw new NoSuchElementException();\n    }\n    return last.data;\n}\n","name":"getLast","className":"LinkedList","variables":{"last":1},"constants":{"null":1},"javaDoc":"Returns the last element in the linked list the last element in the linked list","comments":"\n      Returns the last element in the linked list.\n      @return the last element in the linked list\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"NullLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":14,"FieldAccessExpr":3,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n      Removes the last element in the linked list.\n      @return the removed element\n   */\npublic Object removeLast() {\n    if (last == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = last.data;\n    last = last.previous;\n    if (// List is now empty\n    last == null) // List is now empty\n    {\n        first = null;\n    } else {\n        last.next = null;\n    }\n    return element;\n}\n","name":"removeLast","className":"LinkedList","variables":{"last":3,"first":1,"element":2},"constants":{"null":4},"javaDoc":"Removes the last element in the linked list the removed element","comments":"List is now empty List is now empty \n      Removes the last element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"FieldAccessExpr":4,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n      Adds an element to the back of the linked list.\n      @param element the element to add\n   */\npublic void addLast(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = null;\n    newNode.previous = last;\n    if (last == null) {\n        first = newNode;\n    } else {\n        last.next = newNode;\n    }\n    last = newNode;\n}\n","name":"addLast","className":"LinkedList","variables":{"last":3,"newNode":4,"first":1,"element":1},"constants":{"null":2},"javaDoc":"Adds an element to the back of the linked list element the element to add","comments":"\n      Adds an element to the back of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   */\npublic ListIterator listIterator() {\n    return new LinkedListIterator();\n}\n","name":"listIterator","className":"LinkedList","variables":{},"constants":{},"javaDoc":"Returns an iterator for iterating through this list an iterator for iterating through this list","comments":"\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"LinkedListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BooleanLiteralExpr":2,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n         Constructs an iterator that points to the front\n         of the linked list.\n      */\npublic LinkedListIterator() {\n    position = null;\n    isAfterNext = false;\n    isAfterPrevious = false;\n}\n","name":"LinkedListIterator","className":"LinkedListIterator","variables":{"isAfterPrevious":1,"position":1,"isAfterNext":1},"constants":{"null":1,"false":2},"javaDoc":"Constructs an iterator that points to the front of the linked list","comments":"\n         Constructs an iterator that points to the front\n         of the linked list.\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"BooleanLiteralExpr":2,"BinaryExpr":1,"NameExpr":14,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":4},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n         Moves the iterator past the next element.\n         @return the traversed element\n      */\npublic Object next() {\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    isAfterNext = true;\n    isAfterPrevious = false;\n    if (position == null) {\n        position = first;\n    } else {\n        position = position.next;\n    }\n    return position.data;\n}\n","name":"next","className":"LinkedListIterator","variables":{"isAfterPrevious":1,"position":3,"first":1,"isAfterNext":1},"constants":{"null":1,"true":1,"false":1},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n         Moves the iterator past the next element.\n         @return the traversed element\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"BinaryExpr":3,"NameExpr":5,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      */\npublic boolean hasNext() {\n    if (position == null) {\n        return first != null;\n    } else {\n        return position.next != null;\n    }\n}\n","name":"hasNext","className":"LinkedListIterator","variables":{"position":1,"first":1},"constants":{"null":3},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasPrevious":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":2,"NameExpr":12,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n         Moves the iterator before the previous element.\n         @return the traversed element\n      */\npublic Object previous() {\n    if (!hasPrevious()) {\n        throw new NoSuchElementException();\n    }\n    isAfterNext = false;\n    isAfterPrevious = true;\n    Object result = position.data;\n    position = position.previous;\n    return result;\n}\n","name":"previous","className":"LinkedListIterator","variables":{"result":2,"isAfterPrevious":1,"position":1,"isAfterNext":1},"constants":{"false":1,"true":1},"javaDoc":"Moves the iterator before the previous element the traversed element","comments":"\n         Moves the iterator before the previous element.\n         @return the traversed element\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n         Tests if there is an element before the iterator position.\n         @return true if there is an element before the iterator position\n      */\npublic boolean hasPrevious() {\n    return position != null;\n}\n","name":"hasPrevious","className":"LinkedListIterator","variables":{"position":1},"constants":{"null":1},"javaDoc":"Tests if there is an element before the iterator position true if there is an element before the iterator position","comments":"\n         Tests if there is an element before the iterator position.\n         @return true if there is an element before the iterator position\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"addLast":1,"addFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":41,"FieldAccessExpr":7,"MethodCallExpr":2,"AssignExpr":10},"statements":{"IfStmt":2,"BlockStmt":3,"ExpressionStmt":13},"text":"/**\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      */\npublic void add(Object element) {\n    if (position == null) {\n        addFirst(element);\n        position = first;\n    } else if (position == last) {\n        addLast(element);\n        position = last;\n    } else {\n        Node newNode = new Node();\n        newNode.data = element;\n        newNode.next = position.next;\n        newNode.next.previous = newNode;\n        position.next = newNode;\n        newNode.previous = position;\n        position = newNode;\n    }\n    isAfterNext = false;\n    isAfterPrevious = false;\n}\n","name":"add","className":"LinkedListIterator","variables":{"last":2,"isAfterPrevious":1,"newNode":4,"position":6,"first":1,"element":1,"isAfterNext":1},"constants":{"null":1,"false":2},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeFirst":1,"lastPosition":1,"removeLast":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":33,"FieldAccessExpr":7,"MethodCallExpr":3,"AssignExpr":5},"statements":{"IfStmt":3,"BlockStmt":4,"ExpressionStmt":8},"text":"/**\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      */\npublic void remove() {\n    Node positionToRemove = lastPosition();\n    if (positionToRemove == first) {\n        removeFirst();\n    } else if (positionToRemove == last) {\n        removeLast();\n    } else {\n        positionToRemove.previous.next = positionToRemove.next;\n        positionToRemove.next.previous = positionToRemove.previous;\n    }\n    if (isAfterNext) {\n        position = position.previous;\n    }\n    isAfterNext = false;\n    isAfterPrevious = false;\n}\n","name":"remove","className":"LinkedListIterator","variables":{"last":1,"isAfterPrevious":1,"position":1,"positionToRemove":3,"first":1,"isAfterNext":2},"constants":{"false":2},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"lastPosition":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      */\npublic void set(Object element) {\n    Node positionToSet = lastPosition();\n    positionToSet.data = element;\n}\n","name":"set","className":"LinkedListIterator","variables":{"positionToSet":1,"element":1},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Node","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":8,"FieldAccessExpr":1},"statements":{"IfStmt":3,"BlockStmt":5,"ReturnStmt":3,"ThrowStmt":1},"text":"/**\n         Returns the last node traversed by this iterator, or\n         throws an IllegalStateException if there wasn't an immediately\n         preceding call to next or previous.\n         @return the last traversed node\n      */\nprivate Node lastPosition() {\n    if (isAfterNext) {\n        return position;\n    } else if (isAfterPrevious) {\n        if (position == null) {\n            return first;\n        } else {\n            return position.next;\n        }\n    } else {\n        throw new IllegalStateException();\n    }\n}\n","name":"lastPosition","className":"LinkedListIterator","variables":{"isAfterPrevious":1,"position":2,"first":1,"isAfterNext":1},"constants":{"null":1},"javaDoc":"Returns the last node traversed by this iterator or throws an IllegalStateException if there wasn't an immediately preceding call to next or previous the last traversed node","comments":"\n         Returns the last node traversed by this iterator, or\n         throws an IllegalStateException if there wasn't an immediately\n         preceding call to next or previous.\n         @return the last traversed node\n      ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":17,"add":3,"addLast":19,"set":4,"previous":8,"removeFirst":2,"listIterator":4,"assertEquals":29,"check":27,"removeLast":2,"addFirst":2,"remove":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"ListIterator":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":7,"VariableDeclarationExpr":2,"NameExpr":349,"StringLiteralExpr":111,"MethodCallExpr":123,"AssignExpr":9},"statements":{"ExpressionStmt":101},"text":"public static void main(String[] args) {\n    LinkedList lst = new LinkedList();\n    check(\"\", lst, \"Constructing empty list\");\n    lst.addLast(\"A\");\n    check(\"A\", lst, \"Adding last to empty list\");\n    lst.addLast(\"B\");\n    check(\"AB\", lst, \"Adding last to non-empty list\");\n    lst = new LinkedList();\n    lst.addFirst(\"A\");\n    check(\"A\", lst, \"Adding first to empty list\");\n    lst.addFirst(\"B\");\n    check(\"BA\", lst, \"Adding first to non-empty list\");\n    assertEquals(\"B\", lst.removeFirst());\n    check(\"A\", lst, \"Removing first, yielding non-empty list\");\n    assertEquals(\"A\", lst.removeFirst());\n    check(\"\", lst, \"Removing first, yielding empty list\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    check(\"AB\", lst, \"\");\n    assertEquals(\"B\", lst.removeLast());\n    check(\"A\", lst, \"Removing last, yielding non-empty list\");\n    assertEquals(\"A\", lst.removeLast());\n    check(\"\", lst, \"Removing last, yielding empty list\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    check(\"ABC\", lst, \"\");\n    ListIterator iter = lst.listIterator();\n    assertEquals(\"A\", iter.next());\n    iter.set(\"D\");\n    check(\"DBC\", lst, \"Set element after next\");\n    assertEquals(\"D\", iter.previous());\n    iter.set(\"E\");\n    check(\"EBC\", lst, \"Set first element after previous\");\n    assertEquals(\"E\", iter.next());\n    assertEquals(\"B\", iter.next());\n    assertEquals(\"B\", iter.previous());\n    iter.set(\"F\");\n    check(\"EFC\", lst, \"Set second element after previous\");\n    assertEquals(\"F\", iter.next());\n    assertEquals(\"C\", iter.next());\n    assertEquals(\"C\", iter.previous());\n    iter.set(\"G\");\n    check(\"EFG\", lst, \"Set last element after previous\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    lst.addLast(\"D\");\n    lst.addLast(\"E\");\n    check(\"ABCDE\", lst, \"\");\n    iter = lst.listIterator();\n    assertEquals(\"A\", iter.next());\n    iter.remove();\n    check(\"BCDE\", lst, \"Remove first element after next\");\n    assertEquals(\"B\", iter.next());\n    assertEquals(\"C\", iter.next());\n    iter.remove();\n    check(\"BDE\", lst, \"Remove middle element after next\");\n    assertEquals(\"D\", iter.next());\n    assertEquals(\"E\", iter.next());\n    iter.remove();\n    check(\"BD\", lst, \"Remove last element after next\");\n    lst = new LinkedList();\n    lst.addLast(\"A\");\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    lst.addLast(\"D\");\n    lst.addLast(\"E\");\n    check(\"ABCDE\", lst, \"\");\n    iter = lst.listIterator();\n    assertEquals(\"A\", iter.next());\n    assertEquals(\"B\", iter.next());\n    assertEquals(\"C\", iter.next());\n    assertEquals(\"D\", iter.next());\n    assertEquals(\"E\", iter.next());\n    assertEquals(\"E\", iter.previous());\n    iter.remove();\n    check(\"ABCD\", lst, \"Remove last element after previous\");\n    assertEquals(\"D\", iter.previous());\n    assertEquals(\"C\", iter.previous());\n    iter.remove();\n    check(\"ABD\", lst, \"Remove middle element after previous\");\n    assertEquals(\"B\", iter.previous());\n    assertEquals(\"A\", iter.previous());\n    iter.remove();\n    check(\"BD\", lst, \"Remove first element after previous\");\n    lst = new LinkedList();\n    lst.addLast(\"B\");\n    lst.addLast(\"C\");\n    check(\"BC\", lst, \"\");\n    iter = lst.listIterator();\n    iter.add(\"A\");\n    check(\"ABC\", lst, \"Add first element\");\n    assertEquals(\"B\", iter.next());\n    iter.add(\"D\");\n    check(\"ABDC\", lst, \"Add middle element\");\n    assertEquals(\"C\", iter.next());\n    iter.add(\"E\");\n    check(\"ABDCE\", lst, \"Add last element\");\n}\n","name":"main","className":"LinkedListTest","variables":{"iter":42,"lst":36},"constants":{"\"\"":8,"\"D\"":8,"\"Add first element\"":1,"\"EBC\"":1,"\"EFG\"":1,"\"B\"":15,"\"Adding first to non-empty list\"":1,"\"Adding last to non-empty list\"":1,"\"ABCD\"":1,"\"Removing last, yielding non-empty list\"":1,"\"BC\"":1,"\"Adding last to empty list\"":1,"\"Set second element after previous\"":1,"\"Removing first, yielding non-empty list\"":1,"\"Constructing empty list\"":1,"\"Removing first, yielding empty list\"":1,"\"ABDC\"":1,"\"Remove last element after next\"":1,"\"ABD\"":1,"\"G\"":1,"\"Add middle element\"":1,"\"E\"":8,"\"BDE\"":1,"\"DBC\"":1,"\"Remove middle element after previous\"":1,"\"C\"":10,"\"ABCDE\"":2,"\"A\"":17,"\"Removing last, yielding empty list\"":1,"\"Adding first to empty list\"":1,"\"Set element after next\"":1,"\"Set last element after previous\"":1,"\"Remove last element after previous\"":1,"\"BD\"":2,"\"AB\"":2,"\"Set first element after previous\"":1,"\"BA\"":1,"\"Remove first element after next\"":1,"\"BCDE\"":1,"\"Remove middle element after next\"":1,"\"Remove first element after previous\"":1,"\"Add last element\"":1,"\"EFC\"":1,"\"F\"":2,"\"ABC\"":2,"\"ABDCE\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object","Object"],"returnType":"void","methodCalls":{"equals":1},"annotations":[],"exceptions":["AssertionError"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"BinaryExpr":7,"NameExpr":8,"StringLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1},"text":"/**\n      Checks whether two objects are equal and throws an exception if not.\n      @param expected the expected value\n      @param actual the actual value\n   */\npublic static void assertEquals(Object expected, Object actual) {\n    if (expected == null && actual != null || !expected.equals(actual)) {\n        throw new AssertionError(\"Expected \" + expected + \" but found \" + actual);\n    }\n}\n","name":"assertEquals","className":"LinkedListTest","variables":{"actual":2,"expected":3},"constants":{"null":2,"\"Expected \"":1,"\" but found \"":1},"javaDoc":"Checks whether two objects are equal and throws an exception if not expected the expected value actual the actual value","comments":"\n      Checks whether two objects are equal and throws an exception if not.\n      @param expected the expected value\n      @param actual the actual value\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","LinkedList","String"],"returnType":"void","methodCalls":{"next":1,"previous":1,"getFirst":2,"length":2,"listIterator":1,"hasPrevious":2,"assertEquals":8,"hasNext":2,"getLast":2,"substring":4,"System.out.println":1},"annotations":[],"exceptions":["IllegalStateException","NoSuchElementException"],"concepts":["ExceptionHandling"],"types":{"ListIterator":1,"int":3},"expressions":{"IntegerLiteralExpr":10,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":10,"BooleanLiteralExpr":4,"NameExpr":85,"StringLiteralExpr":4,"FieldAccessExpr":1,"UnaryExpr":2,"MethodCallExpr":26},"statements":{"IfStmt":2,"BlockStmt":9,"TryStmt":2,"ForStmt":2,"ThrowStmt":2,"ExpressionStmt":13},"text":"/**\n      Checks whether a linked list has the expected contents, and throws\n      an exception if not.\n      @param expected the letters that are expected in each node\n      @param actual the linked list\n      @param what a string explaining what has been tested. It is \n      included in the message that is displayed when the test passes.\n   */\npublic static void check(String expected, LinkedList actual, String what) {\n    int n = expected.length();\n    if (n > 0) {\n        // Check first and last reference       \n        assertEquals(expected.substring(0, 1), actual.getFirst());\n        assertEquals(expected.substring(n - 1), actual.getLast());\n        // Check next references\n        ListIterator iter = actual.listIterator();\n        for (int i = 0; i < n; i++) {\n            assertEquals(true, iter.hasNext());\n            assertEquals(expected.substring(i, i + 1), iter.next());\n        }\n        assertEquals(false, iter.hasNext());\n        // Check previous references\n        for (int i = n - 1; i >= 0; i--) {\n            assertEquals(true, iter.hasPrevious());\n            assertEquals(expected.substring(i, i + 1), iter.previous());\n        }\n        assertEquals(false, iter.hasPrevious());\n    } else {\n        // Check that first and last are null\n        try {\n            actual.getFirst();\n            throw new IllegalStateException(\"first not null\");\n        } catch (NoSuchElementException ex) {\n        }\n        try {\n            actual.getLast();\n            throw new IllegalStateException(\"last not null\");\n        } catch (NoSuchElementException ex) {\n        }\n    }\n    if (what.length() > 0) {\n        System.out.println(\"Passed \\\"\" + what + \"\\\".\");\n    }\n}\n","name":"check","className":"LinkedListTest","variables":{"actual":5,"ex":2,"what":2,"expected":5,"iter":7,"i":8,"n":5},"constants":{"0":5,"1":5,"\"Passed \\\"\"":1,"\"last not null\"":1,"\"\\\".\"":1,"true":2,"false":2,"\"first not null\"":1},"javaDoc":"Checks whether a linked list has the expected contents and throws an exception if not expected the letters that are expected in each node actual the linked list what a string explaining what has been tested It is included in the message that is displayed when the test passes","comments":"Check first and last reference Check next references Check previous references Check that first and last are null \n      Checks whether a linked list has the expected contents, and throws\n      an exception if not.\n      @param expected the letters that are expected in each node\n      @param actual the linked list\n      @param what a string explaining what has been tested. It is \n      included in the message that is displayed when the test passes.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":4,"add":2,"listIterator":2,"hasNext":1,"addFirst":4,"remove":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ListIterator":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":53,"StringLiteralExpr":7,"FieldAccessExpr":2,"MethodCallExpr":16,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    LinkedList staff = new LinkedList();\n    staff.addFirst(\"Tom\");\n    staff.addFirst(\"Romeo\");\n    staff.addFirst(\"Harry\");\n    staff.addFirst(\"Diana\");\n    // | in the comments indicates the iterator position\n    // |DHRT\n    ListIterator iterator = staff.listIterator();\n    // D|HRT\n    iterator.next();\n    // DH|RT\n    iterator.next();\n    // Add more elements after second element\n    // DHJ|RT\n    iterator.add(\"Juliet\");\n    // DHJN|RT\n    iterator.add(\"Nina\");\n    // DHJNR|T\n    iterator.next();\n    // Remove last traversed element \n    // DHJN|T\n    iterator.remove();\n    // Print all elements\n    iterator = staff.listIterator();\n    while (iterator.hasNext()) {\n        System.out.print(iterator.next() + \" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"ListDemo","variables":{"iterator":10,"staff":7},"constants":{"\"Nina\"":1,"\"Tom\"":1,"\" \"":1,"\"Juliet\"":1,"\"Diana\"":1,"\"Harry\"":1,"\"Romeo\"":1},"javaDoc":"","comments":"| in the comments indicates the iterator position Add more elements after second element Remove last traversed element Print all elements |DHRT D|HRT DH|RT DHJ|RT DHJN|RT DHJNR|T DHJN|T ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Moves the iterator past the next element.\n      @return the traversed element\n   */\nObject next();\n","name":"next","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"\n      Moves the iterator past the next element.\n      @return the traversed element\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   */\nboolean hasNext();\n","name":"hasNext","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n      Tests if there is an element after the iterator position.\n      @return true if there is an element after the iterator position\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   */\nvoid add(Object element);\n","name":"add","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n      Adds an element before the iterator position\n      and moves the iterator past the inserted element.\n      @param element the element to add\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   */\nvoid remove();\n","name":"remove","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n      Removes the last traversed element. This method may\n      only be called after a call to the next() method.\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   */\nvoid set(Object element);\n","name":"set","className":"ListIterator","variables":{},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n      Sets the last traversed element to a different value. \n      @param element the element to set\n   ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"LinkedList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Constructs an empty linked list.\n   */\npublic LinkedList() {\n    first = null;\n}\n","name":"LinkedList","className":"LinkedList","variables":{"first":1},"constants":{"null":1},"javaDoc":"Constructs an empty linked list","comments":" \n      Constructs an empty linked list.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"/**\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   */\npublic Object getFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    return first.data;\n}\n","name":"getFirst","className":"LinkedList","variables":{"first":1},"constants":{"null":1},"javaDoc":"Returns the first element in the linked list the first element in the linked list","comments":"\n      Returns the first element in the linked list.\n      @return the first element in the linked list\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Removes the first element in the linked list.\n      @return the removed element\n   */\npublic Object removeFirst() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    return element;\n}\n","name":"removeFirst","className":"LinkedList","variables":{"first":2,"element":2},"constants":{"null":1},"javaDoc":"Removes the first element in the linked list the removed element","comments":"\n      Removes the first element in the linked list.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":10,"FieldAccessExpr":2,"AssignExpr":3},"statements":{"ExpressionStmt":4},"text":"/**\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   */\npublic void addFirst(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    first = newNode;\n}\n","name":"addFirst","className":"LinkedList","variables":{"newNode":2,"first":2,"element":1},"constants":{},"javaDoc":"Adds an element to the front of the linked list element the element to add","comments":"\n      Adds an element to the front of the linked list.\n      @param element the element to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   */\npublic ListIterator listIterator() {\n    return new LinkedListIterator();\n}\n","name":"listIterator","className":"LinkedList","variables":{},"constants":{},"javaDoc":"Returns an iterator for iterating through this list an iterator for iterating through this list","comments":"\n      Returns an iterator for iterating through this list.\n      @return an iterator for iterating through this list\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"LinkedListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BooleanLiteralExpr":1,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n         Constructs an iterator that points to the front\n         of the linked list.\n      */\npublic LinkedListIterator() {\n    position = null;\n    previous = null;\n    isAfterNext = false;\n}\n","name":"LinkedListIterator","className":"LinkedListIterator","variables":{"previous":1,"position":1,"isAfterNext":1},"constants":{"null":2,"false":1},"javaDoc":"Constructs an iterator that points to the front of the linked list","comments":"\n         Constructs an iterator that points to the front\n         of the linked list.\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":15,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":4},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n         Moves the iterator past the next element.\n         @return the traversed element\n      */\npublic Object next() {\n    if (!hasNext()) {\n        throw new NoSuchElementException();\n    }\n    // Remember for remove\n    previous = position;\n    isAfterNext = true;\n    if (position == null) {\n        position = first;\n    } else {\n        position = position.next;\n    }\n    return position.data;\n}\n","name":"next","className":"LinkedListIterator","variables":{"previous":1,"position":4,"first":1,"isAfterNext":1},"constants":{"null":1,"true":1},"javaDoc":"Moves the iterator past the next element the traversed element","comments":"Remember for remove \n         Moves the iterator past the next element.\n         @return the traversed element\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"BinaryExpr":3,"NameExpr":5,"FieldAccessExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/**\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      */\npublic boolean hasNext() {\n    if (position == null) {\n        return first != null;\n    } else {\n        return position.next != null;\n    }\n}\n","name":"hasNext","className":"LinkedListIterator","variables":{"position":1,"first":1},"constants":{"null":3},"javaDoc":"Tests if there is an element after the iterator position true if there is an element after the iterator position","comments":"\n         Tests if there is an element after the iterator position.\n         @return true if there is an element after the iterator position\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"addFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":23,"FieldAccessExpr":4,"MethodCallExpr":1,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":8},"text":"/**\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      */\npublic void add(Object element) {\n    if (position == null) {\n        addFirst(element);\n        position = first;\n    } else {\n        Node newNode = new Node();\n        newNode.data = element;\n        newNode.next = position.next;\n        position.next = newNode;\n        position = newNode;\n    }\n    isAfterNext = false;\n}\n","name":"add","className":"LinkedListIterator","variables":{"newNode":3,"position":3,"first":1,"element":1,"isAfterNext":1},"constants":{"null":1,"false":1},"javaDoc":"Adds an element before the iterator position and moves the iterator past the inserted element element the element to add","comments":"\n         Adds an element before the iterator position\n         and moves the iterator past the inserted element.\n         @param element the element to add\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":14,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":4},"text":"/**\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      */\npublic void remove() {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    if (position == first) {\n        removeFirst();\n    } else {\n        previous.next = position.next;\n    }\n    position = previous;\n    isAfterNext = false;\n}\n","name":"remove","className":"LinkedListIterator","variables":{"previous":1,"position":2,"first":1,"isAfterNext":2},"constants":{"false":1},"javaDoc":"Removes the last traversed element This method may only be called after a call to the next() method","comments":"\n         Removes the last traversed element. This method may\n         only be called after a call to the next() method.\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      */\npublic void set(Object element) {\n    if (!isAfterNext) {\n        throw new IllegalStateException();\n    }\n    position.data = element;\n}\n","name":"set","className":"LinkedListIterator","variables":{"isAfterNext":1,"element":1},"constants":{},"javaDoc":"Sets the last traversed element to a different value element the element to set","comments":"\n         Sets the last traversed element to a different value. \n         @param element the element to set\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"HashSet","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n      Constructs a hash table.\n      @param bucketsLength the length of the buckets array\n   */\npublic HashSet(int bucketsLength) {\n    buckets = new Node[bucketsLength];\n    currentSize = 0;\n}\n","name":"HashSet","className":"HashSet","variables":{"buckets":1,"bucketsLength":1,"currentSize":1},"constants":{"0":1},"javaDoc":"Constructs a hash table bucketsLength the length of the buckets array","comments":"\n      Constructs a hash table.\n      @param bucketsLength the length of the buckets array\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"hashCode":1,"current.data.equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":24,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":3},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":3,"ReturnStmt":2,"ExpressionStmt":5},"text":"/**\n      Tests for set membership.\n      @param x an object\n      @return true if x is an element of this set\n   */\npublic boolean contains(Object x) {\n    int h = x.hashCode();\n    h = h % buckets.length;\n    if (h < 0) {\n        h = -h;\n    }\n    Node current = buckets[h];\n    while (current != null) {\n        if (current.data.equals(x)) {\n            return true;\n        }\n        current = current.next;\n    }\n    return false;\n}\n","name":"contains","className":"HashSet","variables":{"current":3,"buckets":1,"h":7,"x":1},"constants":{"0":1,"null":1,"true":1,"false":1},"javaDoc":"Tests for set membership x an object true if x is an element of this set","comments":"\n      Tests for set membership.\n      @param x an object\n      @return true if x is an element of this set\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"hashCode":1,"current.data.equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":2,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":37,"FieldAccessExpr":5,"UnaryExpr":2,"MethodCallExpr":2,"AssignExpr":6},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":3,"ReturnStmt":2,"ExpressionStmt":10},"text":"/**\n      Adds an element to this set.\n      @param x an object\n      @return true if x is a new object, false if x was\n      already in the set\n   */\npublic boolean add(Object x) {\n    int h = x.hashCode();\n    h = h % buckets.length;\n    if (h < 0) {\n        h = -h;\n    }\n    Node current = buckets[h];\n    while (current != null) {\n        if (current.data.equals(x)) {\n            return false;\n        }\n        // Already in the set\n        current = current.next;\n    }\n    Node newNode = new Node();\n    newNode.data = x;\n    newNode.next = buckets[h];\n    buckets[h] = newNode;\n    currentSize++;\n    return true;\n}\n","name":"add","className":"HashSet","variables":{"current":3,"buckets":3,"h":9,"x":2,"newNode":2,"currentSize":1},"constants":{"0":1,"null":1,"false":1,"true":1},"javaDoc":"Adds an element to this set x an object true if x is a new object false if x was already in the set","comments":"Already in the set \n      Adds an element to this set.\n      @param x an object\n      @return true if x is a new object, false if x was\n      already in the set\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"hashCode":1,"current.data.equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":2,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":4,"BooleanLiteralExpr":2,"NameExpr":39,"FieldAccessExpr":6,"UnaryExpr":2,"MethodCallExpr":2,"AssignExpr":6},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":5,"ReturnStmt":2,"ExpressionStmt":10},"text":"/**\n      Removes an object from this set.\n      @param x an object\n      @return true if x was removed from this set, false\n      if x was not an element of this set\n   */\npublic boolean remove(Object x) {\n    int h = x.hashCode();\n    h = h % buckets.length;\n    if (h < 0) {\n        h = -h;\n    }\n    Node current = buckets[h];\n    Node previous = null;\n    while (current != null) {\n        if (current.data.equals(x)) {\n            if (previous == null) {\n                buckets[h] = current.next;\n            } else {\n                previous.next = current.next;\n            }\n            currentSize--;\n            return true;\n        }\n        previous = current;\n        current = current.next;\n    }\n    return false;\n}\n","name":"remove","className":"HashSet","variables":{"current":4,"previous":3,"buckets":2,"h":8,"x":1,"currentSize":1},"constants":{"0":1,"null":3,"true":1,"false":1},"javaDoc":"Removes an object from this set x an object true if x was removed from this set false if x was not an element of this set","comments":"\n      Removes an object from this set.\n      @param x an object\n      @return true if x was removed from this set, false\n      if x was not an element of this set\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Returns an iterator that traverses the elements of this set.\n      @return a hash set iterator\n   */\npublic Iterator iterator() {\n    return new HashSetIterator();\n}\n","name":"iterator","className":"HashSet","variables":{},"constants":{},"javaDoc":"Returns an iterator that traverses the elements of this set a hash set iterator","comments":"\n      Returns an iterator that traverses the elements of this set.\n      @return a hash set iterator\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Gets the number of elements in this set.\n      @return the number of elements\n   */\npublic int size() {\n    return currentSize;\n}\n","name":"size","className":"HashSet","variables":{"currentSize":1},"constants":{},"javaDoc":"Gets the number of elements in this set the number of elements","comments":"\n      Gets the number of elements in this set.\n      @return the number of elements\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"HashSetIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"NameExpr":2,"UnaryExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n         Constructs a hash set iterator that points to the\n         first element of the hash set.\n      */\npublic HashSetIterator() {\n    current = null;\n    bucketIndex = -1;\n}\n","name":"HashSetIterator","className":"HashSetIterator","variables":{"current":1,"bucketIndex":1},"constants":{"1":1,"null":1},"javaDoc":"Constructs a hash set iterator that points to the first element of the hash set","comments":"\n         Constructs a hash set iterator that points to the\n         first element of the hash set.\n      ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"NullLiteralExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":6,"BooleanLiteralExpr":3,"NameExpr":12,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":3,"ForStmt":1},"text":"public boolean hasNext() {\n    if (current != null && current.next != null) {\n        return true;\n    }\n    for (int b = bucketIndex + 1; b < buckets.length; b++) {\n        if (buckets[b] != null) {\n            return true;\n        }\n    }\n    return false;\n}\n","name":"hasNext","className":"HashSetIterator","variables":{"current":1,"b":4,"buckets":1,"bucketIndex":1},"constants":{"1":1,"null":3,"true":2,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"ObjectCreationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":20,"FieldAccessExpr":4,"UnaryExpr":1,"AssignExpr":2},"statements":{"IfStmt":2,"BlockStmt":4,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":3,"DoStmt":1},"text":"public Object next() {\n    if (current != null && current.next != null) {\n        // Move to next element in bucket\n        current = current.next;\n    } else // Move to next bucket\n    {\n        do {\n            bucketIndex++;\n            if (bucketIndex == buckets.length) {\n                throw new NoSuchElementException();\n            }\n            current = buckets[bucketIndex];\n        } while (current == null);\n    }\n    return current.data;\n}\n","name":"next","className":"HashSetIterator","variables":{"current":4,"buckets":1,"bucketIndex":3},"constants":{"null":3},"javaDoc":"","comments":"Move to next element in bucket Move to next bucket ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ThrowStmt":1},"text":"public void remove() {\n    throw new UnsupportedOperationException();\n}\n","name":"remove","className":"HashSetIterator","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":12,"next":1,"iterator":1,"hasNext":1,"remove":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Iterator":1,"HashSet":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":56,"StringLiteralExpr":14,"FieldAccessExpr":1,"MethodCallExpr":18},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":17},"text":"public static void main(String[] args) {\n    HashSet names = new HashSet(101);\n    names.add(\"Harry\");\n    names.add(\"Sue\");\n    names.add(\"Nina\");\n    names.add(\"Susannah\");\n    names.add(\"Larry\");\n    names.add(\"Eve\");\n    names.add(\"Sarah\");\n    names.add(\"Adam\");\n    names.add(\"Tony\");\n    names.add(\"Katherine\");\n    names.add(\"Juliet\");\n    names.add(\"Romeo\");\n    names.remove(\"Romeo\");\n    names.remove(\"George\");\n    Iterator iter = names.iterator();\n    while (iter.hasNext()) {\n        System.out.println(iter.next());\n    }\n}\n","name":"main","className":"HashSetDemo","variables":{"names":16,"iter":3},"constants":{"\"Tony\"":1,"\"Sue\"":1,"\"Susannah\"":1,"\"Katherine\"":1,"\"George\"":1,"\"Larry\"":1,"\"Eve\"":1,"101":1,"\"Nina\"":1,"\"Adam\"":1,"\"Juliet\"":1,"\"Harry\"":1,"\"Romeo\"":2,"\"Sarah\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"LinkedListStack","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n      Constructs an empty stack.\n   */\npublic LinkedListStack() {\n    first = null;\n}\n","name":"LinkedListStack","className":"LinkedListStack","variables":{"first":1},"constants":{"null":1},"javaDoc":"Constructs an empty stack","comments":" \n      Constructs an empty stack.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":10,"FieldAccessExpr":2,"AssignExpr":3},"statements":{"ExpressionStmt":4},"text":"/**\n      Adds an element to the top of the stack.\n      @param element the element to add\n   */\npublic void push(Object element) {\n    Node newNode = new Node();\n    newNode.data = element;\n    newNode.next = first;\n    first = newNode;\n}\n","name":"push","className":"LinkedListStack","variables":{"newNode":2,"first":2,"element":1},"constants":{},"javaDoc":"Adds an element to the top of the stack element the element to add","comments":"\n      Adds an element to the top of the stack.\n      @param element the element to add\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n      Removes the element from the top of the stack.\n      @return the removed element\n   */\npublic Object pop() {\n    if (first == null) {\n        throw new NoSuchElementException();\n    }\n    Object element = first.data;\n    first = first.next;\n    return element;\n}\n","name":"pop","className":"LinkedListStack","variables":{"first":2,"element":2},"constants":{"null":1},"javaDoc":"Removes the element from the top of the stack the removed element","comments":"\n      Removes the element from the top of the stack.\n      @return the removed element\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n      Checks whether this stack is empty.\n      @return true if the stack is empty\n   */\npublic boolean empty() {\n    return first == null;\n}\n","name":"empty","className":"LinkedListStack","variables":{"first":1},"constants":{"null":1},"javaDoc":"Checks whether this stack is empty true if the stack is empty","comments":"\n      Checks whether this stack is empty.\n      @return true if the stack is empty\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"push":3,"empty":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LinkedListStack":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    LinkedListStack s = new LinkedListStack();\n    s.push(\"Tom\");\n    s.push(\"Diana\");\n    s.push(\"Harry\");\n    while (!s.empty()) {\n        System.out.println(s.pop());\n    }\n}\n","name":"main","className":"StackDemo","variables":{"s":6},"constants":{"\"Tom\"":1,"\"Diana\"":1,"\"Harry\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getLogger":1,"error":1,"info":1},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"Object":1,"Logger":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":13,"StringLiteralExpr":4,"MethodCallExpr":3},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    Logger theLogger = Logger.getLogger(\"com.darwinsys\");\n    try {\n        Object o = new Object();\n        theLogger.info(\"I created an object: \" + o);\n        if (o != null) {\n            // bogus, just to show logging\n            throw new IllegalArgumentException(\"Just testing\");\n        }\n    } catch (Exception ex) {\n        theLogger.error(\"Caught Exception: \" + ex, ex);\n    }\n}\n","name":"main","className":"Log4JDemo2","variables":{"ex":2,"Logger":1,"theLogger":3,"o":3},"constants":{"\"Just testing\"":1,"\"com.darwinsys\"":1,"null":1,"\"I created an object: \"":1,"\"Caught Exception: \"":1},"javaDoc":"","comments":"bogus just to show logging ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"log":5,"close":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"NetLog":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":29,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) throws IOException {\n    System.out.println(\"NetLogSimple: Starting...\");\n    // Get the connection to the NetLog\n    NetLog nl = new NetLog();\n    // Show sending a String\n    nl.log(\"Hello Java\");\n    // Show sending Objects\n    nl.log(new java.util.Date());\n    nl.log(nl);\n    // Show sending null and \"\" (normally an accident...)\n    nl.log(null);\n    nl.log(\"\");\n    // All done, close the log\n    nl.close();\n    System.out.println(\"NetLogSimple: Done...\");\n}\n","name":"main","className":"NetLogSimple","variables":{"nl":7},"constants":{"\"\"":1,"\"Hello Java\"":1,"\"NetLogSimple: Starting...\"":1,"null":1,"\"NetLogSimple: Done...\"":1},"javaDoc":"","comments":"Get the connection to the NetLog Show sending a String Show sending Objects Show sending null and \"\" (normally an accident ) All done close the log ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getLogger":1,"info":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"Logger":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    Logger myLogger = Logger.getLogger(\"com.darwinsys\");\n    // PropertyConfigurator.configure(\"log4j.properties\");\n    Object o = new Object();\n    myLogger.info(\"I created an object: \" + o);\n}\n","name":"main","className":"Log4JDemo","variables":{"myLogger":2,"Logger":1,"o":2},"constants":{"\"com.darwinsys\"":1,"\"I created an object: \"":1},"javaDoc":"","comments":"PropertyConfigurator configure(\"log4j properties\"); ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"error":1,"info":1},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"Person":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":10,"StringLiteralExpr":3,"MethodCallExpr":2},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    try {\n        Person p = new Person();\n        // populate person's fields here...\n        theLogger.info(\"I created an object {}\", p);\n        if (p != null) {\n            // bogus, just to show logging\n            throw new IllegalArgumentException(\"Just testing\");\n        }\n    } catch (Exception ex) {\n        theLogger.error(\"Caught Exception: \" + ex, ex);\n    }\n}\n","name":"main","className":"Slf4jDemo2","variables":{"p":2,"ex":2,"theLogger":2},"constants":{"\"Just testing\"":1,"null":1,"\"I created an object {}\"":1,"\"Caught Exception: \"":1},"javaDoc":"","comments":"populate person's fields here bogus just to show logging ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"log":1,"setProperty":1,"getLogger":1,"info":1},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"Object":1,"Logger":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":18,"StringLiteralExpr":6,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    System.setProperty(\"java.util.logging.config.file\", \"logging/logging.properties\");\n    Logger logger = Logger.getLogger(\"com.darwinsys\");\n    try {\n        Object o = new Object();\n        logger.info(\"I created an object: \" + o);\n        if (o != null) {\n            // bogus, just to show logging\n            throw new IllegalArgumentException(\"Just testing\");\n        }\n    } catch (Exception t) {\n        logger.log(Level.SEVERE, \"Caught Exception\", t);\n    }\n}\n             // All-in-one call:\n\n             // Alternate: Long form, more control.\n\n             // LogRecord msg = new LogRecord(Level.SEVERE, \"Caught exception\");\n\n             // msg.setThrown(t);\n\n             // logger.log(msg);\n\n","name":"main","className":"Log14Demo2","variables":{"t":1,"logger":3,"Logger":1,"System":1,"o":3},"constants":{"\"Just testing\"":1,"\"logging/logging.properties\"":1,"\"com.darwinsys\"":1,"null":1,"\"I created an object: \"":1,"\"java.util.logging.config.file\"":1,"\"Caught Exception\"":1},"javaDoc":"","comments":"bogus just to show logging All-in-one call: Alternate: Long form more control LogRecord msg = new LogRecord(Level SEVERE \"Caught exception\"); msg setThrown(t); logger log(msg); ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2},"statements":{"ExpressionStmt":1},"text":"/** Main method, to start the servers. */\npublic static void main(String[] av) {\n    new NetLogServer(PORT, NUM_THREADS);\n}\n","name":"main","className":"NetLogServer","variables":{"NUM_THREADS":1,"PORT":1},"constants":{},"javaDoc":"Main method to start the servers","comments":" Main method, to start the servers. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"NetLogServer","methodCalls":{"createTitledBorder":1,"add":1,"setVisible":1,"exit":1,"setEditable":1,"setBorder":1,"getContentPane":1,"setDefaultCloseOperation":1,"System.err.println":1,"pack":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"ServerSocket":1,"int":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":47,"StringLiteralExpr":3,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":11},"statements":{"TryStmt":1,"BlockStmt":3,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":13},"text":"/** Constructor */\npublic NetLogServer(int port, int numThreads) {\n    ServerSocket servSock;\n    try {\n        servSock = new ServerSocket(PORT);\n    } catch (IOException e) {\n        System.err.println(\"Could not create ServerSocket \" + e);\n        System.exit(1);\n        return;\n    }\n    // Build the GUI - must be before Handler constructors!\n    theFrame = new JFrame(\"NetLog Server\");\n    theTextArea = new JTextArea(24, 80);\n    theTextArea.setEditable(false);\n    theTextArea.setBorder(BorderFactory.createTitledBorder(\"NetLogServer\"));\n    theFrame.getContentPane().add(new JScrollPane(theTextArea));\n    // Now start the Threads\n    for (int i = 0; i < numThreads; i++) {\n        new Handler(servSock, i).start();\n    }\n    theFrame.pack();\n    theFrame.setVisible(true);\n    theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n             /* Crash the server if IO fails. Something bad has happened */\n\n                        /*NOTREACHED*/\n\n","name":"NetLogServer","className":"NetLogServer","variables":{"servSock":3,"BorderFactory":1,"PORT":1,"e":2,"theFrame":5,"i":4,"theTextArea":4,"numThreads":1,"System":1},"constants":{"0":1,"\"Could not create ServerSocket \"":1,"1":1,"\"NetLogServer\"":1,"24":1,"\"NetLog Server\"":1,"80":1,"false":1,"true":1},"javaDoc":"Constructor","comments":"Crash the server if IO fails Something bad has happened NOTREACHED Build the GUI - must be before Handler constructors! Now start the Threads  Constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","String"],"returnType":"void","methodCalls":{"toFront":1,"getText":1,"length":2,"toString":1,"setCaretPosition":1,"append":7},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"StringBuffer":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":41,"StringLiteralExpr":3,"CharLiteralExpr":1,"MethodCallExpr":13},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":10},"text":"public synchronized void log(int tid, String s) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(tid);\n    sb.append(\": \");\n    if (s == null) {\n        sb.append(\"(null)\");\n    } else if (s.length() == 0) {\n        sb.append(\"(null string)\");\n    } else\n        sb.append(s);\n    sb.append('\\n');\n    theTextArea.append(sb.toString());\n    theTextArea.setCaretPosition(theTextArea.getText().length());\n    theFrame.toFront();\n}\n","name":"log","className":"NetLogServer","variables":{"s":2,"theFrame":1,"theTextArea":3,"sb":8},"constants":{"0":1,"null":1,"\"(null string)\"":1,"\": \"":1,"'\\n'":1,"\"(null)\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["ServerSocket","int"],"returnType":"Handler","methodCalls":{"setName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":3},"text":"/** Construct a Handler. */\nHandler(ServerSocket s, int i) {\n    super();\n    servSock = s;\n    tid = i;\n    setName(\"Thread \" + tid);\n}\n","name":"Handler","className":"Handler","variables":{"servSock":1,"s":1,"i":1,"tid":2},"constants":{"\"Thread \"":1},"javaDoc":"Construct a Handler","comments":" Construct a Handler. ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"getInetAddress":1,"getName":3,"log":4,"readLine":1,"getInputStream":1,"close":1,"accept":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"Socket":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":6,"NameExpr":36,"StringLiteralExpr":3,"EnclosedExpr":1,"MethodCallExpr":12,"AssignExpr":1},"statements":{"WhileStmt":2,"BlockStmt":4,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"public void run() {\n    /* Wait for a connection */\n    while (true) {\n        try {\n            // log(tid, getName() + \" waiting\");\n            Socket clientSocket = servSock.accept();\n            log(tid, getName() + \" START, IP=\" + clientSocket.getInetAddress());\n            BufferedReader is = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            String line;\n            while ((line = is.readLine()) != null) {\n                // System.out.println(\">> \" + line);\n                log(tid, line);\n            }\n            log(tid, getName() + \" ENDED \");\n            clientSocket.close();\n        } catch (IOException ex) {\n            log(tid, getName() + \": IO Error on socket \" + ex);\n            return;\n        }\n    }\n}\n","name":"run","className":"Handler","variables":{"clientSocket":4,"servSock":1,"ex":2,"line":2,"is":2},"constants":{"null":1,"\" START, IP=\"":1,"true":1,"\": IO Error on socket \"":1,"\" ENDED \"":1},"javaDoc":"","comments":"Wait for a connection log(tid getName() + \" waiting\"); System out println(\">> \" + line); ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"info":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Object o = new Object();\n    theLogger.info(\"I created an object: \" + o);\n}\n","name":"main","className":"Slf4jDemo","variables":{"o":2,"theLogger":1},"constants":{"\"I created an object: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getLogger":1,"info":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"Logger":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    Logger myLogger = Logger.getLogger(\"com.darwinsys\");\n    Object o = new Object();\n    myLogger.info(\"I created an object: \" + o);\n}\n","name":"main","className":"Log14Demo","variables":{"myLogger":2,"Logger":1,"o":2},"constants":{"\"com.darwinsys\"":1,"\"I created an object: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getproperties":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public static void main(String argv[]) {\n    // BEGIN main\n    // EXPECT COMPILE ERROR \n    System.out.println(System.getproperties());\n// END main\n}\n","name":"main","className":"Problem","variables":{"System":1},"constants":{},"javaDoc":"","comments":"BEGIN main END main EXPECT COMPILE ERROR ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getAudioInputStream":1,"getClip":1,"start":1,"main":1,"System.err.println":2,"open":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["FinalVariables","ExceptionHandling","Recursion"],"types":{"AudioInputStream":1,"Clip":1,"String":1,"URL":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":43,"StringLiteralExpr":2,"FieldAccessExpr":4,"ClassExpr":1,"MethodCallExpr":9},"statements":{"ContinueStmt":1,"IfStmt":2,"BlockStmt":4,"TryStmt":1,"ForeachStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] av) {\n    if (av.length == 0)\n        main(defSounds);\n    else\n        for (String a : av) {\n            System.out.println(\"Playing  \" + a);\n            try {\n                URL snd = AudioPlay.class.getResource(a);\n                if (snd == null) {\n                    System.err.println(\"Cannot getResource \" + a);\n                    continue;\n                }\n                AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(snd);\n                final Clip clip = AudioSystem.getClip();\n                clip.open(audioInputStream);\n                clip.start();\n            } catch (Exception e) {\n                System.err.println(e);\n            }\n        }\n}\n","name":"main","className":"AudioPlay","variables":{"a":3,"audioInputStream":1,"av":1,"e":1,"snd":2,"AudioSystem":2,"clip":3},"constants":{"0":1,"null":1,"\"Playing  \"":1,"\"Cannot getResource \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String"],"returnType":"TTFontDemo","methodCalls":{"deriveFont":1,"getResourceAsStream":1,"setFont":1,"setBackground":1,"createFont":1},"annotations":[],"exceptions":["IOException","FontFormatException"],"concepts":[],"types":{"InputStream":1,"Font":2},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":32,"StringLiteralExpr":1,"FieldAccessExpr":4,"ThisExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ThrowStmt":1,"ExpressionStmt":5},"text":"/** Construct a TTFontDemo -- Create a Font from TTF.\n     */\npublic TTFontDemo(String fontFileName, String text) throws IOException, FontFormatException {\n    super(text, JLabel.CENTER);\n    setBackground(Color.white);\n    // First, see if we can load the font file.\n    InputStream is = this.getClass().getResourceAsStream(fontFileName);\n    if (is == null) {\n        throw new IOException(\"Cannot open \" + fontFileName);\n    }\n    // createFont makes a 1-point font, bit hard to read :-)\n    Font ttfBase = Font.createFont(Font.TRUETYPE_FONT, is);\n    // So scale it to 24 pt.\n    Font ttfReal = ttfBase.deriveFont(Font.PLAIN, 24);\n    setFont(ttfReal);\n}\n","name":"TTFontDemo","className":"TTFontDemo","variables":{"fontFileName":1,"ttfBase":2,"is":2,"text":1,"ttfReal":1,"Font":1},"constants":{"24":1,"null":1,"\"Cannot open \"":1},"javaDoc":"Construct a TTFontDemo -- Create a Font from TTF","comments":"First see if we can load the font file createFont makes a 1-point font bit hard to read :-) So scale it to 24 pt  Construct a TTFontDemo -- Create a Font from TTF.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"getContentPane":1,"setDefaultCloseOperation":1,"setBounds":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"JFrame":1,"TTFontDemo":1,"String":3},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":2,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":3,"NameExpr":25,"FieldAccessExpr":2,"ConditionalExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":9},"text":"/** Simple main program for TTFontDemo */\npublic static void main(String[] args) throws Exception {\n    String DEFAULT_MESSAGE = \"What hath man wrought? Or at least rendered?\";\n    // Loaded as Resource so don't need graphics/ in front\n    String DEFAULT_FONTFILE = \"Kellyag_.ttf\";\n    String message = args.length == 1 ? args[0] : DEFAULT_MESSAGE;\n    JFrame f = new JFrame(\"TrueType Font Demo\");\n    TTFontDemo ttfd = new TTFontDemo(DEFAULT_FONTFILE, message);\n    f.getContentPane().add(ttfd);\n    f.setBounds(100, 100, 700, 250);\n    f.setVisible(true);\n    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n","name":"main","className":"TTFontDemo","variables":{"args":1,"f":5,"ttfd":1,"DEFAULT_MESSAGE":2,"message":2,"DEFAULT_FONTFILE":2},"constants":{"0":1,"1":1,"100":2,"\"Kellyag_.ttf\"":1,"\"What hath man wrought? Or at least rendered?\"":1,"700":1,"\"TrueType Font Demo\"":1,"true":1,"250":1},"javaDoc":"Simple main program for TTFontDemo","comments":"Loaded as Resource so don't need graphics/ in front  Simple main program for TTFontDemo ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"setVisible":1,"exit":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void windowClosing(WindowEvent e) {\n    f.setVisible(false);\n    f.dispose();\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"f":2,"System":1},"constants":{"0":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":2,"addWindowListener":1,"exit":1,"setLocation":1,"dispose":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"TexturedText":1,"Frame":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BooleanLiteralExpr":2,"StringLiteralExpr":1,"NameExpr":27,"MethodCallExpr":8},"statements":{"BlockStmt":1,"ExpressionStmt":10},"text":"/** \"main program\" method - construct and show */\npublic static void main(String[] av) {\n    // create a TexturedText object, tell it to show up\n    final Frame f = new Frame(\"TexturedText\");\n    TexturedText comp = new TexturedText();\n    f.add(comp);\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            f.setVisible(false);\n            f.dispose();\n            System.exit(0);\n        }\n    });\n    f.pack();\n    f.setLocation(200, 200);\n    f.setVisible(true);\n}\n","name":"main","className":"TexturedText","variables":{"comp":1,"e":1,"windowClosing":1,"f":8,"System":1},"constants":{"\"TexturedText\"":1,"0":1,"200":2,"false":1,"true":1},"javaDoc":"\"main program\" method - construct and show","comments":"create a TexturedText object tell it to show up  \"main program\" method - construct and show ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"TexturedText","methodCalls":{"getHeight":1,"createGraphics":1,"drawLine":2,"getWidth":1,"setBackground":1,"setPaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1,"int":2,"Graphics2D":1},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":3,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":48,"FieldAccessExpr":3,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":7,"AssignExpr":2},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ForStmt":1,"ExpressionStmt":9},"text":"/** Construct the object */\npublic TexturedText() {\n    super();\n    setBackground(Color.white);\n    int width = 8, height = 8;\n    bim = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n    Graphics2D g2 = bim.createGraphics();\n    for (int i = 0; i < width; i++) {\n        g2.setPaint(colors[(i / 2) % colors.length]);\n        g2.drawLine(0, i, i, 0);\n        g2.drawLine(width - i, height, width, height - i);\n    }\n    Rectangle r = new Rectangle(0, 0, bim.getWidth(), bim.getHeight());\n    tp = new TexturePaint(bim, r);\n}\n","name":"TexturedText","className":"TexturedText","variables":{"r":2,"bim":5,"width":4,"i":6,"g2":4,"tp":1,"colors":1,"height":3},"constants":{"0":5,"2":1,"8":2},"javaDoc":"Construct the object","comments":" Construct the object ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setRenderingHint":1,"setFont":1,"drawString":1,"setPaint":1},"annotations":["Override"],"exceptions":[],"concepts":["Casting"],"types":{"Graphics2D":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":22,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"@Override\npublic void paintComponent(Graphics g) {\n    Graphics2D g2 = (Graphics2D) g;\n    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    g2.setPaint(tp);\n    g2.setFont(myFont);\n    g2.drawString(mesg, 20, 100);\n}\n","name":"paintComponent","className":"TexturedText","variables":{"g":1,"g2":5},"constants":{"100":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"@Override\npublic Dimension getMinimumSize() {\n    return new Dimension(250, 100);\n}\n","name":"getMinimumSize","className":"TexturedText","variables":{},"constants":{"100":1,"250":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"@Override\npublic Dimension getPreferredSize() {\n    return new Dimension(320, 150);\n}\n","name":"getPreferredSize","className":"TexturedText","variables":{},"constants":{"320":1,"150":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawString":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void paintComponent(Graphics g) {\n    g.drawString(\"Hello Java\", textX, textY);\n}\n","name":"paintComponent","className":"DrawStringDemo","variables":{"g":1},"constants":{"\"Hello Java\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"public Dimension getPreferredSize() {\n    return new Dimension(100, 100);\n}\n","name":"getPreferredSize","className":"DrawStringDemo","variables":{},"constants":{"100":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["JFrame","String"],"returnType":"JMFPlayer","methodCalls":{"getClass":1,"getResource":1,"addControllerListener":1,"start":1,"setLayout":1,"System.err.println":2,"createPlayer":1,"System.out.println":1},"annotations":[],"exceptions":["MalformedURLException","Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":2,"BinaryExpr":3,"NameExpr":43,"StringLiteralExpr":4,"FieldAccessExpr":3,"ThisExpr":2,"AssignExpr":5,"MethodCallExpr":9},"statements":{"TryStmt":1,"BlockStmt":3,"ReturnStmt":1,"ExpressionStmt":11},"text":"/** Construct the player object and the GUI. */\npublic JMFPlayer(JFrame pf, String media) {\n    parentFrame = pf;\n    mediaName = media;\n    // cp = getContentPane();\n    cp = this;\n    cp.setLayout(new BorderLayout());\n    try {\n        theURL = new URL(getClass().getResource(\".\"), mediaName);\n        thePlayer = Manager.createPlayer(theURL);\n        thePlayer.addControllerListener(this);\n    } catch (MalformedURLException e) {\n        System.err.println(\"JMF URL creation error: \" + e);\n    } catch (Exception e) {\n        System.err.println(\"JMF Player creation error: \" + e);\n        return;\n    }\n    System.out.println(\"theURL = \" + theURL);\n    // Start the player: this will notify our ControllerListener.\n    // start playing\n    thePlayer.start();\n}\n","name":"JMFPlayer","className":"JMFPlayer","variables":{"parentFrame":1,"theURL":2,"e":4,"pf":1,"thePlayer":3,"media":1,"Manager":1,"cp":2,"mediaName":2},"constants":{"\".\"":1,"\"theURL = \"":1,"\"JMF URL creation error: \"":1,"\"JMF Player creation error: \"":1},"javaDoc":"Construct the player object and the GUI","comments":"Start the player: this will notify our ControllerListener cp = getContentPane(); start playing  Construct the player object and the GUI. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"stop":1,"deallocate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"MethodCallExpr":2},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Called to stop the audio, as from a Stop button or menuitem */\npublic void stop() {\n    if (thePlayer == null)\n        return;\n    // stop playing!\n    thePlayer.stop();\n    // free system resources\n    thePlayer.deallocate();\n}\n","name":"stop","className":"JMFPlayer","variables":{"thePlayer":3},"constants":{"null":1},"javaDoc":"Called to stop the audio as from a Stop button or menuitem","comments":"stop playing! free system resources  Called to stop the audio, as from a Stop button or menuitem ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Called when we are really finished (as from an Exit button). */\npublic void destroy() {\n    if (thePlayer == null)\n        return;\n    thePlayer.close();\n}\n","name":"destroy","className":"JMFPlayer","variables":{"thePlayer":2},"constants":{"null":1},"javaDoc":"Called when we are really finished (as from an Exit button)","comments":" Called when we are really finished (as from an Exit button). ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ControllerEvent"],"returnType":"void","methodCalls":{"add":2,"getControlPanelComponent":1,"setTitle":1,"getVisualComponent":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NullLiteralExpr":3,"BinaryExpr":3,"NameExpr":31,"FieldAccessExpr":2,"EnclosedExpr":2,"InstanceOfExpr":1,"AssignExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":4,"BlockStmt":2,"ExpressionStmt":4},"text":"/** Called by JMF when the Player has something to tell us about. */\npublic synchronized void controllerUpdate(ControllerEvent event) {\n    // System.out.println(\"controllerUpdate(\" + event + \")\");\n    if (event instanceof RealizeCompleteEvent) {\n        if ((visualComponent = thePlayer.getVisualComponent()) != null)\n            cp.add(BorderLayout.CENTER, visualComponent);\n        if ((controlComponent = thePlayer.getControlPanelComponent()) != null)\n            cp.add(BorderLayout.SOUTH, controlComponent);\n        // resize the main window\n        if (parentFrame != null) {\n            parentFrame.pack();\n            parentFrame.setTitle(mediaName);\n        }\n    }\n}\n","name":"controllerUpdate","className":"JMFPlayer","variables":{"parentFrame":3,"visualComponent":1,"thePlayer":2,"controlComponent":1,"event":1,"cp":2},"constants":{"null":3},"javaDoc":"Called by JMF when the Player has something to tell us about","comments":"System out println(\"controllerUpdate(\" + event + \")\"); resize the main window  Called by JMF when the Player has something to tell us about. ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"getContentPane":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Container":1,"JFrame":1,"String":1,"JMFPlayer":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":2,"NameExpr":28,"FieldAccessExpr":3,"ConditionalExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] argv) {\n    JFrame f = new JFrame(\"JMF Player Demo\");\n    Container frameCP = f.getContentPane();\n    final String musicURL = argv.length == 0 ? \"file:/home/ian/Music/Classical/Rachmaninoff Prelude C_ min.mp3\" : argv[0];\n    JMFPlayer p = new JMFPlayer(f, musicURL);\n    frameCP.add(BorderLayout.CENTER, p);\n    f.setSize(200, 200);\n    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    f.setVisible(true);\n}\n","name":"main","className":"JMFPlayer","variables":{"p":1,"frameCP":2,"f":6,"musicURL":2,"argv":1},"constants":{"\"JMF Player Demo\"":1,"0":2,"200":2,"\"file:/home/ian/Music/Classical/Rachmaninoff Prelude C_ min.mp3\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"TiledImageComponent","methodCalls":{"add":6,"getToolkit":1,"setLayout":1,"setEchoChar":1,"getImage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":3,"NameExpr":35,"StringLiteralExpr":3,"FieldAccessExpr":3,"CharLiteralExpr":1,"MethodCallExpr":10,"AssignExpr":4},"statements":{"ExpressionStmt":9},"text":"/** Set things up nicely. */\npublic TiledImageComponent() {\n    setLayout(new FlowLayout());\n    add(new Label(\"Name:\", Label.CENTER));\n    add(nameTF = new TextField(10));\n    add(new Label(\"Password:\", Label.CENTER));\n    add(passTF = new TextField(10));\n    passTF.setEchoChar('*');\n    add(new Label(\"Domain:\", Label.CENTER));\n    add(domainTF = new TextField(10));\n    im = getToolkit().getImage(DEFAULT_IMAGE_NAME);\n}\n","name":"TiledImageComponent","className":"TiledImageComponent","variables":{"nameTF":1,"im":1,"domainTF":1,"passTF":2},"constants":{"\"Name:\"":1,"\"Password:\"":1,"'*'":1,"\"Domain:\"":1,"10":3},"javaDoc":"Set things up nicely","comments":" Set things up nicely. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawImage":1,"getHeight":1,"getSize":2,"println":1,"getWidth":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"int":4},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":10,"NameExpr":36,"StringLiteralExpr":4,"FieldAccessExpr":2,"ThisExpr":3,"MethodCallExpr":6,"AssignExpr":2},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":2,"ForStmt":2,"ExpressionStmt":4},"text":"/** paint()  - just tile the background.  */\n@Override\npublic void paintComponent(Graphics g) {\n    if (im == null)\n        return;\n    int iw = im.getWidth(this), ih = im.getHeight(this);\n    if (// image not ready\n    iw < 0 || ih < 0)\n        // live to try again later.\n        return;\n    int w = getSize().width, h = getSize().height;\n    for (int i = 0; i <= w; i += iw) {\n        for (int j = 0; j <= h; j += ih) {\n            Debug.println(\"draw\", \"drawImage(im,\" + i + \",\" + j + \")\");\n            g.drawImage(im, i, j, this);\n        }\n    }\n}\n","name":"paintComponent","className":"TiledImageComponent","variables":{"im":3,"w":2,"g":1,"h":2,"i":4,"j":4,"iw":3,"Debug":1,"ih":3},"constants":{"0":4,"null":1,"\"draw\"":1,"\"drawImage(im,\"":1,"\",\"":1,"\")\"":1},"javaDoc":"paint() - just tile the background","comments":"image not ready live to try again later  paint()  - just tile the background.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"getContentPane":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":17,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] av) {\n    JFrame f = new JFrame(\"TiledImageComponent Demo\");\n    f.getContentPane().add(new TiledImageComponent());\n    f.setSize(200, 200);\n    f.setVisible(true);\n    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n","name":"main","className":"TiledImageComponent","variables":{"f":5},"constants":{"\"TiledImageComponent Demo\"":1,"200":2,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Grapher","methodCalls":{"figure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public Grapher() {\n    data = new ArrayList<Point2D>();\n    figure();\n}\n","name":"Grapher","className":"Grapher","variables":{"data":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["List<String>"],"returnType":"void","methodCalls":{"add":1,"figure":1,"size":1,"setLocation":1,"get":1,"clear":1,"java.lang.Double.parseDouble":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Point2D":1,"Double":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":29,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"/** Set the list data from a list of Strings, where the\n     * x coordinate is incremented automatically, and the y coordinate\n     * is made from the String in the list.\n     */\npublic void setListDataFromYStrings(List<String> newData) {\n    data.clear();\n    for (int i = 0; i < newData.size(); i++) {\n        Point2D p = new Point2D.Double();\n        p.setLocation(i, java.lang.Double.parseDouble(newData.get(i)));\n        data.add(p);\n    }\n    figure();\n}\n","name":"setListDataFromYStrings","className":"Grapher","variables":{"p":2,"data":2,"i":3,"newData":2},"constants":{"0":1},"javaDoc":"Set the list data from a list of Strings where the x coordinate is incremented automatically and the y coordinate is made from the String in the list","comments":" Set the list data from a list of Strings, where the\n     * x coordinate is incremented automatically, and the y coordinate\n     * is made from the String in the list.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["List<Point2D>"],"returnType":"void","methodCalls":{"figure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Set the list from an existing List, as from GraphReader.read() */\npublic void setListData(List<Point2D> newData) {\n    data = newData;\n    figure();\n}\n","name":"setListData","className":"Grapher","variables":{"data":1,"newData":1},"constants":{},"javaDoc":"Set the list from an existing List as from GraphReader read()","comments":" Set the list from an existing List, as from GraphReader.read() ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getX":4,"println":2,"getY":4,"size":1,"get":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Point2D":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":19,"NameExpr":61,"CastExpr":1,"StringLiteralExpr":4,"CharLiteralExpr":4,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":12,"AssignExpr":6},"statements":{"IfStmt":4,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":9},"text":"/** Compute new data when list changes */\nprivate void figure() {\n    // find min & max\n    for (int i = 0; i < data.size(); i++) {\n        Point2D d = (Point2D) data.get(i);\n        if (d.getX() < minx)\n            minx = d.getX();\n        if (d.getX() > maxx)\n            maxx = d.getX();\n        if (d.getY() < miny)\n            miny = d.getY();\n        if (d.getY() > maxy)\n            maxy = d.getY();\n    }\n    // Compute ranges\n    xrange = (maxx - minx) * BORDERFACTOR;\n    yrange = (maxy - miny) * BORDERFACTOR;\n    Debug.println(\"range\", \"minx,x,r = \" + minx + ' ' + maxx + ' ' + xrange);\n    Debug.println(\"range\", \"miny,y,r = \" + miny + ' ' + maxy + ' ' + yrange);\n}\n","name":"figure","className":"Grapher","variables":{"BORDERFACTOR":2,"data":2,"d":9,"miny":4,"minx":4,"maxy":4,"maxx":4,"i":3,"yrange":2,"xrange":2,"Debug":2},"constants":{"0":1,"\"range\"":2,"\"miny,y,r = \"":1,"\"minx,x,r = \"":1,"' '":4},"javaDoc":"Compute new data when list changes","comments":"find min & max Compute ranges  Compute new data when list changes ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getSize":1,"getX":1,"println":1,"getY":1,"size":3,"get":1,"drawRect":1,"drawString":1},"annotations":["Override"],"exceptions":[],"concepts":["Casting"],"types":{"Point2D":1,"double":4,"Dimension":1,"int":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":7,"SuperExpr":1,"BinaryExpr":20,"NameExpr":56,"StringLiteralExpr":7,"CastExpr":3,"FieldAccessExpr":3,"EnclosedExpr":3,"UnaryExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"/** Called when the window needs painting.\n     * Computes X and Y range, scales.\n     */\n@Override\npublic void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    Dimension s = getSize();\n    if (data.size() < 2) {\n        g.drawString(\"Insufficient data: \" + data.size(), 10, 40);\n        return;\n    }\n    // Compute scale factors\n    double xfact = s.width / xrange;\n    double yfact = s.height / yrange;\n    // Scale and plot the data\n    for (int i = 0; i < data.size(); i++) {\n        Point2D d = (Point2D) data.get(i);\n        double x = (d.getX() - minx) * xfact;\n        double y = (d.getY() - miny) * yfact;\n        Debug.println(\"point\", \"AT \" + i + \" \" + d + \"; \" + \"x = \" + x + \"; y = \" + y);\n        // Draw a 5-pixel rectangle centered, so -2 both x and y.\n        // AWT numbers Y from 0 down, so invert:\n        g.drawRect(((int) x) - 2, s.height - 2 - (int) y, 5, 5);\n    }\n}\n","name":"paintComponent","className":"Grapher","variables":{"data":4,"d":4,"g":2,"i":4,"yrange":1,"xfact":2,"s":1,"miny":1,"minx":1,"x":3,"y":3,"xrange":1,"yfact":2,"Debug":1},"constants":{"0":1,"2":3,"\"point\"":1,"\" \"":1,"5":2,"\"AT \"":1,"\"x = \"":1,"\"; y = \"":1,"\"; \"":1,"40":1,"\"Insufficient data: \"":1,"10":1},"javaDoc":"Called when the window needs painting Computes X and Y range scales","comments":"Compute scale factors Scale and plot the data Draw a 5-pixel rectangle centered so -2 both x and y AWT numbers Y from 0 down so invert:  Called when the window needs painting.\n     * Computes X and Y range, scales.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"@Override\npublic Dimension getPreferredSize() {\n    return new Dimension(150, 150);\n}\n","name":"getPreferredSize","className":"Grapher","variables":{},"constants":{"150":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"read":3,"setLocation":1,"setContentPane":1,"setListData":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables"],"types":{"JFrame":1,"Grapher":1,"List<Point2D>":1,"String":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":4,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":4,"NameExpr":46,"FieldAccessExpr":3,"MethodCallExpr":10,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ExpressionStmt":13},"text":"public static void main(String[] args) throws IOException {\n    final JFrame f = new JFrame(\"Grapher\");\n    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    Grapher grapher = new Grapher();\n    f.setContentPane(grapher);\n    f.setLocation(100, 100);\n    f.pack();\n    List<Point2D> data = null;\n    if (args.length == 0)\n        data = GraphReader.read(\"Grapher.txt\");\n    else {\n        String fileName = args[0];\n        if (\"-\".equals(fileName)) {\n            data = GraphReader.read(new InputStreamReader(System.in), \"System.in\");\n        } else {\n            data = GraphReader.read(fileName);\n        }\n    }\n    grapher.setListData(data);\n    f.setVisible(true);\n}\n","name":"main","className":"Grapher","variables":{"args":1,"fileName":1,"data":4,"GraphReader":3,"f":6,"grapher":2},"constants":{"0":2,"100":2,"\"System.in\"":1,"null":1,"\"-\"":1,"\"Grapher\"":1,"true":1,"\"Grapher.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getFontMetrics":1,"getAscent":1,"stringWidth":1,"getSize":3,"getFont":1,"getDescent":2,"drawString":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"FontMetrics":1,"int":2},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"BinaryExpr":9,"NameExpr":39,"FieldAccessExpr":3,"EnclosedExpr":2,"MethodCallExpr":10,"AssignExpr":2},"statements":{"IfStmt":2,"ExpressionStmt":6},"text":"/** Called by the window system to draw the text. */\n@Override\npublic void paintComponent(Graphics g) {\n    // Get the current Font, and ask it for its FontMetrics.\n    FontMetrics fm = getFontMetrics(getFont());\n    // Use the FontMetrics to get the width of the String.\n    // Subtract this from width, divide by 2, that's our starting point.\n    int textX = (getSize().width - fm.stringWidth(message)) / 2;\n    if (// If string too long, start at 0\n    textX < 0)\n        textX = 0;\n    // Same as above but for the height\n    int textY = (getSize().height - fm.getAscent()) / 2 - fm.getDescent();\n    if (textY < 0)\n        textY = getSize().height - fm.getDescent() - 1;\n    // Now draw the text at the computed spot.\n    g.drawString(message, textX, textY);\n}\n","name":"paintComponent","className":"DrawStringDemo2","variables":{"fm":5,"g":1,"textX":3,"textY":3},"constants":{"0":3,"1":1,"2":2},"javaDoc":"Called by the window system to draw the text","comments":"Use the FontMetrics to get the width of the String Get the current Font and ask it for its FontMetrics Subtract this from width divide by 2 that's our starting point If string too long start at 0 Same as above but for the height Now draw the text at the computed spot  Called by the window system to draw the text. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"//-\npublic Dimension getPreferredSize() {\n    return new Dimension(100, 100);\n}\n","name":"getPreferredSize","className":"DrawStringDemo2","variables":{},"constants":{"100":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"JFrame":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(final String[] args) {\n    final JFrame jf = new JFrame();\n    jf.add(new DrawStringDemo2());\n    jf.setBounds(100, 100, 100, 100);\n    jf.setVisible(true);\n}\n","name":"main","className":"DrawStringDemo2","variables":{"jf":4},"constants":{"100":4,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"loadImage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void init() {\n    loadImage();\n}\n","name":"init","className":"GetImage","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getToolkit":1,"getClass":1,"getResource":1,"getImage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"URL":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":10,"StringLiteralExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"public void loadImage() {\n    // Portable version: getClass().getResource() works in either\n    // applet or application, 1.1 or 1.3, returns URL for file name.\n    URL url = getClass().getResource(\"Duke.gif\");\n    image = getToolkit().getImage(url);\n// Or just:\n// image = getToolkit().getImage(getClass().getResource(\"Duke.gif\"));\n}\n","name":"loadImage","className":"GetImage","variables":{"image":1,"url":1},"constants":{"\"Duke.gif\"":1},"javaDoc":"","comments":"Portable version: getClass() getResource() works in either Or just: image = getToolkit() getImage(getClass() getResource(\"Duke gif\")); applet or application 1 1 or 1 3 returns URL for file name ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawImage":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":4,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void paint(Graphics g) {\n    g.drawImage(image, 20, 20, this);\n}\n","name":"paint","className":"GetImage","variables":{"g":1},"constants":{"20":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"init":1,"setSize":1,"setContentPane":1,"start":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"GetImage":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    JFrame f = new JFrame(\"GetImage\");\n    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    GetImage myApplet = new GetImage();\n    f.setContentPane(myApplet);\n    myApplet.init();\n    f.setSize(100, 100);\n    f.setVisible(true);\n    myApplet.start();\n}\n","name":"main","className":"GetImage","variables":{"f":5,"myApplet":3},"constants":{"100":2,"true":1,"\"GetImage\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"NameExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new VlcjVideo(args[0]);\n}\n","name":"main","className":"VlcjVideo","variables":{"args":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"VlcjVideo","methodCalls":{"add":1,"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JPanel":1,"MyVideoPanel":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":21,"StringLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":7},"statements":{"ExpressionStmt":8},"text":"public VlcjVideo(String url) {\n    setTitle(\"VLCJ Video\");\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    setSize(800, 600);\n    JPanel player = new MyVideoPanel();\n    add(player, BorderLayout.CENTER);\n    pack();\n    setVisible(true);\n    ((MyVideoPanel) player).play(url);\n}\n","name":"VlcjVideo","className":"VlcjVideo","variables":{"player":2},"constants":{"\"VLCJ Video\"":1,"600":1,"800":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MyVideoPanel","methodCalls":{"add":1,"getAbsolutePath":1,"addSearchPath":1,"getMediaPlayer":1,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"EmbeddedMediaPlayerComponent":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"ExpressionStmt":5},"text":"public MyVideoPanel() {\n    NativeLibrary.addSearchPath(\"libvlc\", vlcWhere.getAbsolutePath());\n    EmbeddedMediaPlayerComponent videoCanvas = new EmbeddedMediaPlayerComponent();\n    setLayout(new BorderLayout());\n    add(videoCanvas, BorderLayout.CENTER);\n    player = videoCanvas.getMediaPlayer();\n}\n","name":"MyVideoPanel","className":"MyVideoPanel","variables":{"NativeLibrary":1,"vlcWhere":1,"videoCanvas":2,"player":1},"constants":{"\"libvlc\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"play":1,"prepareMedia":1,"parseMedia":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void play(String media) {\n    player.prepareMedia(media);\n    player.parseMedia();\n    player.play();\n}\n","name":"play","className":"MyVideoPanel","variables":{"player":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"DropShadow","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Set up the GUI\n     * limit ourselves to the ubiquitous IllegalArgumentException.\n     */\npublic DropShadow() {\n    this(\"DropShadow\");\n}\n","name":"DropShadow","className":"DropShadow","variables":{},"constants":{"\"DropShadow\"":1},"javaDoc":"Set up the GUI limit ourselves to the ubiquitous IllegalArgumentException","comments":"\n     * Set up the GUI\n     * limit ourselves to the ubiquitous IllegalArgumentException.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"DropShadow","methodCalls":{"setBackground":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"BinaryExpr":8,"NameExpr":29,"StringLiteralExpr":4,"FieldAccessExpr":5,"ConditionalExpr":1,"ThisExpr":1,"AssignExpr":4,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"public DropShadow(String theLabel) {\n    this.theLabel = theLabel == null ? \"DropShadow\" : theLabel;\n    // Now handle font stuff.\n    fontName = \"Sans\";\n    fontSize = 24;\n    if (fontName != null || fontSize != 0) {\n        theFont = new Font(fontName, Font.BOLD + Font.ITALIC, fontSize);\n        System.out.println(\"Name \" + fontName + \", font \" + theFont);\n    }\n    setBackground(Color.green);\n}\n","name":"DropShadow","className":"DropShadow","variables":{"fontName":4,"theLabel":2,"fontSize":3,"theFont":2},"constants":{"0":1,"24":1,"null":2,"\", font \"":1,"\"Name \"":1,"\"Sans\"":1,"\"DropShadow\"":1},"javaDoc":"","comments":"Now handle font stuff ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":2,"setFont":1,"drawString":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"BinaryExpr":2,"NameExpr":26,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"/** Paint method showing drop shadow effect */\npublic void paint(Graphics g) {\n    g.setFont(theFont);\n    g.setColor(Color.black);\n    g.drawString(theLabel, theOffset + 30, theOffset + 50);\n    g.setColor(Color.white);\n    g.drawString(theLabel, 30, 50);\n}\n","name":"paint","className":"DropShadow","variables":{"g":5,"theOffset":2},"constants":{"50":2,"30":2},"javaDoc":"Paint method showing drop shadow effect","comments":" Paint method showing drop shadow effect ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":1,"fillRect":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":13,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n     * Component subclasses can override paint(), but\n     * JComponent subclasses should normally use paintComponent()\n     * instead, to avoid clobbering border painting and the like.\n     */\n@Override\npublic void paint(Graphics g) {\n    g.setColor(Color.red);\n    g.fillRect(rectX, rectY, rectWidth, rectHeight);\n}\n","name":"paint","className":"PaintDemo","variables":{"g":2},"constants":{},"javaDoc":"Component subclasses can override paint() but JComponent subclasses should normally use paintComponent() instead to avoid clobbering border painting and the like","comments":"\n     * Component subclasses can override paint(), but\n     * JComponent subclasses should normally use paintComponent()\n     * instead, to avoid clobbering border painting and the like.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"@Override\npublic Dimension getPreferredSize() {\n    return new Dimension(100, 100);\n}\n","name":"getPreferredSize","className":"PaintDemo","variables":{},"constants":{"100":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ChessMoveException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public ChessMoveException() {\n    super();\n}\n","name":"ChessMoveException","className":"ChessMoveException","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"ChessMoveException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public ChessMoveException(String msg) {\n    super(msg);\n}\n","name":"ChessMoveException","className":"ChessMoveException","variables":{"msg":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","Exception"],"returnType":"ChessMoveException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public ChessMoveException(String msg, Exception cause) {\n    super(msg, cause);\n}\n","name":"ChessMoveException","className":"ChessMoveException","variables":{"msg":1,"cause":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"computeArea":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Shape":1,"double":1},"expressions":{"VariableDeclarationExpr":2,"DoubleLiteralExpr":1,"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Iterate over all the Shapes, getting their areas;\n     * this cannot use the Java 8 Collection.forEach because the\n     * variable total would have to be final, which would defeat the purpose :-) \n     */\npublic double totalAreas() {\n    double total = 0.0;\n    for (Shape s : allShapes) {\n        total += s.computeArea();\n    }\n    return total;\n}\n","name":"totalAreas","className":"ShapeDriver","variables":{"total":3,"s":2,"allShapes":1},"constants":{"0.0":1},"javaDoc":"Iterate over all the Shapes getting their areas; this cannot use the Java 8 Collection forEach because the variable total would have to be final which would defeat the purpose :-)","comments":" Iterate over all the Shapes, getting their areas;\n     * this cannot use the Java 8 Collection.forEach because the\n     * variable total would have to be final, which would defeat the purpose :-) \n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ShapeDriver","methodCalls":{"add":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"// END main\nShapeDriver() {\n    allShapes = new ArrayList<>();\n    allShapes.add(new Circle());\n    allShapes.add(new Rectangle());\n}\n","name":"ShapeDriver","className":"ShapeDriver","variables":{"allShapes":3},"constants":{},"javaDoc":"","comments":" END main","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":7,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    System.out.println(new ShapeDriver().totalAreas());\n}\n","name":"main","className":"ShapeDriver","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"ToStringWithout","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Simple constructor */\npublic ToStringWithout(int anX, int aY) {\n    x = anX;\n    y = aY;\n}\n","name":"ToStringWithout","className":"ToStringWithout","variables":{"x":1,"aY":1,"y":1,"anX":1},"constants":{},"javaDoc":"Simple constructor","comments":" Simple constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"NameExpr":5,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Main just creates and prints an object */\npublic static void main(String[] args) {\n    System.out.println(new ToStringWithout(42, 86));\n}\n","name":"main","className":"ToStringWithout","variables":{},"constants":{"42":1,"86":1},"javaDoc":"Main just creates and prints an object","comments":" Main just creates and prints an object ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","SomeClass"],"returnType":"EqualsDemo","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":5,"StringLiteralExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":2},"text":"/** Constructor */\npublic EqualsDemo(int i, SomeClass o) {\n    int1 = i;\n    if (o == null) {\n        throw new IllegalArgumentException(\"Data Object may not be null\");\n    }\n    obj1 = o;\n}\n","name":"EqualsDemo","className":"EqualsDemo","variables":{"int1":1,"i":1,"obj1":1,"o":2},"constants":{"null":1,"\"Data Object may not be null\"":1},"javaDoc":"Constructor","comments":" Constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"EqualsDemo","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Default Constructor */\npublic EqualsDemo() {\n    this(0, new SomeClass());\n}\n","name":"EqualsDemo","className":"EqualsDemo","variables":{},"constants":{"0":1},"javaDoc":"Default Constructor","comments":" Default Constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1,"equals":1},"annotations":["Override"],"exceptions":[],"concepts":["Casting"],"types":{"EqualsDemo":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"BooleanLiteralExpr":6,"NameExpr":16,"CastExpr":1,"ClassExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":5,"ReturnStmt":6,"ExpressionStmt":1},"text":"/** Demonstration \"equals\" method */\n@Override\npublic boolean equals(Object o) {\n    if (// <1> optimization\n    o == this)\n        return true;\n    if (// <2> No object ever equals null\n    o == null)\n        return false;\n    // Of the correct class?\n    if (// <3>\n    o.getClass() != EqualsDemo.class)\n        return false;\n    // OK, cast to this class\n    EqualsDemo other = (EqualsDemo) o;\n    // compare field-by-field         // <4>\n    if (// compare primitives directly\n    int1 != other.int1)\n        return false;\n    if (// compare objects using their equals\n    !obj1.equals(other.obj1))\n        return false;\n    return true;\n}\n","name":"equals","className":"EqualsDemo","variables":{"other":1,"int1":1,"obj1":1,"o":4},"constants":{"null":1,"true":2,"false":4},"javaDoc":"Demonstration \"equals\" method","comments":"<1> optimization <2> No object ever equals null Of the correct class? <3> OK cast to this class compare field-by-field // <4> compare primitives directly compare objects using their equals  Demonstration \"equals\" method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSource":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Data":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":21,"CastExpr":2,"StringLiteralExpr":1,"FieldAccessExpr":3,"EnclosedExpr":2,"AssignExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent evt) {\n    Data loc = new Data();\n    loc.x = ((Component) evt.getSource()).getX();\n    loc.x = ((Component) evt.getSource()).getY();\n    System.out.println(\"Thanks for pressing me\");\n}\n","name":"actionPerformed","className":"","variables":{"loc":1,"evt":2},"constants":{"\"Thanks for pressing me\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSource":2,"addActionListener":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"JButton":1,"Data":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"StringLiteralExpr":2,"NameExpr":26,"CastExpr":2,"FieldAccessExpr":3,"EnclosedExpr":2,"MethodCallExpr":6,"AssignExpr":2},"statements":{"BlockStmt":1,"ExpressionStmt":6},"text":"public void getResults() {\n    JButton b = new JButton(\"Press me\");\n    b.addActionListener(new // <2>\n    ActionListener() {\n\n        public void actionPerformed(ActionEvent evt) {\n            Data loc = new Data();\n            loc.x = ((Component) evt.getSource()).getX();\n            loc.x = ((Component) evt.getSource()).getY();\n            System.out.println(\"Thanks for pressing me\");\n        }\n    });\n}\n","name":"getResults","className":"AllClasses","variables":{"loc":1,"actionPerformed":1,"b":2,"evt":3},"constants":{"\"Thanks for pressing me\"":1,"\"Press me\"":1},"javaDoc":"","comments":"<2> ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"AnotherClass","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// methods and fields here...\nAnotherClass() {\n// Inner class from above cannot be used here, of course\n// Data d = new Data();    // EXPECT COMPILE ERROR\n}\n","name":"AnotherClass","className":"AnotherClass","variables":{},"constants":{},"javaDoc":"","comments":"Inner class from above cannot be used here of course Data d = new Data(); // EXPECT COMPILE ERROR  methods and fields here...","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":31,"StringLiteralExpr":4,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    System.out.println(\"About to hashCode \" + data.length + \" objects.\");\n    for (int i = 0; i < data.length; i++) {\n        System.out.println(data[i].toString() + \" --> \" + data[i].hashCode());\n    }\n    System.out.println(\"All done.\");\n}\n","name":"main","className":"PrintHashCodes","variables":{"data":2,"i":5},"constants":{"0":1,"\"About to hashCode \"":1,"\"All done.\"":1,"\" --> \"":1,"\" objects.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Object","methodCalls":{"toString":1,"System.out.println":1},"annotations":[],"exceptions":["InternalError","CloneNotSupportedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"SuperExpr":1,"NameExpr":10,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/** Clone this object. Call super.clone() to do the work */\npublic Object clone() {\n    try {\n        return super.clone();\n    } catch (CloneNotSupportedException ex) {\n        System.out.println(\"Now that's a surprise!!\");\n        throw new InternalError(ex.toString());\n    }\n}\n","name":"clone","className":"Clone1","variables":{"ex":2},"constants":{"\"Now that's a surprise!!\"":1},"javaDoc":"Clone this object Call super clone() to do the work","comments":" Clone this object. Call super.clone() to do the work ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/** Display the current object as a string */\npublic String toString() {\n    return \"Clone1[\" + x + \",\" + y + \"]\";\n}\n","name":"toString","className":"Clone1","variables":{"x":1,"y":1},"constants":{"\"Clone1[\"":1,"\"]\"":1,"\",\"":1},"javaDoc":"Display the current object as a string","comments":" Display the current object as a string ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":11,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"InstanceOfExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"/** Scenario: goodNight() is called from a timer Thread at 2200, or when\n     * we get the \"shutdown\" command from the security guard.\n     */\npublic void goodNight() {\n    for (int i = 0; i < things.length; i++) if (things[i] instanceof PowerSwitchable)\n        ((PowerSwitchable) things[i]).powerDown();\n}\n","name":"goodNight","className":"BuildingManagement","variables":{"things":2,"i":5},"constants":{"0":1},"javaDoc":"Scenario: goodNight() is called from a timer Thread at 2200 or when we get the \"shutdown\" command from the security guard","comments":" Scenario: goodNight() is called from a timer Thread at 2200, or when\n     * we get the \"shutdown\" command from the security guard.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Asset"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Add a Asset to this building */\npublic void add(Asset thing) {\n    System.out.println(\"Adding \" + thing);\n    things[numItems++] = thing;\n}\n","name":"add","className":"BuildingManagement","variables":{"things":1,"thing":2,"numItems":1},"constants":{"\"Adding \"":1},"javaDoc":"Add a Asset to this building","comments":" Add a Asset to this building ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"goodNight":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BuildingManagement":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"NameExpr":15,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"/** The main program */\npublic static void main(String[] av) {\n    BuildingManagement b1 = new BuildingManagement();\n    // control lights in room 101\n    b1.add(new RoomLights(101));\n    // and emerg. lights.\n    b1.add(new EmergencyLight(101));\n    // add the computer on desk#4 in room 101\n    b1.add(new ComputerCPU(10104));\n    // and its monitor\n    b1.add(new ComputerMonitor(10104));\n    // time passes, and the sun sets...\n    b1.goodNight();\n}\n","name":"main","className":"BuildingManagement","variables":{"b1":6},"constants":{"101":2,"10104":2},"javaDoc":"The main program","comments":"control lights in room 101 and emerg lights add the computer on desk#4 in room 101 and its monitor time passes and the sun sets  The main program ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"equals":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"CopyConstructorDemo":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"StringLiteralExpr":3,"NameExpr":15,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    CopyConstructorDemo object1 = new CopyConstructorDemo(123, \"Hello\");\n    CopyConstructorDemo object2 = new CopyConstructorDemo(object1);\n    if (!object1.equals(object2)) {\n        System.out.println(\"Something is terribly wrong...\");\n    }\n    System.out.println(\"All done.\");\n}\n","name":"main","className":"CopyConstructorDemo","variables":{"object2":1,"object1":3},"constants":{"\"Hello\"":1,"123":1,"\"Something is terribly wrong...\"":1,"\"All done.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"CopyConstructorDemo","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Default constructor */\npublic CopyConstructorDemo() {\n}\n","name":"CopyConstructorDemo","className":"CopyConstructorDemo","variables":{},"constants":{},"javaDoc":"Default constructor","comments":" Default constructor ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","String"],"returnType":"CopyConstructorDemo","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Normal constructor */\npublic CopyConstructorDemo(int number, String name) {\n    this.number = number;\n    this.name = name;\n}\n","name":"CopyConstructorDemo","className":"CopyConstructorDemo","variables":{"number":1,"name":1},"constants":{},"javaDoc":"Normal constructor","comments":" Normal constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["CopyConstructorDemo"],"returnType":"CopyConstructorDemo","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"FieldAccessExpr":4,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Copy Constructor */\npublic CopyConstructorDemo(CopyConstructorDemo other) {\n    this.number = other.number;\n    this.name = other.name;\n}\n","name":"CopyConstructorDemo","className":"CopyConstructorDemo","variables":{},"constants":{},"javaDoc":"Copy Constructor","comments":" Copy Constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"hashCode":1},"annotations":["Override"],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":12,"EnclosedExpr":2,"ConditionalExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":4},"text":"// hashCode() and equals() not shown\n// END main\n@Override\npublic int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null) ? 0 : name.hashCode());\n    result = prime * result + number;\n    return result;\n}\n","name":"hashCode","className":"CopyConstructorDemo","variables":{"prime":3,"result":6,"number":1,"name":2},"constants":{"0":1,"1":1,"null":1,"31":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":2,"equals":1},"annotations":["Override"],"exceptions":[],"concepts":["Casting"],"types":{"CopyConstructorDemo":1},"expressions":{"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":6,"BooleanLiteralExpr":7,"NameExpr":22,"CastExpr":1,"FieldAccessExpr":3,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":7,"BlockStmt":1,"ReturnStmt":7,"ExpressionStmt":1},"text":"@Override\npublic boolean equals(Object obj) {\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    CopyConstructorDemo other = (CopyConstructorDemo) obj;\n    if (number != other.number)\n        return false;\n    if (name == null) {\n        if (other.name != null)\n            return false;\n    } else if (!name.equals(other.name))\n        return false;\n    return true;\n}\n","name":"equals","className":"CopyConstructorDemo","variables":{"number":1,"other":1,"obj":4,"name":2},"constants":{"null":3,"true":2,"false":5},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Singleton","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** A private Constructor prevents any other class from instantiating. */\nprivate Singleton() {\n// nothing to do this time\n}\n","name":"Singleton","className":"Singleton","variables":{},"constants":{},"javaDoc":"A private Constructor prevents any other class from instantiating","comments":"nothing to do this time  A private Constructor prevents any other class from instantiating. ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"Singleton","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Static 'instance' method */\npublic static Singleton getInstance() {\n    return instance;\n}\n","name":"getInstance","className":"Singleton","variables":{"instance":1},"constants":{},"javaDoc":"Static 'instance' method","comments":" Static 'instance' method ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** A simple demo method */\npublic String demoMethod() {\n    return \"demo\";\n}\n","name":"demoMethod","className":"Singleton","variables":{},"constants":{"\"demo\"":1},"javaDoc":"A simple demo method","comments":" A simple demo method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"ToStringWith","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Simple constructor */\npublic ToStringWith(int anX, int aY) {\n    x = anX;\n    y = aY;\n}\n","name":"ToStringWith","className":"ToStringWith","variables":{"x":1,"aY":1,"y":1,"anX":1},"constants":{},"javaDoc":"Simple constructor","comments":" Simple constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"@Override\npublic String toString() {\n    return \"ToStringWith[\" + x + \",\" + y + \"]\";\n}\n","name":"toString","className":"ToStringWith","variables":{"x":1,"y":1},"constants":{"\"]\"":1,"\",\"":1,"\"ToStringWith[\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"NameExpr":5,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Main just creates and prints an object */\npublic static void main(String[] args) {\n    System.out.println(new ToStringWith(42, 86));\n}\n","name":"main","className":"ToStringWith","variables":{},"constants":{"42":1,"86":1},"javaDoc":"Main just creates and prints an object","comments":" Main just creates and prints an object ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":["Throwable"],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void finalize() throws Throwable {\n    System.out.println(\"Running finalize()\");\n    super.finalize();\n}\n","name":"finalize","className":"","variables":{},"constants":{"\"Running finalize()\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void run() {\n    System.out.println(\"Running Shutdown Hook\");\n}\n","name":"run","className":"","variables":{},"constants":{"\"Running Shutdown Hook\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"addShutdownHook":1,"gc":1,"getRuntime":1,"System.out.println":3},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod"],"types":{"Object":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"SuperExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":40,"StringLiteralExpr":4,"FieldAccessExpr":4,"MethodCallExpr":9,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public static void main(String[] args) throws Exception {\n    // Create an Object with a finalize() method - Bad idea!\n    Object f = new Object() {\n\n        public void finalize() throws Throwable {\n            System.out.println(\"Running finalize()\");\n            super.finalize();\n        }\n    };\n    // Add a shutdownHook to the JVM\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n\n        public void run() {\n            System.out.println(\"Running Shutdown Hook\");\n        }\n    });\n    if (args.length == 1 && args[0].equals(\"-f\")) {\n        f = null;\n        System.gc();\n    }\n    System.out.println(\"Calling System.exit(), with f = \" + f);\n    System.exit(0);\n}\n         // Unless the user puts -f (this-program-specific argument for \"free\") on \n\n         // the command line, call System.exit while holding a reference to \n\n         // Object f, which can therefore not be finalized().\n\n","name":"main","className":"ShutdownDemo","variables":{"args":1,"Runtime":1,"f":3,"finalize":1,"run":1,"System":2},"constants":{"0":2,"1":1,"null":1,"\"-f\"":1,"\"Calling System.exit(), with f = \"":1,"\"Running finalize()\"":1,"\"Running Shutdown Hook\"":1},"javaDoc":"","comments":"Unless the user puts -f (this-program-specific argument for \"free\") on the command line call System exit while holding a reference to Object f which can therefore not be finalized() Create an Object with a finalize() method - Bad idea! Add a shutdownHook to the JVM ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","char","MutableInteger"],"returnType":"boolean","methodCalls":{"setValue":1,"indexOf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":9,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/** This is the function that has a return value of true but\n     * also \"passes back\" the offset into the String where a\n     * value was found. Contrived example!\n     */\npublic static boolean parse(String in, char lookFor, MutableInteger whereFound) {\n    int i = in.indexOf(lookFor);\n    if (i == -1)\n        // not found\n        return false;\n    // say where found\n    whereFound.setValue(i);\n    // say that it was found\n    return true;\n}\n","name":"parse","className":"StringParse","variables":{"in":1,"i":2,"whereFound":1},"constants":{"1":1,"false":1,"true":1},"javaDoc":"This is the function that has a return value of true but also \"passes back\" the offset into the String where a value was found Contrived example!","comments":"not found say where found say that it was found  This is the function that has a return value of true but\n     * also \"passes back\" the offset into the String where a\n     * value was found. Contrived example!\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parse":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"MutableInteger":1,"char":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":5,"StringLiteralExpr":5,"NameExpr":18,"CharLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    MutableInteger mi = new MutableInteger();\n    String text = \"Hello, World\";\n    char c = 'W';\n    if (parse(text, c, mi)) {\n        System.out.println(\"Character \" + c + \" found at offset \" + mi + \" in \" + text);\n    } else {\n        System.out.println(\"Not found\");\n    }\n}\n","name":"main","className":"StringParse","variables":{"c":2,"text":2,"mi":2},"constants":{"\"Character \"":1,"\"Not found\"":1,"'W'":1,"\" found at offset \"":1,"\" in \"":1,"\"Hello, World\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showStatus":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    showStatus(\"Thanks for pushing my first button!\");\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{"\"Thanks for pushing my first button!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showStatus":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    showStatus(\"Thanks for pushing my second button!\");\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{"\"Thanks for pushing my second button!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"addActionListener":2,"showStatus":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":4,"NameExpr":20,"StringLiteralExpr":4,"MethodCallExpr":6,"AssignExpr":2},"statements":{"BlockStmt":2,"ExpressionStmt":6},"text":"public void init() {\n    add(b = new Button(\"A button\"));\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            showStatus(\"Thanks for pushing my first button!\");\n        }\n    });\n    add(b = new Button(\"Another button\"));\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            showStatus(\"Thanks for pushing my second button!\");\n        }\n    });\n}\n","name":"init","className":"ButtonDemo2c","variables":{"actionPerformed":2,"b":4,"e":2},"constants":{"\"Another button\"":1,"\"A button\"":1,"\"Thanks for pushing my first button!\"":1,"\"Thanks for pushing my second button!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"currentThread":1,"pollEvents":1,"kind":1,"getDefault":1,"newWatchService":1,"take":1,"get":1,"equals":1,"context":2,"reset":1,"toString":1,"System.err.println":1,"System.out.println":3,"register":1},"annotations":[],"exceptions":["Throwable"],"concepts":[],"types":{"Path":1,"WatchKey":1,"WatchEvent<?>":1,"String":1,"Kind<?>[]":1,"WatchService":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":6,"ArrayInitializerExpr":1,"BinaryExpr":4,"BooleanLiteralExpr":1,"StringLiteralExpr":7,"NameExpr":67,"FieldAccessExpr":4,"UnaryExpr":2,"MethodCallExpr":18,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ForeachStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] args) throws Throwable {\n    String tempDirPath = \"/tmp\";\n    System.out.println(\"Starting watcher for \" + tempDirPath);\n    Path p = Paths.get(tempDirPath);\n    WatchService watcher = FileSystems.getDefault().newWatchService();\n    Kind<?>[] watchKinds = { ENTRY_CREATE, ENTRY_MODIFY };\n    p.register(watcher, watchKinds);\n    mainRunner = Thread.currentThread();\n    new Thread(new DemoService()).start();\n    while (!done) {\n        WatchKey key = watcher.take();\n        for (WatchEvent<?> e : key.pollEvents()) {\n            System.out.println(\"Saw event \" + e.kind() + \" on \" + e.context());\n            if (e.context().toString().equals(\"MyFileSema.for\")) {\n                System.out.println(\"Semaphore found, shutting down watcher\");\n                done = true;\n            }\n        }\n        if (!key.reset()) {\n            System.err.println(\"Key failed to reset!\");\n        }\n    }\n}\n","name":"main","className":"FileWatchServiceDemo","variables":{"watcher":2,"FileSystems":1,"mainRunner":1,"e":4,"ENTRY_CREATE":1,"ENTRY_MODIFY":1,"done":2,"Thread":1,"p":2,"Paths":1,"tempDirPath":2,"watchKinds":1,"key":3},"constants":{"\"MyFileSema.for\"":1,"\"Starting watcher for \"":1,"\" on \"":1,"\"Semaphore found, shutting down watcher\"":1,"\"Key failed to reset!\"":1,"\"Saw event \"":1,"true":1,"\"/tmp\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":3,"interrupt":1,"System.out.println":3},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":32,"StringLiteralExpr":4,"FieldAccessExpr":3,"MethodCallExpr":8,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":9},"text":"public void run() {\n    try {\n        Thread.sleep(1000);\n        System.out.println(\"Creating file\");\n        new File(tempDirPath + \"/MyFileSema.for\").createNewFile();\n        Thread.sleep(1000);\n        System.out.println(\"Stopping WatcherServiceDemo\");\n        done = true;\n        Thread.sleep(1500);\n        mainRunner.interrupt();\n    } catch (Exception e) {\n        System.out.println(\"Caught UNEXPECTED \" + e);\n    }\n}\n","name":"run","className":"DemoService","variables":{"mainRunner":1,"e":2,"tempDirPath":1,"done":1,"Thread":3},"constants":{"\"/MyFileSema.for\"":1,"1500":1,"1000":2,"true":1,"\"Stopping WatcherServiceDemo\"":1,"\"Caught UNEXPECTED \"":1,"\"Creating file\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setVisible":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"StringLiteralExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent e) {\n    if (propsDialog == null) {\n        propsDialog = new ProtoDialog(NetFrame.this, \"Properties\");\n    }\n    propsDialog.setVisible(true);\n// TODO fetch protocol\n}\n","name":"actionPerformed","className":"","variables":{"NetFrame":1,"propsDialog":3},"constants":{"null":1,"\"Properties\"":1,"true":1},"javaDoc":"","comments":"TODO fetch protocol ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showMessageDialog":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":7,"StringLiteralExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    JOptionPane.showMessageDialog(NetFrame.this, \"NetWatch Application -- $Version$\\n\" + \"Copyright (c) 2000 Ian F. Darwin\\n\" + \"See LEGAL.NOTICE for licensing.\", \"RMIWatch\", JOptionPane.INFORMATION_MESSAGE);\n}\n","name":"actionPerformed","className":"","variables":{"NetFrame":1,"JOptionPane":1},"constants":{"\"NetWatch Application -- $Version$\\n\"":1,"\"Copyright (c) 2000 Ian F. Darwin\\n\"":1,"\"See LEGAL.NOTICE for licensing.\"":1,"\"RMIWatch\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","Properties"],"returnType":"NetFrame","methodCalls":{"add":6,"setVisible":1,"exit":1,"showMessageDialog":1,"addActionListener":3,"getContentPane":1,"setLayout":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"JMenuItem":1,"JMenuBar":1,"JMenu":1},"expressions":{"ObjectCreationExpr":12,"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"BooleanLiteralExpr":1,"NameExpr":67,"StringLiteralExpr":11,"FieldAccessExpr":1,"ThisExpr":3,"AssignExpr":9,"MethodCallExpr":15},"statements":{"IfStmt":1,"BlockStmt":4,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":20},"text":"/** Constructor */\npublic NetFrame(String title, Properties p) {\n    super(title);\n    props = p;\n    cp = getContentPane();\n    JMenuBar jb = new JMenuBar();\n    JMenu jm;\n    JMenuItem mi;\n    // FILE MENU\n    jb.add(jm = new JMenu(\"File\"));\n    jm.add(mi = new JMenuItem(\"Exit\"));\n    mi.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    // VIEW MENU\n    jb.add(jm = new JMenu(\"Edit\"));\n    jm.add(mi = new JMenuItem(\"Properties...\"));\n    mi.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            if (propsDialog == null) {\n                propsDialog = new ProtoDialog(NetFrame.this, \"Properties\");\n            }\n            propsDialog.setVisible(true);\n        // TODO fetch protocol\n        }\n    });\n    // HELP MENU\n    jb.add(jm = new JMenu(\"Help\"));\n    jm.add(mi = new JMenuItem(\"About\"));\n    mi.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            JOptionPane.showMessageDialog(NetFrame.this, \"NetWatch Application -- $Version$\\n\" + \"Copyright (c) 2000 Ian F. Darwin\\n\" + \"See LEGAL.NOTICE for licensing.\", \"RMIWatch\", JOptionPane.INFORMATION_MESSAGE);\n        }\n    });\n    this.setJMenuBar(jb);\n    cp.setLayout(new GridLayout(0, 1));\n}\n","name":"NetFrame","className":"NetFrame","variables":{"NetFrame":2,"jm":7,"e":3,"propsDialog":3,"title":1,"cp":2,"JOptionPane":1,"System":1,"props":1,"p":1,"actionPerformed":3,"jb":4,"mi":7},"constants":{"\"Properties...\"":1,"\"Properties\"":1,"\"Exit\"":1,"\"About\"":1,"\"See LEGAL.NOTICE for licensing.\"":1,"\"RMIWatch\"":1,"0":2,"1":1,"\"File\"":1,"null":1,"\"Help\"":1,"\"Edit\"":1,"true":1,"\"NetWatch Application -- $Version$\\n\"":1,"\"Copyright (c) 2000 Ian F. Darwin\\n\"":1},"javaDoc":"Constructor","comments":"FILE MENU VIEW MENU TODO fetch protocol HELP MENU  Constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","Properties"],"returnType":"void","methodCalls":{"add":1,"parseInt":1,"getProperty":1,"getComponents":2,"setLayout":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"ObjectCreationExpr":4,"NullLiteralExpr":1,"IntegerLiteralExpr":7,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":33,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":8},"statements":{"IfStmt":3,"BlockStmt":1,"ExpressionStmt":6},"text":"/** CONSTRUCT PANELS, ONE FOR EACH HOST. */\nprotected void addHost(String hostName, Properties props) {\n    cp.add(new RMIPanel(hostName, props));\n    // If asked for ncolumns, make it so.\n    // Else If it got too tall, make it multi columns.\n    String nc = props.getProperty(\"netwatch.gui.columns\");\n    if (nc != null) {\n        int n = Integer.parseInt(nc);\n        cp.setLayout(new GridLayout(0, n));\n    } else if (cp.getComponents().length > 12)\n        cp.setLayout(new GridLayout(0, 3));\n    else if (cp.getComponents().length > 6)\n        cp.setLayout(new GridLayout(0, 2));\n}\n","name":"addHost","className":"NetFrame","variables":{"Integer":1,"hostName":1,"nc":2,"cp":6,"n":2,"props":2},"constants":{"0":3,"12":1,"2":1,"\"netwatch.gui.columns\"":1,"3":1,"null":1,"6":1},"javaDoc":"CONSTRUCT PANELS ONE FOR EACH HOST","comments":"If asked for ncolumns make it so Else If it got too tall make it multi columns  CONSTRUCT PANELS, ONE FOR EACH HOST. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","Properties"],"returnType":"RMIPanel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public RMIPanel(String host, Properties p) {\n    super(host, p);\n}\n","name":"RMIPanel","className":"RMIPanel","variables":{"p":1,"host":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"e.detail.getClass":3,"getClass":2,"getProperty":2,"getName":2,"getText":1,"length":1,"list":1,"sleep":1,"random":1,"setState":7,"toString":1,"indexOf":1,"append":1,"setText":6},"annotations":[],"exceptions":["MalformedURLException","java.rmi.ConnectIOException","RemoteException","InterruptedException","java.rmi.ConnectException"],"concepts":["ExceptionHandling"],"types":{"String":4,"String[]":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"NullLiteralExpr":1,"VariableDeclarationExpr":6,"ArrayAccessExpr":1,"BinaryExpr":24,"NameExpr":110,"StringLiteralExpr":17,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":1,"UnaryExpr":3,"MethodCallExpr":30},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":12,"TryStmt":2,"ForStmt":1,"ExpressionStmt":20},"text":"/** Keep the screen updated forever, unless stop()ped. */\npublic void run() {\n    String thePort = props.getProperty(\"rmiwatch.port\", \"\");\n    String theURL = \"rmi://\" + hostName + \":\" + thePort;\n    while (!done) {\n        try {\n            String[] names = Naming.list(theURL);\n            ta.setText(\"\");\n            for (int i = 0; i < names.length; i++) {\n                ta.append(i + \": \" + names[i] + \"\\n\");\n            }\n            // If we didnt get an exception, host is up.\n            String expect = props.getProperty(\"rmiwatch.expect\");\n            String fullText = ta.getText();\n            if (fullText.length() == 0) {\n                ta.setText(\"(nothing registered!)\");\n                setState(EMPTY);\n            } else if (expect != null && fullText.indexOf(expect) == -1) {\n                setState(DUBIOUS);\n            } else\n                setState(FINE);\n        } catch (java.rmi.ConnectIOException e) {\n            setState(DOWN);\n            ta.setText(\"Net error: \" + e.detail.getClass());\n        } catch (java.rmi.ConnectException e) {\n            setState(NOREG);\n            ta.setText(\"RMI error: \" + e.getClass().getName() + \"\\n\" + \"  \" + e.detail.getClass());\n        } catch (RemoteException e) {\n            setState(NOREG);\n            ta.setText(\"RMI error: \" + e.getClass().getName() + \"\\n\" + \"  \" + e.detail.getClass());\n        } catch (MalformedURLException e) {\n            setState(DOWN);\n            ta.setText(\"Invalid host: \" + e.toString());\n        } finally {\n            // Randomize time so we dont make net load bursty.\n            try {\n                Thread.sleep((int) (sleepTime * MSEC * 2 * Math.random()));\n            } catch (InterruptedException e) {\n            }\n        }\n    }\n}\n                 // System.err.println(hostName + \":\" + e);\n\n                 // sleep() in \"finally\" so common \"down\" states dont bypass.\n\n                     /*CANTHAPPEN*/\n\n","name":"run","className":"RMIPanel","variables":{"MSEC":1,"hostName":1,"theURL":1,"e":8,"i":5,"fullText":3,"Naming":1,"Math":1,"done":1,"ta":8,"props":2,"Thread":1,"expect":2,"thePort":2,"names":2,"sleepTime":1},"constants":{"\"\"":2,"\"Invalid host: \"":1,"\"rmiwatch.expect\"":1,"\"rmi://\"":1,"\"RMI error: \"":2,"\":\"":1,"\": \"":1,"\"  \"":2,"0":2,"1":1,"2":1,"null":1,"\"Net error: \"":1,"\"(nothing registered!)\"":1,"\"rmiwatch.port\"":1,"\"\\n\"":3},"javaDoc":"Keep the screen updated forever unless stop()ped","comments":"If we didnt get an exception host is up System err println(hostName + \":\" + e); sleep() in \"finally\" so common \"down\" states dont bypass Randomize time so we dont make net load bursty CANTHAPPEN  Keep the screen updated forever, unless stop()ped. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","Properties"],"returnType":"NetPanel","methodCalls":{"parseInt":1,"add":1,"createTitledBorder":1,"getProperty":1,"setEditable":1,"setBorder":1,"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":40,"StringLiteralExpr":2,"FieldAccessExpr":2,"ThisExpr":1,"AssignExpr":5,"MethodCallExpr":8},"statements":{"IfStmt":2,"ExpressionStmt":11},"text":"public NetPanel(String host, Properties p) {\n    hostName = host;\n    props = p;\n    String s = props.getProperty(\"rmiwatch.sleep\");\n    if (s != null)\n        sleepTime = Integer.parseInt(s);\n    // Maybe get font name and size from props?\n    if (cwFont == null)\n        cwFont = new Font(\"lucidasansTypewriter\", Font.PLAIN, 10);\n    // Gooey gooey stuff.\n    ta = new JTextArea(2, 26);\n    ta.setEditable(false);\n    ta.setFont(cwFont);\n    add(BorderLayout.CENTER, ta);\n    setBorder(BorderFactory.createTitledBorder(hostName));\n    // Sparks. Ignition!\n    new Thread(this).start();\n}\n         // System.out.println(\"Sleep time now \" + sleepTime);\n\n","name":"NetPanel","className":"NetPanel","variables":{"p":1,"Integer":1,"hostName":1,"BorderFactory":1,"s":2,"host":1,"sleepTime":1,"cwFont":2,"ta":3,"props":2},"constants":{"2":1,"\"rmiwatch.sleep\"":1,"null":2,"26":1,"\"lucidasansTypewriter\"":1,"false":1,"10":1},"javaDoc":"","comments":"System out println(\"Sleep time now \" + sleepTime); Maybe get font name and size from props? Gooey gooey stuff Sparks Ignition! ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Stop this Thread */\npublic void stop() {\n    done = true;\n}\n","name":"stop","className":"NetPanel","variables":{"done":1},"constants":{"true":1},"javaDoc":"Stop this Thread","comments":" Stop this Thread ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"setForeground":5,"setBackground":5},"annotations":[],"exceptions":["IllegalStateException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":3,"NameExpr":61,"StringLiteralExpr":2,"FieldAccessExpr":5,"MethodCallExpr":10,"AssignExpr":1},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":5,"SwitchEntryStmt":6,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":11},"text":"/** Record the new state of the current machine.\n     * If this machine has changed state, set its color\n     * @param newState - one of the five valid states in the introduction.\n     */\nprotected void setState(int newState) {\n    if (state == /*already*/\n    newState)\n        // nothing to do.\n        return;\n    switch(newState) {\n        case // Server has \"expect\"ed name registered.\n        FINE:\n            ta.setBackground(COLOR_FINE);\n            ta.setForeground(Color.black);\n            break;\n        case // Server does not have expected name registered.\n        DUBIOUS:\n            ta.setBackground(COLOR_DUBIOUS);\n            ta.setForeground(Color.black);\n            break;\n        case // Server has nothing registered.\n        EMPTY:\n            ta.setBackground(COLOR_EMPTY);\n            ta.setForeground(Color.black);\n            break;\n        case // host is up but not running RMI\n        NOREG:\n            ta.setBackground(COLOR_NOREG);\n            ta.setForeground(Color.white);\n            break;\n        case // host unreachable, not responding, ECONN, etc.\n        DOWN:\n            ta.setBackground(COLOR_DOWN);\n            ta.setForeground(Color.white);\n            break;\n        default:\n            throw new IllegalStateException(\"setState(\" + state + \") invalid\");\n    }\n    state = newState;\n}\n","name":"setState","className":"NetPanel","variables":{"DOWN":1,"NOREG":1,"FINE":1,"state":3,"ta":10,"DUBIOUS":1,"EMPTY":1,"newState":3},"constants":{"\"setState(\"":1,"\") invalid\"":1},"javaDoc":"Record the new state of the current machine If this machine has changed state set its color newState - one of the five valid states in the introduction","comments":"already nothing to do Server has \"expect\"ed name registered Server does not have expected name registered Server has nothing registered host is up but not running RMI host unreachable not responding ECONN etc  Record the new state of the current machine.\n     * If this machine has changed state, set its color\n     * @param newState - one of the five valid states in the introduction.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":2,"setVisible":1,"addWindowListener":1,"exit":1,"showMessageDialog":1,"getProperty":4,"load":1,"size":1,"toString":1,"close":1,"addHost":4,"pack":1},"annotations":[],"exceptions":["IOException"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"NetFrame":1,"String":2,"Properties":1,"FileInputStream":1,"int":5},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":5,"VariableDeclarationExpr":10,"ArrayAccessExpr":1,"BinaryExpr":10,"StringLiteralExpr":9,"NameExpr":91,"UnaryExpr":3,"AssignExpr":1,"NullLiteralExpr":3,"BooleanLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":19},"statements":{"IfStmt":3,"BreakStmt":1,"TryStmt":1,"BlockStmt":9,"ForStmt":3,"ExpressionStmt":19},"text":"public static void main(String[] argv) {\n    Properties p = null;\n    NetFrame f = new NetFrame(\"Network Watcher\", p);\n    try {\n        FileInputStream is = new FileInputStream(\"NetWatch.properties\");\n        p = new Properties();\n        p.load(is);\n        is.close();\n    } catch (IOException e) {\n        JOptionPane.showMessageDialog(f, e.toString(), \"Properties error\", JOptionPane.ERROR_MESSAGE);\n    }\n    // If arguments, use them as hostnames.\n    if (argv.length != 0) {\n        for (int i = 0; i < argv.length; i++) {\n            f.addHost(argv[i], p);\n        }\n    // No arguments. Can we use properties?\n    } else if (p != null && p.size() > 0) {\n        String net = p.getProperty(\"netwatch.net\");\n        int start = Integer.parseInt(p.getProperty(\"netwatch.start\"));\n        int end = Integer.parseInt(p.getProperty(\"netwatch.end\"));\n        for (int i = start; i <= end; i++) {\n            f.addHost(net + \".\" + i, p);\n        }\n        for (int i = 0; ; i++) {\n            String nextHost = p.getProperty(\"nethost\" + i);\n            if (nextHost == null)\n                break;\n            f.addHost(nextHost, p);\n        }\n    } else // None of the above. Fall back to localhost\n    {\n        f.addHost(\"localhost\", p);\n    }\n    // All done. Pack the Frame and show it.\n    f.pack();\n         // NOW CONSTRUCT PANELS, ONE FOR EACH HOST.\n\n    // UtilGUI.centre(f);\n    f.setVisible(true);\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n}\n","name":"main","className":"NetWatch","variables":{"e":3,"f":8,"start":2,"i":11,"is":2,"JOptionPane":1,"argv":1,"System":1,"p":10,"Integer":2,"windowClosing":1,"end":2,"nextHost":2,"net":2},"constants":{"0":5,"\"netwatch.net\"":1,"\"localhost\"":1,"\"nethost\"":1,"\"Properties error\"":1,"null":3,"\".\"":1,"true":1,"\"Network Watcher\"":1,"\"netwatch.end\"":1,"\"NetWatch.properties\"":1,"\"netwatch.start\"":1},"javaDoc":"","comments":"NOW CONSTRUCT PANELS ONE FOR EACH HOST If arguments use them as hostnames No arguments Can we use properties? None of the above Fall back to localhost All done Pack the Frame and show it UtilGUI centre(f); ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","char"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void setCharAt(int index, char newChar) {\n// The implementation of this method\n// would be left as an exercise for the reader.\n// Hint: compile this code exactly as is before bothering!\n}\n","name":"setCharAt","className":"WolfInStringsClothing","variables":{},"constants":{},"javaDoc":"","comments":"The implementation of this method would be left as an exercise for the reader Hint: compile this code exactly as is before bothering! ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":30,"StringLiteralExpr":6,"FieldAccessExpr":6,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] argv) {\n    System.out.println(\"Java Strings in action:\");\n    // System.out.println(\"An alarm or alert: \\a\");    // not supported\n    System.out.println(\"An alarm entered in Octal: \\007\");\n    System.out.println(\"A tab key: \\t(what comes after)\");\n    System.out.println(\"A newline: \\n(what comes after)\");\n    System.out.println(\"A UniCode character: ȇ\");\n    System.out.println(\"A backslash character: \\\\\");\n}\n","name":"main","className":"StringEscapes","variables":{},"constants":{"\"A newline: \\n(what comes after)\"":1,"\"A UniCode character: ȇ\"":1,"\"An alarm entered in Octal: \\007\"":1,"\"A backslash character: \\\\\"":1,"\"Java Strings in action:\"":1,"\"A tab key: \\t(what comes after)\"":1},"javaDoc":"","comments":"System out println(\"An alarm or alert: \\a\"); // not supported ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"Undent","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"Undent(int n) {\n    nSpaces = n;\n}\n","name":"Undent","className":"Undent","variables":{"nSpaces":1,"n":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":2,"System.err.println":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Undent":1,"int":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":25,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"SwitchStmt":1,"BreakStmt":1,"TryStmt":1,"BlockStmt":2,"SwitchEntryStmt":2,"ForStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] av) {\n    Undent c = new Undent(5);\n    switch(av.length) {\n        case 0:\n            c.process(new BufferedReader(new InputStreamReader(System.in)));\n            break;\n        default:\n            for (int i = 0; i < av.length; i++) try {\n                c.process(new BufferedReader(new FileReader(av[i])));\n            } catch (FileNotFoundException e) {\n                System.err.println(e);\n            }\n    }\n}\n","name":"main","className":"Undent","variables":{"c":3,"av":1,"e":1,"i":4},"constants":{"0":2,"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["BufferedReader"],"returnType":"void","methodCalls":{"length":1,"isWhitespace":1,"readLine":1,"close":1,"charAt":1,"substring":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"String":1,"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":6,"NameExpr":37,"StringLiteralExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":2,"AssignExpr":1,"MethodCallExpr":8},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":6},"text":"/** print one file, given an open BufferedReader */\npublic void process(BufferedReader is) {\n    try {\n        String inputLine;\n        // BEGIN main\n        while ((inputLine = is.readLine()) != null) {\n            int toRemove = 0;\n            for (int i = 0; i < nSpaces && i < inputLine.length() && Character.isWhitespace(inputLine.charAt(i)); i++) ++toRemove;\n            System.out.println(inputLine.substring(toRemove));\n        }\n        // END main\n        is.close();\n    } catch (IOException e) {\n        System.out.println(\"IOException: \" + e);\n    }\n}\n","name":"process","className":"Undent","variables":{"inputLine":5,"toRemove":2,"Character":1,"e":2,"i":4,"is":2,"nSpaces":1},"constants":{"0":2,"null":1,"\"IOException: \"":1},"javaDoc":"print one file given an open BufferedReader","comments":"BEGIN main END main  print one file, given an open BufferedReader ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":2,"System.out.println":1},"annotations":[],"exceptions":["RuntimeException","FileNotFoundException"],"concepts":["ExceptionHandling"],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":5,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":24,"StringLiteralExpr":1,"FieldAccessExpr":3,"AssignExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ForeachStmt":1,"ThrowStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int sum = 0;\n    if (args.length == 0) {\n        sum = CheckSum.process(new BufferedReader(new InputStreamReader(System.in)));\n    } else\n        for (String arg : args) {\n            try {\n                sum += CheckSum.process(new BufferedReader(new FileReader(arg)));\n            } catch (FileNotFoundException e) {\n                throw new RuntimeException(\"File not found: \" + arg, e);\n            }\n        }\n    System.out.println(sum);\n}\n","name":"main","className":"CheckSum","variables":{"args":1,"e":2,"CheckSum":2,"arg":3,"sum":3},"constants":{"0":2,"\"File not found: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["BufferedReader"],"returnType":"int","methodCalls":{"length":1,"readLine":1,"charAt":1},"annotations":[],"exceptions":["RuntimeException","IOException"],"concepts":["ExceptionHandling"],"types":{"String":1,"int":2},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":17,"StringLiteralExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ForStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/** CheckSum one text file, given an open BufferedReader.\n     * Checksumm does not include line endings, so will give the\n     * same value for given text on any platform. Do not use\n     * on binary files!\n     */\npublic static int process(BufferedReader is) {\n    int sum = 0;\n    try {\n        String inputLine;\n        while ((inputLine = is.readLine()) != null) {\n            int i;\n            for (i = 0; i < inputLine.length(); i++) {\n                sum += inputLine.charAt(i);\n            }\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(\"IOException: \" + e);\n    }\n    return sum;\n}\n","name":"process","className":"CheckSum","variables":{"inputLine":4,"e":2,"i":4,"sum":3,"is":1},"constants":{"0":2,"null":1,"\"IOException: \"":1},"javaDoc":"CheckSum one text file given an open BufferedReader Checksumm does not include line endings so will give the same value for given text on any platform Do not use on binary files!","comments":" CheckSum one text file, given an open BufferedReader.\n     * Checksumm does not include line endings, so will give the\n     * same value for given text on any platform. Do not use\n     * on binary files!\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":2,"System.err.println":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Indent":1,"int":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":25,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"SwitchStmt":1,"BreakStmt":1,"TryStmt":1,"BlockStmt":2,"SwitchEntryStmt":2,"ForStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] av) {\n    Indent c = new Indent();\n    switch(av.length) {\n        case 0:\n            c.process(new BufferedReader(new InputStreamReader(System.in)));\n            break;\n        default:\n            for (int i = 0; i < av.length; i++) try {\n                c.process(new BufferedReader(new FileReader(av[i])));\n            } catch (FileNotFoundException e) {\n                System.err.println(e);\n            }\n    }\n}\n","name":"main","className":"Indent","variables":{"c":3,"av":1,"e":1,"i":4},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["BufferedReader"],"returnType":"void","methodCalls":{"readLine":1,"close":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"String":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":27,"StringLiteralExpr":1,"FieldAccessExpr":3,"CharLiteralExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":5},"text":"/** print one file, given an open BufferedReader */\npublic void process(BufferedReader is) {\n    try {\n        String inputLine;\n        // BEGIN main\n        while ((inputLine = is.readLine()) != null) {\n            for (int i = 0; i < nSpaces; i++) System.out.print(' ');\n            System.out.println(inputLine);\n        }\n        // END main\n        is.close();\n    } catch (IOException e) {\n        System.out.println(\"IOException: \" + e);\n    }\n}\n","name":"process","className":"Indent","variables":{"inputLine":2,"e":2,"i":3,"is":2,"nSpaces":1},"constants":{"0":1,"null":1,"\"IOException: \"":1,"' '":1},"javaDoc":"print one file given an open BufferedReader","comments":"BEGIN main END main  print one file, given an open BufferedReader ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toCharArray":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"char":1,"String":1},"expressions":{"VariableDeclarationExpr":2,"StringLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    String s = \"Hello world\";\n    // for (char ch : s) {...} Does not work, in Java 7\n    for (char ch : s.toCharArray()) {\n        System.out.println(ch);\n    }\n}\n","name":"main","className":"ForEachChar","variables":{"s":2,"ch":1},"constants":{"\"Hello world\"":1},"javaDoc":"","comments":"for (char ch : s) { } Does not work in Java 7 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    String sh = \"FCGDAEB\";\n    System.out.println(sh + \" -> \" + new StringBuilder(sh).reverse());\n// END main\n}\n","name":"main","className":"StringRevChar","variables":{"sh":3},"constants":{"\" -> \"":1,"\"FCGDAEB\"":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toLowerCase":1,"equals":1,"toUpperCase":1,"System.err.println":4,"equalsIgnoreCase":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":3,"StringLiteralExpr":9,"NameExpr":50,"FieldAccessExpr":7,"UnaryExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":2,"ExpressionStmt":9},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    String name = \"Java Cookbook\";\n    System.out.println(\"Normal:\\t\" + name);\n    System.out.println(\"Upper:\\t\" + name.toUpperCase());\n    System.out.println(\"Lower:\\t\" + name.toLowerCase());\n    // If it were Java identifiers :-)\n    String javaName = \"java cookBook\";\n    if (!name.equals(javaName))\n        System.err.println(\"equals() correctly reports false\");\n    else\n        System.err.println(\"equals() incorrectly reports true\");\n    if (name.equalsIgnoreCase(javaName))\n        System.err.println(\"equalsIgnoreCase() correctly reports true\");\n    else\n        System.err.println(\"equalsIgnoreCase() incorrectly reports false\");\n// END main\n}\n","name":"main","className":"Case","variables":{"name":6,"javaName":1},"constants":{"\"equals() incorrectly reports true\"":1,"\"equalsIgnoreCase() correctly reports true\"":1,"\"Upper:\\t\"":1,"\"Normal:\\t\"":1,"\"java cookBook\"":1,"\"equalsIgnoreCase() incorrectly reports false\"":1,"\"Java Cookbook\"":1,"\"Lower:\\t\"":1,"\"equals() correctly reports false\"":1},"javaDoc":"","comments":"END main BEGIN main If it were Java identifiers :-) ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":2,"toString":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringAlign":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":24,"StringLiteralExpr":1,"FieldAccessExpr":4,"MethodCallExpr":5},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    // Construct a \"formatter\" to center strings.\n    StringAlign formatter = new StringAlign(70, StringAlign.Justify.CENTER);\n    // Try it out, for page \"i\"\n    System.out.println(formatter.format(\"- i -\"));\n    // Try it out, for page 4. Since this formatter is\n    // optimized for Strings, not specifically for page numbers,\n    // we have to convert the number to a String\n    System.out.println(formatter.format(Integer.toString(4)));\n}\n","name":"main","className":"StringAlignSimple","variables":{"formatter":3,"Integer":1},"constants":{"\"- i -\"":1,"4":1,"70":1},"javaDoc":"","comments":"Try it out for page 4 Since this formatter is optimized for Strings not specifically for page numbers Construct a \"formatter\" to center strings Try it out for page \"i\" we have to convert the number to a String ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{"getTabSpacing":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * Delegate tab spacing information to tabs.\n     */\npublic int getTabSpacing() {\n    return tabs.getTabSpacing();\n}\n","name":"getTabSpacing","className":"EnTab","variables":{"tabs":1},"constants":{},"javaDoc":"Delegate tab spacing information to tabs","comments":"\n     * Delegate tab spacing information to tabs.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"entab":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"EnTab":1,"String":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":20,"FieldAccessExpr":4,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":3},"text":"/**\n     * Main program: just create an EnTab object, and pass the standard input\n     * or the named file(s) through it.\n     */\npublic static void main(String[] argv) throws IOException {\n    EnTab et = new EnTab(8);\n    if (// do standard input\n    argv.length == 0)\n        et.entab(new BufferedReader(new InputStreamReader(System.in)), System.out);\n    else\n        for (String fileName : argv) {\n            // do each file\n            et.entab(new BufferedReader(new FileReader(fileName)), System.out);\n        }\n}\n","name":"main","className":"EnTab","variables":{"fileName":2,"argv":1,"et":3},"constants":{"0":1,"8":1},"javaDoc":"Main program: just create an EnTab object and pass the standard input or the named file(s) through it","comments":"do standard input do each file \n     * Main program: just create an EnTab object, and pass the standard input\n     * or the named file(s) through it.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"EnTab","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Constructor: just save the tab values.\n     * \n     * @param n\n     *            The number of spaces each tab is to replace.\n     */\npublic EnTab(int n) {\n    tabs = new Tabs(n);\n}\n","name":"EnTab","className":"EnTab","variables":{"tabs":1,"n":1},"constants":{},"javaDoc":"Constructor: just save the tab values n The number of spaces each tab is to replace","comments":"\n     * Constructor: just save the tab values.\n     * \n     * @param n\n     *            The number of spaces each tab is to replace.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"EnTab","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public EnTab() {\n    tabs = new Tabs();\n}\n","name":"EnTab","className":"EnTab","variables":{"tabs":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BufferedReader","PrintWriter"],"returnType":"void","methodCalls":{"println":1,"entabLine":1,"readLine":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n     * entab: process one file, replacing blanks with tabs.\n     * \n     * @param is A BufferedReader opened to the file to be read.\n     * @param out a PrintWriter to send the output to.\n     */\npublic void entab(BufferedReader is, PrintWriter out) throws IOException {\n    String line;\n    // main loop: process entire file one line at a time.\n    while ((line = is.readLine()) != null) {\n        out.println(entabLine(line));\n    }\n}\n","name":"entab","className":"EnTab","variables":{"line":2,"is":1,"out":1},"constants":{"null":1},"javaDoc":"entab: process one file replacing blanks with tabs is A BufferedReader opened to the file to be read out a PrintWriter to send the output to","comments":"main loop: process entire file one line at a time \n     * entab: process one file, replacing blanks with tabs.\n     * \n     * @param is A BufferedReader opened to the file to be read.\n     * @param out a PrintWriter to send the output to.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BufferedReader","PrintStream"],"returnType":"void","methodCalls":{"entab":1},"annotations":[],"exceptions":["IOException"],"concepts":["Recursion"],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * entab: process one file, replacing blanks with tabs.\n     * \n     * @param is A BufferedReader opened to the file to be read.\n     * @param out A PrintStream to write the output to.\n     */\npublic void entab(BufferedReader is, PrintStream out) throws IOException {\n    entab(is, new PrintWriter(out));\n}\n","name":"entab","className":"EnTab","variables":{"out":1},"constants":{},"javaDoc":"entab: process one file replacing blanks with tabs is A BufferedReader opened to the file to be read out A PrintStream to write the output to","comments":"\n     * entab: process one file, replacing blanks with tabs.\n     * \n     * @param is A BufferedReader opened to the file to be read.\n     * @param out A PrintStream to write the output to.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"println":4,"length":1,"toString":1,"isTabStop":1,"charAt":1,"append":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"char":1,"int":4},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":9,"NameExpr":59,"StringLiteralExpr":8,"CharLiteralExpr":4,"UnaryExpr":6,"MethodCallExpr":12,"AssignExpr":3},"statements":{"ContinueStmt":1,"IfStmt":2,"WhileStmt":1,"BlockStmt":6,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":18},"text":"/**\n     * entabLine: process one line, replacing blanks with tabs.\n     * \n     * @param line -\n     *            the string to be processed\n     */\npublic String entabLine(String line) {\n    int N = line.length(), outCol = 0;\n    StringBuffer sb = new StringBuffer();\n    char ch;\n    int consumedSpaces = 0;\n    for (int inCol = 0; inCol < N; inCol++) {\n        ch = line.charAt(inCol);\n        // If this takes us to a tab stop, output a tab character.\n        if (ch == ' ') {\n            Debug.println(\"space\", \"Got space at \" + inCol);\n            if (!tabs.isTabStop(inCol)) {\n                consumedSpaces++;\n            } else {\n                Debug.println(\"tab\", \"Got a Tab Stop \" + inCol);\n                sb.append('\\t');\n                outCol += consumedSpaces;\n                consumedSpaces = 0;\n            }\n            continue;\n        }\n        // them above.\n        while (inCol - 1 > outCol) {\n            Debug.println(\"pad\", \"Padding space at \" + inCol);\n            sb.append(' ');\n            outCol++;\n        }\n        // Now we have a plain character to output.\n        sb.append(ch);\n        outCol++;\n    }\n    // If line ended with trailing (or only!) spaces, preserve them.\n    for (int i = 0; i < consumedSpaces; i++) {\n        Debug.println(\"trail\", \"Padding space at end # \" + i);\n        sb.append(' ');\n    }\n    return sb.toString();\n}\n             // If we get a space, consume it, don't output it.\n\n             // We're at a non-space; if we're just past a tab stop, we need\n\n             // to put the \"leftover\" spaces back out, since we consumed\n\n","name":"entabLine","className":"EnTab","variables":{"inCol":7,"outCol":5,"ch":3,"line":2,"tabs":1,"i":4,"N":2,"Debug":4,"sb":6,"consumedSpaces":5},"constants":{"0":5,"1":1,"\"pad\"":1,"\"trail\"":1,"\"space\"":1,"\"Got space at \"":1,"\"tab\"":1,"'\\t'":1,"\"Got a Tab Stop \"":1,"\"Padding space at \"":1,"' '":3,"\"Padding space at end # \"":1},"javaDoc":"entabLine: process one line replacing blanks with tabs line - the string to be processed","comments":"If we get a space consume it don't output it We're at a non-space; if we're just past a tab stop we need to put the \"leftover\" spaces back out since we consumed If this takes us to a tab stop output a tab character them above Now we have a plain character to output If line ended with trailing (or only!) spaces preserve them \n     * entabLine: process one line, replacing blanks with tabs.\n     * \n     * @param line -\n     *            the string to be processed\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":1,"substring":3,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":4},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"StringLiteralExpr":1,"NameExpr":36,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] av) {\n    String a = \"Java is great.\";\n    System.out.println(a);\n    // b is the String \"is great.\"\n    String b = a.substring(5);\n    System.out.println(b);\n    // c is the String \"is\"\n    String c = a.substring(5, 7);\n    System.out.println(c);\n    // d is \"is great.\"\n    String d = a.substring(5, a.length());\n    System.out.println(d);\n}\n","name":"main","className":"SubStringDemo","variables":{"a":5,"b":1,"c":1,"d":1},"constants":{"5":3,"7":1,"\"Java is great.\"":1},"javaDoc":"","comments":"b is the String \"is great \" c is the String \"is\" d is \"is great \" ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String[]","methodCalls":{"hasMoreTokens":1,"nextToken":1,"equals":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"StringTokenizer":1,"String[]":1,"String":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":2,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ContinueStmt":1,"IfStmt":2,"WhileStmt":1,"BlockStmt":2,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** Processes one String, returns it as an array of Strings */\npublic static String[] process(String line) {\n    String[] results = new String[MAXFIELDS];\n    // Unless you ask StringTokenizer to give you the tokens,\n    // it silently discards multiple null tokens.\n    StringTokenizer st = new StringTokenizer(line, DELIM, true);\n    int i = 0;\n    // stuff each token into the current slot in the array.\n    while (st.hasMoreTokens()) {\n        String s = st.nextToken();\n        if (s.equals(DELIM)) {\n            if (i++ >= MAXFIELDS)\n                // a List to allow any number of fields.\n                throw new IllegalArgumentException(\"Input line \" + line + \" has too many fields\");\n            continue;\n        }\n        results[i] = s;\n    }\n    return results;\n}\n                     // This is messy: See StrTokDemo4b which uses \n\n","name":"process","className":"StrTokDemo4","variables":{"st":3,"DELIM":1,"MAXFIELDS":2,"s":3,"line":2,"i":3,"results":3},"constants":{"0":1,"\" has too many fields\"":1,"true":1,"\"Input line \"":1},"javaDoc":"Processes one String returns it as an array of Strings","comments":"Unless you ask StringTokenizer to give you the tokens it silently discards multiple null tokens stuff each token into the current slot in the array This is messy: See StrTokDemo4b which uses a List to allow any number of fields  Processes one String, returns it as an array of Strings ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String[]"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":14,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"ForeachStmt":1,"ExpressionStmt":2},"text":"public static void printResults(String input, String[] outputs) {\n    System.out.println(\"Input: \" + input);\n    for (String s : outputs) System.out.println(\"Output \" + s + \" was: \" + s);\n}\n","name":"printResults","className":"StrTokDemo4","variables":{"outputs":1,"input":1,"s":3},"constants":{"\"Output \"":1,"\"Input: \"":1,"\" was: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":3,"printResults":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"StringLiteralExpr":6,"MethodCallExpr":6},"statements":{"ExpressionStmt":3},"text":"// Should be a JUnit test but is referred to in the book text,\n// so I can't move it to \"tests\" until the next edit.\npublic static void main(String[] a) {\n    printResults(\"A|B|C|D\", process(\"A|B|C|D\"));\n    printResults(\"A||C|D\", process(\"A||C|D\"));\n    printResults(\"A|||D|E\", process(\"A|||D|E\"));\n}\n","name":"main","className":"StrTokDemo4","variables":{},"constants":{"\"A|B|C|D\"":2,"\"A|||D|E\"":2,"\"A||C|D\"":2},"javaDoc":"","comments":" so I can't move it to \"tests\" until the next edit.","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"split":1,"hasMoreElements":2,"nextToken":1,"length":1,"append":4,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringTokenizer":1,"StringBuilder":2,"String":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":41,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ForeachStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    // BEGIN main\n    // Method using regexp split \n    StringBuilder sb1 = new StringBuilder();\n    for (String word : SAMPLE_STRING.split(\" \")) {\n        if (sb1.length() > 0) {\n            sb1.append(\", \");\n        }\n        sb1.append(word);\n    }\n    System.out.println(sb1);\n    // Method using a StringTokenizer\n    StringTokenizer st = new StringTokenizer(SAMPLE_STRING);\n    StringBuilder sb2 = new StringBuilder();\n    while (st.hasMoreElements()) {\n        sb2.append(st.nextToken());\n        if (st.hasMoreElements()) {\n            sb2.append(\", \");\n        }\n    }\n    System.out.println(sb2);\n// END main\n}\n","name":"main","className":"StringBuilderCommaList","variables":{"st":4,"sb2":3,"sb1":4,"SAMPLE_STRING":2,"word":1},"constants":{"0":1,"\" \"":1,"\", \"":2},"javaDoc":"","comments":"BEGIN main END main Method using regexp split Method using a StringTokenizer ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":1,"length":1,"append":5,"charAt":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"char":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":43,"StringLiteralExpr":2,"CastExpr":1,"CharLiteralExpr":6,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":10},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":8},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    // UnicodeChars.java\n    StringBuffer b = new StringBuffer();\n    for (char c = 'a'; c < 'd'; c++) {\n        b.append(c);\n    }\n    // Japanese Yen symbol\n    b.append('¥');\n    // Roman AE with acute accent\n    b.append('Ǽ');\n    // GREEK Capital Alpha\n    b.append('Α');\n    // GREEK Capital Omega\n    b.append('Ω');\n    for (int i = 0; i < b.length(); i++) {\n        System.out.printf(\"Character #%d (%04x) is %c%n\", i, (int) b.charAt(i), b.charAt(i));\n    }\n    System.out.println(\"Accumulated characters are \" + b);\n// END main\n}\n","name":"main","className":"UnicodeChars","variables":{"b":10,"c":3,"i":3},"constants":{"0":1,"\"Accumulated characters are \"":1,"'Ǽ'":1,"'Ω'":1,"'¥'":1,"'d'":1,"'Α'":1,"\"Character #%d (%04x) is %c%n\"":1,"'a'":1},"javaDoc":"","comments":"BEGIN main END main UnicodeChars java Japanese Yen symbol Roman AE with acute accent GREEK Capital Alpha GREEK Capital Omega ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","Justify"],"returnType":"StringAlign","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":1,"BlockStmt":1,"SwitchEntryStmt":4,"ThrowStmt":2,"ExpressionStmt":2},"text":"/** Construct a StringAlign formatter; length and alignment are\n     * passed to the Constructor instead of each format() call as the\n     * expected common use is in repetitive formatting e.g., page numbers.\n     * @param maxChars - the maximum length of the output\n     * @param just - one of the enum values LEFT, CENTER or RIGHT\n     */\npublic StringAlign(int maxChars, Justify just) {\n    switch(just) {\n        case LEFT:\n        case CENTER:\n        case RIGHT:\n            this.just = just;\n            break;\n        default:\n            throw new IllegalArgumentException(\"invalid justification arg.\");\n    }\n    if (maxChars < 0) {\n        throw new IllegalArgumentException(\"maxChars must be positive.\");\n    }\n    this.maxChars = maxChars;\n}\n","name":"StringAlign","className":"StringAlign","variables":{"CENTER":1,"LEFT":1,"RIGHT":1,"maxChars":2,"just":2},"constants":{"0":1,"\"invalid justification arg.\"":1,"\"maxChars must be positive.\"":1},"javaDoc":"Construct a StringAlign formatter; length and alignment are passed to the Constructor instead of each format() call as the expected common use is in repetitive formatting e g page numbers maxChars - the maximum length of the output just - one of the enum values LEFT CENTER or RIGHT","comments":" Construct a StringAlign formatter; length and alignment are\n     * passed to the Constructor instead of each format() call as the\n     * expected common use is in repetitive formatting e.g., page numbers.\n     * @param maxChars - the maximum length of the output\n     * @param just - one of the enum values LEFT, CENTER or RIGHT\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","StringBuffer","FieldPosition"],"returnType":"StringBuffer","methodCalls":{"pad":4,"min":1,"length":4,"toString":1,"substring":1,"append":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":6,"NameExpr":57,"MethodCallExpr":14},"statements":{"SwitchStmt":1,"BreakStmt":3,"SwitchEntryStmt":3,"ReturnStmt":1,"ExpressionStmt":10},"text":"/** Format a String.\n     * @param input - the string to be aligned.\n     * @parm where - the StringBuffer to append it to.\n     * @param ignore - a FieldPosition (may be null, not used but\n     * specified by the general contract of Format).\n     */\npublic StringBuffer format(Object input, StringBuffer where, FieldPosition ignore) {\n    String s = input.toString();\n    String wanted = s.substring(0, Math.min(s.length(), maxChars));\n    // Get the spaces in the right place.\n    switch(just) {\n        case RIGHT:\n            pad(where, maxChars - wanted.length());\n            where.append(wanted);\n            break;\n        case CENTER:\n            int toAdd = maxChars - wanted.length();\n            pad(where, toAdd / 2);\n            where.append(wanted);\n            pad(where, toAdd - toAdd / 2);\n            break;\n        case LEFT:\n            where.append(wanted);\n            pad(where, maxChars - wanted.length());\n            break;\n    }\n    return where;\n}\n","name":"format","className":"StringAlign","variables":{"CENTER":1,"toAdd":4,"input":1,"s":3,"wanted":4,"LEFT":1,"RIGHT":1,"maxChars":3,"where":4,"Math":1,"just":1},"constants":{"0":1,"2":2},"javaDoc":"Format a String input - the string to be aligned @parm where - the StringBuffer to append it to ignore - a FieldPosition (may be null not used but specified by the general contract of Format)","comments":"Get the spaces in the right place  Format a String.\n     * @param input - the string to be aligned.\n     * @parm where - the StringBuffer to append it to.\n     * @param ignore - a FieldPosition (may be null, not used but\n     * specified by the general contract of Format).\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["StringBuffer","int"],"returnType":"void","methodCalls":{"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":6,"CharLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"protected final void pad(StringBuffer to, int howMany) {\n    for (int i = 0; i < howMany; i++) to.append(' ');\n}\n","name":"pad","className":"StringAlign","variables":{"i":3,"to":1,"howMany":1},"constants":{"0":1,"' '":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":20}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"format":1,"toString":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** Convenience Routine */\nString format(String s) {\n    return format(s, new StringBuffer(), null).toString();\n}\n","name":"format","className":"StringAlign","variables":{},"constants":{"null":1},"javaDoc":"Convenience Routine","comments":" Convenience Routine ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String","ParsePosition"],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** ParseObject is required, but not useful here. */\npublic Object parseObject(String source, ParsePosition pos) {\n    return source;\n}\n","name":"parseObject","className":"StringAlign","variables":{"source":1},"constants":{},"javaDoc":"ParseObject is required but not useful here","comments":" ParseObject is required, but not useful here. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":1,"charAt":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":15,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] av) {\n    String a = \"A quick bronze fox lept a lazy bovine\";\n    for (// Don't use foreach\n    int i = 0; // Don't use foreach\n    i < a.length(); // Don't use foreach\n    i++) System.out.println(\"Char \" + i + \" is \" + a.charAt(i));\n}\n","name":"main","className":"StrCharAt","variables":{"a":3,"i":4},"constants":{"0":1,"\"A quick bronze fox lept a lazy bovine\"":1,"\" is \"":1,"\"Char \"":1},"javaDoc":"","comments":"Don't use foreach Don't use foreach Don't use foreach ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":1,"hasMoreTokens":1,"nextToken":1,"push":1,"System.out.print":3,"empty":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Stack<String>":1,"StringTokenizer":1,"String":1,"Stack":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":37,"FieldAccessExpr":4,"CharLiteralExpr":4,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"WhileStmt":2,"BlockStmt":2,"ExpressionStmt":8},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    String s = \"Father Charles Goes Down And Ends Battle\";\n    // Put it in the stack frontwards\n    Stack<String> myStack = new Stack<>();\n    StringTokenizer st = new StringTokenizer(s);\n    while (st.hasMoreTokens()) {\n        myStack.push(st.nextToken());\n    }\n    // Print the stack backwards\n    System.out.print('\"' + s + '\"' + \" backwards by word is:\\n\\t\\\"\");\n    while (!myStack.empty()) {\n        System.out.print(myStack.pop());\n        System.out.print(' ');\n    }\n    System.out.println('\"');\n// END main\n}\n","name":"main","className":"StringReverse","variables":{"st":3,"s":3,"myStack":4},"constants":{"\"Father Charles Goes Down And Ends Battle\"":1,"\" backwards by word is:\\n\\t\\\"\"":1,"'\"'":3,"' '":1},"javaDoc":"","comments":"END main BEGIN main Put it in the stack frontwards Print the stack backwards ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"toUpperCase":1,"length":4,"toString":1,"charAt":1,"append":3,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"char":2,"String":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":6,"ArrayAccessExpr":1,"BinaryExpr":19,"NameExpr":60,"StringLiteralExpr":1,"CharLiteralExpr":8,"UnaryExpr":2,"AssignExpr":3,"NullLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":5,"BlockStmt":6,"ForStmt":2,"ReturnStmt":2,"ExpressionStmt":10},"text":"/** Convert the given String to its Soundex code.\n     * @return null If the given string can't be mapped to Soundex.\n     */\npublic static String soundex(String s) {\n    // Algorithm works on uppercase (mainframe era).\n    String t = s.toUpperCase();\n    StringBuffer res = new StringBuffer();\n    char c, prev = '?', prevOutput = '?';\n    // Main loop: find up to 4 chars that map.\n    for (int i = 0; i < t.length() && res.length() < 4 && (c = t.charAt(i)) != ','; i++) {\n        // Also, skip double letters.\n        if (c >= 'A' && c <= 'Z' && c != prev) {\n            prev = c;\n            // First char is installed unchanged, for sorting.\n            if (i == 0) {\n                res.append(c);\n            } else {\n                char m = MAP[c - 'A'];\n                if (debug) {\n                    System.out.println(c + \" --> \" + m);\n                }\n                if (m != '0' && m != prevOutput) {\n                    res.append(m);\n                    prevOutput = m;\n                }\n            }\n        }\n    }\n    if (res.length() == 0)\n        return null;\n    for (int i = res.length(); i < 4; i++) res.append('0');\n    return res.toString();\n}\n             // Check to see if the given character is alphabetic.\n\n             // Text is already converted to uppercase. Algorithm\n\n             // only handles ASCII letters, do NOT use Character.isLetter()!\n\n","name":"soundex","className":"Soundex","variables":{"res":8,"prevOutput":3,"s":1,"c":8,"debug":1,"t":3,"prev":3,"i":7,"m":5,"MAP":1},"constants":{"0":3,"','":1,"4":2,"'Z'":1,"null":1,"\" --> \"":1,"'A'":2,"'0'":2,"'?'":2},"javaDoc":"Convert the given String to its Soundex code null If the given string can't be mapped to Soundex","comments":"Algorithm works on uppercase (mainframe era) Main loop: find up to 4 chars that map Check to see if the given character is alphabetic Text is already converted to uppercase Algorithm only handles ASCII letters do NOT use Character isLetter()! Also skip double letters First char is installed unchanged for sorting  Convert the given String to its Soundex code.\n     * @return null If the given string can't be mapped to Soundex.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":1,"append":7,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuilder":1,"String":2},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":2,"StringLiteralExpr":7,"NameExpr":40,"FieldAccessExpr":3,"CharLiteralExpr":4,"MethodCallExpr":12},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] argv) {\n    String s1 = \"Hello\" + \", \" + \"World\";\n    System.out.println(s1);\n    // Build a StringBuilder, and append some things to it.\n    StringBuilder sb2 = new StringBuilder();\n    sb2.append(\"Hello\");\n    sb2.append(',');\n    sb2.append(' ');\n    sb2.append(\"World\");\n    // Get the StringBuilder's value as a String, and print it.\n    String s2 = sb2.toString();\n    System.out.println(s2);\n    // Now do the above all over again, but in a more \n    // concise (and typical \"real-world\" Java) fashion.\n    System.out.println(new StringBuilder().append(\"Hello\").append(',').append(' ').append(\"World\"));\n}\n","name":"main","className":"StringBuilderDemo","variables":{"sb2":6,"s1":1,"s2":1},"constants":{"\"Hello\"":3,"','":2,"\"World\"":3,"\", \"":1,"' '":2},"javaDoc":"","comments":"Now do the above all over again but in a more concise (and typical \"real-world\" Java) fashion Build a StringBuilder and append some things to it Get the StringBuilder's value as a String and print it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"/** If files present, format each, else format the standard input. */\npublic static void main(String[] av) throws IOException {\n    if (av.length == 0)\n        new Fmt(System.in).format();\n    else\n        for (String name : av) {\n            new Fmt(name).format();\n        }\n}\n","name":"main","className":"Fmt","variables":{"av":1,"name":2},"constants":{"0":1},"javaDoc":"If files present format each else format the standard input","comments":" If files present, format each, else format the standard input. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["BufferedReader","PrintWriter"],"returnType":"Fmt","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Fmt(BufferedReader inFile, PrintWriter outFile) {\n    this.in = inFile;\n    this.out = outFile;\n}\n","name":"Fmt","className":"Fmt","variables":{"outFile":1,"inFile":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter"],"returnType":"Fmt","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":4,"FieldAccessExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public Fmt(PrintWriter out) {\n    this(new BufferedReader(new InputStreamReader(System.in)), out);\n}\n","name":"Fmt","className":"Fmt","variables":{"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BufferedReader"],"returnType":"Fmt","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a Formatter given an open Reader */\npublic Fmt(BufferedReader file) throws IOException {\n    this(file, new PrintWriter(System.out));\n}\n","name":"Fmt","className":"Fmt","variables":{"file":1},"constants":{},"javaDoc":"Construct a Formatter given an open Reader","comments":" Construct a Formatter given an open Reader ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Fmt","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a Formatter given a filename */\npublic Fmt(String fname) throws IOException {\n    this(new BufferedReader(new FileReader(fname)));\n}\n","name":"Fmt","className":"Fmt","variables":{"fname":1},"constants":{},"javaDoc":"Construct a Formatter given a filename","comments":" Construct a Formatter given a filename ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream"],"returnType":"Fmt","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a Formatter given an open Stream */\npublic Fmt(InputStream file) throws IOException {\n    this(new BufferedReader(new InputStreamReader(file)));\n}\n","name":"Fmt","className":"Fmt","variables":{"file":1},"constants":{},"javaDoc":"Construct a Formatter given an open Stream","comments":" Construct a Formatter given an open Stream ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"println":5,"setLength":2,"hasMoreTokens":1,"nextToken":1,"length":4,"readLine":1,"append":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"StringTokenizer":1,"StringBuilder":1,"String":2},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":5,"NameExpr":54,"CharLiteralExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":16},"statements":{"IfStmt":3,"WhileStmt":2,"BlockStmt":7,"ExpressionStmt":12},"text":"/** Format the File contained in a constructed Fmt object */\npublic void format() throws IOException {\n    String line;\n    StringBuilder outBuf = new StringBuilder();\n    while ((line = in.readLine()) != null) {\n        if (line.length() == 0) {\n            // null line\n            // end current line\n            out.println(outBuf);\n            // output blank line\n            out.println();\n            outBuf.setLength(0);\n        } else {\n            // otherwise it's text, so format it.\n            StringTokenizer st = new StringTokenizer(line);\n            while (st.hasMoreTokens()) {\n                String word = st.nextToken();\n                // first dump out anything previous.\n                if (outBuf.length() + word.length() > COLWIDTH) {\n                    out.println(outBuf);\n                    outBuf.setLength(0);\n                }\n                outBuf.append(word).append(' ');\n            }\n        }\n    }\n    if (outBuf.length() > 0) {\n        out.println(outBuf);\n    } else {\n        out.println();\n    }\n}\n                     // If this word would go past the margin,\n\n","name":"format","className":"Fmt","variables":{"st":3,"COLWIDTH":1,"outBuf":6,"in":1,"line":4,"word":2,"out":5},"constants":{"0":4,"null":1,"' '":1},"javaDoc":"Format the File contained in a constructed Fmt object","comments":"null line end current line output blank line otherwise it's text so format it If this word would go past the margin first dump out anything previous  Format the File contained in a constructed Fmt object ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"detab":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"DeTab":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) throws IOException {\n    DeTab dt = new DeTab(8);\n    dt.detab(new BufferedReader(new InputStreamReader(System.in)), new PrintWriter(System.out));\n}\n","name":"main","className":"DeTab","variables":{"dt":2},"constants":{"8":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"DeTab","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public DeTab(int n) {\n    ts = new Tabs(n);\n}\n","name":"DeTab","className":"DeTab","variables":{"n":1,"ts":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"DeTab","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public DeTab() {\n    ts = new Tabs();\n}\n","name":"DeTab","className":"DeTab","variables":{"ts":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BufferedReader","PrintWriter"],"returnType":"void","methodCalls":{"println":1,"readLine":1,"detabLine":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/** detab one file (replace tabs with spaces)\n     * @param is - the file to be processed\n     * @param out - the updated file\n     */\npublic void detab(BufferedReader is, PrintWriter out) throws IOException {\n    String line;\n    while ((line = is.readLine()) != null) {\n        out.println(detabLine(line));\n    }\n}\n","name":"detab","className":"DeTab","variables":{"line":2,"is":1,"out":1},"constants":{"null":1},"javaDoc":"detab one file (replace tabs with spaces) is - the file to be processed out - the updated file","comments":" detab one file (replace tabs with spaces)\n     * @param is - the file to be processed\n     * @param out - the updated file\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"length":1,"toString":1,"isTabStop":1,"charAt":1,"append":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"char":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":26,"CharLiteralExpr":2,"EnclosedExpr":1,"UnaryExpr":4,"AssignExpr":2,"MethodCallExpr":6},"statements":{"ContinueStmt":1,"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":7,"DoStmt":1},"text":"/** detab one line (replace tabs with spaces)\n     * @param line - the line to be processed\n     * @return the updated line\n     */\npublic String detabLine(String line) {\n    char c;\n    int col;\n    StringBuffer sb = new StringBuffer();\n    col = 0;\n    for (int i = 0; i < line.length(); i++) {\n        // Either ordinary character or tab.\n        if ((c = line.charAt(i)) != '\\t') {\n            // Ordinary\n            sb.append(c);\n            ++col;\n            continue;\n        }\n        do {\n            // Tab, expand it, must put >=1 space\n            sb.append(' ');\n        } while (!ts.isTabStop(++col));\n    }\n    return sb.toString();\n}\n","name":"detabLine","className":"DeTab","variables":{"col":4,"c":2,"line":2,"i":3,"sb":4,"ts":1},"constants":{"0":2,"'\\t'":1,"' '":1},"javaDoc":"detab one line (replace tabs with spaces) line - the line to be processed the updated line","comments":"Either ordinary character or tab Ordinary Tab expand it must put >=1 space  detab one line (replace tabs with spaces)\n     * @param line - the line to be processed\n     * @return the updated line\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"soundex":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"String":1},"expressions":{"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"BinaryExpr":2,"StringLiteralExpr":4,"NameExpr":11,"FieldAccessExpr":1,"CharLiteralExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"/** main */\npublic static void main(String[] args) {\n    String[] names = { \"Darwin, Ian\", \"Davidson, Greg\", \"Darwent, William\", \"Derwin, Daemon\" };\n    for (String name : names) {\n        System.out.println(Soundex.soundex(name) + ' ' + name);\n    }\n}\n","name":"main","className":"SoundexSimple","variables":{"Soundex":1,"names":2,"name":2},"constants":{"\"Darwent, William\"":1,"\"Derwin, Daemon\"":1,"\"Davidson, Greg\"":1,"' '":1,"\"Darwin, Ian\"":1},"javaDoc":"main","comments":" main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"Tabs","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/** Construct a Tabs object with a given tab stop settings */\npublic Tabs(int n) {\n    if (n <= 0) {\n        n = 1;\n    }\n    tabSpace = n;\n}\n","name":"Tabs","className":"Tabs","variables":{"tabSpace":1,"n":3},"constants":{"0":1,"1":1},"javaDoc":"Construct a Tabs object with a given tab stop settings","comments":" Construct a Tabs object with a given tab stop settings ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Tabs","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a Tabs object with a default tab stop settings */\npublic Tabs() {\n    this(DEFTABSPACE);\n}\n","name":"Tabs","className":"Tabs","variables":{"DEFTABSPACE":1},"constants":{},"javaDoc":"Construct a Tabs object with a default tab stop settings","comments":" Construct a Tabs object with a default tab stop settings ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * @return Returns the tabSpace.\n     */\npublic int getTabSpacing() {\n    return tabSpace;\n}\n","name":"getTabSpacing","className":"Tabs","variables":{"tabSpace":1},"constants":{},"javaDoc":"Returns the tabSpace","comments":"\n     * @return Returns the tabSpace.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":4,"BooleanLiteralExpr":1,"NameExpr":3,"EnclosedExpr":1},"statements":{"IfStmt":1,"ReturnStmt":2},"text":"/** isTabStop - returns true if given column is a tab stop.\n     * @param col - the current column number\n     */\npublic boolean isTabStop(int col) {\n    if (col <= 0)\n        return false;\n    return (col + 1) % tabSpace == 0;\n}\n","name":"isTabStop","className":"Tabs","variables":{"col":2,"tabSpace":1},"constants":{"0":2,"1":1,"false":1},"javaDoc":"isTabStop - returns true if given column is a tab stop col - the current column number","comments":" isTabStop - returns true if given column is a tab stop.\n     * @param col - the current column number\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getActionCommand":1,"do_the_work":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":7,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"/*  Button - toggle the state of the \"requested\" flag, to draw or\n             *  not to draw.\n             */\npublic void actionPerformed(ActionEvent e) {\n    String arg = e.getActionCommand();\n    // Invert the state of the draw request.\n    requested = !requested;\n    do_the_work();\n}\n","name":"actionPerformed","className":"","variables":{"requested":2,"e":1,"arg":1},"constants":{},"javaDoc":"","comments":"Invert the state of the draw request   Button - toggle the state of the \"requested\" flag, to draw or\n             *  not to draw.\n             ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"addActionListener":1,"getContentPane":1,"setLayout":1,"getActionCommand":1,"do_the_work":1,"getParameter":1},"annotations":[],"exceptions":[],"concepts":["Casting","InnerMethod"],"types":{"Container":1,"JButton":1,"String":2},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":27,"CastExpr":1,"StringLiteralExpr":2,"UnaryExpr":1,"AssignExpr":4,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":11},"text":"/** init() is an Applet method called by the browser to initialize */\npublic void init() {\n    JButton b;\n    requested = false;\n    Container cp = (Container) getContentPane();\n    cp.setLayout(new FlowLayout());\n    String buttonLabel = getParameter(\"buttonlabel\");\n    if (buttonLabel == null) {\n        buttonLabel = \"Draw/Don't Draw\";\n    }\n    cp.add(b = new JButton(buttonLabel));\n    b.addActionListener(new ActionListener() {\n\n        /*  Button - toggle the state of the \"requested\" flag, to draw or\n             *  not to draw.\n             */\n        public void actionPerformed(ActionEvent e) {\n            String arg = e.getActionCommand();\n            // Invert the state of the draw request.\n            requested = !requested;\n            do_the_work();\n        }\n    });\n}\n","name":"init","className":"HelloApplet","variables":{"actionPerformed":1,"b":3,"requested":3,"e":2,"arg":1,"cp":3,"buttonLabel":4},"constants":{"null":1,"\"Draw/Don't Draw\"":1,"\"buttonlabel\"":1,"false":1},"javaDoc":"init() is an Applet method called by the browser to initialize","comments":"Button - toggle the state of the \"requested\" flag to draw or not to draw Invert the state of the draw request  init() is an Applet method called by the browser to initialize ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showStatus":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"/** paint() is an AWT Component method, called when the \n     *  component needs to be painted.\n     */\npublic void do_the_work() {\n    /* If the Draw button is selected, draw something */\n    if (requested) {\n        showStatus(\"Welcome to Java!\");\n    } else {\n        // retract welcome? :-)\n        showStatus(\"\");\n    }\n}\n","name":"do_the_work","className":"HelloApplet","variables":{"requested":1},"constants":{"\"\"":1,"\"Welcome to Java!\"":1},"javaDoc":"paint() is an AWT Component method called when the component needs to be painted","comments":"If the Draw button is selected draw something retract welcome? :-)  paint() is an AWT Component method, called when the \n     *  component needs to be painted.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new GetResourceDemo().demo();\n}\n","name":"main","className":"GetResourceDemo","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"load":1,"getResourceAsStream":1,"getClassLoader":1,"System.err.println":2,"list":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"InputStream":1,"ClassLoader":1,"Properties":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":29,"StringLiteralExpr":3,"FieldAccessExpr":3,"ThisExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":2,"ExpressionStmt":7},"text":"/** The demo itself */\npublic void demo() {\n    // BEGIN main\n    // Find the ClassLoader that loaded us.\n    // Regard it as the One True ClassLoader for this app.\n    ClassLoader loader = this.getClass().getClassLoader();\n    // Use the loader's getResource() method to open the file.\n    InputStream is = loader.getResourceAsStream(\"widgets.properties\");\n    if (is == null) {\n        System.err.println(\"Can't load properties file\");\n        return;\n    }\n    // Create a Properties object\n    Properties p = new Properties();\n    // Load the properties file into the Properties object\n    try {\n        p.load(is);\n    } catch (IOException ex) {\n        System.err.println(\"Load failed: \" + ex);\n        return;\n    }\n    // List it to confirm that we loaded it.\n    p.list(System.out);\n// END main\n}\n","name":"demo","className":"GetResourceDemo","variables":{"p":3,"ex":2,"loader":2,"is":2},"constants":{"\"widgets.properties\"":1,"null":1,"\"Load failed: \"":1,"\"Can't load properties file\"":1},"javaDoc":"The demo itself","comments":"BEGIN main Find the ClassLoader that loaded us END main Regard it as the One True ClassLoader for this app Use the loader's getResource() method to open the file Create a Properties object Load the properties file into the Properties object List it to confirm that we loaded it  The demo itself ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int add(int a, int b) {\n    System.out.println(\"CalcImpl.add()\");\n    return a + b;\n}\n","name":"add","className":"Calc","variables":{"a":1,"b":1},"constants":{"\"CalcImpl.add()\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"// The other three methods are pretty simple too\n// END main\npublic int subtract(int a, int b) {\n    System.out.println(\"CalcImpl.subtract()\");\n    return a - b;\n}\n","name":"subtract","className":"Calc","variables":{"a":1,"b":1},"constants":{"\"CalcImpl.subtract()\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int multiply(int a, int b) {\n    System.out.println(\"CalcImpl.multiply()\");\n    return a * b;\n}\n","name":"multiply","className":"Calc","variables":{"a":1,"b":1},"constants":{"\"CalcImpl.multiply()\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":["ArithmeticException"],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":4,"NameExpr":9,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"public int divide(int a, int b) {\n    System.out.println(\"CalcImpl.divide()\");\n    if (b == 0) {\n        // slightly better-than-average message\n        throw new ArithmeticException(\"You tried to divide \" + a + \" by 0\");\n    }\n    return a / b;\n}\n","name":"divide","className":"Calc","variables":{"a":2,"b":2},"constants":{"0":1,"\"CalcImpl.divide()\"":1,"\"You tried to divide \"":1,"\" by 0\"":1},"javaDoc":"","comments":"slightly better-than-average message ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"publish":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Endpoint":1,"Calc":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    // BEGIN main\n    // Create the \"service stub\"\n    Calc impl = new Calc();\n    // Start the service running\n    Endpoint ep = Endpoint.publish(\"http://localhost:9090/calc\", impl);\n    System.out.println(\"Endpoint running: \" + ep);\n// END main\n}\n","name":"main","className":"ServiceMain","variables":{"impl":1,"Endpoint":1,"ep":2},"constants":{"\"Endpoint running: \"":1,"\"http://localhost:9090/calc\"":1},"javaDoc":"","comments":"BEGIN main END main Create the \"service stub\" Start the service running ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int","int","int","int","int"],"returnType":"Appt","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":15,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":7},"statements":{"IfStmt":1,"ExpressionStmt":7},"text":"/** Construct an Appointment. */\npublic Appt(String text, int y, int mo, int d, int h, int min) {\n    this.text = text;\n    year = y;\n    month = mo;\n    day = d;\n    hour = h;\n    minute = min;\n    if (gc == null)\n        gc = new GregorianCalendar();\n}\n","name":"Appt","className":"Appt","variables":{"mo":1,"min":1,"month":1,"d":1,"hour":1,"year":1,"h":1,"y":1,"text":1,"gc":2,"day":1,"minute":1},"constants":{"null":1},"javaDoc":"Construct an Appointment","comments":" Construct an Appointment. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"//-----------------------------------------------------------------\n//    METHODS - REPETITION\n//-----------------------------------------------------------------\npublic void setRep(int typ, int intv, int count) {\n    r_type = typ;\n    r_interval = intv;\n    r_count = count;\n}\n","name":"setRep","className":"Appt","variables":{"intv":1,"r_count":1,"count":1,"typ":1,"r_interval":1,"r_type":1},"constants":{},"javaDoc":"","comments":"-----------------------------------------------------------------","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"boolean","methodCalls":{"add":1,"set":5,"getTime":1,"get":6,"toString":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":19,"BooleanLiteralExpr":4,"NameExpr":112,"FieldAccessExpr":13,"UnaryExpr":1,"MethodCallExpr":15},"statements":{"SwitchStmt":1,"IfStmt":3,"BreakStmt":6,"BlockStmt":1,"SwitchEntryStmt":6,"ReturnStmt":4,"ForStmt":1,"ExpressionStmt":7},"text":"/** Decide whether a given Appointment matches the given y/m/d.\n     */\npublic boolean matches(int y, int m, int d) {\n    // Do the simple case first!\n    if (year == y && month == m && day == d)\n        return true;\n    // If NOT today AND no repetition, not interesting.\n    if (r_count == NONE)\n        return false;\n    // Else potentially interesting!\n    // System.out.println(\"ME:\"+year+\",\"+month+\",\"+day);\n    // System.out.println(\"YE:\"+y   +\",\"+m    +\",\"+d  );\n    // using our GregorianCalendar for calculations from here on... \n    gc.set(Calendar.YEAR, year);\n    gc.set(Calendar.MONTH, month - 1);\n    gc.set(Calendar.DAY_OF_MONTH, day);\n    gc.set(Calendar.HOUR, hour);\n    gc.set(Calendar.MINUTE, minute);\n    System.out.println(gc.getTime().toString());\n    for (int i = 0; i < r_count && gc.get(Calendar.YEAR) <= year && gc.get(Calendar.MONTH) <= month && gc.get(Calendar.DAY_OF_MONTH) <= day; i++) {\n        switch(r_type) {\n            case HOURLY:\n                break;\n            case DAILY:\n                gc.add(Calendar.DAY_OF_MONTH, r_interval);\n                break;\n            case WEEKLY:\n                break;\n            case MONTHLY_NUMDAY_OF_M:\n                break;\n            case MONTHLY_WEEKDAY_OF_M:\n                break;\n            case YEARLY:\n                break;\n        }\n        // matches the date we're looking for.\n        if (gc.get(Calendar.YEAR) == y && gc.get(Calendar.MONTH) == m && gc.get(Calendar.DAY_OF_MONTH) == d)\n            return true;\n    }\n    // We got out of the loop without finding a match, so...\n    return false;\n}\n             // OK, we did the increment. Now see if it\n\n","name":"matches","className":"Appt","variables":{"YEARLY":1,"WEEKLY":1,"d":2,"year":2,"DAILY":1,"r_count":2,"MONTHLY_NUMDAY_OF_M":1,"i":3,"m":2,"HOURLY":1,"month":3,"y":2,"MONTHLY_WEEKDAY_OF_M":1,"NONE":1,"gc":13,"day":2,"r_type":1},"constants":{"0":1,"1":1,"true":2,"false":2},"javaDoc":"Decide whether a given Appointment matches the given y/m/d","comments":"Else potentially interesting! System out println(\"ME:\"+year+\" \"+month+\" \"+day); System out println(\"YE:\"+y +\" \"+m +\" \"+d ); Do the simple case first! If NOT today AND no repetition not interesting using our GregorianCalendar for calculations from here on OK we did the increment Now see if it matches the date we're looking for We got out of the loop without finding a match so  Decide whether a given Appointment matches the given y/m/d.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Appt"],"returnType":"int","methodCalls":{"compareTo":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":10,"BinaryExpr":10,"NameExpr":46,"FieldAccessExpr":11,"UnaryExpr":10,"MethodCallExpr":1},"statements":{"IfStmt":10,"ReturnStmt":11},"text":"/** compareTo method, from Comparable interface.\n     * Compare this Appointment against another, for purposes of sorting.\n     * <P>Only text, and date and time participate, not repetition!\n     * (Repetition has to do with recurring events, e.g., \n     *  \"Meeting every Tuesday at 9\").\n     * This methods is consistent with equals().\n     * @return -1 if this<a2, +1 if this>a2, else 0.\n     */\n@Override\npublic int compareTo(Appt a2) {\n    if (year < a2.year)\n        return -1;\n    if (year > a2.year)\n        return +1;\n    if (month < a2.month)\n        return -1;\n    if (month > a2.month)\n        return +1;\n    if (day < a2.day)\n        return -1;\n    if (day > a2.day)\n        return +1;\n    if (hour < a2.hour)\n        return -1;\n    if (hour > a2.hour)\n        return +1;\n    if (minute < a2.minute)\n        return -1;\n    if (minute > a2.minute)\n        return +1;\n    return text.compareTo(a2.text);\n}\n","name":"compareTo","className":"Appt","variables":{"month":2,"hour":2,"year":2,"text":1,"day":2,"minute":2},"constants":{"1":10},"javaDoc":"compareTo method from Comparable interface Compare this Appointment against another for purposes of sorting <P>Only text and date and time participate not repetition! (Repetition has to do with recurring events e g \"Meeting every Tuesday at 9\") This methods is consistent with equals() -1 if this<a2 +1 if this>a2 else 0","comments":" compareTo method, from Comparable interface.\n     * Compare this Appointment against another, for purposes of sorting.\n     * <P>Only text, and date and time participate, not repetition!\n     * (Repetition has to do with recurring events, e.g., \n     *  \"Meeting every Tuesday at 9\").\n     * This methods is consistent with equals().\n     * @return -1 if this<a2, +1 if this>a2, else 0.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":["Override"],"exceptions":[],"concepts":["Casting"],"types":{"Appt":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":9,"BooleanLiteralExpr":1,"CastExpr":1,"NameExpr":27,"FieldAccessExpr":6,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"/** Compare this appointment against another, for equality.\n     * Consistent with compareTo(). For this reason, only\n     * text, date & time participate, not repetition.\n     * @returns true if the objects are equal, false if not.\n     */\n@Override\npublic boolean equals(Object o2) {\n    Appt a2 = (Appt) o2;\n    if (year != a2.year || month != a2.month || day != a2.day || hour != a2.hour || minute != a2.minute)\n        return false;\n    return text.equals(a2.text);\n}\n","name":"equals","className":"Appt","variables":{"a2":1,"o2":1,"month":1,"hour":1,"year":1,"text":1,"day":1,"minute":1},"constants":{"false":1},"javaDoc":"Compare this appointment against another for equality Consistent with compareTo() For this reason only text date & time participate not repetition s true if the objects are equal false if not","comments":" Compare this appointment against another, for equality.\n     * Consistent with compareTo(). For this reason, only\n     * text, date & time participate, not repetition.\n     * @returns true if the objects are equal, false if not.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":10},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":30,"CharLiteralExpr":5,"MethodCallExpr":12},"statements":{"ReturnStmt":1},"text":"/** Return a String representation of this Appt.\n     * Output is intended for debugging, not presentation!\n     */\n@Override\npublic String toString() {\n    return new StringBuffer().append(year).append(' ').append(month).append(' ').append(day).append(' ').append(hour).append(' ').append(minute).append(' ').append(text).toString();\n}\n","name":"toString","className":"Appt","variables":{},"constants":{"' '":5},"javaDoc":"Return a String representation of this Appt Output is intended for debugging not presentation!","comments":" Return a String representation of this Appt.\n     * Output is intended for debugging, not presentation!\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Appt","methodCalls":{"countTokens":1,"parseInt":5,"nextToken":6,"hasMoreElements":2,"toString":1,"append":2},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"StringTokenizer":1,"StringBuffer":1,"int":5},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":2,"NameExpr":58,"StringLiteralExpr":1,"CharLiteralExpr":1,"MethodCallExpr":17},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":9},"text":"/** Factory: build a String representation into an Appt.\n     * Cast as a static factory for minor efficiency gains - reconsider.\n     */\npublic static Appt fromString(String s) {\n    StringTokenizer st = new StringTokenizer(s);\n    if (st.countTokens() < 6)\n        throw new IllegalArgumentException(\"Too few fields in \" + s);\n    int y = Integer.parseInt(st.nextToken());\n    int m = Integer.parseInt(st.nextToken());\n    int d = Integer.parseInt(st.nextToken());\n    int h = Integer.parseInt(st.nextToken());\n    int i = Integer.parseInt(st.nextToken());\n    StringBuffer sb = new StringBuffer();\n    while (st.hasMoreElements()) {\n        sb.append(st.nextToken());\n        if (st.hasMoreElements())\n            sb.append(' ');\n    }\n    return new Appt(sb.toString(), y, m, d, h, i);\n}\n                    /*still*/\n\n","name":"fromString","className":"Appt","variables":{"Integer":5,"st":10,"s":2,"d":2,"h":2,"y":2,"i":2,"m":2,"sb":4},"constants":{"6":1,"\"Too few fields in \"":1,"' '":1},"javaDoc":"Factory: build a String representation into an Appt Cast as a static factory for minor efficiency gains - reconsider","comments":"still  Factory: build a String representation into an Appt.\n     * Cast as a static factory for minor efficiency gains - reconsider.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getDay() {\n    return day;\n}\n","name":"getDay","className":"Appt","variables":{"day":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getHour() {\n    return hour;\n}\n","name":"getHour","className":"Appt","variables":{"hour":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getMinute() {\n    return minute;\n}\n","name":"getMinute","className":"Appt","variables":{"minute":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getMonth() {\n    return month;\n}\n","name":"getMonth","className":"Appt","variables":{"month":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getText() {\n    return text;\n}\n","name":"getText","className":"Appt","variables":{"text":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getYear() {\n    return year;\n}\n","name":"getYear","className":"Appt","variables":{"year":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["T"],"returnType":"TNode","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"TNode(T o) {\n    data = o;\n    next = null;\n}\n","name":"TNode","className":"TNode","variables":{"next":1,"data":1,"o":1},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"LinkList","methodCalls":{"clear":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Construct a LinkList: initialize the first and last nodes */\npublic LinkList() {\n    clear();\n}\n","name":"LinkList","className":"LinkList","variables":{},"constants":{},"javaDoc":"Construct a LinkList: initialize the first and last nodes","comments":" Construct a LinkList: initialize the first and last nodes ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Collection<T>"],"returnType":"LinkList","methodCalls":{"addAll":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/** Construct a LinkList given another Collection.\n     * This method is recommended by the general contract of List.\n     */\npublic LinkList(Collection<T> c) {\n    this();\n    addAll(c);\n}\n","name":"LinkList","className":"LinkList","variables":{},"constants":{},"javaDoc":"Construct a LinkList given another Collection This method is recommended by the general contract of List","comments":" Construct a LinkList given another Collection.\n     * This method is recommended by the general contract of List.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"NameExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Set the List (back) to its initial state.\n     * Any references held will be discarded.\n     */\npublic void clear() {\n    first = new TNode<T>(null);\n    last = first;\n}\n","name":"clear","className":"LinkList","variables":{"last":1,"first":2},"constants":{"null":1},"javaDoc":"Set the List (back) to its initial state Any references held will be discarded","comments":" Set the List (back) to its initial state.\n     * Any references held will be discarded.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["T"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":8,"FieldAccessExpr":2,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Add one object to the end of the list. Update the \"next\"\n     * reference in the previous end, to refer to the new node.\n     * Update \"last\" to refer to the new node. \n     */\npublic boolean add(T o) {\n    last.next = new TNode<T>(o);\n    last = last.next;\n    return true;\n}\n","name":"add","className":"LinkList","variables":{"last":1,"o":1},"constants":{"true":1},"javaDoc":"Add one object to the end of the list Update the \"next\" reference in the previous end to refer to the new node Update \"last\" to refer to the new node","comments":" Add one object to the end of the list. Update the \"next\"\n     * reference in the previous end, to refer to the new node.\n     * Update \"last\" to refer to the new node. \n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","T"],"returnType":"void","methodCalls":{"System.out.printf":1},"annotations":[],"exceptions":["IndexOutOfBoundsException"],"concepts":[],"types":{"TNode<T>":2,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":26,"StringLiteralExpr":2,"FieldAccessExpr":4,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ThrowStmt":1,"ExpressionStmt":6},"text":"public void add(int where, T o) {\n    TNode<T> t = first;\n    for (int i = 0; i <= where; i++) {\n        t = t.next;\n        if (t == null) {\n            throw new IndexOutOfBoundsException(\"'add(n,T) went off end of list\");\n        }\n        if (DIAGNOSTIC) {\n            System.out.printf(\"add(int,T): i = %d, t = %s%n\", i, t);\n        }\n    }\n    TNode<T> t2 = t;\n    t.next = new TNode<T>(o);\n    t.next = t2;\n}\n","name":"add","className":"LinkList","variables":{"DIAGNOSTIC":1,"t":4,"i":3,"where":1,"first":1,"t2":2,"o":1},"constants":{"0":1,"\"'add(n,T) went off end of list\"":1,"null":1,"\"add(int,T): i = %d, t = %s%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"TNode<T>":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":9,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"BreakStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public int size() {\n    TNode<T> t = first;\n    int i;\n    for (i = 0; ; i++) {\n        if (t == null)\n            break;\n        t = t.next;\n    }\n    // subtract one for mandatory head node.\n    return i - 1;\n}\n","name":"size","className":"LinkList","variables":{"t":3,"i":4,"first":1},"constants":{"0":1,"1":1,"null":1},"javaDoc":"","comments":"subtract one for mandatory head node ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public boolean isEmpty() {\n    return first == last;\n}\n","name":"isEmpty","className":"LinkList","variables":{"last":1,"first":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"T","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"TNode<T>":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":11,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public T get(int where) {\n    TNode<T> t = first;\n    int i = 0;\n    // If we get to the end of list before 'where', error out\n    while (i <= where) {\n        i++;\n        if ((t = t.next) == null) {\n            throw new IndexOutOfBoundsException();\n        }\n    }\n    return t.data;\n}\n","name":"get","className":"LinkList","variables":{"t":2,"i":3,"where":1,"first":1},"constants":{"0":1,"null":1},"javaDoc":"","comments":"If we get to the end of list before 'where' error out ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","T"],"returnType":"T","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public T set(int i, T o) {\n    return null;\n}\n","name":"set","className":"LinkList","variables":{},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"t.data.equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"TNode<T>":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":11,"FieldAccessExpr":2,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"public boolean contains(Object o) {\n    TNode<T> t = first;\n    while ((t = t.next) != null) {\n        if (t.data.equals(o)) {\n            return true;\n        }\n    }\n    return false;\n}\n","name":"contains","className":"LinkList","variables":{"t":2,"first":1},"constants":{"null":1,"true":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Collection<? extends T>"],"returnType":"boolean","methodCalls":{"add":1,"forEach":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"LambdaExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"CastExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public boolean addAll(Collection<? extends T> c) {\n    c.forEach( o -> add((T) o));\n    return false;\n}\n","name":"addAll","className":"LinkList","variables":{"c":1,"o":2},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ListIterator<T>","methodCalls":{},"annotations":[],"exceptions":["UnsupportedOperationException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"StringLiteralExpr":1},"statements":{"ThrowStmt":1},"text":"public ListIterator<T> listIterator() {\n    throw new UnsupportedOperationException(\"listIterator\");\n}\n","name":"listIterator","className":"LinkList","variables":{},"constants":{"\"listIterator\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public boolean hasNext() {\n    return t != last;\n}\n","name":"hasNext","className":"","variables":{"t":1,"last":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"T","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":6,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"public T next() {\n    if (t == last)\n        throw new IndexOutOfBoundsException();\n    return (T) (t = t.next);\n}\n","name":"next","className":"","variables":{"t":2,"last":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["UnsupportedOperationException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"StringLiteralExpr":1},"statements":{"ThrowStmt":1},"text":"public void remove() {\n    throw new UnsupportedOperationException(\"remove\");\n}\n","name":"remove","className":"","variables":{},"constants":{"\"remove\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Iterator<T>","methodCalls":{},"annotations":[],"exceptions":["UnsupportedOperationException"],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":3,"BinaryExpr":2,"NameExpr":17,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ReturnStmt":3,"ThrowStmt":2},"text":"public Iterator<T> iterator() {\n    return new Iterator<T>() {\n\n        TNode<T> t = first.next;\n\n        public boolean hasNext() {\n            return t != last;\n        }\n\n        public T next() {\n            if (t == last)\n                throw new IndexOutOfBoundsException();\n            return (T) (t = t.next);\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException(\"remove\");\n        }\n    };\n}\n","name":"iterator","className":"LinkList","variables":{"next":1,"t":4,"last":2,"hasNext":1,"remove":1},"constants":{"\"remove\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// END main\n// THE FOLLOWING METHODS ARE NOT YET IMPLEMENTED!\npublic Object[] toArray() {\n    return null;\n}\n","name":"toArray","className":"LinkList","variables":{},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object[]"],"returnType":"T[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public T[] toArray(Object[] data) {\n    return null;\n}\n","name":"toArray","className":"LinkList","variables":{},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean remove(Object o) {\n    return false;\n}\n","name":"remove","className":"LinkList","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"T","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public T remove(int i) {\n    return null;\n}\n","name":"remove","className":"LinkList","variables":{},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Collection"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean containsAll(Collection c) {\n    return false;\n}\n","name":"containsAll","className":"LinkList","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","Collection"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean addAll(int i, Collection c) {\n    return false;\n}\n","name":"addAll","className":"LinkList","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Collection"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean removeAll(Collection c) {\n    return false;\n}\n","name":"removeAll","className":"LinkList","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Collection"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean retainAll(Collection c) {\n    return false;\n}\n","name":"retainAll","className":"LinkList","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public int indexOf(Object o) {\n    return 0;\n}\n","name":"indexOf","className":"LinkList","variables":{},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public int lastIndexOf(Object o) {\n    return 0;\n}\n","name":"lastIndexOf","className":"LinkList","variables":{},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"ListIterator<T>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public ListIterator<T> listIterator(int where) {\n    return null;\n}\n","name":"listIterator","className":"LinkList","variables":{},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"List<T>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public List<T> subList(int sub1, int sub2) {\n    return null;\n}\n","name":"subList","className":"LinkList","variables":{},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"size":1,"get":1,"getDate":3,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"StructureDemo":1,"ArrayList":1,"ArrayList<Date>":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":38,"StringLiteralExpr":3,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":10},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] argv) {\n    ArrayList<Date> al = new ArrayList<>();\n    // Create a source of Objects\n    StructureDemo source = new StructureDemo(15);\n    // Add lots of elements to the ArrayList...\n    al.add(source.getDate());\n    al.add(source.getDate());\n    al.add(source.getDate());\n    // Print them out using old-style for loop to index number.\n    System.out.println(\"Retrieving by index:\");\n    for (int i = 0; i < al.size(); i++) {\n        System.out.println(\"Element \" + i + \" = \" + al.get(i));\n    }\n}\n","name":"main","className":"ArrayListDemo","variables":{"i":4,"al":6,"source":4},"constants":{"0":1,"\"Retrieving by index:\"":1,"15":1,"\"Element \"":1,"\" = \"":1},"javaDoc":"","comments":"Create a source of Objects Add lots of elements to the ArrayList Print them out using old-style for loop to index number ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"play":2,"parseInt":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArrayHunt":1,"int":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":24,"StringLiteralExpr":3,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] argv) {\n    ArrayHunt h = new ArrayHunt();\n    if (argv.length == 0)\n        h.play();\n    else {\n        int won = 0;\n        int games = Integer.parseInt(argv[0]);\n        for (int i = 0; i < games; i++) if (h.play())\n            ++won;\n        System.out.println(\"Computer won \" + won + \" out of \" + games + \".\");\n    }\n}\n","name":"main","className":"ArrayHunt","variables":{"Integer":1,"won":3,"h":3,"games":3,"i":3,"argv":1},"constants":{"0":4,"\".\"":1,"\"Computer won \"":1,"\" out of \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"ArrayHunt","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Construct the hunting ground */\npublic ArrayHunt() {\n    haystack = new int[MAX];\n    r = new Random();\n}\n","name":"ArrayHunt","className":"ArrayHunt","variables":{"r":1,"haystack":1,"MAX":1},"constants":{},"javaDoc":"Construct the hunting ground","comments":" Construct the hunting ground ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"nextFloat":1,"sort":1,"binarySearch":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":15,"NameExpr":37,"StringLiteralExpr":7,"UnaryExpr":3,"AssignExpr":3,"BooleanLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":2,"EnclosedExpr":3,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":6},"text":"/** Play one game. */\npublic boolean play() {\n    int i;\n    // Fill the array with random data (hay?)\n    for (i = 0; i < MAX; i++) {\n        haystack[i] = (int) (r.nextFloat() * MAX);\n    }\n    // Precondition for binary search is that data be sorted!\n    Arrays.sort(haystack);\n    // Look for needle in haystack\n    i = Arrays.binarySearch(haystack, NEEDLE);\n    if (i >= 0) {\n        // Found it, we win.\n        System.out.println(\"Value \" + NEEDLE + \" occurs at haystack[\" + i + \"]\");\n        return true;\n    } else {\n        // Not found, we lose.\n        System.out.println(\"Value \" + NEEDLE + \" does not occur in haystack; nearest value is \" + haystack[-(i + 2)] + \" (found at \" + -(i + 2) + \")\");\n        return false;\n    }\n}\n","name":"play","className":"ArrayHunt","variables":{"r":1,"haystack":2,"MAX":2,"i":10,"NEEDLE":2,"Arrays":2},"constants":{"0":2,"2":2,"\"]\"":1,"true":1,"false":1,"\" does not occur in haystack; nearest value is \"":1,"\")\"":1,"\" (found at \"":1,"\"Value \"":2,"\" occurs at haystack[\"":1},"javaDoc":"Play one game","comments":"Fill the array with random data (hay?) Precondition for binary search is that data be sorted! Look for needle in haystack Found it we win Not found we lose  Play one game. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"size":1,"get":1,"System.out.println":1},"annotations":["SuppressWarnings"],"exceptions":[],"concepts":["Casting","PolyMorphism"],"types":{"// BEGIN oldWay\nList":1,"ArrayList":1,"String":1,"int":1},"expressions":{"SingleMemberAnnotationExpr":1,"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":22,"StringLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"@SuppressWarnings(\"unchecked\")\npublic void oldWay() {\n    @SuppressWarnings(\"rawtypes\") // BEGIN oldWay\n    List myList = new ArrayList();\n    myList.add(\"hello\");\n    myList.add(\"goodbye\");\n    for (int i = 0; i < myList.size(); i++) {\n        String s = (String) myList.get(i);\n        System.out.println(s);\n    }\n// END oldWay\n}\n     // myList.add(new Date()); This would compile but cause failures later\n\n","name":"oldWay","className":"ListsOldAndNew","variables":{"s":1,"SuppressWarnings":1,"myList":5,"i":3},"constants":{"0":1,"\"rawtypes\"":1,"\"hello\"":1,"\"goodbye\"":1},"javaDoc":"","comments":"myList add(new Date()); This would compile but cause failures later END oldWay BEGIN oldWay ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayList":1,"String":1,"List<String>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":4},"text":"public void newWay() {\n    // BEGIN newWay\n    // Java 6: new ArrayList<String>();\n    List<String> myList = new ArrayList<>();\n    myList.add(\"hello\");\n    myList.add(\"goodbye\");\n    for (String s : myList) {\n        // Look Ma, no downcast!\n        System.out.println(s);\n    }\n// END newWay\n}\n     // myList.add(new Date()); This would not compile!\n\n","name":"newWay","className":"ListsOldAndNew","variables":{"s":1,"myList":4},"constants":{"\"hello\"":1,"\"goodbye\"":1},"javaDoc":"","comments":"BEGIN newWay myList add(new Date()); This would not compile! END newWay Java 6: new ArrayList<String>(); Look Ma no downcast! ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getInstance":1,"System.out.println":2},"annotations":["SuppressWarnings"],"exceptions":[],"concepts":["FinalVariables"],"types":{"int[][]":1,"int[]":3,"int":3,"Calendar[]":1},"expressions":{"IntegerLiteralExpr":21,"VariableDeclarationExpr":8,"ArrayInitializerExpr":1,"ArrayAccessExpr":3,"BinaryExpr":2,"NameExpr":30,"FieldAccessExpr":4,"ArrayCreationExpr":5,"UnaryExpr":2,"AssignExpr":3,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":2,"ExpressionStmt":11},"text":"@SuppressWarnings(\"unused\")\npublic static void main(String[] argv) {\n    // declare a reference\n    int[] monthLen1;\n    // construct it\n    monthLen1 = new int[12];\n    // short form\n    int[] monthLen2 = new int[12];\n    // even shorter is this initializer form:\n    int[] monthLen3 = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n    final int MAX = 10;\n    Calendar[] days = new Calendar[MAX];\n    for (int i = 0; i < MAX; i++) {\n        // Note that this actually stores GregorianCalendar\n        // etc. instances into a Calendar Array\n        days[i] = Calendar.getInstance();\n    }\n    // Two-Dimensional Arrays\n    // Want a 10-by-24 array\n    int[][] me = new int[10][];\n    for (int i = 0; i < 10; i++) me[i] = new int[24];\n    // Remember that an array has a \".length\" attribute\n    System.out.println(me.length);\n    System.out.println(me[0].length);\n}\n","name":"main","className":"Array1","variables":{"MAX":3,"Calendar":1,"me":3,"days":2,"i":8,"monthLen3":1,"monthLen1":2,"monthLen2":1},"constants":{"0":3,"12":2,"24":1,"28":1,"30":4,"31":7,"10":3},"javaDoc":"","comments":"Two-Dimensional Arrays declare a reference construct it short form even shorter is this initializer form: Note that this actually stores GregorianCalendar etc instances into a Calendar Array Want a 10-by-24 array Remember that an array has a \" length\" attribute ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"values":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"State":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    for (State i : State.values()) {\n        System.out.println(i);\n    }\n}\n","name":"main","className":"EnumList","variables":{"State":1,"i":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String[][]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":6,"NameExpr":18,"StringLiteralExpr":3,"FieldAccessExpr":2,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":2},"statements":{"BlockStmt":2,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Return list of subscript names (unrealistic; just for demo). */\npublic static String[][] getArrayInfo() {\n    String info[][];\n    info = new String[10][10];\n    for (int i = 0; i < info.length; i++) {\n        for (int j = 0; j < info[i].length; j++) {\n            info[i][j] = \"String[\" + i + \",\" + j + \"]\";\n        }\n    }\n    return info;\n}\n","name":"getArrayInfo","className":"ArrayTwoDObjects","variables":{"i":6,"j":5,"info":5},"constants":{"0":2,"\"String[\"":1,"\"]\"":1,"\",\"":1,"10":2},"javaDoc":"Return list of subscript names (unrealistic; just for demo)","comments":" Return list of subscript names (unrealistic; just for demo). ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String[][]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"ArrayInitializerExpr":3,"StringLiteralExpr":6,"NameExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Return list of allowable parameters (Applet method). */\npublic static String[][] getParameterInfo() {\n    String param_info[][] = { { \"fontsize\", \"9-18\", \"Size of font\" }, { \"URL\", \"-\", \"Where to download\" } };\n    return param_info;\n}\n","name":"getParameterInfo","className":"ArrayTwoDObjects","variables":{"param_info":2},"constants":{"\"URL\"":1,"\"-\"":1,"\"9-18\"":1,"\"Size of font\"":1,"\"fontsize\"":1,"\"Where to download\"":1},"javaDoc":"Return list of allowable parameters (Applet method)","comments":" Return list of allowable parameters (Applet method). ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":2,"getArrayInfo":1,"getParameterInfo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"StringLiteralExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":2},"text":"/** Run both initialization methods and print part of the results */\npublic static void main(String[] args) {\n    print(\"from getArrayInfo\", getArrayInfo());\n    print(\"from getParameterInfo\", getParameterInfo());\n}\n","name":"main","className":"ArrayTwoDObjects","variables":{},"constants":{"\"from getArrayInfo\"":1,"\"from getParameterInfo\"":1},"javaDoc":"Run both initialization methods and print part of the results","comments":" Run both initialization methods and print part of the results ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String[][]"],"returnType":"void","methodCalls":{"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":11,"ArrayAccessExpr":11,"BinaryExpr":10,"NameExpr":42,"StringLiteralExpr":8,"FieldAccessExpr":8,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"/** Print selected elements from the 2D array */\npublic static void print(String tag, String[][] array) {\n    System.out.println(\"Array \" + tag + \" is \" + array.length + \" x \" + array[0].length);\n    System.out.println(\"Array[0][0] = \" + array[0][0]);\n    System.out.println(\"Array[0][1] = \" + array[0][1]);\n    System.out.println(\"Array[1][0] = \" + array[1][0]);\n    System.out.println(\"Array[0][0] = \" + array[0][0]);\n    System.out.println(\"Array[1][1] = \" + array[1][1]);\n}\n","name":"print","className":"ArrayTwoDObjects","variables":{"array":6,"tag":1},"constants":{"\"Array \"":1,"0":7,"1":4,"\" is \"":1,"\" x \"":1,"\"Array[0][0] = \"":2,"\"Array[1][1] = \"":1,"\"Array[1][0] = \"":1,"\"Array[0][1] = \"":1},"javaDoc":"Print selected elements from the 2D array","comments":" Print selected elements from the 2D array ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"next":1,"previous":1,"listIterator":1,"hasPrevious":1,"hasNext":1,"System.err.println":2,"indexOf":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"LinkedList<String>":1,"ListIterator":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":59,"StringLiteralExpr":9,"FieldAccessExpr":6,"MethodCallExpr":16},"statements":{"IfStmt":1,"WhileStmt":2,"BlockStmt":1,"ExpressionStmt":11},"text":"public static void main(String[] argv) {\n    System.out.println(\"Here is a demo of Java's LinkedList class\");\n    LinkedList<String> l = new LinkedList<>();\n    l.add(new Object().toString());\n    l.add(\"Hello\");\n    l.add(\"end of the list\");\n    System.out.println(\"Here is a list of all the elements\");\n    ListIterator li = l.listIterator(0);\n    while (li.hasNext()) System.out.println(\"Next to: \" + li.next());\n    if (l.indexOf(\"Hello\") < 0)\n        System.err.println(\"Lookup does not work\");\n    else\n        System.err.println(\"Lookup works\");\n    // Now, for added fun, let's walk the linked list backwards.\n    while (li.hasPrevious()) {\n        System.out.println(\"Back to: \" + li.previous());\n    }\n}\n","name":"main","className":"LinkedListDemo","variables":{"l":6,"li":5},"constants":{"\"Hello\"":2,"0":2,"\"Lookup works\"":1,"\"Here is a demo of Java's LinkedList class\"":1,"\"Here is a list of all the elements\"":1,"\"Next to: \"":1,"\"Back to: \"":1,"\"end of the list\"":1,"\"Lookup does not work\"":1},"javaDoc":"","comments":"Now for added fun let's walk the linked list backwards ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"load":1,"list":1,"put":7},"annotations":[],"exceptions":["java.io.IOException"],"concepts":[],"types":{"Properties":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":33,"StringLiteralExpr":14,"FieldAccessExpr":2,"MethodCallExpr":9},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] argv) throws java.io.IOException {\n    Properties props = new Properties();\n    // Get my data\n    props.put(\"Adobe\", \"Mountain View, CA\");\n    props.put(\"IBM\", \"White Plains, NY\");\n    props.put(\"Learning Tree\", \"Los Angeles, CA\");\n    props.put(\"Microsoft\", \"Redmond, WA\");\n    props.put(\"Netscape\", \"Mountain View, CA\");\n    props.put(\"O'Reilly\", \"Sebastopol, CA\");\n    props.put(\"Sun\", \"Mountain View, CA\");\n    // Now load additional properties\n    props.load(System.in);\n    // List merged properties, using System.out\n    props.list(System.out);\n}\n","name":"main","className":"PropsCompanies","variables":{"props":10},"constants":{"\"Mountain View, CA\"":3,"\"IBM\"":1,"\"Redmond, WA\"":1,"\"Microsoft\"":1,"\"White Plains, NY\"":1,"\"Netscape\"":1,"\"Adobe\"":1,"\"Sebastopol, CA\"":1,"\"O'Reilly\"":1,"\"Learning Tree\"":1,"\"Sun\"":1,"\"Los Angeles, CA\"":1},"javaDoc":"","comments":"Get my data Now load additional properties List merged properties using System out ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"arraycopy":1,"getDate":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"StructureDemo":1,"Date[]":2,"int":1,"Date":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":34,"StringLiteralExpr":1,"UnaryExpr":1,"AssignExpr":3,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":5,"EnclosedExpr":2,"ArrayCreationExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":9},"text":"public static void main(String[] argv) {\n    int nDates = 0;\n    Date[] dates = new Date[INITIAL];\n    StructureDemo source = new StructureDemo(21);\n    Date c;\n    while ((c = (Date) (source.getDate())) != null) {\n        // better: reallocate, making data structure dynamic\n        if (nDates >= dates.length) {\n            Date[] tmp = new Date[dates.length * GROW_FACTOR];\n            System.arraycopy(dates, 0, tmp, 0, dates.length);\n            // copies the array reference\n            dates = tmp;\n        // old array will be garbage collected soon...\n        }\n        dates[nDates++] = c;\n    }\n    System.out.println(\"Final array size = \" + dates.length);\n}\n             // if (nDates >= dates.length) {\n\n             //     System.err.println(\"Too Many Dates! Simplify your life!!\");\n\n             //     System.exit(1);  // wimp out\n\n             // }\n\n","name":"main","className":"Array2","variables":{"c":3,"GROW_FACTOR":1,"nDates":3,"tmp":2,"INITIAL":1,"dates":3,"source":2,"System":1},"constants":{"0":3,"\"Final array size = \"":1,"null":1,"21":1},"javaDoc":"","comments":"if (nDates >= dates length) { System err println(\"Too Many Dates! Simplify your life!!\"); System exit(1); // wimp out } better: reallocate making data structure dynamic old array will be garbage collected soon copies the array reference ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"forEach":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Set<String>":1,"HashSet":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"LambdaExpr":1,"NameExpr":21,"StringLiteralExpr":4,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    Set<String> hashSet = new HashSet<>();\n    hashSet.add(\"One\");\n    hashSet.add(\"Two\");\n    // DUPLICATE\n    hashSet.add(\"One\");\n    hashSet.add(\"Three\");\n    hashSet.forEach( s -> System.out.println(s));\n// END main\n}\n","name":"main","className":"SetDemo","variables":{"s":1,"hashSet":6},"constants":{"\"One\"":2,"\"Two\"":1,"\"Three\"":1},"javaDoc":"","comments":"END main BEGIN main DUPLICATE ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":3,"UnaryExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** push - add an element onto the stack */\nprotected void push(int n) {\n    stack[depth++] = n;\n}\n","name":"push","className":"ToyStack","variables":{"stack":1,"depth":1,"n":1},"constants":{},"javaDoc":"push - add an element onto the stack","comments":" push - add an element onto the stack ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":2,"UnaryExpr":1},"statements":{"ReturnStmt":1},"text":"/** pop - return and remove the top element */\nprotected int pop() {\n    return stack[--depth];\n}\n","name":"pop","className":"ToyStack","variables":{"stack":1,"depth":1},"constants":{},"javaDoc":"pop - return and remove the top element","comments":" pop - return and remove the top element ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/** peek - return the top element but don't remove it */\nprotected int peek() {\n    return stack[depth - 1];\n}\n","name":"peek","className":"ToyStack","variables":{"stack":1,"depth":1},"constants":{"1":1},"javaDoc":"peek - return the top element but don't remove it","comments":" peek - return the top element but don't remove it ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"Book\";\n}\n","name":"toString","className":"","variables":{},"constants":{"\"Book\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MediaFancy[]":1,"MediaFancy":1},"expressions":{"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"NameExpr":10,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"/** It is generally disparaged to have a main() in an enum;\n     * please forgive this tiny demo class for doing so.\n     */\npublic static void main(String[] args) {\n    MediaFancy[] data = { BOOK, MOVIE_DVD, MUSIC_VINYL };\n    for (MediaFancy mf : data) {\n        System.out.println(mf);\n    }\n}\n","name":"main","className":"","variables":{"data":2,"BOOK":1,"MOVIE_DVD":1,"mf":1,"MUSIC_VINYL":1},"constants":{},"javaDoc":"It is generally disparaged to have a main() in an enum; please forgive this tiny demo class for doing so","comments":" It is generally disparaged to have a main() in an enum;\n     * please forgive this tiny demo class for doing so.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getProperty":2,"setProperty":5,"list":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2,"Properties":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":27,"StringLiteralExpr":12,"FieldAccessExpr":1,"MethodCallExpr":8},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] argv) {\n    Properties ian = new Properties();\n    // Set my data.\n    ian.setProperty(\"name\", \"Ian Darwin\");\n    ian.setProperty(\"favorite popsicle\", \"cherry\");\n    ian.setProperty(\"favorite rock group\", \"Fleetwood Mac\");\n    ian.setProperty(\"favorite programming language\", \"Java\");\n    ian.setProperty(\"pencil_color\", \"green\");\n    // should return the string \"green\".\n    String ianColor = ian.getProperty(\"pencil_color\");\n    // Don't know what it will return.\n    // BEGIN pencil.color\n    String sysColor = System.getProperty(\"pencil_color\");\n    // END pencil.color\n    // Now list the Properties, using System.out\n    ian.list(System.out);\n}\n","name":"main","className":"PropsDemo","variables":{"ian":8,"ianColor":1,"sysColor":1,"System":1},"constants":{"\"Ian Darwin\"":1,"\"Fleetwood Mac\"":1,"\"name\"":1,"\"pencil_color\"":3,"\"favorite programming language\"":1,"\"cherry\"":1,"\"Java\"":1,"\"favorite popsicle\"":1,"\"green\"":1,"\"favorite rock group\"":1},"javaDoc":"","comments":"Don't know what it will return END pencil color Set my data should return the string \"green\" BEGIN pencil color Now list the Properties using System out ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"asList":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"String":2,"List<String>":1},"expressions":{"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"StringLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"BlockStmt":2,"ForeachStmt":2,"ExpressionStmt":4},"text":"public static void main(String args[]) {\n    // BEGIN main\n    String[] data = { \"Toronto\", \"Stockholm\" };\n    for (String s : data) {\n        System.out.println(s);\n    }\n    // Show the Java 5 foreach loop - do not modernize to Java 8\n    List<String> list = Arrays.asList(data);\n    for (String s : list) {\n        System.out.println(s);\n    }\n// END main\n}\n","name":"main","className":"ForeachDemo","variables":{"s":2,"data":2,"list":2,"Arrays":1},"constants":{"\"Toronto\"":1,"\"Stockholm\"":1},"javaDoc":"","comments":"END main BEGIN main Show the Java 5 foreach loop - do not modernize to Java 8 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":3,"hasNext":2,"System.err.println":1,"push":5,"System.out.println":3},"annotations":[],"exceptions":["ClassCastException"],"concepts":["Casting","PolyMorphism","ExceptionHandling"],"types":{"MyStack<String>":1,"String":3,"MyStack":2},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":1,"NameExpr":53,"StringLiteralExpr":6,"CastExpr":2,"FieldAccessExpr":4,"MethodCallExpr":14},"statements":{"WhileStmt":2,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    MyStack<String> ms1 = new MyStack<>();\n    ms1.push(\"billg\");\n    ms1.push(\"scottm\");\n    while (ms1.hasNext()) {\n        String name = ms1.pop();\n        System.out.println(name);\n    }\n    // Old way of using Collections: not type safe.\n    // DO NOT GENERICIZE THIS\n    MyStack ms2 = new MyStack();\n    // EXPECT WARNING\n    ms2.push(\"billg\");\n    // EXPECT WARNING\n    ms2.push(\"scottm\");\n    // EXPECT WARNING\n    ms2.push(new java.util.Date());\n    // Show that it is broken \n    try {\n        String bad = (String) ms2.pop();\n        System.err.println(\"Didn't get expected exception, popped \" + bad);\n    } catch (ClassCastException ex) {\n        System.out.println(\"Did get expected exception.\");\n    }\n    // Removed the brokenness, print rest of it.\n    while (ms2.hasNext()) {\n        String name = (String) ms2.pop();\n        System.out.println(name);\n    }\n}\n","name":"main","className":"MyStackDemo","variables":{"ex":1,"bad":2,"name":2,"ms1":5,"ms2":7},"constants":{"\"scottm\"":2,"\"Did get expected exception.\"":1,"\"billg\"":2,"\"Didn't get expected exception, popped \"":1},"javaDoc":"","comments":"Old way of using Collections: not type safe DO NOT GENERICIZE THIS EXPECT WARNING EXPECT WARNING EXPECT WARNING Show that it is broken Removed the brokenness print rest of it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"next":1,"iterator":1,"getDate":3,"hasNext":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"StructureDemo":1,"List<Date>":1,"ArrayList":1,"Iterator":1,"Object":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":3,"NameExpr":34,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":10},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] argv) {\n    List<Date> l = new ArrayList<>();\n    StructureDemo source = new StructureDemo(15);\n    // Add lots of elements to the list...\n    l.add(source.getDate());\n    l.add(source.getDate());\n    l.add(source.getDate());\n    int i = 0;\n    Iterator it = l.iterator();\n    // if the data is an an array, a List, a Vector, or whatever.\n    while (it.hasNext()) {\n        Object o = it.next();\n        System.out.println(\"Element \" + i++ + \" = \" + o);\n    }\n}\n         // Process the data structure using an iterator.\n\n         // This part of the code does not know or care\n\n","name":"main","className":"IteratorDemo","variables":{"i":2,"source":4,"it":3,"l":5,"o":2},"constants":{"0":1,"15":1,"\"Element \"":1,"\" = \"":1},"javaDoc":"","comments":"Process the data structure using an iterator This part of the code does not know or care Add lots of elements to the list if the data is an an array a List a Vector or whatever ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":7,"tailSet":1,"size":1,"System.out.printf":1,"forEach":1,"toArray":1,"first":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"TreeSet":1,"TreeSet<String>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"LambdaExpr":1,"NameExpr":66,"StringLiteralExpr":12,"FieldAccessExpr":7,"MethodCallExpr":17},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    // A TreeSet keeps objects in sorted order. Use a Comparator\n    // published by String for case-insensitive sorting order.\n    TreeSet<String> theSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n    theSet.add(\"Gosling\");\n    theSet.add(\"da Vinci\");\n    theSet.add(\"van Gogh\");\n    theSet.add(\"Java To Go\");\n    theSet.add(\"Vanguard\");\n    theSet.add(\"Darwin\");\n    // TreeSet is Set, ignores duplicates.\n    theSet.add(\"Darwin\");\n    System.out.printf(\"Our set contains %d elements\", theSet.size());\n    // Since it is sorted we can easily get various subsets\n    System.out.println(\"Lowest (alphabetically) is \" + theSet.first());\n    // Print how many elements are greater than \"k\"\n    // Should be 2 - \"van Gogh\" and \"Vanguard\"\n    System.out.println(theSet.tailSet(\"k\").toArray().length + \" elements higher than \\\"k\\\"\");\n    // Print the whole list in sorted order\n    System.out.println(\"Sorted list:\");\n    theSet.forEach( name -> System.out.println(name));\n// END main\n}\n","name":"main","className":"TreeSetDemo","variables":{"name":1,"theSet":12},"constants":{"\"Vanguard\"":1,"\"da Vinci\"":1,"\"Lowest (alphabetically) is \"":1,"\" elements higher than \\\"k\\\"\"":1,"\"van Gogh\"":1,"\"k\"":1,"\"Darwin\"":2,"\"Sorted list:\"":1,"\"Gosling\"":1,"\"Our set contains %d elements\"":1,"\"Java To Go\"":1},"javaDoc":"","comments":"BEGIN main A TreeSet keeps objects in sorted order Use a Comparator Print how many elements are greater than \"k\" END main published by String for case-insensitive sorting order TreeSet is Set ignores duplicates Since it is sorted we can easily get various subsets Should be 2 - \"van Gogh\" and \"Vanguard\" Print the whole list in sorted order ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":11,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"void load() {\n    v = new ArrayList<String>();\n    for (int i = 0; i < rawStrings.length; i++) v.add(rawStrings[i]);\n}\n","name":"load","className":"StrSortCase","variables":{"v":2,"rawStrings":1,"i":4},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":6,"NameExpr":21,"StringLiteralExpr":4,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"void dump(String title) {\n    System.out.println(\"***** \" + title + \" *****\");\n    for (int i = 0; i < v.size(); i++) System.out.println(\"v[\" + i + \"]=\" + v.get(i));\n}\n","name":"dump","className":"StrSortCase","variables":{"v":2,"i":4,"title":1},"constants":{"0":1,"\"]=\"":1,"\"***** \"":1,"\" *****\"":1,"\"v[\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"load":1,"dump":2,"sort":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"StrSortCase":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":23,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"/** Simple main program to test the sorting */\npublic static void main(String[] argv) {\n    // BEGIN main\n    System.out.println(\"StrSort Demo Ignoring Case\");\n    StrSortCase s = new StrSortCase();\n    s.load();\n    s.dump(\"Before\");\n    Collections.sort(s.v, String.CASE_INSENSITIVE_ORDER);\n    s.dump(\"After\");\n}\n","name":"main","className":"StrSortCase","variables":{"s":4,"Collections":1},"constants":{"\"StrSort Demo Ignoring Case\"":1,"\"After\"":1,"\"Before\"":1},"javaDoc":"Simple main program to test the sorting","comments":"BEGIN main  Simple main program to test the sorting ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"forEach":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayIterator<String>":1,"String":1,"ArrayIterator":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"LambdaExpr":1,"NameExpr":17,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    ArrayIterator<String> arrayIterator = new ArrayIterator<>(names);\n    // Java 5, 6 way\n    for (String s : arrayIterator) {\n        System.out.println(s);\n    }\n    // Java 8 way\n    arrayIterator.forEach( s -> System.out.println(s));\n}\n","name":"main","className":"ArrayIteratorDemo","variables":{"names":1,"s":2,"arrayIterator":3},"constants":{},"javaDoc":"","comments":"Java 5 6 way Java 8 way ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"forEach":1,"asList":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Collection<String>":1},"expressions":{"VariableDeclarationExpr":1,"LambdaExpr":1,"NameExpr":12,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    Collection<String> // <1>\n    c = // <2>\n    Arrays.asList(\"One\", \"Two\", \"Three\");\n    // <3>\n    c.forEach( s -> System.out.println(s));\n}\n","name":"main","className":"IterableForEach","variables":{"c":2,"s":1,"Arrays":1},"constants":{"\"One\"":1,"\"Two\"":1,"\"Three\"":1},"javaDoc":"","comments":"<1> <2> <3> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":2,"dump":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayInitializerExpr":1,"StringLiteralExpr":6,"NameExpr":14,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] unused) {\n    String[] strings = { \"painful\", \"mainly\", \"gaining\", \"raindrops\" };\n    Arrays.sort(strings);\n    dump(strings, \"Using Default Sort\");\n    Arrays.sort(strings, new SubstringComparator());\n    dump(strings, \"Using SubstringComparator\");\n}\n","name":"main","className":"SubstrCompDemo","variables":{"strings":1,"Arrays":2},"constants":{"\"Using Default Sort\"":1,"\"gaining\"":1,"\"mainly\"":1,"\"painful\"":1,"\"Using SubstringComparator\"":1,"\"raindrops\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]","String"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":18,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"static void dump(String[] args, String title) {\n    System.out.println(title);\n    for (int i = 0; i < args.length; i++) System.out.println(args[i]);\n}\n","name":"dump","className":"SubstrCompDemo","variables":{"args":1,"i":4},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"foo":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/** Shows autoboxing (in the call to foo(i), i is wrapped automatically)\n     * and auto-unboxing (the return value is automatically unwrapped).\n     */\npublic static void main(String[] args) {\n    int i = 42;\n    // <1>\n    int result = foo(i);\n    System.out.println(result);\n}\n","name":"main","className":"AutoboxDemo","variables":{"result":1,"i":1},"constants":{"42":1},"javaDoc":"Shows autoboxing (in the call to foo(i) i is wrapped automatically) and auto-unboxing (the return value is automatically unwrapped)","comments":"<1>  Shows autoboxing (in the call to foo(i), i is wrapped automatically)\n     * and auto-unboxing (the return value is automatically unwrapped).\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Integer"],"returnType":"Integer","methodCalls":{"valueOf":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public static Integer foo(Integer i) {\n    System.out.println(\"Object = \" + i);\n    // <2>\n    return Integer.valueOf(123);\n}\n","name":"foo","className":"AutoboxDemo","variables":{"Integer":1,"i":1},"constants":{"123":1,"\"Object = \"":1},"javaDoc":"","comments":"<2> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getKey":1,"getValue":1,"entrySet":1,"forEach":1,"get":2,"keySet":1,"put":7,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<String, String>":1,"HashMap":1,"String":3},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":9,"LambdaExpr":1,"NameExpr":71,"StringLiteralExpr":22,"FieldAccessExpr":5,"MethodCallExpr":19},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":16},"text":"public static void main(String[] argv) {\n    // Construct and load the hash. This simulates loading a\n    // database or reading from a file, or wherever the data is.\n    Map<String, String> map = new HashMap<String, String>();\n    // The hash maps from company name to address.\n    // In real life this might map to an Address object...\n    map.put(\"Adobe\", \"Mountain View, CA\");\n    map.put(\"IBM\", \"White Plains, NY\");\n    map.put(\"Learning Tree\", \"Los Angeles, CA\");\n    map.put(\"Microsoft\", \"Redmond, WA\");\n    map.put(\"Netscape\", \"Mountain View, CA\");\n    map.put(\"O'Reilly\", \"Sebastopol, CA\");\n    map.put(\"Sun\", \"Mountain View, CA\");\n    // Two versions of the \"retrieval\" phase.\n    // Version 1: get one pair's value given its key\n    // (presumably the key would really come from user input):\n    String queryString = \"O'Reilly\";\n    System.out.println(\"You asked about \" + queryString + \".\");\n    String resultString = map.get(queryString);\n    System.out.println(\"They are located in: \" + resultString);\n    System.out.println();\n    // (maybe to print a report, or to save to disk)\n    for (String key : map.keySet()) {\n        System.out.println(\"Key \" + key + \"; Value \" + map.get(key));\n    }\n    // Version 3: Same but using a Map.Entry lambda\n    map.entrySet().forEach( mE -> System.out.println(\"Key + \" + mE.getKey() + \"; Value \" + mE.getValue()));\n}\n         // Version 2: get ALL the keys and values \n\n","name":"main","className":"HashMapDemo","variables":{"resultString":2,"mE":3,"queryString":2,"map":12,"key":2},"constants":{"\"They are located in: \"":1,"\"Microsoft\"":1,"\"White Plains, NY\"":1,"\"Adobe\"":1,"\"Key + \"":1,"\"Key \"":1,"\"Learning Tree\"":1,"\"Los Angeles, CA\"":1,"\"Mountain View, CA\"":3,"\"IBM\"":1,"\"Redmond, WA\"":1,"\"Netscape\"":1,"\".\"":1,"\"Sebastopol, CA\"":1,"\"You asked about \"":1,"\"O'Reilly\"":2,"\"Sun\"":1,"\"; Value \"":2},"javaDoc":"","comments":"Construct and load the hash This simulates loading a database or reading from a file or wherever the data is The hash maps from company name to address Two versions of the \"retrieval\" phase Version 1: get one pair's value given its key Version 2: get ALL the keys and values In real life this might map to an Address object (presumably the key would really come from user input): (maybe to print a report or to save to disk) Version 3: Same but using a Map Entry lambda ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"toArray":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["Casting","PolyMorphism"],"types":{"ArrayList":1,"String[]":1,"Object[]":1,"List<String>":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":31,"StringLiteralExpr":5,"CastExpr":1,"FieldAccessExpr":4,"ArrayCreationExpr":1,"MethodCallExpr":7},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    // BEGIN main\n    List<String> list = new ArrayList<>();\n    list.add(\"Blobbo\");\n    list.add(\"Cracked\");\n    list.add(\"Dumbo\");\n    // Convert a collection to Object[], which can store objects\n    // of any type.\n    Object[] ol = list.toArray();\n    System.out.println(\"Array of Object has length \" + ol.length);\n    String[] sl = (String[]) list.toArray(new String[0]);\n    System.out.println(\"Array of String has length \" + sl.length);\n// END main\n}\n","name":"main","className":"ToArray","variables":{"sl":1,"list":6,"ol":1},"constants":{"0":1,"\"Array of Object has length \"":1,"\"Array of String has length \"":1,"\"Dumbo\"":1,"\"Cracked\"":1,"\"Blobbo\"":1},"javaDoc":"","comments":"Convert a collection to Object[] which can store objects END main BEGIN main of any type ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","Media"],"returnType":"Product","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":3,"ThisExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public Product(String artist, String title, Media media) {\n    this.title = title;\n    this.artist = artist;\n    this.media = media;\n}\n","name":"Product","className":"Product","variables":{"artist":1,"media":1,"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":7,"NameExpr":13,"StringLiteralExpr":6},"statements":{"SwitchStmt":1,"SwitchEntryStmt":6,"ReturnStmt":6},"text":"@Override\npublic String toString() {\n    switch(media) {\n        case BOOK:\n            return title + \" is a book\";\n        case MUSIC_CD:\n            return title + \" is a CD\";\n        case MUSIC_VINYL:\n            return title + \" is a relic of the age of vinyl\";\n        case MOVIE_VHS:\n            return title + \" is on old video tape\";\n        case MOVIE_DVD:\n            return title + \" is on DVD\";\n        default:\n            return title + \": Unknown media \" + media;\n    }\n}\n","name":"toString","className":"Product","variables":{"BOOK":1,"MOVIE_VHS":1,"MOVIE_DVD":1,"MUSIC_CD":1,"MUSIC_VINYL":1,"media":2,"title":6},"constants":{"\" is a CD\"":1,"\" is a book\"":1,"\" is on DVD\"":1,"\" is a relic of the age of vinyl\"":1,"\": Unknown media \"":1,"\" is on old video tape\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":16,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] unused) {\n    String[] strings = { \"painful\", \"mainly\", \"gaining\", \"raindrops\" };\n    Arrays.sort(strings);\n    for (int i = 0; i < strings.length; i++) {\n        System.out.println(strings[i]);\n    }\n}\n","name":"main","className":"SortArray","variables":{"strings":2,"i":4,"Arrays":1},"constants":{"0":1,"\"gaining\"":1,"\"mainly\"":1,"\"painful\"":1,"\"raindrops\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":2,"dump":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayInitializerExpr":1,"StringLiteralExpr":6,"NameExpr":14,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] unused) {\n    String[] strings = { \"painful\", \"mainly\", \"gaining\", \"raindrops\" };\n    Arrays.sort(strings);\n    dump(strings, \"Using Default Sort\");\n    Arrays.sort(strings, new SubstringComparator());\n    dump(strings, \"Using SubstringComparator\");\n}\n","name":"main","className":"SubstringComparatorDemo","variables":{"strings":1,"Arrays":2},"constants":{"\"Using Default Sort\"":1,"\"gaining\"":1,"\"mainly\"":1,"\"painful\"":1,"\"Using SubstringComparator\"":1,"\"raindrops\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]","String"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":13,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"ForeachStmt":1,"ExpressionStmt":2},"text":"static void dump(String[] args, String title) {\n    System.out.println(title);\n    for (String s : args) System.out.println(s);\n}\n","name":"dump","className":"SubstringComparatorDemo","variables":{"args":1,"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic boolean empty() {\n    return depth == 0;\n}\n","name":"empty","className":"ToyStack2","variables":{"depth":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Integer"],"returnType":"void","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":3,"UnaryExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void push(Integer n) {\n    stack[depth++] = n;\n}\n","name":"push","className":"ToyStack2","variables":{"stack":1,"depth":1,"n":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Integer","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":2,"UnaryExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic Integer pop() {\n    return stack[--depth];\n}\n","name":"pop","className":"ToyStack2","variables":{"stack":1,"depth":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Integer","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"@Override\npublic Integer peek() {\n    return stack[depth - 1];\n}\n","name":"peek","className":"ToyStack2","variables":{"stack":1,"depth":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Person"],"returnType":"void","methodCalls":{"add":2,"getName":1,"select":1,"size":1,"get":1,"compareTo":1,"getLastName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":34,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":9,"AssignExpr":1},"statements":{"IfStmt":1,"BreakStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"/** Add one (new) Person to the list, keeping the list sorted. */\nprotected void add(Person p) {\n    String lastName = p.getLastName();\n    int i;\n    // Find in \"i\" the position in the list where to insert this person\n    for (i = 0; i < usrList.size(); i++) if (lastName.compareTo((usrList.get(i)).getLastName()) <= 0)\n        // If we don't break, will insert at end of list.\n        break;\n    usrList.add(i, p);\n    // Now insert them in the scrolling list, in the same position.\n    visList.add(p.getName(), i);\n    // ensure current\n    visList.select(i);\n}\n","name":"add","className":"CallTrack","variables":{"p":2,"lastName":2,"usrList":3,"i":4,"visList":2},"constants":{"0":2},"javaDoc":"Add one (new) Person to the list keeping the list sorted","comments":"Find in \"i\" the position in the list where to insert this person If we don't break will insert at end of list Now insert them in the scrolling list in the same position ensure current  Add one (new) Person to the list, keeping the list sorted. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/** empty - return true if the stack is empty */\nabstract boolean empty();\n","name":"empty","className":"SimpleStack","variables":{},"constants":{},"javaDoc":"empty - return true if the stack is empty","comments":" empty - return true if the stack is empty ","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":["T"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/** push - add an element onto the stack */\nabstract void push(T n);\n","name":"push","className":"SimpleStack","variables":{},"constants":{},"javaDoc":"push - add an element onto the stack","comments":" push - add an element onto the stack ","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":[],"returnType":"T","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/** pop - return and remove the top element */\nabstract T pop();\n","name":"pop","className":"SimpleStack","variables":{},"constants":{},"javaDoc":"pop - return and remove the top element","comments":" pop - return and remove the top element ","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":[],"returnType":"T","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/** peek - return the top element but don't remove it */\nabstract T peek();\n","name":"peek","className":"SimpleStack","variables":{},"constants":{},"javaDoc":"peek - return the top element but don't remove it","comments":" peek - return the top element but don't remove it ","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":[],"returnType":"MyStack","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MyStack() {\n    this(DEFAULT_INITIAL);\n}\n","name":"MyStack","className":"MyStack","variables":{"DEFAULT_INITIAL":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"MyStack","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":1,"CastExpr":1,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"public MyStack(int howBig) {\n    if (howBig <= 0) {\n        throw new IllegalArgumentException(howBig + \" must be positive, but was \" + howBig);\n    }\n    stack = (T[]) new Object[howBig];\n}\n","name":"MyStack","className":"MyStack","variables":{"stack":1,"howBig":4},"constants":{"0":1,"\" must be positive, but was \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic boolean empty() {\n    return depth == 0;\n}\n","name":"empty","className":"MyStack","variables":{"depth":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["T"],"returnType":"void","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":3,"UnaryExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** push - add an element onto the stack */\n@Override\npublic void push(T obj) {\n    // Could check capacity and expand\n    stack[depth++] = obj;\n}\n","name":"push","className":"MyStack","variables":{"stack":1,"depth":1,"obj":1},"constants":{},"javaDoc":"push - add an element onto the stack","comments":"Could check capacity and expand  push - add an element onto the stack ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"T","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"T":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"NameExpr":6,"UnaryExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/* pop - return and remove the top element */\n@Override\npublic T pop() {\n    --depth;\n    T tmp = stack[depth];\n    stack[depth] = null;\n    return tmp;\n}\n","name":"pop","className":"MyStack","variables":{"stack":2,"depth":3,"tmp":2},"constants":{"null":1},"javaDoc":"","comments":" pop - return and remove the top element ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"T","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2},"text":"/** peek - return the top element but don't remove it */\n@Override\npublic T peek() {\n    if (depth == 0) {\n        return null;\n    }\n    return stack[depth - 1];\n}\n","name":"peek","className":"MyStack","variables":{"stack":1,"depth":2},"constants":{"0":1,"1":1,"null":1},"javaDoc":"peek - return the top element but don't remove it","comments":" peek - return the top element but don't remove it ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean hasNext() {\n    return depth > 0;\n}\n","name":"hasNext","className":"MyStack","variables":{"depth":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean hasRoom() {\n    return depth < stack.length;\n}\n","name":"hasRoom","className":"MyStack","variables":{"depth":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getStackDepth() {\n    return depth;\n}\n","name":"getStackDepth","className":"MyStack","variables":{"depth":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"node":1,"putInt":1,"get":2,"putDouble":1,"exportSubtree":1,"userNodeForPackage":1,"put":2,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"String":2,"Preferences":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"NameExpr":45,"StringLiteralExpr":11,"ClassExpr":1,"FieldAccessExpr":4,"MethodCallExpr":11},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) throws Exception {\n    // Setup the Preferences for this application, by class.\n    Preferences prefs = Preferences.userNodeForPackage(PrefsDemo.class);\n    // Retrieve some preferences previously stored, with defaults in case\n    // this is the first run.\n    String text = prefs.get(\"textFontName\", \"lucida-bright\");\n    String display = prefs.get(\"displayFontName\", \"lucida-blackletter\");\n    System.out.println(text);\n    System.out.println(display);\n    // Assume the user chose new preference values: Store them back.\n    prefs.put(\"textFontName\", \"times-roman\");\n    prefs.put(\"displayFontName\", \"helvetica\");\n    // Toss in a couple more values for the curious who want to look\n    // at how Preferences values are actually stored.\n    Preferences child = prefs.node(\"a/b\");\n    child.putInt(\"meaning\", 42);\n    child.putDouble(\"pi\", Math.PI);\n    // And dump the subtree from our first node on down, in XML.\n    prefs.exportSubtree(System.out);\n}\n","name":"main","className":"PrefsDemo","variables":{"display":1,"text":1,"Preferences":1,"prefs":7,"child":3},"constants":{"\"times-roman\"":1,"\"helvetica\"":1,"\"lucida-bright\"":1,"\"displayFontName\"":2,"\"meaning\"":1,"\"pi\"":1,"\"a/b\"":1,"\"lucida-blackletter\"":1,"42":1,"\"textFontName\"":2},"javaDoc":"","comments":"Retrieve some preferences previously stored with defaults in case Toss in a couple more values for the curious who want to look Setup the Preferences for this application by class this is the first run Assume the user chose new preference values: Store them back at how Preferences values are actually stored And dump the subtree from our first node on down in XML ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String"],"returnType":"int","methodCalls":{"compareTo":1,"substring":2},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":12,"AssignExpr":2,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"@Override\npublic int compare(String s1, String s2) {\n    s1 = s1.substring(1);\n    s2 = s2.substring(1);\n    return s1.compareTo(s2);\n// or, more concisely:\n// return s1.substring(1).compareTo(s2.substring(1));\n}\n","name":"compare","className":"SubstringComparator","variables":{"s1":3,"s2":2},"constants":{"1":2},"javaDoc":"","comments":"or more concisely: return s1 substring(1) compareTo(s2 substring(1)); ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"forEach":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayList":1,"ArrayList<String>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"LambdaExpr":1,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    ArrayList<String> data = new ArrayList<>();\n    data.add(\"hello\");\n    data.add(\"goodbye\");\n    // data.add(new Date()); This won't compile!\n    data.forEach( s -> System.out.println(s));\n}\n","name":"main","className":"ArrayListGenericDemo","variables":{"s":1,"data":4},"constants":{"\"hello\"":1,"\"goodbye\"":1},"javaDoc":"","comments":"data add(new Date()); This won't compile! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"equals":1,"get":1,"hasNext":1,"keySet":1,"put":7,"remove":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<String, String>":1,"HashMap":1,"Iterator<String>":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":48,"StringLiteralExpr":18,"FieldAccessExpr":1,"MethodCallExpr":15},"statements":{"ContinueStmt":1,"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":12},"text":"public static void main(String[] argv) {\n    // Construct and load the hash. This simulates loading a\n    // database or reading from a file, or wherever the data is.\n    Map<String, String> map = new HashMap<String, String>();\n    // The hash maps from company name to address.\n    // In real life this might map to an Address object...\n    map.put(\"Adobe\", \"Mountain View, CA\");\n    map.put(\"IBM\", \"White Plains, NY\");\n    map.put(\"Learning Tree\", \"Los Angeles, CA\");\n    map.put(\"Microsoft\", \"Redmond, WA\");\n    map.put(\"Netscape\", \"Mountain View, CA\");\n    map.put(\"O'Reilly\", \"Sebastopol, CA\");\n    map.put(\"Sun\", \"Mountain View, CA\");\n    // BEGIN SafeRemoval\n    // Version 2: get ALL the keys and values \n    // with concurrent modification\n    Iterator<String> it = map.keySet().iterator();\n    while (it.hasNext()) {\n        String key = it.next();\n        if (key.equals(\"Sun\")) {\n            it.remove();\n            continue;\n        }\n        System.out.println(\"Company \" + key + \"; \" + \"Address \" + map.get(key));\n    }\n// END SafeRemoval\n}\n","name":"main","className":"HashMapWithRemoves","variables":{"it":4,"map":10,"key":3},"constants":{"\"Company \"":1,"\"Microsoft\"":1,"\"White Plains, NY\"":1,"\"Adobe\"":1,"\"Address \"":1,"\"; \"":1,"\"Learning Tree\"":1,"\"Los Angeles, CA\"":1,"\"Mountain View, CA\"":3,"\"IBM\"":1,"\"Redmond, WA\"":1,"\"Netscape\"":1,"\"Sebastopol, CA\"":1,"\"O'Reilly\"":1,"\"Sun\"":2},"javaDoc":"","comments":"Construct and load the hash This simulates loading a database or reading from a file or wherever the data is The hash maps from company name to address BEGIN SafeRemoval Version 2: get ALL the keys and values END SafeRemoval In real life this might map to an Address object with concurrent modification ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"get":1,"length":1,"getString":4,"System.out.println":5,"getJSONArray":1},"annotations":[],"exceptions":["NullPointerException","Exception"],"concepts":[],"types":{"JSONObject":1,"InputStream":1,"JSONArray":1,"int":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":8,"NameExpr":55,"StringLiteralExpr":11,"ClassExpr":1,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":13},"statements":{"IfStmt":1,"BlockStmt":2,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) throws Exception {\n    InputStream jsonInput = SoftwareParseOrgJson.class.getResourceAsStream(FILE_NAME);\n    if (jsonInput == null) {\n        throw new NullPointerException(\"can't find\" + FILE_NAME);\n    }\n    // <1>\n    JSONObject obj = new JSONObject(new JSONTokener(jsonInput));\n    // <2>\n    System.out.println(\"Software Name: \" + obj.getString(\"name\"));\n    System.out.println(\"Version: \" + obj.getString(\"version\"));\n    System.out.println(\"Description: \" + obj.getString(\"description\"));\n    System.out.println(\"Class: \" + obj.getString(\"className\"));\n    // <3>\n    JSONArray contribs = obj.getJSONArray(\"contributors\");\n    for (int i = 0; i < contribs.length(); i++) {\n        // <4>\n        System.out.println(\"Contributor Name: \" + contribs.get(i));\n    }\n}\n","name":"main","className":"SoftwareParseOrgJson","variables":{"obj":6,"i":3,"jsonInput":3,"FILE_NAME":1,"contribs":3},"constants":{"\"contributors\"":1,"\"version\"":1,"\"description\"":1,"\"can't find\"":1,"\"Contributor Name: \"":1,"\"Class: \"":1,"0":1,"\"Software Name: \"":1,"null":1,"\"name\"":1,"\"Description: \"":1,"\"className\"":1,"\"Version: \"":1},"javaDoc":"","comments":"<1> <2> <3> <4> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readValue":1,"writeValue":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1,"Person":2,"ObjectMapper":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":3,"StringLiteralExpr":6,"NameExpr":23,"ClassExpr":1,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) throws IOException {\n    // <1>\n    ObjectMapper mapper = new ObjectMapper();\n    String // <2>\n    jsonInput = \"{\\\"id\\\":0,\\\"firstName\\\":\\\"Robin\\\",\\\"lastName\\\":\\\"Wilson\\\"}\";\n    Person q = mapper.readValue(jsonInput, Person.class);\n    System.out.println(\"Read and parsed Person from JSON: \" + q);\n    // <3>\n    Person p = new Person(\"Roger\", \"Rabbit\");\n    System.out.print(\"Person object \" + p + \" as JSON = \");\n    mapper.writeValue(System.out, p);\n}\n","name":"main","className":"ReadWriteJackson","variables":{"p":2,"q":2,"mapper":3,"jsonInput":1},"constants":{"\"Roger\"":1,"\" as JSON = \"":1,"\"Rabbit\"":1,"\"{\\\"id\\\":0,\\\"firstName\\\":\\\"Robin\\\",\\\"lastName\\\":\\\"Wilson\\\"}\"":1,"\"Person object \"":1,"\"Read and parsed Person from JSON: \"":1},"javaDoc":"","comments":"<1> <2> <3> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toJson":1,"now":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LocalDate":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":11,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    LocalDate dNow = LocalDate.now();\n    System.out.println(toJson(dNow));\n}\n","name":"main","className":"LocalDateToJsonManually","variables":{"dNow":1,"LocalDate":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["LocalDate"],"returnType":"String","methodCalls":{"getYear":1,"toString":1,"getMonth":1,"getDayOfMonth":1,"jsonize":3,"append":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuilder":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":39,"StringLiteralExpr":5,"MethodCallExpr":14},"statements":{"ReturnStmt":1,"ExpressionStmt":6},"text":"public static String toJson(LocalDate dNow) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(OPEN).append(\"\\n\");\n    sb.append(jsonize(\"year\", dNow.getYear()));\n    sb.append(jsonize(\"month\", dNow.getMonth()));\n    sb.append(jsonize(\"day\", dNow.getDayOfMonth()));\n    sb.append(CLOSE).append(\"\\n\");\n    return sb.toString();\n}\n","name":"toJson","className":"LocalDateToJsonManually","variables":{"dNow":3,"sb":7},"constants":{"\"month\"":1,"\"day\"":1,"\"\\n\"":2,"\"year\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Object"],"returnType":"String","methodCalls":{"format":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public static String jsonize(String key, Object value) {\n    return String.format(\"\\\"%s\\\": \\\"%s\\\",\\n\", key, value);\n}\n","name":"jsonize","className":"LocalDateToJsonManually","variables":{"String":1},"constants":{"\"\\\"%s\\\": \\\"%s\\\",\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readValue":1,"System.out.println":1},"annotations":[],"exceptions":["NullPointerException","Exception"],"concepts":[],"types":{"InputStream":1,"ObjectMapper":1,"SoftwareInfo":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":15,"StringLiteralExpr":1,"ClassExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) throws Exception {\n    // <1>\n    ObjectMapper mapper = new ObjectMapper();\n    InputStream jsonInput = SoftwareParseJackson.class.getResourceAsStream(FILE_NAME);\n    if (jsonInput == null) {\n        throw new NullPointerException(\"can't find\" + FILE_NAME);\n    }\n    SoftwareInfo sware = mapper.readValue(jsonInput, SoftwareInfo.class);\n    System.out.println(sware);\n}\n","name":"main","className":"SoftwareParseJackson","variables":{"mapper":2,"jsonInput":2,"sware":1,"FILE_NAME":1},"constants":{"null":1,"\"can't find\"":1},"javaDoc":"","comments":"<1> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":1,"put":3,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JSONObject":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":16,"StringLiteralExpr":6,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    JSONObject jsonObject = new JSONObject();\n    // <1>\n    jsonObject.put(\"Name\", \"robinParse\").put(\"Version\", \"1.2.3\").put(\"Class\", \"RobinParse\");\n    // <2>\n    String printable = jsonObject.toString();\n    System.out.println(printable);\n}\n","name":"main","className":"WriteOrgJson","variables":{"jsonObject":3,"printable":1},"constants":{"\"Version\"":1,"\"robinParse\"":1,"\"Class\"":1,"\"Name\"":1,"\"1.2.3\"":1,"\"RobinParse\"":1},"javaDoc":"","comments":"<1> <2> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Calc":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":10,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Calc client = new CalcService().getCalcPort();\n    System.out.println(client.add(2, 2));\n}\n","name":"main","className":"TinyClientMain","variables":{"client":2},"constants":{"2":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":11,"FieldAccessExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    int[] a = new int[4];\n    System.out.println(a.length);\n    // EXPECT COMPILE ERROR\n    a.length = 5;\n// END main\n}\n","name":"main","className":"ChangeArrayLength","variables":{"a":1},"constants":{"4":1,"5":1},"javaDoc":"","comments":"END main BEGIN main EXPECT COMPILE ERROR ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"public abstract void myMethod(Object o);\n","name":"myMethod","className":"Top","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"@Override\npublic void myMethod(String s) {\n// EXPECT COMPILE ERROR\n// Do something here...\n}\n","name":"myMethod","className":"Bottom","variables":{},"constants":{},"javaDoc":"","comments":"EXPECT COMPILE ERROR Do something here ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"default String filter(String s) {\n    return \"Filtered \" + s;\n}\n","name":"filter","className":"Bar","variables":{"s":1},"constants":{"\"Filtered \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"default String convolve(String s) {\n    return \"Convolved \" + s;\n}\n","name":"convolve","className":"Foo","variables":{"s":1},"constants":{"\"Convolved \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":2,"ConditionalExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    String input = args.length > 0 ? args[0] : \"Hello\";\n    String output = new MixinsDemo().process(input);\n    System.out.println(output);\n}\n","name":"main","className":"MixinsDemo","variables":{"args":1,"output":1,"input":1},"constants":{"0":2,"\"Hello\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"filter":1,"convolve":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"private String process(String s) {\n    // methods mixed in!\n    return filter(convolve(s));\n}\n","name":"process","className":"MixinsDemo","variables":{},"constants":{},"javaDoc":"","comments":"methods mixed in! ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getClass":1,"forName":1,"invoke":1,"getMethod":1,"System.err.println":1,"System.out.println":3},"annotations":["SuppressWarnings"],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Class<?>[]":1,"Method":1,"String[]":1,"Class<?>":1,"Object[]":1},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":5,"ArrayInitializerExpr":3,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":44,"StringLiteralExpr":6,"FieldAccessExpr":5,"MethodCallExpr":9},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"// BEGIN main\n@SuppressWarnings(\"unchecked\")\npublic static void main(String[] args) {\n    System.out.println(\"In lang.InvokeMain.main()\");\n    if (args.length == 1 && args[0].equals(\"quit\")) {\n        return;\n    }\n    try {\n        // First, find the class.\n        Class<?> c = Class.forName(\"lang.InvokeMain\");\n        System.out.println(c);\n        // Create the array of Argument Types\n        Class<?>[] argTypes = { // args is String!\n        args.getClass() };\n        // Now find the method\n        Method m = c.getMethod(\"main\", argTypes);\n        System.out.println(\"Found method\" + m);\n        // Create the actual argument array\n        String[] newArgs = { \"quit\" };\n        Object[] passedArgs = { newArgs };\n        // Now invoke the method. Null for \"this ref\" because it's static\n        m.invoke(null, passedArgs);\n    } catch (Exception e) {\n        System.err.println(e);\n    }\n}\n             //e.printStackTrace();\n\n","name":"main","className":"InvokeMain","variables":{"args":2,"argTypes":1,"passedArgs":1,"c":2,"e":1,"Class":1,"m":3,"newArgs":2},"constants":{"\"In lang.InvokeMain.main()\"":1,"0":1,"1":1,"\"quit\"":2,"null":1,"\"main\"":1,"\"Found method\"":1,"\"lang.InvokeMain\"":1},"javaDoc":"","comments":"First find the class Create the array of Argument Types args is String! Now find the method Create the actual argument array Now invoke the method Null for \"this ref\" because it's static e printStackTrace();  BEGIN main","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":8},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":16,"BinaryExpr":16,"NameExpr":40,"StringLiteralExpr":8,"CastExpr":2,"FieldAccessExpr":8,"EnclosedExpr":8,"MethodCallExpr":8},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    System.out.println(\" 2<<4 = \" + (2 << 4));\n    System.out.println(\" 2<<8 = \" + (2 << 8));\n    System.out.println(\"2<<16 = \" + (2 << 16));\n    System.out.println(\"2<<24 = \" + (2 << 24));\n    System.out.println(\"2<<31 = \" + (2 << 31));\n    System.out.println(\"2<<32 = \" + (2 << 32));\n    // Now try those last two as longs\n    System.out.println(\"2<<31 = \" + ((long) 2 << 31));\n    System.out.println(\"2<<32 = \" + ((long) 2 << 32));\n// END main\n}\n","name":"main","className":"Shifting","variables":{},"constants":{"24":1,"\" 2<<8 = \"":1,"16":1,"\"2<<24 = \"":1,"\"2<<31 = \"":2,"\" 2<<4 = \"":1,"2":8,"4":1,"\"2<<16 = \"":1,"8":1,"\"2<<32 = \"":2,"31":2,"32":2},"javaDoc":"","comments":"END main BEGIN main Now try those last two as longs ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"foo":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    System.out.println(\"Hello. The answer is yes.\");\n    // The following is redundant, since we got in here!\n    AbstractStatic.foo();\n// END main\n}\n","name":"main","className":"AbstractStatic","variables":{"AbstractStatic":1},"constants":{"\"Hello. The answer is yes.\"":1},"javaDoc":"","comments":"END main BEGIN main The following is redundant since we got in here! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void foo() {\n    System.out.println(\"Hello from foo. The answer is still yes.\");\n}\n","name":"foo","className":"AbstractStatic","variables":{},"constants":{"\"Hello from foo. The answer is still yes.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"fancy":1,"getName":1,"getAnnotations":1,"System.out.println":3,"order":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Class<?>":1,"AnnotationDemo":1,"Annotation":1},"expressions":{"VariableDeclarationExpr":3,"BinaryExpr":8,"NameExpr":31,"StringLiteralExpr":6,"CastExpr":1,"ClassExpr":1,"FieldAccessExpr":3,"InstanceOfExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ExpressionStmt":5},"text":"/** Print out the annotations attached to this class */\npublic static void main(String[] args) {\n    Class<?> c = FancyClassJustToShowAnnotation.class;\n    System.out.println(\"Class \" + c.getName() + \" has these annotations:\");\n    for (Annotation a : c.getAnnotations()) {\n        if (a instanceof AnnotationDemo) {\n            AnnotationDemo ad = (AnnotationDemo) a;\n            System.out.println(\"\\t\" + a + \" with fancy=\" + ad.fancy() + \" and order \" + ad.order());\n        } else {\n            System.out.println(\"\\tSomebody else's annotation: \" + a);\n        }\n    }\n}\n","name":"main","className":"FancyClassJustToShowAnnotation","variables":{"a":5,"c":3,"ad":3},"constants":{"\" and order \"":1,"\"\\t\"":1,"\"Class \"":1,"\" has these annotations:\"":1,"\" with fancy=\"":1,"\"\\tSomebody else's annotation: \"":1},"javaDoc":"Print out the annotations attached to this class","comments":" Print out the annotations attached to this class ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1,"int":1},"expressions":{"IntegerLiteralExpr":9,"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    long data[] = { 0, 0x01, 0xff, 0x100, 0xffff, 0xffffff, 0x7fffffff, 0xffffffff };\n    for (int i = 0; i < data.length; i++) System.out.println(\"data[\" + i + \"] = \" + data[i]);\n// END main\n}\n","name":"main","className":"HexNeg","variables":{"data":2,"i":5},"constants":{"0":2,"0xffffffff":1,"0x100":1,"0x7fffffff":1,"\"data[\"":1,"0xffffff":1,"\"] = \"":1,"0xffff":1,"0x01":1,"0xff":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"InnerInnerChild","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"private InnerInnerChild() {\n// empty\n}\n","name":"InnerInnerChild","className":"InnerInnerChild","variables":{},"constants":{},"javaDoc":"","comments":"empty ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"InnerChild":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    // System.out.println(new InnerChild.InnerInnerChild()); // NOT how!\n    InnerChild x = new InnerChild();\n    System.out.println(x.new InnerInnerChild());\n}\n","name":"main","className":"InnerChild","variables":{"x":2},"constants":{},"javaDoc":"","comments":"System out println(new InnerChild InnerInnerChild()); // NOT how! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"mySumCalls":1,"passThrough":1,"process":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":4,"NameExpr":22,"StringLiteralExpr":5,"CastExpr":3,"FieldAccessExpr":4,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    mySumCalls();\n    // BEGIN processCalls\n    process(System.out, \"Hello\", \"Goodbye\");\n    process(System.out, (int) 42, (int) 1066, (int) 1776);\n    process(System.out, \"Foo\", new Date(), new Object());\n    // END processCalls\n    // BEGIN passThroughCalls\n    passThrough(System.out, \"%s %s %s%n\", \"Foo\", new Date(), new Object());\n// END passThroughCalls\n}\n","name":"main","className":"VarArgsDemo","variables":{},"constants":{"\"Hello\"":1,"1776":1,"\"Goodbye\"":1,"1066":1,"\"%s %s %s%n\"":1,"42":1,"\"Foo\"":2},"javaDoc":"","comments":"END processCalls END passThroughCalls BEGIN processCalls BEGIN passThroughCalls ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"// BEGIN mySumDefn\nstatic int mySum(int... args) {\n    int total = 0;\n    for (int a : args) {\n        total += a;\n    }\n    return total;\n}\n","name":"mySum","className":"VarArgsDemo","variables":{"args":1,"a":2,"total":3},"constants":{"0":1},"javaDoc":"","comments":" BEGIN mySumDefn","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":[],"returnType":"void","methodCalls":{"mySum":4,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":1,"ArrayInitializerExpr":1,"NameExpr":29,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"ExpressionStmt":5},"text":"// END mySumDefn\npublic static void mySumCalls() {\n    // BEGIN mySumCalls\n    System.out.println(mySum(5, 7, 9));\n    System.out.println(mySum(5));\n    System.out.println(mySum());\n    int[] nums = { 5, 7, 9 };\n    System.out.println(mySum(nums));\n// END mySumCalls\n}\n","name":"mySumCalls","className":"VarArgsDemo","variables":{"nums":1},"constants":{"5":3,"7":2,"9":2},"javaDoc":"","comments":"END mySumCalls BEGIN mySumCalls ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["PrintStream","String","Object"],"returnType":"void","methodCalls":{"line":1,"printf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Show passing the entire varargs list on to another method\n     * @param out\n     * @param fmt\n     * @param args\n     */\nstatic void passThrough(PrintStream out, String fmt, Object... args) {\n    line();\n    out.printf(fmt, args);\n}\n","name":"passThrough","className":"VarArgsDemo","variables":{"out":1},"constants":{},"javaDoc":"Show passing the entire varargs list on to another method out fmt args","comments":" Show passing the entire varargs list on to another method\n     * @param out\n     * @param fmt\n     * @param args\n     ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["PrintStream","Object"],"returnType":"void","methodCalls":{"print":1,"line":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":13,"StringLiteralExpr":3,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":4},"text":"/** Show iterating through the varargs list.\n     * @param out\n     * @param args\n     */\nstatic void process(PrintStream out, Object... args) {\n    line();\n    int i = 0;\n    for (Object o : args) {\n        out.print(\"Argument \" + ++i + \" is \" + o + \"; \");\n    }\n    System.out.println();\n}\n","name":"process","className":"VarArgsDemo","variables":{"args":1,"i":2,"o":2,"out":1},"constants":{"0":1,"\" is \"":1,"\"Argument \"":1,"\"; \"":1},"javaDoc":"Show iterating through the varargs list out args","comments":" Show iterating through the varargs list.\n     * @param out\n     * @param args\n     ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** toy, draw a line... */\nprivate static void line() {\n    System.out.println(\"--------------------------\");\n}\n","name":"line","className":"VarArgsDemo","variables":{},"constants":{"\"--------------------------\"":1},"javaDoc":"toy draw a line","comments":" toy, draw a line... ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["FileSaver"],"returnType":"AutoSave","methodCalls":{"setDaemon":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":4,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":2},"text":"public AutoSave(FileSaver m) {\n    super(\"AutoSave Thread\");\n    // so we don't keep the main app alive\n    setDaemon(true);\n    model = m;\n}\n","name":"AutoSave","className":"AutoSave","variables":{"model":1,"m":1},"constants":{"true":1,"\"AutoSave Thread\"":1},"javaDoc":"","comments":"so we don't keep the main app alive ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"saveFile":1,"wantAutoSave":1,"hasUnsavedChanges":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":12,"MethodCallExpr":4},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    while (true) {\n        // entire run method runs forever.\n        try {\n            sleep(SECONDS * 1000);\n        } catch (InterruptedException e) {\n        }\n        if (model.wantAutoSave() && model.hasUnsavedChanges())\n            model.saveFile(null);\n    }\n}\n                 // do nothing with it\n\n","name":"run","className":"AutoSave","variables":{"e":1,"SECONDS":1,"model":3},"constants":{"null":1,"true":1,"1000":1},"javaDoc":"","comments":"entire run method runs forever do nothing with it ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Load new model from fn; if null, prompt for new fname */\npublic void loadFile(String fn);\n","name":"loadFile","className":"FileSaver","variables":{},"constants":{},"javaDoc":"Load new model from fn; if null prompt for new fname","comments":" Load new model from fn; if null, prompt for new fname ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Ask the model if it wants AutoSave done for it */\npublic boolean wantAutoSave();\n","name":"wantAutoSave","className":"FileSaver","variables":{},"constants":{},"javaDoc":"Ask the model if it wants AutoSave done for it","comments":" Ask the model if it wants AutoSave done for it ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Ask the model if it has any unsaved changes, don't save otherwise */\npublic boolean hasUnsavedChanges();\n","name":"hasUnsavedChanges","className":"FileSaver","variables":{},"constants":{},"javaDoc":"Ask the model if it has any unsaved changes don't save otherwise","comments":" Ask the model if it has any unsaved changes, don't save otherwise ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Save the current model's data in fn. \n     * If fn == null, use current fname or prompt for a filename if null.\n     */\npublic void saveFile(String fn);\n","name":"saveFile","className":"FileSaver","variables":{},"constants":{},"javaDoc":"Save the current model's data in fn If fn == null use current fname or prompt for a filename if null","comments":" Save the current model's data in fn. \n     * If fn == null, use current fname or prompt for a filename if null.\n     ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sleep":1,"currentTimeMillis":2,"System.out.print":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"long":2,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":4,"NameExpr":17,"CastExpr":1,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    long t0 = System.currentTimeMillis();\n    while (true) {\n        long t1 = System.currentTimeMillis();\n        int seconds = (int) (t1 - t0) / 1000;\n        System.out.print(\"Elapsed: \" + seconds + \"\\r\");\n        try {\n            Thread.sleep(999);\n        } catch (InterruptedException e) {\n        }\n    }\n// END main\n}\n                 // nothing to say\n\n","name":"main","className":"Stopwatch","variables":{"seconds":2,"e":1,"t0":2,"t1":2,"System":2,"Thread":1},"constants":{"\"Elapsed: \"":1,"true":1,"1000":1,"999":1,"\"\\r\"":1},"javaDoc":"","comments":"END main BEGIN main nothing to say ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.in.read":1,"System.err.println":1,"System.out.println":2},"annotations":[],"exceptions":["java.io.IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":21,"StringLiteralExpr":2,"FieldAccessExpr":4,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public void run() {\n    System.out.println(\"Reading\");\n    try {\n        System.in.read();\n    } catch (java.io.IOException ex) {\n        System.err.println(ex);\n    }\n    System.out.println(\"Thread Finished.\");\n}\n","name":"run","className":"","variables":{"ex":1},"constants":{"\"Thread Finished.\"":1,"\"Reading\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.in.read":1,"start":1,"join":1,"System.err.println":1,"System.out.println":6},"annotations":[],"exceptions":["java.io.IOException","InterruptedException"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"Thread":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":49,"StringLiteralExpr":6,"FieldAccessExpr":8,"MethodCallExpr":10},"statements":{"BlockStmt":5,"TryStmt":2,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    Thread t = new Thread() {\n\n        public void run() {\n            System.out.println(\"Reading\");\n            try {\n                System.in.read();\n            } catch (java.io.IOException ex) {\n                System.err.println(ex);\n            }\n            System.out.println(\"Thread Finished.\");\n        }\n    };\n    System.out.println(\"Starting\");\n    t.start();\n    System.out.println(\"Joining\");\n    try {\n        t.join();\n    } catch (InterruptedException ex) {\n        System.out.println(\"Who dares interrupt my sleep?\");\n    }\n    System.out.println(\"Main Finished.\");\n}\n             // should not happen:\n\n","name":"main","className":"Join","variables":{"ex":2,"t":3,"run":1},"constants":{"\"Joining\"":1,"\"Starting\"":1,"\"Who dares interrupt my sleep?\"":1,"\"Main Finished.\"":1,"\"Thread Finished.\"":1,"\"Reading\"":1},"javaDoc":"","comments":"should not happen: ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"StringLiteralExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n     * Main program, test driver for ThreadsDemo2 class.\n     */\npublic static void main(String[] argv) {\n    new ThreadsDemo2(\"Hello from X\", 10);\n    new ThreadsDemo2(\"Hello from Y\", 15);\n}\n","name":"main","className":"ThreadsDemo2","variables":{},"constants":{"\"Hello from X\"":1,"15":1,"10":1,"\"Hello from Y\"":1},"javaDoc":"Main program test driver for ThreadsDemo2 class","comments":"\n     * Main program, test driver for ThreadsDemo2 class.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int"],"returnType":"ThreadsDemo2","methodCalls":{"setName":1,"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":12,"StringLiteralExpr":1,"ThisExpr":1,"AssignExpr":3,"MethodCallExpr":2},"statements":{"ExpressionStmt":5},"text":"/**\n     * Construct a ThreadsDemo2 object\n     * @param m Message to display\n     * @param n How many times to display it\n     */\npublic ThreadsDemo2(String m, int n) {\n    count = n;\n    mesg = m;\n    t = new Thread(this);\n    t.setName(m + \" runner Thread\");\n    t.start();\n}\n","name":"ThreadsDemo2","className":"ThreadsDemo2","variables":{"t":3,"count":1,"m":2,"n":1,"mesg":1},"constants":{"\" runner Thread\"":1},"javaDoc":"Construct a ThreadsDemo2 object m Message to display n How many times to display it","comments":"\n     * Construct a ThreadsDemo2 object\n     * @param m Message to display\n     * @param n How many times to display it\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Run does the work. We override the run() method in Runnable. */\npublic void run() {\n    while (count-- > 0) {\n        System.out.println(mesg);\n        try {\n            // 100 msec\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            return;\n        }\n    }\n    System.out.println(mesg + \" thread all done.\");\n}\n","name":"run","className":"ThreadsDemo2","variables":{"e":1,"count":1,"Thread":1,"mesg":1},"constants":{"0":1,"100":1,"\" thread all done.\"":1},"javaDoc":"Run does the work We override the run() method in Runnable","comments":"100 msec  Run does the work. We override the run() method in Runnable. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"notifyAll":1,"addFirst":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ExpressionStmt":6},"text":"protected void produce() {\n    int len = 0;\n    synchronized (list) {\n        Object justProduced = new Object();\n        list.addFirst(justProduced);\n        len = list.size();\n        list.notifyAll();\n    }\n    System.out.println(\"List size now \" + len);\n}\n","name":"produce","className":"ProdCons1","variables":{"len":3,"justProduced":1,"list":4},"constants":{"0":1,"\"List size now \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"wait":1,"size":2,"removeLast":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Object":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":27,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":6,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":4,"TryStmt":1,"SynchronizedStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"protected void consume() {\n    Object obj = null;\n    int len = 0;\n    synchronized (list) {\n        while (list.size() == 0) {\n            try {\n                list.wait();\n            } catch (InterruptedException ex) {\n                return;\n            }\n        }\n        obj = list.removeLast();\n        len = list.size();\n    }\n    System.out.println(\"Consuming object \" + obj);\n    System.out.println(\"List size now \" + len);\n}\n","name":"consume","className":"ProdCons1","variables":{"ex":1,"len":3,"obj":3,"list":5},"constants":{"0":2,"null":1,"\"List size now \"":1,"\"Consuming object \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.in.read":1,"consume":1,"produce":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["Casting"],"types":{"char":1,"ProdCons1":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":1,"CharLiteralExpr":2,"UnaryExpr":1,"AssignExpr":1,"CastExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"MethodCallExpr":4},"statements":{"SwitchStmt":1,"WhileStmt":1,"BreakStmt":2,"BlockStmt":1,"SwitchEntryStmt":2,"ExpressionStmt":6},"text":"public static void main(String[] args) throws IOException {\n    ProdCons1 pc = new ProdCons1();\n    System.out.println(\"Ready (p to produce, c to consume):\");\n    int i;\n    while ((i = System.in.read()) != -1) {\n        char ch = (char) i;\n        switch(ch) {\n            case 'p':\n                pc.produce();\n                break;\n            case 'c':\n                pc.consume();\n                break;\n        }\n    }\n}\n","name":"main","className":"ProdCons1","variables":{"pc":3,"ch":2,"i":3},"constants":{"1":1,"\"Ready (p to produce, c to consume):\"":1,"'c'":1,"'p'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":1,"readLine":1,"getInputStream":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":24,"StringLiteralExpr":4,"FieldAccessExpr":3,"AssignExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"public void run() {\n    try {\n        // HTTP\n        io = new Socket(\"java.sun.com\", 80);\n        BufferedReader is = new BufferedReader(new InputStreamReader(io.getInputStream()));\n        System.out.println(\"StopClose reading\");\n        // The following line will deadlock (intentionally), since HTTP \n        // enjoins the client to send a request (like \"GET / HTTP/1.0\")\n        // and a null line, before reading the response.\n        // DEADLOCK\n        String line = is.readLine();\n        // Should only get out of the readLine if an interrupt\n        // is thrown, as a result of closing the socket.\n        // So we shouldn't get here, ever:\n        System.out.printf(\"StopClose FINISHED after reading %s!?\", line);\n    } catch (IOException ex) {\n        System.out.println(\"StopClose terminating: \" + ex);\n    }\n}\n","name":"run","className":"StopClose","variables":{"ex":2,"io":2,"line":1,"is":2},"constants":{"\"java.sun.com\"":1,"\"StopClose reading\"":1,"80":1,"\"StopClose FINISHED after reading %s!?\"":1,"\"StopClose terminating: \"":1},"javaDoc":"","comments":"The following line will deadlock (intentionally) since HTTP enjoins the client to send a request (like \"GET / HTTP/1 0\") and a null line before reading the response Should only get out of the readLine if an interrupt is thrown as a result of closing the socket HTTP DEADLOCK So we shouldn't get here ever: ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["Synchronization"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"SynchronizedStmt":1,"ExpressionStmt":2},"text":"public void shutDown() throws IOException {\n    if (io != null) {\n        // This is supposed to interrupt the waiting read.\n        synchronized (io) {\n            io.close();\n        }\n    }\n    System.out.println(\"StopClose.shutDown() completed\");\n}\n","name":"shutDown","className":"StopClose","variables":{"io":3},"constants":{"null":1,"\"StopClose.shutDown() completed\"":1},"javaDoc":"","comments":"This is supposed to interrupt the waiting read ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sleep":1,"start":1,"shutDown":1},"annotations":[],"exceptions":["IOException","InterruptedException"],"concepts":[],"types":{"StopClose":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) throws InterruptedException, IOException {\n    StopClose t = new StopClose();\n    t.start();\n    Thread.sleep(1000 * 5);\n    t.shutDown();\n}\n","name":"main","className":"StopClose","variables":{"t":3,"Thread":1},"constants":{"5":1,"1000":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Run does the work: print a message, \"count\" number of times */\npublic void run() {\n    while (count-- > 0) {\n        System.out.println(mesg);\n        try {\n            // in mSec\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            return;\n        }\n    }\n    System.out.println(mesg + \" all done.\");\n}\n","name":"run","className":"ThreadsDemo1","variables":{"e":1,"count":1,"Thread":1,"mesg":1},"constants":{"0":1,"100":1,"\" all done.\"":1},"javaDoc":"Run does the work: print a message \"count\" number of times","comments":"in mSec  Run does the work: print a message, \"count\" number of times ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"ThreadsDemo1","methodCalls":{"setName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"/**\n     * Construct a ThreadsDemo1 object.\n     * @param m Message to display\n     * @param n How many times to display it\n     */\npublic ThreadsDemo1(final String mesg, int n) {\n    this.mesg = mesg;\n    count = n;\n    setName(mesg + \" runner Thread\");\n}\n","name":"ThreadsDemo1","className":"ThreadsDemo1","variables":{"count":1,"n":1,"mesg":2},"constants":{"\" runner Thread\"":1},"javaDoc":"Construct a ThreadsDemo1 object m Message to display n How many times to display it","comments":"\n     * Construct a ThreadsDemo1 object.\n     * @param m Message to display\n     * @param n How many times to display it\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"StringLiteralExpr":2,"NameExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n     * Main program, test driver for ThreadsDemo1 class.\n     */\npublic static void main(String[] argv) {\n    // could say: new ThreadsDemo1(\"Hello from X\", 10).run();\n    // could say: new ThreadsDemo1(\"Hello from Y\", 15).run();\n    // But then it wouldn't be multi-threaded!\n    new ThreadsDemo1(\"Hello from X\", 10).start();\n    new ThreadsDemo1(\"Hello from Y\", 15).start();\n}\n","name":"main","className":"ThreadsDemo1","variables":{},"constants":{"\"Hello from X\"":1,"15":1,"10":1,"\"Hello from Y\"":1},"javaDoc":"Main program test driver for ThreadsDemo1 class","comments":"could say: new ThreadsDemo1(\"Hello from X\" 10) run(); could say: new ThreadsDemo1(\"Hello from Y\" 15) run(); But then it wouldn't be multi-threaded! \n     * Main program, test driver for ThreadsDemo1 class.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"wait":1,"size":2,"notifyAll":1,"getRequestFromNetwork":1,"addFirst":1,"System.out.println":3},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Object":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":9},"statements":{"IfStmt":1,"WhileStmt":2,"BreakStmt":1,"BlockStmt":5,"TryStmt":1,"SynchronizedStmt":1,"ExpressionStmt":7},"text":"public void run() {\n    while (true) {\n        Object justProduced = getRequestFromNetwork();\n        // might have to wait for hours if the client is having coffee.\n        synchronized (list) {\n            while (list.size() == MAX) {\n                // queue \"full\"\n                try {\n                    System.out.println(\"Producer WAITING\");\n                    // Limit the size\n                    list.wait();\n                } catch (InterruptedException ex) {\n                    System.out.println(\"Producer INTERRUPTED\");\n                }\n            }\n            list.addFirst(justProduced);\n            // must own the lock\n            list.notifyAll();\n            System.out.println(\"Produced 1; List size now \" + list.size());\n            if (done)\n                break;\n        // yield();    // Useful for green threads & demo programs.\n        }\n    }\n}\n                 // Get request from the network - outside the synch section.\n\n                 // We're simulating this actually reading from a client, and it\n\n","name":"run","className":"Producer","variables":{"ex":1,"MAX":1,"justProduced":1,"list":6,"done":1},"constants":{"\"Producer WAITING\"":1,"\"Producer INTERRUPTED\"":1,"true":1,"\"Produced 1; List size now \"":1},"javaDoc":"","comments":"Get request from the network - outside the synch section We're simulating this actually reading from a client and it might have to wait for hours if the client is having coffee yield(); // Useful for green threads & demo programs queue \"full\" Limit the size must own the lock ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"Object getRequestFromNetwork() {\n    // }\n    return (new Object());\n}\n                                             // Simulation of reading from client\n\n             // try {\n\n             //     Thread.sleep(10); // simulate time passing during read\n\n             // } catch (InterruptedException ex) {\n\n             //     System.out.println(\"Producer Read INTERRUPTED\");\n\n","name":"getRequestFromNetwork","className":"Producer","variables":{},"constants":{},"javaDoc":"","comments":"Simulation of reading from client try { Thread sleep(10); // simulate time passing during read } catch (InterruptedException ex) { System out println(\"Producer Read INTERRUPTED\"); } ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"wait":1,"process":1,"size":2,"notifyAll":1,"removeLast":1,"System.out.println":3},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Object":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":37,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":9,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":2,"BreakStmt":1,"BlockStmt":5,"TryStmt":1,"SynchronizedStmt":1,"ExpressionStmt":9},"text":"public void run() {\n    while (true) {\n        Object obj = null;\n        synchronized (list) {\n            while (list.size() == 0) {\n                try {\n                    System.out.println(\"CONSUMER WAITING\");\n                    // must own the lock\n                    list.wait();\n                } catch (InterruptedException ex) {\n                    System.out.println(\"CONSUMER INTERRUPTED\");\n                }\n            }\n            obj = list.removeLast();\n            list.notifyAll();\n            int len = list.size();\n            System.out.println(\"List size now \" + len);\n            if (done)\n                break;\n        }\n        // Outside synch section (could take time)\n        process(obj);\n    //yield(); DITTO\n    }\n}\n","name":"run","className":"Consumer","variables":{"ex":1,"len":2,"obj":2,"list":6,"done":1},"constants":{"0":1,"null":1,"\"List size now \"":1,"true":1,"\"CONSUMER INTERRUPTED\"":1,"\"CONSUMER WAITING\"":1},"javaDoc":"","comments":"yield(); DITTO must own the lock Outside synch section (could take time) ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"void process(Object obj) {\n    // Thread.sleep(1234) // Simulate time passing\n    System.out.println(\"Consuming object \" + obj);\n}\n","name":"process","className":"Consumer","variables":{"obj":1},"constants":{"\"Consuming object \"":1},"javaDoc":"","comments":"Thread sleep(1234) // Simulate time passing ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int","int"],"returnType":"ProdCons2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":10,"UnaryExpr":2,"MethodCallExpr":2},"statements":{"ForStmt":2,"ExpressionStmt":2},"text":"ProdCons2(int nP, int nC) {\n    for (int i = 0; i < nP; i++) new Producer().start();\n    for (int i = 0; i < nC; i++) new Consumer().start();\n}\n","name":"ProdCons2","className":"ProdCons2","variables":{"nP":1,"nC":1,"i":6},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sleep":1,"pc.list.notifyAll":1},"annotations":[],"exceptions":["IOException","InterruptedException"],"concepts":["Synchronization"],"types":{"int":2,"ProdCons2":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":16,"FieldAccessExpr":3,"MethodCallExpr":2,"AssignExpr":1},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) throws IOException, InterruptedException {\n    // Start producers and consumers\n    int numProducers = 4;\n    int numConsumers = 3;\n    ProdCons2 pc = new ProdCons2(numProducers, numConsumers);\n    // Let it run for, say, 10 seconds\n    Thread.sleep(10 * 1000);\n    // End of simulation - shut down gracefully\n    synchronized (pc.list) {\n        pc.done = true;\n        pc.list.notifyAll();\n    }\n}\n","name":"main","className":"ProdCons2","variables":{"pc":1,"numProducers":2,"numConsumers":2,"Thread":1},"constants":{"3":1,"4":1,"1000":1,"true":1,"10":1},"javaDoc":"","comments":"Start producers and consumers Let it run for say 10 seconds End of simulation - shut down gracefully ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"LambdaExpr":1,"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    new Thread(() -> System.out.println(\"Hello from a thread\")).start();\n}\n","name":"main","className":"RunnableLambda","variables":{},"constants":{"\"Hello from a thread\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new ReadersWriterDemo().demo();\n}\n","name":"main","className":"ReadersWriterDemo","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"ReadersWriterDemo","methodCalls":{"add":3},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayList":1,"List<String>":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":11,"StringLiteralExpr":3,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":5},"text":"/**\n     * Constructor: set up some quasi-random initial data\n     */\npublic ReadersWriterDemo() {\n    List<String> questionsList = new ArrayList<>();\n    questionsList.add(\"Agree\");\n    questionsList.add(\"Disagree\");\n    questionsList.add(\"No opinion\");\n    theData = new BallotBox(questionsList);\n}\n","name":"ReadersWriterDemo","className":"ReadersWriterDemo","variables":{"theData":1,"questionsList":5},"constants":{"\"Agree\"":1,"\"No opinion\"":1,"\"Disagree\"":1},"javaDoc":"Constructor: set up some quasi-random initial data","comments":"\n     * Constructor: set up some quasi-random initial data\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"random":1,"getName":1,"getVotes":1,"unlock":1,"forEach":1,"System.out.printf":1,"readLock":2,"lock":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"LambdaExpr":1,"BinaryExpr":1,"NameExpr":31,"StringLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":10},"statements":{"WhileStmt":1,"BlockStmt":5,"TryStmt":2,"ExpressionStmt":5},"text":"public void run() {\n    while (!done) {\n        lock.readLock().lock();\n        try {\n            theData.forEach( p -> System.out.printf(\"%s: votes %d%n\", p.getName(), p.getVotes()));\n        } finally {\n            // Unlock in \"finally\" to be sure it gets done.\n            lock.readLock().unlock();\n        }\n        try {\n            Thread.sleep(((long) (Math.random() * 1000)));\n        } catch (InterruptedException ex) {\n        }\n    }\n}\n                             // nothing to do\n\n","name":"run","className":"","variables":{"p":3,"theData":1,"ex":1,"lock":2,"Math":1,"done":1,"Thread":1},"constants":{"1000":1,"\"%s: votes %d%n\"":1},"javaDoc":"","comments":"Unlock in \"finally\" to be sure it gets done nothing to do ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"random":2,"writeLock":2,"unlock":1,"voteFor":1,"getCandidateCount":1,"lock":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":26,"CastExpr":2,"EnclosedExpr":5,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"WhileStmt":1,"BlockStmt":5,"TryStmt":2,"ExpressionStmt":4},"text":"public void run() {\n    while (!done) {\n        lock.writeLock().lock();\n        try {\n            theData.voteFor(// Performance: should have one PRNG per thread.\n            (((int) (Math.random() * theData.getCandidateCount()))));\n        } finally {\n            lock.writeLock().unlock();\n        }\n        try {\n            Thread.sleep(((long) (Math.random() * 1000)));\n        } catch (InterruptedException ex) {\n        }\n    }\n}\n                             // Vote for random candidate :-)\n\n                         // nothing to do\n\n","name":"run","className":"","variables":{"theData":2,"ex":1,"lock":2,"Math":2,"done":1,"Thread":1},"constants":{"1000":1},"javaDoc":"","comments":"Vote for random candidate :-) Performance: should have one PRNG per thread nothing to do ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":3,"random":3,"getName":1,"getVotes":1,"unlock":2,"writeLock":2,"voteFor":1,"forEach":1,"System.out.printf":1,"readLock":2,"getCandidateCount":1,"lock":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":5,"LambdaExpr":1,"NameExpr":72,"StringLiteralExpr":1,"UnaryExpr":3,"AssignExpr":1,"BooleanLiteralExpr":1,"CastExpr":3,"FieldAccessExpr":1,"EnclosedExpr":7,"MethodCallExpr":22},"statements":{"WhileStmt":2,"BlockStmt":16,"TryStmt":5,"ForStmt":1,"ExpressionStmt":13},"text":"/**\n     * Run a demo with more readers than writers\n     */\nprivate void demo() {\n    // Start two reader threads\n    for (int i = 0; i < NUM_READER_THREADS; i++) {\n        new Thread() {\n\n            public void run() {\n                while (!done) {\n                    lock.readLock().lock();\n                    try {\n                        theData.forEach( p -> System.out.printf(\"%s: votes %d%n\", p.getName(), p.getVotes()));\n                    } finally {\n                        // Unlock in \"finally\" to be sure it gets done.\n                        lock.readLock().unlock();\n                    }\n                    try {\n                        Thread.sleep(((long) (Math.random() * 1000)));\n                    } catch (InterruptedException ex) {\n                    }\n                }\n            }\n        }.start();\n    }\n    // Start one writer thread to simulate occasional voting\n    new Thread() {\n\n        public void run() {\n            while (!done) {\n                lock.writeLock().lock();\n                try {\n                    theData.voteFor(// Performance: should have one PRNG per thread.\n                    (((int) (Math.random() * theData.getCandidateCount()))));\n                } finally {\n                    lock.writeLock().unlock();\n                }\n                try {\n                    Thread.sleep(((long) (Math.random() * 1000)));\n                } catch (InterruptedException ex) {\n                }\n            }\n        }\n    }.start();\n    // In the main thread, wait a while then terminate the run.\n    try {\n        Thread.sleep(10 * 1000);\n    } catch (InterruptedException ex) {\n    } finally {\n        done = true;\n    }\n}\n                             // nothing to do\n\n                             // Vote for random candidate :-)\n\n                         // nothing to do\n\n             // nothing to do\n\n","name":"demo","className":"ReadersWriterDemo","variables":{"p":3,"theData":3,"ex":3,"NUM_READER_THREADS":1,"i":3,"lock":4,"run":2,"Math":3,"done":3,"Thread":3},"constants":{"0":1,"1000":3,"true":1,"\"%s: votes %d%n\"":1,"10":1},"javaDoc":"Run a demo with more readers than writers","comments":"Start two reader threads Unlock in \"finally\" to be sure it gets done nothing to do Start one writer thread to simulate occasional voting Vote for random candidate :-) Performance: should have one PRNG per thread nothing to do In the main thread wait a while then terminate the run nothing to do \n     * Run a demo with more readers than writers\n     ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":3},"text":"public void run() {\n    while (!done) {\n        System.out.println(\"StopBoolean running\");\n        try {\n            sleep(720);\n        } catch (InterruptedException ex) {\n        }\n    }\n    System.out.println(\"StopBoolean finished.\");\n}\n                 // nothing to do \n\n","name":"run","className":"StopBoolean","variables":{"ex":1,"done":1},"constants":{"\"StopBoolean running\"":1,"720":1,"\"StopBoolean finished.\"":1},"javaDoc":"","comments":"nothing to do ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void shutDown() {\n    done = true;\n}\n","name":"shutDown","className":"StopBoolean","variables":{"done":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sleep":1,"start":1,"shutDown":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{"StopBoolean":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) throws InterruptedException {\n    StopBoolean t1 = new StopBoolean();\n    t1.start();\n    Thread.sleep(1000 * 5);\n    t1.shutDown();\n}\n","name":"main","className":"StopBoolean","variables":{"t1":3,"Thread":1},"constants":{"5":1,"1000":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Component","Image","int"],"returnType":"Sprite","methodCalls":{"getHeight":1,"setSize":1,"getWidth":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":21,"StringLiteralExpr":2,"FieldAccessExpr":2,"ThisExpr":4,"AssignExpr":3,"MethodCallExpr":3},"statements":{"SwitchStmt":1,"BreakStmt":1,"SwitchEntryStmt":4,"ThrowStmt":1,"ExpressionStmt":4},"text":"/** Construct a Sprite with a Component parent, image and direction.\n     * Construct and start a Thread to drive this Sprite.\n     */\npublic Sprite(Component parent, Image img, int dir) {\n    this.parent = parent;\n    this.img = img;\n    switch(dir) {\n        case VERTICAL:\n        case HORIZONTAL:\n        case DIAGONAL:\n            direction = dir;\n            break;\n        default:\n            throw new IllegalArgumentException(\"Direction \" + dir + \" invalid\");\n    }\n    setSize(img.getWidth(this), img.getHeight(this));\n}\n","name":"Sprite","className":"Sprite","variables":{"parent":1,"img":3,"VERTICAL":1,"DIAGONAL":1,"HORIZONTAL":1,"dir":3,"direction":1},"constants":{"\"Direction \"":1,"\" invalid\"":1},"javaDoc":"Construct a Sprite with a Component parent image and direction Construct and start a Thread to drive this Sprite","comments":" Construct a Sprite with a Component parent, image and direction.\n     * Construct and start a Thread to drive this Sprite.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component","Image"],"returnType":"Sprite","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a sprite with the default direction */\npublic Sprite(Component parent, Image img) {\n    this(parent, img, DIAGONAL);\n}\n","name":"Sprite","className":"Sprite","variables":{"parent":1,"img":1,"DIAGONAL":1},"constants":{},"javaDoc":"Construct a sprite with the default direction","comments":" Construct a sprite with the default direction ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setName":1,"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"UnaryExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/** Start this Sprite's thread. */\npublic void start() {\n    t = new Thread(this);\n    t.setName(\"Sprite #\" + ++spriteNumber);\n    t.start();\n}\n","name":"start","className":"Sprite","variables":{"spriteNumber":1,"t":3},"constants":{"\"Sprite #\"":1},"javaDoc":"Start this Sprite's thread","comments":" Start this Sprite's thread. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getName":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":10,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Stop this Sprite's thread. */\npublic void stop() {\n    if (t == null)\n        return;\n    System.out.println(\"Stopping \" + t.getName());\n    done = true;\n}\n","name":"stop","className":"Sprite","variables":{"t":2,"done":1},"constants":{"\"Stopping \"":1,"null":1,"true":1},"javaDoc":"Stop this Sprite's thread","comments":" Stop this Sprite's thread. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Adjust the motion rate */\nprotected void setSleepTime(int n) {\n    sleepTime = n;\n}\n","name":"setSleepTime","className":"Sprite","variables":{"sleepTime":1,"n":1},"constants":{},"javaDoc":"Adjust the motion rate","comments":" Adjust the motion rate ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"random":4,"getSize":4,"setLocation":1,"repaint":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":4},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":4,"DoubleLiteralExpr":2,"BinaryExpr":8,"NameExpr":69,"CastExpr":2,"FieldAccessExpr":4,"EnclosedExpr":4,"ConditionalExpr":2,"UnaryExpr":3,"MethodCallExpr":11,"AssignExpr":12},"statements":{"SwitchStmt":1,"IfStmt":4,"WhileStmt":1,"BreakStmt":3,"BlockStmt":3,"TryStmt":1,"SwitchEntryStmt":3,"ReturnStmt":1,"ExpressionStmt":17},"text":"/**\n     * Run one Sprite around the screen.\n     * This version just moves them around either across, down, or\n     * at some 45-degree angle.\n     */\npublic void run() {\n    int width = parent.getSize().width;\n    int height = parent.getSize().height;\n    // Set initial location\n    x = (int) (Math.random() * width);\n    y = (int) (Math.random() * height);\n    // Flip coin for x & y directions\n    int xincr = Math.random() > 0.5 ? 1 : -1;\n    int yincr = Math.random() > 0.5 ? 1 : -1;\n    while (!done) {\n        width = parent.getSize().width;\n        height = parent.getSize().height;\n        if ((x += xincr) >= width)\n            x = 0;\n        if ((y += yincr) >= height)\n            y = 0;\n        if (x < 0)\n            x = width;\n        if (y < 0)\n            y = height;\n        switch(direction) {\n            case VERTICAL:\n                x = 0;\n                break;\n            case HORIZONTAL:\n                y = 0;\n                break;\n            case DIAGONAL:\n                break;\n        }\n        //System.out.println(\"from \" + getLocation() + \"->\" + x + \",\" + y);\n        setLocation(x, y);\n        repaint();\n        try {\n            Thread.sleep(sleepTime);\n        } catch (InterruptedException e) {\n            return;\n        }\n    }\n}\n","name":"run","className":"Sprite","variables":{"xincr":2,"parent":4,"e":1,"Math":4,"done":1,"Thread":1,"VERTICAL":1,"yincr":2,"width":5,"x":6,"y":6,"DIAGONAL":1,"HORIZONTAL":1,"height":5,"direction":1},"constants":{"0":6,"1":4,"0.5":2},"javaDoc":"Run one Sprite around the screen This version just moves them around either across down or at some 45-degree angle","comments":"Set initial location Flip coin for x & y directions System out println(\"from \" + getLocation() + \"->\" + x + \" \" + y); \n     * Run one Sprite around the screen.\n     * This version just moves them around either across, down, or\n     * at some 45-degree angle.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawImage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":4,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** paint -- just draw our image at its current location */\npublic void paint(Graphics g) {\n    g.drawImage(img, 0, 0, this);\n}\n","name":"paint","className":"Sprite","variables":{"g":1},"constants":{"0":2},"javaDoc":"paint -- just draw our image at its current location","comments":" paint -- just draw our image at its current location ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"invoke":1,"System.out.print":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"RecursiveActionDemo":1,"int":1,"ForkJoinPool":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":30,"StringLiteralExpr":1,"FieldAccessExpr":5,"CharLiteralExpr":2,"ArrayCreationExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    sorted = new int[raw.length];\n    RecursiveActionDemo fb = new RecursiveActionDemo(raw, 0, raw.length, sorted);\n    ForkJoinPool pool = new ForkJoinPool();\n    pool.invoke(fb);\n    System.out.print('[');\n    for (int i : sorted) {\n        System.out.print(i + \",\");\n    }\n    System.out.println(']');\n}\n","name":"main","className":"RecursiveActionDemo","variables":{"sorted":3,"pool":2,"raw":1,"i":2,"fb":1},"constants":{"0":1,"']'":1,"'['":1,"\",\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int","int[]"],"returnType":"RecursiveActionDemo","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public RecursiveActionDemo(int[] src, int start, int length, int[] dest) {\n    this.source = src;\n    this.start = start;\n    this.length = length;\n    this.dest = dest;\n}\n","name":"RecursiveActionDemo","className":"RecursiveActionDemo","variables":{"src":1,"start":1,"length":1,"dest":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"invokeAll":1,"System.out.println":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":7,"NameExpr":31,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":4},"text":"@Override\nprotected void compute() {\n    System.out.println(\"ForkJoinDemo.compute()\");\n    if (length <= THRESHOLD) {\n        // Compute Directly\n        for (int i = start; i < start + length; i++) {\n            dest[i] = source[i] * source[i];\n        }\n    } else {\n        // Divide and Conquer    \n        int split = length / 2;\n        invokeAll(new RecursiveActionDemo(source, start, split, dest), new RecursiveActionDemo(source, start + split, length - split, dest));\n    }\n}\n","name":"compute","className":"RecursiveActionDemo","variables":{"THRESHOLD":1,"split":4,"length":4,"start":4,"i":6,"source":4,"dest":3},"constants":{"2":1,"\"ForkJoinDemo.compute()\"":1},"javaDoc":"","comments":"Compute Directly Divide and Conquer ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"StringLiteralExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n     * Main program, test driver for ThreadsDemo4 class.\n     */\npublic static void main(String[] argv) {\n    new ThreadsDemo4(\"Hello from X\", 10);\n    new ThreadsDemo4(\"Hello from Y\", 15);\n}\n","name":"main","className":"ThreadsDemo4","variables":{},"constants":{"\"Hello from X\"":1,"15":1,"10":1,"\"Hello from Y\"":1},"javaDoc":"Main program test driver for ThreadsDemo4 class","comments":"\n     * Main program, test driver for ThreadsDemo4 class.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int"],"returnType":"ThreadsDemo4","methodCalls":{"sleep":1,"setName":1,"start":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"LambdaExpr":1,"BinaryExpr":3,"NameExpr":26,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":4,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"/**\n     * Construct a ThreadDemo object\n     * @param m Message to display\n     * @param n How many times to display it\n     */\npublic ThreadsDemo4(final String mesg, int n) {\n    count = n;\n    t = new Thread(() -> {\n        while (count-- > 0) {\n            System.out.println(mesg);\n            try {\n                // 100 msec\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n        System.out.println(mesg + \" thread all done.\");\n    });\n    t.setName(mesg + \" runner Thread\");\n    t.start();\n}\n","name":"ThreadsDemo4","className":"ThreadsDemo4","variables":{"t":3,"e":1,"count":2,"n":1,"Thread":1,"mesg":2},"constants":{"0":1,"100":1,"\" thread all done.\"":1,"\" runner Thread\"":1},"javaDoc":"Construct a ThreadDemo object m Message to display n How many times to display it","comments":"100 msec \n     * Construct a ThreadDemo object\n     * @param m Message to display\n     * @param n How many times to display it\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BlockingQueue<Object>"],"returnType":"Producer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"Producer(BlockingQueue<Object> theQueue) {\n    this.queue = theQueue;\n}\n","name":"Producer","className":"Producer","variables":{"theQueue":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"getRequestFromNetwork":1,"put":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"Object":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":4},"text":"public void run() {\n    try {\n        while (true) {\n            Object justProduced = getRequestFromNetwork();\n            queue.put(justProduced);\n            System.out.println(\"Produced 1 object; List size now \" + queue.size());\n            if (done) {\n                return;\n            }\n        }\n    } catch (InterruptedException ex) {\n        System.out.println(\"Producer INTERRUPTED\");\n    }\n}\n","name":"run","className":"Producer","variables":{"ex":1,"justProduced":1,"done":1,"queue":2},"constants":{"\"Produced 1 object; List size now \"":1,"\"Producer INTERRUPTED\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"sleep":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":2},"text":"Object getRequestFromNetwork() {\n    // Simulation of reading from client\n    try {\n        // simulate time passing during read\n        Thread.sleep(10);\n    } catch (InterruptedException ex) {\n        System.out.println(\"Producer Read INTERRUPTED\");\n    }\n    return new Object();\n}\n","name":"getRequestFromNetwork","className":"Producer","variables":{"ex":1,"Thread":1},"constants":{"\"Producer Read INTERRUPTED\"":1,"10":1},"javaDoc":"","comments":"Simulation of reading from client simulate time passing during read ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["BlockingQueue<Object>"],"returnType":"Consumer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"Consumer(BlockingQueue<Object> theQueue) {\n    this.queue = theQueue;\n}\n","name":"Consumer","className":"Consumer","variables":{"theQueue":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"take":1,"process":1,"size":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"Object":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":21,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":5},"text":"public void run() {\n    try {\n        while (true) {\n            Object obj = queue.take();\n            int len = queue.size();\n            System.out.println(\"List size now \" + len);\n            process(obj);\n            if (done) {\n                return;\n            }\n        }\n    } catch (InterruptedException ex) {\n        System.out.println(\"CONSUMER INTERRUPTED\");\n    }\n}\n","name":"run","className":"Consumer","variables":{"ex":1,"len":2,"obj":1,"done":1,"queue":2},"constants":{"\"List size now \"":1,"true":1,"\"CONSUMER INTERRUPTED\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"void process(Object obj) {\n    // Thread.sleep(123) // Simulate time passing\n    System.out.println(\"Consuming object \" + obj);\n}\n","name":"process","className":"Consumer","variables":{"obj":1},"constants":{"\"Consuming object \"":1},"javaDoc":"","comments":"Thread sleep(123) // Simulate time passing ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int","int"],"returnType":"ProdCons15","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"BlockingQueue<Object>":1,"LinkedBlockingQueue":1,"int":2},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":12,"UnaryExpr":2,"MethodCallExpr":2},"statements":{"ForStmt":2,"ExpressionStmt":3},"text":"ProdCons15(int nP, int nC) {\n    BlockingQueue<Object> myQueue = new LinkedBlockingQueue<>();\n    for (int i = 0; i < nP; i++) new Thread(new Producer(myQueue)).start();\n    for (int i = 0; i < nC; i++) new Thread(new Consumer(myQueue)).start();\n}\n","name":"ProdCons15","className":"ProdCons15","variables":{"nP":1,"nC":1,"myQueue":3,"i":6},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sleep":1},"annotations":[],"exceptions":["IOException","InterruptedException"],"concepts":[],"types":{"int":2,"ProdCons15":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) throws IOException, InterruptedException {\n    // Start producers and consumers\n    int numProducers = 4;\n    int numConsumers = 3;\n    ProdCons15 pc = new ProdCons15(numProducers, numConsumers);\n    // Let the simulation run for, say, 10 seconds\n    Thread.sleep(10 * 1000);\n    // End of simulation - shut down gracefully\n    pc.done = true;\n}\n","name":"main","className":"ProdCons15","variables":{"pc":1,"numProducers":2,"numConsumers":2,"Thread":1},"constants":{"3":1,"4":1,"1000":1,"true":1,"10":1},"javaDoc":"","comments":"Start producers and consumers Let the simulation run for say 10 seconds End of simulation - shut down gracefully ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"StringLiteralExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n     * Main program, test driver for ThreadsDemo3 class.\n     */\npublic static void main(String[] argv) {\n    new ThreadsDemo3(\"Hello from X\", 10);\n    new ThreadsDemo3(\"Hello from Y\", 15);\n}\n","name":"main","className":"ThreadsDemo3","variables":{},"constants":{"\"Hello from X\"":1,"15":1,"10":1,"\"Hello from Y\"":1},"javaDoc":"Main program test driver for ThreadsDemo3 class","comments":"\n     * Main program, test driver for ThreadsDemo3 class.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public void run() {\n    while (count-- > 0) {\n        System.out.println(mesg);\n        try {\n            // 100 msec\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            return;\n        }\n    }\n    System.out.println(mesg + \" thread all done.\");\n}\n","name":"run","className":"","variables":{"e":1,"count":1,"Thread":1,"mesg":1},"constants":{"0":1,"100":1,"\" thread all done.\"":1},"javaDoc":"","comments":"100 msec ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"ThreadsDemo3","methodCalls":{"sleep":1,"setName":1,"start":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["InnerMethod","ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":28,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":4,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"/**\n     * Construct a ThreadDemo object\n     * @param m Message to display\n     * @param n How many times to display it\n     */\npublic ThreadsDemo3(final String mesg, int n) {\n    count = n;\n    t = new Thread(new Runnable() {\n\n        public void run() {\n            while (count-- > 0) {\n                System.out.println(mesg);\n                try {\n                    // 100 msec\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    return;\n                }\n            }\n            System.out.println(mesg + \" thread all done.\");\n        }\n    });\n    t.setName(mesg + \" runner Thread\");\n    t.start();\n}\n","name":"ThreadsDemo3","className":"ThreadsDemo3","variables":{"t":3,"e":1,"count":2,"run":1,"n":1,"Thread":1,"mesg":2},"constants":{"0":1,"100":1,"\" thread all done.\"":1,"\" runner Thread\"":1},"javaDoc":"Construct a ThreadDemo object m Message to display n How many times to display it","comments":"100 msec \n     * Construct a ThreadDemo object\n     * @param m Message to display\n     * @param n How many times to display it\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpServletRequest","HttpServletResponse"],"returnType":"void","methodCalls":{"setAttribute":1,"println":6,"getAttribute":2,"getServletContext":1,"getRemoteAddr":2,"log":1,"getWriter":1,"getRemoteHost":1,"setContentType":1},"annotations":[],"exceptions":["ServletException","IOException"],"concepts":["Synchronization"],"types":{"boolean":1,"ServletContext":1,"String":1,"PrintWriter":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":2,"BinaryExpr":7,"NameExpr":55,"StringLiteralExpr":9,"CharLiteralExpr":1,"MethodCallExpr":16,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":4,"SynchronizedStmt":1,"ExpressionStmt":14},"text":"/** doGet is called from the contestants web page.\n     * Uses a synchronized code block to ensure that\n     * only one contestant can change the state of \"buzzed\".\n     */\npublic void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    ServletContext application = getServletContext();\n    boolean iWon = false;\n    String user = request.getRemoteHost() + '@' + request.getRemoteAddr();\n    // Do the synchronized stuff first, and all in one place.\n    synchronized (application) {\n        if (application.getAttribute(WINNER) == null) {\n            application.setAttribute(WINNER, user);\n            application.log(\"BuzzInServlet: WINNER \" + user);\n            iWon = true;\n        }\n    }\n    response.setContentType(\"text/html\");\n    PrintWriter out = response.getWriter();\n    out.println(\"<html><head><title>Thanks for playing</title></head>\");\n    out.println(\"<body bgcolor=\\\"white\\\">\");\n    if (iWon) {\n        out.println(\"<b>YOU GOT IT</b>\");\n    // TODO - output HTML to play a sound file :-)\n    } else {\n        out.println(\"Thanks for playing, \" + request.getRemoteAddr());\n        out.println(\", but \" + application.getAttribute(WINNER) + \" buzzed in first\");\n    }\n    out.println(\"</body></html>\");\n}\n","name":"doGet","className":"BuzzInServlet","variables":{"request":3,"application":6,"response":2,"iWon":3,"user":2,"out":7},"constants":{"\" buzzed in first\"":1,"\"</body></html>\"":1,"false":1,"\"BuzzInServlet: WINNER \"":1,"\"<body bgcolor=\\\"white\\\">\"":1,"'@'":1,"\"<b>YOU GOT IT</b>\"":1,"null":1,"\"<html><head><title>Thanks for playing</title></head>\"":1,"true":1,"\", but \"":1,"\"text/html\"":1,"\"Thanks for playing, \"":1},"javaDoc":"doGet is called from the contestants web page Uses a synchronized code block to ensure that only one contestant can change the state of \"buzzed\"","comments":"Do the synchronized stuff first and all in one place TODO - output HTML to play a sound file :-)  doGet is called from the contestants web page.\n     * Uses a synchronized code block to ensure that\n     * only one contestant can change the state of \"buzzed\".\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpServletRequest","HttpServletResponse"],"returnType":"void","methodCalls":{"getName":1,"getUserPrincipal":2,"getServletContext":1,"forward":1,"getRequestDispatcher":1,"isUserInRole":1,"println":7,"setAttribute":5,"getAttribute":1,"getWriter":1,"equals":2,"setContentType":1,"getSession":1,"getParameter":1},"annotations":[],"exceptions":["ServletException","IOException"],"concepts":["Synchronization"],"types":{"HttpSession":1,"ServletContext":1,"String":2,"RequestDispatcher":1,"PrintWriter":1},"expressions":{"NullLiteralExpr":3,"VariableDeclarationExpr":6,"BinaryExpr":7,"NameExpr":86,"StringLiteralExpr":23,"CastExpr":1,"MethodCallExpr":26,"AssignExpr":1},"statements":{"IfStmt":4,"BlockStmt":9,"SynchronizedStmt":2,"ExpressionStmt":21},"text":"/** The Post method is used from an Administrator page (which should\n     * only be installed in the instructor/host's localweb directory). \n     * Post is used for administrative functions:\n     * 1) to display the winner;\n     * 2) to reset the buzzer for the next question.\n     */\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    ServletContext application = getServletContext();\n    response.setContentType(\"text/html\");\n    HttpSession session = request.getSession();\n    PrintWriter out = response.getWriter();\n    if (request.isUserInRole(\"host\")) {\n        out.println(\"<html><head><title>Welcome back, \" + request.getUserPrincipal().getName() + \"</title><head>\");\n        out.println(\"<body bgcolor=\\\"white\\\">\");\n        String command = request.getParameter(\"command\");\n        if (command.equals(\"reset\")) {\n            // Synchronize what you need, no more, no less.\n            synchronized (application) {\n                application.setAttribute(WINNER, null);\n            }\n            session.setAttribute(\"buzzin.message\", \"RESET\");\n        } else if (command.equals(\"show\")) {\n            String winner = null;\n            synchronized (application) {\n                winner = (String) application.getAttribute(WINNER);\n            }\n            if (winner == null) {\n                session.setAttribute(\"buzzin.message\", \"<b>No winner yet!</b>\");\n            } else {\n                session.setAttribute(\"buzzin.message\", \"<b>Winner is: </b>\" + winner);\n            }\n        } else {\n            session.setAttribute(\"buzzin.message\", \"ERROR: Command \" + command + \" invalid.\");\n        }\n        RequestDispatcher rd = application.getRequestDispatcher(\"/hosts/index.jsp\");\n        rd.forward(request, response);\n    } else {\n        out.println(\"<html><head><title>Nice try, but... </title><head>\");\n        out.println(\"<body bgcolor=\\\"white\\\">\");\n        out.println(\"I'm sorry, Dave, but you know I can't allow you to do that.\");\n        out.println(\"Even if you are \" + request.getUserPrincipal());\n    }\n    out.println(\"</body></html>\");\n}\n","name":"doPost","className":"BuzzInServlet","variables":{"request":5,"rd":2,"winner":4,"application":6,"response":2,"session":5,"command":4,"out":8},"constants":{"\"RESET\"":1,"\"</body></html>\"":1,"\" invalid.\"":1,"\"ERROR: Command \"":1,"\"show\"":1,"\"<b>Winner is: </b>\"":1,"\"host\"":1,"\"<html><head><title>Welcome back, \"":1,"\"<body bgcolor=\\\"white\\\">\"":2,"\"I'm sorry, Dave, but you know I can't allow you to do that.\"":1,"\"<b>No winner yet!</b>\"":1,"\"<html><head><title>Nice try, but... </title><head>\"":1,"\"reset\"":1,"null":3,"\"</title><head>\"":1,"\"command\"":1,"\"/hosts/index.jsp\"":1,"\"text/html\"":1,"\"buzzin.message\"":4,"\"Even if you are \"":1},"javaDoc":"The Post method is used from an Administrator page (which should only be installed in the instructor/host's localweb directory) Post is used for administrative functions: 1) to display the winner; 2) to reset the buzzer for the next question","comments":"Synchronize what you need no more no less  The Post method is used from an Administrator page (which should\n     * only be installed in the instructor/host's localweb directory). \n     * Post is used for administrative functions:\n     * 1) to display the winner;\n     * 2) to reset the buzzer for the next question.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"isErrorID":1,"getCodeBase":1,"addActionListener":1,"addImage":1,"setLayout":2,"getImage":1,"getParameter":1,"waitForID":1},"annotations":[],"exceptions":["InterruptedException","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"MediaTracker":1,"Button":1,"String":1},"expressions":{"ObjectCreationExpr":7,"NullLiteralExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"StringLiteralExpr":5,"NameExpr":43,"FieldAccessExpr":2,"ThisExpr":2,"MethodCallExpr":11,"AssignExpr":4},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":3,"ThrowStmt":2,"ExpressionStmt":13},"text":"public void init() {\n    Button b = new Button(\"Start\");\n    b.addActionListener(this);\n    setLayout(new BorderLayout());\n    add(b, BorderLayout.NORTH);\n    add(p = new Panel(), BorderLayout.CENTER);\n    p.setLayout(null);\n    String imgName = getParameter(\"imagefile\");\n    if (imgName == null)\n        imgName = \"duke.gif\";\n    img = getImage(getCodeBase(), imgName);\n    MediaTracker mt = new MediaTracker(this);\n    mt.addImage(img, 0);\n    try {\n        mt.waitForID(0);\n    } catch (InterruptedException e) {\n        throw new IllegalArgumentException(\"InterruptedException while loading image \" + imgName);\n    }\n    if (mt.isErrorID(0)) {\n        throw new IllegalArgumentException(\"Couldn't load image \" + imgName);\n    }\n    // multithreaded, use Vector\n    v = new Vector<Sprite>();\n}\n","name":"init","className":"Bounce","variables":{"p":2,"imgName":5,"b":2,"img":1,"e":1,"v":1,"mt":4},"constants":{"0":3,"\"InterruptedException while loading image \"":1,"\"imagefile\"":1,"\"Start\"":1,"null":2,"\"Couldn't load image \"":1,"\"duke.gif\"":1},"javaDoc":"","comments":"multithreaded use Vector ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"add":2,"start":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Sprite":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent e) {\n    System.out.println(\"Creat-ing another one!\");\n    Sprite s = new Sprite(this, img);\n    s.start();\n    p.add(s);\n    v.add(s);\n}\n","name":"actionPerformed","className":"Bounce","variables":{"p":1,"img":1,"s":2,"v":1},"constants":{"\"Creat-ing another one!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"stop":1,"get":1,"clear":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":14,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"public void stop() {\n    for (int i = 0; i < v.size(); i++) {\n        v.get(i).stop();\n    }\n    v.clear();\n}\n","name":"stop","className":"Bounce","variables":{"v":3,"i":3},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"currentTimeMillis":2,"loadData":1,"invoke":1,"getRawResult":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"RecursiveTaskDemo":1,"int[]":1,"long":4,"ForkJoinPool":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":5,"NameExpr":36,"StringLiteralExpr":3,"FieldAccessExpr":3,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":7},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    int[] source = new int[N];\n    loadData(source);\n    RecursiveTaskDemo fb = new RecursiveTaskDemo(source, 0, source.length);\n    ForkJoinPool pool = new ForkJoinPool();\n    long before = System.currentTimeMillis();\n    pool.invoke(fb);\n    long after = System.currentTimeMillis();\n    long total = fb.getRawResult();\n    long avg = total / N;\n    System.out.println(\"Average: \" + avg);\n    System.out.println(\"Time :\" + (after - before) + \" mSec\");\n}\n","name":"main","className":"RecursiveTaskDemo","variables":{"total":2,"avg":2,"before":2,"pool":2,"source":2,"after":2,"fb":2,"N":2,"System":2},"constants":{"0":1,"\" mSec\"":1,"\"Time :\"":1,"\"Average: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"nextInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Random":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":10,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"static void loadData(int[] data) {\n    Random r = new Random();\n    for (int i = 0; i < data.length; i++) {\n        data[i] = r.nextInt();\n    }\n}\n","name":"loadData","className":"RecursiveTaskDemo","variables":{"r":2,"data":1,"i":4},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["int[]","int","int"],"returnType":"RecursiveTaskDemo","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":3,"ThisExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public RecursiveTaskDemo(int[] data, int start, int length) {\n    this.data = data;\n    this.start = start;\n    this.length = length;\n}\n","name":"RecursiveTaskDemo","className":"RecursiveTaskDemo","variables":{"data":1,"start":1,"length":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Long","methodCalls":{"compute":1,"fork":1,"join":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"RecursiveTaskDemo":2,"long":1,"int":2},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":7,"NameExpr":29,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":6},"text":"@Override\nprotected Long compute() {\n    if (length <= THRESHOLD) {\n        // Compute Directly\n        long total = 0;\n        for (int i = start; i < start + length; i++) {\n            total += data[i];\n        }\n        return total;\n    } else {\n        // Divide and Conquer    \n        int split = length / 2;\n        RecursiveTaskDemo t1 = new RecursiveTaskDemo(data, start, split);\n        t1.fork();\n        RecursiveTaskDemo t2 = new RecursiveTaskDemo(data, start + split, length - split);\n        return t2.compute() + t1.join();\n    }\n}\n","name":"compute","className":"RecursiveTaskDemo","variables":{"THRESHOLD":1,"total":3,"split":4,"data":3,"length":4,"start":4,"i":4,"t1":3,"t2":2},"constants":{"0":1,"2":1},"javaDoc":"","comments":"Compute Directly Divide and Conquer ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"ofEpochSecond":1,"getTimeZone":1,"getTime":1,"format":1,"ofPattern":1,"getMinutes":1,"getHours":1,"toFormat":1,"getSeconds":1,"getYear":1,"of":2,"getDate":1,"getMonth":1,"toZoneId":1,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"LocalDateTime":2,"TimeZone":1,"Format":1,"ZoneId":1,"DateTimeFormatter":1,"Date":1,"long":1,"ZoneOffset":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":9,"BinaryExpr":7,"NameExpr":78,"StringLiteralExpr":5,"CastExpr":1,"FieldAccessExpr":5,"EnclosedExpr":2,"MethodCallExpr":20},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    Date legacyDate = new Date();\n    System.out.println(legacyDate);\n    ZoneOffset zoneOffset1 = ZoneOffset.of(\"-0400\");\n    // using the long integer-based methods\n    long longTime = legacyDate.getTime();\n    LocalDateTime convertedDate1 = LocalDateTime.ofEpochSecond(longTime / 1000, (int) ((longTime % 1000) * 1000), zoneOffset1);\n    System.out.println(convertedDate1);\n    // Using individual values\n    LocalDateTime convertedDate2 = LocalDateTime.of(legacyDate.getYear() + 1900, legacyDate.getMonth() + 1, legacyDate.getDate(), legacyDate.getHours(), legacyDate.getMinutes(), legacyDate.getSeconds());\n    System.out.println(convertedDate2);\n    // Timezone\n    TimeZone timeZone = TimeZone.getTimeZone(\"EST\");\n    ZoneId zoneId = timeZone.toZoneId();\n    System.out.println(\"EST - > \" + zoneId);\n    // Convert new DateTimeFormatter to old java.util.Format, but it\n    // will only format things that implement TemporalAccessor, e.g., new API\n    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy MM dd\");\n    Format legacyFormat = dateTimeFormatter.toFormat();\n    System.out.println(\"Formatted: \" + legacyFormat.format(convertedDate2));\n}\n","name":"main","className":"LegacyDatesDIY","variables":{"LocalDateTime":2,"dateTimeFormatter":2,"convertedDate1":1,"convertedDate2":1,"timeZone":2,"ZoneOffset":1,"TimeZone":1,"legacyFormat":2,"zoneOffset1":1,"longTime":3,"zoneId":2,"legacyDate":8,"DateTimeFormatter":1},"constants":{"1":1,"\"EST\"":1,"\"EST - > \"":1,"\"yyyy MM dd\"":1,"1000":3,"\"-0400\"":1,"\"Formatted: \"":1,"1900":1},"javaDoc":"","comments":"Convert new DateTimeFormatter to old java util Format but it using the long integer-based methods Using individual values Timezone will only format things that implement TemporalAccessor e g new API ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getDays":1,"System.out.printf":2,"getYears":1,"of":1,"now":1,"between":1,"getMonths":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Period":1,"LocalDate":2},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"NameExpr":32,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":8},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    /** The date at the end of the last century */\n    LocalDate endofCentury = LocalDate.of(2000, 12, 31);\n    LocalDate now = LocalDate.now();\n    Period diff = Period.between(endofCentury, now);\n    System.out.printf(\"The 21st century (up to %s) is %s old%n\", now, diff);\n    System.out.printf(\"The 21st century is %d years, %d months and %d days old\", diff.getYears(), diff.getMonths(), diff.getDays());\n}\n","name":"main","className":"DateDiff","variables":{"now":1,"Period":1,"diff":4,"endofCentury":1,"LocalDate":2},"constants":{"12":1,"\"The 21st century (up to %s) is %s old%n\"":1,"\"The 21st century is %d years, %d months and %d days old\"":1,"2000":1,"31":1},"javaDoc":"","comments":"The date at the end of the last century ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":1,"now":1,"ofDays":1,"plus":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Period":1,"LocalDate":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] av) {\n    /** Today's date */\n    LocalDate now = LocalDate.now();\n    Period p = Period.ofDays(700);\n    LocalDate then = now.plus(p);\n    System.out.printf(\"Seven hundred days from %s is %s%n\", now, then);\n}\n","name":"main","className":"DateAdd","variables":{"p":1,"now":2,"Period":1,"then":1,"LocalDate":1},"constants":{"700":1,"\"Seven hundred days from %s is %s%n\"":1},"javaDoc":"","comments":"Today's date ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Date":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    // BEGIN ofTime\n    Date endOfTime = new Date(Long.MAX_VALUE);\n    System.out.println(\"Java8 time overflows on \" + endOfTime);\n// END ofTime\n}\n","name":"main","className":"EndOfTime64Msec","variables":{"endOfTime":2},"constants":{"\"Java8 time overflows on \"":1},"javaDoc":"","comments":"END ofTime BEGIN ofTime ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"ofInstant":2,"systemDefault":2,"getInstance":1,"toInstant":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"LocalDateTime":2,"Calendar":1,"Date":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"NameExpr":45,"FieldAccessExpr":4,"MethodCallExpr":11},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    // There and back again, via Date\n    Date legacyDate = new Date();\n    System.out.println(legacyDate);\n    LocalDateTime newDate = LocalDateTime.ofInstant(legacyDate.toInstant(), ZoneId.systemDefault());\n    System.out.println(newDate);\n    // And via Calendar\n    Calendar c = Calendar.getInstance();\n    System.out.println(c);\n    LocalDateTime newCal = LocalDateTime.ofInstant(c.toInstant(), ZoneId.systemDefault());\n    System.out.println(newCal);\n}\n","name":"main","className":"LegacyDates","variables":{"LocalDateTime":2,"c":2,"ZoneId":2,"newCal":1,"Calendar":1,"newDate":1,"legacyDate":2},"constants":{},"javaDoc":"","comments":"There and back again via Date And via Calendar ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"now":2,"format":2,"parse":1,"ofPattern":2,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"DateTimeFormatter":2},"expressions":{"VariableDeclarationExpr":2,"NameExpr":37,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":10},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    // Format a date ISO8601-like but with slashes instead of dashes\n    DateTimeFormatter df = DateTimeFormatter.ofPattern(\"yyyy/LL/dd\");\n    System.out.println(df.format(LocalDate.now()));\n    // Parse a String to a date using the same formatter\n    System.out.println(LocalDate.parse(\"2014/04/01\", df));\n    // Format a Date and Time without timezone information\n    DateTimeFormatter nTZ = DateTimeFormatter.ofPattern(\"d MMMM, yyyy h:mm a\");\n    System.out.println(ZonedDateTime.now().format(nTZ));\n}\n","name":"main","className":"DateFormatter","variables":{"df":2,"nTZ":1,"ZonedDateTime":1,"DateTimeFormatter":2,"LocalDate":2},"constants":{"\"d MMMM, yyyy h:mm a\"":1,"\"yyyy/LL/dd\"":1,"\"2014/04/01\"":1},"javaDoc":"","comments":"Format a date ISO8601-like but with slashes instead of dashes Parse a String to a date using the same formatter Format a Date and Time without timezone information ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"ofEpochSecond":1,"systemDefault":1,"ofInstant":1,"System.out.printf":1,"now":2,"of":1,"getEpochSecond":1,"atZone":1,"toInstant":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"LocalDateTime":1,"ZoneId":1,"ZonedDateTime":2,"Instant":1,"long":1},"expressions":{"VariableDeclarationExpr":6,"BinaryExpr":2,"NameExpr":46,"StringLiteralExpr":4,"LongLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":12},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    // BEGIN main\n    // Convert a number of Seconds since the Epoch, to a local date/time\n    Instant epochSec = Instant.ofEpochSecond(1000000000L);\n    ZoneId zId = ZoneId.systemDefault();\n    ZonedDateTime then = ZonedDateTime.ofInstant(epochSec, zId);\n    System.out.println(\"The epoch was a billion seconds old on \" + then);\n    // Convert a date/time to Epoch seconds\n    long epochSecond = ZonedDateTime.now().toInstant().getEpochSecond();\n    System.out.println(\"Current epoch seconds = \" + epochSecond);\n    LocalDateTime now = LocalDateTime.now();\n    ZonedDateTime there = now.atZone(ZoneId.of(\"Canada/Pacific\"));\n    System.out.printf(\"When it's %s here, it's %s in Vancouver%n\", now, there);\n// END main\n}\n","name":"main","className":"DateConversions","variables":{"LocalDateTime":1,"zId":1,"ZoneId":2,"ZonedDateTime":2,"epochSec":1,"Instant":1,"now":2,"there":1,"epochSecond":2,"then":2},"constants":{"\"Canada/Pacific\"":1,"\"The epoch was a billion seconds old on \"":1,"\"When it's %s here, it's %s in Vancouver%n\"":1,"1000000000L":1,"\"Current epoch seconds = \"":1},"javaDoc":"","comments":"BEGIN main END main Convert a number of Seconds since the Epoch to a local date/time Convert a date/time to Epoch seconds ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":1,"parse":3,"ofPattern":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"LocalDateTime":1,"String":3,"LocalDate":2,"DateTimeFormatter":1},"expressions":{"VariableDeclarationExpr":7,"BinaryExpr":6,"StringLiteralExpr":8,"NameExpr":45,"FieldAccessExpr":4,"MethodCallExpr":9},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    String armisticeDate = \"1914-11-11\";\n    LocalDate aLD = LocalDate.parse(armisticeDate);\n    System.out.println(\"Date: \" + aLD);\n    String armisticeDateTime = \"1914-11-11T11:11\";\n    LocalDateTime aLDT = LocalDateTime.parse(armisticeDateTime);\n    System.out.println(\"Date/Time: \" + aLDT);\n    // END part1\n    // BEGIN part2\n    DateTimeFormatter df = DateTimeFormatter.ofPattern(\"dd MMM uuuu\");\n    String anotherDate = \"27 Jan 2011\";\n    LocalDate random = LocalDate.parse(anotherDate, df);\n    System.out.println(anotherDate + \" parses as \" + random);\n    // END part2\n    System.out.println(aLD + \" formats as \" + df.format(aLD));\n}\n","name":"main","className":"DateParse","variables":{"LocalDateTime":1,"random":2,"armisticeDateTime":1,"df":2,"anotherDate":2,"aLDT":2,"aLD":3,"LocalDate":2,"DateTimeFormatter":1,"armisticeDate":1},"constants":{"\"dd MMM uuuu\"":1,"\"27 Jan 2011\"":1,"\"Date/Time: \"":1,"\"1914-11-11T11:11\"":1,"\" parses as \"":1,"\" formats as \"":1,"\"1914-11-11\"":1,"\"Date: \"":1},"javaDoc":"","comments":"END part1 END part2 BEGIN part2 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"now":3,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"LocalDateTime":1,"LocalTime":1,"LocalDate":1},"expressions":{"VariableDeclarationExpr":3,"NameExpr":27,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    LocalDate dNow = LocalDate.now();\n    System.out.println(dNow);\n    LocalTime tNow = LocalTime.now();\n    System.out.println(tNow);\n    LocalDateTime now = LocalDateTime.now();\n    System.out.println(now);\n}\n","name":"main","className":"CurrentDateTime","variables":{"LocalDateTime":1,"LocalTime":1,"tNow":1,"now":1,"dNow":1,"LocalDate":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Predicate<Camera>"],"returnType":"List<Camera>","methodCalls":{"add":1,"test":1,"forEach":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"List<Camera>":1,"ArrayList":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"LambdaExpr":1,"NameExpr":12,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"// BEGIN search\npublic List<Camera> search(Predicate<Camera> tester) {\n    List<Camera> results = new ArrayList<>();\n    privateListOfCameras.forEach( c -> {\n        if (tester.test(c))\n            results.add(c);\n    });\n    return results;\n}\n","name":"search","className":"CameraSearchPredicate","variables":{"privateListOfCameras":1,"c":1,"tester":1,"results":3},"constants":{},"javaDoc":"","comments":" BEGIN search","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"search":1,"isIlc":1,"getPrice":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"List<Camera>":1,"CameraSearchPredicate":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"LambdaExpr":1,"BinaryExpr":2,"NameExpr":15,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"// END search\npublic static void main(String[] args) {\n    CameraSearchPredicate searchApp = new CameraSearchPredicate();\n    List<Camera> results = searchApp.search( c -> c.isIlc() && c.getPrice() < 500);\n    System.out.println(results);\n}\n","name":"main","className":"CameraSearchPredicate","variables":{"c":3,"searchApp":2,"results":1},"constants":{"500":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"toArray":1,"parallelStream":1,"isIlc":1,"getPrice":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"LambdaExpr":1,"BinaryExpr":2,"NameExpr":19,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"// BEGIN search\npublic static void main(String[] args) {\n    for (Object camera : // <1>\n    privateListOfCameras.parallelStream().filter(// <2>\n     c -> c.isIlc() && c.getPrice() < 500).toArray()) {\n        // <3>\n        // <4>\n        System.out.println(camera);\n    }\n}\n","name":"main","className":"CameraSearchParallelStream","variables":{"privateListOfCameras":1,"c":3,"camera":1},"constants":{"500":1},"javaDoc":"","comments":"<1> <2> <3> <4>  BEGIN search","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// Assume this is an existing method we don't want to rename\npublic void walk() {\n    System.out.println(\"ReferencesDemo.walk(): Stand-in run method called\");\n}\n","name":"walk","className":"ReferencesDemo","variables":{},"constants":{"\"ReferencesDemo.walk(): Stand-in run method called\"":1},"javaDoc":"","comments":" Assume this is an existing method we don't want to rename","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Runnable":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodReferenceExpr":1,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"// This is our main processing method; it runs \"walk\" in a Thread\npublic void doIt() {\n    Runnable r = this::walk;\n    new Thread(r).start();\n}\n","name":"doIt","className":"ReferencesDemo","variables":{"r":2},"constants":{},"javaDoc":"","comments":" This is our main processing method; it runs \"walk\" in a Thread","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// The usual simple main method to start things off\npublic static void main(String[] args) {\n    new ReferencesDemo().doIt();\n}\n","name":"main","className":"ReferencesDemo","variables":{},"constants":{},"javaDoc":"","comments":" The usual simple main method to start things off","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int"],"returnType":"Hero","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Hero(String name, int age) {\n    this.name = name;\n    this.age = age;\n}\n","name":"Hero","className":"Hero","variables":{"name":1,"age":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"filter":1,"sorted":1,"stream":2,"mapToInt":1,"sum":1,"h1.name.compareTo":1,"toList":1,"collect":1,"map":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"List<Object>":1,"long":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"LambdaExpr":4,"BinaryExpr":4,"NameExpr":52,"StringLiteralExpr":3,"FieldAccessExpr":7,"MethodCallExpr":12},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    long adultYearsExperience = Arrays.stream(heroes).filter( b -> b.age >= 18).mapToInt( b -> b.age).sum();\n    System.out.println(\"We're in good hands! The adult superheros have \" + adultYearsExperience + \" years of experience\");\n    List<Object> sorted = Arrays.stream(heroes).sorted(( h1,  h2) -> h1.name.compareTo(h2.name)).map( h -> h.name).collect(Collectors.toList());\n    System.out.println(\"Heroes by name: \" + sorted);\n}\n","name":"main","className":"SimpleStreamDemo","variables":{"Collectors":1,"b":2,"sorted":2,"h":1,"h1":1,"h2":1,"adultYearsExperience":2,"Arrays":2},"constants":{"\"We're in good hands! The adult superheros have \"":1,"18":1,"\" years of experience\"":1,"\"Heroes by name: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","Function<Integer, Integer>"],"returnType":"int","methodCalls":{"apply":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Function to be called with an int and a Function;\n     * just apply the function to the int and return the result\n     */\nstatic int doTheMath(int n, Function<Integer, Integer> func) {\n    return func.apply(n);\n}\n","name":"doTheMath","className":"ProcessIntsFunctional","variables":{"func":1},"constants":{},"javaDoc":"Function to be called with an int and a Function; just apply the function to the int and return the result","comments":" Function to be called with an int and a Function;\n     * just apply the function to the int and return the result\n     ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"doTheMath":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"LambdaExpr":1,"BinaryExpr":2,"NameExpr":13,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int total = 0;\n    for (int i : integers) {\n        // Call doTheMath with 'i' and a Lambda for n^2 +1\n        total += doTheMath(i,  k -> k * k + 1);\n    }\n    System.out.println(total);\n}\n","name":"main","className":"ProcessIntsFunctional","variables":{"total":2,"i":1,"k":3,"integers":1},"constants":{"0":1,"1":1},"javaDoc":"","comments":"Call doTheMath with 'i' and a Lambda for n^2 +1 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"int compute(int x);\n","name":"compute","className":"MyFunctionalInterface","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"LambdaExpr":1,"BinaryExpr":3,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ForeachStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int total = 0;\n    for (int i : integers) total += process(i,  x -> x * x + 1);\n    System.out.println(\"The total is \" + total);\n}\n","name":"main","className":"ProcessIntsUsingFunctional","variables":{"total":3,"x":3,"i":1,"integers":1},"constants":{"0":1,"\"The total is \"":1,"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","MyFunctionalInterface"],"returnType":"int","methodCalls":{"compute":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"private static int process(int i, MyFunctionalInterface o) {\n    return o.compute(i);\n}\n","name":"process","className":"ProcessIntsUsingFunctional","variables":{"o":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String","String"],"returnType":"int","methodCalls":{"compareToIgnoreCase":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic int compare(String str1, String str2) {\n    return str1.compareToIgnoreCase(str2);\n}\n","name":"compare","className":"","variables":{"str1":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"clone":4,"sort":4,"dump":4,"compareToIgnoreCase":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"String[]":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"LambdaExpr":1,"NameExpr":58,"FieldAccessExpr":1,"MarkerAnnotationExpr":1,"MethodReferenceExpr":1,"TypeExpr":1,"AssignExpr":4,"MethodCallExpr":14},"statements":{"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    String[] names;\n    // Sort using \n    // \"an Instance Method of an Arbitrary Object of a Particular Type\"\n    names = unsortedNames.clone();\n    // <1>\n    Arrays.sort(names, String::compareToIgnoreCase);\n    dump(names);\n    // Equivalent Lambda:\n    names = unsortedNames.clone();\n    // <2>\n    Arrays.sort(names, ( str1,  str2) -> str1.compareToIgnoreCase(str2));\n    dump(names);\n    // Equivalent old way:\n    names = unsortedNames.clone();\n    Arrays.sort(names, new // <3>\n    Comparator<String>() {\n\n        @Override\n        public int compare(String str1, String str2) {\n            return str1.compareToIgnoreCase(str2);\n        }\n    });\n    dump(names);\n    // Simpest way, using existing comparator\n    names = unsortedNames.clone();\n    // <4>\n    Arrays.sort(names, String.CASE_INSENSITIVE_ORDER);\n    dump(names);\n}\n","name":"main","className":"ReferencesDemo4","variables":{"unsortedNames":4,"compare":1,"names":5,"str1":4,"str2":2,"Arrays":4,"Override":1},"constants":{},"javaDoc":"","comments":"Sort using \"an Instance Method of an Arbitrary Object of a Particular Type\" <1> Equivalent Lambda: <2> Equivalent old way: <3> Simpest way using existing comparator <4> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":17,"FieldAccessExpr":3,"CharLiteralExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":3},"text":"/** Simple dumper just to show the order of the names in the array */\nprivate static void dump(String[] names) {\n    for (String s : names) {\n        System.out.print(s);\n        System.out.print(' ');\n    }\n    System.out.println();\n}\n","name":"dump","className":"ReferencesDemo4","variables":{"s":1,"names":1},"constants":{"' '":1},"javaDoc":"Simple dumper just to show the order of the names in the array","comments":" Simple dumper just to show the order of the names in the array ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"void cloz() {\n    System.out.println(\"Stand-in close() method called\");\n}\n","name":"cloz","className":"ReferencesDemo2","variables":{},"constants":{"\"Stand-in close() method called\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"ReferencesDemo2":1,"AutoCloseable":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodReferenceExpr":1,"TypeExpr":1,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] args) throws Exception {\n    ReferencesDemo2 rd2 = new ReferencesDemo2();\n    // short for close, but just to she the method name isn't what matters).\n    try (AutoCloseable autoCloseable = rd2::cloz) {\n        System.out.println(\"Some action happening here.\");\n    }\n}\n         // Use a method reference to assign the AutoCloseable interface\n\n         // variable \"ac\" to the matching method signature \"c\" (obviously\n\n","name":"main","className":"ReferencesDemo2","variables":{"rd2":1,"autoCloseable":1},"constants":{"\"Some action happening here.\"":1},"javaDoc":"","comments":"Use a method reference to assign the AutoCloseable interface variable \"ac\" to the matching method signature \"c\" (obviously short for close but just to she the method name isn't what matters) ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","String","char","double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"void process(int i, String j, char c, double d);\n","name":"process","className":"FunInterface","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int","String","char","double"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void work(int i, String j, char c, double d) {\n    System.out.println(\"Moo\");\n}\n","name":"work","className":"ReferencesDemo3","variables":{},"constants":{"\"Moo\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"FunInterface":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodReferenceExpr":1,"TypeExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    FunInterface sample = ReferencesDemo3::work;\n    System.out.println(\"My process method is \" + sample);\n}\n","name":"main","className":"ReferencesDemo3","variables":{"sample":2},"constants":{"\"My process method is \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"get":1,"System.err.println":1,"keySet":1,"parseArguments":1,"charAt":1,"System.out.print":6,"getFilenameList":1,"System.out.println":1},"annotations":[],"exceptions":["IllegalStateException"],"concepts":[],"types":{"GetOpt":1,"Map<String, String>":1,"boolean":2,"char":1,"GetOptDesc[]":1,"String":3},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":9,"BinaryExpr":5,"StringLiteralExpr":9,"NameExpr":67,"CharLiteralExpr":7,"AssignExpr":3,"NullLiteralExpr":1,"ArrayInitializerExpr":1,"BooleanLiteralExpr":6,"CastExpr":1,"FieldAccessExpr":8,"MethodCallExpr":13},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":3,"BlockStmt":3,"SwitchEntryStmt":4,"ForeachStmt":2,"ThrowStmt":1,"ExpressionStmt":18},"text":"public static void main(String[] argv) {\n    boolean numeric_option = false;\n    boolean errs = false;\n    String outputFileName = null;\n    GetOptDesc[] options = { new GetOptDesc('n', \"numeric\", false), new GetOptDesc('o', \"output-file\", true) };\n    GetOpt parser = new GetOpt(options);\n    Map<String, String> optionsFound = parser.parseArguments(argv);\n    for (String key : optionsFound.keySet()) {\n        char c = key.charAt(0);\n        switch(c) {\n            case 'n':\n                numeric_option = true;\n                break;\n            case 'o':\n                outputFileName = (String) optionsFound.get(key);\n                break;\n            case '?':\n                errs = true;\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected option character: \" + c);\n        }\n    }\n    if (errs) {\n        System.err.println(\"Usage: GetOptDemo [-n][-o file][file...]\");\n    }\n    System.out.print(\"Options: \");\n    System.out.print(\"Numeric: \" + numeric_option + ' ');\n    System.out.print(\"Output: \" + outputFileName + \"; \");\n    System.out.print(\"Input files: \");\n    for (String fileName : parser.getFilenameList()) {\n        System.out.print(fileName);\n        System.out.print(' ');\n    }\n    System.out.println();\n}\n","name":"main","className":"GetOptDemoNew","variables":{"errs":3,"fileName":1,"c":3,"outputFileName":3,"parser":3,"numeric_option":3,"options":2,"optionsFound":3,"key":2},"constants":{"'n'":2,"\"numeric\"":1,"\"Input files: \"":1,"false":3,"\"Numeric: \"":1,"\"; \"":1,"' '":2,"'?'":1,"0":1,"null":1,"true":3,"\"Unexpected option character: \"":1,"\"Output: \"":1,"\"output-file\"":1,"\"Usage: GetOptDemo [-n][-o file][file...]\"":1,"\"Options: \"":1,"'o'":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1,"getenv":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] argv) {\n    System.out.println(\"System.getenv(\\\"PATH\\\") = \" + System.getenv(\"PATH\"));\n}\n","name":"main","className":"GetEnv","variables":{"System":1},"constants":{"\"PATH\"":1,"\"System.getenv(\\\"PATH\\\") = \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getProperty":1,"getProperties":1,"list":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":22,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] argv) throws IOException {\n    if (argv.length == 0)\n        // BEGIN sysprops\n        System.getProperties().list(System.out);\n    else // END sysprops\n    {\n        for (String s : argv) {\n            System.out.println(s + \" = \" + System.getProperty(s));\n        }\n    }\n}\n","name":"main","className":"SysPropDemo","variables":{"s":2,"argv":1,"System":2},"constants":{"0":1,"\" = \"":1},"javaDoc":"","comments":"BEGIN sysprops END sysprops ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"get":2,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Map<String, String>":1,"GetOptDesc[]":1,"String":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"StringLiteralExpr":7,"NameExpr":27,"CharLiteralExpr":2,"AssignExpr":1,"NullLiteralExpr":3,"ArrayInitializerExpr":1,"BooleanLiteralExpr":2,"FieldAccessExpr":3,"EnclosedExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":2,"BlockStmt":3,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    // BEGIN main\n    GetOptDesc[] options = { new GetOptDesc('n', \"numeric\", false), new GetOptDesc('o', \"output-file\", true) };\n    Map<String, String> optionsFound = new GetOpt(options).parseArguments(args);\n    if (optionsFound.get(\"n\") != null) {\n        System.out.println(\"sortType = NUMERIC;\");\n    }\n    String outputFile = null;\n    if ((outputFile = optionsFound.get(\"o\")) != null) {\n        System.out.println(\"output file specified as \" + outputFile);\n    } else {\n        System.out.println(\"Output to System.out\");\n    }\n// END main\n}\n","name":"main","className":"GetOptParseArgsDemo","variables":{"outputFile":3,"options":2,"optionsFound":3},"constants":{"'n'":1,"\"numeric\"":1,"null":3,"\"o\"":1,"\"n\"":1,"false":1,"true":1,"\"sortType = NUMERIC;\"":1,"\"output-file\"":1,"\"Output to System.out\"":1,"'o'":1,"\"output file specified as \"":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getOptInd":1,"getopt":1,"helpAndExit":2,"System.err.println":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"GetOpt":1,"char":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":24,"CharLiteralExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"SwitchStmt":1,"WhileStmt":1,"BreakStmt":1,"BlockStmt":1,"SwitchEntryStmt":2,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    GetOpt go = new GetOpt(\"h\");\n    char c;\n    while ((c = go.getopt(args)) != 0) {\n        switch(c) {\n            case 'h':\n                helpAndExit(0);\n                break;\n            default:\n                System.err.println(\"Unknown option in \" + args[go.getOptInd() - 1]);\n                helpAndExit(1);\n        }\n    }\n    System.out.println();\n}\n","name":"main","className":"GetOptSimple","variables":{"args":1,"c":3,"go":3},"constants":{"0":2,"1":2,"'h'":1,"\"Unknown option in \"":1,"\"h\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"exit":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Stub for providing help on usage\n     * You can write a longer help than this, certainly.\n     */\nstatic void helpAndExit(int returnValue) {\n    System.err.println(\"This would tell you how to use this program\");\n    System.exit(returnValue);\n}\n","name":"helpAndExit","className":"GetOptSimple","variables":{"System":1},"constants":{"\"This would tell you how to use this program\"":1},"javaDoc":"Stub for providing help on usage You can write a longer help than this certainly","comments":" Stub for providing help on usage\n     * You can write a longer help than this, certainly.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sqrt":1,"isNaN":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":31,"StringLiteralExpr":3,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":3,"ExpressionStmt":6},"text":"// BEGIN main\npublic static void main(String[] argv) {\n    double d = 123;\n    double e = 0;\n    if (d / e == Double.POSITIVE_INFINITY)\n        System.out.println(\"Check for POSITIVE_INFINITY works\");\n    double s = Math.sqrt(-1);\n    if (s == Double.NaN)\n        System.out.println(\"Comparison with NaN incorrectly returns true\");\n    if (Double.isNaN(s))\n        System.out.println(\"Double.isNaN() correctly returns true\");\n}\n","name":"main","className":"InfNaN","variables":{"s":2,"d":2,"e":2,"Math":1,"Double":1},"constants":{"0":1,"1":1,"123":1,"\"Comparison with NaN incorrectly returns true\"":1,"\"Double.isNaN() correctly returns true\"":1,"\"Check for POSITIVE_INFINITY works\"":1},"javaDoc":"","comments":" BEGIN main","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Random":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":10,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] a) {\n    Random r = new Random();\n    for (int i = 0; i < 1000; i++) // nextInt(10) goes from 0-9; add 1 for 1-10;\n    System.out.println(1 + r.nextInt(10));\n}\n","name":"main","className":"RandomInt","variables":{"r":2,"i":3},"constants":{"0":1,"1":1,"1000":1,"10":1},"javaDoc":"","comments":"nextInt(10) goes from 0-9; add 1 for 1-10; ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double"],"returnType":"int","methodCalls":{"floor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/* \n     * Round floating values to integers.\n     * @return the closest int to the argument.\n     * @param d A non-negative values to be rounded.\n     */\npublic static int round(double d) {\n    return (int) Math.floor(d + 1.0 - THRESHOLD);\n}\n","name":"round","className":"Round","variables":{"THRESHOLD":1,"d":1,"Math":1},"constants":{"1.0":1},"javaDoc":"","comments":" \n     * Round floating values to integers.\n     * @return the closest int to the argument.\n     * @param d A non-negative values to be rounded.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"round":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"VariableDeclarationExpr":1,"DoubleLiteralExpr":3,"BinaryExpr":7,"NameExpr":21,"StringLiteralExpr":4,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    for (double d = 0.1; d <= 1.0; d += 0.05) {\n        System.out.println(\"My way:  \" + d + \"-> \" + round(d));\n        System.out.println(\"Math way:\" + d + \"-> \" + Math.round(d));\n    }\n}\n","name":"main","className":"Round","variables":{"d":5,"Math":1},"constants":{"\"My way:  \"":1,"\"-> \"":2,"1.0":1,"0.1":1,"0.05":1,"\"Math way:\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toBinaryString":1,"valueOf":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":20,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    String bin = \"101010\";\n    System.out.println(bin + \" as an integer is \" + Integer.valueOf(bin, 2));\n    int i = 42;\n    System.out.println(i + \" as binary digits (bits) is \" + Integer.toBinaryString(i));\n// END main\n}\n","name":"main","className":"BinaryDigits","variables":{"Integer":2,"bin":2,"i":2},"constants":{"\" as an integer is \"":1,"2":1,"\"101010\"":1,"\" as binary digits (bits) is \"":1,"42":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"calculate":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BigNumCalc":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    BigNumCalc calc = new BigNumCalc();\n    System.out.println(calc.calculate(testInput));\n}\n","name":"main","className":"BigNumCalc","variables":{"calc":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object[]"],"returnType":"BigDecimal","methodCalls":{"pop":9,"push":5},"annotations":[],"exceptions":["IllegalStateException","IllegalArgumentException"],"concepts":[],"types":{"Object":1,"BigDecimal":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":70,"StringLiteralExpr":2,"CharLiteralExpr":4,"UnaryExpr":1,"InstanceOfExpr":2,"AssignExpr":2,"CastExpr":3,"FieldAccessExpr":2,"EnclosedExpr":5,"MethodCallExpr":19},"statements":{"SwitchStmt":1,"IfStmt":2,"BreakStmt":4,"BlockStmt":4,"SwitchEntryStmt":5,"ForStmt":1,"ThrowStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n     * Calculate a set of operands; the input is an Object array containing\n     * either BigDecimal objects (which may be pushed onto the Stack) and\n     * operators (which are operated on immediately).\n     * @param input\n     * @return\n     */\npublic BigDecimal calculate(Object[] input) {\n    BigDecimal tmp;\n    for (int i = 0; i < input.length; i++) {\n        Object o = input[i];\n        if (o instanceof BigDecimal) {\n            stack.push((BigDecimal) o);\n        } else if (o instanceof String) {\n            switch(((String) o).charAt(0)) {\n                // + and * are commutative, order doesn't matter\n                case '+':\n                    stack.push((stack.pop()).add(stack.pop()));\n                    break;\n                case '*':\n                    stack.push((stack.pop()).multiply(stack.pop()));\n                    break;\n                // - and /, order *does* matter\n                case '-':\n                    tmp = (BigDecimal) stack.pop();\n                    stack.push((stack.pop()).subtract(tmp));\n                    break;\n                case '/':\n                    tmp = stack.pop();\n                    stack.push((stack.pop()).divide(tmp, BigDecimal.ROUND_HALF_UP));\n                    break;\n                default:\n                    throw new IllegalStateException(\"Unknown OPERATOR popped\");\n            }\n        } else {\n            throw new IllegalArgumentException(\"Syntax error in input\");\n        }\n    }\n    return stack.pop();\n}\n","name":"calculate","className":"BigNumCalc","variables":{"input":1,"stack":14,"tmp":3,"i":4,"o":5},"constants":{"0":2,"'-'":1,"\"Syntax error in input\"":1,"'+'":1,"'*'":1,"\"Unknown OPERATOR popped\"":1,"'/'":1},"javaDoc":"Calculate a set of operands; the input is an Object array containing either BigDecimal objects (which may be pushed onto the Stack) and operators (which are operated on immediately) input","comments":"+ and are commutative order doesn't matter - and / order does matter \n     * Calculate a set of operands; the input is an Object array containing\n     * either BigDecimal objects (which may be pushed onto the Stack) and\n     * operators (which are operated on immediately).\n     * @param input\n     * @return\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int[][]","int[][]"],"returnType":"int[][]","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"int[][]":1,"int":7},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":8,"ArrayAccessExpr":8,"BinaryExpr":8,"NameExpr":37,"StringLiteralExpr":2,"FieldAccessExpr":4,"ArrayCreationExpr":1,"UnaryExpr":3,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ThrowStmt":1,"ForStmt":3,"ReturnStmt":1,"ExpressionStmt":6},"text":"/* Matrix-multiply two arrays together.\n     * The arrays MUST be rectangular.\n     * @author Tom Christiansen & Nathan Torkington, Perl Cookbook version.\n     */\npublic static int[][] multiply(int[][] m1, int[][] m2) {\n    int m1rows = m1.length;\n    int m1cols = m1[0].length;\n    int m2rows = m2.length;\n    int m2cols = m2[0].length;\n    if (m1cols != m2rows)\n        throw new IllegalArgumentException(\"matrices don't match: \" + m1cols + \" != \" + m2rows);\n    int[][] result = new int[m1rows][m2cols];\n    // multiply\n    for (int i = 0; i < m1rows; i++) {\n        for (int j = 0; j < m2cols; j++) {\n            for (int k = 0; k < m1cols; k++) {\n                result[i][j] += m1[i][k] * m2[k][j];\n            }\n        }\n    }\n    return result;\n}\n","name":"multiply","className":"Matrix","variables":{"result":3,"m1":2,"m1rows":3,"m2":2,"m1cols":4,"m2cols":3,"m2rows":3,"i":5,"j":5,"k":5},"constants":{"0":5,"\"matrices don't match: \"":1,"\" != \"":1},"javaDoc":"","comments":"multiply  Matrix-multiply two arrays together.\n     * The arrays MUST be rectangular.\n     * @author Tom Christiansen & Nathan Torkington, Perl Cookbook version.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[][]"],"returnType":"void","methodCalls":{"System.out.print":2,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":4},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"ArrayAccessExpr":3,"BinaryExpr":8,"NameExpr":42,"StringLiteralExpr":8,"FieldAccessExpr":7,"UnaryExpr":2,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForStmt":2,"ExpressionStmt":7},"text":"/** Matrix print.\n     */\npublic static void mprint(int[][] a) {\n    int rows = a.length;\n    int cols = a[0].length;\n    System.out.println(\"array[\" + rows + \"][\" + cols + \"] = {\");\n    for (int i = 0; i < rows; i++) {\n        System.out.print(\"{\");\n        for (int j = 0; j < cols; j++) System.out.print(\" \" + a[i][j] + \",\");\n        System.out.println(\"},\");\n    }\n    System.out.println(\"};\");\n}\n","name":"mprint","className":"Matrix","variables":{"a":2,"i":4,"j":4,"rows":3,"cols":3},"constants":{"0":3,"\"},\"":1,"\"][\"":1,"\"};\"":1,"\" \"":1,"\",\"":1,"\"{\"":1,"\"] = {\"":1,"\"array[\"":1},"javaDoc":"Matrix print","comments":" Matrix print.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"valueOf":1,"intValue":1,"toString":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Integer":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":20,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    // int to Integer\n    Integer i1 = Integer.valueOf(42);\n    // or just i1\n    System.out.println(i1.toString());\n    // Integer to int\n    int i2 = i1.intValue();\n    System.out.println(i2);\n}\n","name":"main","className":"IntObject","variables":{"Integer":1,"i1":3,"i2":1},"constants":{"42":1},"javaDoc":"","comments":"int to Integer or just i1 Integer to int ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":1,"getInstance":1,"parse":1,"System.err.println":1,"System.out.println":1},"annotations":[],"exceptions":["ParseException"],"concepts":["ExceptionHandling"],"types":{"Number":1,"NumberFormat":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":24,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public static void main(String[] av) {\n    NumberFormat defForm = NumberFormat.getInstance();\n    try {\n        Number d = defForm.parse(input);\n        System.out.println(input + \" parses as \" + d + \" and formats as \" + defForm.format(d));\n    } catch (ParseException pe) {\n        System.err.println(input + \"not parseable!\");\n    }\n}\n","name":"main","className":"NumFormatParse","variables":{"input":2,"d":2,"pe":1,"defForm":3,"NumberFormat":1},"constants":{"\"not parseable!\"":1,"\" parses as \"":1,"\" and formats as \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"Complex","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Construct a Complex */\nComplex(double rr, double ii) {\n    r = rr;\n    i = ii;\n}\n","name":"Complex","className":"Complex","variables":{"rr":1,"ii":1,"r":1,"i":1},"constants":{},"javaDoc":"Construct a Complex","comments":" Construct a Complex ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":15,"CharLiteralExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Display the current Complex as a String, for use in\n     * println() and elsewhere.\n     */\npublic String toString() {\n    StringBuffer sb = new StringBuffer().append(r);\n    if (i > 0)\n        // else append(i) appends - sign\n        sb.append('+');\n    return sb.append(i).append('i').toString();\n}\n","name":"toString","className":"Complex","variables":{"i":1,"sb":3},"constants":{"0":1,"'+'":1,"'i'":1},"javaDoc":"Display the current Complex as a String for use in println() and elsewhere","comments":"else append(i) appends - sign  Display the current Complex as a String, for use in\n     * println() and elsewhere.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return just the Real part */\npublic double getReal() {\n    return r;\n}\n","name":"getReal","className":"Complex","variables":{"r":1},"constants":{},"javaDoc":"Return just the Real part","comments":" Return just the Real part ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return just the Real part */\npublic double getImaginary() {\n    return i;\n}\n","name":"getImaginary","className":"Complex","variables":{"i":1},"constants":{},"javaDoc":"Return just the Real part","comments":" Return just the Real part ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":7,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the magnitude of a complex number */\npublic double magnitude() {\n    return Math.sqrt(r * r + i * i);\n}\n","name":"magnitude","className":"Complex","variables":{"r":2,"i":2,"Math":1},"constants":{},"javaDoc":"Return the magnitude of a complex number","comments":" Return the magnitude of a complex number ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Complex"],"returnType":"Complex","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":3,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Add another Complex to this one\n     */\npublic Complex add(Complex other) {\n    return add(this, other);\n}\n","name":"add","className":"Complex","variables":{},"constants":{},"javaDoc":"Add another Complex to this one","comments":" Add another Complex to this one\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Complex","Complex"],"returnType":"Complex","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":12,"FieldAccessExpr":4},"statements":{"ReturnStmt":1},"text":"/** Add two Complexes\n     */\npublic static Complex add(Complex c1, Complex c2) {\n    return new Complex(c1.r + c2.r, c1.i + c2.i);\n}\n","name":"add","className":"Complex","variables":{},"constants":{},"javaDoc":"Add two Complexes","comments":" Add two Complexes\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Complex"],"returnType":"Complex","methodCalls":{"subtract":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":3,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Subtract another Complex from this one\n     */\npublic Complex subtract(Complex other) {\n    return subtract(this, other);\n}\n","name":"subtract","className":"Complex","variables":{},"constants":{},"javaDoc":"Subtract another Complex from this one","comments":" Subtract another Complex from this one\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Complex","Complex"],"returnType":"Complex","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":12,"FieldAccessExpr":4},"statements":{"ReturnStmt":1},"text":"/** Subtract two Complexes\n     */\npublic static Complex subtract(Complex c1, Complex c2) {\n    return new Complex(c1.r - c2.r, c1.i - c2.i);\n}\n","name":"subtract","className":"Complex","variables":{},"constants":{},"javaDoc":"Subtract two Complexes","comments":" Subtract two Complexes\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Complex"],"returnType":"Complex","methodCalls":{"multiply":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":3,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Multiply this Complex times another one\n     */\npublic Complex multiply(Complex other) {\n    return multiply(this, other);\n}\n","name":"multiply","className":"Complex","variables":{},"constants":{},"javaDoc":"Multiply this Complex times another one","comments":" Multiply this Complex times another one\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Complex","Complex"],"returnType":"Complex","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":6,"NameExpr":24,"FieldAccessExpr":8},"statements":{"ReturnStmt":1},"text":"/** Multiply two Complexes\n     */\npublic static Complex multiply(Complex c1, Complex c2) {\n    return new Complex(c1.r * c2.r - c1.i * c2.i, c1.r * c2.i + c1.i * c2.r);\n}\n","name":"multiply","className":"Complex","variables":{},"constants":{},"javaDoc":"Multiply two Complexes","comments":" Multiply two Complexes\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Complex","Complex"],"returnType":"Complex","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":14,"NameExpr":48,"FieldAccessExpr":16,"EnclosedExpr":4},"statements":{"ReturnStmt":1},"text":"/** Divide c1 by c2.\n     * @author Gisbert Selke.\n     */\npublic static Complex divide(Complex c1, Complex c2) {\n    return new Complex((c1.r * c2.r + c1.i * c2.i) / (c2.r * c2.r + c2.i * c2.i), (c1.i * c2.r - c1.r * c2.i) / (c2.r * c2.r + c2.i * c2.i));\n}\n","name":"divide","className":"Complex","variables":{},"constants":{},"javaDoc":"Divide c1 by c2 @author Gisbert Selke","comments":" Divide c1 by c2.\n     * @author Gisbert Selke.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":["Casting"],"types":{"Complex":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":12,"StringLiteralExpr":1,"CastExpr":1,"ClassExpr":1,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/* Compare this Complex number with another\n     */\npublic boolean equals(Object o) {\n    if (o.getClass() != Complex.class) {\n        throw new IllegalArgumentException(\"Complex.equals argument must be a Complex\");\n    }\n    Complex other = (Complex) o;\n    return r == other.r && i == other.i;\n}\n","name":"equals","className":"Complex","variables":{"other":1,"r":1,"i":1,"o":2},"constants":{"\"Complex.equals argument must be a Complex\"":1},"javaDoc":"","comments":" Compare this Complex number with another\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"CastExpr":2,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/* Generate a hashCode; not sure how well distributed these are.\n     */\npublic int hashCode() {\n    return (int) (r) | (int) i;\n}\n","name":"hashCode","className":"Complex","variables":{"r":1,"i":1},"constants":{},"javaDoc":"","comments":" Generate a hashCode; not sure how well distributed these are.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextInt":1,"nextDouble":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Random":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":20,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":4},"statements":{"ForStmt":2,"ExpressionStmt":3},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    // java.util.Random methods are non-static, so need to construct\n    Random r = new Random();\n    for (int i = 0; i < 10; i++) System.out.println(\"A double from java.util.Random is \" + r.nextDouble());\n    for (int i = 0; i < 10; i++) System.out.println(\"An integer from java.util.Random is \" + r.nextInt());\n// END main\n}\n","name":"main","className":"Random2","variables":{"r":3,"i":6},"constants":{"0":2,"\"An integer from java.util.Random is \"":1,"\"A double from java.util.Random is \"":1,"10":2},"javaDoc":"","comments":"BEGIN main END main java util Random methods are non-static so need to construct ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"report":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"NameExpr":6,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] argv) {\n    report(0);\n    report(1);\n    report(2);\n}\n","name":"main","className":"FormatPlurals","variables":{},"constants":{"0":1,"1":1,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":4,"NameExpr":7,"StringLiteralExpr":4,"FieldAccessExpr":1,"EnclosedExpr":1,"ConditionalExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** report -- using conditional operator */\npublic static void report(int n) {\n    System.out.println(\"We used \" + n + \" item\" + (n == 1 ? \"\" : \"s\"));\n}\n","name":"report","className":"FormatPlurals","variables":{"n":2},"constants":{"\"\"":1,"1":1,"\"s\"":1,"\"We used \"":1,"\" item\"":1},"javaDoc":"report -- using conditional operator","comments":" report -- using conditional operator ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"log":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":12,"StringLiteralExpr":2,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    double someValue;\n    // compute someValue...\n    someValue = 0;\n    double log_e = Math.log(someValue);\n    System.out.println(\"Log(e) of \" + someValue + \" is \" + log_e);\n// END main\n}\n","name":"main","className":"Logarithm","variables":{"someValue":3,"Math":1,"log_e":2},"constants":{"0":1,"\"Log(e) of \"":1,"\" is \"":1},"javaDoc":"","comments":"END main BEGIN main compute someValue ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getReal":1,"add":2,"divide":1,"multiply":1,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"Complex":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":14,"NameExpr":59,"StringLiteralExpr":7,"FieldAccessExpr":6,"UnaryExpr":1,"MethodCallExpr":11},"statements":{"ExpressionStmt":8},"text":"/** The program */\npublic static void main(String[] args) {\n    Complex c = new Complex(3, 5);\n    Complex d = new Complex(2, -2);\n    System.out.println(c);\n    System.out.println(c + \".getReal() = \" + c.getReal());\n    System.out.println(c + \" + \" + d + \" = \" + c.add(d));\n    System.out.println(c + \" + \" + d + \" = \" + Complex.add(c, d));\n    System.out.println(c + \" * \" + d + \" = \" + c.multiply(d));\n    System.out.println(Complex.divide(c, d));\n}\n","name":"main","className":"ComplexDemo","variables":{"c":8,"d":4,"Complex":2},"constants":{"\" * \"":1,"\".getReal() = \"":1,"\" + \"":2,"2":2,"3":1,"5":1,"\" = \"":3},"javaDoc":"The program","comments":" The program ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"doubleValue":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"BigInteger":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":22,"StringLiteralExpr":4,"FieldAccessExpr":4,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    System.out.println(\"Here's Long.MAX_VALUE: \" + Long.MAX_VALUE);\n    BigInteger bInt = new BigInteger(\"3419229223372036854775807\");\n    System.out.println(\"Here's a bigger number: \" + bInt);\n    System.out.println(\"Here it is as a double: \" + bInt.doubleValue());\n// END main\n}\n","name":"main","className":"BigNums","variables":{"bInt":3},"constants":{"\"Here it is as a double: \"":1,"\"3419229223372036854775807\"":1,"\"Here's a bigger number: \"":1,"\"Here's Long.MAX_VALUE: \"":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":31,"StringLiteralExpr":5,"FieldAccessExpr":4,"MethodCallExpr":6},"statements":{"BlockStmt":2,"ForeachStmt":2,"ExpressionStmt":4},"text":"public static void main(String[] argv) {\n    System.out.println(\"Pluralized Format\");\n    for (int i : data) {\n        System.out.println(\"Found \" + i + \" \" + pluralizedFormat.format(i));\n    }\n    System.out.println(\"Quantized Format\");\n    for (int i : data) {\n        System.out.println(\"Found \" + quantizedFormat.format(i));\n    }\n}\n","name":"main","className":"FormatPluralsChoice","variables":{"pluralizedFormat":1,"quantizedFormat":1,"data":2,"i":3},"constants":{"\" \"":1,"\"Found \"":2,"\"Quantized Format\"":1,"\"Pluralized Format\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    // java.lang.Math.random() is static, don't need to construct Math\n    System.out.println(\"A random from java.lang.Math is \" + Math.random());\n// END main\n}\n","name":"main","className":"Random1","variables":{"Math":1},"constants":{"\"A random from java.lang.Math is \"":1},"javaDoc":"","comments":"BEGIN main END main java lang Math random() is static don't need to construct Math ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":3,"getInstance":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"DecimalFormat":1,"NumberFormat":2},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":8,"NameExpr":41,"StringLiteralExpr":6,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":9},"statements":{"ExpressionStmt":6},"text":"/** The main (and only) method in this class. */\npublic static void main(String[] av) {\n    // BEGIN part2\n    NumberFormat defForm = NumberFormat.getInstance();\n    NumberFormat ourForm = new DecimalFormat(\"##0.##\");\n    // toPattern() will reveal the combination of #0., etc\n    // that this particular Locale uses to format with!\n    System.out.println(\"defForm's pattern is \" + ((DecimalFormat) defForm).toPattern());\n    System.out.println(intlNumber + \" formats as \" + defForm.format(intlNumber));\n    System.out.println(ourNumber + \" formats as \" + ourForm.format(ourNumber));\n    System.out.println(ourNumber + \" formats as \" + defForm.format(ourNumber) + \" using the default format\");\n// END part2\n}\n","name":"main","className":"NumFormatDemo","variables":{"ourForm":2,"intlNumber":1,"ourNumber":2,"defForm":4,"NumberFormat":1},"constants":{"\" using the default format\"":1,"\"defForm's pattern is \"":1,"\"##0.##\"":1,"\" formats as \"":3},"javaDoc":"The main (and only) method in this class","comments":"toPattern() will reveal the combination of #0 etc END part2 BEGIN part2 that this particular Locale uses to format with!  The main (and only) method in this class. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getYear":1,"now":1,"format":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"RomanNumberFormat":1,"int":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":15,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    // BEGIN main\n    RomanNumberFormat nf = new RomanNumberFormat();\n    int year = LocalDate.now().getYear();\n    System.out.println(year + \" -> \" + nf.format(year));\n// END main\n}\n","name":"main","className":"RomanNumberSimple","variables":{"year":2,"nf":2,"LocalDate":1},"constants":{"\" -> \"":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setMinimumIntegerDigits":1,"format":1,"getInstance":1,"setMinimumFractionDigits":1,"setMaximumFractionDigits":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1,"NumberFormat":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"ForStmt":1,"ExpressionStmt":5},"text":"/** The main (and only) method in this class. */\npublic static void main(String[] av) {\n    // Get a format instance\n    NumberFormat form = NumberFormat.getInstance();\n    // Set it to look like 999.99[99]\n    form.setMinimumIntegerDigits(3);\n    form.setMinimumFractionDigits(2);\n    form.setMaximumFractionDigits(4);\n    // Now print using it.\n    for (int i = 0; i < data.length; i++) System.out.println(data[i] + \"\\tformats as \" + form.format(data[i]));\n}\n","name":"main","className":"NumFormat2","variables":{"form":5,"data":2,"i":5,"NumberFormat":1},"constants":{"0":1,"\"\\tformats as \"":1,"2":1,"3":1,"4":1},"javaDoc":"The main (and only) method in this class","comments":"Get a format instance Set it to look like 999 99[99] Now print using it  The main (and only) method in this class. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"double","methodCalls":{"log":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"// BEGIN main\npublic static double log_base(double base, double value) {\n    return Math.log(value) / Math.log(base);\n}\n","name":"log_base","className":"LogBase","variables":{"Math":2},"constants":{},"javaDoc":"","comments":" BEGIN main","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"set":3,"get":1,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"BitSet":1,"int[]":1,"int":5},"expressions":{"IntegerLiteralExpr":12,"ObjectCreationExpr":1,"VariableDeclarationExpr":7,"ArrayInitializerExpr":1,"ArrayAccessExpr":3,"BinaryExpr":9,"NameExpr":64,"StringLiteralExpr":5,"FieldAccessExpr":8,"UnaryExpr":3,"MethodCallExpr":9,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ForStmt":4,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    // starting at 1.\n    for (int i = 1; i <= months.length; i++) System.out.println(\"Month # \" + i);\n    // starting at 0.\n    for (int i = 0; i < months.length; i++) System.out.println(\"Month \" + months[i]);\n    // For e.g., counting by 3 from 11 to 27, use a for loop\n    for (int i = 11; i <= 27; i += 3) {\n        System.out.println(\"i = \" + i);\n    }\n    // A discontiguous set of integers, using a BitSet\n         // When you want an ordinal list of numbers, use a for loop\n\n    // Create a BitSet and turn on a couple of bits.\n    BitSet b = new BitSet();\n    // January\n    b.set(0);\n         // When you want a set of array indices, use a for loop\n\n    // April\n    b.set(3);\n    // September\n    b.set(8);\n    // Presumably this would be somewhere else in the code.\n    for (int i = 0; i < months.length; i++) {\n        if (b.get(i))\n            System.out.println(\"Month \" + months[i]);\n    }\n    // Same example but shorter:\n    // a discontiguous set of integers, using an array\n    int[] numbers = { 0, 3, 8 };\n    // Presumably this would be somewhere else in the code.\n    for (int n : numbers) {\n        System.out.println(\"Month: \" + months[n]);\n    }\n}\n","name":"main","className":"NumSeries","variables":{"b":5,"months":3,"numbers":2,"i":16,"n":2},"constants":{"0":4,"11":1,"1":1,"\"Month # \"":1,"\"Month: \"":1,"3":3,"27":1,"\"Month \"":2,"8":2,"\"i = \"":1},"javaDoc":"","comments":"When you want an ordinal list of numbers use a for loop When you want a set of array indices use a for loop A discontiguous set of integers using a BitSet Same example but shorter: starting at 1 starting at 0 For e g counting by 3 from 11 to 27 use a for loop Create a BitSet and turn on a couple of bits January April September Presumably this would be somewhere else in the code a discontiguous set of integers using an array Presumably this would be somewhere else in the code ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sqrt":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":2,"float":2},"expressions":{"VariableDeclarationExpr":4,"DoubleLiteralExpr":8,"BinaryExpr":20,"NameExpr":48,"CastExpr":1,"StringLiteralExpr":2,"FieldAccessExpr":2,"EnclosedExpr":8,"AssignExpr":10,"MethodCallExpr":4},"statements":{"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    // Sides for triangle in float\n    float af, bf, cf;\n    float sf, areaf;\n    // Ditto in double\n    double ad, bd, cd;\n    double sd, aread;\n    // Area of triangle in float\n    af = 12345679.0f;\n    bf = 12345678.0f;\n    cf = 1.01233995f;\n    sf = (af + bf + cf) / 2.0f;\n    areaf = (float) Math.sqrt(sf * (sf - af) * (sf - bf) * (sf - cf));\n    System.out.println(\"Single precision: \" + areaf);\n    // Area of triangle in double\n    ad = 12345679.0;\n    bd = 12345678.0;\n    cd = 1.01233995;\n    sd = (ad + bd + cd) / 2.0d;\n    aread = Math.sqrt(sd * (sd - ad) * (sd - bd) * (sd - cd));\n    System.out.println(\"Double precision: \" + aread);\n}\n","name":"main","className":"Heron","variables":{"cd":4,"sd":6,"bd":4,"cf":4,"sf":6,"ad":4,"bf":4,"af":4,"areaf":3,"aread":3,"Math":2},"constants":{"12345679.0f":1,"\"Single precision: \"":1,"2.0f":1,"2.0d":1,"12345679.0":1,"12345678.0":1,"1.01233995f":1,"\"Double precision: \"":1,"1.01233995":1,"12345678.0f":1},"javaDoc":"","comments":"Sides for triangle in float Ditto in double Area of triangle in float Area of triangle in double ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"data":1,"start":1,"end":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"TempConverter2":1,"TempConverter":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    TempConverter t = new TempConverter2();\n    t.start();\n    t.data();\n    t.end();\n}\n","name":"main","className":"TempConverter2","variables":{"t":4},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["float","float"],"returnType":"void","methodCalls":{"System.out.printf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"protected void print(float f, float c) {\n    System.out.printf(\"%6.2f %6.2f%n\", f, c);\n}\n","name":"print","className":"TempConverter2","variables":{},"constants":{"\"%6.2f %6.2f%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"protected void start() {\n    System.out.println(\"Fahr    Centigrade\");\n}\n","name":"start","className":"TempConverter2","variables":{},"constants":{"\"Fahr    Centigrade\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"protected void end() {\n    System.out.println(\"-------------------\");\n}\n","name":"end","className":"TempConverter2","variables":{},"constants":{"\"-------------------\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"log_base":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"// BEGIN main\npublic static void main(String[] argv) {\n    double d = LogBase.log_base(10, 10000);\n    System.out.println(\"log10(10000) = \" + d);\n}\n","name":"main","className":"LogBaseUse","variables":{"d":2,"LogBase":1},"constants":{"\"log10(10000) = \"":1,"10000":1,"10":1},"javaDoc":"","comments":" BEGIN main","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"findPalindrome":1,"parseLong":1,"System.err.println":3,"System.out.println":1},"annotations":[],"exceptions":["IllegalStateException","NumberFormatException"],"concepts":["ExceptionHandling"],"types":{"int":1,"long":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":5,"BinaryExpr":8,"NameExpr":43,"StringLiteralExpr":4,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"ContinueStmt":1,"IfStmt":1,"TryStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] argv) {\n    for (int i = 0; i < argv.length; i++) try {\n        long l = Long.parseLong(argv[i]);\n        if (l < 0) {\n            System.err.println(argv[i] + \" -> TOO SMALL\");\n            continue;\n        }\n        System.out.println(argv[i] + \"->\" + findPalindrome(l));\n    } catch (NumberFormatException e) {\n        System.err.println(argv[i] + \"-> INVALID\");\n    } catch (IllegalStateException e) {\n        System.err.println(argv[i] + \"-> \" + e);\n    }\n}\n","name":"main","className":"Palindrome","variables":{"e":3,"Long":1,"i":8,"l":2,"argv":5},"constants":{"0":2,"\"-> \"":1,"\" -> TOO SMALL\"":1,"\"-> INVALID\"":1,"\"->\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["long"],"returnType":"long","methodCalls":{"isPalindrome":1,"findPalindrome":1,"reverseNumber":1,"System.out.println":1},"annotations":[],"exceptions":["IllegalStateException"],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":3,"NameExpr":18,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":3,"ThrowStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"/** find a palindromic number given a starting point, by\n     * calling ourself until we get a number that is palindromic.\n     */\nstatic long findPalindrome(long num) {\n    if (num < 0)\n        throw new IllegalStateException(\"negative\");\n    if (isPalindrome(num))\n        return num;\n    if (verbose)\n        System.out.println(\"Trying \" + num);\n    return findPalindrome(num + reverseNumber(num));\n}\n","name":"findPalindrome","className":"Palindrome","variables":{"num":4,"verbose":1},"constants":{"0":1,"\"negative\"":1,"\"Trying \"":1},"javaDoc":"find a palindromic number given a starting point by calling ourself until we get a number that is palindromic","comments":" find a palindromic number given a starting point, by\n     * calling ourself until we get a number that is palindromic.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["long"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":9,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":10,"BooleanLiteralExpr":3,"NameExpr":15,"UnaryExpr":2,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":1,"ReturnStmt":3,"ForStmt":1,"ExpressionStmt":3},"text":"/** Check if a number is palindromic. */\nstatic boolean isPalindrome(long num) {\n    // Consider any single digit to be as palindromic as can be\n    if (num >= 0 && num <= 9)\n        return true;\n    int nDigits = 0;\n    while (num > 0) {\n        digits[nDigits++] = num % 10;\n        num /= 10;\n    }\n    for (int i = 0; i < nDigits / 2; i++) if (digits[i] != digits[nDigits - i - 1])\n        return false;\n    return true;\n}\n","name":"isPalindrome","className":"Palindrome","variables":{"num":5,"i":5,"digits":3,"nDigits":4},"constants":{"0":4,"1":1,"2":1,"true":2,"false":1,"9":1,"10":2},"javaDoc":"Check if a number is palindromic","comments":"Consider any single digit to be as palindromic as can be  Check if a number is palindromic. ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["long"],"returnType":"long","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2,"long":1},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":13,"UnaryExpr":2,"AssignExpr":4},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"static long reverseNumber(long num) {\n    int nDigits = 0;\n    while (num > 0) {\n        digits[nDigits++] = num % 10;\n        num /= 10;\n    }\n    long ret = 0;\n    for (int i = 0; i < nDigits; i++) {\n        ret *= 10;\n        ret += digits[i];\n    }\n    return ret;\n}\n","name":"reverseNumber","className":"Palindrome","variables":{"ret":4,"num":3,"i":4,"digits":2,"nDigits":3},"constants":{"0":4,"10":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":4,"int":1},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":5,"DoubleLiteralExpr":4,"BinaryExpr":9,"NameExpr":30,"FieldAccessExpr":5,"EnclosedExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] u) {\n    // fast but obscure and inaccurate: convert\n    double d1 = 0.666 * 5;\n    // 2/3 to 0.666 in programmer's head\n    System.out.println(d1);\n    // wrong answer - 2/3 == 0, 0*5 = 0\n    double d2 = 2 / 3 * 5;\n    System.out.println(d2);\n    // \"normal\"\n    double d3 = 2d / 3d * 5;\n    System.out.println(d3);\n    // one step done as integers, almost same answer\n    double d4 = (2 * 5) / 3d;\n    System.out.println(d4);\n    // fast, approximate integer answer\n    int i5 = 2 * 5 / 3;\n    System.out.println(i5);\n}\n","name":"main","className":"FractMult","variables":{"d4":1,"i5":1,"d1":1,"d2":1,"d3":1},"constants":{"3d":2,"0.666":1,"2":3,"2d":1,"3":2,"5":5},"javaDoc":"","comments":"fast but obscure and inaccurate: convert 2/3 to 0 666 in programmer's head wrong answer - 2/3 == 0 0 5 = 0 \"normal\" one step done as integers almost same answer fast approximate integer answer ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"process":1,"getText":1,"toString":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":11,"MethodCallExpr":4},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent ev) {\n    String s = textField.getText();\n    statusLabel.setText(process(s).toString());\n}\n","name":"actionPerformed","className":"","variables":{"s":1,"statusLabel":1,"textField":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"GetNumber","methodCalls":{"add":4,"process":1,"getText":1,"addActionListener":1,"toString":1,"pack":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Panel":1,"String":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"NameExpr":37,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":10,"AssignExpr":2},"statements":{"BlockStmt":1,"ExpressionStmt":9},"text":"/** Constructor: set up the GUI */\npublic GetNumber() {\n    Panel p = new Panel();\n    p.add(new Label(\"Number:\"));\n    p.add(textField = new TextField(10));\n    add(BorderLayout.NORTH, p);\n    textField.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent ev) {\n            String s = textField.getText();\n            statusLabel.setText(process(s).toString());\n        }\n    });\n    add(BorderLayout.SOUTH, statusLabel = new TextField(10));\n    pack();\n}\n","name":"GetNumber","className":"GetNumber","variables":{"p":3,"ev":1,"actionPerformed":1,"s":1,"statusLabel":2,"textField":3},"constants":{"\"Number:\"":1,"10":2},"javaDoc":"Constructor: set up the GUI","comments":" Constructor: set up the GUI ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Number","methodCalls":{"parseDouble":1,"parseInt":1,"valueOf":2,"matches":1,"System.out.println":4},"annotations":[],"exceptions":["NumberFormatException"],"concepts":["ExceptionHandling"],"types":{"double":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":45,"StringLiteralExpr":5,"FieldAccessExpr":4,"MethodCallExpr":9},"statements":{"IfStmt":1,"BlockStmt":5,"TryStmt":2,"ReturnStmt":4,"ExpressionStmt":6},"text":"/* Process one String, returning it as a Number subclass\n     * Does not require the GUI.\n     */\npublic static Number process(String s) {\n    if (s.matches(\"[+-]*\\\\d*\\\\.\\\\d+[dDeEfF]*\")) {\n        try {\n            double dValue = Double.parseDouble(s);\n            System.out.println(\"It's a double: \" + dValue);\n            return Double.valueOf(dValue);\n        } catch (NumberFormatException e) {\n            System.out.println(\"Invalid double: \" + s);\n            return NAN;\n        }\n    } else\n        // did not contain . d e or f, so try as int.\n        try {\n            int iValue = Integer.parseInt(s);\n            System.out.println(\"It's an int: \" + iValue);\n            return Integer.valueOf(iValue);\n        } catch (NumberFormatException e2) {\n            System.out.println(\"Not a number: \" + s);\n            return NAN;\n        }\n}\n","name":"process","className":"GetNumber","variables":{"Integer":2,"s":3,"dValue":2,"e":1,"NAN":2,"Double":2,"e2":1,"iValue":2},"constants":{"\"Not a number: \"":1,"\"[+-]*\\\\d*\\\\.\\\\d+[dDeEfF]*\"":1,"\"It's a double: \"":1,"\"Invalid double: \"":1,"\"It's an int: \"":1},"javaDoc":"","comments":"did not contain d e or f so try as int  Process one String, returning it as a Number subclass\n     * Does not require the GUI.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] ap) {\n    new GetNumber().setVisible(true);\n}\n","name":"main","className":"GetNumber","variables":{},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["Casting","FinalVariables"],"types":{"double":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"DoubleLiteralExpr":1,"BinaryExpr":10,"NameExpr":18,"StringLiteralExpr":4,"CastExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    int a = 100;\n    int b = a * 5 / 7;\n    System.out.println(\"5/7 of \" + a + \" is \" + b);\n    // Just for fun, do it again in floating point.\n    final double FRACT = 0.7142857132857;\n    int c = (int) (a * FRACT);\n    System.out.println(FRACT + \" of \" + a + \" is \" + c);\n// END main\n}\n","name":"main","className":"IntFract","variables":{"a":5,"b":2,"c":2,"FRACT":3},"constants":{"100":1,"\" is \"":2,"5":1,"\"5/7 of \"":1,"7":1,"0.7142857132857":1,"\" of \"":1},"javaDoc":"","comments":"END main BEGIN main Just for fun do it again in floating point ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"byte":1,"int":1},"expressions":{"VariableDeclarationExpr":3,"DoubleLiteralExpr":1,"BinaryExpr":2,"NameExpr":20,"CastExpr":2,"StringLiteralExpr":2,"FieldAccessExpr":2,"AssignExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":9},"text":"// BEGIN main\npublic static void main(String[] argv) {\n    int i;\n    double j = 2.75;\n    // EXPECT COMPILE ERROR\n    i = j;\n    // with cast; i gets 2\n    i = (int) j;\n    System.out.println(\"i =\" + i);\n    byte b;\n    // EXPECT COMPILE ERROR\n    b = i;\n    // with cast, i gets 2\n    b = (byte) i;\n    System.out.println(\"b =\" + b);\n}\n","name":"main","className":"CastNeeded","variables":{"b":4,"i":6,"j":3},"constants":{"\"i =\"":1,"\"b =\"":1,"2.75":1},"javaDoc":"","comments":"EXPECT COMPILE ERROR with cast; i gets 2 EXPECT COMPILE ERROR with cast i gets 2  BEGIN main","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"multiply":1,"mprint":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":12,"VariableDeclarationExpr":3,"ArrayInitializerExpr":7,"NameExpr":17,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    int x[][] = { { 3, 2, 3 }, { 5, 9, 8 } };\n    int y[][] = { { 4, 7 }, { 9, 3 }, { 8, 1 } };\n    int z[][] = Matrix.multiply(x, y);\n    Matrix.mprint(x);\n    Matrix.mprint(y);\n    Matrix.mprint(z);\n// END main\n}\n","name":"main","className":"MatrixUse","variables":{"Matrix":4,"x":1,"y":1,"z":1},"constants":{"1":1,"2":1,"3":3,"4":1,"5":1,"7":1,"8":2,"9":2},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseDouble":1,"System.out.println":2},"annotations":[],"exceptions":["NumberFormatException"],"concepts":["ExceptionHandling"],"types":{"double":1,"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":18,"StringLiteralExpr":2,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"// BEGIN main\npublic static void main(String[] argv) {\n    // not argv[1]\n    String aNumber = argv[0];\n    double result;\n    try {\n        result = Double.parseDouble(aNumber);\n        System.out.println(\"Number is \" + result);\n    } catch (NumberFormatException exc) {\n        System.out.println(\"Invalid number \" + aNumber);\n        return;\n    }\n}\n","name":"main","className":"StringToDouble","variables":{"aNumber":2,"result":3,"exc":1,"argv":1,"Double":1},"constants":{"0":1,"\"Invalid number \"":1,"\"Number is \"":1},"javaDoc":"","comments":"not argv[1]  BEGIN main","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"valueOf":1,"toString":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":2},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"ArrayInitializerExpr":1,"BinaryExpr":9,"StringLiteralExpr":6,"NameExpr":24,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    String input = \"101010\";\n    for (int radix : new int[] { 2, 8, 10, 16, 36 }) {\n        System.out.print(input + \" in base \" + radix + \" is \" + Integer.valueOf(input, radix) + \"; \");\n        int i = 42;\n        System.out.println(i + \" formatted in base \" + radix + \" is \" + Integer.toString(i, radix));\n    }\n// END main\n}\n","name":"main","className":"IntegerBinOctHexEtc","variables":{"radix":3,"Integer":2,"input":2,"i":2},"constants":{"\" formatted in base \"":1,"2":1,"36":1,"\" is \"":2,"16":1,"8":1,"\"101010\"":1,"\"; \"":1,"42":1,"10":1,"\" in base \"":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextGaussian":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Random":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":10,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    // java.util.Random methods are non-static, do need to construct Math\n    // BEGIN main\n    Random r = new Random();\n    for (int i = 0; i < 10; i++) System.out.println(\"A gaussian random double is \" + r.nextGaussian());\n// END main\n}\n","name":"main","className":"Random3","variables":{"r":2,"i":3},"constants":{"0":1,"\"A gaussian random double is \"":1,"10":1},"javaDoc":"","comments":"java util Random methods are non-static do need to construct Math END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"get":1,"format":2,"getInstance":1,"System.out.print":3,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"RomanNumberFormat":1,"Calendar":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":56,"StringLiteralExpr":1,"FieldAccessExpr":8,"CharLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":10},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] argv) {\n    RomanNumberFormat rf = new RomanNumberFormat();\n    Calendar cal = Calendar.getInstance();\n    int year = cal.get(Calendar.YEAR);\n    // If no arguments, just print the year.\n    if (argv.length == 0) {\n        System.out.println(rf.format(year));\n        return;\n    }\n    // Else a micro-formatter: replace \"-\" arg with year, else print.\n    for (int i = 0; i < argv.length; i++) {\n        if (argv[i].equals(\"-\"))\n            System.out.print(rf.format(year));\n        else\n            // e.g., \"Copyright\"\n            System.out.print(argv[i]);\n        System.out.print(' ');\n    }\n    System.out.println();\n}\n","name":"main","className":"RomanYear","variables":{"rf":3,"year":1,"Calendar":1,"i":5,"argv":2,"cal":2},"constants":{"0":2,"\"-\"":1,"' '":1},"javaDoc":"","comments":"If no arguments just print the year Else a micro-formatter: replace \"-\" arg with year else print e g \"Copyright\" ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"cos":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1,"BinaryExpr":3,"NameExpr":24,"StringLiteralExpr":3,"FieldAccessExpr":5,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    System.out.println(\"Java's PI is \" + Math.PI);\n    System.out.println(\"Java's e is \" + Math.E);\n    System.out.println(\"The cosine of 1.1418 is \" + Math.cos(1.1418));\n// END main\n}\n","name":"main","className":"Trig","variables":{"Math":1},"constants":{"\"The cosine of 1.1418 is \"":1,"1.1418":1,"\"Java's e is \"":1,"\"Java's PI is \"":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"data":1,"start":1,"end":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"TempConverter":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    TempConverter t = new TempConverter();\n    t.start();\n    t.data();\n    t.end();\n}\n","name":"main","className":"TempConverter","variables":{"t":4},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"protected void start() {\n}\n","name":"start","className":"TempConverter","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"DoubleLiteralExpr":1,"BinaryExpr":4,"NameExpr":7,"EnclosedExpr":2,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"protected void data() {\n    for (int i = -40; i <= 120; i += 10) {\n        float c = (i - 32) * (5f / 9);\n        print(i, c);\n    }\n}\n","name":"data","className":"TempConverter","variables":{"c":1,"i":4},"constants":{"5f":1,"9":1,"40":1,"120":1,"10":1,"32":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["float","float"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"protected void print(float f, float c) {\n    System.out.println(f + \" \" + c);\n}\n","name":"print","className":"TempConverter","variables":{"c":1,"f":1},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"protected void end() {\n}\n","name":"end","className":"TempConverter","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"equals":1,"System.out.println":8},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":4},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"DoubleLiteralExpr":3,"BinaryExpr":10,"NameExpr":66,"StringLiteralExpr":9,"FieldAccessExpr":11,"MethodCallExpr":10},"statements":{"IfStmt":4,"BlockStmt":3,"ExpressionStmt":12},"text":"public static void main(String[] argv) {\n    double da = 3 * .3333333333;\n    double db = 0.99999992857;\n    // Compare two numbers that are expected to be close.\n    if (da == db) {\n        System.out.println(\"Java considers \" + da + \"==\" + db);\n    // else compare with our own equals overload\n    } else if (equals(da, db, 0.0000001)) {\n        System.out.println(\"Equal within epsilon \" + EPSILON);\n    } else {\n        System.out.println(da + \" != \" + db);\n    }\n    System.out.println(\"NaN prints as \" + Double.NaN);\n    // Show that comparing two NaNs is not a good idea:\n    double nan1 = Double.NaN;\n    double nan2 = Double.NaN;\n    if (nan1 == nan2)\n        System.out.println(\"Comparing two NaNs incorrectly returns true.\");\n    else\n        System.out.println(\"Comparing two NaNs correctly reports false.\");\n    if (new Double(nan1).equals(new Double(nan2)))\n        System.out.println(\"Double(NaN).equals(NaN) correctly returns true.\");\n    else\n        System.out.println(\"Double(NaN).equals(NaN) incorrectly returns false.\");\n}\n","name":"main","className":"FloatCmp","variables":{"nan2":3,"nan1":3,"da":4,"db":4,"EPSILON":1},"constants":{"\"Java considers \"":1,"0.99999992857":1,"\"Equal within epsilon \"":1,"0.0000001":1,"\" != \"":1,".3333333333":1,"\"Comparing two NaNs correctly reports false.\"":1,"\"==\"":1,"\"Double(NaN).equals(NaN) incorrectly returns false.\"":1,"3":1,"\"Double(NaN).equals(NaN) correctly returns true.\"":1,"\"Comparing two NaNs incorrectly returns true.\"":1,"\"NaN prints as \"":1},"javaDoc":"","comments":"Compare two numbers that are expected to be close else compare with our own equals overload Show that comparing two NaNs is not a good idea: ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double","double"],"returnType":"boolean","methodCalls":{"abs":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"BooleanLiteralExpr":1,"NameExpr":8,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":2},"text":"/** Compare two doubles within a given epsilon */\npublic static boolean equals(double a, double b, double eps) {\n    if (a == b)\n        return true;\n    // If the difference is less than epsilon, treat as equal.\n    return Math.abs(a - b) < eps;\n}\n","name":"equals","className":"FloatCmp","variables":{"a":2,"b":2,"eps":1,"Math":1},"constants":{"true":1},"javaDoc":"Compare two doubles within a given epsilon","comments":"If the difference is less than epsilon treat as equal  Compare two doubles within a given epsilon ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Compare two doubles, using default epsilon */\npublic static boolean equals(double a, double b) {\n    return equals(a, b, EPSILON);\n}\n","name":"equals","className":"FloatCmp","variables":{},"constants":{},"javaDoc":"Compare two doubles using default epsilon","comments":" Compare two doubles, using default epsilon ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["char","int"],"returnType":"R2A","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":2},"text":"public R2A(char ch, int amount) {\n    super();\n    this.ch = ch;\n    this.amount = amount;\n}\n","name":"R2A","className":"R2A","variables":{"amount":1,"ch":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"String","methodCalls":{"format":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":3,"CastExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Format a given double as a Roman Numeral; just truncate to a\n     * long, and call format(long).\n     */\npublic String format(double n) {\n    return format((long) n);\n}\n","name":"format","className":"RomanNumberFormat","variables":{"n":1},"constants":{},"javaDoc":"Format a given double as a Roman Numeral; just truncate to a long and call format(long)","comments":" Format a given double as a Roman Numeral; just truncate to a\n     * long, and call format(long).\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["long"],"returnType":"String","methodCalls":{"valueOf":1,"format":1,"toString":1},"annotations":[],"exceptions":["NumberFormatException"],"concepts":["Recursion"],"types":{"StringBuffer":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":16,"StringLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Format a given long as a Roman Numeral. Just call the\n     * three-argument form.\n     */\npublic String format(long n) {\n    if (n <= 0 || n >= 4000)\n        throw new NumberFormatException(n + \" must be > 0 && < 4000\");\n    StringBuffer sb = new StringBuffer();\n    format(Integer.valueOf((int) n), sb, new FieldPosition(NumberFormat.INTEGER_FIELD));\n    return sb.toString();\n}\n","name":"format","className":"RomanNumberFormat","variables":{"Integer":1,"n":4,"sb":2},"constants":{"0":1,"\" must be > 0 && < 4000\"":1,"4000":1},"javaDoc":"Format a given long as a Roman Numeral Just call the three-argument form","comments":" Format a given long as a Roman Numeral. Just call the\n     * three-argument form.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","StringBuffer","FieldPosition"],"returnType":"StringBuffer","methodCalls":{"pop":1,"getField":1,"push":1,"append":8},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"int":7},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":21,"VariableDeclarationExpr":7,"ArrayAccessExpr":16,"BinaryExpr":14,"NameExpr":76,"StringLiteralExpr":2,"UnaryExpr":5,"InstanceOfExpr":1,"AssignExpr":1,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":2,"MethodCallExpr":12},"statements":{"ContinueStmt":1,"IfStmt":7,"BlockStmt":7,"ThrowStmt":2,"ForStmt":4,"ReturnStmt":1,"ExpressionStmt":13},"text":"/* Format the given Number as a Roman Numeral, returning the\n     * Stringbuffer (updated), and updating the FieldPosition.\n     * This method is the REAL FORMATTING ENGINE.\n     * Method signature is overkill, but required as a subclass of Format.\n     */\npublic StringBuffer format(Object on, StringBuffer sb, FieldPosition fp) {\n    if (!(on instanceof Number))\n        throw new IllegalArgumentException(on + \" must be a Number object\");\n    if (fp.getField() != NumberFormat.INTEGER_FIELD)\n        throw new IllegalArgumentException(fp + \" must be FieldPosition(NumberFormat.INTEGER_FIELD\");\n    // TODO: check in range.\n    int n = ((Number) on).intValue();\n    // First, put the digits on a tiny stack. Must be 4 digits.\n    for (int i = 0; i < 4; i++) {\n        int d = n % 10;\n        push(d);\n        // System.out.println(\"Pushed \" + d);\n        n = n / 10;\n    }\n    // Now pop and convert.\n    for (int i = 0; i < 4; i++) {\n        int ch = pop();\n        // System.out.println(\"Popped \" + ch);\n        if (ch == 0)\n            continue;\n        else if (ch <= 3) {\n            for (int k = 1; k <= ch; k++) // I\n            sb.append(A2R[i][1]);\n        } else if (ch == 4) {\n            // I\n            sb.append(A2R[i][1]);\n            // V\n            sb.append(A2R[i][2]);\n        } else if (ch == 5) {\n            // V\n            sb.append(A2R[i][2]);\n        } else if (ch <= 8) {\n            // V\n            sb.append(A2R[i][2]);\n            for (int k = 6; k <= ch; k++) // I\n            sb.append(A2R[i][1]);\n        } else {\n            // 9\n            sb.append(A2R[i][1]);\n            sb.append(A2R[i][3]);\n        }\n    }\n    // fp.setEndIndex(3);\n    return sb;\n}\n         // fp.setBeginIndex(0);\n\n","name":"format","className":"RomanNumberFormat","variables":{"A2R":8,"d":1,"ch":8,"i":14,"fp":2,"k":6,"n":4,"on":3,"sb":9},"constants":{"\" must be a Number object\"":1,"0":3,"1":5,"2":3,"3":2,"\" must be FieldPosition(NumberFormat.INTEGER_FIELD\"":1,"4":3,"5":1,"6":1,"8":1,"10":2},"javaDoc":"","comments":"fp setBeginIndex(0); TODO: check in range First put the digits on a tiny stack Must be 4 digits System out println(\"Pushed \" + d); Now pop and convert System out println(\"Popped \" + ch); I I V V V I 9 fp setEndIndex(3);  Format the given Number as a Roman Numeral, returning the\n     * Stringbuffer (updated), and updating the FieldPosition.\n     * This method is the REAL FORMATTING ENGINE.\n     * Method signature is overkill, but required as a subclass of Format.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","ParsePosition"],"returnType":"Object","methodCalls":{"toCharArray":1,"toUpperCase":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"R2A":1,"char":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":15,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BreakStmt":1,"BlockStmt":3,"ForeachStmt":2,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Parse a generic object, returning an Object */\npublic Object parseObject(String what, ParsePosition where) {\n    int n = 0;\n    for (char ch : what.toUpperCase().toCharArray()) {\n        for (R2A r : R2A) {\n            if (r.ch == ch) {\n                n += r.amount;\n                break;\n            }\n        }\n    }\n    return new Long(n);\n}\n","name":"parseObject","className":"RomanNumberFormat","variables":{"R2A":1,"r":1,"what":1,"ch":2,"n":3},"constants":{"0":1},"javaDoc":"Parse a generic object returning an Object","comments":" Parse a generic object, returning an Object ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":3,"UnaryExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/* Implement a toy stack */\nprotected void push(int n) {\n    stack[depth++] = n;\n}\n","name":"push","className":"RomanNumberFormat","variables":{"stack":1,"depth":1,"n":1},"constants":{},"javaDoc":"","comments":" Implement a toy stack ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":2,"UnaryExpr":1},"statements":{"ReturnStmt":1},"text":"/* Implement a toy stack */\nprotected int pop() {\n    return stack[--depth];\n}\n","name":"pop","className":"RomanNumberFormat","variables":{"stack":1,"depth":1},"constants":{},"javaDoc":"","comments":" Implement a toy stack ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":8,"System.out.println":12,"parseObject":1},"annotations":[],"exceptions":["NumberFormatException"],"concepts":["ExceptionHandling"],"types":{"RomanNumberFormat":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":8,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":10,"NameExpr":88,"StringLiteralExpr":13,"FieldAccessExpr":12,"MethodCallExpr":21},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":13},"text":"/** Simple test case */\npublic static void main(String[] argv) {\n    // BEGIN main\n    RomanNumberFormat nf = new RomanNumberFormat();\n    System.out.println(\"Test of \" + nf);\n    try {\n        System.out.println(\"0->\" + nf.format(0));\n        System.out.println(\"Failed to object to zero\");\n    } catch (NumberFormatException ex) {\n        System.out.println(\"Correctly rejected zero\");\n    }\n    System.out.println(\"42->\" + nf.format(42));\n    System.out.println(\"678->\" + nf.format(678));\n    System.out.println(\"1999->\" + nf.format(1999));\n    // Y2K anyone?\n    System.out.println(\"2000->\" + nf.format(2000));\n    // Y2K anyone?\n    System.out.println(\"2001->\" + nf.format(2001));\n    System.out.println(\"3999->\" + nf.format(3999));\n    // expect Exception\n    System.out.println(\"4000->\" + nf.format(4000));\n    // END main\n    // parsing not implemented.\n    System.out.println(\"XIV->\" + nf.parseObject(\"XIV\", null));\n}\n","name":"main","className":"RomanNumberDemo","variables":{"ex":1,"nf":11},"constants":{"\"Test of \"":1,"4000":1,"\"XIV->\"":1,"\"678->\"":1,"2001":1,"\"42->\"":1,"2000":1,"\"Correctly rejected zero\"":1,"\"3999->\"":1,"0":1,"\"2000->\"":1,"\"2001->\"":1,"null":1,"\"0->\"":1,"678":1,"\"XIV\"":1,"\"Failed to object to zero\"":1,"\"1999->\"":1,"\"4000->\"":1,"42":1,"3999":1,"1999":1},"javaDoc":"Simple test case","comments":"END main BEGIN main Y2K anyone? Y2K anyone? expect Exception parsing not implemented  Simple test case ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["T[]"],"returnType":"ArrayIterator","methodCalls":{"setData":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Construct an ArrayIterator object.\n     * @param d The array of objects to be iterated over.\n     */\npublic ArrayIterator(final T[] d) {\n    setData(d);\n}\n","name":"ArrayIterator","className":"ArrayIterator","variables":{},"constants":{},"javaDoc":"Construct an ArrayIterator object d The array of objects to be iterated over","comments":" Construct an ArrayIterator object.\n     * @param d The array of objects to be iterated over.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["T[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** (Re)set the data array to the given array, and reset the iterator.\n     * @param d The array of objects to be iterated over.\n     */\npublic void setData(final T[] d) {\n    this.data = d;\n    index = 0;\n}\n","name":"setData","className":"ArrayIterator","variables":{"d":1,"index":1},"constants":{"0":1},"javaDoc":"(Re)set the data array to the given array and reset the iterator d The array of objects to be iterated over","comments":" (Re)set the data array to the given array, and reset the iterator.\n     * @param d The array of objects to be iterated over.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Iterator<T>","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"// -------------------\n// Methods of Iterable\n// -------------------\n@Override\npublic Iterator<T> iterator() {\n    index = 0;\n    // since main class implements both interfaces\n    return this;\n}\n","name":"iterator","className":"ArrayIterator","variables":{"index":1},"constants":{"0":1},"javaDoc":"","comments":"since main class implements both interfaces ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n     * Tell if there are any more elements.\n     * @return true if not at the end, i.e., if next() will succeed.\n     * @return false if next() will throw an exception.\n     */\n@Override\npublic boolean hasNext() {\n    return (index < data.length);\n}\n","name":"hasNext","className":"ArrayIterator","variables":{"index":1},"constants":{},"javaDoc":"Tell if there are any more elements true if not at the end i e if next() will succeed false if next() will throw an exception","comments":" \n     * Tell if there are any more elements.\n     * @return true if not at the end, i.e., if next() will succeed.\n     * @return false if next() will throw an exception.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"T","methodCalls":{"hasNext":1},"annotations":["Override"],"exceptions":["NoSuchElementException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":7,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ThrowStmt":1},"text":"/** Returns the next element from the data */\n@Override\npublic T next() {\n    if (hasNext()) {\n        return data[index++];\n    }\n    throw new NoSuchElementException(\"only \" + data.length + \" elements\");\n}\n","name":"next","className":"ArrayIterator","variables":{"data":1,"index":1},"constants":{"\" elements\"":1,"\"only \"":1},"javaDoc":"Returns the next element from the data","comments":" Returns the next element from the data ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":["Override"],"exceptions":["UnsupportedOperationException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"StringLiteralExpr":1},"statements":{"ThrowStmt":1},"text":"/** Remove the object that next() just returned.\n     * An Iterator is not required to support this interface,\n     * and we don't.\n     * @throws UnsupportedOperationException unconditionally\n     */\n@Override\npublic void remove() {\n    throw new UnsupportedOperationException(\"This demo Iterator does not implement the remove method\");\n}\n","name":"remove","className":"ArrayIterator","variables":{},"constants":{"\"This demo Iterator does not implement the remove method\"":1},"javaDoc":"Remove the object that next() just returned An Iterator is not required to support this interface and we don't @throws UnsupportedOperationException unconditionally","comments":" Remove the object that next() just returned.\n     * An Iterator is not required to support this interface,\n     * and we don't.\n     * @throws UnsupportedOperationException unconditionally\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Retrieve the current option argument; UNIX variant spelling. */\npublic String optarg() {\n    return optarg;\n}\n","name":"optarg","className":"GetOpt","variables":{"optarg":1},"constants":{},"javaDoc":"Retrieve the current option argument; UNIX variant spelling","comments":" Retrieve the current option argument; UNIX variant spelling. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Retrieve the current option argument; Java variant spelling. */\npublic String optArg() {\n    return optarg;\n}\n","name":"optArg","className":"GetOpt","variables":{"optarg":1},"constants":{},"javaDoc":"Retrieve the current option argument; Java variant spelling","comments":" Retrieve the current option argument; Java variant spelling. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GetOptDesc[]"],"returnType":"GetOpt","methodCalls":{"clone":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Construct a GetOpt parser, given the option specifications\n     * in an array of GetOptDesc objects. This is the preferred constructor.\n     */\npublic GetOpt(final GetOptDesc[] opt) {\n    this.options = opt.clone();\n}\n","name":"GetOpt","className":"GetOpt","variables":{"opt":1},"constants":{},"javaDoc":"Construct a GetOpt parser given the option specifications in an array of GetOptDesc objects This is the preferred constructor","comments":" Construct a GetOpt parser, given the option specifications\n     * in an array of GetOptDesc objects. This is the preferred constructor.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"GetOpt","methodCalls":{"toCharArray":1,"println":1,"length":2,"charAt":3},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":["FinalVariables"],"types":{"boolean":1,"char":2,"int":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":7,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":16,"NameExpr":42,"StringLiteralExpr":7,"CharLiteralExpr":3,"UnaryExpr":4,"AssignExpr":3,"NullLiteralExpr":2,"BooleanLiteralExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":5,"BlockStmt":6,"ForeachStmt":1,"ThrowStmt":3,"ForStmt":1,"ExpressionStmt":9},"text":"/** Construct a GetOpt parser, storing the set of option characters.\n     * This is a legacy constructor for backward compatibility.\n     * That said, it is easier to use if you don't need long-name options,\n     * so it has not been and will not be marked \"deprecated\".\n     */\npublic GetOpt(final String patt) {\n    if (patt == null) {\n        throw new IllegalArgumentException(\"Pattern may not be null\");\n    }\n    if (patt.charAt(0) == ':') {\n        throw new IllegalArgumentException(\"Pattern incorrect, may not begin with ':'\");\n    }\n    // Pass One: just count the option letters in the pattern\n    int n = 0;\n    for (char ch : patt.toCharArray()) {\n        if (ch != ':')\n            ++n;\n    }\n    if (n == 0) {\n        throw new IllegalArgumentException(\"No option letters found in \" + patt);\n    }\n    // Pass Two: construct an array of GetOptDesc objects.\n    options = new GetOptDesc[n];\n    for (int i = 0, ix = 0; i < patt.length(); i++) {\n        final char c = patt.charAt(i);\n        boolean argTakesValue = false;\n        if (i < patt.length() - 1 && patt.charAt(i + 1) == ':') {\n            argTakesValue = true;\n            ++i;\n        }\n        Debug.println(\"getopt\", \"CONSTR: options[\" + ix + \"] = \" + c + \", \" + argTakesValue);\n        options[ix++] = new GetOptDesc(c, null, argTakesValue);\n    }\n}\n","name":"GetOpt","className":"GetOpt","variables":{"c":3,"patt":8,"ch":2,"options":2,"i":6,"argTakesValue":4,"n":4,"Debug":1,"ix":3},"constants":{"false":1,"\"] = \"":1,"\"No option letters found in \"":1,"0":5,"\"CONSTR: options[\"":1,"1":2,"null":2,"':'":3,"\"Pattern may not be null\"":1,"true":1,"\"Pattern incorrect, may not begin with ':'\"":1,"\"getopt\"":1,"\", \"":1},"javaDoc":"Construct a GetOpt parser storing the set of option characters This is a legacy constructor for backward compatibility That said it is easier to use if you don't need long-name options so it has not been and will not be marked \"deprecated\"","comments":"Pass One: just count the option letters in the pattern Pass Two: construct an array of GetOptDesc objects  Construct a GetOpt parser, storing the set of option characters.\n     * This is a legacy constructor for backward compatibility.\n     * That said, it is easier to use if you don't need long-name options,\n     * so it has not been and will not be marked \"deprecated\".\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/** Reset this GetOpt parser */\npublic void rewind() {\n    fileNameArguments = null;\n    done = false;\n    optind = 0;\n    optarg = null;\n}\n","name":"rewind","className":"GetOpt","variables":{"optind":1,"fileNameArguments":1,"optarg":1,"done":1},"constants":{"0":1,"null":2,"false":1},"javaDoc":"Reset this GetOpt parser","comments":" Reset this GetOpt parser ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"Map<String, String>","methodCalls":{"add":1,"println":1,"getopt":1,"toString":1,"put":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Map<String, String>":1,"HashMap":1,"char":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":33,"StringLiteralExpr":3,"FieldAccessExpr":1,"UnaryExpr":2,"AssignExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":2,"BlockStmt":4,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"/** \n     * Modern way of using GetOpt: call this once and get all options.\n     * <p>\n     * This parses the options, returns a Map whose keys are the found options.\n     * Normally followed by a call to getFilenameList().\n     * <br>Side effect: sets \"fileNameArguments\" to a new List\n     * @return a Map whose keys are Strings of length 1 (containing the char\n     * from the option that was matched) and whose value is a String\n     * containing the value, or null for a non-option argument.\n     */\npublic Map<String, String> parseArguments(String[] argv) {\n    Map<String, String> optionsValueMap = new HashMap<String, String>();\n    fileNameArguments = new ArrayList<String>();\n    for (int i = 0; i < argv.length; i++) {\n        // Cannot use foreach, need i\n        Debug.println(\"getopt\", \"parseArg: i=\" + i + \": arg \" + argv[i]);\n        // sets global \"optarg\"\n        char c = getopt(argv);\n        if (c == DONE) {\n            fileNameArguments.add(argv[i]);\n        } else {\n            optionsValueMap.put(Character.toString(c), optarg);\n            // If this arg takes an option, must arrange here to skip it.\n            if (optarg != null) {\n                i++;\n            }\n        }\n    }\n    return optionsValueMap;\n}\n","name":"parseArguments","className":"GetOpt","variables":{"optionsValueMap":3,"DONE":1,"c":2,"Character":1,"fileNameArguments":2,"i":7,"optarg":1,"argv":2,"Debug":1},"constants":{"0":1,"\"parseArg: i=\"":1,"null":1,"\": arg \"":1,"\"getopt\"":1},"javaDoc":"Modern way of using GetOpt: call this once and get all options <p> This parses the options returns a Map whose keys are the found options Normally followed by a call to getFilenameList() <br>Side effect: sets \"fileNameArguments\" to a new List a Map whose keys are Strings of length 1 (containing the char from the option that was matched) and whose value is a String containing the value or null for a non-option argument","comments":"Cannot use foreach need i sets global \"optarg\" If this arg takes an option must arrange here to skip it  \n     * Modern way of using GetOpt: call this once and get all options.\n     * <p>\n     * This parses the options, returns a Map whose keys are the found options.\n     * Normally followed by a call to getFilenameList().\n     * <br>Side effect: sets \"fileNameArguments\" to a new List\n     * @return a Map whose keys are Strings of length 1 (containing the char\n     * from the option that was matched) and whose value is a String\n     * containing the value, or null for a non-option argument.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":2,"StringLiteralExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"/** Get the list of filename-like arguments after options;\n     * only for use if you called parseArguments.\n     */\npublic List<String> getFilenameList() {\n    if (fileNameArguments == null) {\n        throw new IllegalArgumentException(\"Illegal call to getFilenameList() before parseOptions()\");\n    }\n    return fileNameArguments;\n}\n","name":"getFilenameList","className":"GetOpt","variables":{"fileNameArguments":2},"constants":{"\"Illegal call to getFilenameList() before parseOptions()\"":1,"null":1},"javaDoc":"Get the list of filename-like arguments after options; only for use if you called parseArguments","comments":" Get the list of filename-like arguments after options;\n     * only for use if you called parseArguments.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"char","methodCalls":{"println":1,"equals":1,"length":1,"getArgName":2,"charAt":1,"substring":1,"startsWith":1,"getArgLetter":3,"takesArgument":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"GetOptDesc":1,"String":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":15,"NameExpr":66,"StringLiteralExpr":7,"CharLiteralExpr":1,"UnaryExpr":5,"AssignExpr":4,"NullLiteralExpr":2,"BooleanLiteralExpr":2,"FieldAccessExpr":3,"EnclosedExpr":3,"MethodCallExpr":13},"statements":{"IfStmt":6,"BlockStmt":9,"ForeachStmt":1,"ReturnStmt":4,"ThrowStmt":1,"ExpressionStmt":9},"text":"/** The true heart of getopt, whether used old way or new way:\n     * returns one argument; call repeatedly until it returns DONE.\n     * Side-effect: sets globals optarg, optind\n     */\npublic char getopt(String argv[]) {\n    Debug.println(\"getopt\", \"optind=\" + optind + \", argv.length=\" + argv.length);\n    if (optind >= (argv.length) || !argv[optind].startsWith(\"-\")) {\n        done = true;\n    }\n    // Do not collapse this into the \"if\" above\n    if (done) {\n        return DONE;\n    }\n    optarg = null;\n    // XXX TODO - two-pass, 1st check long args, 2nd check for\n    // char, to allow advanced usage like \"-no outfile\" == \"-n -o outfile\".\n    // Pick off next command line argument, if it starts \"-\",\n    // then look it up in the list of valid args.\n    String thisArg = argv[optind];\n    if (thisArg.startsWith(\"-\")) {\n        for (GetOptDesc option : options) {\n            if ((thisArg.length() == 2 && option.getArgLetter() == thisArg.charAt(1)) || (option.getArgName() != null && option.getArgName().equals(thisArg.substring(1)))) {\n                // If it needs an option argument, get it.\n                if (option.takesArgument()) {\n                    if (optind < argv.length - 1) {\n                        optarg = argv[++optind];\n                    } else {\n                        throw new IllegalArgumentException(\"Option \" + option.getArgLetter() + \" needs value but found end of arg list\");\n                    }\n                }\n                ++optind;\n                return option.getArgLetter();\n            }\n        }\n        // Began with \"-\" but not matched, so must be error.\n        ++optind;\n        return '?';\n    } else {\n        // Found non-argument non-option word in argv: end of options.\n        ++optind;\n        done = true;\n        return DONE;\n    }\n}\n         // If we are finished (either now OR from before), bail.\n\n                                                                          // found it\n\n","name":"getopt","className":"GetOpt","variables":{"DONE":2,"optind":9,"options":1,"optarg":2,"argv":3,"done":3,"Debug":1,"thisArg":5,"option":7},"constants":{"1":3,"2":1,"\"Option \"":1,"\"optind=\"":1,"null":2,"\", argv.length=\"":1,"\"-\"":2,"true":2,"\" needs value but found end of arg list\"":1,"\"getopt\"":1,"'?'":1},"javaDoc":"The true heart of getopt whether used old way or new way: returns one argument; call repeatedly until it returns DONE Side-effect: sets globals optarg optind","comments":"If we are finished (either now OR from before) bail XXX TODO - two-pass 1st check long args 2nd check for char to allow advanced usage like \"-no outfile\" == \"-n -o outfile\" Pick off next command line argument if it starts \"-\" Do not collapse this into the \"if\" above then look it up in the list of valid args found it If it needs an option argument get it Began with \"-\" but not matched so must be error Found non-argument non-option word in argv: end of options  The true heart of getopt, whether used old way or new way:\n     * returns one argument; call repeatedly until it returns DONE.\n     * Side-effect: sets globals optarg, optind\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return optind, the index into args of the last option we looked at */\npublic int getOptInd() {\n    return optind;\n}\n","name":"getOptInd","className":"GetOpt","variables":{"optind":1},"constants":{},"javaDoc":"Return optind the index into args of the last option we looked at","comments":" Return optind, the index into args of the last option we looked at ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"MutableInteger","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public MutableInteger(int i) {\n    value = i;\n}\n","name":"MutableInteger","className":"MutableInteger","variables":{"i":1,"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MutableInteger","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MutableInteger() {\n    this(0);\n}\n","name":"MutableInteger","className":"MutableInteger","variables":{},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"UnaryExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int incr() {\n    value++;\n    return value;\n}\n","name":"incr","className":"MutableInteger","variables":{"value":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int incr(int amt) {\n    value += amt;\n    return value;\n}\n","name":"incr","className":"MutableInteger","variables":{"amt":1,"value":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"UnaryExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int decr() {\n    value--;\n    return value;\n}\n","name":"decr","className":"MutableInteger","variables":{"value":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int setValue(int i) {\n    value = i;\n    return value;\n}\n","name":"setValue","className":"MutableInteger","variables":{"i":1,"value":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getValue() {\n    return value;\n}\n","name":"getValue","className":"MutableInteger","variables":{"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return Integer.toString(value);\n}\n","name":"toString","className":"MutableInteger","variables":{"Integer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"String","methodCalls":{"toString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public static String toString(int val) {\n    return Integer.toString(val);\n}\n","name":"toString","className":"MutableInteger","variables":{"Integer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"int","methodCalls":{"parseInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public static int parseInt(String str) {\n    return Integer.parseInt(str);\n}\n","name":"parseInt","className":"MutableInteger","variables":{"Integer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"int","methodCalls":{"run":1},"annotations":[],"exceptions":["IOException"],"concepts":["Recursion"],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Run the command given as a String, printing its output to System.out */\npublic static int run(String cmd) throws IOException {\n    return run(cmd, new OutputStreamWriter(System.out));\n}\n","name":"run","className":"ExecAndPrint","variables":{},"constants":{},"javaDoc":"Run the command given as a String printing its output to System out","comments":" Run the command given as a String, printing its output to System.out ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Writer"],"returnType":"int","methodCalls":{"copyFile":1,"exitValue":1,"getInputStream":1,"waitFor":1,"exec":1},"annotations":[],"exceptions":["IOException","InterruptedException"],"concepts":["ExceptionHandling"],"types":{"Process":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":17,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":3},"text":"/** Run the command given as a String, print its output to \"out\" */\npublic static int run(String cmd, Writer out) throws IOException {\n    Process p = r.exec(cmd);\n    FileIO.copyFile(new InputStreamReader(p.getInputStream()), out, true);\n    try {\n        // wait for process to complete\n        p.waitFor();\n    } catch (InterruptedException e) {\n        return -1;\n    }\n    return p.exitValue();\n}\n","name":"run","className":"ExecAndPrint","variables":{"p":4,"r":1,"e":1,"FileIO":1},"constants":{"1":1,"true":1},"javaDoc":"Run the command given as a String print its output to \"out\"","comments":"wait for process to complete  Run the command given as a String, print its output to \"out\" ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"int","methodCalls":{"run":1},"annotations":[],"exceptions":["IOException"],"concepts":["Recursion"],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Run the command given as a String[], print its output to System.out */\npublic static int run(String[] cmd) throws IOException {\n    return run(cmd, new OutputStreamWriter(System.out));\n}\n","name":"run","className":"ExecAndPrint","variables":{},"constants":{},"javaDoc":"Run the command given as a String[] print its output to System out","comments":" Run the command given as a String[], print its output to System.out ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]","Writer"],"returnType":"int","methodCalls":{"copyFile":1,"exitValue":1,"getInputStream":1,"waitFor":1,"exec":1},"annotations":[],"exceptions":["IOException","InterruptedException"],"concepts":["ExceptionHandling"],"types":{"Process":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":17,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":3},"text":"/** Run the command given as a String[], print its output to \"out\" */\npublic static int run(String[] cmd, Writer out) throws IOException {\n    Process p = r.exec(cmd);\n    FileIO.copyFile(new InputStreamReader(p.getInputStream()), out, true);\n    try {\n        // wait for process to complete\n        p.waitFor();\n    } catch (InterruptedException e) {\n        return -1;\n    }\n    return p.exitValue();\n}\n","name":"run","className":"ExecAndPrint","variables":{"p":4,"r":1,"e":1,"FileIO":1},"constants":{"1":1,"true":1},"javaDoc":"Run the command given as a String[] print its output to \"out\"","comments":"wait for process to complete  Run the command given as a String[], print its output to \"out\" ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{"getProperty":1,"startsWith":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":14,"StringLiteralExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":3,"BlockStmt":3,"ReturnStmt":4,"ExpressionStmt":1},"text":"/** Return the name of the \"Null Device\" on platforms which support it,\n     * or \"jnk\" (to create an obviously well-named temp file) otherwise.\n     */\npublic static String getDevNull() {\n    if (new File(UNIX_NULL_DEV).exists()) {\n        // <1>\n        return UNIX_NULL_DEV;\n    }\n    // <2>\n    String sys = System.getProperty(\"os.name\");\n    if (sys == null) {\n        // <3>\n        return FAKE_NULL_DEV;\n    }\n    if (sys.startsWith(\"Windows\")) {\n        // <4>\n        return WINDOWS_NULL_DEV;\n    }\n    // <5>\n    return FAKE_NULL_DEV;\n}\n","name":"getDevNull","className":"SysDep","variables":{"UNIX_NULL_DEV":2,"WINDOWS_NULL_DEV":1,"sys":3,"System":1,"FAKE_NULL_DEV":2},"constants":{"null":1,"\"Windows\"":1,"\"os.name\"":1},"javaDoc":"Return the name of the \"Null Device\" on platforms which support it or \"jnk\" (to create an obviously well-named temp file) otherwise","comments":"<1> <2> <3> <4> <5>  Return the name of the \"Null Device\" on platforms which support it,\n     * or \"jnk\" (to create an obviously well-named temp file) otherwise.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"NameExpr":11,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public static void main(final String[] argv) throws IOException {\n    System.out.println(CSV_PATTERN);\n    new CSVRE().process(new BufferedReader(new InputStreamReader(System.in)));\n}\n","name":"main","className":"CSVRE","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["BufferedReader"],"returnType":"void","methodCalls":{"size":1,"parse":1,"readLine":1,"System.out.print":1,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables"],"types":{"String":2,"List<String>":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":6,"NameExpr":33,"StringLiteralExpr":5,"FieldAccessExpr":4,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":7},"statements":{"WhileStmt":1,"BlockStmt":2,"ForeachStmt":1,"ExpressionStmt":6},"text":"/** Process one file. Delegates to parse() a line at a time */\npublic void process(final BufferedReader input) throws IOException {\n    String line;\n    // For each line...\n    while ((line = input.readLine()) != null) {\n        System.out.println(\"line = `\" + line + \"'\");\n        final List<String> list = parse(line);\n        System.out.println(\"Found \" + list.size() + \" items.\");\n        for (String str : list) {\n            System.out.print(str + \",\");\n        }\n        System.out.println();\n    }\n}\n","name":"process","className":"CSVRE","variables":{"str":2,"input":1,"line":3,"list":3},"constants":{"null":1,"\"Found \"":1,"\",\"":1,"\" items.\"":1,"\"'\"":1,"\"line = `\"":1},"javaDoc":"Process one file Delegates to parse() a line at a time","comments":"For each line  Process one file. Delegates to parse() a line at a time ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"List<String>","methodCalls":{"add":1,"find":1,"endsWith":2,"length":3,"matcher":1,"substring":2,"group":1,"startsWith":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":["FinalVariables","PolyMorphism"],"types":{"Matcher":1,"ArrayList":1,"String":1,"List<String>":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":44,"StringLiteralExpr":5,"UnaryExpr":1,"MethodCallExpr":12,"AssignExpr":3},"statements":{"IfStmt":5,"WhileStmt":1,"BreakStmt":1,"BlockStmt":6,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"/** Parse one line.\n     * @return List of Strings, minus their double quotes\n     */\npublic List<String> parse(final String line) {\n    final List<String> list = new ArrayList<>();\n    final Matcher m = csvRE.matcher(line);\n    // For each field\n    while (m.find()) {\n        String match = m.group();\n        if (match == null) {\n            break;\n        }\n        if (match.endsWith(\",\")) {\n            // trim trailing ,\n            match = match.substring(0, match.length() - 1);\n        }\n        if (match.startsWith(\"\\\"\")) {\n            // must also end with \\\"\n            if (!match.endsWith(\"\\\"\")) {\n                throw new IllegalArgumentException(\"Quoted column missing end quote: \" + line);\n            }\n            match = match.substring(1, match.length() - 1);\n        }\n        if (match.length() == 0) {\n            match = \"\";\n        }\n        list.add(match);\n    }\n    return list;\n}\n","name":"parse","className":"CSVRE","variables":{"csvRE":1,"line":1,"match":13,"list":3,"m":3},"constants":{"0":2,"\"\"":1,"1":3,"null":1,"\"Quoted column missing end quote: \"":1,"\",\"":1,"\"\\\"\"":2},"javaDoc":"Parse one line List of Strings minus their double quotes","comments":"For each field trim trailing must also end with \\\"  Parse one line.\n     * @return List of Strings, minus their double quotes\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"CSVImport","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a CSV parser, with the default separator (`,'). */\npublic CSVImport() {\n    this(DEFAULT_SEP);\n}\n","name":"CSVImport","className":"CSVImport","variables":{"DEFAULT_SEP":1},"constants":{},"javaDoc":"Construct a CSV parser with the default separator (` ')","comments":" Construct a CSV parser, with the default separator (`,'). ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char"],"returnType":"CSVImport","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Construct a CSV parser with a given separator.\n     * @param sep The single char for the separator (not a list of\n     * separator characters)\n     */\npublic CSVImport(char sep) {\n    fieldSep = sep;\n}\n","name":"CSVImport","className":"CSVImport","variables":{"fieldSep":1,"sep":1},"constants":{},"javaDoc":"Construct a CSV parser with a given separator sep The single char for the separator (not a list of separator characters)","comments":" Construct a CSV parser with a given separator.\n     * @param sep The single char for the separator (not a list of\n     * separator characters)\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"List<String>","methodCalls":{"add":2,"advPlain":1,"setLength":1,"println":1,"clear":1,"length":3,"toString":2,"advQuoted":1,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":52,"StringLiteralExpr":1,"CharLiteralExpr":1,"UnaryExpr":2,"MethodCallExpr":13,"AssignExpr":2},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":10,"DoStmt":1},"text":"/** parse: break the input String into fields\n     * @return java.util.Iterator containing each field\n     * from the original as a String, in order.\n     */\npublic List<String> parse(String line) {\n    StringBuffer sb = new StringBuffer();\n    // recycle to initial state\n    list.clear();\n    int i = 0;\n    if (line.length() == 0) {\n        list.add(line);\n        return list;\n    }\n    do {\n        sb.setLength(0);\n        if (i < line.length() && line.charAt(i) == '\"')\n            // skip quote\n            i = advQuoted(line, sb, ++i);\n        else\n            i = advPlain(line, sb, i);\n        list.add(sb.toString());\n        Debug.println(\"csv\", sb.toString());\n        i++;\n    } while (i < line.length());\n    return list;\n}\n","name":"parse","className":"CSVImport","variables":{"line":4,"i":7,"list":5,"Debug":1,"sb":4},"constants":{"0":3,"\"csv\"":1,"'\"'":1},"javaDoc":"parse: break the input String into fields java util Iterator containing each field from the original as a String in order","comments":"recycle to initial state skip quote  parse: break the input String into fields\n     * @return java.util.Iterator containing each field\n     * from the original as a String, in order.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","StringBuffer","int"],"returnType":"int","methodCalls":{"length":1,"charAt":5,"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":13,"NameExpr":39,"CharLiteralExpr":3,"UnaryExpr":3,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":4,"BreakStmt":2,"BlockStmt":5,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** advQuoted: quoted field; return index of next separator */\nprotected int advQuoted(String s, StringBuffer sb, int i) {\n    int j;\n    int len = s.length();\n    for (j = i; j < len; j++) {\n        if (s.charAt(j) == '\"' && j + 1 < len) {\n            if (s.charAt(j + 1) == '\"') {\n                // skip escape char\n                j++;\n            } else if (s.charAt(j + 1) == fieldSep) {\n                //next delimeter\n                // skip end quotes\n                j++;\n                break;\n            }\n        } else if (s.charAt(j) == '\"' && j + 1 == len) {\n            //done\n            break;\n        }\n        // regular character.\n        sb.append(s.charAt(j));\n    }\n    return j;\n}\n                                                            // end quote @ line end\n\n","name":"advQuoted","className":"CSVImport","variables":{"s":6,"len":4,"fieldSep":1,"i":1,"j":11,"sb":1},"constants":{"1":4,"'\"'":3},"javaDoc":"advQuoted: quoted field; return index of next separator","comments":"skip escape char next delimeter skip end quotes end quote @ line end done regular character  advQuoted: quoted field; return index of next separator ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","StringBuffer","int"],"returnType":"int","methodCalls":{"println":1,"length":1,"indexOf":1,"append":2,"substring":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":31,"StringLiteralExpr":3,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":5},"text":"/** advPlain: unquoted field; return index of next separator */\nprotected int advPlain(String s, StringBuffer sb, int i) {\n    int j;\n    // look for separator\n    j = s.indexOf(fieldSep, i);\n    Debug.println(\"csv\", \"i = \" + i + \", j = \" + j);\n    if (j == -1) {\n        // none found\n        sb.append(s.substring(i));\n        return s.length();\n    } else {\n        sb.append(s.substring(i, j));\n        return j;\n    }\n}\n","name":"advPlain","className":"CSVImport","variables":{"s":4,"i":1,"j":5,"Debug":1,"sb":2},"constants":{"1":1,"\"csv\"":1,"\", j = \"":1,"\"i = \"":1},"javaDoc":"advPlain: unquoted field; return index of next separator","comments":"look for separator none found  advPlain: unquoted field; return index of next separator ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get from */\npublic String getFrom() {\n    return from;\n}\n","name":"getFrom","className":"Mailer","variables":{"from":1},"constants":{},"javaDoc":"Get from","comments":" Get from ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set from */\npublic void setFrom(String fm) {\n    from = fm;\n}\n","name":"setFrom","className":"Mailer","variables":{"fm":1,"from":1},"constants":{},"javaDoc":"Set from","comments":" Set from ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get subject */\npublic String getSubject() {\n    return subject;\n}\n","name":"getSubject","className":"Mailer","variables":{"subject":1},"constants":{},"javaDoc":"Get subject","comments":" Get subject ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set subject */\npublic void setSubject(String subj) {\n    subject = subj;\n}\n","name":"setSubject","className":"Mailer","variables":{"subject":1,"subj":1},"constants":{},"javaDoc":"Set subject","comments":" Set subject ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get tolist, as an array of Strings */\npublic List<String> getToList() {\n    return toList;\n}\n","name":"getToList","className":"Mailer","variables":{"toList":1},"constants":{},"javaDoc":"Get tolist as an array of Strings","comments":" Get tolist, as an array of Strings ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ArrayList<String>"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set to list to an ArrayList of Strings */\npublic void setToList(ArrayList<String> to) {\n    toList = to;\n}\n","name":"setToList","className":"Mailer","variables":{"toList":1,"to":1},"constants":{},"javaDoc":"Set to list to an ArrayList of Strings","comments":" Set to list to an ArrayList of Strings ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"split":1,"asList":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"StringLiteralExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"/** Set to as a string like \"tom, mary, robin@host\". Loses any\n     * previously set values. */\npublic void setToList(String s) {\n    toList = Arrays.asList(s.split(\",\\\\s+\"));\n}\n","name":"setToList","className":"Mailer","variables":{"s":1,"toList":1,"Arrays":1},"constants":{"\",\\\\s+\"":1},"javaDoc":"Set to as a string like \"tom mary robin@host\" Loses any previously set values","comments":" Set to as a string like \"tom, mary, robin@host\". Loses any\n     * previously set values. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Add one \"to\" recipient */\npublic void addTo(String to) {\n    toList.add(to);\n}\n","name":"addTo","className":"Mailer","variables":{"toList":1},"constants":{},"javaDoc":"Add one \"to\" recipient","comments":" Add one \"to\" recipient ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get cclist, as an array of Strings */\npublic List<String> getCcList() {\n    return ccList;\n}\n","name":"getCcList","className":"Mailer","variables":{"ccList":1},"constants":{},"javaDoc":"Get cclist as an array of Strings","comments":" Get cclist, as an array of Strings ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ArrayList<String>"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set cc list to an ArrayList of Strings */\npublic void setCcList(ArrayList<String> cc) {\n    ccList = cc;\n}\n","name":"setCcList","className":"Mailer","variables":{"cc":1,"ccList":1},"constants":{},"javaDoc":"Set cc list to an ArrayList of Strings","comments":" Set cc list to an ArrayList of Strings ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"split":1,"asList":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"StringLiteralExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"/** Set cc as a string like \"tom, mary, robin@host\". Loses any\n     * previously set values. */\npublic void setCcList(String s) {\n    ccList = Arrays.asList(s.split(\",\\\\s+\"));\n}\n","name":"setCcList","className":"Mailer","variables":{"s":1,"ccList":1,"Arrays":1},"constants":{"\",\\\\s+\"":1},"javaDoc":"Set cc as a string like \"tom mary robin@host\" Loses any previously set values","comments":" Set cc as a string like \"tom, mary, robin@host\". Loses any\n     * previously set values. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Add one \"cc\" recipient */\npublic void addCc(String cc) {\n    ccList.add(cc);\n}\n","name":"addCc","className":"Mailer","variables":{"ccList":1},"constants":{},"javaDoc":"Add one \"cc\" recipient","comments":" Add one \"cc\" recipient ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get bcclist, as an array of Strings */\npublic List<String> getBccList() {\n    return bccList;\n}\n","name":"getBccList","className":"Mailer","variables":{"bccList":1},"constants":{},"javaDoc":"Get bcclist as an array of Strings","comments":" Get bcclist, as an array of Strings ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["List<String>"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set bcc list to an ArrayList of Strings */\npublic void setBccList(List<String> bcc) {\n    bccList = bcc;\n}\n","name":"setBccList","className":"Mailer","variables":{"bcc":1,"bccList":1},"constants":{},"javaDoc":"Set bcc list to an ArrayList of Strings","comments":" Set bcc list to an ArrayList of Strings ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"split":1,"asList":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"StringLiteralExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"/** Set bcc as a string like \"tom, mary, robin@host\". Loses any\n     * previously set values. */\npublic void setBccList(String s) {\n    bccList = Arrays.asList(s.split(\",\\\\s+\"));\n}\n","name":"setBccList","className":"Mailer","variables":{"s":1,"bccList":1,"Arrays":1},"constants":{"\",\\\\s+\"":1},"javaDoc":"Set bcc as a string like \"tom mary robin@host\" Loses any previously set values","comments":" Set bcc as a string like \"tom, mary, robin@host\". Loses any\n     * previously set values. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Add one \"bcc\" recipient */\npublic void addBcc(String bcc) {\n    bccList.add(bcc);\n}\n","name":"addBcc","className":"Mailer","variables":{"bccList":1},"constants":{},"javaDoc":"Add one \"bcc\" recipient","comments":" Add one \"bcc\" recipient ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get message */\npublic String getBody() {\n    return body;\n}\n","name":"getBody","className":"Mailer","variables":{"body":1},"constants":{},"javaDoc":"Get message","comments":" Get message ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set message */\npublic void setBody(String text) {\n    body = text;\n}\n","name":"setBody","className":"Mailer","variables":{"text":1,"body":1},"constants":{},"javaDoc":"Set message","comments":" Set message ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get verbose */\npublic boolean isVerbose() {\n    return verbose;\n}\n","name":"isVerbose","className":"Mailer","variables":{"verbose":1},"constants":{},"javaDoc":"Get verbose","comments":" Get verbose ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set verbose */\npublic void setVerbose(boolean v) {\n    verbose = v;\n}\n","name":"setVerbose","className":"Mailer","variables":{"v":1,"verbose":1},"constants":{},"javaDoc":"Set verbose","comments":" Set verbose ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"size":1,"length":4,"System.err.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":4,"IntegerLiteralExpr":5,"BinaryExpr":13,"BooleanLiteralExpr":6,"NameExpr":44,"StringLiteralExpr":5,"FieldAccessExpr":5,"MethodCallExpr":10},"statements":{"IfStmt":5,"BlockStmt":5,"ReturnStmt":6,"ExpressionStmt":5},"text":"/** Check if all required fields have been set before sending.\n     * Normally called before doSend; called by doSend for verification.\n     */\npublic boolean isComplete() {\n    if (from == null || from.length() == 0) {\n        System.err.println(\"doSend: no FROM\");\n        return false;\n    }\n    if (subject == null || subject.length() == 0) {\n        System.err.println(\"doSend: no SUBJECT\");\n        return false;\n    }\n    if (toList.size() == 0) {\n        System.err.println(\"doSend: no recipients\");\n        return false;\n    }\n    if (body == null || body.length() == 0) {\n        System.err.println(\"doSend: no body\");\n        return false;\n    }\n    if (mailHost == null || mailHost.length() == 0) {\n        System.err.println(\"doSend: no server host\");\n        return false;\n    }\n    return true;\n}\n","name":"isComplete","className":"Mailer","variables":{"mailHost":2,"subject":2,"from":2,"toList":1,"body":2},"constants":{"0":5,"\"doSend: no FROM\"":1,"\"doSend: no body\"":1,"null":4,"\"doSend: no SUBJECT\"":1,"false":5,"true":1,"\"doSend: no recipients\"":1,"\"doSend: no server host\"":1},"javaDoc":"Check if all required fields have been set before sending Normally called before doSend; called by doSend for verification","comments":" Check if all required fields have been set before sending.\n     * Normally called before doSend; called by doSend for verification.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setServer(String s) {\n    mailHost = s;\n}\n","name":"setServer","className":"Mailer","variables":{"mailHost":1,"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getDefaultInstance":1,"setSubject":1,"size":3,"setFrom":1,"get":3,"setDebug":1,"setRecipients":3,"send":1,"put":1,"isComplete":1,"setText":1},"annotations":[],"exceptions":["MessagingException","IllegalArgumentException"],"concepts":["FinalVariables","PolyMorphism","Synchronization"],"types":{"Message":1,"MimeMessage":1,"InternetAddress[]":1,"Properties":1,"int":3},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":3,"VariableDeclarationExpr":6,"ArrayAccessExpr":3,"BinaryExpr":4,"NameExpr":105,"StringLiteralExpr":2,"UnaryExpr":4,"AssignExpr":7,"NullLiteralExpr":2,"BooleanLiteralExpr":1,"CastExpr":3,"FieldAccessExpr":9,"ArrayCreationExpr":3,"MethodCallExpr":17},"statements":{"IfStmt":3,"BlockStmt":1,"ThrowStmt":1,"ForStmt":3,"ExpressionStmt":19},"text":"/** Send the message.\n     */\npublic synchronized void doSend() throws MessagingException {\n    if (!isComplete())\n        throw new IllegalArgumentException(\"doSend called before message was complete\");\n    /** Properties object used to pass props into the MAIL API */\n    Properties props = new Properties();\n    props.put(\"mail.smtp.host\", mailHost);\n    // Create the Session object\n    if (session == null) {\n        session = Session.getDefaultInstance(props, null);\n        if (verbose)\n            // Verbose!\n            session.setDebug(true);\n    }\n    // create a message\n    final Message mesg = new MimeMessage(session);\n    InternetAddress[] addresses;\n    // TO Address list\n    addresses = new InternetAddress[toList.size()];\n    for (int i = 0; i < addresses.length; i++) addresses[i] = new InternetAddress((String) toList.get(i));\n    mesg.setRecipients(Message.RecipientType.TO, addresses);\n    // From Address\n    mesg.setFrom(new InternetAddress(from));\n    // CC Address list\n    addresses = new InternetAddress[ccList.size()];\n    for (int i = 0; i < addresses.length; i++) addresses[i] = new InternetAddress((String) ccList.get(i));\n    mesg.setRecipients(Message.RecipientType.CC, addresses);\n    // BCC Address list\n    addresses = new InternetAddress[bccList.size()];\n    for (int i = 0; i < addresses.length; i++) addresses[i] = new InternetAddress((String) bccList.get(i));\n    mesg.setRecipients(Message.RecipientType.BCC, addresses);\n    // The Subject\n    mesg.setSubject(subject);\n    // Now the message body.\n    mesg.setText(body);\n    Transport.send(mesg);\n}\n","name":"doSend","className":"Mailer","variables":{"addresses":7,"session":4,"i":12,"ccList":2,"bccList":2,"from":1,"toList":2,"Transport":1,"props":2,"Session":1,"verbose":1,"mesg":7},"constants":{"0":3,"\"doSend called before message was complete\"":1,"null":2,"true":1,"\"mail.smtp.host\"":1},"javaDoc":"Send the message","comments":"Properties object used to pass props into the MAIL API Create the Session object Verbose! create a message TO Address list From Address CC Address list BCC Address list The Subject Now the message body  Send the message.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String","String","String","String"],"returnType":"void","methodCalls":{"setSubject":1,"setFrom":1,"addTo":1,"setServer":1,"doSend":1,"setBody":1},"annotations":[],"exceptions":["MessagingException"],"concepts":[],"types":{"Mailer":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":23,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"/** Convenience method that does it all with one call.\n     * @param mailhost - SMTP server host\n     * @param recipient - domain address of email (user@host.domain)\n     * @param sender - your email address\n     * @param subject - the subject line\n     * @param message - the entire message body as a String with embedded \\n's\n     */\npublic static void send(String mailhost, String recipient, String sender, String subject, String message) throws MessagingException {\n    Mailer m = new Mailer();\n    m.setServer(mailhost);\n    m.addTo(recipient);\n    m.setFrom(sender);\n    m.setSubject(subject);\n    m.setBody(message);\n    m.doSend();\n}\n","name":"send","className":"Mailer","variables":{"m":7},"constants":{},"javaDoc":"Convenience method that does it all with one call mailhost - SMTP server host recipient - domain address of email (user@host domain) sender - your email address subject - the subject line message - the entire message body as a String with embedded \\n's","comments":" Convenience method that does it all with one call.\n     * @param mailhost - SMTP server host\n     * @param recipient - domain address of email (user@host.domain)\n     * @param sender - your email address\n     * @param subject - the subject line\n     * @param message - the entire message body as a String with embedded \\n's\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":2,"process":2,"getOptInd":1,"getopt":1,"optarg":2,"System.err.println":7,"readLine":1},"annotations":[],"exceptions":["IOException","Exception","PatternSyntaxException"],"concepts":["ExceptionHandling"],"types":{"GetOpt":1,"JGrep":1,"char":1,"BufferedReader":1,"String":1,"int":2},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":6,"VariableDeclarationExpr":7,"ArrayAccessExpr":2,"BinaryExpr":9,"NameExpr":112,"StringLiteralExpr":5,"CharLiteralExpr":11,"UnaryExpr":3,"AssignExpr":15,"NullLiteralExpr":4,"BooleanLiteralExpr":10,"FieldAccessExpr":12,"EnclosedExpr":1,"MethodCallExpr":16},"statements":{"SwitchStmt":1,"IfStmt":6,"WhileStmt":1,"BreakStmt":10,"BlockStmt":12,"TryStmt":3,"SwitchEntryStmt":11,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":30},"text":"/** Construct a Grep object for the pattern, and run it\n     * on all input files listed in argv.\n     * Be aware that a few of the command-line options are not\n     * acted upon in this version - left as an exercise for the reader!\n     */\npublic static void main(String[] argv) {\n    if (argv.length < 1) {\n        System.err.println(USAGE);\n        System.exit(1);\n    }\n    String patt = null;\n    GetOpt go = new GetOpt(\"cf:hilnrRsv\");\n    char c;\n    while ((c = go.getopt(argv)) != 0) {\n        switch(c) {\n            case 'c':\n                countOnly = true;\n                break;\n            case 'f':\n                /* External file contains the pattern */\n                try (BufferedReader b = new BufferedReader(new FileReader(go.optarg()))) {\n                    patt = b.readLine();\n                } catch (IOException e) {\n                    System.err.println(\"Can't read pattern file \" + go.optarg());\n                    System.exit(1);\n                }\n                break;\n            case 'h':\n                dontPrintFileName = true;\n                break;\n            case 'i':\n                ignoreCase = true;\n                break;\n            case 'l':\n                listOnly = true;\n                break;\n            case 'n':\n                numbered = true;\n                break;\n            case 'r':\n            case 'R':\n                recursive = true;\n                break;\n            case 's':\n                silent = true;\n                break;\n            case 'v':\n                inVert = true;\n                break;\n            case '?':\n                System.err.println(\"Getopts was not happy!\");\n                System.err.println(USAGE);\n                break;\n        }\n    }\n    int ix = go.getOptInd();\n    if (patt == null)\n        patt = argv[ix++];\n    JGrep prog = null;\n    try {\n        prog = new JGrep(patt);\n    } catch (PatternSyntaxException ex) {\n        System.err.println(\"RE Syntax error in \" + patt);\n        return;\n    }\n    if (argv.length == ix) {\n        // Don't print filenames if stdin\n        dontPrintFileName = true;\n        if (recursive) {\n            System.err.println(\"Warning: recursive search of stdin!\");\n        }\n        prog.process(new InputStreamReader(System.in), null);\n    } else {\n        if (!dontPrintFileName)\n            // Nor if only one file.\n            dontPrintFileName = ix == argv.length - 1;\n        if (recursive)\n            // unless a directory!\n            dontPrintFileName = false;\n        for (int i = ix; i < argv.length; i++) {\n            // note starting index\n            try {\n                prog.process(new File(argv[i]));\n            } catch (Exception e) {\n                System.err.println(e);\n            }\n        }\n    }\n}\n","name":"main","className":"JGrep","variables":{"b":2,"silent":1,"c":3,"patt":6,"e":2,"numbered":1,"go":5,"i":4,"argv":2,"System":2,"recursive":3,"prog":4,"dontPrintFileName":5,"ix":5,"ex":1,"countOnly":1,"inVert":1,"ignoreCase":1,"listOnly":1},"constants":{"'n'":1,"'l'":1,"\"Can't read pattern file \"":1,"'i'":1,"'h'":1,"'f'":1,"false":1,"'c'":1,"\"cf:hilnrRsv\"":1,"'?'":1,"0":1,"1":4,"null":4,"\"RE Syntax error in \"":1,"true":9,"'v'":1,"'s'":1,"'r'":1,"'R'":1,"\"Warning: recursive search of stdin!\"":1,"\"Getopts was not happy!\"":1},"javaDoc":"Construct a Grep object for the pattern and run it on all input files listed in argv Be aware that a few of the command-line options are not acted upon in this version - left as an exercise for the reader!","comments":"External file contains the pattern Don't print filenames if stdin Nor if only one file unless a directory! note starting index  Construct a Grep object for the pattern, and run it\n     * on all input files listed in argv.\n     * Be aware that a few of the command-line options are not\n     * acted upon in this version - left as an exercise for the reader!\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"JGrep","methodCalls":{"System.err.printf":1,"compile":1,"matcher":1},"annotations":[],"exceptions":["PatternSyntaxException"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":24,"StringLiteralExpr":2,"FieldAccessExpr":3,"ConditionalExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/** Construct a JGrep object.\n     * @param patt The pattern to look for\n     * @param args the command-line options.\n     */\npublic JGrep(String patt) throws PatternSyntaxException {\n    if (debug) {\n        System.err.printf(\"JGrep.JGrep(%s)%n\", patt);\n    }\n    // compile the regular expression\n    int caseMode = ignoreCase ? Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE : 0;\n    pattern = Pattern.compile(patt, caseMode);\n    matcher = pattern.matcher(\"\");\n}\n","name":"JGrep","className":"JGrep","variables":{"caseMode":1,"Pattern":1,"debug":1,"ignoreCase":1,"pattern":2,"matcher":1},"constants":{"0":1,"\"\"":1,"\"JGrep.JGrep(%s)%n\"":1},"javaDoc":"Construct a JGrep object patt The pattern to look for args the command-line options","comments":"compile the regular expression  Construct a JGrep object.\n     * @param patt The pattern to look for\n     * @param args the command-line options.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["File"],"returnType":"void","methodCalls":{"process":2,"isFile":1,"canRead":1,"getAbsolutePath":4,"exists":1,"System.err.println":3,"listFiles":1,"isDirectory":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["Recursion"],"types":{"File":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":49,"StringLiteralExpr":3,"FieldAccessExpr":3,"UnaryExpr":3,"MethodCallExpr":14},"statements":{"IfStmt":4,"BlockStmt":5,"ForeachStmt":1,"ReturnStmt":4,"ExpressionStmt":5},"text":"/** Process one command line argument (file or directory)\n     * @throws FileNotFoundException \n     */\npublic void process(File file) throws FileNotFoundException {\n    if (!file.exists() || !file.canRead()) {\n        System.err.println(\"ERROR: can't read file \" + file.getAbsolutePath());\n        return;\n    }\n    if (file.isFile()) {\n        process(new BufferedReader(new FileReader(file)), file.getAbsolutePath());\n        return;\n    }\n    if (file.isDirectory()) {\n        if (!recursive) {\n            System.err.println(\"ERROR: -r not specified but directory given \" + file.getAbsolutePath());\n            return;\n        }\n        for (File nf : file.listFiles()) {\n            // \"Recursion, n.: See Recursion.\"\n            process(nf);\n        }\n        return;\n    }\n    System.err.println(\"WEIRDNESS: neither file nor directory: \" + file.getAbsolutePath());\n}\n","name":"process","className":"JGrep","variables":{"file":10,"nf":1,"recursive":1},"constants":{"\"ERROR: -r not specified but directory given \"":1,"\"WEIRDNESS: neither file nor directory: \"":1,"\"ERROR: can't read file \"":1},"javaDoc":"Process one command line argument (file or directory) @throws FileNotFoundException","comments":"\"Recursion n : See Recursion \"  Process one command line argument (file or directory)\n     * @throws FileNotFoundException \n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader","String"],"returnType":"void","methodCalls":{"find":1,"reset":1,"readLine":1,"System.err.println":1,"System.out.print":1,"System.out.println":4},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":55,"StringLiteralExpr":2,"FieldAccessExpr":6,"EnclosedExpr":1,"UnaryExpr":2,"AssignExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":6,"WhileStmt":1,"TryStmt":1,"BlockStmt":9,"ReturnStmt":1,"ExpressionStmt":10},"text":"/** Do the work of scanning one file\n     * @param    ifile    Reader    Reader object already open\n     * @param    fileName String    Name of the input file\n     */\npublic void process(Reader ifile, String fileName) {\n    String inputLine;\n    int matches = 0;\n    try (BufferedReader reader = new BufferedReader(ifile)) {\n        while ((inputLine = reader.readLine()) != null) {\n            matcher.reset(inputLine);\n            if (matcher.find()) {\n                if (listOnly) {\n                    // -l, print filename on first match, and we're done\n                    System.out.println(fileName);\n                    return;\n                }\n                if (countOnly) {\n                    matches++;\n                } else {\n                    if (!dontPrintFileName) {\n                        System.out.print(fileName + \": \");\n                    }\n                    System.out.println(inputLine);\n                }\n            } else if (inVert) {\n                System.out.println(inputLine);\n            }\n        }\n        if (countOnly)\n            System.out.println(matches + \" matches in \" + fileName);\n    } catch (IOException e) {\n        System.err.println(e);\n    }\n}\n","name":"process","className":"JGrep","variables":{"ifile":1,"fileName":2,"inputLine":2,"countOnly":2,"inVert":1,"e":1,"reader":2,"listOnly":1,"matcher":2,"matches":3,"dontPrintFileName":1},"constants":{"0":1,"\" matches in \"":1,"null":1,"\": \"":1},"javaDoc":"Do the work of scanning one file ifile Reader Reader object already open fileName String Name of the input file","comments":"-l print filename on first match and we're done  Do the work of scanning one file\n     * @param    ifile    Reader    Reader object already open\n     * @param    fileName String    Name of the input file\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ResourceBundle","String"],"returnType":"JButton","methodCalls":{"getString":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Convenience routine to make a JButton */\npublic static JButton mkButton(ResourceBundle b, String name) {\n    String label;\n    try {\n        label = b.getString(name + \".label\");\n    } catch (MissingResourceException e) {\n        label = name;\n    }\n    return new JButton(label);\n}\n","name":"mkButton","className":"I18N","variables":{"b":1,"e":1,"name":2,"label":4},"constants":{"\".label\"":1},"javaDoc":"Convenience routine to make a JButton","comments":" Convenience routine to make a JButton ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ResourceBundle","String"],"returnType":"JMenu","methodCalls":{"getString":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Convenience routine to make a JMenu */\npublic static JMenu mkMenu(ResourceBundle b, String name) {\n    String menuLabel;\n    try {\n        menuLabel = b.getString(name + \".label\");\n    } catch (MissingResourceException e) {\n        menuLabel = name;\n    }\n    return new JMenu(menuLabel);\n}\n","name":"mkMenu","className":"I18N","variables":{"b":1,"e":1,"name":2,"menuLabel":4},"constants":{"\".label\"":1},"javaDoc":"Convenience routine to make a JMenu","comments":" Convenience routine to make a JMenu ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ResourceBundle","String","String"],"returnType":"JMenuItem","methodCalls":{"getString":2,"charAt":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling"],"types":{"String":2},"expressions":{"NullLiteralExpr":3,"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":7,"NameExpr":21,"StringLiteralExpr":4,"AssignExpr":4,"MethodCallExpr":3},"statements":{"IfStmt":1,"TryStmt":2,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":6},"text":"/** Convenience routine to make a JMenuItem */\npublic static JMenuItem mkMenuItem(ResourceBundle b, String menu, String name) {\n    String miLabel;\n    try {\n        miLabel = b.getString(menu + \".\" + name + \".label\");\n    } catch (MissingResourceException e) {\n        miLabel = name;\n    }\n    String key = null;\n    try {\n        key = b.getString(menu + \".\" + name + \".key\");\n    } catch (MissingResourceException e) {\n        key = null;\n    }\n    if (key == null)\n        return new JMenuItem(miLabel);\n    else\n        return new JMenuItem(miLabel, key.charAt(0));\n}\n","name":"mkMenuItem","className":"I18N","variables":{"b":2,"e":2,"miLabel":5,"name":3,"menu":2,"key":5},"constants":{"\".key\"":1,"0":1,"null":3,"\".\"":2,"\".label\"":1},"javaDoc":"Convenience routine to make a JMenuItem","comments":" Convenience routine to make a JMenuItem ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ResourceBundle","JFrame","String","String","int"],"returnType":"void","methodCalls":{"showMessageDialog":1,"getString":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":15,"StringLiteralExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"/** Show a JOptionPane message dialog */\npublic static void mkDialog(ResourceBundle b, JFrame parent, String dialogTag, String titleTag, int messageType) {\n    JOptionPane.showMessageDialog(parent, getString(b, dialogTag, \"DIALOG TEXT MISSING: \" + dialogTag), getString(b, titleTag, \"DIALOG TITLE MISSING: \" + titleTag), messageType);\n}\n","name":"mkDialog","className":"I18N","variables":{"dialogTag":1,"titleTag":1,"JOptionPane":1},"constants":{"\"DIALOG TEXT MISSING: \"":1,"\"DIALOG TITLE MISSING: \"":1},"javaDoc":"Show a JOptionPane message dialog","comments":" Show a JOptionPane message dialog ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ResourceBundle","String","String"],"returnType":"String","methodCalls":{"getString":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":8,"AssignExpr":2,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Just get a String (for dialogs, labels, etc.) */\npublic static String getString(ResourceBundle b, String name, String dflt) {\n    String result;\n    try {\n        result = b.getString(name);\n    } catch (MissingResourceException e) {\n        result = dflt;\n    }\n    return result;\n}\n","name":"getString","className":"I18N","variables":{"result":4,"b":1,"e":1,"dflt":1},"constants":{},"javaDoc":"Just get a String (for dialogs labels etc )","comments":" Just get a String (for dialogs, labels, etc.) ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Window"],"returnType":"WindowCloser","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a WindowCloser that doesn't exit, just closes the window */\npublic WindowCloser(Window w) {\n    this(w, false);\n}\n","name":"WindowCloser","className":"WindowCloser","variables":{"w":1},"constants":{"false":1},"javaDoc":"Construct a WindowCloser that doesn't exit just closes the window","comments":" Construct a WindowCloser that doesn't exit, just closes the window ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Window","boolean"],"returnType":"WindowCloser","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Construct a WindowCloser with control over whether it exits */\npublic WindowCloser(Window w, boolean exit) {\n    win = w;\n    doExit = exit;\n}\n","name":"WindowCloser","className":"WindowCloser","variables":{"exit":1,"w":1,"doExit":1,"win":1},"constants":{},"javaDoc":"Construct a WindowCloser with control over whether it exits","comments":" Construct a WindowCloser with control over whether it exits ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"setVisible":1,"exit":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":10,"MethodCallExpr":3},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"/** Called by AWT when the user tries to close the window */\npublic void windowClosing(WindowEvent e) {\n    win.setVisible(false);\n    win.dispose();\n    if (doExit)\n        System.exit(0);\n}\n","name":"windowClosing","className":"WindowCloser","variables":{"doExit":1,"win":2,"System":1},"constants":{"0":1,"false":1},"javaDoc":"Called by AWT when the user tries to close the window","comments":" Called by AWT when the user tries to close the window ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Window"],"returnType":"void","methodCalls":{"getSize":1,"getDefaultToolkit":1,"setLocation":1,"getScreenSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Dimension":1,"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":25,"FieldAccessExpr":4,"EnclosedExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/** Centre a Window, Frame, JFrame, Dialog, etc. */\npublic static void centre(final Window w) {\n    // After packing a Frame or Dialog, centre it on the screen.\n    Dimension us = w.getSize(), them = Toolkit.getDefaultToolkit().getScreenSize();\n    int newX = (them.width - us.width) / 2;\n    int newY = (them.height - us.height) / 2;\n    w.setLocation(newX, newY);\n}\n","name":"centre","className":"UtilGUI","variables":{"w":2,"them":1,"Toolkit":1,"newY":1,"newX":1,"us":1},"constants":{"2":2},"javaDoc":"Centre a Window Frame JFrame Dialog etc","comments":"After packing a Frame or Dialog centre it on the screen  Centre a Window, Frame, JFrame, Dialog, etc. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Window"],"returnType":"void","methodCalls":{"centre":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Center a Window, Frame, JFrame, Dialog, etc., \n     * but do it the American Spelling Way :-)\n     */\npublic static void center(final Window w) {\n    UtilGUI.centre(w);\n}\n","name":"center","className":"UtilGUI","variables":{"UtilGUI":1},"constants":{},"javaDoc":"Center a Window Frame JFrame Dialog etc but do it the American Spelling Way :-)","comments":" Center a Window, Frame, JFrame, Dialog, etc., \n     * but do it the American Spelling Way :-)\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Window"],"returnType":"void","methodCalls":{"getDefaultToolkit":1,"getScreenSize":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Dimension":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":14,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/** Maximize a window, the hard way. */\npublic static void maximize(final Window w) {\n    Dimension them = Toolkit.getDefaultToolkit().getScreenSize();\n    w.setBounds(0, 0, them.width, them.height);\n}\n","name":"maximize","className":"UtilGUI","variables":{"w":1,"them":1,"Toolkit":1},"constants":{"0":2},"javaDoc":"Maximize a window the hard way","comments":" Maximize a window, the hard way. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Clipboard","Transferable"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void lostOwnership(Clipboard clipboard, Transferable contents) {\n// don't care\n}\n","name":"lostOwnership","className":"","variables":{},"constants":{},"javaDoc":"","comments":"don't care ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component","String"],"returnType":"void","methodCalls":{"getToolkit":1,"setContents":1,"getSystemClipboard":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Clipboard":1,"StringSelection":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":13,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** \n     * Copy a string value to the system copy buffer\n     */\npublic static void setSystemClipboardContents(Component c, String srcData) {\n    if (srcData != null) {\n        Clipboard clipboard = c.getToolkit().getSystemClipboard();\n        StringSelection contents = new StringSelection(srcData);\n        clipboard.setContents(contents, new ClipboardOwner() {\n\n            public void lostOwnership(Clipboard clipboard, Transferable contents) {\n            // don't care\n            }\n        });\n    }\n}\n","name":"setSystemClipboardContents","className":"UtilGUI","variables":{"c":1,"contents":2,"lostOwnership":1,"srcData":2,"clipboard":3},"constants":{"null":1},"javaDoc":"Copy a string value to the system copy buffer","comments":"don't care  \n     * Copy a string value to the system copy buffer\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["JFrame","String"],"returnType":"boolean","methodCalls":{"showConfirmDialog":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Print a yes/no prompt; return true if the user presses yes\n     */\npublic static boolean confirm(JFrame parent, String message) {\n    int confirm = JOptionPane.showConfirmDialog(parent, message, \"Confirm\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);\n    // Only selecting Yes choice will result in true\n    return confirm == 0;\n}\n","name":"confirm","className":"UtilGUI","variables":{"confirm":2,"JOptionPane":1},"constants":{"0":1,"\"Confirm\"":1},"javaDoc":"Print a yes/no prompt; return true if the user presses yes","comments":"Only selecting Yes choice will result in true  Print a yes/no prompt; return true if the user presses yes\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Preferences","Window"],"returnType":"void","methodCalls":{"getLocation":1,"getX":1,"getY":1,"putInt":2,"max":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Point":1,"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"NameExpr":23,"CastExpr":2,"StringLiteralExpr":2,"MethodCallExpr":7},"statements":{"ExpressionStmt":5},"text":"/**    Save the X and Y locations in Preferences node provided.\n     */\npublic static void setSavedLocation(final Preferences pNode, final Window w) {\n    Point where = w.getLocation();\n    int x = (int) where.getX();\n    pNode.putInt(\"mainwindow.x\", Math.max(0, x));\n    int y = (int) where.getY();\n    pNode.putInt(\"mainwindow.y\", Math.max(0, y));\n}\n","name":"setSavedLocation","className":"UtilGUI","variables":{"w":1,"x":1,"y":1,"where":3,"Math":2,"pNode":2},"constants":{"0":2,"\"mainwindow.y\"":1,"\"mainwindow.x\"":1},"javaDoc":"Save the X and Y locations in Preferences node provided","comments":"    Save the X and Y locations in Preferences node provided.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Preferences"],"returnType":"Point","methodCalls":{"getInt":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":8,"StringLiteralExpr":2,"UnaryExpr":2,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Retrieve the saved X and Y from Preferences\n     */\npublic static Point getSavedLocation(final Preferences pNode) {\n    int savedX = pNode.getInt(\"mainwindow.x\", -1);\n    int savedY = pNode.getInt(\"mainwindow.y\", -1);\n    return new Point(savedX, savedY);\n}\n","name":"getSavedLocation","className":"UtilGUI","variables":{"savedY":2,"savedX":2,"pNode":2},"constants":{"1":2,"\"mainwindow.y\"":1,"\"mainwindow.x\"":1},"javaDoc":"Retrieve the saved X and Y from Preferences","comments":" Retrieve the saved X and Y from Preferences\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ComponentEvent"],"returnType":"void","methodCalls":{"setSavedLocation":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void componentMoved(ComponentEvent e) {\n    setSavedLocation(pNode, w);\n}\n","name":"componentMoved","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Window","Preferences"],"returnType":"void","methodCalls":{"setSavedLocation":1,"getSavedLocation":1,"getX":1,"getY":1,"setLocation":1,"centre":1,"addComponentListener":1},"annotations":[],"exceptions":[],"concepts":["Casting","InnerMethod"],"types":{"Point":1,"int":2},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":28,"CastExpr":2,"MarkerAnnotationExpr":1,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":3,"ExpressionStmt":7},"text":"/** \n     * Track a Window's position across application restarts; location is saved\n     * in a Preferences node that you pass in; we attach a ComponentListener to\n     * the Window.\n     */\npublic static void monitorWindowPosition(final Window w, final Preferences pNode) {\n    // Get the current saved position, if any\n    Point p = getSavedLocation(pNode);\n    int savedX = (int) p.getX();\n    int savedY = (int) p.getY();\n    if (savedX != -1) {\n        // Move window to is previous location\n        w.setLocation(savedX, savedY);\n    } else {\n        // Not saved yet, at least make it look nice\n        centre(w);\n    }\n    // Now make sure that if the user moves the window,\n    // we will save the new position.\n    w.addComponentListener(new ComponentAdapter() {\n\n        @Override\n        public void componentMoved(ComponentEvent e) {\n            setSavedLocation(pNode, w);\n        }\n    });\n}\n","name":"monitorWindowPosition","className":"UtilGUI","variables":{"p":3,"e":1,"w":2,"savedY":1,"savedX":2,"componentMoved":1,"Override":1},"constants":{"1":1},"javaDoc":"Track a Window's position across application restarts; location is saved in a Preferences node that you pass in; we attach a ComponentListener to the Window","comments":"Now make sure that if the user moves the window Get the current saved position if any Move window to is previous location Not saved yet at least make it look nice we will save the new position  \n     * Track a Window's position across application restarts; location is saved\n     * in a Preferences node that you pass in; we attach a ComponentListener to\n     * the Window.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double[]","int","int"],"returnType":"EntryLayout","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":2,"NameExpr":22,"StringLiteralExpr":1,"UnaryExpr":1,"AssignExpr":6,"DoubleLiteralExpr":1,"BooleanLiteralExpr":1,"FieldAccessExpr":2,"ArrayCreationExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ThrowStmt":1,"ExpressionStmt":6},"text":"/** Construct an EntryLayout with widths and padding specified.\n     * @param relWidths    Array of doubles specifying relative column widths.\n     * @param h            Horizontal padding between items\n     * @param v            Vertical padding between items\n     */\npublic EntryLayout(double[] relWidths, int h, int v) {\n    COLUMNS = relWidths.length;\n    widthPercentages = new double[COLUMNS];\n    for (int i = 0; i < relWidths.length; i++) {\n        if (relWidths[i] >= 1.0)\n            throw new IllegalArgumentException(\"EntryLayout: widths must be fractions < 1\");\n        widthPercentages[i] = relWidths[i];\n    }\n    validWidths = true;\n    hpad = h;\n    vpad = v;\n}\n","name":"EntryLayout","className":"EntryLayout","variables":{"widthPercentages":2,"v":1,"h":1,"i":6,"COLUMNS":2,"vpad":1,"relWidths":2,"hpad":1,"validWidths":1},"constants":{"0":1,"1.0":1,"true":1,"\"EntryLayout: widths must be fractions < 1\"":1},"javaDoc":"Construct an EntryLayout with widths and padding specified relWidths Array of doubles specifying relative column widths h Horizontal padding between items v Vertical padding between items","comments":" Construct an EntryLayout with widths and padding specified.\n     * @param relWidths    Array of doubles specifying relative column widths.\n     * @param h            Horizontal padding between items\n     * @param v            Vertical padding between items\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double[]"],"returnType":"EntryLayout","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct an EntryLayout with widths and with default padding amounts.\n     * @param relWidths    Array of doubles specifying column widths.\n     */\npublic EntryLayout(double[] relWidths) {\n    this(relWidths, HPAD, VPAD);\n}\n","name":"EntryLayout","className":"EntryLayout","variables":{"VPAD":1,"HPAD":1,"relWidths":1},"constants":{},"javaDoc":"Construct an EntryLayout with widths and with default padding amounts relWidths Array of doubles specifying column widths","comments":" Construct an EntryLayout with widths and with default padding amounts.\n     * @param relWidths    Array of doubles specifying column widths.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","Component"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Adds the specified component with the specified constraint\n     * to the layout; required by LayoutManager but not used.\n     */\npublic void addLayoutComponent(String name, Component comp) {\n// nothing to do\n}\n","name":"addLayoutComponent","className":"EntryLayout","variables":{},"constants":{},"javaDoc":"Adds the specified component with the specified constraint to the layout; required by LayoutManager but not used","comments":"nothing to do  Adds the specified component with the specified constraint\n     * to the layout; required by LayoutManager but not used.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Removes the specified component from the layout;\n     * required by LayoutManager, but does nothing.\n     */\npublic void removeLayoutComponent(Component comp) {\n// nothing to do\n}\n","name":"removeLayoutComponent","className":"EntryLayout","variables":{},"constants":{},"javaDoc":"Removes the specified component from the layout; required by LayoutManager but does nothing","comments":"nothing to do  Removes the specified component from the layout;\n     * required by LayoutManager, but does nothing.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"Dimension","methodCalls":{"computeLayoutSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Calculates the preferred size dimensions for the specified panel\n     * given the components in the specified parent container. */\npublic Dimension preferredLayoutSize(Container parent) {\n    // System.out.println(\"preferredLayoutSize\");\n    return computeLayoutSize(parent, hpad, vpad);\n}\n","name":"preferredLayoutSize","className":"EntryLayout","variables":{},"constants":{},"javaDoc":"Calculates the preferred size dimensions for the specified panel given the components in the specified parent container","comments":"System out println(\"preferredLayoutSize\");  Calculates the preferred size dimensions for the specified panel\n     * given the components in the specified parent container. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"Dimension","methodCalls":{"computeLayoutSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Find the minimum Dimension for the\n     * specified container given the components therein.\n     */\npublic Dimension minimumLayoutSize(Container parent) {\n    // System.out.println(\"minimumLayoutSize\");\n    return computeLayoutSize(parent, 0, 0);\n}\n","name":"minimumLayoutSize","className":"EntryLayout","variables":{},"constants":{"0":2},"javaDoc":"Find the minimum Dimension for the specified container given the components therein","comments":"System out println(\"minimumLayoutSize\");  Find the minimum Dimension for the\n     * specified container given the components therein.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container","int","int"],"returnType":"Dimension","methodCalls":{"getPreferredSize":1,"max":2,"getComponents":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Component[]":1,"Dimension":1,"Component":1,"int":4},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":7,"ArrayAccessExpr":7,"BinaryExpr":8,"NameExpr":72,"FieldAccessExpr":8,"UnaryExpr":4,"ArrayCreationExpr":2,"MethodCallExpr":4,"AssignExpr":9},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ForStmt":3,"ExpressionStmt":13},"text":"/** Compute the size of the whole mess. Serves as the guts of\n     * preferredLayoutSize() and minimumLayoutSize().\n     * @param parent The container in which to do the layout.\n     * @param hp The horizontal padding (may be zero)\n     * @param vp The Vertical Padding (may be zero).\n     */\nprotected Dimension computeLayoutSize(Container parent, int hp, int vp) {\n    if (!validWidths)\n        return null;\n    Component[] components = parent.getComponents();\n    int preferredWidth = 0, preferredHeight = 0;\n    widths = new int[COLUMNS];\n    heights = new int[components.length / COLUMNS];\n    // System.out.println(\"Grid: \" + widths.length + \", \" + heights.length);\n    int i;\n    // Pass One: Compute largest widths and heights.\n    for (i = 0; i < components.length; i++) {\n        int row = i / widthPercentages.length;\n        int col = i % widthPercentages.length;\n        Component c = components[i];\n        Dimension d = c.getPreferredSize();\n        widths[col] = Math.max(widths[col], d.width);\n        heights[row] = Math.max(heights[row], d.height);\n    }\n    // Pass two: agregate them.\n    for (i = 0; i < widths.length; i++) preferredWidth += widths[i] + hp;\n    for (i = 0; i < heights.length; i++) preferredHeight += heights[i] + vp;\n    // Finally, pass the sums back as the actual size.\n    return new Dimension(preferredWidth, preferredHeight);\n}\n","name":"computeLayoutSize","className":"EntryLayout","variables":{"parent":1,"preferredWidth":3,"col":3,"components":2,"c":2,"d":1,"hp":1,"i":15,"widths":4,"Math":2,"preferredHeight":3,"heights":4,"COLUMNS":2,"vp":1,"row":3,"validWidths":1},"constants":{"0":5,"null":1},"javaDoc":"Compute the size of the whole mess Serves as the guts of preferredLayoutSize() and minimumLayoutSize() parent The container in which to do the layout hp The horizontal padding (may be zero) vp The Vertical Padding (may be zero)","comments":"System out println(\"Grid: \" + widths length + \" \" + heights length); Pass One: Compute largest widths and heights Pass two: agregate them Finally pass the sums back as the actual size  Compute the size of the whole mess. Serves as the guts of\n     * preferredLayoutSize() and minimumLayoutSize().\n     * @param parent The container in which to do the layout.\n     * @param hp The horizontal padding (may be zero)\n     * @param vp The Vertical Padding (may be zero).\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Container"],"returnType":"void","methodCalls":{"println":1,"getSize":1,"getPreferredSize":1,"getComponents":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Rectangle":1,"Component[]":1,"Dimension":2,"Component":1,"int":6},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":11,"ArrayAccessExpr":5,"BinaryExpr":15,"NameExpr":60,"StringLiteralExpr":2,"UnaryExpr":2,"AssignExpr":2,"CastExpr":2,"FieldAccessExpr":5,"EnclosedExpr":6,"MethodCallExpr":5},"statements":{"IfStmt":2,"BlockStmt":3,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":14},"text":"/** Lays out the container in the specified panel. This is a row-column\n     * type layout; find x, y, width and height of each Component.\n     * @param parent The Container whose children we are laying out.\n     */\npublic void layoutContainer(Container parent) {\n    Debug.println(\"layout\", \"layoutContainer:\");\n    if (!validWidths)\n        return;\n    Component[] components = parent.getComponents();\n    Dimension contSize = parent.getSize();\n    int x = 0;\n    for (int i = 0; i < components.length; i++) {\n        int row = i / COLUMNS;\n        int col = i % COLUMNS;\n        Component c = components[i];\n        Dimension d = c.getPreferredSize();\n        int colWidth = (int) (contSize.width * widthPercentages[col]);\n        if (col == 0) {\n            x = hpad;\n        } else {\n            x += hpad * (col - 1) + (int) (contSize.width * widthPercentages[col - 1]);\n        }\n        int y = vpad * (row) + (row * heights[row]) + (heights[row] - d.height);\n        Rectangle r = new Rectangle(x, y, colWidth, d.height);\n        c.setBounds(r);\n    }\n}\n","name":"layoutContainer","className":"EntryLayout","variables":{"widthPercentages":2,"parent":2,"col":5,"components":2,"c":3,"d":1,"colWidth":2,"i":6,"vpad":1,"r":1,"contSize":1,"heights":2,"x":4,"y":2,"COLUMNS":2,"row":5,"hpad":2,"validWidths":1,"Debug":1},"constants":{"0":3,"1":2,"\"layoutContainer:\"":1,"\"layout\"":1},"javaDoc":"Lays out the container in the specified panel This is a row-column type layout; find x y width and height of each Component parent The Container whose children we are laying out","comments":" Lays out the container in the specified panel. This is a row-column\n     * type layout; find x, y, width and height of each Component.\n     * @param parent The Container whose children we are laying out.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"LabelText","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"StringLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct the object with no initial values.\n     * To be usable as a JavaBean there must be a no-argument constructor.\n     */\npublic LabelText() {\n    this(\"(LabelText)\", 12);\n}\n","name":"LabelText","className":"LabelText","variables":{},"constants":{"12":1,"\"(LabelText)\"":1},"javaDoc":"Construct the object with no initial values To be usable as a JavaBean there must be a no-argument constructor","comments":" Construct the object with no initial values.\n     * To be usable as a JavaBean there must be a no-argument constructor.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"LabelText","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct the object with the label and a default textfield size */\npublic LabelText(String label) {\n    this(label, 12);\n}\n","name":"LabelText","className":"LabelText","variables":{"label":1},"constants":{"12":1},"javaDoc":"Construct the object with the label and a default textfield size","comments":" Construct the object with the label and a default textfield size ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"LabelText","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct the object with given label and textfield size */\npublic LabelText(String label, int numChars) {\n    this(label, numChars, null);\n}\n","name":"LabelText","className":"LabelText","variables":{"label":1,"numChars":1},"constants":{"null":1},"javaDoc":"Construct the object with given label and textfield size","comments":" Construct the object with given label and textfield size ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int","JComponent"],"returnType":"LabelText","methodCalls":{"add":3,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":19,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":6},"text":"/** Construct the object with given label, textfield size,\n     * and \"Extra\" component\n     * @param label The text to display\n     * @param numChars The size of the text area\n     * @param extra A third component such as a cancel button;\n     * may be null, in which case only the label and textfield exist.\n     */\npublic LabelText(String label, int numChars, JComponent extra) {\n    super();\n    setLayout(new BoxLayout(this, BoxLayout.X_AXIS));\n    theLabel = new JLabel(label);\n    add(theLabel);\n    theTextField = new JTextField(numChars);\n    add(theTextField);\n    if (extra != null) {\n        add(extra);\n    }\n}\n","name":"LabelText","className":"LabelText","variables":{"theLabel":1,"extra":1,"theTextField":1,"label":1,"numChars":1},"constants":{"null":1},"javaDoc":"Construct the object with given label textfield size and \"Extra\" component label The text to display numChars The size of the text area extra A third component such as a cancel button; may be null in which case only the label and textfield exist","comments":" Construct the object with given label, textfield size,\n     * and \"Extra\" component\n     * @param label The text to display\n     * @param numChars The size of the text area\n     * @param extra A third component such as a cancel button;\n     * may be null, in which case only the label and textfield exist.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getHorizontalAlignment":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get the label's horizontal alignment */\npublic int getLabelAlignment() {\n    return theLabel.getHorizontalAlignment();\n}\n","name":"getLabelAlignment","className":"LabelText","variables":{"theLabel":1},"constants":{},"javaDoc":"Get the label's horizontal alignment","comments":" Get the label's horizontal alignment ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"setHorizontalAlignment":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the label's horizontal alignment */\npublic void setLabelAlignment(int align) {\n    theLabel.setHorizontalAlignment(align);\n}\n","name":"setLabelAlignment","className":"LabelText","variables":{"theLabel":1},"constants":{},"javaDoc":"Set the label's horizontal alignment","comments":" Set the label's horizontal alignment ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get the text displayed in the text field */\npublic String getText() {\n    return theTextField.getText();\n}\n","name":"getText","className":"LabelText","variables":{"theTextField":1},"constants":{},"javaDoc":"Get the text displayed in the text field","comments":" Get the text displayed in the text field ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the text displayed in the text field */\npublic void setText(String text) {\n    theTextField.setText(text);\n}\n","name":"setText","className":"LabelText","variables":{"theTextField":1},"constants":{},"javaDoc":"Set the text displayed in the text field","comments":" Set the text displayed in the text field ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get the text displayed in the label */\npublic String getLabel() {\n    return theLabel.getText();\n}\n","name":"getLabel","className":"LabelText","variables":{"theLabel":1},"constants":{},"javaDoc":"Get the text displayed in the label","comments":" Get the text displayed in the label ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the text displayed in the label */\npublic void setLabel(String text) {\n    theLabel.setText(text);\n}\n","name":"setLabel","className":"LabelText","variables":{"theLabel":1},"constants":{},"javaDoc":"Set the text displayed in the label","comments":" Set the text displayed in the label ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Font"],"returnType":"void","methodCalls":{"setFont":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":2,"NameExpr":10,"MethodCallExpr":2},"statements":{"IfStmt":2,"ExpressionStmt":2},"text":"/** Set the font used in both subcomponents. */\npublic void setFont(Font f) {\n    // before we create our components, so work around this.\n    if (theLabel != null)\n        theLabel.setFont(f);\n    if (theTextField != null)\n        theTextField.setFont(f);\n}\n         // This class' constructors call to super() can trigger\n\n         // calls to setFont() (from Swing.LookAndFeel.installColorsAndFont),\n\n","name":"setFont","className":"LabelText","variables":{"theLabel":2,"theTextField":2},"constants":{"null":2},"javaDoc":"Set the font used in both subcomponents","comments":"This class' constructors call to super() can trigger calls to setFont() (from Swing LookAndFeel installColorsAndFont) before we create our components so work around this  Set the font used in both subcomponents. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionListener"],"returnType":"void","methodCalls":{"addActionListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Adds the ActionListener to receive action events from the textfield */\npublic void addActionListener(ActionListener l) {\n    theTextField.addActionListener(l);\n}\n","name":"addActionListener","className":"LabelText","variables":{"theTextField":1},"constants":{},"javaDoc":"Adds the ActionListener to receive action events from the textfield","comments":" Adds the ActionListener to receive action events from the textfield ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionListener"],"returnType":"void","methodCalls":{"removeActionListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Remove an ActionListener from the textfield. */\npublic void removeActionListener(ActionListener l) {\n    theTextField.removeActionListener(l);\n}\n","name":"removeActionListener","className":"LabelText","variables":{"theTextField":1},"constants":{},"javaDoc":"Remove an ActionListener from the textfield","comments":" Remove an ActionListener from the textfield. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ErrorUtil","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Public no-arg constructor for those who like simple instantiation. */\npublic ErrorUtil() {\n// Nothing to do\n}\n","name":"ErrorUtil","className":"ErrorUtil","variables":{},"constants":{},"javaDoc":"Public no-arg constructor for those who like simple instantiation","comments":"Nothing to do  Public no-arg constructor for those who like simple instantiation. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Throwable"],"returnType":"void","methodCalls":{"showExceptions":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Convenience routine for use with AWT's dispatch thread; this is the old,\n     * never-supported and now often-doesn't-work method, but the code is still here.\n     * Usage:\n     * <pre>\n     * System.setProperty(\"sun.awt.exception.handler\", \"com.darwinsys.swingui.ErrorUtil\");\n     * </pre>\n     */\npublic void handle(Throwable th) {\n    //System.out.println(\"handle() called with \" + th.getClass().getName());\n    showExceptions(null, th);\n}\n","name":"handle","className":"ErrorUtil","variables":{},"constants":{"null":1},"javaDoc":"Convenience routine for use with AWT's dispatch thread; this is the old never-supported and now often-doesn't-work method but the code is still here Usage: <pre> System setProperty(\"sun awt exception handler\" \"com darwinsys swingui ErrorUtil\"); </pre>","comments":"System out println(\"handle() called with \" + th getClass() getName());  Convenience routine for use with AWT's dispatch thread; this is the old,\n     * never-supported and now often-doesn't-work method, but the code is still here.\n     * Usage:\n     * <pre>\n     * System.setProperty(\"sun.awt.exception.handler\", \"com.darwinsys.swingui.ErrorUtil\");\n     * </pre>\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component","Throwable"],"returnType":"void","methodCalls":{"showStackTrace":1,"getClass":1,"getName":1,"getErrorCode":1,"getNextException":1,"getCause":1,"showOptionDialog":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"SQLException":1,"Throwable":1,"String":2,"String[]":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":6,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":49,"StringLiteralExpr":1,"ConditionalExpr":1,"InstanceOfExpr":1,"AssignExpr":5,"NullLiteralExpr":5,"CastExpr":2,"FieldAccessExpr":2,"MethodCallExpr":7},"statements":{"IfStmt":4,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":12,"DoStmt":1},"text":"/**\n     * Show the given Exception (and any nested Exceptions) in JOptionPane(s).\n     */\npublic static void showExceptions(Component parent, Throwable theExc) {\n    Throwable next = null;\n    do {\n        String className = theExc.getClass().getName();\n        String message = className;\n        if (theExc instanceof SQLException) {\n            SQLException sexc = (SQLException) theExc;\n            message += \"; code=\" + sexc.getErrorCode();\n            next = sexc.getNextException();\n        } else {\n            // Comment out if < JDK 1.4\n            next = theExc.getCause();\n        }\n        String[] choices = next != null ? choicesMore : choicesNoMore;\n        /* Show the Dialog! */\n        int response = JOptionPane.showOptionDialog(parent, message, // title\n        className, // icontType\n        JOptionPane.YES_NO_CANCEL_OPTION, // messageType\n        JOptionPane.ERROR_MESSAGE, // icon\n        null, // options\n        choices, // default\n        choices[0]);\n        if (// \"OK\"\n        response == 0)\n            return;\n        if (response == 1) {\n            // show ANOTHER JDialog with a JTextArea of printStackTrace();\n            if (// first time, lazy creation\n            detailsDialog == null)\n                detailsDialog = new DetailsDialog((JFrame) parent);\n            detailsDialog.showStackTrace(theExc);\n        }\n        // else resp = 2, \"Next\", let it fall through:\n        theExc = next;\n    } while (next != null);\n}\n                                         // \"Details\"\n\n","name":"showExceptions","className":"ErrorUtil","variables":{"next":6,"parent":1,"theExc":5,"response":3,"sexc":3,"className":2,"message":2,"choices":2,"choicesNoMore":1,"choicesMore":1,"JOptionPane":1,"detailsDialog":3},"constants":{"0":2,"1":1,"null":4,"\"; code=\"":1},"javaDoc":"Show the given Exception (and any nested Exceptions) in JOptionPane(s)","comments":"else resp = 2 \"Next\" let it fall through: Comment out if < JDK 1 4 Show the Dialog! title icontType messageType icon options default \"OK\" \"Details\" show ANOTHER JDialog with a JTextArea of printStackTrace(); first time lazy creation \n     * Show the given Exception (and any nested Exceptions) in JOptionPane(s).\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent evt) {\n    dispose();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["JFrame"],"returnType":"DetailsDialog","methodCalls":{"add":2,"addActionListener":1,"getContentPane":1,"dispose":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Container":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":28,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":6,"AssignExpr":2},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":8},"text":"/** Construct a DetailsDialog given a parent (Frame/JFrame) */\nDetailsDialog(JFrame parent) {\n    super(parent);\n    Container cp = getContentPane();\n    text = new JTextArea(40, 40);\n    cp.add(text, BorderLayout.CENTER);\n    ok = new JButton(\"Close\");\n    cp.add(ok, BorderLayout.SOUTH);\n    ok.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent evt) {\n            dispose();\n        }\n    });\n    pack();\n}\n","name":"DetailsDialog","className":"DetailsDialog","variables":{"parent":1,"actionPerformed":1,"evt":1,"text":1,"ok":2,"cp":3},"constants":{"\"Close\"":1,"40":2},"javaDoc":"Construct a DetailsDialog given a parent (Frame/JFrame)","comments":" Construct a DetailsDialog given a parent (Frame/JFrame) ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Throwable"],"returnType":"void","methodCalls":{"setVisible":1,"printStackTrace":1,"toString":1,"close":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"CharArrayWriter":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":16,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"/** Display the stackTrace from the given Throwable in this Dialog. */\nvoid showStackTrace(Throwable exc) {\n    CharArrayWriter buff = new CharArrayWriter();\n    PrintWriter pw = new PrintWriter(buff);\n    exc.printStackTrace(pw);\n    pw.close();\n    text.setText(buff.toString());\n    setVisible(true);\n}\n","name":"showStackTrace","className":"DetailsDialog","variables":{"exc":1,"pw":2,"text":1,"buff":3},"constants":{"true":1},"javaDoc":"Display the stackTrace from the given Throwable in this Dialog","comments":" Display the stackTrace from the given Throwable in this Dialog. ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["ListSelectionEvent"],"returnType":"void","methodCalls":{"previewFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void valueChanged(ListSelectionEvent e) {\n    previewFont();\n}\n","name":"valueChanged","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemEvent"],"returnType":"void","methodCalls":{"previewFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void itemStateChanged(ItemEvent e) {\n    previewFont();\n}\n","name":"itemStateChanged","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setVisible":1,"previewFont":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":6,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent e) {\n    previewFont();\n    dispose();\n    setVisible(false);\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setVisible":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":1,"BooleanLiteralExpr":3,"NameExpr":9,"AssignExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":7},"text":"public void actionPerformed(ActionEvent e) {\n    // Set all values to null. Better: restore previous.\n    resultFont = null;\n    resultName = null;\n    resultSize = 0;\n    isBold = false;\n    isItalic = false;\n    dispose();\n    setVisible(false);\n}\n","name":"actionPerformed","className":"","variables":{"isItalic":1,"resultSize":1,"isBold":1,"resultFont":1,"resultName":1},"constants":{"0":1,"null":2,"false":3},"javaDoc":"","comments":"Set all values to null Better: restore previous ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["JFrame"],"returnType":"FontChooser","methodCalls":{"add":10,"addListSelectionListener":2,"setVisible":2,"addActionListener":2,"getContentPane":1,"setLayout":2,"pack":1,"getAvailableFontFamilyNames":1,"setSize":1,"setSelectedValue":1,"previewFont":4,"setLocation":1,"setBorder":1,"setVisibleRowCount":1,"addItemListener":2,"dispose":2,"setSelectedIndex":1,"getLocalGraphicsEnvironment":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"JPanel":3,"Container":1,"JButton":2,"ItemListener":1,"String[]":1,"ListSelectionListener":1},"expressions":{"ObjectCreationExpr":19,"IntegerLiteralExpr":9,"NullLiteralExpr":2,"VariableDeclarationExpr":9,"BooleanLiteralExpr":8,"BinaryExpr":2,"NameExpr":148,"StringLiteralExpr":7,"FieldAccessExpr":6,"MethodCallExpr":36,"AssignExpr":10},"statements":{"BlockStmt":4,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":50},"text":"/** Construct a FontChooser -- Sets title and gets\n     * array of fonts on the system. Builds a GUI to let\n     * the user choose one font at one size.\n     */\npublic FontChooser(JFrame f) {\n    super(f, \"Font Chooser\", true);\n    Container cp = getContentPane();\n    JPanel top = new JPanel();\n    top.setBorder(new TitledBorder(new EtchedBorder(), \"Font\"));\n    top.setLayout(new FlowLayout());\n    // This gives a longish list; most of the names that come\n    // with your OS (e.g., Helvetica, Times), plus the Sun/Java ones (Lucida,\n    // Lucida Bright, Lucida Sans...)\n    String[] fontList = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n    fontNameChoice = new JList(fontList);\n    top.add(new JScrollPane(fontNameChoice));\n    fontNameChoice.setVisibleRowCount(fontSizes.length);\n    fontNameChoice.setSelectedValue(\"Serif\", true);\n    fontSizeChoice = new JList(fontSizes);\n    top.add(fontSizeChoice);\n    fontSizeChoice.setSelectedIndex(fontSizes.length * 3 / 4);\n    cp.add(top, BorderLayout.NORTH);\n    JPanel attrs = new JPanel();\n    top.add(attrs);\n    attrs.setLayout(new GridLayout(0, 1));\n    attrs.add(bold = new JCheckBox(\"Bold\", false));\n    attrs.add(italic = new JCheckBox(\"Italic\", false));\n    // Make sure that any change to the GUI will trigger a font preview.\n    ListSelectionListener waker = new ListSelectionListener() {\n\n        public void valueChanged(ListSelectionEvent e) {\n            previewFont();\n        }\n    };\n    fontSizeChoice.addListSelectionListener(waker);\n    fontNameChoice.addListSelectionListener(waker);\n    ItemListener waker2 = new ItemListener() {\n\n        public void itemStateChanged(ItemEvent e) {\n            previewFont();\n        }\n    };\n    bold.addItemListener(waker2);\n    italic.addItemListener(waker2);\n    previewArea = new JLabel(displayText, JLabel.CENTER);\n    previewArea.setSize(200, 50);\n    cp.add(previewArea, BorderLayout.CENTER);\n    JPanel bot = new JPanel();\n    JButton okButton = new JButton(\"Apply\");\n    bot.add(okButton);\n    okButton.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            previewFont();\n            dispose();\n            setVisible(false);\n        }\n    });\n    JButton canButton = new JButton(\"Cancel\");\n    bot.add(canButton);\n    canButton.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            // Set all values to null. Better: restore previous.\n            resultFont = null;\n            resultName = null;\n            resultSize = 0;\n            isBold = false;\n            isItalic = false;\n            dispose();\n            setVisible(false);\n        }\n    });\n    cp.add(bot, BorderLayout.SOUTH);\n    // ensure view is up to date!\n    previewFont();\n    pack();\n    setLocation(100, 100);\n}\n","name":"FontChooser","className":"FontChooser","variables":{"bot":3,"fontList":2,"fontSizes":1,"okButton":2,"italic":2,"isItalic":1,"fontNameChoice":5,"actionPerformed":2,"top":6,"resultSize":1,"fontSizeChoice":3,"canButton":2,"displayText":1,"itemStateChanged":1,"valueChanged":1,"e":4,"f":1,"bold":2,"GraphicsEnvironment":1,"cp":4,"isBold":1,"attrs":4,"resultFont":1,"resultName":1,"waker":1,"previewArea":2,"waker2":1},"constants":{"\"Bold\"":1,"\"Font\"":1,"false":6,"\"Cancel\"":1,"\"Apply\"":1,"\"Font Chooser\"":1,"0":2,"1":1,"100":2,"200":1,"3":1,"4":1,"null":2,"true":2,"\"Italic\"":1,"50":1,"\"Serif\"":1},"javaDoc":"Construct a FontChooser -- Sets title and gets array of fonts on the system Builds a GUI to let the user choose one font at one size","comments":"This gives a longish list; most of the names that come with your OS (e g Helvetica Times) plus the Sun/Java ones (Lucida Lucida Bright Lucida Sans ) Make sure that any change to the GUI will trigger a font preview Set all values to null Better: restore previous ensure view is up to date!  Construct a FontChooser -- Sets title and gets\n     * array of fonts on the system. Builds a GUI to let\n     * the user choose one font at one size.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"parseInt":1,"isSelected":2,"getSelectedValue":2,"toString":1,"setFont":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":2},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":44,"CastExpr":1,"FieldAccessExpr":3,"AssignExpr":6,"MethodCallExpr":8},"statements":{"IfStmt":2,"ExpressionStmt":11},"text":"/** Called from the action handlers to get the font info,\n     * build a font, and set it.\n     */\nprotected void previewFont() {\n    resultName = (String) fontNameChoice.getSelectedValue();\n    String resultSizeName = fontSizeChoice.getSelectedValue().toString();\n    int resultSize = Integer.parseInt(resultSizeName);\n    isBold = bold.isSelected();\n    isItalic = italic.isSelected();\n    int attrs = Font.PLAIN;\n    if (isBold)\n        attrs = Font.BOLD;\n    if (isItalic)\n        attrs |= Font.ITALIC;\n    resultFont = new Font(resultName, attrs, resultSize);\n    // System.out.println(\"resultName = \" + resultName + \"; \" +\n    //         \"resultFont = \" + resultFont);\n    previewArea.setFont(resultFont);\n    // ensure Dialog is big enough.\n    pack();\n}\n","name":"previewFont","className":"FontChooser","variables":{"bold":1,"italic":1,"isBold":2,"resultName":2,"attrs":4,"resultFont":1,"resultSizeName":1,"Integer":1,"isItalic":2,"fontNameChoice":1,"previewArea":1,"resultSize":2,"fontSizeChoice":1},"constants":{},"javaDoc":"Called from the action handlers to get the font info build a font and set it","comments":"System out println(\"resultName = \" + resultName + \"; \" + \"resultFont = \" + resultFont); ensure Dialog is big enough  Called from the action handlers to get the font info,\n     * build a font, and set it.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Retrieve the selected font name. */\npublic String getSelectedName() {\n    return resultName;\n}\n","name":"getSelectedName","className":"FontChooser","variables":{"resultName":1},"constants":{},"javaDoc":"Retrieve the selected font name","comments":" Retrieve the selected font name. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Retrieve the selected size */\npublic int getSelectedSize() {\n    return resultSize;\n}\n","name":"getSelectedSize","className":"FontChooser","variables":{"resultSize":1},"constants":{},"javaDoc":"Retrieve the selected size","comments":" Retrieve the selected size ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Font","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Retrieve the selected font, or null */\npublic Font getSelectedFont() {\n    return resultFont;\n}\n","name":"getSelectedFont","className":"FontChooser","variables":{"resultFont":1},"constants":{},"javaDoc":"Retrieve the selected font or null","comments":" Retrieve the selected font, or null ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getDisplayText() {\n    return displayText;\n}\n","name":"getDisplayText","className":"FontChooser","variables":{"displayText":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"previewFont":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public void setDisplayText(String displayText) {\n    this.displayText = displayText;\n    previewArea.setText(displayText);\n    previewFont();\n}\n","name":"setDisplayText","className":"FontChooser","variables":{"displayText":1,"previewArea":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public JList getFontNameChoice() {\n    return fontNameChoice;\n}\n","name":"getFontNameChoice","className":"FontChooser","variables":{"fontNameChoice":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public JList getFontSizeChoice() {\n    return fontSizeChoice;\n}\n","name":"getFontSizeChoice","className":"FontChooser","variables":{"fontSizeChoice":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean isBold() {\n    return isBold;\n}\n","name":"isBold","className":"FontChooser","variables":{"isBold":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean isItalic() {\n    return isItalic;\n}\n","name":"isItalic","className":"FontChooser","variables":{"isItalic":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["File"],"returnType":"FileSaver","methodCalls":{"getAbsolutePath":2,"createNewFile":1,"deleteOnExit":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"BinaryExpr":2,"NameExpr":21,"StringLiteralExpr":2,"FieldAccessExpr":2,"ThisExpr":1,"AssignExpr":4,"MethodCallExpr":4},"statements":{"ExpressionStmt":6},"text":"public FileSaver(File input) throws IOException {\n    // Step 1: Create temp file in right place\n    this.inputFile = input;\n    tmpFile = new File(inputFile.getAbsolutePath() + \".tmp\");\n    tmpFile.createNewFile();\n    tmpFile.deleteOnExit();\n    backupFile = new File(inputFile.getAbsolutePath() + \".bak\");\n    state = State.AVAILABLE;\n}\n","name":"FileSaver","className":"FileSaver","variables":{"input":1,"inputFile":2,"backupFile":1,"state":1,"tmpFile":3},"constants":{"\".tmp\"":1,"\".bak\"":1},"javaDoc":"","comments":"Step 1: Create temp file in right place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"File","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * Return a reference to the contained File object, to\n     * promote reuse (File objects are immutable so this\n     * is at least moderately safe). Typical use would be:\n     * <pre>\n     * if (fileSaver == null ||\n     *   !(fileSaver.getFile().equals(file))) {\n     *        fileSaver = new FileSaver(file);\n     * }\n     * </pre>\n     */\npublic File getFile() {\n    return inputFile;\n}\n","name":"getFile","className":"FileSaver","variables":{"inputFile":1},"constants":{},"javaDoc":"Return a reference to the contained File object to promote reuse (File objects are immutable so this is at least moderately safe) Typical use would be: <pre> if (fileSaver == null || !(fileSaver getFile() equals(file))) { fileSaver = new FileSaver(file); } </pre>","comments":"\n     * Return a reference to the contained File object, to\n     * promote reuse (File objects are immutable so this\n     * is at least moderately safe). Typical use would be:\n     * <pre>\n     * if (fileSaver == null ||\n     *   !(fileSaver.getFile().equals(file))) {\n     *        fileSaver = new FileSaver(file);\n     * }\n     * </pre>\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"OutputStream","methodCalls":{},"annotations":[],"exceptions":["IllegalStateException","IOException"],"concepts":["PolyMorphism"],"types":{"FileOutputStream":1,"OutputStream":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":1,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Return an output file that the client should use to\n     * write the client's data to.\n     * @return An OutputStream, which should be wrapped in a\n     *     buffered OutputStream to ensure reasonable performance.\n     * @throws IOException if the temporary file cannot be written\n     */\npublic OutputStream getOutputStream() throws IOException {\n    if (state != State.AVAILABLE) {\n        throw new IllegalStateException(\"FileSaver not opened\");\n    }\n    OutputStream out = new FileOutputStream(tmpFile);\n    state = State.INUSE;\n    return out;\n}\n","name":"getOutputStream","className":"FileSaver","variables":{"state":2,"tmpFile":1,"out":2},"constants":{"\"FileSaver not opened\"":1},"javaDoc":"Return an output file that the client should use to write the client's data to An OutputStream which should be wrapped in a buffered OutputStream to ensure reasonable performance @throws IOException if the temporary file cannot be written","comments":" Return an output file that the client should use to\n     * write the client's data to.\n     * @return An OutputStream, which should be wrapped in a\n     *     buffered OutputStream to ensure reasonable performance.\n     * @throws IOException if the temporary file cannot be written\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Writer","methodCalls":{},"annotations":[],"exceptions":["IllegalStateException","IOException"],"concepts":["PolyMorphism"],"types":{"FileWriter":1,"Writer":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":1,"FieldAccessExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Return an output file that the client should use to\n     * write the client's data to.\n     * @return A Writer, which should be wrapped in a\n     *     buffered Writer to ensure reasonable performance.\n     * @throws IOException if the temporary file cannot be written\n     */\npublic Writer getWriter() throws IOException {\n    if (state != State.AVAILABLE) {\n        throw new IllegalStateException(\"FileSaver not opened\");\n    }\n    Writer out = new FileWriter(tmpFile);\n    state = State.INUSE;\n    return out;\n}\n","name":"getWriter","className":"FileSaver","variables":{"state":2,"tmpFile":1,"out":2},"constants":{"\"FileSaver not opened\"":1},"javaDoc":"Return an output file that the client should use to write the client's data to A Writer which should be wrapped in a buffered Writer to ensure reasonable performance @throws IOException if the temporary file cannot be written","comments":" Return an output file that the client should use to\n     * write the client's data to.\n     * @return A Writer, which should be wrapped in a\n     *     buffered Writer to ensure reasonable performance.\n     * @throws IOException if the temporary file cannot be written\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"renameTo":2,"exists":1,"delete":1},"annotations":[],"exceptions":["IllegalStateException","IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"BinaryExpr":2,"NameExpr":22,"StringLiteralExpr":3,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":3,"BlockStmt":3,"ThrowStmt":3,"ExpressionStmt":2},"text":"/** Close the output file and rename the temp file to the original name.\n     * @throws IOException If anything goes wrong\n     */\npublic void finish() throws IOException {\n    if (state != State.INUSE) {\n        throw new IllegalStateException(\"FileSaver not in use\");\n    }\n    // Delete the previous backup file if it exists;\n    backupFile.delete();\n    // UNLESS this is a new file ;\n    if (inputFile.exists() && !inputFile.renameTo(backupFile)) {\n        throw new IOException(\"Could not rename file to backup file\");\n    }\n    // Rename the temporary file to the save file.\n    if (!tmpFile.renameTo(inputFile)) {\n        throw new IOException(\"Could not rename temp file to save file\");\n    }\n    state = State.AVAILABLE;\n}\n         // Rename the user's previous file to itsName.bak,\n\n","name":"finish","className":"FileSaver","variables":{"inputFile":2,"backupFile":1,"state":2,"tmpFile":1},"constants":{"\"FileSaver not in use\"":1,"\"Could not rename temp file to save file\"":1,"\"Could not rename file to backup file\"":1},"javaDoc":"Close the output file and rename the temp file to the original name @throws IOException If anything goes wrong","comments":"Rename the user's previous file to itsName bak Delete the previous backup file if it exists; UNLESS this is a new file ; Rename the temporary file to the save file  Close the output file and rename the temp file to the original name.\n     * @throws IOException If anything goes wrong\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["JTextArea"],"returnType":"TextAreaWriter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public TextAreaWriter(final JTextArea textArea) {\n    this.textArea = textArea;\n}\n","name":"TextAreaWriter","className":"TextAreaWriter","variables":{"textArea":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"@Override\npublic void flush() {\n}\n","name":"flush","className":"TextAreaWriter","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"@Override\npublic void close() {\n}\n","name":"close","className":"TextAreaWriter","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char[]","int","int"],"returnType":"void","methodCalls":{"append":1},"annotations":["Override"],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void write(char[] cbuf, int off, int len) throws IOException {\n    textArea.append(new String(cbuf, off, len));\n}\n","name":"write","className":"TextAreaWriter","variables":{"len":1,"cbuf":1,"off":1,"textArea":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"FileIO","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Nobody should need to create an instance; all methods are static */\nprivate FileIO() {\n// Nothing to do\n}\n","name":"FileIO","className":"FileIO","variables":{},"constants":{},"javaDoc":"Nobody should need to create an instance; all methods are static","comments":"Nothing to do  Nobody should need to create an instance; all methods are static ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"copyFile":1,"close":2},"annotations":[],"exceptions":["FileNotFoundException","IOException"],"concepts":["ExceptionHandling","Recursion"],"types":{"BufferedInputStream":1,"BufferedOutputStream":1},"expressions":{"NullLiteralExpr":4,"ObjectCreationExpr":4,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":16,"AssignExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":7},"text":"/** Copy a file from one filename to another */\npublic static void copyFile(String inName, String outName) throws FileNotFoundException, IOException {\n    BufferedInputStream is = null;\n    BufferedOutputStream os = null;\n    try {\n        is = new BufferedInputStream(new FileInputStream(inName));\n        os = new BufferedOutputStream(new FileOutputStream(outName));\n        copyFile(is, os, false);\n    } finally {\n        if (is != null) {\n            is.close();\n        }\n        if (os != null) {\n            os.close();\n        }\n    }\n}\n","name":"copyFile","className":"FileIO","variables":{"os":4,"is":4,"outName":1,"inName":1},"constants":{"null":4,"false":1},"javaDoc":"Copy a file from one filename to another","comments":" Copy a file from one filename to another ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["InputStream","OutputStream","boolean"],"returnType":"void","methodCalls":{"read":1,"write":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"byte[]":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":18,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"/** Copy a file from an opened InputStream to opened OutputStream */\npublic static void copyFile(InputStream is, OutputStream os, boolean close) throws IOException {\n    // the byte read from the file\n    byte[] b = new byte[BLKSIZ];\n    int i;\n    while ((i = is.read(b)) != -1) {\n        os.write(b, 0, i);\n    }\n    is.close();\n    if (close)\n        os.close();\n}\n","name":"copyFile","className":"FileIO","variables":{"BLKSIZ":1,"b":1,"os":2,"i":2,"is":2,"close":1},"constants":{"0":1,"1":1},"javaDoc":"Copy a file from an opened InputStream to opened OutputStream","comments":"the byte read from the file  Copy a file from an opened InputStream to opened OutputStream ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Reader","Writer","boolean"],"returnType":"void","methodCalls":{"read":1,"write":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":15,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/** Copy a file from an opened Reader to opened Writer */\npublic static void copyFile(Reader is, Writer os, boolean close) throws IOException {\n    // the byte read from the file\n    int b;\n    while ((b = is.read()) != -1) {\n        os.write(b);\n    }\n    is.close();\n    if (close)\n        os.close();\n}\n","name":"copyFile","className":"FileIO","variables":{"b":2,"os":2,"is":2,"close":1},"constants":{"1":1},"javaDoc":"Copy a file from an opened Reader to opened Writer","comments":"the byte read from the file  Copy a file from an opened Reader to opened Writer ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","PrintWriter","boolean"],"returnType":"void","methodCalls":{"copyFile":1},"annotations":[],"exceptions":["FileNotFoundException","IOException"],"concepts":["Recursion"],"types":{"BufferedReader":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Copy a file from a filename to a PrintWriter. */\npublic static void copyFile(String inName, PrintWriter pw, boolean close) throws FileNotFoundException, IOException {\n    BufferedReader ir = new BufferedReader(new FileReader(inName));\n    copyFile(ir, pw, close);\n}\n","name":"copyFile","className":"FileIO","variables":{"ir":1,"inName":1},"constants":{},"javaDoc":"Copy a file from a filename to a PrintWriter","comments":" Copy a file from a filename to a PrintWriter. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["File","File"],"returnType":"void","methodCalls":{"getName":1,"read":1,"isFile":1,"canRead":1,"exists":1,"write":1,"close":2,"isDirectory":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"InputStream":1,"OutputStream":1,"File":1,"int":1},"expressions":{"ObjectCreationExpr":4,"NullLiteralExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":4,"NameExpr":40,"StringLiteralExpr":1,"EnclosedExpr":2,"UnaryExpr":4,"ArrayCreationExpr":1,"MethodCallExpr":9,"AssignExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"TryStmt":1,"ThrowStmt":1,"ExpressionStmt":11},"text":"/**\n     * Copy a file to a directory, given File objects representing the files.\n     * @param file File representing the source, must be a single file.\n     * @param target File representing the location, may be file or directory.\n     * @throws IOException\n     */\npublic static void copyFile(File file, File target) throws IOException {\n    if (!file.exists() || !file.isFile() || !(file.canRead())) {\n        throw new IOException(file + \" is not a readable file\");\n    }\n    File dest = target;\n    if (target.isDirectory()) {\n        dest = new File(dest, file.getName());\n    }\n    InputStream is = null;\n    OutputStream os = null;\n    try {\n        is = new FileInputStream(file);\n        os = new FileOutputStream(dest);\n        // the byte count\n        int count = 0;\n        // the bytes read from the file\n        byte[] b = new byte[BLKSIZ];\n        while ((count = is.read(b)) != -1) {\n            os.write(b, 0, count);\n        }\n    } finally {\n        is.close();\n        os.close();\n    }\n}\n","name":"copyFile","className":"FileIO","variables":{"BLKSIZ":1,"b":1,"file":6,"os":4,"count":2,"is":4,"dest":4,"target":2},"constants":{"0":2,"1":1,"null":2,"\" is not a readable file\"":1},"javaDoc":"Copy a file to a directory given File objects representing the files file File representing the source must be a single file target File representing the location may be file or directory @throws IOException","comments":"the byte count the bytes read from the file \n     * Copy a file to a directory, given File objects representing the files.\n     * @param file File representing the source, must be a single file.\n     * @param target File representing the location, may be file or directory.\n     * @throws IOException\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"read":1,"write":1,"close":2},"annotations":[],"exceptions":["FileNotFoundException","IOException"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"InputStream":1,"OutputStream":1,"int":1},"expressions":{"NullLiteralExpr":4,"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":23,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":1,"BlockStmt":5,"ExpressionStmt":9},"text":"/** Copy a data file from one filename to another, alternative method.\n     * As the name suggests, use my own buffer instead of letting\n     * the BufferedReader allocate and use the buffer.\n     */\npublic void copyFileBuffered(String inName, String outName) throws FileNotFoundException, IOException {\n    InputStream is = null;\n    OutputStream os = null;\n    try {\n        is = new FileInputStream(inName);\n        os = new FileOutputStream(outName);\n        // the byte count\n        int count = 0;\n        // the bytes read from the file\n        byte[] b = new byte[BLKSIZ];\n        while ((count = is.read(b)) != -1) {\n            os.write(b, 0, count);\n        }\n    } finally {\n        if (is != null) {\n            is.close();\n        }\n        if (os != null) {\n            os.close();\n        }\n    }\n}\n","name":"copyFileBuffered","className":"FileIO","variables":{"BLKSIZ":1,"b":1,"os":5,"count":2,"is":5,"outName":1,"inName":1},"constants":{"0":2,"1":1,"null":4},"javaDoc":"Copy a data file from one filename to another alternative method As the name suggests use my own buffer instead of letting the BufferedReader allocate and use the buffer","comments":"the byte count the bytes read from the file  Copy a data file from one filename to another, alternative method.\n     * As the name suggests, use my own buffer instead of letting\n     * the BufferedReader allocate and use the buffer.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["File","File","boolean"],"returnType":"void","methodCalls":{"copyFile":1,"getName":1,"isFile":1,"copyRecursively":1,"mkdirs":1,"format":3,"exists":2,"System.err.println":1,"listFiles":1,"isDirectory":1,"printf":1},"annotations":[],"exceptions":["IOException"],"concepts":["Recursion"],"types":{"File":2},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":53,"StringLiteralExpr":5,"FieldAccessExpr":1,"UnaryExpr":2,"MethodCallExpr":14},"statements":{"IfStmt":5,"BlockStmt":7,"ForeachStmt":1,"ThrowStmt":2,"ExpressionStmt":6},"text":"/**\n     * Copy all objects found in and under \"fromdir\", to their places in \"todir\".\n     * @param fromDir\n     * @param toDir\n     * @throws IOException\n     */\npublic static void copyRecursively(File fromDir, File toDir, boolean create) throws IOException {\n    Debug.printf(\"fileio\", \"copyRecursively(%s, %s%n\", fromDir, toDir);\n    if (!fromDir.exists()) {\n        throw new IOException(String.format(\"Source directory %s does not exist\", fromDir));\n    }\n    if (create) {\n        toDir.mkdirs();\n    } else if (!toDir.exists()) {\n        throw new IOException(String.format(\"Destination dir %s must exist\", toDir));\n    }\n    for (File src : fromDir.listFiles()) {\n        if (src.isDirectory()) {\n            File destSubDir = new File(toDir, src.getName());\n            copyRecursively(src, destSubDir, true);\n        } else if (src.isFile()) {\n            copyFile(src, toDir);\n        } else {\n            System.err.println(String.format(\"Warning: %s is neither file nor directory\", src));\n        }\n    }\n}\n","name":"copyRecursively","className":"FileIO","variables":{"fromDir":2,"toDir":3,"src":4,"destSubDir":1,"create":1,"String":3,"Debug":1},"constants":{"\"copyRecursively(%s, %s%n\"":1,"\"Source directory %s does not exist\"":1,"\"Destination dir %s must exist\"":1,"true":1,"\"Warning: %s is neither file nor directory\"":1,"\"fileio\"":1},"javaDoc":"Copy all objects found in and under \"fromdir\" to their places in \"todir\" fromDir toDir @throws IOException","comments":"\n     * Copy all objects found in and under \"fromdir\", to their places in \"todir\".\n     * @param fromDir\n     * @param toDir\n     * @throws IOException\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["File","File"],"returnType":"void","methodCalls":{"copyRecursively":1},"annotations":[],"exceptions":["IOException"],"concepts":["Recursion"],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void copyRecursively(File fromDir, File toDir) throws IOException {\n    copyRecursively(fromDir, toDir, false);\n}\n","name":"copyRecursively","className":"FileIO","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["File"],"returnType":"void","methodCalls":{"getCanonicalPath":2,"exists":1,"System.err.println":1,"listFiles":2,"delete":2,"isDirectory":1,"startsWith":1,"deleteRecursively":1},"annotations":[],"exceptions":["IOException"],"concepts":["Recursion"],"types":{"String":1,"File":2},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":37,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":3,"BlockStmt":5,"ForeachStmt":2,"ThrowStmt":1,"ExpressionStmt":5},"text":"public static void deleteRecursively(File startDir) throws IOException {\n    String startDirPath = startDir.getCanonicalPath();\n    // Pass one - delete recursively\n    for (File f : startDir.listFiles()) {\n        if (!f.getCanonicalPath().startsWith(startDirPath)) {\n            throw new IOException(\"Attempted to go out of \" + startDir);\n        }\n        if (f.isDirectory()) {\n            deleteRecursively(f);\n        }\n    }\n    // Pass two - delete whatever's left: files and (empty) directories\n    for (File f : startDir.listFiles()) {\n        f.delete();\n        if (f.exists()) {\n            System.err.println(f + \" did not get deleted!\");\n        }\n    }\n    // Pass three - delete the (now empty) starting directory\n    startDir.delete();\n}\n","name":"deleteRecursively","className":"FileIO","variables":{"startDirPath":1,"f":7,"startDir":5},"constants":{"\"Attempted to go out of \"":1,"\" did not get deleted!\"":1},"javaDoc":"","comments":"Pass one - delete recursively Pass two - delete whatever's left: files and (empty) directories Pass three - delete the (now empty) starting directory ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["JarFile","JarEntry","File"],"returnType":"void","methodCalls":{"copyFile":1,"entries":1,"getName":2,"hasMoreElements":1,"copyRecursively":1,"format":2,"exists":1,"getInputStream":1,"close":2,"isDirectory":2,"nextElement":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling","Recursion"],"types":{"InputStream":1,"OutputStream":1,"JarEntry":1,"Enumeration<JarEntry>":1},"expressions":{"ObjectCreationExpr":5,"NullLiteralExpr":4,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":56,"StringLiteralExpr":2,"UnaryExpr":2,"MethodCallExpr":15,"AssignExpr":2},"statements":{"IfStmt":5,"WhileStmt":1,"BlockStmt":7,"TryStmt":1,"ThrowStmt":2,"ExpressionStmt":10},"text":"/**\n     * Copy a tree of files to directory, given File objects representing the files.\n     * @param base File representing the source, must be a single file.\n     * @param startingDir\n     * @param toDir File representing the location, may be file or directory.\n     * @throws IOException \n     */\npublic static void copyRecursively(JarFile base, JarEntry startingDir, File toDir) throws IOException {\n    if (!startingDir.isDirectory()) {\n        throw new IOException(String.format(\"Starting point %s is not a directory\", startingDir));\n    }\n    if (!toDir.exists()) {\n        throw new IOException(String.format(\"Destination dir %s must exist\", toDir));\n    }\n    Enumeration<JarEntry> all = base.entries();\n    while (all.hasMoreElements()) {\n        JarEntry file = all.nextElement();\n        // XXX ensure that it matches starting dir\n        if (file.isDirectory()) {\n            copyRecursively(base, file, new File(toDir, file.getName()));\n        } else {\n            InputStream is = null;\n            OutputStream os = null;\n            try {\n                is = base.getInputStream(file);\n                os = new FileOutputStream(new File(toDir, file.getName()));\n                copyFile(is, os, false);\n            } finally {\n                if (os != null)\n                    os.close();\n                if (is != null)\n                    is.close();\n            }\n        }\n    }\n}\n","name":"copyRecursively","className":"FileIO","variables":{"all":3,"file":4,"toDir":3,"os":4,"startingDir":1,"is":4,"String":2,"base":2},"constants":{"\"Starting point %s is not a directory\"":1,"\"Destination dir %s must exist\"":1,"null":4,"false":1},"javaDoc":"Copy a tree of files to directory given File objects representing the files base File representing the source must be a single file startingDir toDir File representing the location may be file or directory @throws IOException","comments":"XXX ensure that it matches starting dir \n     * Copy a tree of files to directory, given File objects representing the files.\n     * @param base File representing the source, must be a single file.\n     * @param startingDir\n     * @param toDir File representing the location, may be file or directory.\n     * @throws IOException \n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"readLine":1,"close":2},"annotations":[],"exceptions":["FileNotFoundException","IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1},"expressions":{"NullLiteralExpr":3,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":14,"AssignExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":6},"text":"/** Open a file and read the first line from it. */\npublic static String readLine(String inName) throws FileNotFoundException, IOException {\n    BufferedReader is = null;\n    try {\n        is = new BufferedReader(new FileReader(inName));\n        String line = null;\n        line = is.readLine();\n        is.close();\n        return line;\n    } finally {\n        if (is != null)\n            is.close();\n    }\n}\n","name":"readLine","className":"FileIO","variables":{"line":3,"is":6,"inName":1},"constants":{"null":3},"javaDoc":"Open a file and read the first line from it","comments":" Open a file and read the first line from it. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Reader"],"returnType":"String","methodCalls":{"read":1,"toString":1,"append":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"StringBuilder":1,"int":1,"char[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":14,"EnclosedExpr":1,"ArrayCreationExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/** Read the entire content of a Reader into a String;\n     * of course Readers should only be used for text files;\n     * please do not use this to read a JPEG file, for example.\n     */\npublic static String readerToString(Reader is) throws IOException {\n    StringBuilder sb = new StringBuilder();\n    char[] b = new char[BLKSIZ];\n    int n;\n    // Read a block. If it gets any chars, append them.\n    while ((n = is.read(b)) > 0) {\n        sb.append(b, 0, n);\n    }\n    // Only construct the String object once, here.\n    return sb.toString();\n}\n","name":"readerToString","className":"FileIO","variables":{"BLKSIZ":1,"b":1,"is":1,"n":2,"sb":3},"constants":{"0":2},"javaDoc":"Read the entire content of a Reader into a String; of course Readers should only be used for text files; please do not use this to read a JPEG file for example","comments":"Read a block If it gets any chars append them Only construct the String object once here  Read the entire content of a Reader into a String;\n     * of course Readers should only be used for text files;\n     * please do not use this to read a JPEG file, for example.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["InputStream"],"returnType":"String","methodCalls":{"readerToString":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Read the content of a Stream into a String */\npublic static String inputStreamToString(InputStream is) throws IOException {\n    return readerToString(new InputStreamReader(is));\n}\n","name":"inputStreamToString","className":"FileIO","variables":{"is":1},"constants":{},"javaDoc":"Read the content of a Stream into a String","comments":" Read the content of a Stream into a String ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"readerToString":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public static String readAsString(String filename) throws IOException {\n    return readerToString(new FileReader(filename));\n}\n","name":"readAsString","className":"FileIO","variables":{"filename":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"flush":1,"write":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"BufferedWriter":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":11,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"/** Write a String as the entire content of a File */\npublic static void stringToFile(String text, String fileName) throws IOException {\n    BufferedWriter os = new BufferedWriter(new FileWriter(fileName));\n    os.write(text);\n    os.flush();\n    os.close();\n}\n","name":"stringToFile","className":"FileIO","variables":{"fileName":1,"os":4},"constants":{},"javaDoc":"Write a String as the entire content of a File","comments":" Write a String as the entire content of a File ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"BufferedReader","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Open a BufferedReader from a named file. */\npublic static BufferedReader openFile(String fileName) throws IOException {\n    return new BufferedReader(new FileReader(fileName));\n}\n","name":"openFile","className":"FileIO","variables":{"fileName":1},"constants":{},"javaDoc":"Open a BufferedReader from a named file","comments":" Open a BufferedReader from a named file. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["JTextArea"],"returnType":"TextAreaOutputStream","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public TextAreaOutputStream(final JTextArea textArea) {\n    this.textArea = textArea;\n}\n","name":"TextAreaOutputStream","className":"TextAreaOutputStream","variables":{"textArea":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"@Override\npublic void flush() {\n}\n","name":"flush","className":"TextAreaOutputStream","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"@Override\npublic void close() {\n}\n","name":"close","className":"TextAreaOutputStream","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"setLength":1,"toString":1,"append":2},"annotations":["Override"],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":15,"CastExpr":1,"CharLiteralExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"@Override\npublic void write(int b) throws IOException {\n    if (b == '\\r')\n        return;\n    if (b == '\\n') {\n        textArea.append(sb.toString());\n        sb.setLength(0);\n    }\n    sb.append((char) b);\n}\n","name":"write","className":"TextAreaOutputStream","variables":{"b":3,"textArea":1,"sb":3},"constants":{"0":1,"'\\r'":1,"'\\n'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"equals":1,"check":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LinkStatus":1,"KwikLinkChecker":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":21,"StringLiteralExpr":1,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ContinueStmt":1,"IfStmt":2,"BlockStmt":2,"ForeachStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    KwikLinkChecker checker = new KwikLinkChecker();\n    for (String arg : args) {\n        if (arg.equals(\"-v\")) {\n            verbose = true;\n            continue;\n        }\n        LinkStatus stat = checker.check(arg);\n        if (verbose || !stat.ok)\n            System.out.println(stat.message);\n    }\n}\n","name":"main","className":"KwikLinkChecker","variables":{"args":1,"stat":1,"arg":2,"checker":2,"verbose":2},"constants":{"\"-v\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"LinkStatus","methodCalls":{"disconnect":1,"openConnection":1,"getResponseCode":1,"toString":1,"setFollowRedirects":1,"getInputStream":1},"annotations":[],"exceptions":["SocketException","UnknownHostException","IllegalArgumentException | MalformedURLException","FileNotFoundException","IOException","Exception","ConnectException"],"concepts":["ExceptionHandling"],"types":{"HttpURLConnection":1,"URL":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":12,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BooleanLiteralExpr":12,"BinaryExpr":10,"NameExpr":33,"CastExpr":1,"StringLiteralExpr":8,"MethodCallExpr":6,"AssignExpr":2},"statements":{"SwitchStmt":1,"IfStmt":1,"TryStmt":1,"BlockStmt":10,"SwitchEntryStmt":3,"ReturnStmt":11,"ExpressionStmt":7},"text":"/**\n     * Check one HTTP link; not recursive. Returns a LinkStatus with\n     * boolean success, and the filename or an error message in the\n     * message part of the LinkStatus.  The end of this method is one of\n     * the few places where a whole raft of different \"catch\" clauses is\n     * actually needed for the intent of the program.\n     */\npublic LinkStatus check(String urlString) {\n    URL url;\n    HttpURLConnection conn = null;\n    HttpURLConnection.setFollowRedirects(false);\n    try {\n        url = new URL(urlString);\n        conn = (HttpURLConnection) url.openConnection();\n        switch(conn.getResponseCode()) {\n            case 200:\n                return new LinkStatus(true, urlString);\n            case 403:\n                return new LinkStatus(false, \"403: \" + urlString);\n            case 404:\n                return new LinkStatus(false, \"404: \" + urlString);\n        }\n        conn.getInputStream();\n        return new LinkStatus(true, urlString);\n    } catch (IllegalArgumentException | MalformedURLException e) {\n        return new LinkStatus(false, \"Malformed URL: \" + urlString);\n    } catch (UnknownHostException e) {\n        return new LinkStatus(false, \"Host invalid/dead: \" + urlString);\n    } catch (FileNotFoundException e) {\n        return new LinkStatus(false, \"NOT FOUND (404) \" + urlString);\n    } catch (ConnectException e) {\n        return new LinkStatus(false, \"Server not listening: \" + urlString);\n    } catch (SocketException e) {\n        return new LinkStatus(false, e + \": \" + urlString);\n    } catch (IOException e) {\n        return new LinkStatus(false, e.toString());\n    } catch (Exception e) {\n        return new LinkStatus(false, \"Unexpected exception! \" + e);\n    } finally {\n        if (conn != null) {\n            conn.disconnect();\n        }\n    }\n}\n             // Oracle JDK throws IAE if host can't be determined from URL string\n\n                                                         // includes failing URL\n\n","name":"check","className":"KwikLinkChecker","variables":{"conn":6,"HttpURLConnection":1,"e":10,"urlString":10,"url":3},"constants":{"\"Server not listening: \"":1,"\"Host invalid/dead: \"":1,"false":10,"\"404: \"":1,"\": \"":1,"\"403: \"":1,"\"Unexpected exception! \"":1,"200":1,"null":2,"403":1,"true":2,"404":1,"\"NOT FOUND (404) \"":1,"\"Malformed URL: \"":1},"javaDoc":"Check one HTTP link; not recursive Returns a LinkStatus with boolean success and the filename or an error message in the message part of the LinkStatus The end of this method is one of the few places where a whole raft of different \"catch\" clauses is actually needed for the intent of the program","comments":"Oracle JDK throws IAE if host can't be determined from URL string includes failing URL \n     * Check one HTTP link; not recursive. Returns a LinkStatus with\n     * boolean success, and the filename or an error message in the\n     * message part of the LinkStatus.  The end of this method is one of\n     * the few places where a whole raft of different \"catch\" clauses is\n     * actually needed for the intent of the program.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"contains":1,"selfTest":1,"get":1,"accumulateXrefs":1,"keySet":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"String":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":32,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":5,"TryStmt":1,"ForeachStmt":2,"ExpressionStmt":4},"text":"public static void main(String[] args) throws Exception {\n    selfTest(VERBOSE_SELFTEST);\n    for (String file : args) {\n        try {\n            accumulateXrefs(file, VERBOSE_RUN);\n        } catch (Exception e) {\n            System.out.println(e + \" in file \" + file);\n        }\n    }\n    for (String s : refs.keySet()) {\n        if (!decls.contains(s)) {\n            System.out.println(refs.get(s) + \" use of undeclared ref \" + s);\n        }\n    }\n}\n","name":"main","className":"XrefCheck","variables":{"args":1,"file":2,"s":2,"e":2,"refs":2,"decls":1},"constants":{"\" use of undeclared ref \"":1,"\" in file \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{"find":2,"matcher":2,"System.out.println":2,"group":3},"annotations":[],"exceptions":["IllegalStateException"],"concepts":[],"types":{"Matcher":2,"int":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":37,"StringLiteralExpr":7,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":10},"statements":{"IfStmt":4,"WhileStmt":1,"BlockStmt":3,"ThrowStmt":2,"ExpressionStmt":7},"text":"// END main\npublic static void selfTest(boolean verbose) {\n    Matcher md = decl.matcher(\"[[dog-chapter]]\");\n    md.find();\n    if (verbose)\n        System.out.println(\"DECL: \" + md.group(1));\n    if (!\"dog-chapter\".equals(md.group(1))) {\n        throw new IllegalStateException(\"Failed to match decl\");\n    }\n    Matcher mr = ref.matcher(\"see woof <<dog-chapter>> or meow <<cat_chapter>>.\");\n    int i = 0;\n    while (mr.find()) {\n        ++i;\n        if (verbose)\n            System.out.println(\"REF: \" + mr.group(1));\n    }\n    if (i != 2) {\n        throw new IllegalStateException(\"Failed to match 2 xrefs\");\n    }\n}\n","name":"selfTest","className":"XrefCheck","variables":{"ref":1,"decl":1,"mr":3,"md":4,"i":3,"verbose":2},"constants":{"0":1,"\"DECL: \"":1,"1":3,"2":1,"\"dog-chapter\"":1,"\"REF: \"":1,"\"Failed to match 2 xrefs\"":1,"\"[[dog-chapter]]\"":1,"\"see woof <<dog-chapter>> or meow <<cat_chapter>>.\"":1,"\"Failed to match decl\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","boolean"],"returnType":"void","methodCalls":{"add":1,"find":2,"length":1,"readLine":1,"matcher":2,"put":1,"startsWith":1,"System.out.println":3,"group":4},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Matcher":1,"BufferedReader":1,"String":2,"int":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":2,"IntegerLiteralExpr":6,"VariableDeclarationExpr":5,"BinaryExpr":7,"NameExpr":67,"StringLiteralExpr":5,"FieldAccessExpr":3,"EnclosedExpr":1,"UnaryExpr":2,"AssignExpr":3,"MethodCallExpr":16},"statements":{"ContinueStmt":3,"IfStmt":5,"WhileStmt":2,"TryStmt":1,"BlockStmt":6,"ExpressionStmt":12},"text":"public static void accumulateXrefs(String fileName, boolean verbose) throws Exception {\n    Matcher md, mr;\n    try (BufferedReader is = new BufferedReader(new FileReader(fileName))) {\n        String line = null;\n        int lineNumber = 0;\n        while ((line = is.readLine()) != null) {\n            ++lineNumber;\n            if (line.length() == 0) {\n                continue;\n            }\n            // Decls occur on a line by themselves\n            if (line.startsWith(\"[[\")) {\n                md = decl.matcher(line);\n                if (!md.find()) {\n                    System.out.println(\"Misformed label: \" + line);\n                    continue;\n                }\n                decls.add(md.group(1));\n                if (verbose)\n                    System.out.println(\"decl:\" + md.group(1));\n                continue;\n            }\n            // Not a decl, see if any refs in this line\n            mr = ref.matcher(line);\n            while (mr.find()) {\n                String ref = mr.group(1);\n                refs.put(ref, fileName + \":\" + lineNumber);\n                if (verbose)\n                    System.out.println(\"ref: \" + mr.group(1));\n            }\n        }\n    }\n}\n","name":"accumulateXrefs","className":"XrefCheck","variables":{"fileName":2,"ref":2,"decl":1,"mr":5,"refs":1,"line":5,"md":5,"decls":1,"is":2,"lineNumber":3,"verbose":2},"constants":{"0":2,"\"[[\"":1,"1":4,"\"ref: \"":1,"\"decl:\"":1,"null":2,"\"Misformed label: \"":1,"\":\"":1},"javaDoc":"","comments":"Decls occur on a line by themselves Not a decl see if any refs in this line ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void setOkToExit(final boolean setting) {\n    okToExit = setting;\n}\n","name":"setOkToExit","className":"SQLRunner","variables":{"okToExit":1,"setting":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public static boolean isOkToExit() {\n    return okToExit;\n}\n","name":"isOkToExit","className":"SQLRunner","variables":{"okToExit":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":1},"text":"public static void exit(final int exitStatus) {\n    if (okToExit) {\n        System.exit(exitStatus);\n    } else {\n    // do nothing\n    }\n}\n","name":"exit","className":"SQLRunner","variables":{"okToExit":1,"System":1},"constants":{},"javaDoc":"","comments":"do nothing ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","String","String","String","String"],"returnType":"SQLRunner","methodCalls":{"getConnection":1,"commonSetup":1},"annotations":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"concepts":[],"types":{},"expressions":{"NameExpr":12,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Construct a SQLRunner object\n     * @param driver String for the JDBC driver\n     * @param dbUrl String for the JDBC URL\n     * @param user String for the username\n     * @param password String for the password, normally in cleartext\n     * @param outputMode One of the MODE_XXX constants.\n     * @throws ClassNotFoundException\n     * @throws SQLException\n     */\npublic SQLRunner(String driver, String dbUrl, String user, String password, String outputFile, String outputMode) throws IOException, ClassNotFoundException, SQLException {\n    conn = ConnectionUtil.getConnection(driver, dbUrl, user, password);\n    commonSetup(outputFile, outputMode);\n}\n","name":"SQLRunner","className":"SQLRunner","variables":{"conn":1,"ConnectionUtil":1},"constants":{},"javaDoc":"Construct a SQLRunner object driver String for the JDBC driver dbUrl String for the JDBC URL user String for the username password String for the password normally in cleartext outputMode One of the MODE_XXX constants @throws ClassNotFoundException @throws SQLException","comments":" Construct a SQLRunner object\n     * @param driver String for the JDBC driver\n     * @param dbUrl String for the JDBC URL\n     * @param user String for the username\n     * @param password String for the password, normally in cleartext\n     * @param outputMode One of the MODE_XXX constants.\n     * @throws ClassNotFoundException\n     * @throws SQLException\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Connection","String","String"],"returnType":"SQLRunner","methodCalls":{"commonSetup":1},"annotations":[],"exceptions":["SQLException","IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public SQLRunner(Connection c, String outputFile, String outputModeName) throws IOException, SQLException {\n    // set up the SQL input\n    conn = c;\n    commonSetup(outputFile, outputModeName);\n}\n","name":"SQLRunner","className":"SQLRunner","variables":{"conn":1,"c":1},"constants":{},"javaDoc":"","comments":"set up the SQL input ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"createStatement":1,"setOutputMode":1,"getDatabaseProductName":2,"getMetaData":1,"indexOf":1,"System.out.println":1},"annotations":[],"exceptions":["SQLException","IOException"],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":33,"StringLiteralExpr":2,"FieldAccessExpr":2,"AssignExpr":5,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":8},"text":"private void commonSetup(String outputFileName, String outputModeName) throws IOException, SQLException {\n    dbMeta = conn.getMetaData();\n    upperCaseTableNames = dbMeta.getDatabaseProductName().indexOf(\"DB2\") >= 0;\n    String dbName = dbMeta.getDatabaseProductName();\n    System.out.println(\"SQLRunner: Connected to \" + dbName);\n    statement = conn.createStatement();\n    if (outputFileName == null) {\n        out = new PrintWriter(System.out);\n    } else {\n        out = new PrintWriter(new FileWriter(outputFileName));\n    }\n    setOutputMode(outputModeName);\n}\n","name":"commonSetup","className":"SQLRunner","variables":{"conn":2,"outputFileName":2,"upperCaseTableNames":1,"dbName":2,"statement":1,"dbMeta":3,"out":2},"constants":{"0":1,"null":1,"\"SQLRunner: Connected to \"":1,"\"DB2\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"setOutputMode":1,"valueOf":1,"length":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":5,"NameExpr":18,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/** Set the output mode.\n     * @param outputMode Must be a value equal to one of the MODE_XXX values.\n     * @throws IllegalArgumentException if the mode is not valid.\n     */\nvoid setOutputMode(String outputModeName) {\n    if (outputModeName == null || outputModeName.length() == 0) {\n        System.err.println(\"invalid mode: \" + outputMode + \"; must be t, h or s\");\n    }\n    outputMode = OutputMode.valueOf(outputModeName);\n    setOutputMode(outputMode);\n}\n","name":"setOutputMode","className":"SQLRunner","variables":{"OutputMode":1,"outputMode":2,"outputModeName":2},"constants":{"0":1,"\"invalid mode: \"":1,"null":1,"\"; must be t, h or s\"":1},"javaDoc":"Set the output mode outputMode Must be a value equal to one of the MODE_XXX values @throws IllegalArgumentException if the mode is not valid","comments":" Set the output mode.\n     * @param outputMode Must be a value equal to one of the MODE_XXX values.\n     * @throws IllegalArgumentException if the mode is not valid.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["OutputMode"],"returnType":"void","methodCalls":{"setWriter":1,"print":2,"println":1,"values":1,"getJTable":1,"System.err.println":1,"System.out.println":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"OutputMode":1,"ResultsDecorator":1},"expressions":{"NullLiteralExpr":6,"ObjectCreationExpr":5,"VariableDeclarationExpr":2,"BinaryExpr":9,"NameExpr":70,"StringLiteralExpr":4,"FieldAccessExpr":2,"CharLiteralExpr":1,"AssignExpr":10,"MethodCallExpr":8},"statements":{"SwitchStmt":1,"IfStmt":7,"BreakStmt":5,"BlockStmt":7,"SwitchEntryStmt":6,"ForeachStmt":1,"ThrowStmt":1,"ExpressionStmt":17},"text":"/** Assign the correct ResultsDecorator, creating them on the fly\n     * using lazy evaluation.\n     */\nvoid setOutputMode(OutputMode outputMode) {\n    ResultsDecorator newDecorator = null;\n    switch(outputMode) {\n        case t:\n            newDecorator = textDecorator;\n            break;\n        case h:\n            if (htmlDecorator == null) {\n                htmlDecorator = new ResultsDecoratorHTML(out, verbosity);\n            }\n            newDecorator = htmlDecorator;\n            break;\n        case s:\n            if (sqlDecorator == null) {\n                sqlDecorator = new ResultsDecoratorSQL(out, verbosity);\n            }\n            newDecorator = sqlDecorator;\n            break;\n        case x:\n            if (xmlDecorator == null) {\n                xmlDecorator = new ResultsDecoratorXML(out, verbosity);\n            }\n            newDecorator = xmlDecorator;\n            break;\n        case j:\n            if (jtableDecorator == null) {\n                if (gui == null) {\n                    throw new IllegalArgumentException(\"Can't set mode to JTable before calling setGUI()\");\n                }\n                jtableDecorator = new ResultsDecoratorJTable(gui.getJTable(), out, verbosity);\n            }\n            newDecorator = jtableDecorator;\n            break;\n        default:\n            System.err.println(\"invalid mode: \" + outputMode + \"; must be one of: \");\n            for (OutputMode t : OutputMode.values()) {\n                out.print(t);\n                out.print(' ');\n            }\n            out.println();\n    }\n    if (currentDecorator != newDecorator) {\n        currentDecorator = newDecorator;\n        if (debug)\n            System.out.println(\"Mode set to  \" + outputMode);\n    }\n    currentDecorator.setWriter(out);\n}\n","name":"setOutputMode","className":"SQLRunner","variables":{"debug":1,"newDecorator":8,"OutputMode":1,"h":1,"xmlDecorator":3,"sqlDecorator":3,"j":1,"outputMode":3,"out":7,"htmlDecorator":3,"s":1,"t":2,"textDecorator":1,"jtableDecorator":3,"x":1,"currentDecorator":3,"gui":2,"verbosity":4},"constants":{"\"Mode set to  \"":1,"\"invalid mode: \"":1,"null":6,"\"Can't set mode to JTable before calling setGUI()\"":1,"' '":1,"\"; must be one of: \"":1},"javaDoc":"Assign the correct ResultsDecorator creating them on the fly using lazy evaluation","comments":" Assign the correct ResultsDecorator, creating them on the fly\n     * using lazy evaluation.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"runScript":1},"annotations":["Deprecated"],"exceptions":["SQLException","SyntaxException","IOException"],"concepts":["Recursion"],"types":{"BufferedReader":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"/** Run one script file, by name. Called from cmd line main\n     * or from user code. Deprecated because of the poor capability\n     * for error handling; it would be better for the user interface\n     * code to create a Reader and then say:\n     * <pre>while ((stmt = SQLRunner.getStatement(is)) != null) {\n            stmt = stmt.trim();\n            try {\n                myRunner.runStatement(stmt);\n            } catch (Exception e) {\n                // Display the message to the user ...\n            }\n        }\n     * </pre>\n     * @throws SyntaxException\n     */\n@Deprecated\npublic void runScript(String scriptFile) throws IOException, SQLException, SyntaxException {\n    BufferedReader is;\n    // Load the script file first, it's the most likely error\n    is = new BufferedReader(new FileReader(scriptFile));\n    runScript(is, scriptFile);\n}\n","name":"runScript","className":"SQLRunner","variables":{"is":2,"scriptFile":1},"constants":{},"javaDoc":"Run one script file by name Called from cmd line main or from user code Deprecated because of the poor capability for error handling; it would be better for the user interface code to create a Reader and then say: <pre>while ((stmt = SQLRunner getStatement(is)) != null) { stmt = stmt trim(); try { myRunner runStatement(stmt); } catch (Exception e) { // Display the message to the user } } </pre> @throws SyntaxException","comments":"Load the script file first it's the most likely error  Run one script file, by name. Called from cmd line main\n     * or from user code. Deprecated because of the poor capability\n     * for error handling; it would be better for the user interface\n     * code to create a Reader and then say:\n     * <pre>while ((stmt = SQLRunner.getStatement(is)) != null) {\n            stmt = stmt.trim();\n            try {\n                myRunner.runStatement(stmt);\n            } catch (Exception e) {\n                // Display the message to the user ...\n            }\n        }\n     * </pre>\n     * @throws SyntaxException\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BufferedReader","String"],"returnType":"void","methodCalls":{"trim":1,"getStatement":1,"runStatement":1},"annotations":["Deprecated"],"exceptions":["SQLException","SyntaxException","IOException"],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/** Run one script, by name, given a BufferedReader.\n     * Deprecated because of the poor capability\n     * for error handling; it would be better for the\n     * user interface code to do:\n     * <pre>while ((stmt = SQLRunner.getStatement(is)) != null) {\n            stmt = stmt.trim();\n            try {\n                myRunner.runStatement(stmt);\n            } catch (Exception e) {\n                // Display the message to the user ...\n            }\n        }\n     * </pre>\n     * @throws SyntaxException\n     */\n@Deprecated\npublic void runScript(BufferedReader is, String name) throws IOException, SQLException, SyntaxException {\n    String stmt;\n    while ((stmt = getStatement(is)) != null) {\n        stmt = stmt.trim();\n        runStatement(stmt);\n    }\n}\n","name":"runScript","className":"SQLRunner","variables":{"stmt":4},"constants":{"null":1},"javaDoc":"Run one script by name given a BufferedReader Deprecated because of the poor capability for error handling; it would be better for the user interface code to do: <pre>while ((stmt = SQLRunner getStatement(is)) != null) { stmt = stmt trim(); try { myRunner runStatement(stmt); } catch (Exception e) { // Display the message to the user } } </pre> @throws SyntaxException","comments":" Run one script, by name, given a BufferedReader.\n     * Deprecated because of the poor capability\n     * for error handling; it would be better for the\n     * user interface code to do:\n     * <pre>while ((stmt = SQLRunner.getStatement(is)) != null) {\n            stmt = stmt.trim();\n            try {\n                myRunner.runStatement(stmt);\n            } catch (Exception e) {\n                // Display the message to the user ...\n            }\n        }\n     * </pre>\n     * @throws SyntaxException\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"exit":1,"setOutputMode":1,"display":1,"length":1,"substring":1,"setOutputFile":1,"startsWith":4},"annotations":[],"exceptions":["SQLException","SyntaxException","IOException"],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":4,"IntegerLiteralExpr":3,"ObjectCreationExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":34,"StringLiteralExpr":8,"MethodCallExpr":10,"AssignExpr":1},"statements":{"IfStmt":8,"BlockStmt":9,"ThrowStmt":4,"ExpressionStmt":6},"text":"/**\n     * Process an escape, like \"\\ms;\" for mode=sql.\n     * @throws SyntaxException\n     */\nprivate void doEscape(String str) throws IOException, SQLException, SyntaxException {\n    String rest = null;\n    if (str.length() > 2) {\n        rest = str.substring(2);\n    }\n    if (str.startsWith(\"\\\\d\")) {\n        // Display\n        if (rest == null) {\n            throw new SyntaxException(\"\\\\d needs display arg\");\n        }\n        display(rest);\n    } else if (str.startsWith(\"\\\\m\")) {\n        // MODE\n        if (rest == null) {\n            throw new SyntaxException(\"\\\\m needs output mode arg\");\n        }\n        setOutputMode(rest);\n    } else if (str.startsWith(\"\\\\o\")) {\n        if (rest == null) {\n            throw new SyntaxException(\"\\\\o needs output file arg\");\n        }\n        setOutputFile(rest);\n    } else if (str.startsWith(\"\\\\q\")) {\n        exit(0);\n    } else {\n        throw new SyntaxException(\"Unknown escape: \" + str);\n    }\n}\n","name":"doEscape","className":"SQLRunner","variables":{"str":7,"rest":5},"constants":{"0":1,"2":2,"null":4,"\"Unknown escape: \"":1,"\"\\\\q\"":1,"\"\\\\d\"":1,"\"\\\\d needs display arg\"":1,"\"\\\\m needs output mode arg\"":1,"\"\\\\m\"":1,"\"\\\\o\"":1,"\"\\\\o needs output file arg\"":1},"javaDoc":"Process an escape like \"\\ms;\" for mode=sql @throws SyntaxException","comments":"Display MODE \n     * Process an escape, like \"\\ms;\" for mode=sql.\n     * @throws SyntaxException\n     ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"setWriter":1,"substring":1,"getColumns":1,"displayTable":1,"flush":2,"trim":1,"getTables":1,"equals":1,"toUpperCase":1,"getMetaData":2,"write":1,"startsWith":1,"System.out.println":1},"annotations":[],"exceptions":["SQLException","SyntaxException","IOException"],"concepts":[],"types":{"ResultSet":2,"String":1,"DatabaseMetaData":2},"expressions":{"NullLiteralExpr":4,"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayInitializerExpr":1,"BinaryExpr":3,"NameExpr":55,"StringLiteralExpr":9,"FieldAccessExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":15,"AssignExpr":1},"statements":{"IfStmt":3,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":12},"text":"/**\n     * Display - generate output for \\dt and similar escapes\n     * @param rest - what to display - the argument with the \\d stripped off\n     * XXX: Move more formatting to ResultsDecorator: listTables(rs), listColumns(rs)\n     */\nprivate void display(String rest) throws IOException, SQLException, SyntaxException {\n    // setOutputMode(OutputMode.t);\n    if (rest.equals(\"t\")) {\n        // Display list of tables\n        DatabaseMetaData md = conn.getMetaData();\n        ResultSet rs = md.getTables(null, null, \"%\", new String[] { \"TABLE\", \"VIEW\" });\n        textDecorator.setWriter(out);\n        textDecorator.write(rs);\n        textDecorator.flush();\n    } else if (rest.startsWith(\"t\")) {\n        // Display one table. Some DatabaseMetaData implementations\n        // don't do ignorecase so, for now, convert to UPPERCASE.\n        String tableName = rest.substring(1).trim();\n        if (upperCaseTableNames) {\n            tableName = tableName.toUpperCase();\n        }\n        System.out.println(\"-- Display table \" + tableName);\n        DatabaseMetaData md = conn.getMetaData();\n        ResultSet rs = md.getColumns(null, null, tableName, \"%\");\n        currentDecorator.displayTable(tableName, rs);\n        textDecorator.flush();\n    } else\n        throw new SyntaxException(\"\\\\d\" + rest + \" invalid\");\n}\n","name":"display","className":"SQLRunner","variables":{"rest":4,"rs":2,"conn":2,"textDecorator":4,"md":4,"upperCaseTableNames":1,"currentDecorator":1,"tableName":4},"constants":{"\"t\"":2,"1":1,"null":4,"\" invalid\"":1,"\"TABLE\"":1,"\"VIEW\"":1,"\"\\\\d\"":1,"\"-- Display table \"":1,"\"%\"":2},"javaDoc":"Display - generate output for \\dt and similar escapes rest - what to display - the argument with the \\d stripped off XXX: Move more formatting to ResultsDecorator: listTables(rs) listColumns(rs)","comments":"setOutputMode(OutputMode t); Display list of tables Display one table Some DatabaseMetaData implementations don't do ignorecase so for now convert to UPPERCASE \n     * Display - generate output for \\dt and similar escapes\n     * @param rest - what to display - the argument with the \\d stripped off\n     * XXX: Move more formatting to ResultsDecorator: listTables(rs), listColumns(rs)\n     ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["ResultSet"],"returnType":"CachedRowSet","methodCalls":{"populate":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"CachedRowSet":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n     * @param rs\n     * @return\n     * @throws SQLException\n     */\nprivate static CachedRowSet cacheResultSet(ResultSet rs) throws SQLException {\n    //new com.sun.rowset.WebRowSetImpl();\n    CachedRowSet rows = null;\n    rows.populate(rs);\n    return rows;\n}\n","name":"cacheResultSet","className":"SQLRunner","variables":{"rows":3},"constants":{"null":1},"javaDoc":"rs @throws SQLException","comments":"new com sun rowset WebRowSetImpl(); \n     * @param rs\n     * @return\n     * @throws SQLException\n     ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getCanonicalPath":1,"setOutputFile":2,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["Recursion"],"types":{"File":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/** Set the output to the given filename.\n     * @param fileName\n     */\npublic void setOutputFile(String fileName) throws IOException {\n    if (fileName == null) {\n        /* Set the output file back to System.out */\n        setOutputFile(new PrintWriter(System.out, true));\n    } else {\n        File file = new File(fileName);\n        setOutputFile(new PrintWriter(new FileWriter(file), true));\n        System.out.println(\"Output set to \" + file.getCanonicalPath());\n    }\n}\n","name":"setOutputFile","className":"SQLRunner","variables":{"fileName":2,"file":3},"constants":{"null":1,"\"Output set to \"":1,"true":2},"javaDoc":"Set the output to the given filename fileName","comments":"Set the output file back to System out  Set the output to the given filename.\n     * @param fileName\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{"setWriter":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Set the output to the given Writer; immediately \n     * update the textDecorator so \\dt works...\n     * @param writer\n     */\npublic void setOutputFile(PrintWriter writer) {\n    out = writer;\n    currentDecorator.setWriter(out);\n}\n","name":"setOutputFile","className":"SQLRunner","variables":{"currentDecorator":1,"writer":1,"out":1},"constants":{},"javaDoc":"Set the output to the given Writer; immediately update the textDecorator so \\dt works writer","comments":" Set the output to the given Writer; immediately \n     * update the textDecorator so \\dt works...\n     * @param writer\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":2,"trim":1,"flush":2,"doEscape":1,"getResultSet":1,"printRowCount":2,"format":1,"getUpdateCount":1,"execute":1,"write":1,"cacheResultSet":1,"startsWith":1},"annotations":[],"exceptions":["SQLException","SyntaxException","IOException"],"concepts":["FinalVariables"],"types":{"boolean":1,"String":1,"int":1},"expressions":{"VariableDeclarationExpr":3,"BinaryExpr":6,"BooleanLiteralExpr":2,"NameExpr":63,"StringLiteralExpr":4,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":15,"AssignExpr":2},"statements":{"IfStmt":4,"BlockStmt":5,"ReturnStmt":1,"ExpressionStmt":12},"text":"/** Run one Statement, and format results as per Update or Query.\n     * Called from runScript or from user code.\n     * @throws SyntaxException\n     */\npublic void runStatement(final String rawString) throws IOException, SQLException, SyntaxException {\n    final String inString = rawString.trim();\n    if (verbosity != Verbosity.QUIET) {\n        out.println(\"Executing : <<\" + inString + \">>\");\n        out.flush();\n    }\n    currentDecorator.println(String.format(\"-- output from command -- \\\"%s\\\"%n\", inString));\n    escape = false;\n    if (inString.startsWith(\"\\\\\")) {\n        escape = true;\n        doEscape(inString);\n        return;\n    }\n    boolean hasResultSet = // DO IT - call the database.\n    statement.execute(inString);\n    if (!hasResultSet) {\n        currentDecorator.printRowCount(statement.getUpdateCount());\n    } else {\n        int n = currentDecorator.write(cacheResultSet(statement.getResultSet()));\n        if (verbosity == Verbosity.VERBOSE || verbosity == Verbosity.DEBUG) {\n            currentDecorator.printRowCount(n);\n        }\n    }\n    currentDecorator.flush();\n}\n","name":"runStatement","className":"SQLRunner","variables":{"rawString":1,"inString":3,"hasResultSet":2,"currentDecorator":5,"statement":3,"String":1,"escape":2,"verbosity":3,"n":1,"out":2},"constants":{"\">>\"":1,"\"\\\\\"":1,"\"Executing : <<\"":1,"false":1,"true":1,"\"-- output from command -- \\\"%s\\\"%n\"":1},"javaDoc":"Run one Statement and format results as per Update or Query Called from runScript or from user code @throws SyntaxException","comments":"DO IT - call the database  Run one Statement, and format results as per Update or Query.\n     * Called from runScript or from user code.\n     * @throws SyntaxException\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BufferedReader"],"returnType":"String","methodCalls":{"setLength":1,"trim":1,"length":3,"toString":1,"readLine":1,"append":2,"charAt":1,"System.out.println":1,"startsWith":3},"annotations":[],"exceptions":["IOException","IllegalArgumentException"],"concepts":[],"types":{"StringBuilder":1,"String":1,"int":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":4,"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"BinaryExpr":14,"NameExpr":57,"StringLiteralExpr":5,"FieldAccessExpr":2,"CharLiteralExpr":2,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":14},"statements":{"ContinueStmt":2,"IfStmt":7,"WhileStmt":1,"BlockStmt":8,"ThrowStmt":1,"ReturnStmt":3,"ExpressionStmt":8},"text":"/** Extract one statement from the given Reader.\n     * Ignore comments and null lines.\n     * @return The SQL statement, up to but not including the ';' character.\n     * May be null if no statement found.\n     */\npublic static String getStatement(BufferedReader is) throws IOException {\n    StringBuilder sb = new StringBuilder();\n    String line;\n    while ((line = is.readLine()) != null) {\n        if (verbosity == Verbosity.DEBUG) {\n            System.out.println(\"SQLRunner.getStatement(): LINE \" + line);\n        }\n        if (line == null || line.length() == 0) {\n            continue;\n        }\n        line = line.trim();\n        if (line.startsWith(\"#\") || line.startsWith(\"--\")) {\n            continue;\n        }\n        if (line.startsWith(\"\\\\\")) {\n            if (sb.length() != 0) {\n                throw new IllegalArgumentException(\"Escape command found inside statement\");\n            }\n        }\n        sb.append(line);\n        int nb = sb.length();\n        // If the buffer currently ends with ';', return it.\n        if (nb > 0 && sb.charAt(nb - 1) == ';') {\n            if (nb == 1) {\n                return null;\n            }\n            sb.setLength(nb - 1);\n            return sb.toString();\n        }\n        // Add a space in case the SQL is generated by a tool\n        // that doesn't remember to add spaces (hopefully this won't\n        // break tools that output newlines inside quoted strings!).\n        sb.append(' ');\n    }\n    return null;\n}\n","name":"getStatement","className":"SQLRunner","variables":{"nb":5,"line":10,"is":1,"verbosity":1,"sb":8},"constants":{"0":3,"\"--\"":1,"\"\\\\\"":1,"\"#\"":1,"1":3,"\"SQLRunner.getStatement(): LINE \"":1,"';'":1,"null":4,"\"Escape command found inside statement\"":1,"' '":1},"javaDoc":"Extract one statement from the given Reader Ignore comments and null lines The SQL statement up to but not including the ';' character May be null if no statement found","comments":"Add a space in case the SQL is generated by a tool that doesn't remember to add spaces (hopefully this won't If the buffer currently ends with ';' return it break tools that output newlines inside quoted strings!)  Extract one statement from the given Reader.\n     * Ignore comments and null lines.\n     * @return The SQL statement, up to but not including the ';' character.\n     * May be null if no statement found.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"flush":1,"close":3},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":2,"NameExpr":14,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":4},"text":"public void close() throws SQLException {\n    if (statement != null) {\n        statement.close();\n    }\n    if (conn != null) {\n        conn.close();\n    }\n    out.flush();\n    out.close();\n}\n","name":"close","className":"SQLRunner","variables":{"conn":2,"statement":2,"out":2},"constants":{"null":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Verbosity","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public static Verbosity getVerbosity() {\n    return verbosity;\n}\n","name":"getVerbosity","className":"SQLRunner","variables":{"verbosity":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Verbosity"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void setVerbosity(Verbosity verbosity) {\n    SQLRunner.verbosity = verbosity;\n}\n","name":"setVerbosity","className":"SQLRunner","variables":{"verbosity":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["SQLRunnerErrorHandler"],"returnType":"void","methodCalls":{"setErrorHandler":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setErrorHandler(SQLRunnerErrorHandler eHandler) {\n    gui.setErrorHandler(eHandler);\n}\n","name":"setErrorHandler","className":"SQLRunner","variables":{"gui":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["SQLRunnerGUI"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setGUI(SQLRunnerGUI gui) {\n    this.gui = gui;\n}\n","name":"setGUI","className":"SQLRunner","variables":{"gui":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"sqlrunner\";\n}\n","name":"toString","className":"SQLRunner","variables":{},"constants":{"\"sqlrunner\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean isEscape() {\n    return escape;\n}\n","name":"isEscape","className":"SQLRunner","variables":{"escape":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter","Verbosity"],"returnType":"ResultsDecoratorText","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public ResultsDecoratorText(PrintWriter out, Verbosity v) {\n    super(out, v);\n}\n","name":"ResultsDecoratorText","className":"ResultsDecoratorText","variables":{"v":1,"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ResultSet"],"returnType":"int","methodCalls":{"next":1,"print":2,"println":2,"getColumnName":1,"getColumnCount":1,"getString":1,"getMetaData":1},"annotations":["Override"],"exceptions":["SQLException","IOException"],"concepts":[],"types":{"ResultSetMetaData":1,"int":4},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":4,"NameExpr":33,"StringLiteralExpr":2,"UnaryExpr":3,"MethodCallExpr":9},"statements":{"WhileStmt":1,"BlockStmt":3,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":8},"text":"@Override\npublic int write(ResultSet rs) throws IOException, SQLException {\n    ResultSetMetaData md = rs.getMetaData();\n    int colCount = md.getColumnCount();\n    for (int i = 1; i <= colCount; i++) {\n        print(md.getColumnName(i) + \"\\t\");\n    }\n    println();\n    int rowCount = 0;\n    while (rs.next()) {\n        ++rowCount;\n        for (int i = 1; i <= colCount; i++) {\n            print(rs.getString(i) + \"\\t\");\n        }\n        println();\n    }\n    return rowCount;\n}\n","name":"write","className":"ResultsDecoratorText","variables":{"rs":3,"md":3,"colCount":3,"i":6,"rowCount":3},"constants":{"0":1,"1":2,"\"\\t\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","ResultSet"],"returnType":"void","methodCalls":{"write":1},"annotations":["Override"],"exceptions":["SQLException","IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void displayTable(String table, ResultSet rs) throws IOException, SQLException {\n    write(rs);\n}\n","name":"displayTable","className":"ResultsDecoratorText","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"println":1},"annotations":["Override"],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void printRowCount(int rowCount) throws IOException {\n    println(\"Rows: \" + rowCount);\n}\n","name":"printRowCount","className":"ResultsDecoratorText","variables":{"rowCount":1},"constants":{"\"Rows: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/* (non-Javadoc)\n     * @see ResultsDecorator#getName()\n     */\n@Override\npublic String getName() {\n    return \"Plain text\";\n}\n","name":"getName","className":"ResultsDecoratorText","variables":{},"constants":{"\"Plain text\"":1},"javaDoc":"","comments":" (non-Javadoc)\n     * @see ResultsDecorator#getName()\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter","Verbosity"],"returnType":"ResultsDecoratorHTML","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public ResultsDecoratorHTML(PrintWriter out, Verbosity v) {\n    super(out, v);\n}\n","name":"ResultsDecoratorHTML","className":"ResultsDecoratorHTML","variables":{"v":1,"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ResultSet"],"returnType":"int","methodCalls":{"next":1,"println":4,"print":6,"getColumnLabel":1,"getColumnCount":1,"getString":1,"getMetaData":1},"annotations":[],"exceptions":["SQLException","IOException"],"concepts":[],"types":{"ResultSetMetaData":1,"int":4},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":2,"NameExpr":45,"StringLiteralExpr":8,"UnaryExpr":3,"MethodCallExpr":15},"statements":{"WhileStmt":1,"BlockStmt":3,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":14},"text":"public int write(ResultSet rs) throws IOException, SQLException {\n    ResultSetMetaData md = rs.getMetaData();\n    int colCount = md.getColumnCount();\n    println(\"<table border=1>\");\n    print(\"<tr>\");\n    for (int i = 1; i <= colCount; i++) {\n        print(\"<th>\");\n        print(md.getColumnLabel(i));\n    }\n    println(\"</tr>\");\n    int rowCount = 0;\n    while (rs.next()) {\n        ++rowCount;\n        print(\"<tr>\");\n        for (int i = 1; i <= colCount; i++) {\n            print(\"<td>\");\n            print(rs.getString(i));\n        }\n        println(\"</tr>\");\n    }\n    println(\"</table>\");\n    return rowCount;\n}\n","name":"write","className":"ResultsDecoratorHTML","variables":{"rs":3,"md":3,"colCount":3,"i":6,"rowCount":3},"constants":{"0":1,"\"<table border=1>\"":1,"1":2,"\"<tr>\"":2,"\"</tr>\"":2,"\"<td>\"":1,"\"<th>\"":1,"\"</table>\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","ResultSet"],"returnType":"void","methodCalls":{"write":1},"annotations":["Override"],"exceptions":["SQLException","IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void displayTable(String table, ResultSet rs) throws IOException, SQLException {\n    write(rs);\n}\n","name":"displayTable","className":"ResultsDecoratorHTML","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return a printable name for this decorator\n     * @see ResultsDecorator#getName()\n     */\npublic String getName() {\n    return \"HTML\";\n}\n","name":"getName","className":"ResultsDecoratorHTML","variables":{},"constants":{"\"HTML\"":1},"javaDoc":"Return a printable name for this decorator @see ResultsDecorator#getName()","comments":" Return a printable name for this decorator\n     * @see ResultsDecorator#getName()\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter","Verbosity"],"returnType":"ResultsDecorator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"ResultsDecorator(PrintWriter wr, Verbosity v) {\n    this.out = wr;\n    this.verbosity = v;\n}\n","name":"ResultsDecorator","className":"ResultsDecorator","variables":{"v":1,"wr":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/** Print the name of this Decorator's output format */\npublic abstract String getName();\n","name":"getName","className":"ResultsDecorator","variables":{},"constants":{},"javaDoc":"Print the name of this Decorator's output format","comments":" Print the name of this Decorator's output format ","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":["ResultSet"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":["SQLException","IOException"],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/** Print the contents of a ResultSet */\npublic abstract int write(ResultSet rs) throws IOException, SQLException;\n","name":"write","className":"ResultsDecorator","variables":{},"constants":{},"javaDoc":"Print the contents of a ResultSet","comments":" Print the contents of a ResultSet ","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":["String","ResultSet"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["SQLException","IOException"],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/** Print the resultset as a table info */\npublic abstract void displayTable(String table, ResultSet rs) throws IOException, SQLException;\n","name":"displayTable","className":"ResultsDecorator","variables":{},"constants":{},"javaDoc":"Print the resultset as a table info","comments":" Print the resultset as a table info ","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void printRowCount(int n) throws IOException {\n    out.println(\"Row Count = \" + n);\n}\n","name":"printRowCount","className":"ResultsDecorator","variables":{"n":1,"out":1},"constants":{"\"Row Count = \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void println(String line) throws IOException {\n    out.println(line);\n}\n","name":"println","className":"ResultsDecorator","variables":{"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void println() throws IOException {\n    out.println();\n}\n","name":"println","className":"ResultsDecorator","variables":{"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"print":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void print(String lineSeg) throws IOException {\n    out.print(lineSeg);\n}\n","name":"print","className":"ResultsDecorator","variables":{"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"flush":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void flush() {\n    out.flush();\n}\n","name":"flush","className":"ResultsDecorator","variables":{"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setWriter(PrintWriter out) {\n    this.out = out;\n}\n","name":"setWriter","className":"ResultsDecorator","variables":{"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \"main program\" method - construct and show */\npublic static void main(String[] av) {\n    // create a BusCard object, tell it to show up\n    new BusCard().setVisible(true);\n}\n","name":"main","className":"BusCard","variables":{},"constants":{"true":1},"javaDoc":"\"main program\" method - construct and show","comments":"create a BusCard object tell it to show up  \"main program\" method - construct and show ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"setVisible":1,"exit":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":7,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void windowClosing(WindowEvent e) {\n    setVisible(false);\n    dispose();\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BusCard","methodCalls":{"setVisible":1,"setJMenuBar":1,"add":14,"addActionListener":1,"mkMenuItem":1,"getContentPane":1,"setTitle":1,"setLayout":3,"getString":7,"pack":1,"getBundle":1,"addWindowListener":1,"exit":2,"addItem":1,"mkMenu":5,"dispose":1,"setFont":2,"setText":5},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"JPanel":2,"Container":1,"ResourceBundle":1,"String":1,"JMenuItem":1,"JMenuBar":1,"JMenu":1,"int":1},"expressions":{"ObjectCreationExpr":16,"IntegerLiteralExpr":15,"NullLiteralExpr":3,"VariableDeclarationExpr":9,"BooleanLiteralExpr":1,"BinaryExpr":5,"NameExpr":197,"StringLiteralExpr":26,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":49,"AssignExpr":12},"statements":{"IfStmt":1,"BlockStmt":3,"ExpressionStmt":55,"DoStmt":1},"text":"/** Construct the object including its GUI */\npublic BusCard() {\n    Container cp = getContentPane();\n    cp.setLayout(new GridLayout(0, 1));\n    addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            setVisible(false);\n            dispose();\n            System.exit(0);\n        }\n    });\n    JMenuBar mb = new JMenuBar();\n    setJMenuBar(mb);\n    ResourceBundle b = ResourceBundle.getBundle(\"i18n.BusCard\");\n    JMenu aMenu;\n    aMenu = I18N.mkMenu(b, \"filemenu\");\n    mb.add(aMenu);\n    JMenuItem mi = I18N.mkMenuItem(b, \"filemenu\", \"exit\");\n    aMenu.add(mi);\n    mi.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    aMenu = I18N.mkMenu(b, \"editmenu\");\n    mb.add(aMenu);\n    aMenu = I18N.mkMenu(b, \"viewmenu\");\n    mb.add(aMenu);\n    aMenu = I18N.mkMenu(b, \"optionsmenu\");\n    mb.add(aMenu);\n    aMenu = I18N.mkMenu(b, \"helpmenu\");\n    mb.add(aMenu);\n    //mb.setHelpMenu(aMenu);        // needed for portability (Motif, etc.).\n    setTitle(I18N.getString(b, \"card\" + \".company\", \"TITLE\"));\n    JPanel p1 = new JPanel();\n    p1.setLayout(new GridLayout(0, 1, 50, 10));\n    nameTF = new JLabel(\"My Name\", JLabel.CENTER);\n    nameTF.setFont(new Font(\"helvetica\", Font.BOLD, 18));\n    nameTF.setText(I18N.getString(b, \"card\" + \".myname\", \"MYNAME\"));\n    p1.add(nameTF);\n    jobChoice = new JComboBox<>();\n    jobChoice.setFont(new Font(\"helvetica\", Font.BOLD, 14));\n    // Get Job Titles from the Properties file loaded into \"b\"!\n    String next;\n    int i = 1;\n    do {\n        next = I18N.getString(b, \"job_title\" + i++, null);\n        if (next != null)\n            jobChoice.addItem(next);\n    } while (next != null);\n    p1.add(jobChoice);\n    cp.add(p1);\n    JPanel p2 = new JPanel();\n    p2.setLayout(new GridLayout(2, 2, 10, 10));\n    B1 = new JButton();\n    B1.setText(I18N.getString(b, \"button1.label\", \"BUTTON LABEL\"));\n    p2.add(B1);\n    B2 = new JButton();\n    B2.setText(I18N.getString(b, \"button2.label\", \"BUTTON LABEL\"));\n    p2.add(B2);\n    B3 = new JButton();\n    B3.setText(I18N.getString(b, \"button3.label\", \"BUTTON LABEL\"));\n    p2.add(B3);\n    B4 = new JButton();\n    B4.setText(I18N.getString(b, \"button4.label\", \"BUTTON LABEL\"));\n    p2.add(B4);\n    cp.add(p2);\n    pack();\n}\n","name":"BusCard","className":"BusCard","variables":{"next":4,"p1":4,"b":1,"nameTF":3,"p2":6,"jobChoice":3,"e":2,"i":2,"cp":4,"System":2,"B1":2,"B2":2,"actionPerformed":1,"B3":2,"B4":2,"windowClosing":1,"mb":6,"ResourceBundle":1,"aMenu":7,"mi":2,"I18N":13},"constants":{"\"viewmenu\"":1,"\"button4.label\"":1,"\"button2.label\"":1,"\"button1.label\"":1,"\"button3.label\"":1,"\"filemenu\"":2,"\"My Name\"":1,"\"helvetica\"":2,"\"card\"":2,"\"MYNAME\"":1,"\"TITLE\"":1,"\"BUTTON LABEL\"":4,"50":1,"\".company\"":1,"10":3,"14":1,"\"job_title\"":1,"18":1,"false":1,"\"exit\"":1,"0":4,"1":3,"\"editmenu\"":1,"2":2,"\"helpmenu\"":1,"null":3,"\".myname\"":1,"\"i18n.BusCard\"":1,"\"optionsmenu\"":1},"javaDoc":"Construct the object including its GUI","comments":"mb setHelpMenu(aMenu); // needed for portability (Motif etc ) Get Job Titles from the Properties file loaded into \"b\"!  Construct the object including its GUI ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getDisplayName":2,"format":3,"getDateInstance":3,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Locale":2,"DateFormat":3,"Date":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":6,"BinaryExpr":6,"NameExpr":56,"StringLiteralExpr":3,"FieldAccessExpr":7,"CharLiteralExpr":3,"MethodCallExpr":11},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    // predefined\n    Locale frLocale = Locale.FRANCE;\n    // English, UK version\n    Locale ukLocale = new Locale(\"en\", \"UK\");\n    DateFormat defaultDateFormatter = DateFormat.getDateInstance(DateFormat.MEDIUM);\n    DateFormat frDateFormatter = DateFormat.getDateInstance(DateFormat.MEDIUM, frLocale);\n    DateFormat ukDateFormatter = DateFormat.getDateInstance(DateFormat.MEDIUM, ukLocale);\n    Date now = new Date();\n    System.out.println(\"Default: \" + ' ' + defaultDateFormatter.format(now));\n    System.out.println(frLocale.getDisplayName() + ' ' + frDateFormatter.format(now));\n    System.out.println(ukLocale.getDisplayName() + ' ' + ukDateFormatter.format(now));\n}\n","name":"main","className":"UseLocales","variables":{"frDateFormatter":2,"defaultDateFormatter":2,"DateFormat":3,"now":1,"ukDateFormatter":2,"frLocale":2,"ukLocale":2},"constants":{"\"en\"":1,"\"Default: \"":1,"\"UK\"":1,"' '":3},"javaDoc":"","comments":"predefined English UK version ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":10,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    String result = MessageFormat.format(\"At {0,time} on {0,date}, {1} {2}.\", data);\n    System.out.println(result);\n}\n","name":"main","className":"MessageFormatDemo","variables":{"result":1,"MessageFormat":1},"constants":{"\"At {0,time} on {0,date}, {1} {2}.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showMessageDialog":1,"getString":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    JOptionPane.showMessageDialog(JOptionDemo.this, rb.getString(\"dialog1.text\"), rb.getString(\"dialog1.title\"), JOptionPane.INFORMATION_MESSAGE);\n}\n","name":"actionPerformed","className":"","variables":{"rb":2,"JOptionDemo":1,"JOptionPane":1},"constants":{"\"dialog1.text\"":1,"\"dialog1.title\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"JOptionDemo","methodCalls":{"add":2,"mkButton":2,"exit":1,"showMessageDialog":1,"setSize":1,"addActionListener":2,"getContentPane":1,"setLayout":1,"getString":2,"pack":1,"getBundle":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Container":1,"JButton":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"NameExpr":57,"StringLiteralExpr":5,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":15,"AssignExpr":2},"statements":{"BlockStmt":2,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":13},"text":"// Constructor\nJOptionDemo(String s) {\n    super(s);\n    Container cp = getContentPane();\n    cp.setLayout(new FlowLayout());\n    rb = ResourceBundle.getBundle(\"Widgets\");\n    JButton b = I18N.mkButton(rb, \"getButton\");\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            JOptionPane.showMessageDialog(JOptionDemo.this, rb.getString(\"dialog1.text\"), rb.getString(\"dialog1.title\"), JOptionPane.INFORMATION_MESSAGE);\n        }\n    });\n    cp.add(b);\n    b = I18N.mkButton(rb, \"goodbye\");\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    cp.add(b);\n    // the main window\n    setSize(200, 150);\n    pack();\n}\n","name":"JOptionDemo","className":"JOptionDemo","variables":{"rb":3,"actionPerformed":2,"b":4,"s":1,"e":2,"JOptionDemo":1,"ResourceBundle":1,"cp":4,"JOptionPane":1,"System":1,"I18N":2},"constants":{"0":1,"200":1,"\"getButton\"":1,"\"dialog1.text\"":1,"\"dialog1.title\"":1,"150":1,"\"Widgets\"":1,"\"goodbye\"":1},"javaDoc":"","comments":"the main window  Constructor","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JOptionDemo":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] arg) {\n    JOptionDemo x = new JOptionDemo(\"Testing 1 2 3...\");\n    x.setVisible(true);\n}\n","name":"main","className":"JOptionDemo","variables":{"x":2},"constants":{"true":1,"\"Testing 1 2 3...\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \"main program\" method - construct and show */\npublic static void main(String[] av) {\n    // create an MenuIntl object, tell it to show up\n    new MenuIntl().setVisible(true);\n}\n","name":"main","className":"MenuIntl","variables":{},"constants":{"true":1},"javaDoc":"\"main program\" method - construct and show","comments":"create an MenuIntl object tell it to show up  \"main program\" method - construct and show ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"ThisExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent e) {\n    MenuIntl.this.setVisible(false);\n    MenuIntl.this.dispose();\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"MenuIntl":2,"System":1},"constants":{"0":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MenuIntl","methodCalls":{"add":12,"setJMenuBar":1,"addActionListener":1,"mkMenuItem":8,"getContentPane":1,"setTitle":1,"setLayout":1,"getString":2,"pack":1,"getBundle":1,"exit":1,"setSize":1,"mkMenu":3,"setDefaultCloseOperation":1,"setText":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"Container":1,"JLabel":2,"ResourceBundle":1,"String":2,"JMenuItem":1,"JMenuBar":1,"JMenu":3},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":3,"VariableDeclarationExpr":11,"BinaryExpr":2,"BooleanLiteralExpr":1,"StringLiteralExpr":28,"NameExpr":131,"ThisExpr":2,"MethodCallExpr":38,"AssignExpr":13},"statements":{"TryStmt":2,"BlockStmt":5,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":38},"text":"/** Construct the object including its GUI */\npublic MenuIntl() {\n    super(\"MenuIntlTest\");\n    // used in various spots\n    JMenuItem mi;\n    Container cp = getContentPane();\n    cp.setLayout(new FlowLayout());\n    JLabel lab;\n    cp.add(lab = new JLabel());\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    JMenuBar mb = new JMenuBar();\n    setJMenuBar(mb);\n    ResourceBundle b = ResourceBundle.getBundle(\"i18n.Widgets\");\n    String titlebar;\n    try {\n        titlebar = b.getString(\"program\" + \".title\");\n    } catch (MissingResourceException e) {\n        titlebar = \"MenuIntl Demo\";\n    }\n    setTitle(titlebar);\n    String message;\n    try {\n        message = b.getString(\"program\" + \".message\");\n    } catch (MissingResourceException e) {\n        message = \"Welcome to the world of Java\";\n    }\n    lab.setText(message);\n    JMenu fm = mkMenu(b, \"file\");\n    // In finished code there would be a call to\n    // mi.addActionListener(...) after *each* of\n    // these mkMenuItem calls!\n    fm.add(mi = mkMenuItem(b, \"file\", \"open\"));\n    fm.add(mi = mkMenuItem(b, \"file\", \"new\"));\n    fm.add(mi = mkMenuItem(b, \"file\", \"save\"));\n    fm.add(mi = mkMenuItem(b, \"file\", \"exit\"));\n    mi.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            MenuIntl.this.setVisible(false);\n            MenuIntl.this.dispose();\n            System.exit(0);\n        }\n    });\n    mb.add(fm);\n    JMenu vm = mkMenu(b, \"view\");\n    vm.add(mi = mkMenuItem(b, \"view\", \"tree\"));\n    vm.add(mi = mkMenuItem(b, \"view\", \"list\"));\n    vm.add(mi = mkMenuItem(b, \"view\", \"longlist\"));\n    mb.add(vm);\n    JMenu hm = mkMenu(b, \"help\");\n    hm.add(mi = mkMenuItem(b, \"help\", \"about\"));\n    // mb.setHelpMenu(hm);    // needed for portability (Motif, etc.).\n    // the main window\n    JLabel jl = new JLabel(\"Menu Demo Window\");\n    jl.setSize(200, 150);\n    cp.add(jl);\n    pack();\n}\n","name":"MenuIntl","className":"MenuIntl","variables":{"b":3,"jl":2,"MenuIntl":2,"e":3,"hm":2,"fm":5,"lab":3,"message":3,"cp":4,"System":1,"titlebar":3,"actionPerformed":1,"mb":3,"vm":4,"ResourceBundle":1,"mi":10},"constants":{"\".title\"":1,"\"open\"":1,"\"save\"":1,"\"about\"":1,"\".message\"":1,"\"Menu Demo Window\"":1,"\"i18n.Widgets\"":1,"false":1,"\"list\"":1,"\"program\"":2,"\"MenuIntl Demo\"":1,"150":1,"\"MenuIntlTest\"":1,"\"exit\"":1,"\"view\"":4,"0":1,"\"longlist\"":1,"\"help\"":2,"200":1,"\"new\"":1,"\"file\"":5,"\"Welcome to the world of Java\"":1,"\"tree\"":1},"javaDoc":"Construct the object including its GUI","comments":"In finished code there would be a call to mi addActionListener( ) after each of mb setHelpMenu(hm); // needed for portability (Motif etc ) used in various spots these mkMenuItem calls! the main window  Construct the object including its GUI ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ResourceBundle","String"],"returnType":"JMenu","methodCalls":{"getString":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Convenience routine to make a JMenu */\npublic JMenu mkMenu(ResourceBundle b, String name) {\n    String menuLabel;\n    try {\n        menuLabel = b.getString(name + \".label\");\n    } catch (MissingResourceException e) {\n        menuLabel = name;\n    }\n    return new JMenu(menuLabel);\n}\n","name":"mkMenu","className":"MenuIntl","variables":{"b":1,"e":1,"name":2,"menuLabel":4},"constants":{"\".label\"":1},"javaDoc":"Convenience routine to make a JMenu","comments":" Convenience routine to make a JMenu ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ResourceBundle","String","String"],"returnType":"JMenuItem","methodCalls":{"getString":2,"charAt":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling"],"types":{"String":2},"expressions":{"NullLiteralExpr":3,"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":7,"NameExpr":21,"StringLiteralExpr":4,"AssignExpr":4,"MethodCallExpr":3},"statements":{"IfStmt":1,"TryStmt":2,"BlockStmt":4,"ReturnStmt":2,"ExpressionStmt":6},"text":"/** Convenience routine to make a JMenuItem */\npublic JMenuItem mkMenuItem(ResourceBundle b, String menu, String name) {\n    String miLabel;\n    try {\n        miLabel = b.getString(menu + \".\" + name + \".label\");\n    } catch (MissingResourceException e) {\n        miLabel = name;\n    }\n    String key = null;\n    try {\n        key = b.getString(menu + \".\" + name + \".key\");\n    } catch (MissingResourceException e) {\n        key = null;\n    }\n    if (key == null)\n        return new JMenuItem(miLabel);\n    else\n        return new JMenuItem(miLabel, key.charAt(0));\n}\n","name":"mkMenuItem","className":"MenuIntl","variables":{"b":2,"e":2,"miLabel":5,"name":3,"menu":2,"key":5},"constants":{"\".key\"":1,"0":1,"null":3,"\".\"":2,"\".label\"":1},"javaDoc":"Convenience routine to make a JMenuItem","comments":" Convenience routine to make a JMenuItem ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ResourceBundle","String","String"],"returnType":"String","methodCalls":{"getString":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"private String lookupWithDefault(ResourceBundle rb, String key, String dflt) {\n    try {\n        return rb.getString(key);\n    } catch (MissingResourceException e) {\n        return dflt;\n    }\n}\n","name":"lookupWithDefault","className":"MenuIntl","variables":{"rb":1,"e":1,"dflt":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getAvailableLocales":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Locale":1,"Locale[]":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":10,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    // BEGIN main\n    Locale[] list = Locale.getAvailableLocales();\n    for (Locale loc : list) {\n        System.out.println(loc);\n    }\n// END main\n}\n","name":"main","className":"ListLocales","variables":{"Locale":1,"loc":1,"list":2},"constants":{},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":2,"getInstance":2,"setDefault":2,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"DateFormat":1,"NumberFormat":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"DoubleLiteralExpr":1,"ArrayAccessExpr":2,"NameExpr":41,"StringLiteralExpr":1,"FieldAccessExpr":5,"MethodCallExpr":9},"statements":{"SwitchStmt":1,"BreakStmt":2,"SwitchEntryStmt":4,"ThrowStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    switch(args.length) {\n        case 0:\n            Locale.setDefault(Locale.FRANCE);\n            break;\n        case 1:\n            throw new IllegalArgumentException();\n        case 2:\n            Locale.setDefault(new Locale(args[0], args[1]));\n            break;\n        default:\n            System.out.println(\"Usage: SetLocale [language [country]]\");\n    }\n    DateFormat df = DateFormat.getInstance();\n    NumberFormat nf = NumberFormat.getInstance();\n    System.out.println(df.format(new Date()));\n    System.out.println(nf.format(123.4567));\n}\n             // FALLTHROUGH\n\n","name":"main","className":"SetLocale","variables":{"Locale":2,"args":2,"df":2,"DateFormat":1,"nf":2,"NumberFormat":1},"constants":{"0":2,"1":2,"2":1,"123.4567":1,"\"Usage: SetLocale [language [country]]\"":1},"javaDoc":"","comments":"FALLTHROUGH ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":1,"getString":1,"getBundle":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ResourceBundle":1,"String":2},"expressions":{"VariableDeclarationExpr":3,"NameExpr":18,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    ResourceBundle rb = ResourceBundle.getBundle(\"Widgets\");\n    String format = rb.getString(\"filedialogs.cantopen.format\");\n    String result = MessageFormat.format(format, date, fileName);\n    System.out.println(result);\n}\n","name":"main","className":"MessageFormatDemoIntl","variables":{"rb":2,"result":1,"MessageFormat":1,"format":1,"ResourceBundle":1},"constants":{"\"filedialogs.cantopen.format\"":1,"\"Widgets\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["PrintException","IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) throws IOException, PrintException {\n    new PrintPostScript().print();\n}\n","name":"main","className":"PrintPostScript","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"lookupStreamPrintServiceFactories":1,"add":4,"getClass":1,"print":1,"DocFlavor.BYTE_ARRAY.POSTSCRIPT.getMimeType":1,"createPrintJob":1,"getResourceAsStream":1,"System.err.println":1},"annotations":[],"exceptions":["PrintException","NullPointerException","IOException"],"concepts":["PolyMorphism"],"types":{"StreamPrintServiceFactory[]":1,"SimpleDoc":1,"InputStream":1,"Doc":1,"DocPrintJob":1,"StreamPrintService":1,"DocFlavor":1,"HashPrintRequestAttributeSet":1,"PrintRequestAttributeSet":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":6,"NullLiteralExpr":3,"VariableDeclarationExpr":7,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":62,"StringLiteralExpr":3,"FieldAccessExpr":8,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":13},"text":"public void print() throws IOException, PrintException {\n    DocFlavor inputFlavor = DocFlavor.INPUT_STREAM.TEXT_PLAIN_UTF_8;\n    // Lookup a print factory to convert from desired input to output.\n    StreamPrintServiceFactory[] psfactories = StreamPrintServiceFactory.lookupStreamPrintServiceFactories(inputFlavor, DocFlavor.BYTE_ARRAY.POSTSCRIPT.getMimeType());\n    if (psfactories.length == 0) {\n        System.err.println(\"Ack! No StreamPrintFactory found for this job!\");\n    }\n    StreamPrintService printService = psfactories[0].getPrintService(new FileOutputStream(\"demo.ps\"));\n    PrintRequestAttributeSet attrs = new HashPrintRequestAttributeSet();\n    attrs.add(OrientationRequested.LANDSCAPE);\n    attrs.add(MediaSizeName.NA_LETTER);\n    attrs.add(new Copies(1));\n    attrs.add(new JobName(INPUT_FILE_NAME, null));\n    InputStream is = getClass().getResourceAsStream(INPUT_FILE_NAME);\n    if (is == null) {\n        throw new NullPointerException(\"Input Stream is null: file not found?\");\n    }\n    Doc doc = new SimpleDoc(is, inputFlavor, null);\n    DocPrintJob printJob = printService.createPrintJob();\n    printJob.print(doc, attrs);\n}\n","name":"print","className":"PrintPostScript","variables":{"inputFlavor":2,"printService":2,"INPUT_FILE_NAME":1,"doc":1,"is":3,"printJob":2,"psfactories":2,"StreamPrintServiceFactory":1,"attrs":5},"constants":{"0":2,"1":1,"\"demo.ps\"":1,"null":3,"\"Input Stream is null: file not found?\"":1,"\"Ack! No StreamPrintFactory found for this job!\"":1},"javaDoc":"","comments":"Lookup a print factory to convert from desired input to output ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        new PrintServiceDemo(\"Print Demo\").setVisible(true);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"run","className":"","variables":{"e":2},"constants":{"\"Print Demo\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":1,"invokeLater":1},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":2,"BooleanLiteralExpr":1,"NameExpr":10,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":3,"TryStmt":1,"ExpressionStmt":3},"text":"/** main program: instantiate and show. \n     * @throws IOException */\npublic static void main(String[] av) throws Exception {\n    SwingUtilities.invokeLater(new Runnable() {\n\n        public void run() {\n            try {\n                new PrintServiceDemo(\"Print Demo\").setVisible(true);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    });\n}\n","name":"main","className":"PrintServiceDemo","variables":{"e":2,"run":1,"SwingUtilities":1},"constants":{"\"Print Demo\"":1,"true":1},"javaDoc":"main program: instantiate and show @throws IOException","comments":" main program: instantiate and show. \n     * @throws IOException ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"print":1,"showMessageDialog":1,"printStackTrace":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":3,"FieldAccessExpr":2,"ThisExpr":1,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent e) {\n    System.out.println(\"PrintServiceDemo.PrintServiceDemo...actionPerformed()\");\n    try {\n        print(INPUT_FILE_NAME);\n    } catch (Exception e1) {\n        JOptionPane.showMessageDialog(PrintServiceDemo.this, \"Error: \" + e1, \"Error\", JOptionPane.ERROR_MESSAGE);\n        e1.printStackTrace();\n    }\n}\n","name":"actionPerformed","className":"","variables":{"PrintServiceDemo":1,"e1":3,"JOptionPane":1},"constants":{"\"PrintServiceDemo.PrintServiceDemo...actionPerformed()\"":1,"\"Error: \"":1,"\"Error\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"PrintServiceDemo","methodCalls":{"add":1,"print":1,"showMessageDialog":1,"printStackTrace":1,"addActionListener":1,"center":1,"setDefaultCloseOperation":1,"setLayout":1,"pack":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"JButton":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":43,"StringLiteralExpr":5,"FieldAccessExpr":3,"ThisExpr":2,"MethodCallExpr":11,"AssignExpr":1},"statements":{"BlockStmt":3,"TryStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":12},"text":"/** Constructor for GUI display with pushbutton to print */\nPrintServiceDemo(String title) {\n    super(title);\n    System.out.println(\"PrintServiceDemo.PrintServiceDemo()\");\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    setLayout(new FlowLayout());\n    JButton b;\n    add(b = new JButton(\"Print\"));\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            System.out.println(\"PrintServiceDemo.PrintServiceDemo...actionPerformed()\");\n            try {\n                print(INPUT_FILE_NAME);\n            } catch (Exception e1) {\n                JOptionPane.showMessageDialog(PrintServiceDemo.this, \"Error: \" + e1, \"Error\", JOptionPane.ERROR_MESSAGE);\n                e1.printStackTrace();\n            }\n        }\n    });\n    pack();\n    UtilGUI.center(this);\n}\n","name":"PrintServiceDemo","className":"PrintServiceDemo","variables":{"actionPerformed":1,"b":3,"PrintServiceDemo":1,"UtilGUI":1,"e":1,"title":1,"e1":3,"JOptionPane":1},"constants":{"\"PrintServiceDemo.PrintServiceDemo...actionPerformed()\"":1,"\"Error: \"":1,"\"Error\"":1,"\"PrintServiceDemo.PrintServiceDemo()\"":1,"\"Print\"":1},"javaDoc":"Constructor for GUI display with pushbutton to print","comments":" Constructor for GUI display with pushbutton to print ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1,"getClass":1,"print":1,"showMessageDialog":1,"getResourceAsStream":1,"System.err.println":1,"lookupPrintServices":1,"showOptionDialog":1,"System.out.println":1},"annotations":[],"exceptions":["PrintException","NullPointerException","IOException"],"concepts":["PolyMorphism"],"types":{"SimpleDoc":1,"PrintService[]":1,"InputStream":1,"Doc":1,"DocPrintJob":1,"DocFlavor":1,"HashPrintRequestAttributeSet":1,"int":1,"PrintRequestAttributeSet":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":5,"NullLiteralExpr":3,"VariableDeclarationExpr":7,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":67,"StringLiteralExpr":6,"FieldAccessExpr":9,"ThisExpr":2,"MethodCallExpr":10,"AssignExpr":2},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":2,"BlockStmt":1,"SwitchEntryStmt":3,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":14},"text":"/** Print a file by name \n     * @throws IOException\n     * @throws PrintException \n     */\npublic void print(String fileName) throws IOException, PrintException {\n    System.out.println(\"PrintServiceDemo.print(): Printing \" + fileName);\n    DocFlavor flavor = DocFlavor.INPUT_STREAM.TEXT_PLAIN_UTF_8;\n    PrintRequestAttributeSet aset = new HashPrintRequestAttributeSet();\n    //aset.add(MediaSize.NA.LETTER);\n    aset.add(MediaSizeName.NA_LETTER);\n    //aset.add(new JobName(INPUT_FILE_NAME, null));\n    PrintService[] pservices = PrintServiceLookup.lookupPrintServices(flavor, aset);\n    int i;\n    switch(pservices.length) {\n        case 0:\n            System.err.println(0);\n            JOptionPane.showMessageDialog(PrintServiceDemo.this, \"Error: No PrintService Found\", \"Error\", JOptionPane.ERROR_MESSAGE);\n            return;\n        case 1:\n            // Only one printer, use it.\n            i = 0;\n            break;\n        default:\n            i = JOptionPane.showOptionDialog(this, \"Pick a printer\", \"Choice\", JOptionPane.OK_OPTION, JOptionPane.QUESTION_MESSAGE, null, pservices, pservices[0]);\n            break;\n    }\n    DocPrintJob pj = pservices[i].createPrintJob();\n    InputStream is = getClass().getResourceAsStream(INPUT_FILE_NAME);\n    if (is == null) {\n        throw new NullPointerException(\"Input Stream is null: file not found?\");\n    }\n    Doc doc = new SimpleDoc(is, flavor, null);\n    pj.print(doc, aset);\n}\n","name":"print","className":"PrintServiceDemo","variables":{"flavor":2,"fileName":1,"PrintServiceDemo":1,"PrintServiceLookup":1,"i":4,"doc":1,"pj":2,"is":3,"pservices":3,"aset":2,"JOptionPane":2},"constants":{"0":4,"1":1,"\"Choice\"":1,"\"Error\"":1,"\"Pick a printer\"":1,"null":3,"\"PrintServiceDemo.print(): Printing \"":1,"\"Error: No PrintService Found\"":1,"\"Input Stream is null: file not found?\"":1},"javaDoc":"Print a file by name @throws IOException @throws PrintException","comments":"aset add(MediaSize NA LETTER); aset add(new JobName(INPUT_FILE_NAME null)); Only one printer use it  Print a file by name \n     * @throws IOException\n     * @throws PrintException \n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"String":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"StringLiteralExpr":1,"NameExpr":13,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":3},"text":"public static void main(String argh_my_aching_fingers[]) {\n    // Generate the selective list, with a one-use File object.\n    String[] dirs = new java.io.File(\".\").list(new OnlyJava());\n    // Sort it (Data Structuring chapter))\n    Arrays.sort(dirs);\n    for (String d : dirs) {\n        // Print the list\n        System.out.println(d);\n    }\n}\n","name":"main","className":"FNFilter","variables":{"d":1,"dirs":2,"Arrays":1},"constants":{"\".\"":1},"javaDoc":"","comments":"Generate the selective list with a one-use File object Sort it (Data Structuring chapter)) Print the list ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["File","String"],"returnType":"boolean","methodCalls":{"endsWith":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":9,"StringLiteralExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2},"text":"public boolean accept(File dir, String s) {\n    if (s.endsWith(\".java\") || s.endsWith(\".class\") || s.endsWith(\".jar\")) {\n        return true;\n    }\n    // others: projects, ... ?\n    return false;\n}\n","name":"accept","className":"OnlyJava","variables":{"s":3},"constants":{"\".class\"":1,"\".java\"":1,"true":1,"false":1,"\".jar\"":1},"javaDoc":"","comments":"others: projects ? ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"delete":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"File":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) throws IOException {\n    // Construct a File object for the backup created by editing\n    // this source file. The file probably already exists.\n    // Some text editors create backups by putting ~ at end of filename.\n    File bkup = new File(\"Delete.java~\");\n    // Now, delete it:\n    bkup.delete();\n}\n","name":"main","className":"Delete","variables":{"bkup":2},"constants":{"\"Delete.java~\"":1},"javaDoc":"","comments":"Construct a File object for the backup created by editing this source file The file probably already exists Some text editors create backups by putting ~ at end of filename Now delete it: ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"System.err.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":15,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] argv) throws IOException {\n    // Ensure that a filename (or something) was given in argv[0]\n    if (argv.length == 0) {\n        System.err.println(\"Usage: Creat filename\");\n        System.exit(1);\n    }\n    for (String a : argv) {\n        // Constructing a File object doesn't affect the disk, but\n        // the createNewFile() method does.\n        new File(a).createNewFile();\n    }\n}\n","name":"main","className":"Creat","variables":{"a":2,"argv":1,"System":1},"constants":{"0":1,"1":1,"\"Usage: Creat filename\"":1},"javaDoc":"","comments":"Ensure that a filename (or something) was given in argv[0] Constructing a File object doesn't affect the disk but the createNewFile() method does ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"forEach":1,"get":1,"deleteIfExists":1,"toRealPath":1,"copy":1,"delete":1,"System.out.println":3},"annotations":[],"exceptions":["Exception"],"concepts":["FinalVariables"],"types":{"Path":2,"boolean":1,"InputStream":1,"long":1},"expressions":{"VariableDeclarationExpr":5,"LambdaExpr":1,"NameExpr":42,"StringLiteralExpr":2,"ClassExpr":1,"FieldAccessExpr":3,"MethodCallExpr":10},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) throws Exception {\n    // BEGIN main\n    // <1>\n    Path p = Paths.get(\"my_junk_file\");\n    // <2>\n    boolean deleted = Files.deleteIfExists(p);\n    InputStream // <3>\n    is = PathsFilesDemo.class.getResourceAsStream(\"/demo.txt\");\n    // <4>\n    long newFileSize = Files.copy(is, p);\n    // <5>\n    System.out.println(newFileSize);\n    // <6>\n    final Path realPath = p.toRealPath();\n    System.out.println(realPath);\n    // <7>\n    realPath.forEach( pc -> System.out.println(pc));\n    // <8>\n    Files.delete(p);\n// END main\n}\n","name":"main","className":"PathsFilesDemo","variables":{"p":2,"deleted":1,"pc":1,"is":1,"realPath":2,"Paths":1,"Files":3,"newFileSize":1},"constants":{"\"my_junk_file\"":1,"\"/demo.txt\"":1},"javaDoc":"","comments":"BEGIN main END main <1> <2> <3> <4> <5> <6> <7> <8> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getOptInd":2,"doName":2,"getopt":1,"finder.filter.setSizeFilter":1,"usage":1,"optarg":2,"finder.filter.setNameFilter":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"GetOpt":1,"Find":1,"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":8,"StringLiteralExpr":3,"NameExpr":58,"CharLiteralExpr":2,"UnaryExpr":1,"AssignExpr":1,"FieldAccessExpr":7,"EnclosedExpr":1,"MethodCallExpr":11},"statements":{"SwitchStmt":1,"IfStmt":1,"WhileStmt":1,"BreakStmt":2,"BlockStmt":3,"SwitchEntryStmt":3,"ForStmt":1,"ExpressionStmt":9},"text":"/** Main program */\npublic static void main(String[] args) {\n    Find finder = new Find();\n    GetOpt argHandler = new GetOpt(\"n:s:\");\n    int c;\n    while ((c = argHandler.getopt(args)) != GetOpt.DONE) {\n        switch(c) {\n            case 'n':\n                finder.filter.setNameFilter(argHandler.optarg());\n                break;\n            case 's':\n                finder.filter.setSizeFilter(argHandler.optarg());\n                break;\n            default:\n                System.out.println(\"Got: \" + c);\n                usage();\n        }\n    }\n    if (args.length == 0 || argHandler.getOptInd() - 1 == args.length) {\n        finder.doName(\".\");\n    } else {\n        for (int i = argHandler.getOptInd() - 1; i < args.length; i++) finder.doName(args[i]);\n    }\n}\n","name":"main","className":"Find","variables":{"args":1,"c":4,"i":4,"argHandler":6,"finder":3},"constants":{"'n'":1,"0":1,"1":2,"\"n:s:\"":1,"\".\"":1,"'s'":1,"\"Got: \"":1},"javaDoc":"Main program","comments":" Main program ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public static void usage() {\n    System.err.println(\"Usage: Find [-n namefilter][-s sizefilter][dir...]\");\n    System.exit(1);\n}\n","name":"usage","className":"Find","variables":{"System":1},"constants":{"1":1,"\"Usage: Find [-n namefilter][-s sizefilter][dir...]\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":1,"doName":1,"isFile":1,"doFile":1,"exists":1,"list":1,"System.err.println":1,"isDirectory":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"String":2,"File":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":6,"NameExpr":41,"StringLiteralExpr":5,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":3,"BlockStmt":2,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"/** doName - handle one filesystem object by name */\nprivate void doName(String s) {\n    Debug.println(\"flow\", \"doName(\" + s + \")\");\n    File f = new File(s);\n    if (!f.exists()) {\n        System.out.println(s + \" does not exist\");\n        return;\n    }\n    if (f.isFile())\n        doFile(f);\n    else if (f.isDirectory()) {\n        // System.out.println(\"d \" + f.getPath());\n        String objects[] = f.list(filter);\n        for (String o : objects) doName(s + File.separator + o);\n    } else\n        System.err.println(\"Unknown type: \" + s);\n}\n","name":"doName","className":"Find","variables":{"s":5,"f":5,"objects":2,"Debug":1,"o":2},"constants":{"\"doName(\"":1,"\" does not exist\"":1,"\"Unknown type: \"":1,"\"flow\"":1,"\")\"":1},"javaDoc":"doName - handle one filesystem object by name","comments":"System out println(\"d \" + f getPath());  doName - handle one filesystem object by name ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["File"],"returnType":"void","methodCalls":{"getPath":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"/** doFile - process one regular file. */\nprivate static void doFile(File f) {\n    System.out.println(\"f \" + f.getPath());\n}\n","name":"doFile","className":"Find","variables":{"f":1},"constants":{"\"f \"":1},"javaDoc":"doFile - process one regular file","comments":" doFile - process one regular file. ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"StringLiteralExpr":1,"NameExpr":13,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":3},"text":"public static void main(String args[]) {\n    // Get list of names\n    String[] dirs = new java.io.File(\".\").list();\n    // Sort it (see <<javacook-structure-SECT-8>>)\n    Arrays.sort(dirs);\n    for (String dir : dirs) {\n        // Print the list\n        System.out.println(dir);\n    }\n}\n","name":"main","className":"Ls","variables":{"dirs":2,"Arrays":1,"dir":1},"constants":{"\".\"":1},"javaDoc":"","comments":"Get list of names Sort it (see <<javacook-structure-SECT-8>>) Print the list ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"canWrite":2,"createNewFile":1,"setReadOnly":1,"System.out.println":7},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"File":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":8,"NameExpr":47,"FieldAccessExpr":7,"UnaryExpr":3,"MethodCallExpr":11},"statements":{"IfStmt":4,"BlockStmt":5,"ReturnStmt":4,"ExpressionStmt":8},"text":"public static void main(String[] a) throws IOException {\n    File f = new File(\"f\");\n    if (!f.createNewFile()) {\n        System.out.println(\"Can't create new file.\");\n        return;\n    }\n    if (!f.canWrite()) {\n        System.out.println(\"Can't write new file!\");\n        return;\n    }\n    if (!f.setReadOnly()) {\n        System.out.println(\"Grrr! Can't set file read-only.\");\n        return;\n    }\n    if (f.canWrite()) {\n        System.out.println(\"Most immutable, captain!\");\n        System.out.println(\"But it still says canWrite() after setReadOnly\");\n        return;\n    } else {\n        System.out.println(\"Logical, captain!\");\n        System.out.println(\"canWrite() correctly returns false after setReadOnly\");\n    }\n}\n","name":"main","className":"ReadOnly","variables":{"f":5},"constants":{"\"Can't write new file!\"":1,"\"canWrite() correctly returns false after setReadOnly\"":1,"\"But it still says canWrite() after setReadOnly\"":1,"\"Logical, captain!\"":1,"\"Grrr! Can't set file read-only.\"":1,"\"Can't create new file.\"":1,"\"Most immutable, captain!\"":1,"\"f\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"delete":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":1},"text":"public static void main(String[] argv) {\n    for (String a : argv) {\n        delete(a);\n    }\n}\n","name":"main","className":"Delete2","variables":{"a":1,"argv":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"exists":1,"getMessage":1,"System.err.println":4,"delete":1},"annotations":[],"exceptions":["SecurityException"],"concepts":["ExceptionHandling"],"types":{"File":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":9,"NameExpr":34,"StringLiteralExpr":8,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":3,"ReturnStmt":1,"ExpressionStmt":5},"text":"public static void delete(String fileName) {\n    try {\n        // Construct a File object for the file to be deleted.\n        File target = new File(fileName);\n        if (!target.exists()) {\n            System.err.println(\"File \" + fileName + \" not present to begin with!\");\n            return;\n        }\n        // Now, delete it:\n        if (target.delete())\n            System.err.println(\"** Deleted \" + fileName + \" **\");\n        else\n            System.err.println(\"Failed to delete \" + fileName);\n    } catch (SecurityException e) {\n        System.err.println(\"Unable to delete \" + fileName + \"(\" + e.getMessage() + \")\");\n    }\n}\n","name":"delete","className":"Delete2","variables":{"fileName":5,"e":2,"target":3},"constants":{"\" not present to begin with!\"":1,"\"File \"":1,"\" **\"":1,"\"Unable to delete \"":1,"\")\"":1,"\"Failed to delete \"":1,"\"(\"":1,"\"** Deleted \"":1},"javaDoc":"","comments":"Construct a File object for the file to be deleted Now delete it: ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"renameTo":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"File":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"StringLiteralExpr":2,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) throws IOException {\n    // Construct the file object. Does NOT create a file on disk!\n    // backup of this source file.\n    File f = new File(\"Rename.java~\");\n    // Rename the backup file to \"junk.dat\"\n    // Renaming requires a File object for the target.\n    f.renameTo(new File(\"junk.dat\"));\n}\n","name":"main","className":"Rename","variables":{"f":2},"constants":{"\"Rename.java~\"":1,"\"junk.dat\"":1},"javaDoc":"","comments":"Construct the file object Does NOT create a file on disk! Rename the backup file to \"junk dat\" backup of this source file Renaming requires a File object for the target ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.err.printf":1,"exit":1,"endsWith":3,"sort":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2,"String[]":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":3,"LambdaExpr":1,"NameExpr":39,"StringLiteralExpr":5,"FieldAccessExpr":3,"ConditionalExpr":1,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"public static void main(String args[]) {\n    String dirName = args.length > 0 ? args[0] : \".\";\n    if (!new File(dirName).exists()) {\n        System.err.printf(\"File %s does not exist\", dirName);\n        System.exit(1);\n    }\n    // BEGIN main\n    // Generate the selective list, with a Lambda Expression\n    String[] dirs = new java.io.File(dirName).list(( dir,  s) -> {\n        return s.endsWith(\".java\") || s.endsWith(\".class\") || s.endsWith(\".jar\");\n    });\n    // Sort it (see Data Structuring chapter))\n    Arrays.sort(dirs);\n    for (String d : dirs) {\n        // Print the list\n        System.out.println(d);\n    }\n// END main\n}\n","name":"main","className":"FNFilterL","variables":{"args":1,"s":4,"d":1,"dirs":2,"dir":1,"Arrays":1,"System":1,"dirName":3},"constants":{"0":2,"\".class\"":1,"1":1,"\".java\"":1,"\".\"":1,"\".jar\"":1,"\"File %s does not exist\"":1},"javaDoc":"","comments":"BEGIN main END main Generate the selective list with a Lambda Expression Sort it (see Data Structuring chapter)) Print the list ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"listRoots":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"File[]":1,"File":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":10,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"public static void main(String argh_my_aching_fingers[]) {\n    // Get list of names\n    File[] drives = File.listRoots();\n    for (File dr : drives) {\n        // Print the list\n        System.out.println(dr);\n    }\n}\n","name":"main","className":"ListRoots","variables":{"drives":2,"File":1,"dr":1},"constants":{},"javaDoc":"","comments":"Get list of names Print the list ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"parseInt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":6,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"void setSizeFilter(String sizeFilter) {\n    size = Integer.parseInt(sizeFilter);\n    sizeSet = true;\n}\n","name":"setSizeFilter","className":"FindFilter","variables":{"Integer":1,"size":1,"sizeSet":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"toCharArray":1,"compile":1,"toString":2,"System.err.println":1,"append":9,"System.out.println":1},"annotations":[],"exceptions":["PatternSyntaxException"],"concepts":["ExceptionHandling"],"types":{"StringBuilder":1,"char":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":57,"StringLiteralExpr":10,"CharLiteralExpr":10,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":15},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":8,"BlockStmt":3,"TryStmt":1,"SwitchEntryStmt":8,"ForeachStmt":1,"ExpressionStmt":14},"text":"/** Convert the given shell wildcard pattern into internal form (an RE) */\nvoid setNameFilter(String nameFilter) {\n    name = nameFilter;\n    StringBuilder sb = new StringBuilder('^');\n    for (char c : nameFilter.toCharArray()) {\n        switch(c) {\n            case '.':\n                sb.append(\"\\\\.\");\n                break;\n            case '*':\n                sb.append(\".*\");\n                break;\n            case '?':\n                sb.append('.');\n                break;\n            // Some chars are special to RE and have to be escaped\n            case '[':\n                sb.append(\"\\\\[\");\n                break;\n            case ']':\n                sb.append(\"\\\\]\");\n                break;\n            case '(':\n                sb.append(\"\\\\(\");\n                break;\n            case ')':\n                sb.append(\"\\\\)\");\n                break;\n            default:\n                sb.append(c);\n                break;\n        }\n    }\n    sb.append('$');\n    if (debug)\n        System.out.println(\"RE=\\\"\" + sb + \"\\\".\");\n    try {\n        nameRE = Pattern.compile(sb.toString());\n    } catch (PatternSyntaxException ex) {\n        System.err.println(\"Error: RE \" + sb.toString() + \" didn't compile: \" + ex);\n    }\n}\n","name":"setNameFilter","className":"FindFilter","variables":{"nameRE":1,"Pattern":1,"c":2,"debug":1,"ex":2,"name":1,"nameFilter":2,"sb":13},"constants":{"'.'":2,"\"\\\\[\"":1,"'*'":1,"')'":1,"'('":1,"'$'":1,"\"\\\\]\"":1,"'?'":1,"'^'":1,"']'":1,"\"\\\\)\"":1,"'['":1,"\".*\"":1,"\"Error: RE \"":1,"\"\\\".\"":1,"\"\\\\(\"":1,"\"\\\\.\"":1,"\" didn't compile: \"":1,"\"RE=\\\"\"":1},"javaDoc":"Convert the given shell wildcard pattern into internal form (an RE)","comments":"Some chars are special to RE and have to be escaped  Convert the given shell wildcard pattern into internal form (an RE) ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["File","String"],"returnType":"boolean","methodCalls":{"matcher":1,"matches":1,"isDirectory":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"File":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":2,"BinaryExpr":1,"NameExpr":12,"MethodCallExpr":3},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":3,"ExpressionStmt":1},"text":"/** Do the filtering. For now, only filter on name */\npublic boolean accept(File dir, String fileName) {\n    File f = new File(dir, fileName);\n    if (f.isDirectory()) {\n        // allow recursion\n        return true;\n    }\n    if (nameRE != null) {\n        return nameRE.matcher(fileName).matches();\n    }\n    // Catchall\n    return false;\n}\n         // TODO size handling.\n\n","name":"accept","className":"FindFilter","variables":{"nameRE":2,"fileName":1,"f":2,"dir":1},"constants":{"null":1,"true":1,"false":1},"javaDoc":"Do the filtering For now only filter on name","comments":"TODO size handling allow recursion Catchall  Do the filtering. For now, only filter on name ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"FindFilter","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"System.err.println":1,"status":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":15,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] argv) throws IOException {\n    // Ensure that a filename (or something) was given in argv[0]\n    if (argv.length == 0) {\n        System.err.println(\"Usage: FileStatus filename\");\n        System.exit(1);\n    }\n    for (String a : argv) {\n        status(a);\n    }\n}\n","name":"main","className":"FileStatus","variables":{"a":1,"argv":1,"System":1},"constants":{"0":1,"1":1,"\"Usage: FileStatus filename\"":1},"javaDoc":"","comments":"Ensure that a filename (or something) was given in argv[0] ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getCanonicalPath":1,"getParent":1,"isFile":1,"canRead":1,"length":1,"exists":1,"canWrite":1,"lastModified":1,"isDirectory":1,"System.out.println":12},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1,"File":1,"Date":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":8,"NameExpr":92,"StringLiteralExpr":12,"FieldAccessExpr":12,"UnaryExpr":1,"MethodCallExpr":21},"statements":{"IfStmt":6,"BlockStmt":7,"ReturnStmt":1,"ExpressionStmt":15},"text":"public static void status(String fileName) throws IOException {\n    System.out.println(\"---\" + fileName + \"---\");\n    // Construct a File object for the given file.\n    File f = new File(fileName);\n    // See if it actually exists\n    if (!f.exists()) {\n        System.out.println(\"file not found\");\n        // Blank line\n        System.out.println();\n        return;\n    }\n    // Print full name\n    System.out.println(\"Canonical name \" + f.getCanonicalPath());\n    // Print parent directory if possible\n    String p = f.getParent();\n    if (p != null) {\n        System.out.println(\"Parent directory: \" + p);\n    }\n    // Check if the file is readable\n    if (f.canRead()) {\n        System.out.println(\"File is readable.\");\n    }\n    // Check if the file is writable\n    if (f.canWrite()) {\n        System.out.println(\"File is writable.\");\n    }\n    // Report on the modification time.\n    Date d = new Date(f.lastModified());\n    System.out.println(\"Last modified \" + d);\n    // See if file, directory, or other. If file, print size.\n    if (f.isFile()) {\n        // Report on the file's size\n        System.out.println(\"File size is \" + f.length() + \" bytes.\");\n    } else if (f.isDirectory()) {\n        System.out.println(\"It's a directory\");\n    } else {\n        System.out.println(\"I dunno! Neither a file nor a directory!\");\n    }\n    // blank line between entries\n    System.out.println();\n}\n","name":"status","className":"FileStatus","variables":{"p":3,"fileName":2,"d":2,"f":10},"constants":{"\"File is readable.\"":1,"\"Parent directory: \"":1,"\"---\"":2,"\"Canonical name \"":1,"null":1,"\"I dunno! Neither a file nor a directory!\"":1,"\"File is writable.\"":1,"\"File size is \"":1,"\"It's a directory\"":1,"\" bytes.\"":1,"\"Last modified \"":1,"\"file not found\"":1},"javaDoc":"","comments":"Construct a File object for the given file See if it actually exists Blank line Print full name Print parent directory if possible Check if the file is readable Check if the file is writable Report on the modification time See if file directory or other If file print size Report on the file's size blank line between entries ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getCanonicalPath":2,"writeDataInTemp":1,"createTempFile":1,"deleteOnExit":2,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"File":2},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":22,"FieldAccessExpr":1,"MethodCallExpr":7},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] argv) throws IOException {\n    // 1. Make an existing file temporary\n    // Construct a File object for the backup created by editing\n    // this source file. The file probably already exists.\n    // My editor creates backups by putting ~ at the end of the name.\n    File bkup = new File(\"Rename.java~\");\n    // Arrange to have it deleted when the program ends.\n    bkup.deleteOnExit();\n    // 2. Create a new temporary file.\n    // Make a file object for foo.tmp, in the default temp directory\n    File tmp = File.createTempFile(\"foo\", \"tmp\");\n    // Report on the filename that it made up for us.\n    System.out.println(\"Your temp file is \" + tmp.getCanonicalPath());\n    // Arrange for it to be deleted at exit.\n    tmp.deleteOnExit();\n    // Now do something with the temporary file, without having to\n    // worry about deleting it later.\n    writeDataInTemp(tmp.getCanonicalPath());\n}\n","name":"main","className":"TempFiles","variables":{"tmp":4,"bkup":2,"File":1},"constants":{"\"Rename.java~\"":1,"\"Your temp file is \"":1,"\"foo\"":1,"\"tmp\"":1},"javaDoc":"","comments":"1 Make an existing file temporary Construct a File object for the backup created by editing this source file The file probably already exists 2 Create a new temporary file Now do something with the temporary file without having to My editor creates backups by putting ~ at the end of the name Arrange to have it deleted when the program ends Make a file object for foo tmp in the default temp directory Report on the filename that it made up for us Arrange for it to be deleted at exit worry about deleting it later ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public static void writeDataInTemp(String tempnam) {\n// This version is dummy. Use your imagination.\n}\n","name":"writeDataInTemp","className":"TempFiles","variables":{},"constants":{},"javaDoc":"","comments":"This version is dummy Use your imagination ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readLine":1,"getInputStream":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"URLConnection":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":15,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public static void main(String[] args) throws Exception {\n    URLConnection conn = new URL(\"http://freegeoip.net/json/www.oreilly.com\").openConnection();\n    try (BufferedReader is = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n        String line;\n        while ((line = is.readLine()) != null) {\n            System.out.println(line);\n        }\n    }\n}\n","name":"main","className":"RestClientFreeGeoIp","variables":{"conn":2,"line":2,"is":2},"constants":{"null":1,"\"http://freegeoip.net/json/www.oreilly.com\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"DBM","methodCalls":{"dbminit":1,"setInuse":1,"isInuse":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":["Synchronization"],"types":{"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":11,"StringLiteralExpr":2,"ThisExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":2,"ExpressionStmt":3},"text":"/** Construct a DBM given its filename */\npublic DBM(String file) {\n    synchronized (this) {\n        if (isInuse())\n            throw new IllegalArgumentException(\"Only one DBM object at a time per Java Machine\");\n        setInuse(true);\n    }\n    fileName = file;\n    int retCode = dbminit(fileName);\n    if (retCode < 0)\n        throw new IllegalArgumentException(\"dbminit failed, code = \" + retCode);\n}\n","name":"DBM","className":"DBM","variables":{"fileName":1,"file":1,"retCode":3},"constants":{"0":1,"\"dbminit failed, code = \"":1,"true":1,"\"Only one DBM object at a time per Java Machine\"":1},"javaDoc":"Construct a DBM given its filename","comments":" Construct a DBM given its filename ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"byte[]","methodCalls":{"writeObject":1,"toByteArray":1,"reset":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"ObjectOutputStream":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":16,"AssignExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** serialize an Object to byte array. */\nprotected byte[] toByteArray(Object o) throws IOException {\n    if (bo == null)\n        bo = new ByteArrayOutputStream(1024);\n    bo.reset();\n    ObjectOutputStream os = new ObjectOutputStream(bo);\n    os.writeObject(o);\n    os.close();\n    return bo.toByteArray();\n}\n","name":"toByteArray","className":"DBM","variables":{"os":3,"bo":5},"constants":{"null":1,"1024":1},"javaDoc":"serialize an Object to byte array","comments":" serialize an Object to byte array. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["byte[]"],"returnType":"Object","methodCalls":{"getMessage":1,"close":1,"readObject":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"ByteArrayInputStream":1,"Object":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"NameExpr":13,"AssignExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** un-serialize an Object from a byte array. */\nprotected Object toObject(byte[] b) throws IOException {\n    Object o;\n    ByteArrayInputStream bi = new ByteArrayInputStream(b);\n    ObjectInputStream os = new ObjectInputStream(bi);\n    try {\n        o = os.readObject();\n    } catch (ClassNotFoundException ex) {\n        throw new IOException(ex.getMessage());\n    }\n    os.close();\n    return o;\n}\n             // Convert ClassNotFoundException to I/O error\n\n","name":"toObject","className":"DBM","variables":{"b":1,"ex":2,"os":3,"bi":2,"o":3},"constants":{},"javaDoc":"un-serialize an Object from a byte array","comments":"Convert ClassNotFoundException to I/O error  un-serialize an Object from a byte array. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"protected native int dbminit(String file);\n","name":"dbminit","className":"DBM","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":260}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"protected native int dbmclose();\n","name":"dbmclose","className":"DBM","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":260}
{"paramTypes":[],"returnType":"void","methodCalls":{"setInuse":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":4,"ThisExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Public wrapper for close method. */\npublic void close() {\n    this.dbmclose();\n    setInuse(false);\n}\n","name":"close","className":"DBM","variables":{},"constants":{"false":1},"javaDoc":"Public wrapper for close method","comments":" Public wrapper for close method. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IllegalStateException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"StringLiteralExpr":1,"UnaryExpr":1},"statements":{"IfStmt":1,"ThrowStmt":1},"text":"protected void checkInUse() {\n    if (!inuse)\n        throw new IllegalStateException(\"Method called when DBM not open\");\n}\n","name":"checkInUse","className":"DBM","variables":{"inuse":1},"constants":{"\"Method called when DBM not open\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["byte[]"],"returnType":"byte[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"protected native byte[] dbmfetch(byte[] key);\n","name":"dbmfetch","className":"DBM","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":260}
{"paramTypes":["byte[]"],"returnType":"byte[]","methodCalls":{"checkInUse":1,"dbmfetch":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Fetch using byte arrays */\npublic byte[] fetch(byte[] key) throws IOException {\n    checkInUse();\n    return dbmfetch(key);\n}\n","name":"fetch","className":"DBM","variables":{},"constants":{},"javaDoc":"Fetch using byte arrays","comments":" Fetch using byte arrays ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"Object","methodCalls":{"toByteArray":1,"checkInUse":1,"toObject":1,"dbmfetch":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"byte[]":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":10,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Fetch using Objects */\npublic Object fetch(Object key) throws IOException {\n    checkInUse();\n    byte[] datum = dbmfetch(toByteArray(key));\n    return toObject(datum);\n}\n","name":"fetch","className":"DBM","variables":{"datum":1},"constants":{},"javaDoc":"Fetch using Objects","comments":" Fetch using Objects ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["byte[]","byte[]"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"protected native int dbmstore(byte[] key, byte[] content);\n","name":"dbmstore","className":"DBM","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":260}
{"paramTypes":["byte[]","byte[]"],"returnType":"void","methodCalls":{"dbmstore":1,"checkInUse":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Store using byte arrays */\npublic void store(byte[] key, byte[] value) throws IOException {\n    checkInUse();\n    dbmstore(key, value);\n}\n","name":"store","className":"DBM","variables":{},"constants":{},"javaDoc":"Store using byte arrays","comments":" Store using byte arrays ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"void","methodCalls":{"dbmstore":1,"toByteArray":2,"checkInUse":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":10,"MethodCallExpr":4},"statements":{"ExpressionStmt":2},"text":"/** Store using Objects */\npublic void store(Object key, Object value) throws IOException {\n    checkInUse();\n    dbmstore(toByteArray(key), toByteArray(value));\n}\n","name":"store","className":"DBM","variables":{},"constants":{},"javaDoc":"Store using Objects","comments":" Store using Objects ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"protected native int delete(Object key);\n","name":"delete","className":"DBM","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":260}
{"paramTypes":[],"returnType":"byte[]","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public native byte[] firstkey() throws IOException;\n","name":"firstkey","className":"DBM","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":257}
{"paramTypes":[],"returnType":"Object","methodCalls":{"firstkey":1,"toObject":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public Object firstkeyObject() throws IOException {\n    return toObject(firstkey());\n}\n","name":"firstkeyObject","className":"DBM","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["byte[]"],"returnType":"byte[]","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public native byte[] nextkey(byte[] key) throws IOException;\n","name":"nextkey","className":"DBM","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":257}
{"paramTypes":["Object"],"returnType":"Object","methodCalls":{"nextkey":1,"toByteArray":1,"toObject":1},"annotations":[],"exceptions":["IOException"],"concepts":["Recursion"],"types":{"byte[]":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"IfStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"public Object nextkey(Object key) throws IOException {\n    byte[] ba = nextkey(toByteArray(key));\n    if (ba == null)\n        return null;\n    return toObject(ba);\n}\n","name":"nextkey","className":"DBM","variables":{"ba":2},"constants":{"null":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"hashCode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"DBM@\" + hashCode() + \"[\" + fileName + \"]\";\n}\n","name":"toString","className":"DBM","variables":{"fileName":1},"constants":{"\"]\"":1,"\"[\"":1,"\"DBM@\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public static boolean isInuse() {\n    return inuse;\n}\n","name":"isInuse","className":"DBM","variables":{"inuse":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void setInuse(boolean inuse) {\n    DBM.inuse = inuse;\n}\n","name":"setInuse","className":"DBM","variables":{"inuse":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":7,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    System.out.println(new Array().run());\n}\n","name":"main","className":"Array","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"MutableInteger":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":20,"FieldAccessExpr":2,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":2,"MethodCallExpr":1},"statements":{"BlockStmt":2,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"public int run() {\n    MutableInteger list[] = new MutableInteger[MAX];\n    for (int i = 0; i < list.length; i++) {\n        list[i] = new MutableInteger(i);\n    }\n    int sum = 0;\n    for (int i = 0; i < list.length; i++) {\n        sum += list[i].getValue();\n    }\n    return sum;\n}\n","name":"run","className":"Array","variables":{"MAX":1,"i":9,"sum":3,"list":3},"constants":{"0":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getClass":1,"forName":1,"arraycopy":1,"currentTimeMillis":2,"invoke":1,"toString":1,"getMethod":1,"System.err.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Class<?>[]":1,"Method":1,"String":1,"Class<?>":1,"Object[]":1,"long":3},"expressions":{"IntegerLiteralExpr":4,"NullLiteralExpr":1,"VariableDeclarationExpr":8,"ArrayInitializerExpr":2,"DoubleLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":50,"StringLiteralExpr":3,"FieldAccessExpr":4,"ArrayCreationExpr":1,"MethodCallExpr":10},"statements":{"ExpressionStmt":12},"text":"public static void main(String[] argv) throws Exception {\n    // Instantiate target class, from argv[0]\n    Class<?> c = Class.forName(argv[0]);\n    // Find its static main method (use our own argv as the signature).\n    Class<?>[] classes = { argv.getClass() };\n    Method main = c.getMethod(\"main\", classes);\n    // Make new argv array, dropping class name from front.\n    // (Normally Java doesn't get the class name, but in \n    // this case the user puts the name of the class to time\n    // as well as all its arguments...\n    String nargv[] = new String[argv.length - 1];\n    System.arraycopy(argv, 1, nargv, 0, nargv.length);\n    Object[] nargs = { nargv };\n    System.err.println(\"Starting class \" + c);\n    // About to start timing run. Important to not do anything\n    // (even a println) that would be attributed to the program\n    // being timed, from here until we've gotten ending time.\n    // Get current (i.e., starting) time\n    long t0 = System.currentTimeMillis();\n    // Run the main program\n    main.invoke(null, nargs);\n    // Get ending time, and compute usage\n    long t1 = System.currentTimeMillis();\n    long runTime = t1 - t0;\n    System.err.println(\"runTime=\" + Double.toString(runTime / 1000D));\n}\n","name":"main","className":"Time","variables":{"nargs":1,"c":3,"nargv":2,"classes":1,"Class":1,"main":2,"runTime":2,"t0":2,"argv":2,"t1":2,"Double":1,"System":3},"constants":{"0":2,"1":2,"null":1,"\"main\"":1,"\"runTime=\"":1,"1000D":1,"\"Starting class \"":1},"javaDoc":"","comments":"Make new argv array dropping class name from front (Normally Java doesn't get the class name but in this case the user puts the name of the class to time About to start timing run Important to not do anything (even a println) that would be attributed to the program being timed from here until we've gotten ending time Instantiate target class from argv[0] Find its static main method (use our own argv as the signature) as well as all its arguments Get current (i e starting) time Run the main program Get ending time and compute usage ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":1,"System.out.print":3,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"StringLiteralExpr":3,"NameExpr":25,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] argv) {\n    Object o = \"Hello World\";\n    for (int i = 0; i < 100000; i++) {\n        System.out.print(\"<p><b>\");\n        System.out.print(o.toString());\n        System.out.print(\"</b></p>\");\n        System.out.println();\n    }\n}\n","name":"main","className":"StringPrintB","variables":{"i":3,"o":2},"constants":{"0":1,"\"<p><b>\"":1,"\"Hello World\"":1,"\"</b></p>\"":1,"100000":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":7,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    System.out.println(new ArrayLst().run());\n}\n","name":"main","className":"ArrayLst","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{"add":1,"get":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayList":1,"ArrayList<MutableInteger>":1,"int":3},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":18,"CastExpr":1,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":3,"AssignExpr":1},"statements":{"BlockStmt":2,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"public int run() {\n    ArrayList<MutableInteger> list = new ArrayList<>();\n    for (int i = 0; i < MAX; i++) {\n        list.add(new MutableInteger(i));\n    }\n    int sum = 0;\n    for (int i = 0; i < MAX; i++) {\n        sum += ((MutableInteger) list.get(i)).getValue();\n    }\n    return sum;\n}\n","name":"run","className":"ArrayLst","variables":{"MAX":2,"i":7,"sum":3,"list":3},"constants":{"0":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"StringLiteralExpr":3,"NameExpr":10,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    Object o = \"Hello World\";\n    for (int i = 0; i < 100000; i++) {\n        System.out.println(\"<p><b>\" + o.toString() + \"</b></p>\");\n    }\n}\n","name":"main","className":"StringPrintA","variables":{"i":3,"o":2},"constants":{"0":1,"\"<p><b>\"":1,"\"Hello World\"":1,"\"</b></p>\"":1,"100000":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":2,"System.err.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] argv) throws Exception {\n    if (argv.length != 1) {\n        System.err.println(\"Usage: CommPortSimple deviceName\");\n        System.exit(1);\n    }\n    new CommPortSimple(argv[0]).holdConversation();\n    System.exit(0);\n}\n","name":"main","className":"CommPortSimple","variables":{"argv":1,"System":2},"constants":{"0":2,"1":2,"\"Usage: CommPortSimple deviceName\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"CommPortSimple","methodCalls":{"getName":3,"getPortIdentifiers":1,"getInputStream":1,"exit":1,"getPortType":1,"hasMoreElements":1,"equals":1,"getOutputStream":1,"System.err.println":4,"setSerialPortParams":1,"open":1,"nextElement":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"boolean":1,"SerialPort":1,"CommPortIdentifier":2,"Enumeration<CommPortIdentifier>":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":7,"NameExpr":89,"StringLiteralExpr":8,"AssignExpr":5,"SingleMemberAnnotationExpr":1,"NullLiteralExpr":2,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":9,"MethodCallExpr":18},"statements":{"ContinueStmt":1,"IfStmt":4,"WhileStmt":1,"BreakStmt":1,"BlockStmt":4,"ExpressionStmt":17},"text":"/* Constructor */\npublic CommPortSimple(String devName) throws Exception {\n    @SuppressWarnings(\"unchecked\") Enumeration<CommPortIdentifier> pList = CommPortIdentifier.getPortIdentifiers();\n    // Walk the list, looking for the given name\n    CommPortIdentifier cpi = null;\n    boolean atLeastOneSerialPresent = false;\n    while (pList.hasMoreElements()) {\n        CommPortIdentifier c = pList.nextElement();\n        if (c.getPortType() != CommPortIdentifier.PORT_SERIAL) {\n            System.err.println(\"Not a serial port: \" + c.getName());\n            continue;\n        }\n        if (devName.equals(c.getName())) {\n            cpi = c;\n            // found!\n            break;\n        }\n        atLeastOneSerialPresent = true;\n        System.out.println(\"Not matched: \" + c.getName());\n    }\n    if (cpi == null) {\n        System.err.println(\"Did not find serial port '\" + devName + \"'\");\n        if (atLeastOneSerialPresent)\n            System.err.println(\"Try again with one of the listed names\");\n        else\n            System.err.println(\"In fact, I didn't see ANY serial ports!\");\n        System.exit(1);\n    }\n    thePort = cpi.open(\"JavaCook DataComm\", TIMEOUTSECONDS * 1000);\n    SerialPort myPort = (SerialPort) thePort;\n    // set up the serial port\n    myPort.setSerialPortParams(BAUD, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n    // Get the input and output streams\n    is = new BufferedReader(new InputStreamReader(thePort.getInputStream()));\n    os = new PrintStream(thePort.getOutputStream(), true);\n}\n","name":"CommPortSimple","className":"CommPortSimple","variables":{"pList":3,"atLeastOneSerialPresent":3,"myPort":2,"c":6,"os":1,"CommPortIdentifier":1,"SuppressWarnings":1,"TIMEOUTSECONDS":1,"is":1,"devName":2,"System":1,"thePort":4,"cpi":4},"constants":{"\"Not a serial port: \"":1,"\"Did not find serial port '\"":1,"\"unchecked\"":1,"false":1,"\"Try again with one of the listed names\"":1,"1000":1,"\"Not matched: \"":1,"1":1,"null":2,"\"JavaCook DataComm\"":1,"true":2,"\"In fact, I didn't see ANY serial ports!\"":1,"\"'\"":1},"javaDoc":"","comments":"Walk the list looking for the given name found! set up the serial port Get the input and output streams  Constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"println":1,"System.out.printf":1,"readLine":1,"close":2,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":27,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":2,"ExpressionStmt":6},"text":"/** Hold a conversation - in this case a *very* simple one.  */\nprotected void holdConversation() throws IOException {\n    System.out.println(\"Ready to read and write port.\");\n    os.println(HELLO);\n    String response = is.readLine();\n    System.out.printf(\"I said %s, and the other end replied %s%n\", HELLO, response);\n    // Finally, clean up.\n    if (is != null)\n        is.close();\n    if (os != null)\n        os.close();\n}\n","name":"holdConversation","className":"CommPortSimple","variables":{"os":3,"response":1,"is":3},"constants":{"null":2,"\"Ready to read and write port.\"":1,"\"I said %s, and the other end replied %s%n\"":1},"javaDoc":"Hold a conversation - in this case a very simple one","comments":"Finally clean up  Hold a conversation - in this case a *very* simple one.  ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["PrinterException"],"concepts":[],"types":{"boolean":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BooleanLiteralExpr":2,"BinaryExpr":2,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"/** Simple demo main program. */\npublic static void main(String[] av) throws PrinterException {\n    boolean quiet = false;\n    if (av.length > 0 && av[0].startsWith(\"-q\"))\n        quiet = true;\n    new PrintDemoGfx(quiet);\n}\n","name":"main","className":"PrintDemoGfx","variables":{"av":1,"quiet":3},"constants":{"0":2,"false":1,"true":1,"\"-q\"":1},"javaDoc":"Simple demo main program","comments":" Simple demo main program. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Graphics","PageFormat","int"],"returnType":"int","methodCalls":{"paint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":11,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"/** called from the printer system to print each page */\npublic int print(Graphics pg, PageFormat pf, int pageNum) {\n    if (// we only print one page\n    pageNum > 0)\n        // ie., end of job\n        return Printable.NO_SUCH_PAGE;\n    // Now ask \"thing\" to paint itself\n    // on the printer, by calling its paint() method with \n    // a Printjob Graphics instead of a Window Graphics.\n    thing.paint(pg);\n    // Tell print system that the page is ready to print\n    return Printable.PAGE_EXISTS;\n}\n","name":"print","className":"","variables":{"pageNum":1,"thing":1},"constants":{"0":1},"javaDoc":"called from the printer system to print each page","comments":"Now ask \"thing\" to paint itself on the printer by calling its paint() method with we only print one page ie end of job a Printjob Graphics instead of a Window Graphics Tell print system that the page is ready to print  called from the printer system to print each page ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setJobName":1,"printDialog":1,"print":1,"getPrinterJob":1,"showMessageDialog":1,"setCopies":1,"paint":1,"setPrintable":1},"annotations":[],"exceptions":["PrinterException"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"PrinterJob":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"BooleanLiteralExpr":1,"NameExpr":40,"StringLiteralExpr":3,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":3,"ReturnStmt":3,"ExpressionStmt":7},"text":"public void actionPerformed(ActionEvent e) {\n    try {\n        PrinterJob pjob = PrinterJob.getPrinterJob();\n        pjob.setJobName(\"DemoGfx - Graphics Demo Printout\");\n        pjob.setCopies(1);\n        // Tell the print system how to print our pages.\n        pjob.setPrintable(new Printable() {\n\n            /** called from the printer system to print each page */\n            /** called from the printer system to print each page */\n            public int print(Graphics pg, PageFormat pf, int pageNum) {\n                if (// we only print one page\n                pageNum > 0)\n                    // ie., end of job\n                    return Printable.NO_SUCH_PAGE;\n                // Now ask \"thing\" to paint itself\n                // on the printer, by calling its paint() method with \n                // a Printjob Graphics instead of a Window Graphics.\n                thing.paint(pg);\n                // Tell print system that the page is ready to print\n                return Printable.PAGE_EXISTS;\n            }\n        });\n        if (// choose printer\n        !quiet && pjob.printDialog() == false)\n            // user cancelled\n            return;\n        // Finally, do the printing.\n        pjob.print();\n    } catch (PrinterException pe) {\n        JOptionPane.showMessageDialog(f, \"Printer error\" + pe, \"Printing error\", JOptionPane.ERROR_MESSAGE);\n    }\n}\n","name":"actionPerformed","className":"","variables":{"print":1,"pe":2,"pf":1,"pg":1,"pjob":6,"quiet":1,"pageNum":2,"thing":1,"JOptionPane":1,"PrinterJob":1},"constants":{"0":1,"1":1,"\"Printer error\"":1,"\"Printing error\"":1,"\"DemoGfx - Graphics Demo Printout\"":1,"false":1},"javaDoc":"","comments":"Tell the print system how to print our pages called from the printer system to print each page Now ask \"thing\" to paint itself on the printer by calling its paint() method with we only print one page ie end of job a Printjob Graphics instead of a Window Graphics Tell print system that the page is ready to print choose printer user cancelled Finally do the printing ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean"],"returnType":"PrintDemoGfx","methodCalls":{"add":2,"setJobName":1,"setVisible":1,"getPrinterJob":1,"addActionListener":1,"getContentPane":2,"paint":1,"pack":1,"setPrintable":1,"printDialog":1,"print":1,"showMessageDialog":1,"setCopies":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":["PrinterException"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"GfxDemoCanvas":1,"JFrame":1,"JButton":1,"PrinterJob":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":4,"BooleanLiteralExpr":2,"NameExpr":77,"StringLiteralExpr":5,"FieldAccessExpr":6,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":16},"statements":{"IfStmt":2,"BlockStmt":4,"TryStmt":1,"ReturnStmt":3,"ExpressionStmt":17},"text":"public PrintDemoGfx(boolean q) {\n    quiet = q;\n    final JFrame f = new JFrame(\"Printing Test Dummy Frame\");\n    // Construct the object we want to print. Contrived:\n    // this object would already exist in a real program.\n    final GfxDemoCanvas thing = new GfxDemoCanvas(400, 300);\n    f.getContentPane().add(thing, BorderLayout.CENTER);\n    JButton printButton = new JButton(\"Print\");\n    f.getContentPane().add(printButton, BorderLayout.SOUTH);\n    printButton.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            try {\n                PrinterJob pjob = PrinterJob.getPrinterJob();\n                pjob.setJobName(\"DemoGfx - Graphics Demo Printout\");\n                pjob.setCopies(1);\n                // Tell the print system how to print our pages.\n                pjob.setPrintable(new Printable() {\n\n                    /** called from the printer system to print each page */\n                    /** called from the printer system to print each page */\n                    public int print(Graphics pg, PageFormat pf, int pageNum) {\n                        if (// we only print one page\n                        pageNum > 0)\n                            // ie., end of job\n                            return Printable.NO_SUCH_PAGE;\n                        // Now ask \"thing\" to paint itself\n                        // on the printer, by calling its paint() method with \n                        // a Printjob Graphics instead of a Window Graphics.\n                        thing.paint(pg);\n                        // Tell print system that the page is ready to print\n                        return Printable.PAGE_EXISTS;\n                    }\n                });\n                if (// choose printer\n                !quiet && pjob.printDialog() == false)\n                    // user cancelled\n                    return;\n                // Finally, do the printing.\n                pjob.print();\n            } catch (PrinterException pe) {\n                JOptionPane.showMessageDialog(f, \"Printer error\" + pe, \"Printing error\", JOptionPane.ERROR_MESSAGE);\n            }\n        }\n    });\n    f.pack();\n    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    f.setVisible(true);\n}\n","name":"PrintDemoGfx","className":"PrintDemoGfx","variables":{"e":1,"f":6,"pageNum":2,"JOptionPane":1,"PrinterJob":1,"printButton":2,"q":1,"actionPerformed":1,"print":1,"pe":2,"pf":1,"pg":1,"pjob":6,"quiet":2,"thing":2},"constants":{"\"Printing Test Dummy Frame\"":1,"0":1,"1":1,"300":1,"400":1,"\"Printer error\"":1,"\"Printing error\"":1,"\"Print\"":1,"\"DemoGfx - Graphics Demo Printout\"":1,"false":1,"true":1},"javaDoc":"","comments":"Construct the object we want to print Contrived: this object would already exist in a real program Tell the print system how to print our pages called from the printer system to print each page Now ask \"thing\" to paint itself on the printer by calling its paint() method with we only print one page ie end of job a Printjob Graphics instead of a Window Graphics Tell print system that the page is ready to print choose printer user cancelled Finally do the printing ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"launch":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    launch(args);\n}\n","name":"main","className":"JfxVideo","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Stage"],"returnType":"void","methodCalls":{"play":1,"add":1,"setScene":1,"show":1,"setTitle":1,"fill":1,"getChildren":1,"size":2,"build":1,"get":1,"root":1,"getParameters":1,"width":1,"create":1,"getRaw":1,"height":1},"annotations":["Override"],"exceptions":["Exception"],"concepts":["FinalVariables"],"types":{"Group":1,"Media":1,"String":1,"Scene":1,"MediaView":1,"List<String>":1,"MediaPlayer":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":4,"VariableDeclarationExpr":7,"BinaryExpr":3,"NameExpr":52,"StringLiteralExpr":3,"FieldAccessExpr":1,"ConditionalExpr":1,"MethodCallExpr":17},"statements":{"ExpressionStmt":12},"text":"@Override\npublic void start(Stage primaryStage) throws Exception {\n    primaryStage.setTitle(\"JavaFX Video\");\n    final List<String> args = getParameters().getRaw();\n    String url = args.size() > 0 ? args.get(args.size() - 1) : \"http://www.mediacollege.com/\" + \"video-gallery/testclips/20051210-w50s.flv\";\n    Media media = new Media(url);\n    MediaPlayer player = new MediaPlayer(media);\n    player.play();\n    MediaView view = new MediaView(player);\n    Group root = new Group();\n    root.getChildren().add(view);\n    Scene scene = SceneBuilder.create().width(360).height(288).root(root).fill(Color.WHITE).build();\n    primaryStage.setScene(scene);\n    primaryStage.show();\n}\n","name":"start","className":"JfxVideo","variables":{"args":4,"primaryStage":3,"SceneBuilder":1,"view":1,"root":2,"media":2,"url":2,"player":3,"scene":1},"constants":{"0":1,"1":1,"288":1,"\"video-gallery/testclips/20051210-w50s.flv\"":1,"360":1,"\"JavaFX Video\"":1,"\"http://www.mediacollege.com/\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"play":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Media":1,"String":1,"MediaPlayer":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"StringLiteralExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    String clipName = \"demo.mp3\";\n    Media clip = new Media(clipName);\n    MediaPlayer mediaPlayer = new MediaPlayer(clip);\n    mediaPlayer.play();\n}\n","name":"main","className":"AudioPlay","variables":{"mediaPlayer":2,"clipName":2,"clip":2},"constants":{"\"demo.mp3\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void handle(ActionEvent e) {\n    System.out.println(\"Hello from JavaFX\");\n}\n","name":"handle","className":"","variables":{},"constants":{"\"Hello from JavaFX\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Stage"],"returnType":"void","methodCalls":{"add":1,"setOnAction":1,"getChildren":1,"setScene":1,"show":1,"setTitle":1,"setText":1,"System.out.println":1},"annotations":["Override"],"exceptions":[],"concepts":["InnerMethod"],"types":{"Button":1,"StackPane":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"NameExpr":30,"StringLiteralExpr":3,"FieldAccessExpr":1,"MarkerAnnotationExpr":1,"MethodCallExpr":8},"statements":{"BlockStmt":1,"ExpressionStmt":9},"text":"@Override\npublic void start(Stage stage) {\n    // <3>\n    stage.setTitle(\"JavaFX Hello!\");\n    Button btn = new Button();\n    btn.setText(\"Run Greeting\");\n    btn.setOnAction(new // <4>\n    EventHandler<ActionEvent>() {\n\n        @Override\n        public void handle(ActionEvent e) {\n            System.out.println(\"Hello from JavaFX\");\n        }\n    });\n    // <5>\n    StackPane rootPane = new StackPane();\n    rootPane.getChildren().add(btn);\n    stage.setScene(new Scene(rootPane, 300, 200));\n    stage.show();\n}\n","name":"start","className":"HelloFx","variables":{"stage":3,"e":1,"rootPane":3,"handle":1,"btn":3,"Override":1},"constants":{"200":1,"300":1,"\"JavaFX Hello!\"":1,"\"Run Greeting\"":1,"\"Hello from JavaFX\"":1},"javaDoc":"","comments":"<3> <4> <5> ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"launch":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    // <6>\n    launch(args);\n}\n","name":"main","className":"HelloFx","variables":{},"constants":{},"javaDoc":"","comments":"<6> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"normalize":1,"toString":1,"relativize":1,"System.out.println":5},"annotations":[],"exceptions":["MalformedURLException","URISyntaxException"],"concepts":["FinalVariables"],"types":{"URI":4,"URL":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"BinaryExpr":6,"StringLiteralExpr":8,"NameExpr":40,"FieldAccessExpr":5,"MethodCallExpr":8},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) throws URISyntaxException, MalformedURLException {\n    URI u = new URI(\"http://www.darwinsys.com/java/../openbsd/../index.jsp\");\n    System.out.println(\"Raw: \" + u);\n    URI normalized = u.normalize();\n    System.out.println(\"Normalized: \" + normalized);\n    final URI BASE = new URI(\"http://www.darwinsys.com\");\n    System.out.println(\"Relativized to \" + BASE + \": \" + BASE.relativize(u));\n    // A URL is a type of URI\n    URL url = new URL(normalized.toString());\n    System.out.println(\"URL: \" + url);\n    // Junk\n    URI uri = new URI(\"bean:WonderBean\");\n    System.out.println(uri);\n}\n","name":"main","className":"URIDemo","variables":{"u":3,"normalized":3,"uri":1,"url":2,"BASE":3},"constants":{"\"http://www.darwinsys.com/java/../openbsd/../index.jsp\"":1,"\"bean:WonderBean\"":1,"\"Raw: \"":1,"\"URL: \"":1,"\": \"":1,"\"http://www.darwinsys.com\"":1,"\"Relativized to \"":1,"\"Normalized: \"":1},"javaDoc":"","comments":"A URL is a type of URI Junk ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setEntityResolver":1,"printStackTrace":1,"getAbsolutePath":1,"setNamespaceAware":1,"newInstance":2,"newSchema":1,"parse":1,"setSchema":1,"getLineNumber":1,"setAttribute":1,"newDocumentBuilder":1,"exists":1,"setValidating":1,"toString":1,"System.err.println":10,"System.out.println":1},"annotations":[],"exceptions":["SAXParseException","IOException","Exception","SAXException"],"concepts":["ExceptionHandling"],"types":{"SchemaFactory":1,"boolean":1,"DocumentBuilderFactory":1,"DocumentBuilder":1,"Schema":1,"String":1,"File":2,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":4,"VariableDeclarationExpr":9,"ArrayAccessExpr":4,"BinaryExpr":9,"NameExpr":136,"StringLiteralExpr":16,"UnaryExpr":3,"AssignExpr":2,"NullLiteralExpr":3,"BooleanLiteralExpr":4,"FieldAccessExpr":15,"MethodCallExpr":28},"statements":{"IfStmt":7,"BlockStmt":12,"TryStmt":1,"ReturnStmt":1,"ForStmt":1,"ThrowStmt":1,"ExpressionStmt":28},"text":"/**\n     * Parse one or more XML documents with optional validation.\n     * <b>Note:</b> It is an unpleasant limitation of javax.xml.validation that parsing DTD-based documents can\n     * extract the DTD name/location and use it, whereas Schema(etc)-based validation requires the user to do\n     * this manually before invoking the parser.\n     * @param av Command args, may include -v for validation, and -a schema.xsd, before the filename(s);\n     * all documents parsed in this run must use the same Schema.\n     * @throws SAXException\n     */\n// BEGIN main\npublic static void main(String[] av) throws SAXException {\n    if (av.length == 0) {\n        System.err.println(\"Usage: XParse file\");\n        return;\n    }\n    boolean validate = false;\n    Schema schema = null;\n    try {\n        for (int i = 0; i < av.length; i++) {\n            if (av[i].equals(\"-v\"))\n                validate = true;\n            else if (av[i].equals(\"-a\")) {\n                // \"create a SchemaFactory capable of understanding W3C schemas\"\n                //   -- from the Javadoc page\n                SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n                // load the W3c XML schema, represented by a Schema instance\n                String schemaLocation = av[++i];\n                File schemaFile = new File(schemaLocation);\n                if (!schemaFile.exists()) {\n                    throw new IOException(\"Schema location = \" + schemaLocation + \" does not exist\");\n                }\n                schema = schemaFactory.newSchema(schemaFile);\n            } else {\n                File xmlFile = new File(av[i]);\n                System.err.println(\"Parsing \" + xmlFile.getAbsolutePath() + \"...\");\n                DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n                if (validate) {\n                    if (schema != null) {\n                        dbFactory.setSchema(schema);\n                    } else {\n                        dbFactory.setValidating(true);\n                        dbFactory.setNamespaceAware(true);\n                        dbFactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\", XMLConstants.W3C_XML_SCHEMA_NS_URI);\n                    }\n                }\n                DocumentBuilder parser = dbFactory.newDocumentBuilder();\n                // If not using schema, Get local copies of DTDs...\n                if (schema == null) {\n                    parser.setEntityResolver(new MyDTDResolver());\n                }\n                parser.parse(xmlFile);\n                System.out.println(\"Parsed/Validated OK\");\n            }\n        }\n    // Just +catch+ statements below here...\n    // END main\n    } catch (SAXParseException ex) {\n        System.err.println(\"+================================+\");\n        System.err.println(\"|       *SAX Parse Error*        |\");\n        System.err.println(\"+================================+\");\n        System.err.println(ex.toString());\n        System.err.println(\"At line \" + ex.getLineNumber());\n    } catch (Exception ex) {\n        System.err.println(\"+================================+\");\n        System.err.println(\"|           *XML Error*          |\");\n        System.err.println(\"+================================+\");\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"XParse","variables":{"schema":4,"SchemaFactory":1,"schemaFile":2,"schemaFactory":2,"DocumentBuilderFactory":1,"schemaLocation":3,"i":7,"xmlFile":2,"ex":5,"parser":3,"av":4,"dbFactory":6,"validate":3},"constants":{"\"|           *XML Error*          |\"":1,"\"...\"":1,"\"Parsing \"":1,"\"-v\"":1,"false":1,"\"Schema location = \"":1,"\"+================================+\"":4,"0":2,"\" does not exist\"":1,"\"|       *SAX Parse Error*        |\"":1,"\"Usage: XParse file\"":1,"\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\"":1,"\"Parsed/Validated OK\"":1,"null":3,"\"At line \"":1,"true":3,"\"-a\"":1},"javaDoc":"","comments":"Just +catch+ statements below here END main \"create a SchemaFactory capable of understanding W3C schemas\" -- from the Javadoc page load the W3c XML schema represented by a Schema instance If not using schema Get local copies of DTDs  BEGIN main","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"transform":1,"newTransformer":1,"newInstance":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Transformer":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":6,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":1,"NameExpr":22,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n     * @param args three filenames: XML, XSL, and Output (this order is historical).\n     * @throws Exception\n     */\npublic static void main(String[] args) throws Exception {\n    // Require three input args\n    if (args.length != 3) {\n        System.out.println(\"Usage: java JAXPTransform inputFile.xml inputFile.xsl outputFile\");\n        System.exit(1);\n    }\n    // Create a transformer object\n    Transformer tx = TransformerFactory.newInstance().newTransformer(// not 0\n    new StreamSource(new File(args[1])));\n    // Use its transform() method to perform the transformation\n    // not 1\n    tx.transform(// not 1\n    new StreamSource(new File(args[0])), new StreamResult(new File(args[2])));\n}\n","name":"main","className":"JAXPTransform","variables":{"args":3,"TransformerFactory":1,"tx":2,"System":1},"constants":{"0":1,"1":2,"2":1,"3":1,"\"Usage: java JAXPTransform inputFile.xml inputFile.xsl outputFile\"":1},"javaDoc":"args three filenames: XML XSL and Output (this order is historical) @throws Exception","comments":"Require three input args Create a transformer object not 0 Use its transform() method to perform the transformation not 1 not 1 not 1 \n     * @param args three filenames: XML, XSL, and Output (this order is historical).\n     * @throws Exception\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] av) {\n    if (av.length == 0) {\n        System.err.println(\"Usage: XTW file [...]\");\n        return;\n    }\n    for (int i = 0; i < av.length; i++) {\n        String name = av[i];\n        new XTW().convert(name, true);\n    }\n}\n","name":"main","className":"XTW","variables":{"av":1,"name":1,"i":4},"constants":{"0":2,"\"Usage: XTW file [...]\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","boolean"],"returnType":"void","methodCalls":{"getClass":1,"newDocumentBuilder":1,"getMessage":1,"newInstance":1,"parse":1,"doRecursive":1,"System.err.println":9},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"DocumentBuilderFactory":1,"DocumentBuilder":1,"String":1,"Document":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":7,"NameExpr":73,"StringLiteralExpr":11,"FieldAccessExpr":9,"MethodCallExpr":16},"statements":{"IfStmt":3,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":14},"text":"/** Convert the file */\nprotected void convert(String fileName, boolean verbose) {\n    try {\n        if (verbose)\n            System.err.println(\">>>Parsing \" + fileName + \"...\");\n        // Make the document a URL so relative DTD works.\n        String uri = \"file:\" + new File(fileName).getAbsolutePath();\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.parse(uri);\n        if (verbose)\n            System.err.println(\">>>Walking \" + fileName + \"...\");\n        doRecursive(doc);\n    } catch (Exception ex) {\n        System.err.println(\"+============================+\");\n        System.err.println(\"|        XTW Error           |\");\n        System.err.println(\"+============================+\");\n        System.err.println(ex.getClass());\n        System.err.println(ex.getMessage());\n        System.err.println(\"+============================+\");\n    }\n    if (verbose) {\n        System.err.println(\">>>Done \" + fileName + \"...\");\n    }\n}\n","name":"convert","className":"XTW","variables":{"factory":2,"fileName":4,"DocumentBuilderFactory":1,"ex":3,"builder":2,"doc":1,"uri":1,"verbose":3},"constants":{"\"...\"":3,"\"+============================+\"":3,"\">>>Done \"":1,"\"file:\"":1,"\">>>Parsing \"":1,"\"|        XTW Error           |\"":1,"\">>>Walking \"":1},"javaDoc":"Convert the file","comments":"Make the document a URL so relative DTD works  Convert the file ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"println":1,"item":1,"doNode":1,"getLength":2,"getChildNodes":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"NodeList":1,"Node":1,"int":1},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":23,"StringLiteralExpr":3,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"ContinueStmt":1,"IfStmt":2,"BlockStmt":3,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/* Process all the nodes, recursively. */\nprotected void doRecursive(Node p) {\n    if (p == null) {\n        return;\n    }\n    NodeList nodes = p.getChildNodes();\n    Debug.println(\"xml-tree\", \"Element has \" + nodes.getLength() + \" children\");\n    for (int i = 0; i < nodes.getLength(); i++) {\n        Node n = nodes.item(i);\n        if (n == null) {\n            continue;\n        }\n        doNode(n);\n    }\n}\n","name":"doRecursive","className":"XTW","variables":{"p":2,"nodes":4,"i":3,"Debug":1,"n":2},"constants":{"0":1,"null":2,"\"xml-tree\"":1,"\" children\"":1,"\"Element has \"":1},"javaDoc":"","comments":" Process all the nodes, recursively. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"getNodeValue":1,"getClass":1,"equals":2,"length":1,"getNodeType":2,"getNodeName":1,"doRecursive":1,"System.err.println":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":9,"NameExpr":49,"StringLiteralExpr":7,"FieldAccessExpr":5,"MethodCallExpr":12},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":4,"BlockStmt":1,"SwitchEntryStmt":3,"ExpressionStmt":5},"text":"protected void doNode(Node n) {\n    switch(n.getNodeType()) {\n        case Node.ELEMENT_NODE:\n            System.out.println(\"ELEMENT<\" + n.getNodeName() + \">\");\n            doRecursive(n);\n            break;\n        case Node.TEXT_NODE:\n            String text = n.getNodeValue();\n            if (text.length() == 0 || text.equals(\"\\n\") || text.equals(\"\\\\r\")) {\n                break;\n            }\n            System.out.println(\"TEXT: \" + text);\n            break;\n        default:\n            System.err.println(\"OTHER NODE \" + n.getNodeType() + \": \" + n.getClass());\n            break;\n    }\n}\n","name":"doNode","className":"XTW","variables":{"text":5,"n":5},"constants":{"\"ELEMENT<\"":1,"0":1,"\">\"":1,"\"\\\\r\"":1,"\": \"":1,"\"TEXT: \"":1,"\"\\n\"":1,"\"OTHER NODE \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"transform":1,"newTransformer":1,"makeDoc":1,"newInstance":1,"setOutputProperty":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"DocWriteDOM":1,"Transformer":1,"Document":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"NameExpr":26,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] av) throws Exception {\n    DocWriteDOM dw = new DocWriteDOM();\n    Document doc = dw.makeDoc();\n    System.out.println(\"Writing the tree now...\");\n    Transformer tx = TransformerFactory.newInstance().newTransformer();\n    tx.setOutputProperty(OutputKeys.INDENT, \"yes\");\n    tx.transform(new DOMSource(doc), new StreamResult(System.out));\n}\n","name":"main","className":"DocWriteDOM","variables":{"dw":2,"TransformerFactory":1,"tx":3,"doc":2},"constants":{"\"yes\"":1,"\"Writing the tree now...\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Document","methodCalls":{"appendChild":6,"getClass":1,"createTextNode":2,"newDocumentBuilder":1,"getMessage":1,"newInstance":1,"createElement":4,"System.err.println":6,"newDocument":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"DocumentBuilderFactory":1,"DocumentBuilder":1,"Node":3,"Document":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":6,"NameExpr":87,"StringLiteralExpr":10,"FieldAccessExpr":6,"MethodCallExpr":23,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":19},"text":"/** Generate the XML document */\nprotected Document makeDoc() {\n    try {\n        DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();\n        DocumentBuilder parser = fact.newDocumentBuilder();\n        Document doc = parser.newDocument();\n        Node root = doc.createElement(\"Poem\");\n        doc.appendChild(root);\n        Node stanza = doc.createElement(\"Stanza\");\n        root.appendChild(stanza);\n        Node line = doc.createElement(\"Line\");\n        stanza.appendChild(line);\n        line.appendChild(doc.createTextNode(\"Once, upon a midnight dreary\"));\n        line = doc.createElement(\"Line\");\n        stanza.appendChild(line);\n        line.appendChild(doc.createTextNode(\"While I pondered, weak and weary\"));\n        return doc;\n    } catch (Exception ex) {\n        System.err.println(\"+============================+\");\n        System.err.println(\"|        XML Error           |\");\n        System.err.println(\"+============================+\");\n        System.err.println(ex.getClass());\n        System.err.println(ex.getMessage());\n        System.err.println(\"+============================+\");\n        return null;\n    }\n}\n","name":"makeDoc","className":"DocWriteDOM","variables":{"fact":2,"DocumentBuilderFactory":1,"ex":3,"parser":2,"line":4,"root":2,"stanza":3,"doc":9},"constants":{"\"Stanza\"":1,"\"While I pondered, weak and weary\"":1,"\"+============================+\"":3,"null":1,"\"Poem\"":1,"\"Line\"":2,"\"|        XML Error           |\"":1,"\"Once, upon a midnight dreary\"":1},"javaDoc":"Generate the XML document","comments":" Generate the XML document ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getColorName() {\n    return colorName;\n}\n","name":"getColorName","className":"Configuration","variables":{"colorName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setColorName(String colorName) {\n    this.colorName = colorName;\n}\n","name":"setColorName","className":"Configuration","variables":{"colorName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Remaining accessors, hashCode/equals(), are uninteresting.\n// END main\npublic boolean isVerbose() {\n    return verbose;\n}\n","name":"isVerbose","className":"Configuration","variables":{"verbose":1},"constants":{},"javaDoc":"","comments":" END main","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setVerbose(boolean verbose) {\n    this.verbose = verbose;\n}\n","name":"setVerbose","className":"Configuration","variables":{"verbose":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getWebProxy() {\n    return webProxy;\n}\n","name":"getWebProxy","className":"Configuration","variables":{"webProxy":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setWebProxy(String webProxy) {\n    this.webProxy = webProxy;\n}\n","name":"setWebProxy","className":"Configuration","variables":{"webProxy":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getScreenName() {\n    return screenName;\n}\n","name":"getScreenName","className":"Configuration","variables":{"screenName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setScreenName(String screenName) {\n    this.screenName = screenName;\n}\n","name":"setScreenName","className":"Configuration","variables":{"screenName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"hashCode":3},"annotations":["Override"],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":7,"NullLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":11,"NameExpr":26,"EnclosedExpr":7,"ConditionalExpr":4,"AssignExpr":4,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":6},"text":"@Override\npublic int hashCode() {\n    final int PRIME = 31;\n    int result = 1;\n    result = PRIME * result + ((colorName == null) ? 0 : colorName.hashCode());\n    result = PRIME * result + ((screenName == null) ? 0 : screenName.hashCode());\n    result = PRIME * result + (verbose ? 1231 : 1237);\n    result = PRIME * result + ((webProxy == null) ? 0 : webProxy.hashCode());\n    return result;\n}\n","name":"hashCode","className":"Configuration","variables":{"result":10,"colorName":2,"PRIME":5,"webProxy":2,"screenName":2,"verbose":1},"constants":{"0":3,"1":1,"1237":1,"null":3,"1231":1,"31":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":2,"equals":3},"annotations":["Override"],"exceptions":[],"concepts":["Casting","FinalVariables"],"types":{"Configuration":1},"expressions":{"NullLiteralExpr":7,"VariableDeclarationExpr":1,"BinaryExpr":10,"BooleanLiteralExpr":11,"NameExpr":42,"CastExpr":1,"FieldAccessExpr":7,"UnaryExpr":3,"ThisExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":13,"BlockStmt":3,"ReturnStmt":11,"ExpressionStmt":1},"text":"@Override\npublic boolean equals(Object obj) {\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    final Configuration other = (Configuration) obj;\n    if (colorName == null) {\n        if (other.colorName != null)\n            return false;\n    } else if (!colorName.equals(other.colorName))\n        return false;\n    if (screenName == null) {\n        if (other.screenName != null)\n            return false;\n    } else if (!screenName.equals(other.screenName))\n        return false;\n    if (verbose != other.verbose)\n        return false;\n    if (webProxy == null) {\n        if (other.webProxy != null)\n            return false;\n    } else if (!webProxy.equals(other.webProxy))\n        return false;\n    return true;\n}\n","name":"equals","className":"Configuration","variables":{"colorName":2,"other":1,"webProxy":2,"obj":4,"screenName":2,"verbose":1},"constants":{"null":7,"true":2,"false":9},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) throws Exception {\n    new SAXLister(args);\n}\n","name":"main","className":"SAXLister","variables":{"args":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"SAXLister","methodCalls":{"createXMLReader":1,"setContentHandler":1,"parse":1},"annotations":[],"exceptions":["IOException","SAXException"],"concepts":[],"types":{"XMLReader":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"ConditionalExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public SAXLister(String[] args) throws SAXException, IOException {\n    XMLReader parser = XMLReaderFactory.createXMLReader();\n    parser.setContentHandler(new PeopleHandler());\n    parser.parse(args.length == 1 ? args[0] : \"xml/people.xml\");\n}\n","name":"SAXLister","className":"SAXLister","variables":{"args":1,"parser":3,"XMLReaderFactory":1},"constants":{"0":1,"1":1,"\"xml/people.xml\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","String","Attributes"],"returnType":"void","methodCalls":{"equalsIgnoreCase":2,"System.out.println":1},"annotations":[],"exceptions":["SAXException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":16,"StringLiteralExpr":4,"FieldAccessExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":3,"BlockStmt":1,"ExpressionStmt":3},"text":"public void startElement(String nsURI, String localName, String rawName, Attributes attributes) throws SAXException {\n    if (DEBUG) {\n        System.out.println(\"startElement: \" + localName + \",\" + rawName);\n    }\n    // Consult rawName since we aren't using xmlns prefixes here.\n    if (rawName.equalsIgnoreCase(\"name\"))\n        person = true;\n    if (rawName.equalsIgnoreCase(\"email\"))\n        email = true;\n}\n","name":"startElement","className":"PeopleHandler","variables":{"localName":1,"person":1,"DEBUG":1,"rawName":3,"email":1},"constants":{"\"email\"":1,"\"name\"":1,"\"startElement: \"":1,"\",\"":1,"true":2},"javaDoc":"","comments":"Consult rawName since we aren't using xmlns prefixes here ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char[]","int","int"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":20,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":2},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":4},"text":"public void characters(char[] ch, int start, int length) {\n    if (person) {\n        System.out.println(\"Person:  \" + new String(ch, start, length));\n        person = false;\n    } else if (email) {\n        System.out.println(\"Email: \" + new String(ch, start, length));\n        email = false;\n    }\n}\n","name":"characters","className":"PeopleHandler","variables":{"ch":2,"person":2,"start":2,"length":2,"email":2},"constants":{"\"Person:  \"":1,"false":2,"\"Email: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getClass":1,"getName":1,"newDocumentBuilder":1,"System.out.printf":1,"newXPath":1,"newInstance":2,"parse":1,"evaluate":1,"getBytes":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"XPath":1,"Number":1,"DocumentBuilder":1,"String":2,"Document":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":3,"NameExpr":35,"StringLiteralExpr":6,"CastExpr":1,"FieldAccessExpr":2,"MethodCallExpr":10},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) throws Exception {\n    DocumentBuilder parser = // <1>\n    DocumentBuilderFactory.newInstance().newDocumentBuilder();\n    String doc = // <2>\n    \"<?xml version='1.0'?>\" + \"<section><sectiontitle>A Discourse of Numbers</sectiontitle>\" + \"<sectionnumber>1.2</sectionnumber>\" + \"<SC>Introduction</SC><p></p></section>\";\n    Document document = // <3>\n    parser.parse(new ByteArrayInputStream(doc.getBytes()));\n    // Evaluate the XPath expression against the Document\n    // <4>\n    XPath xpath = XPathFactory.newInstance().newXPath();\n    // <5>\n    String expression = \"/section/sectionnumber\";\n    Number secNum = (Number) // <6>\n    xpath.evaluate(expression, document, XPathConstants.NUMBER);\n    System.out.printf(\"Section number = %s (a %s)\", secNum, // <7>\n    secNum.getClass().getName());\n}\n","name":"main","className":"XPathDemo","variables":{"XPathFactory":1,"xpath":2,"DocumentBuilderFactory":1,"expression":1,"parser":2,"document":1,"doc":2,"secNum":2},"constants":{"\"<SC>Introduction</SC><p></p></section>\"":1,"\"<section><sectiontitle>A Discourse of Numbers</sectiontitle>\"":1,"\"<sectionnumber>1.2</sectionnumber>\"":1,"\"/section/sectionnumber\"":1,"\"Section number = %s (a %s)\"":1},"javaDoc":"","comments":"Evaluate the XPath expression against the Document <1> <2> <3> <4> <5> <6> <6> <7> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.flush":1,"exitValue":1,"readLine":1,"System.err.println":2,"getRuntime":1,"getInputStream":1,"waitFor":1,"exec":1,"System.out.println":3},"annotations":[],"exceptions":["IOException","InterruptedException"],"concepts":["ExceptionHandling"],"types":{"Runtime":1,"BufferedReader":1,"Process":1,"String":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":54,"StringLiteralExpr":3,"FieldAccessExpr":6,"EnclosedExpr":1,"MethodCallExpr":12,"AssignExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":13},"text":"public static void main(String argv[]) throws IOException {\n    // BEGIN main\n    // A Runtime object has methods for dealing with the OS\n    Runtime r = Runtime.getRuntime();\n    // Process tracks one external native process\n    Process p;\n    // reader for output of process\n    BufferedReader is;\n    String line;\n    // Our argv[0] contains the program to run; remaining elements\n    // of argv contain args for the target program. This is just\n    // what is needed for the String[] form of exec.\n    p = r.exec(argv);\n    System.out.println(\"In Main after exec\");\n    // getInputStream gives an Input stream connected to\n    // the process p's standard output. Just use it to make\n    // a BufferedReader to readLine() what the program writes out.\n    is = new BufferedReader(new InputStreamReader(p.getInputStream()));\n    while ((line = is.readLine()) != null) System.out.println(line);\n    System.out.println(\"In Main after EOF\");\n    System.out.flush();\n    try {\n        // wait for process to complete\n        p.waitFor();\n    } catch (InterruptedException e) {\n        System.err.println(e);\n        return;\n    }\n    System.err.println(\"Process done, exit status was \" + p.exitValue());\n// END main\n}\n                                       // \"Can'tHappen\"\n\n","name":"main","className":"ExecDemoWait","variables":{"p":5,"r":2,"Runtime":1,"e":1,"line":2,"is":3},"constants":{"null":1,"\"In Main after exec\"":1,"\"Process done, exit status was \"":1,"\"In Main after EOF\"":1},"javaDoc":"","comments":"BEGIN main Our argv[0] contains the program to run; remaining elements of argv contain args for the target program This is just getInputStream gives an Input stream connected to the process p's standard output Just use it to make END main A Runtime object has methods for dealing with the OS Process tracks one external native process reader for output of process what is needed for the String[] form of exec a BufferedReader to readLine() what the program writes out wait for process to complete \"Can'tHappen\" ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"eval":1,"getEngineByName":1,"put":1,"System.out.println":1},"annotations":[],"exceptions":["ScriptException"],"concepts":[],"types":{"ScriptEngineManager":1,"Object":1,"ScriptEngine":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":15,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"/**\n     * Demonstrate interacting with the \"R\" implementation called \"Renjin\"\n     */\npublic static void main(String[] args) throws ScriptException {\n    ScriptEngineManager manager = new ScriptEngineManager();\n    ScriptEngine engine = manager.getEngineByName(\"Renjin\");\n    engine.put(\"a\", 42);\n    Object ret = engine.eval(\"b <- 2; a*b\");\n    System.out.println(ret);\n}\n","name":"main","className":"RenjinScripting","variables":{"ret":1,"manager":2,"engine":3},"constants":{"\"a\"":1,"\"b <- 2; a*b\"":1,"\"Renjin\"":1,"42":1},"javaDoc":"Demonstrate interacting with the \"R\" implementation called \"Renjin\"","comments":"\n     * Demonstrate interacting with the \"R\" implementation called \"Renjin\"\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":8,"FieldAccessExpr":1,"ConditionalExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** main - instantiate and run */\npublic static void main(String av[]) throws Exception {\n    String program = av.length == 0 ? NETSCAPE : av[0];\n    new ExecDemoNS(program).setVisible(true);\n}\n","name":"main","className":"ExecDemoNS","variables":{"av":1,"NETSCAPE":1,"program":2},"constants":{"0":2,"true":1},"javaDoc":"main - instantiate and run","comments":" main - instantiate and run ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"runProg":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent evt) {\n    runProg();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"doWait":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent evt) {\n    doWait();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent evt) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"ExecDemoNS","methodCalls":{"add":3,"exit":1,"getProperty":1,"runProg":1,"equals":1,"toLowerCase":1,"addActionListener":3,"getContentPane":1,"doWait":1,"setLayout":1,"indexOf":1,"pack":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":["InnerMethod"],"types":{"Container":1,"JButton":1,"String":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":8,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":3,"StringLiteralExpr":9,"NameExpr":58,"ConditionalExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":16,"AssignExpr":5},"statements":{"IfStmt":2,"BlockStmt":3,"ExplicitConstructorInvocationStmt":1,"ThrowStmt":1,"ExpressionStmt":16},"text":"/** Constructor - set up strings and things. */\npublic ExecDemoNS(String prog) {\n    super(\"ExecDemo: \" + prog);\n    String osname = System.getProperty(\"os.name\");\n    if (osname == null)\n        throw new IllegalArgumentException(\"no os.name\");\n    if (prog.equals(NETSCAPE))\n        // Windows or UNIX only for now, sorry Mac fans\n        program = (osname.toLowerCase().indexOf(\"windows\") != -1) ? \"c:/program files/netscape/communicator/program/netscape.exe\" : \"/usr/local/netscape/netscape\";\n    else\n        program = prog;\n    Container cp = getContentPane();\n    cp.setLayout(new FlowLayout());\n    JButton b;\n    cp.add(b = new JButton(\"Exec\"));\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent evt) {\n            runProg();\n        }\n    });\n    cp.add(b = new JButton(\"Wait\"));\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent evt) {\n            doWait();\n        }\n    });\n    cp.add(b = new JButton(\"Exit\"));\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent evt) {\n            System.exit(0);\n        }\n    });\n    pack();\n}\n","name":"ExecDemoNS","className":"ExecDemoNS","variables":{"actionPerformed":3,"b":7,"evt":3,"program":2,"cp":5,"prog":3,"osname":3,"System":2},"constants":{"0":1,"1":1,"null":1,"\"/usr/local/netscape/netscape\"":1,"\"no os.name\"":1,"\"Exec\"":1,"\"ExecDemo: \"":1,"\"Wait\"":1,"\"windows\"":1,"\"Exit\"":1,"\"os.name\"":1,"\"c:/program files/netscape/communicator/program/netscape.exe\"":1},"javaDoc":"Constructor - set up strings and things","comments":"Windows or UNIX only for now sorry Mac fans  Constructor - set up strings and things. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getResource":1,"println":1,"showMessageDialog":1,"size":1,"getClassLoader":1,"getRuntime":1,"push":1,"exec":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"URL":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":31,"StringLiteralExpr":5,"FieldAccessExpr":1,"ThisExpr":2,"MethodCallExpr":9},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public void run() {\n    try {\n        // Get the URL for the Help File\n        URL helpURL = this.getClass().getClassLoader().getResource(HELPFILE);\n        // Start Netscape from the Java Application.\n        pStack.push(Runtime.getRuntime().exec(program + \" \" + helpURL));\n        Debug.println(\"trace\", \"In main after exec \" + pStack.size());\n    } catch (Exception ex) {\n        JOptionPane.showMessageDialog(ExecDemoNS.this, \"Error\" + ex, \"Error\", JOptionPane.ERROR_MESSAGE);\n    }\n}\n","name":"run","className":"","variables":{"Runtime":1,"ExecDemoNS":1,"ex":2,"helpURL":2,"program":1,"JOptionPane":1,"pStack":2,"Debug":1},"constants":{"\"In main after exec \"":1,"\"Error\"":2,"\" \"":1,"\"trace\"":1},"javaDoc":"","comments":"Start Netscape from the Java Application Get the URL for the Help File ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getResource":1,"println":1,"showMessageDialog":1,"size":1,"getClassLoader":1,"getRuntime":1,"push":1,"exec":1},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"URL":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":35,"StringLiteralExpr":5,"FieldAccessExpr":1,"ThisExpr":2,"MethodCallExpr":10},"statements":{"BlockStmt":3,"TryStmt":1,"ExpressionStmt":5},"text":"/** Start the help, in its own Thread. */\npublic void runProg() {\n    new Thread() {\n\n        public void run() {\n            try {\n                // Get the URL for the Help File\n                URL helpURL = this.getClass().getClassLoader().getResource(HELPFILE);\n                // Start Netscape from the Java Application.\n                pStack.push(Runtime.getRuntime().exec(program + \" \" + helpURL));\n                Debug.println(\"trace\", \"In main after exec \" + pStack.size());\n            } catch (Exception ex) {\n                JOptionPane.showMessageDialog(ExecDemoNS.this, \"Error\" + ex, \"Error\", JOptionPane.ERROR_MESSAGE);\n            }\n        }\n    }.start();\n}\n","name":"runProg","className":"ExecDemoNS","variables":{"Runtime":1,"ExecDemoNS":1,"ex":2,"helpURL":2,"run":1,"program":1,"JOptionPane":1,"pStack":2,"Debug":1},"constants":{"\"In main after exec \"":1,"\"Error\"":2,"\" \"":1,"\"trace\"":1},"javaDoc":"Start the help in its own Thread","comments":"Start Netscape from the Java Application Get the URL for the Help File  Start the help, in its own Thread. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"pop":1,"println":2,"showMessageDialog":1,"size":3,"waitFor":1,"peek":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":5,"NameExpr":30,"StringLiteralExpr":7,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"public void doWait() {\n    if (pStack.size() == 0)\n        return;\n    Debug.println(\"trace\", \"Waiting for process \" + pStack.size());\n    try {\n        pStack.peek().waitFor();\n        // wait for process to complete \n        // (may not work as expected for some old Windows programs)\n        Debug.println(\"trace\", \"Process \" + pStack.size() + \" is done\");\n    } catch (Exception ex) {\n        JOptionPane.showMessageDialog(this, \"Error\" + ex, \"Error\", JOptionPane.ERROR_MESSAGE);\n    }\n    pStack.pop();\n}\n","name":"doWait","className":"ExecDemoNS","variables":{"ex":2,"JOptionPane":1,"pStack":5,"Debug":2},"constants":{"0":1,"\"Waiting for process \"":1,"\"Error\"":2,"\"trace\"":2,"\"Process \"":1,"\" is done\"":1},"javaDoc":"","comments":"wait for process to complete (may not work as expected for some old Windows programs) ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ScriptEngineFactory"],"returnType":"CalcScriptEngine","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"CalcScriptEngine(ScriptEngineFactory factory) {\n    super();\n    this.factory = factory;\n}\n","name":"CalcScriptEngine","className":"CalcScriptEngine","variables":{"factory":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String","ScriptContext"],"returnType":"Object","methodCalls":{"pop":8,"getAttribute":1,"hasMoreElements":1,"nextToken":1,"equals":4,"push":1,"System.out.println":1},"annotations":["Override"],"exceptions":["ScriptException"],"concepts":["FinalVariables","PolyMorphism"],"types":{"Integer":2,"StringTokenizer":1,"String":1,"Stack<Integer>":1,"Stack":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":5,"NameExpr":58,"StringLiteralExpr":5,"CastExpr":1,"FieldAccessExpr":1,"MethodCallExpr":17},"statements":{"IfStmt":4,"WhileStmt":1,"BlockStmt":5,"ReturnStmt":5,"ExpressionStmt":7},"text":"@Override\npublic Object eval(String script, ScriptContext context) throws ScriptException {\n    System.out.println(\"CalcScriptEngine.eval(): Running: \" + script);\n    Stack<Integer> stack = new Stack<>();\n    StringTokenizer st = new StringTokenizer(script);\n    while (st.hasMoreElements()) {\n        String tok = st.nextToken();\n        if (tok.equals(\"+\")) {\n            return stack.pop() + stack.pop();\n        }\n        if (tok.equals(\"-\")) {\n            final Integer tos = stack.pop();\n            return stack.pop() - tos;\n        }\n        if (tok.equals(\"*\")) {\n            return stack.pop() * stack.pop();\n        }\n        if (tok.equals(\"/\")) {\n            final Integer tos = stack.pop();\n            return stack.pop() / tos;\n        }\n        // else ... check for other operators\n        // If nothing else, must be a name. get and stack its value\n        stack.push((Integer) context.getAttribute(tok));\n    }\n    return 0;\n}\n","name":"eval","className":"CalcScriptEngine","variables":{"st":3,"tok":5,"stack":10,"context":1,"tos":4,"script":2},"constants":{"0":1,"\"/\"":1,"\"-\"":1,"\"+\"":1,"\"*\"":1,"\"CalcScriptEngine.eval(): Running: \"":1},"javaDoc":"","comments":"else check for other operators If nothing else must be a name get and stack its value ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader","ScriptContext"],"returnType":"Object","methodCalls":{"System.out.println":1},"annotations":["Override"],"exceptions":["ScriptException","IllegalStateException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ThrowStmt":1,"ExpressionStmt":1},"text":"@Override\npublic Object eval(Reader reader, ScriptContext context) throws ScriptException {\n    System.out.println(\"CalcScriptEngine.eval()\");\n    // return eval(scriptString, context);\n    throw new IllegalStateException(\"eval(Reader) not written yet\");\n}\n         // should read the file into a String, then\n\n","name":"eval","className":"CalcScriptEngine","variables":{},"constants":{"\"eval(Reader) not written yet\"":1,"\"CalcScriptEngine.eval()\"":1},"javaDoc":"","comments":"should read the file into a String then return eval(scriptString context); ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Bindings","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":["PolyMorphism"],"types":{"SimpleBindings":1,"Bindings":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"@Override\npublic Bindings createBindings() {\n    Bindings ret = new SimpleBindings();\n    return ret;\n}\n","name":"createBindings","className":"CalcScriptEngine","variables":{"ret":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ScriptEngineFactory","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic ScriptEngineFactory getFactory() {\n    return factory;\n}\n","name":"getFactory","className":"CalcScriptEngine","variables":{"factory":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic String getEngineName() {\n    return THY_NAME;\n}\n","name":"getEngineName","className":"CalcScriptEngineFactory","variables":{"THY_NAME":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic String getEngineVersion() {\n    return \"0.1\";\n}\n","name":"getEngineVersion","className":"CalcScriptEngineFactory","variables":{},"constants":{"\"0.1\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic String getLanguageName() {\n    return THY_NAME;\n}\n","name":"getLanguageName","className":"CalcScriptEngineFactory","variables":{"THY_NAME":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{"add":1},"annotations":["Override"],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ArrayList":1,"ArrayList<String>":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"@Override\npublic List<String> getExtensions() {\n    ArrayList<String> ret = new ArrayList<>(1);\n    ret.add(\"calc\");\n    return ret;\n}\n","name":"getExtensions","className":"CalcScriptEngineFactory","variables":{"ret":3},"constants":{"1":1,"\"calc\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"ArrayList<String>":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"@Override\npublic List<String> getMimeTypes() {\n    ArrayList<String> ret = new ArrayList<String>(0);\n    return ret;\n}\n","name":"getMimeTypes","className":"CalcScriptEngineFactory","variables":{"ret":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"List<String>","methodCalls":{"add":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"ArrayList<String>":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"@Override\npublic List<String> getNames() {\n    ArrayList<String> ret = new ArrayList<String>(1);\n    ret.add(THY_NAME);\n    return ret;\n}\n","name":"getNames","className":"CalcScriptEngineFactory","variables":{"ret":3},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic String getLanguageVersion() {\n    return \"0.1\";\n}\n","name":"getLanguageVersion","className":"CalcScriptEngineFactory","variables":{},"constants":{"\"0.1\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Object","methodCalls":{"getEngineName":1,"getLanguageVersion":1,"getEngineVersion":1,"getLanguageName":1},"annotations":["Override"],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":22,"StringLiteralExpr":1,"FieldAccessExpr":4,"MethodCallExpr":4},"statements":{"SwitchStmt":1,"SwitchEntryStmt":5,"ReturnStmt":4,"ThrowStmt":1},"text":"@Override\npublic Object getParameter(String key) {\n    switch(key) {\n        case ScriptEngine.ENGINE:\n            return getEngineName();\n        case ScriptEngine.ENGINE_VERSION:\n            return getEngineVersion();\n        case ScriptEngine.LANGUAGE:\n            return getLanguageName();\n        case ScriptEngine.LANGUAGE_VERSION:\n            return getLanguageVersion();\n        default:\n            throw new IllegalArgumentException(\"Unknown parameter \" + key);\n    }\n}\n","name":"getParameter","className":"CalcScriptEngineFactory","variables":{"key":2},"constants":{"\"Unknown parameter \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","String"],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic String getMethodCallSyntax(String obj, String m, String... args) {\n    // TODO Auto-generated method stub\n    return null;\n}\n","name":"getMethodCallSyntax","className":"CalcScriptEngineFactory","variables":{},"constants":{"null":1},"javaDoc":"","comments":"TODO Auto-generated method stub ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic String getOutputStatement(String toDisplay) {\n    return toDisplay;\n}\n","name":"getOutputStatement","className":"CalcScriptEngineFactory","variables":{"toDisplay":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"toString":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic String getProgram(String... statements) {\n    return statements.toString();\n}\n","name":"getProgram","className":"CalcScriptEngineFactory","variables":{"statements":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ScriptEngine","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"ThisExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic ScriptEngine getScriptEngine() {\n    return new CalcScriptEngine(this);\n}\n","name":"getScriptEngine","className":"CalcScriptEngineFactory","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getRuntime":1,"waitFor":1,"exec":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Process":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":8,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"public static void main(String av[]) throws Exception {\n    // Run the \"notepad\" program or a similar editor\n    Process p = Runtime.getRuntime().exec(\"kwrite\");\n    p.waitFor();\n}\n","name":"main","className":"ExecDemoSimple","variables":{"p":2,"Runtime":1},"constants":{"\"kwrite\"":1},"javaDoc":"","comments":"Run the \"notepad\" program or a similar editor ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"run":1,"getRuntime":1,"exec":4},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Runtime":1,"String[]":1},"expressions":{"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"NameExpr":19,"StringLiteralExpr":9,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String av[]) throws Exception {\n    // BEGIN main\n    // Get and save the Runtime object.\n    Runtime rt = Runtime.getRuntime();\n    // Create three temporary files (the slow way!)\n    rt.exec(\"mktemp file1\");\n    rt.exec(\"mktemp file2\");\n    rt.exec(\"mktemp file3\");\n    // Run the \"ls\" (directory lister) program\n    // with its output sent into a file\n    String[] args = { \"ls\", \"-l\", \"file1\", \"file2\", \"file3\" };\n    ExecAndPrint.run(args);\n    rt.exec(\"rm file1 file2 file3\");\n// END main\n}\n","name":"main","className":"ExecDemoFiles","variables":{"args":1,"rt":5,"Runtime":1,"ExecAndPrint":1},"constants":{"\"-l\"":1,"\"file3\"":1,"\"file2\"":1,"\"file1\"":1,"\"mktemp file3\"":1,"\"mktemp file2\"":1,"\"ls\"":1,"\"rm file1 file2 file3\"":1,"\"mktemp file1\"":1},"javaDoc":"","comments":"BEGIN main Run the \"ls\" (directory lister) program END main Get and save the Runtime object Create three temporary files (the slow way!) with its output sent into a file ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"waitFor":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"public void run() {\n    try {\n        p.waitFor();\n    } catch (InterruptedException ex) {\n        return;\n    }\n    System.out.println(\"Program terminated!\");\n    done = true;\n}\n                     // OK, just quit.\n\n","name":"run","className":"","variables":{"p":1,"ex":1,"done":1},"constants":{"\"Program terminated!\"":1,"true":1},"javaDoc":"","comments":"OK just quit ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"println":2,"start":1,"readLine":1,"getRuntime":1,"waitFor":1,"getInputStream":1,"exec":1,"System.out.println":2},"annotations":[],"exceptions":["IOException","InterruptedException"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"BufferedReader":1,"Process":1,"String":1,"Thread":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":42,"StringLiteralExpr":5,"FieldAccessExpr":2,"EnclosedExpr":2,"UnaryExpr":1,"AssignExpr":4,"MethodCallExpr":10},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":2,"ExpressionStmt":13},"text":"public static void main(String argv[]) throws IOException {\n    // Process tracks one external native process\n    final Process p;\n    // reader for output of process\n    BufferedReader is;\n    String line;\n    p = Runtime.getRuntime().exec(PROGRAM);\n    Debug.println(\"exec\", \"In Main after exec\");\n    // Optional: start a thread to wait for the process to terminate.\n    // Don't just wait in main line, but here set a \"done\" flag and\n    // use that to control the main reading loop below.\n    Thread waiter = new Thread() {\n\n        public void run() {\n            try {\n                p.waitFor();\n            } catch (InterruptedException ex) {\n                return;\n            }\n            System.out.println(\"Program terminated!\");\n            done = true;\n        }\n    };\n    waiter.start();\n    // getInputStream gives an Input stream connected to\n    // the process p's standard output (and vice versa). We use\n    // that to construct a BufferedReader so we can readLine() it.\n    is = new BufferedReader(new InputStreamReader(p.getInputStream()));\n    while (!done && ((line = is.readLine()) != null)) System.out.println(line);\n    Debug.println(\"exec\", \"In Main after EOF\");\n    return;\n}\n                     // OK, just quit.\n\n","name":"main","className":"ExecDemoLs","variables":{"p":4,"Runtime":1,"ex":1,"line":2,"is":3,"run":1,"waiter":2,"done":2,"Debug":2},"constants":{"\"exec\"":2,"\"Program terminated!\"":1,"null":1,"\"In Main after exec\"":1,"true":1,"\"In Main after EOF\"":1},"javaDoc":"","comments":"Optional: start a thread to wait for the process to terminate Don't just wait in main line but here set a \"done\" flag and getInputStream gives an Input stream connected to the process p's standard output (and vice versa) We use Process tracks one external native process reader for output of process use that to control the main reading loop below OK just quit that to construct a BufferedReader so we can readLine() it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"eval":1,"forEach":1,"getEngineFactories":1,"getLanguageName":1,"getEngineByName":1,"System.err.println":1,"System.out.println":1},"annotations":[],"exceptions":["ScriptException"],"concepts":[],"types":{"ScriptEngineManager":1,"String":1,"ScriptEngine":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"LambdaExpr":1,"BinaryExpr":3,"NameExpr":27,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] args) throws ScriptException {\n    ScriptEngineManager scriptEngineManager = new ScriptEngineManager();\n    // Print list of supported languages\n    scriptEngineManager.getEngineFactories().forEach( factory -> System.out.println(factory.getLanguageName()));\n    // Run a script in the JavaScript language\n    String lang = \"ECMAScript\";\n    ScriptEngine engine = scriptEngineManager.getEngineByName(lang);\n    if (engine == null) {\n        System.err.println(\"Could not find engine\");\n        return;\n    }\n    engine.eval(\"print(\\\"Hello from \" + lang + \"\\\");\");\n}\n","name":"main","className":"ScriptEnginesDemo","variables":{"factory":2,"scriptEngineManager":3,"engine":3,"lang":2},"constants":{"\"ECMAScript\"":1,"\"Could not find engine\"":1,"null":1,"\"print(\\\"Hello from \"":1,"\"\\\");\"":1},"javaDoc":"","comments":"Print list of supported languages Run a script in the JavaScript language ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"environment":1,"getProperty":1,"start":1,"System.err.println":1,"directory":1,"waitFor":1,"put":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["FinalVariables","PolyMorphism"],"types":{"ProcessBuilder":1,"ArrayList":1,"Process":1,"List<String>":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"NameExpr":33,"StringLiteralExpr":7,"FieldAccessExpr":2,"MethodCallExpr":10},"statements":{"ReturnStmt":1,"ExpressionStmt":9},"text":"public static void main(String argv[]) throws Exception {\n    // BEGIN main\n    // <1>\n    List<String> command = new ArrayList<>();\n    command.add(\"notepad\");\n    command.add(\"foo.txt\");\n    // <2>\n    ProcessBuilder builder = new ProcessBuilder(command);\n    builder.environment().put(\"PATH\", // <3>\n    \"/windows;/windows/system32;/winnt\");\n    final Process godot = builder.directory(// <4>\n    new File(System.getProperty(\"user.home\"))).start();\n    // <5>\n    System.err.println(\"Waiting for Godot\");\n    // <6>\n    godot.waitFor();\n    // END main\n    System.out.println(\"Program terminated!\");\n    return;\n}\n","name":"main","className":"ProcessBuilderDemo","variables":{"builder":3,"command":4,"godot":2,"System":1},"constants":{"\"PATH\"":1,"\"notepad\"":1,"\"Program terminated!\"":1,"\"user.home\"":1,"\"foo.txt\"":1,"\"Waiting for Godot\"":1},"javaDoc":"","comments":"BEGIN main END main <1> <2> <3> <4> <5> <6> ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"match":1,"toString":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"ArrayAccessExpr":2,"NameExpr":14,"MethodCallExpr":5},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent ae) {\n    dist.setText(Integer.toString(match(tf[0].getText(), tf[1].getText())));\n}\n","name":"actionPerformed","className":"","variables":{"Integer":1,"tf":2,"dist":1},"constants":{"0":1,"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent ae) {\n    frame.dispose();\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"System":1,"frame":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"StringDistance","methodCalls":{"add":6,"exit":1,"setEditable":1,"addActionListener":2,"match":2,"getContentPane":1,"toString":2,"dispose":1,"setLayout":1,"pack":1,"setText":2},"annotations":[],"exceptions":["InlineJavaException"],"concepts":["InnerMethod"],"types":{"Container":1,"int":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":13,"VariableDeclarationExpr":2,"ArrayAccessExpr":8,"BinaryExpr":9,"NameExpr":104,"StringLiteralExpr":6,"UnaryExpr":1,"AssignExpr":6,"NullLiteralExpr":2,"BooleanLiteralExpr":1,"FieldAccessExpr":2,"EnclosedExpr":4,"ArrayCreationExpr":1,"MethodCallExpr":25},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":23},"text":"/* The constructor with possibly 2 initial strings */\npublic StringDistance(String[] strs) throws InlineJavaException {\n    frame = new JFrame(\"StringDistance\");\n    Container p = frame.getContentPane();\n    p.setLayout(new GridLayout(0, 2));\n    // The input fields, including labels:\n    tf = new JTextField[2];\n    for (int i = 0; i < 2; i++) {\n        p.add(new JLabel(\"String \" + i + \":\"));\n        tf[i] = new JTextField(20);\n        if ((strs != null) && (i < strs.length))\n            tf[i].setText(strs[i]);\n        p.add(tf[i]);\n    }\n    // The output field, including label:\n    p.add(new JLabel(\"Distance:\"));\n    dist = new JTextField(5);\n    dist.setEditable(false);\n    p.add(dist);\n    // The main action button:\n    go = new JButton(\"Compute distance\");\n    go.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent ae) {\n            dist.setText(Integer.toString(match(tf[0].getText(), tf[1].getText())));\n        }\n    });\n    p.add(go);\n    // To finish off:\n    exit = new JButton(\"Exit\");\n    exit.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent ae) {\n            frame.dispose();\n            System.exit(0);\n        }\n    });\n    p.add(exit);\n    if ((strs != null) && (strs.length > 1))\n        dist.setText(Integer.toString(match(tf[0].getText(), tf[1].getText())));\n    frame.pack();\n}\n","name":"StringDistance","className":"StringDistance","variables":{"p":8,"Integer":2,"actionPerformed":2,"exit":2,"tf":8,"strs":3,"ae":2,"go":2,"i":9,"dist":4,"System":1,"frame":4},"constants":{"\"StringDistance\"":1,"false":1,"\":\"":1,"\"Exit\"":1,"\"Distance:\"":1,"0":5,"\"Compute distance\"":1,"1":3,"2":3,"null":2,"5":1,"\"String \"":1,"20":1},"javaDoc":"","comments":"The input fields including labels: The output field including label: The main action button: To finish off:  The constructor with possibly 2 initial strings ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"StringDistance","methodCalls":{},"annotations":[],"exceptions":["InlineJavaException"],"concepts":[],"types":{},"expressions":{"ArrayInitializerExpr":1,"NameExpr":2,"ArrayCreationExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"// Alternative constructors:\npublic StringDistance(String s0, String s1) throws InlineJavaException {\n    this(new String[] { s0, s1 });\n}\n","name":"StringDistance","className":"StringDistance","variables":{"s0":1,"s1":1},"constants":{},"javaDoc":"","comments":" Alternative constructors:","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"StringDistance","methodCalls":{},"annotations":[],"exceptions":["InlineJavaException"],"concepts":[],"types":{},"expressions":{"ArrayInitializerExpr":1,"NameExpr":1,"ArrayCreationExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public StringDistance(String s0) throws InlineJavaException {\n    this(new String[] { s0 });\n}\n","name":"StringDistance","className":"StringDistance","variables":{"s0":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"StringDistance","methodCalls":{},"annotations":[],"exceptions":["InlineJavaException"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"CastExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public StringDistance() throws InlineJavaException {\n    this((String[]) null);\n}\n","name":"StringDistance","className":"StringDistance","variables":{},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** This shows everything */\npublic void show() {\n    frame.setVisible(true);\n}\n","name":"show","className":"StringDistance","variables":{"frame":1},"constants":{"true":1},"javaDoc":"This shows everything","comments":" This shows everything ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/* Optionally for pre-filling the input fields. */\npublic void setText(int fieldno, String str) {\n    tf[fieldno].setText(str);\n}\n","name":"setText","className":"StringDistance","variables":{"fieldno":1,"tf":1},"constants":{},"javaDoc":"","comments":" Optionally for pre-filling the input fields. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"int","methodCalls":{"parseInt":1,"CallPerl":1,"System.err.println":2},"annotations":[],"exceptions":["InlineJavaPerlException","InlineJavaException"],"concepts":["Casting","ExceptionHandling"],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayInitializerExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":20,"StringLiteralExpr":4,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":3,"ReturnStmt":2,"ExpressionStmt":3},"text":"/** The central interface function to Perl. */\npublic int match(String s0, String s1) {\n    try {\n        String str = (String) CallPerl(\"Text::Levenshtein\", \"distance\", new Object[] { s0, s1 });\n        return Integer.parseInt(str);\n    } catch (InlineJavaPerlException e) {\n        System.err.println(\"Inline Java Perl Exception: \" + e);\n    } catch (InlineJavaException e) {\n        System.err.println(\"Inline Java Exception: \" + e);\n    }\n    return 0;\n}\n","name":"match","className":"StringDistance","variables":{"str":1,"Integer":1,"e":4,"s0":1,"s1":1},"constants":{"0":1,"\"Text::Levenshtein\"":1,"\"Inline Java Exception: \"":1,"\"distance\"":1,"\"Inline Java Perl Exception: \"":1},"javaDoc":"The central interface function to Perl","comments":" The central interface function to Perl. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"compile":1,"matcher":1,"matches":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Pattern":1,"String":1,"String[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"ArrayAccessExpr":3,"BinaryExpr":5,"StringLiteralExpr":8,"NameExpr":35,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    // egal\n    String pattStr = \"égal\";\n    String[] input = { // egal - this one had better match :-)\n    \"égal\", // e + \"Combining acute accent\"\n    \"égal\", // e + \"modifier letter acute accent\"\n    \"eˊgal\", // e + single quote\n    \"e'gal\", // e + Latin-1 \"acute\"\n    \"e´gal\" };\n    Pattern pattern = Pattern.compile(pattStr, Pattern.CANON_EQ);\n    for (int i = 0; i < input.length; i++) {\n        if (pattern.matcher(input[i]).matches()) {\n            System.out.println(pattStr + \" matches input \" + input[i]);\n        } else {\n            System.out.println(pattStr + \" does not match input \" + input[i]);\n        }\n    }\n}\n","name":"main","className":"CanonEqDemo","variables":{"input":4,"Pattern":1,"pattStr":3,"pattern":2,"i":6},"constants":{"0":1,"\" does not match input \"":1,"\" matches input \"":1,"\"égal\"":1},"javaDoc":"","comments":"egal egal - this one had better match :-) e + \"Combining acute accent\" e + \"modifier letter acute accent\" e + single quote e + Latin-1 \"acute\" ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"lookingAt":1,"compile":1,"matcher":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Pattern":1,"boolean":1,"String":2,"String[]":1},"expressions":{"VariableDeclarationExpr":5,"ArrayInitializerExpr":1,"BinaryExpr":5,"StringLiteralExpr":8,"NameExpr":19,"FieldAccessExpr":1,"EnclosedExpr":1,"ConditionalExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] argv) {\n    String pattern = \"^Q[^u]\\\\d+\\\\.\";\n    String[] input = { \"QA777. is the next flight. It is on time.\", \"Quack, Quack, Quack!\" };\n    Pattern p = Pattern.compile(pattern);\n    for (String in : input) {\n        boolean found = p.matcher(in).lookingAt();\n        System.out.println(\"'\" + pattern + \"'\" + (found ? \" matches '\" : \" doesn't match '\") + in + \"'\");\n    }\n}\n","name":"main","className":"RESimple","variables":{"p":2,"input":2,"Pattern":1,"found":2,"in":2,"pattern":2},"constants":{"\"Quack, Quack, Quack!\"":1,"\"^Q[^u]\\\\d+\\\\.\"":1,"\"QA777. is the next flight. It is on time.\"":1,"\" matches '\"":1,"\" doesn't match '\"":1,"\"'\"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"compile":1,"matcher":1,"matches":1,"System.out.println":1,"group":2},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"Pattern":1,"Matcher":1,"String":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":2,"StringLiteralExpr":3,"NameExpr":21,"FieldAccessExpr":1,"CharLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    String inputLine = \"Adams, John Quincy\";\n    // Construct an RE with parens to \"grab\" both field1 and field2\n    Pattern r = Pattern.compile(\"(.*), (.*)\");\n    Matcher m = r.matcher(inputLine);\n    if (!m.matches())\n        throw new IllegalArgumentException(\"Bad input\");\n    System.out.println(m.group(2) + ' ' + m.group(1));\n}\n","name":"main","className":"REmatchTwoFields","variables":{"Pattern":1,"r":2,"inputLine":1,"m":4},"constants":{"1":1,"2":1,"\"Adams, John Quincy\"":1,"\"(.*), (.*)\"":1,"\"Bad input\"":1,"' '":1},"javaDoc":"","comments":"Construct an RE with parens to \"grab\" both field1 and field2 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"compile":1,"find":1,"start":1,"end":1,"readLine":1,"matcher":1,"substring":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Pattern":1,"Matcher":1,"BufferedReader":1,"String":1,"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":6,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":31,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":8,"AssignExpr":1},"statements":{"WhileStmt":2,"BlockStmt":2,"ExpressionStmt":7},"text":"public static void main(String[] args) throws IOException {\n    // The RE pattern\n    Pattern patt = Pattern.compile(\"[A-Za-z][a-z]+\");\n    // A FileReader (see the I/O chapter)\n    BufferedReader r = new BufferedReader(new FileReader(args[0]));\n    // For each line of input, try matching in it.\n    String line;\n    while ((line = r.readLine()) != null) {\n        // For each match in the line, extract and print it.\n        Matcher m = patt.matcher(line);\n        while (m.find()) {\n            // Simplest method:\n            // System.out.println(m.group(0));\n            // Get the starting position of the text\n            int start = m.start(0);\n            // Get ending position\n            int end = m.end(0);\n            // Print whatever matched.\n            // Use CharacterIterator.substring(offset, end);\n            System.out.println(line.substring(start, end));\n        }\n    }\n}\n","name":"main","className":"ReaderIter","variables":{"args":1,"Pattern":1,"r":2,"patt":2,"line":3,"start":1,"end":1,"m":4},"constants":{"0":3,"null":1,"\"[A-Za-z][a-z]+\"":1},"javaDoc":"","comments":"The RE pattern A FileReader (see the I/O chapter) For each line of input try matching in it For each match in the line extract and print it Simplest method: System out println(m group(0)); Print whatever matched Get the starting position of the text Get ending position Use CharacterIterator substring(offset end); ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"compile":1,"find":1,"reset":1,"System.err.println":1,"matcher":1,"readLine":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Pattern":1,"Matcher":1,"BufferedReader":1,"String":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"NullLiteralExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":38,"StringLiteralExpr":3,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":8,"AssignExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public static void main(String[] args) throws IOException {\n    BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n    if (args.length != 1) {\n        System.err.println(\"Usage: MatchLines pattern\");\n        System.exit(1);\n    }\n    Pattern patt = Pattern.compile(args[0]);\n    Matcher matcher = patt.matcher(\"\");\n    String line = null;\n    while ((line = is.readLine()) != null) {\n        matcher.reset(line);\n        if (matcher.find()) {\n            System.out.println(\"MATCH: \" + line);\n        }\n    }\n}\n","name":"main","className":"Grep0","variables":{"args":1,"Pattern":1,"patt":2,"line":3,"is":2,"matcher":3,"System":1},"constants":{"0":1,"\"\"":1,"1":2,"\"Usage: MatchLines pattern\"":1,"null":2,"\"MATCH: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"process":1,"compile":1,"System.err.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Pattern":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":25,"StringLiteralExpr":1,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) throws IOException {\n    if (args.length < 2) {\n        System.err.println(\"Usage: GrepNIO patt file [...]\");\n        System.exit(1);\n    }\n    Pattern p = Pattern.compile(args[0]);\n    for (int i = 1; i < args.length; i++) process(p, args[i]);\n}\n","name":"main","className":"GrepNIO","variables":{"p":1,"args":2,"Pattern":1,"i":4,"System":1},"constants":{"0":1,"1":2,"2":1,"\"Usage: GrepNIO patt file [...]\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Pattern","String"],"returnType":"void","methodCalls":{"size":1,"forName":1,"newDecoder":1,"find":1,"decode":1,"matcher":1,"map":1,"System.out.println":1,"group":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Matcher":1,"FileChannel":1,"CharBuffer":1,"ByteBuffer":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"NameExpr":37,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":10},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"static void process(Pattern pattern, String fileName) throws IOException {\n    // Get a FileChannel from the given file.\n    FileChannel fc = new FileInputStream(fileName).getChannel();\n    // Map the file's content\n    ByteBuffer buf = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());\n    // Decode ByteBuffer into CharBuffer\n    CharBuffer cbuf = Charset.forName(\"ISO-8859-1\").newDecoder().decode(buf);\n    Matcher m = pattern.matcher(cbuf);\n    while (m.find()) {\n        System.out.println(m.group(0));\n    }\n}\n","name":"process","className":"GrepNIO","variables":{"fileName":1,"buf":1,"pattern":1,"Charset":1,"fc":3,"m":3,"cbuf":1},"constants":{"0":2,"\"ISO-8859-1\"":1},"javaDoc":"","comments":"Get a FileChannel from the given file Map the file's content Decode ByteBuffer into CharBuffer ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"compile":1,"find":1,"start":1,"end":1,"matcher":1,"substring":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Pattern":1,"Matcher":1,"String":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":5,"StringLiteralExpr":6,"NameExpr":32,"FieldAccessExpr":2,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    String patt = \"Q[^u]\\\\d+\\\\.\";\n    Pattern r = Pattern.compile(patt);\n    String line = \"Order QT300. Now!\";\n    Matcher m = r.matcher(line);\n    if (m.find()) {\n        System.out.println(patt + \" matches \\\"\" + line.substring(m.start(0), m.end(0)) + \"\\\" in \\\"\" + line + \"\\\"\");\n    } else {\n        System.out.println(\"NO MATCH\");\n    }\n// END main\n}\n","name":"main","className":"REsubstr","variables":{"Pattern":1,"r":2,"patt":2,"line":3,"m":4},"constants":{"0":2,"\"NO MATCH\"":1,"\"Q[^u]\\\\d+\\\\.\"":1,"\"\\\" in \\\"\"":1,"\"\\\"\"":1,"\"Order QT300. Now!\"":1,"\" matches \\\"\"":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"matches":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":3,"StringLiteralExpr":5,"NameExpr":16,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public static void main(String[] argv) {\n    String pattern = \".*Q[^u]\\\\d+\\\\..*\";\n    String line = \"Order QT300. Now!\";\n    if (line.matches(pattern)) {\n        System.out.println(line + \" matches \\\"\" + pattern + \"\\\"\");\n    } else {\n        System.out.println(\"NO MATCH\");\n    }\n}\n","name":"main","className":"StringConvenience","variables":{"line":3,"pattern":2},"constants":{"\"NO MATCH\"":1,"\".*Q[^u]\\\\d+\\\\..*\"":1,"\"\\\"\"":1,"\"Order QT300. Now!\"":1,"\" matches \\\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"println":1,"print":1,"getProperty":4,"load":1,"getOutputStream":1,"close":2,"getRuntime":1,"getBookRank":1,"exec":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Process":1,"String":6,"Properties":1,"int":1,"PrintWriter":2},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":2,"VariableDeclarationExpr":11,"ArrayAccessExpr":1,"BinaryExpr":18,"BooleanLiteralExpr":1,"NameExpr":66,"StringLiteralExpr":25,"FieldAccessExpr":3,"ConditionalExpr":1,"UnaryExpr":1,"MethodCallExpr":17},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":18},"text":"/** Grab the sales rank off the web page and log it. */\npublic static void main(String[] args) throws Exception {\n    Properties p = new Properties();\n    p.load(new FileInputStream(args.length == 0 ? \"bookrank.properties\" : args[1]));\n    String title = p.getProperty(\"title\", \"NO TITLE IN PROPERTIES\");\n    // The url must have the \"isbn=\" at the very end, or otherwise\n    // be amenable to being string-catted to, like the default.\n    String url = p.getProperty(\"url\", \"http://test.ing/test.cgi?isbn=\");\n    // The 10-digit ISBN for the book.\n    String isbn = p.getProperty(\"isbn\", \"0000000000\");\n    // The RE pattern (MUST have ONE capture group for the number)\n    String pattern = p.getProperty(\"pattern\", \"Rank: (\\\\d+)\");\n    int rank = getBookRank(isbn);\n    System.out.println(\"Rank is \" + rank);\n    // Now try to draw the graph, using external\n    // plotting program against all historical data.\n    // Could use gnuplot, R, any other math/graph program.\n    // Better yet: use one of the Java plotting APIs.\n    PrintWriter pw = new PrintWriter(new FileWriter(DATA_FILE, true));\n    String date = new SimpleDateFormat(\"MM dd hh mm ss yyyy \").format(new Date());\n    pw.println(date + \" \" + rank);\n    pw.close();\n    String gnuplot_cmd = \"set term png\\n\" + \"set output \\\"\" + GRAPH_FILE + \"\\\"\\n\" + \"set xdata time\\n\" + \"set ylabel \\\"Book sales rank\\\"\\n\" + \"set bmargin 3\\n\" + \"set logscale y\\n\" + \"set yrange [1:60000] reverse\\n\" + \"set timefmt \\\"%m %d %H %M %S %Y\\\"\\n\" + \"plot \\\"\" + DATA_FILE + \"\\\" using 1:7 title \\\"\" + title + \"\\\" with lines\\n\";\n    if (!new File(PLOTTER_PROG).exists()) {\n        System.out.println(\"Plotting software not installed\");\n        return;\n    }\n    Process proc = Runtime.getRuntime().exec(PLOTTER_PROG);\n    PrintWriter gp = new PrintWriter(proc.getOutputStream());\n    gp.print(gnuplot_cmd);\n    gp.close();\n}\n","name":"main","className":"BookRank","variables":{"date":2,"proc":2,"isbn":1,"pw":3,"pattern":1,"gp":3,"title":2,"GRAPH_FILE":1,"url":1,"p":6,"args":1,"Runtime":1,"rank":3,"DATA_FILE":2,"PLOTTER_PROG":1,"gnuplot_cmd":1},"constants":{"\"bookrank.properties\"":1,"\"set term png\\n\"":1,"\"isbn\"":1,"\"MM dd hh mm ss yyyy \"":1,"\"set timefmt \\\"%m %d %H %M %S %Y\\\"\\n\"":1,"\"\\\"\\n\"":1,"\"0000000000\"":1,"\"set output \\\"\"":1,"\"\\\" with lines\\n\"":1,"\"NO TITLE IN PROPERTIES\"":1,"\"set logscale y\\n\"":1,"\"set bmargin 3\\n\"":1,"\"set yrange [1:60000] reverse\\n\"":1,"\"url\"":1,"\"Plotting software not installed\"":1,"\"Rank: (\\\\d+)\"":1,"\" \"":1,"\"set xdata time\\n\"":1,"\"title\"":1,"\"Rank is \"":1,"\"plot \\\"\"":1,"\"http://test.ing/test.cgi?isbn=\"":1,"\"pattern\"":1,"0":1,"1":1,"\"set ylabel \\\"Book sales rank\\\"\\n\"":1,"true":1,"\"\\\" using 1:7 title \\\"\"":1},"javaDoc":"Grab the sales rank off the web page and log it","comments":"The url must have the \"isbn=\" at the very end or otherwise Now try to draw the graph using external plotting program against all historical data Could use gnuplot R any other math/graph program Better yet: use one of the Java plotting APIs be amenable to being string-catted to like the default The 10-digit ISBN for the book The RE pattern (MUST have ONE capture group for the number)  Grab the sales rank off the web page and log it. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"int","methodCalls":{"parseInt":1,"readerToString":1,"compile":1,"find":1,"replace":1,"matcher":1,"group":1},"annotations":[],"exceptions":["RuntimeException","IOException"],"concepts":["FinalVariables"],"types":{"Pattern":1,"Matcher":1,"BufferedReader":1,"String":3},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":3,"StringLiteralExpr":6,"NameExpr":27,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":6},"text":"/**\n     * Look for something like this in the HTML input:\n     *     <b>Sales Rank:</b> \n     *     #26,252\n     *      </font><br>\n     * @throws IOException \n     * @throws IOException \n     */\npublic static int getBookRank(String isbn) throws IOException {\n    // The RE pattern - digits and commas allowed\n    final String pattern = \"Rank:</b> #([\\\\d,]+)\";\n    final Pattern r = Pattern.compile(pattern);\n    // The url -- must have the \"isbn=\" at the very end, or otherwise\n    // be amenable to being appended to.\n    final String url = \"http://www.amazon.com/exec/obidos/ASIN/\" + isbn;\n    // Open the URL and get a Reader from it.\n    final BufferedReader is = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n    // Read the URL looking for the rank information, as\n    // a single long string, so can match RE across multi-lines.\n    final String input = readerToString(is);\n    // If found, append to sales data file.\n    Matcher m = r.matcher(input);\n    if (m.find()) {\n        // Paren 1 is the digits (and maybe ','s) that matched; remove comma\n        return Integer.parseInt(m.group(1).replace(\",\", \"\"));\n    } else {\n        throw new RuntimeException(\"Pattern not matched in `\" + url + \"'!\");\n    }\n}\n","name":"getBookRank","className":"BookRank","variables":{"Integer":1,"Pattern":1,"input":1,"r":2,"isbn":1,"pattern":1,"is":1,"m":3,"url":3},"constants":{"\"\"":1,"1":1,"\"Pattern not matched in `\"":1,"\"Rank:</b> #([\\\\d,]+)\"":1,"\"'!\"":1,"\",\"":1,"\"http://www.amazon.com/exec/obidos/ASIN/\"":1},"javaDoc":"Look for something like this in the HTML input: <b>Sales Rank:</b> #26 252 </font><br> @throws IOException @throws IOException","comments":"The url -- must have the \"isbn=\" at the very end or otherwise Read the URL looking for the rank information as The RE pattern - digits and commas allowed be amenable to being appended to Open the URL and get a Reader from it a single long string so can match RE across multi-lines If found append to sales data file Paren 1 is the digits (and maybe ' 's) that matched; remove comma \n     * Look for something like this in the HTML input:\n     *     <b>Sales Rank:</b> \n     *     #26,252\n     *      </font><br>\n     * @throws IOException \n     * @throws IOException \n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["BufferedReader"],"returnType":"String","methodCalls":{"toString":1,"readLine":1,"append":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"StringBuilder":1,"String":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"private static String readerToString(BufferedReader is) throws IOException {\n    StringBuilder sb = new StringBuilder();\n    String line;\n    while ((line = is.readLine()) != null) {\n        sb.append(line);\n    }\n    return sb.toString();\n}\n","name":"readerToString","className":"BookRank","variables":{"line":2,"is":1,"sb":3},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"compile":1,"find":1,"matcher":1,"System.out.println":2,"group":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Pattern":1,"Matcher":1,"String":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":5,"StringLiteralExpr":6,"NameExpr":26,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"public static void main(String[] argv) {\n    String patt = \"Q[^u]\\\\d+\\\\.\";\n    Pattern r = Pattern.compile(patt);\n    String line = \"Order QT300. Now!\";\n    Matcher m = r.matcher(line);\n    if (m.find()) {\n        System.out.println(patt + \" matches \\\"\" + m.group(0) + \"\\\" in \\\"\" + line + \"\\\"\");\n    } else {\n        System.out.println(\"NO MATCH\");\n    }\n}\n","name":"main","className":"REmatch","variables":{"Pattern":1,"r":2,"patt":2,"line":2,"m":3},"constants":{"0":1,"\"NO MATCH\"":1,"\"Q[^u]\\\\d+\\\\.\"":1,"\"\\\" in \\\"\"":1,"\"\\\"\"":1,"\"Order QT300. Now!\"":1,"\" matches \\\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"appendTail":1,"compile":1,"find":1,"reset":1,"toString":1,"matcher":1,"replaceAll":1,"System.out.print":1,"System.out.println":3,"appendReplacement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Pattern":1,"StringBuffer":1,"Matcher":1,"String":2},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":2,"StringLiteralExpr":7,"NameExpr":49,"FieldAccessExpr":4,"MethodCallExpr":12},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":12},"text":"public static void main(String[] argv) {\n    // Make an RE pattern to match as a word only (\\b=word boundary)\n    String patt = \"\\\\bfavor\\\\b\";\n    // A test input.\n    String input = \"Do me a favor? Fetch my favorite.\";\n    System.out.println(\"Input: \" + input);\n    // Run it from a RE instance and see that it works\n    Pattern r = Pattern.compile(patt);\n    Matcher m = r.matcher(input);\n    System.out.println(\"ReplaceAll: \" + m.replaceAll(\"favour\"));\n    // Show the appendReplacement method\n    m.reset();\n    StringBuffer sb = new StringBuffer();\n    System.out.print(\"Append methods: \");\n    while (m.find()) {\n        // Copy to before first match,\n        // plus the word \"favor\"\n        m.appendReplacement(sb, \"favour\");\n    }\n    // copy remainder\n    m.appendTail(sb);\n    System.out.println(sb.toString());\n}\n","name":"main","className":"ReplaceDemo","variables":{"input":2,"Pattern":1,"r":2,"patt":1,"m":6,"sb":2},"constants":{"\"Append methods: \"":1,"\"\\\\bfavor\\\\b\"":1,"\"favour\"":2,"\"Do me a favor? Fetch my favorite.\"":1,"\"Input: \"":1,"\"ReplaceAll: \"":1},"javaDoc":"","comments":"Make an RE pattern to match as a word only (\\b=word boundary) A test input Run it from a RE instance and see that it works Show the appendReplacement method Copy to before first match plus the word \"favor\" copy remainder ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"compile":2,"find":2,"matcher":2,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"Pattern":2,"boolean":1,"String":1,"String[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"ArrayInitializerExpr":1,"ArrayAccessExpr":3,"BinaryExpr":6,"StringLiteralExpr":8,"NameExpr":70,"FieldAccessExpr":9,"UnaryExpr":1,"MethodCallExpr":12,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] argv) {\n    String input = \"I dream of engines\\nmore engines, all day long\";\n    System.out.println(\"INPUT: \" + input);\n    System.out.println();\n    String[] patt = { \"engines.more engines\", \"ines\\nmore\", \"engines$\" };\n    for (int i = 0; i < patt.length; i++) {\n        System.out.println(\"PATTERN \" + patt[i]);\n        boolean found;\n        Pattern p1l = Pattern.compile(patt[i]);\n        found = p1l.matcher(input).find();\n        System.out.println(\"DEFAULT match \" + found);\n        Pattern pml = Pattern.compile(patt[i], Pattern.DOTALL | Pattern.MULTILINE);\n        found = pml.matcher(input).find();\n        System.out.println(\"MultiLine match \" + found);\n        System.out.println();\n    }\n}\n","name":"main","className":"NLMatch","variables":{"input":2,"Pattern":2,"found":5,"patt":4,"i":6,"p1l":2,"pml":2},"constants":{"0":1,"\"I dream of engines\\nmore engines, all day long\"":1,"\"engines.more engines\"":1,"\"engines$\"":1,"\"PATTERN \"":1,"\"DEFAULT match \"":1,"\"ines\\nmore\"":1,"\"MultiLine match \"":1,"\"INPUT: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"compile":1,"groupCount":1,"equals":1,"matcher":1,"System.err.println":2,"matches":1,"System.out.println":12,"group":9},"annotations":[],"exceptions":[],"concepts":[],"types":{"Pattern":1,"Matcher":1,"String":2},"expressions":{"IntegerLiteralExpr":9,"VariableDeclarationExpr":4,"BinaryExpr":11,"StringLiteralExpr":14,"NameExpr":122,"FieldAccessExpr":16,"UnaryExpr":2,"MethodCallExpr":28},"statements":{"IfStmt":2,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":18},"text":"public static void main(String argv[]) {\n    String logEntryPattern = \"^([\\\\d.]+) (\\\\S+) (\\\\S+) \\\\[([\\\\w:/]+\\\\s[+-]\\\\d{4})\\\\] \" + \"\\\"(.+?)\\\" (\\\\d{3}) (\\\\d+) \\\"([^\\\"]+)\\\" \\\"([^\\\"]+)\\\"\";\n    System.out.println(\"RE Pattern:\");\n    System.out.println(logEntryPattern);\n    System.out.println(\"Input line is:\");\n    String logEntryLine = LogExample.logEntryLine;\n    System.out.println(logEntryLine);\n    Pattern p = Pattern.compile(logEntryPattern);\n    Matcher matcher = p.matcher(logEntryLine);\n    if (!matcher.matches() || LogExample.NUM_FIELDS != matcher.groupCount()) {\n        System.err.println(\"Bad log entry (or problem with regex):\");\n        System.err.println(logEntryLine);\n        return;\n    }\n    System.out.println(\"IP Address: \" + matcher.group(1));\n    System.out.println(\"UserName: \" + matcher.group(3));\n    System.out.println(\"Date/Time: \" + matcher.group(4));\n    System.out.println(\"Request: \" + matcher.group(5));\n    System.out.println(\"Response: \" + matcher.group(6));\n    System.out.println(\"Bytes Sent: \" + matcher.group(7));\n    if (!matcher.group(8).equals(\"-\"))\n        System.out.println(\"Referer: \" + matcher.group(8));\n    System.out.println(\"User-Agent: \" + matcher.group(9));\n}\n","name":"main","className":"LogRegExp","variables":{"p":2,"logEntryLine":1,"Pattern":1,"logEntryPattern":1,"matcher":12},"constants":{"\"UserName: \"":1,"\"Input line is:\"":1,"\"^([\\\\d.]+) (\\\\S+) (\\\\S+) \\\\[([\\\\w:/]+\\\\s[+-]\\\\d{4})\\\\] \"":1,"\"Request: \"":1,"\"Referer: \"":1,"\"\\\"(.+?)\\\" (\\\\d{3}) (\\\\d+) \\\"([^\\\"]+)\\\" \\\"([^\\\"]+)\\\"\"":1,"1":1,"\"User-Agent: \"":1,"\"RE Pattern:\"":1,"3":1,"\"Date/Time: \"":1,"\"IP Address: \"":1,"4":1,"5":1,"6":1,"7":1,"\"-\"":1,"8":2,"\"Response: \"":1,"\"Bytes Sent: \"":1,"9":1,"\"Bad log entry (or problem with regex):\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"now":1,"toString":1,"System.err.println":1,"getInputStream":1,"readUnsignedByte":4,"System.out.println":5},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"String":1,"DataInputStream":1,"Socket":1,"long":1,"Date":1},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":18,"NameExpr":68,"StringLiteralExpr":7,"CastExpr":4,"FieldAccessExpr":7,"EnclosedExpr":11,"AssignExpr":2,"MethodCallExpr":13},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":13},"text":"public static void main(String[] argv) {\n    String hostName;\n    if (argv.length == 0)\n        hostName = \"localhost\";\n    else\n        hostName = argv[0];\n    try {\n        Socket sock = new Socket(hostName, TIME_PORT);\n        DataInputStream is = new DataInputStream(new BufferedInputStream(sock.getInputStream()));\n        // Read 4 bytes from the network, unsigned.\n        // Do it yourself; there is no readUnsignedInt().\n        // Long is 8 bytes on Java, but we are using the\n        // existing time protocol, which uses 4-byte ints.\n        long remoteTime = (((long) (is.readUnsignedByte()) << 24) | ((long) (is.readUnsignedByte()) << 16) | ((long) (is.readUnsignedByte()) << 8) | ((long) (is.readUnsignedByte()) << 0));\n        System.out.println(\"Remote time is \" + remoteTime);\n        System.out.println(\"BASE_DIFF is \" + BASE_DIFF);\n        System.out.println(\"Time diff == \" + (remoteTime - BASE_DIFF));\n        Date d = new Date((remoteTime - BASE_DIFF) * MSEC);\n        System.out.println(\"Time on \" + hostName + \" is \" + d.toString());\n        System.out.println(\"Local date/time = \" + LocalDateTime.now());\n    } catch (IOException e) {\n        System.err.println(e);\n    }\n}\n","name":"main","className":"RDateClient","variables":{"MSEC":1,"LocalDateTime":1,"hostName":5,"sock":2,"remoteTime":4,"d":2,"e":1,"is":5,"TIME_PORT":1,"BASE_DIFF":3,"argv":1},"constants":{"0":3,"\"localhost\"":1,"24":1,"\" is \"":1,"16":1,"\"Remote time is \"":1,"\"Local date/time = \"":1,"8":1,"\"BASE_DIFF is \"":1,"\"Time diff == \"":1,"\"Time on \"":1},"javaDoc":"","comments":"Read 4 bytes from the network unsigned Do it yourself; there is no readUnsignedInt() Long is 8 bytes on Java but we are using the existing time protocol which uses 4-byte ints ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getInetAddress":1,"getHostName":1,"System.out.printf":1,"getByName":2,"getHostAddress":1,"System.out.println":3,"getLocalHost":1},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables"],"types":{"String":3,"InetAddress":2,"Socket":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":5,"StringLiteralExpr":7,"NameExpr":44,"FieldAccessExpr":4,"MethodCallExpr":10},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) throws IOException {\n    String hostName = \"www.darwinsys.com\";\n    // currently a well-known Google DNS server\n    String ipNumber = \"8.8.8.8\";\n    // Show getting the InetAddress (looking up a host) by host name\n    System.out.println(hostName + \"'s address is \" + InetAddress.getByName(hostName).getHostAddress());\n    // Look up a host by address\n    System.out.println(ipNumber + \"'s name is \" + InetAddress.getByName(ipNumber).getHostName());\n    // Look up my localhost addresss\n    final InetAddress localHost = InetAddress.getLocalHost();\n    System.out.println(\"My localhost address is \" + localHost);\n    // Show getting the InetAddress from an open Socket\n    String someServerName = \"www.google.com\";\n    // assuming there's a web server on the named server:\n    Socket theSocket = new Socket(someServerName, 80);\n    InetAddress remote = theSocket.getInetAddress();\n    System.out.printf(\"The InetAddress for %s is %s%n\", someServerName, remote);\n}\n","name":"main","className":"InetAddrDemo","variables":{"hostName":2,"ipNumber":2,"localHost":2,"someServerName":2,"theSocket":2,"remote":1,"InetAddress":3},"constants":{"\"My localhost address is \"":1,"\"www.google.com\"":1,"\"8.8.8.8\"":1,"\"The InetAddress for %s is %s%n\"":1,"80":1,"\"'s address is \"":1,"\"www.darwinsys.com\"":1,"\"'s name is \"":1},"javaDoc":"","comments":"currently a well-known Google DNS server Show getting the InetAddress (looking up a host) by host name Look up a host by address Look up my localhost addresss Show getting the InetAddress from an open Socket assuming there's a web server on the named server: ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Socket":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":2,"NameExpr":5,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":1},"text":"public static void main(String[] argv) throws Exception {\n    try (Socket sock = new Socket(\"localhost\", 8080)) {\n        /* If we get here, we can read and write on the socket \"sock\" */\n        System.out.println(\" *** Connected OK ***\");\n    /* Do some I/O here... */\n    }\n}\n","name":"main","className":"ConnectSimple","variables":{"sock":1},"constants":{"\"localhost\"":1,"8080":1,"\" *** Connected OK ***\"":1},"javaDoc":"","comments":"Do some I/O here If we get here we can read and write on the socket \"sock\" ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"getProperty":1,"runServer":1,"System.err.println":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"JSSEWebServer0":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) throws Exception {\n    if (System.getProperty(\"javax.net.ssl.keyStore\") == null) {\n        System.err.println(\"You must pass in a keystore via -D; see the documentation!\");\n        System.exit(1);\n    }\n    System.out.println(\"DarwinSys JSSE Server 0.0 starting...\");\n    JSSEWebServer0 w = new JSSEWebServer0();\n    // never returns!!\n    w.runServer(HTTPS);\n}\n","name":"main","className":"JSSEWebServer0","variables":{"w":2,"System":2},"constants":{"1":1,"\"DarwinSys JSSE Server 0.0 starting...\"":1,"null":1,"\"javax.net.ssl.keyStore\"":1,"\"You must pass in a keystore via -D; see the documentation!\"":1},"javaDoc":"","comments":"never returns!! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"ServerSocket","methodCalls":{"getDefault":1,"createServerSocket":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"SSLServerSocketFactory":1},"expressions":{"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":7,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Get an HTTPS ServerSocket using JSSE.\n     * @see WebServer0#getServerSocket(int)\n     * @throws ClassNotFoundException if the SecurityProvider cannot be instantiated.\n     */\nprotected ServerSocket getServerSocket(int port) throws Exception {\n    SSLServerSocketFactory ssf = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n    return ssf.createServerSocket(port);\n}\n","name":"getServerSocket","className":"JSSEWebServer0","variables":{"ssf":2,"SSLServerSocketFactory":1},"constants":{},"javaDoc":"Get an HTTPS ServerSocket using JSSE @see WebServer0#getServerSocket(int) @throws ClassNotFoundException if the SecurityProvider cannot be instantiated","comments":" Get an HTTPS ServerSocket using JSSE.\n     * @see WebServer0#getServerSocket(int)\n     * @throws ClassNotFoundException if the SecurityProvider cannot be instantiated.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"exit":1,"System.err.println":1},"annotations":[],"exceptions":["NumberFormatException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":5},"text":"/** main: construct and run */\npublic static void main(String[] args) {\n    int p = ECHOPORT;\n    if (args.length == 1) {\n        try {\n            p = Integer.parseInt(args[0]);\n        } catch (NumberFormatException e) {\n            System.err.println(\"Usage: EchoServer [port#]\");\n            System.exit(1);\n        }\n    }\n    new EchoServer(p).handle();\n}\n","name":"main","className":"EchoServer","variables":{"p":3,"Integer":1,"args":1,"e":1,"ECHOPORT":1,"System":1},"constants":{"0":1,"1":2,"\"Usage: EchoServer [port#]\"":1},"javaDoc":"main: construct and run","comments":" main: construct and run ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"EchoServer","methodCalls":{"exit":1,"System.err.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/** Construct an EchoServer on the given port number */\npublic EchoServer(int port) {\n    try {\n        sock = new ServerSocket(port);\n    } catch (IOException e) {\n        System.err.println(\"I/O error in setup\");\n        System.err.println(e);\n        System.exit(1);\n    }\n}\n","name":"EchoServer","className":"EchoServer","variables":{"sock":1,"port":1,"e":1,"System":1},"constants":{"1":1,"\"I/O error in setup\"":1},"javaDoc":"Construct an EchoServer on the given port number","comments":" Construct an EchoServer on the given port number ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getInetAddress":1,"print":1,"getHostName":1,"flush":1,"getOutputStream":1,"System.err.println":6,"readLine":1,"getInputStream":1,"close":3,"System.out.println":1,"accept":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"Socket":1,"PrintWriter":1},"expressions":{"NullLiteralExpr":7,"ObjectCreationExpr":4,"VariableDeclarationExpr":4,"BooleanLiteralExpr":2,"BinaryExpr":8,"NameExpr":78,"StringLiteralExpr":9,"FieldAccessExpr":7,"EnclosedExpr":1,"MethodCallExpr":18,"AssignExpr":4},"statements":{"IfStmt":3,"WhileStmt":2,"BlockStmt":7,"TryStmt":2,"ExpressionStmt":19},"text":"/** This handles the connections */\nprotected void handle() {\n    Socket ios = null;\n    BufferedReader is = null;\n    PrintWriter os = null;\n    while (true) {\n        try {\n            System.out.println(\"Waiting for client...\");\n            ios = sock.accept();\n            System.err.println(\"Accepted from \" + ios.getInetAddress().getHostName());\n            is = new BufferedReader(new InputStreamReader(ios.getInputStream(), \"8859_1\"));\n            os = new PrintWriter(new OutputStreamWriter(ios.getOutputStream(), \"8859_1\"), true);\n            String echoLine;\n            while ((echoLine = is.readLine()) != null) {\n                System.err.println(\"Read \" + echoLine);\n                os.print(echoLine + \"\\r\\n\");\n                os.flush();\n                System.err.println(\"Wrote \" + echoLine);\n            }\n            System.err.println(\"All done!\");\n        } catch (IOException e) {\n            System.err.println(e);\n        } finally {\n            try {\n                if (is != null)\n                    is.close();\n                if (os != null)\n                    os.close();\n                if (ios != null)\n                    ios.close();\n            } catch (IOException e) {\n                System.err.println(\"IO Error in close\");\n            }\n        }\n    }\n/*NOTREACHED*/\n}\n                     // These are unlikely, but might indicate that\n\n                     // the other end shut down early, a disk filled up\n\n                     // but wasn't detected until close, etc.\n\n","name":"handle","className":"EchoServer","variables":{"sock":1,"os":6,"e":2,"is":5,"ios":7,"echoLine":5},"constants":{"\"8859_1\"":2,"\"\\r\\n\"":1,"null":7,"\"Accepted from \"":1,"\"Read \"":1,"\"Wrote \"":1,"true":2,"\"All done!\"":1,"\"IO Error in close\"":1,"\"Waiting for client...\"":1},"javaDoc":"This handles the connections","comments":"NOTREACHED These are unlikely but might indicate that the other end shut down early a disk filled up but wasn't detected until close etc  This handles the connections ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":1,"System.err.println":1,"accept":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"ServerSocket":1,"Socket":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":15,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"public static void main(String[] argv) throws IOException {\n    ServerSocket sock;\n    Socket clientSock;\n    try {\n        sock = new ServerSocket(PORT);\n        while ((clientSock = sock.accept()) != null) {\n            // Process it.\n            process(clientSock);\n        }\n    } catch (IOException e) {\n        System.err.println(e);\n    }\n}\n","name":"main","className":"Listen","variables":{"sock":3,"PORT":1,"e":1,"clientSock":2},"constants":{"null":1},"javaDoc":"","comments":"Process it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Socket"],"returnType":"void","methodCalls":{"getInetAddress":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/** This would do something with one client. */\nstatic void process(Socket s) throws IOException {\n    System.out.println(\"Accept from client \" + s.getInetAddress());\n    // The conversation would be here.\n    s.close();\n}\n","name":"process","className":"Listen","variables":{"s":2},"constants":{"\"Accept from client \"":1},"javaDoc":"This would do something with one client","comments":"The conversation would be here  This would do something with one client. ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getDisplayName":1,"hasMoreElements":2,"getByName":1,"System.err.println":1,"getNetworkInterfaces":1,"getInetAddresses":1,"getByInetAddress":1,"nextElement":2,"System.out.println":3},"annotations":[],"exceptions":["SocketException","IOException"],"concepts":["Casting","ExceptionHandling"],"types":{"Enumeration":2,"NetworkInterface":2,"InetAddress":2},"expressions":{"VariableDeclarationExpr":6,"BinaryExpr":4,"NameExpr":52,"CastExpr":2,"StringLiteralExpr":4,"FieldAccessExpr":4,"MethodCallExpr":13},"statements":{"WhileStmt":2,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] a) throws IOException {\n    Enumeration list = NetworkInterface.getNetworkInterfaces();\n    while (list.hasMoreElements()) {\n        // Get one NetworkInterface\n        NetworkInterface iface = (NetworkInterface) list.nextElement();\n        // Print its name\n        System.out.println(iface.getDisplayName());\n        Enumeration addrs = iface.getInetAddresses();\n        // And its address(es)\n        while (addrs.hasMoreElements()) {\n            InetAddress addr = (InetAddress) addrs.nextElement();\n            System.out.println(addr);\n        }\n    }\n    // Try to get the Interface for a given local (this machine's) address\n    InetAddress destAddr = InetAddress.getByName(\"laptop\");\n    try {\n        NetworkInterface dest = NetworkInterface.getByInetAddress(destAddr);\n        System.out.println(\"Address for \" + destAddr + \" is \" + dest);\n    } catch (SocketException ex) {\n        System.err.println(\"Couldn't get address for \" + destAddr);\n    }\n}\n","name":"main","className":"NetworkInterfaceDemo","variables":{"iface":3,"ex":1,"addrs":3,"NetworkInterface":2,"destAddr":3,"list":3,"addr":1,"dest":2,"InetAddress":1},"constants":{"\" is \"":1,"\"Address for \"":1,"\"Couldn't get address for \"":1,"\"laptop\"":1},"javaDoc":"","comments":"Get one NetworkInterface Print its name And its address(es) Try to get the Interface for a given local (this machine's) address ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] av) {\n    new EchoServerThreaded().runServer();\n}\n","name":"main","className":"EchoServerThreaded","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1,"System.err.println":1,"System.out.println":1,"accept":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"ServerSocket":1,"Socket":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":23,"StringLiteralExpr":2,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":5},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public void runServer() {\n    ServerSocket sock;\n    Socket clientSocket;\n    try {\n        sock = new ServerSocket(ECHOPORT);\n        System.out.println(\"EchoServerThreaded ready for connections.\");\n        /* Wait for a connection */\n        while (true) {\n            clientSocket = sock.accept();\n            /* Create a thread to do the communication, and start it */\n            new Handler(clientSocket).start();\n        }\n    } catch (IOException e) {\n        System.err.println(\"Could not accept \" + e);\n        System.exit(1);\n    }\n}\n             /* Crash the server if IO fails. Something bad has happened */\n\n","name":"runServer","className":"EchoServerThreaded","variables":{"clientSocket":3,"sock":3,"e":2,"ECHOPORT":1,"System":1},"constants":{"1":1,"true":1,"\"EchoServerThreaded ready for connections.\"":1,"\"Could not accept \"":1},"javaDoc":"","comments":"Wait for a connection Create a thread to do the communication and start it Crash the server if IO fails Something bad has happened ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Socket"],"returnType":"Handler","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"Handler(Socket s) {\n    sock = s;\n}\n","name":"Handler","className":"Handler","variables":{"sock":1,"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"print":1,"flush":1,"getOutputStream":1,"readLine":1,"getInputStream":1,"close":1,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"PrintStream":1,"BufferedReader":1,"String":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":38,"StringLiteralExpr":4,"FieldAccessExpr":3,"EnclosedExpr":1,"MethodCallExpr":9,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ReturnStmt":1,"ExpressionStmt":9},"text":"public void run() {\n    System.out.println(\"Socket starting: \" + sock);\n    try {\n        BufferedReader is = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n        PrintStream os = new PrintStream(sock.getOutputStream(), true);\n        String line;\n        while ((line = is.readLine()) != null) {\n            os.print(line + \"\\r\\n\");\n            os.flush();\n        }\n        sock.close();\n    } catch (IOException e) {\n        System.out.println(\"IO Error on socket \" + e);\n        return;\n    }\n    System.out.println(\"Socket ENDED: \" + sock);\n}\n","name":"run","className":"Handler","variables":{"sock":5,"os":3,"e":2,"line":3,"is":2},"constants":{"\"IO Error on socket \"":1,"\"\\r\\n\"":1,"null":1,"true":1,"\"Socket ENDED: \"":1,"\"Socket starting: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":1,"System.err.println":3,"getInputStream":1,"readObject":1,"System.out.println":2},"annotations":[],"exceptions":["IOException","ClassNotFoundException","IllegalArgumentException"],"concepts":["Casting","ExceptionHandling"],"types":{"Object":1,"String":1,"Socket":1,"Date":1,"ObjectInputStream":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":7,"NameExpr":49,"StringLiteralExpr":7,"InstanceOfExpr":1,"AssignExpr":2,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":6,"EnclosedExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":3,"TryStmt":1,"BlockStmt":6,"ThrowStmt":1,"ExpressionStmt":12},"text":"public static void main(String[] argv) {\n    String hostName;\n    if (argv.length == 0)\n        hostName = \"localhost\";\n    else\n        hostName = argv[0];\n    try {\n        Socket sock = new Socket(hostName, TIME_PORT);\n        ObjectInputStream is = new ObjectInputStream(new BufferedInputStream(sock.getInputStream()));\n        // Read and validate the Object\n        Object o = is.readObject();\n        if (o == null) {\n            System.err.println(\"Read null from server!\");\n        } else if ((o instanceof Date)) {\n            // Valid, so cast to Date, and print\n            Date d = (Date) o;\n            System.out.println(\"Server host is \" + hostName);\n            System.out.println(\"Time there is \" + d.toString());\n        } else {\n            throw new IllegalArgumentException(\"Wanted Date, got \" + o);\n        }\n    } catch (ClassNotFoundException e) {\n        System.err.println(\"Wanted date, got INVALID CLASS (\" + e + \")\");\n    } catch (IOException e) {\n        System.err.println(e);\n    }\n}\n","name":"main","className":"DaytimeObject","variables":{"hostName":5,"sock":2,"d":2,"e":3,"is":2,"TIME_PORT":1,"argv":1,"o":5},"constants":{"0":2,"\"localhost\"":1,"\"Read null from server!\"":1,"\"Wanted date, got INVALID CLASS (\"":1,"\"Time there is \"":1,"null":1,"\"Wanted Date, got \"":1,"\"Server host is \"":1,"\")\"":1},"javaDoc":"","comments":"Read and validate the Object Valid so cast to Date and print ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":1,"getByName":1,"System.err.println":1,"accept":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"ServerSocket":1,"Socket":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":20,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"public static void main(String[] argv) throws IOException {\n    ServerSocket sock;\n    Socket clientSock;\n    try {\n        sock = new ServerSocket(PORT, BACKLOG, InetAddress.getByName(INSIDE_HOST));\n        while ((clientSock = sock.accept()) != null) {\n            // Process it.\n            process(clientSock);\n        }\n    } catch (IOException e) {\n        System.err.println(e);\n    }\n}\n","name":"main","className":"ListenInside","variables":{"sock":3,"PORT":1,"BACKLOG":1,"e":1,"clientSock":2,"InetAddress":1},"constants":{"null":1},"javaDoc":"","comments":"Process it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Socket"],"returnType":"void","methodCalls":{"getInetAddress":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":12,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/** Hold server's conversation with one client. */\nstatic void process(Socket s) throws IOException {\n    System.out.println(\"Connected from  \" + INSIDE_HOST + \": \" + s.getInetAddress());\n    // The conversation would be here.\n    s.close();\n}\n","name":"process","className":"ListenInside","variables":{"s":2,"INSIDE_HOST":1},"constants":{"\"Connected from  \"":1,"\": \"":1},"javaDoc":"Hold server's conversation with one client","comments":"The conversation would be here  Hold server's conversation with one client. ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readLine":1,"System.err.println":1,"getInputStream":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":2,"Socket":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":27,"StringLiteralExpr":3,"FieldAccessExpr":3,"AssignExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":8},"text":"public static void main(String[] argv) {\n    String hostName;\n    if (argv.length == 0)\n        hostName = \"localhost\";\n    else\n        hostName = argv[0];\n    try {\n        Socket sock = new Socket(hostName, TIME_PORT);\n        BufferedReader is = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n        String remoteTime = is.readLine();\n        System.out.println(\"Time on \" + hostName + \" is \" + remoteTime);\n    } catch (IOException e) {\n        System.err.println(e);\n    }\n}\n","name":"main","className":"DaytimeText","variables":{"hostName":5,"sock":2,"remoteTime":2,"e":1,"is":2,"TIME_PORT":1,"argv":1},"constants":{"0":2,"\"localhost\"":1,"\" is \"":1,"\"Time on \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2},"statements":{"ExpressionStmt":1},"text":"/** Main method, to start the servers. */\npublic static void main(String[] av) {\n    new EchoServerThreaded2(ECHOPORT, NUM_THREADS);\n}\n","name":"main","className":"EchoServerThreaded2","variables":{"NUM_THREADS":1,"ECHOPORT":1},"constants":{},"javaDoc":"Main method to start the servers","comments":" Main method, to start the servers. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"EchoServerThreaded2","methodCalls":{},"annotations":[],"exceptions":["RuntimeException","IOException"],"concepts":["ExceptionHandling"],"types":{"ServerSocket":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":3,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"/** Constructor */\npublic EchoServerThreaded2(int port, int numThreads) {\n    ServerSocket servSock;\n    try {\n        servSock = new ServerSocket(port);\n    } catch (IOException e) {\n        throw new RuntimeException(\"Could not create ServerSocket \", e);\n    }\n    // Create a series of threads and start them.\n    for (int i = 0; i < numThreads; i++) {\n        new Handler(servSock, i).start();\n    }\n}\n             /* Crash the server if IO fails. Something bad has happened */\n\n","name":"EchoServerThreaded2","className":"EchoServerThreaded2","variables":{"servSock":3,"port":1,"e":2,"i":4,"numThreads":1},"constants":{"0":1,"\"Could not create ServerSocket \"":1},"javaDoc":"Constructor","comments":"Crash the server if IO fails Something bad has happened Create a series of threads and start them  Constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ServerSocket","int"],"returnType":"Handler","methodCalls":{"setName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"/** Construct a Handler. */\nHandler(ServerSocket s, int i) {\n    servSock = s;\n    threadNumber = i;\n    setName(\"Thread \" + threadNumber);\n}\n","name":"Handler","className":"Handler","variables":{"servSock":1,"s":1,"threadNumber":2,"i":1},"constants":{"\"Thread \"":1},"javaDoc":"Construct a Handler","comments":" Construct a Handler. ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"getInetAddress":1,"print":1,"getName":4,"flush":1,"getOutputStream":1,"readLine":1,"getInputStream":1,"close":1,"System.out.println":4,"accept":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling","Synchronization"],"types":{"PrintStream":1,"BufferedReader":1,"String":1,"Socket":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":2,"BinaryExpr":8,"NameExpr":57,"StringLiteralExpr":5,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":16,"AssignExpr":2},"statements":{"WhileStmt":2,"BlockStmt":5,"TryStmt":1,"SynchronizedStmt":1,"ReturnStmt":1,"ExpressionStmt":12},"text":"public void run() {\n    /* Wait for a connection. Synchronized on the ServerSocket\n             * while calling its accept() method.\n             */\n    while (true) {\n        try {\n            System.out.println(getName() + \" waiting\");\n            Socket clientSocket;\n            // Wait here for the next connection.\n            synchronized (servSock) {\n                clientSocket = servSock.accept();\n            }\n            System.out.println(getName() + \" starting, IP=\" + clientSocket.getInetAddress());\n            BufferedReader is = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintStream os = new PrintStream(clientSocket.getOutputStream(), true);\n            String line;\n            while ((line = is.readLine()) != null) {\n                os.print(line + \"\\r\\n\");\n                os.flush();\n            }\n            System.out.println(getName() + \" ENDED \");\n            clientSocket.close();\n        } catch (IOException ex) {\n            System.out.println(getName() + \": IO Error on socket \" + ex);\n            return;\n        }\n    }\n}\n","name":"run","className":"Handler","variables":{"clientSocket":6,"servSock":2,"ex":2,"os":3,"line":3,"is":2},"constants":{"\"\\r\\n\"":1,"\" starting, IP=\"":1,"null":1,"true":2,"\": IO Error on socket \"":1,"\" waiting\"":1,"\" ENDED \"":1},"javaDoc":"","comments":"Wait for a connection Synchronized on the ServerSocket while calling its accept() method Wait here for the next connection ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    if (argv.length == 0)\n        new EchoClientOneLine().converse(\"localhost\");\n    else\n        new EchoClientOneLine().converse(argv[0]);\n}\n","name":"main","className":"EchoClientOneLine","variables":{"argv":1},"constants":{"0":2,"\"localhost\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"print":1,"flush":1,"getOutputStream":1,"readLine":1,"System.err.println":1,"getInputStream":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"Socket":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"BinaryExpr":5,"NameExpr":35,"StringLiteralExpr":5,"FieldAccessExpr":3,"MethodCallExpr":8},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":9},"text":"/** Hold one conversation across the net */\nprotected void converse(String hostName) {\n    try {\n        // echo server.\n        Socket sock = new Socket(hostName, 7);\n        BufferedReader is = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n        PrintWriter os = new PrintWriter(sock.getOutputStream(), true);\n        // Do the CRLF ourself since println appends only a \\r on\n        // platforms where that is the native line ending.\n        os.print(mesg + \"\\r\\n\");\n        os.flush();\n        String reply = is.readLine();\n        System.out.println(\"Sent \\\"\" + mesg + \"\\\"\");\n        System.out.println(\"Got  \\\"\" + reply + \"\\\"\");\n    } catch (IOException e) {\n        System.err.println(e);\n    }\n}\n","name":"converse","className":"EchoClientOneLine","variables":{"sock":3,"hostName":1,"os":3,"e":1,"is":2,"reply":2,"mesg":2},"constants":{"\"Got  \\\"\"":1,"\"\\r\\n\"":1,"\"Sent \\\"\"":1,"7":1,"true":1,"\"\\\"\"":2},"javaDoc":"Hold one conversation across the net","comments":"Do the CRLF ourself since println appends only a \\r on echo server platforms where that is the native line ending  Hold one conversation across the net ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"runServer":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"WebServer0":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n     * Main method, just creates a server and call its runServer().\n     */\npublic static void main(String[] argv) throws Exception {\n    System.out.println(\"DarwinSys JavaWeb Server 0.0 starting...\");\n    WebServer0 w = new WebServer0();\n    // never returns!!\n    w.runServer(HTTP);\n}\n","name":"main","className":"WebServer0","variables":{"w":2},"constants":{"\"DarwinSys JavaWeb Server 0.0 starting...\"":1},"javaDoc":"Main method just creates a server and call its runServer()","comments":"never returns!! \n     * Main method, just creates a server and call its runServer().\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"ServerSocket","methodCalls":{},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get the actual ServerSocket; deferred until after Constructor\n     * so subclass can mess with ServerSocketFactory (e.g., to do SSL).\n     * @param port The port number to listen on\n     */\nprotected ServerSocket getServerSocket(int port) throws Exception {\n    return new ServerSocket(port);\n}\n","name":"getServerSocket","className":"WebServer0","variables":{"port":1},"constants":{},"javaDoc":"Get the actual ServerSocket; deferred until after Constructor so subclass can mess with ServerSocketFactory (e g to do SSL) port The port number to listen on","comments":" Get the actual ServerSocket; deferred until after Constructor\n     * so subclass can mess with ServerSocketFactory (e.g., to do SSL).\n     * @param port The port number to listen on\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getServerSocket":1,"Handler":1,"System.err.println":1,"accept":1},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"Socket":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":16,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/** RunServer accepts connections and passes each one to handler. */\npublic void runServer(int port) throws Exception {\n    s = getServerSocket(port);\n    while (true) {\n        try {\n            Socket us = s.accept();\n            Handler(us);\n        } catch (IOException e) {\n            System.err.println(e);\n            return;\n        }\n    }\n}\n","name":"runServer","className":"WebServer0","variables":{"s":2,"e":1,"us":1},"constants":{"true":1},"javaDoc":"RunServer accepts connections and passes each one to handler","comments":" RunServer accepts connections and passes each one to handler. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Socket"],"returnType":"void","methodCalls":{"getInetAddress":1,"print":6,"flush":1,"length":3,"toString":1,"getOutputStream":1,"readLine":1,"getInputStream":1,"close":1,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":4,"PrintWriter":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":6,"BinaryExpr":24,"BooleanLiteralExpr":1,"NameExpr":78,"StringLiteralExpr":19,"FieldAccessExpr":3,"EnclosedExpr":1,"MethodCallExpr":19,"AssignExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":20},"text":"/** Handler() handles one conversation with a Web client.\n     * This is the only part of the program that \"knows\" HTTP.\n     */\npublic void Handler(Socket s) {\n    // inputStream, from Viewer\n    BufferedReader is;\n    // outputStream, to Viewer\n    PrintWriter os;\n    // what Viewer sends us.\n    String request;\n    try {\n        String from = s.getInetAddress().toString();\n        System.out.println(\"Accepted connection from \" + from);\n        is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        request = is.readLine();\n        System.out.println(\"Request: \" + request);\n        os = new PrintWriter(s.getOutputStream(), true);\n        os.print(\"HTTP/1.0 200 Here is your data\" + CRLF);\n        os.print(\"Content-type: text/html\" + CRLF);\n        os.print(\"Server-name: DarwinSys NULL Java WebServer 0\" + CRLF);\n        String reply1 = \"<html><head>\" + \"<title>Wrong System Reached</title></head>\\n\" + \"<h1>Welcome, \";\n        String reply2 = \", but...</h1>\\n\" + \"<p>You have reached a desktop machine \" + \"that does not run a real Web service.\\n\" + \"<p>Please pick another system!</p>\\n\" + \"<p>Or view <a href=\\\"\" + VIEW_SOURCE_URL + \"\\\">\" + \"the WebServer0 source on github</a>.</p>\\n\" + \"<hr/><em>Java-based WebServer0</em><hr/>\\n\" + \"</html>\\n\";\n        os.print(\"Content-length: \" + (reply1.length() + from.length() + reply2.length()) + CRLF);\n        os.print(CRLF);\n        os.print(reply1 + from + reply2 + CRLF);\n        os.flush();\n        s.close();\n    } catch (IOException e) {\n        System.out.println(\"IOException \" + e);\n    }\n    return;\n}\n","name":"Handler","className":"WebServer0","variables":{"request":3,"s":4,"os":9,"reply2":3,"VIEW_SOURCE_URL":1,"e":2,"CRLF":5,"is":3,"from":4,"reply1":3},"constants":{"\"Server-name: DarwinSys NULL Java WebServer 0\"":1,"\"the WebServer0 source on github</a>.</p>\\n\"":1,"\"HTTP/1.0 200 Here is your data\"":1,"\"IOException \"":1,"\"Content-length: \"":1,"\"<p>Or view <a href=\\\"\"":1,"\"\\\">\"":1,"\"Request: \"":1,"\"<html><head>\"":1,"\"Content-type: text/html\"":1,"\"<p>You have reached a desktop machine \"":1,"\"Accepted connection from \"":1,"\", but...</h1>\\n\"":1,"\"</html>\\n\"":1,"\"<title>Wrong System Reached</title></head>\\n\"":1,"\"<h1>Welcome, \"":1,"\"<p>Please pick another system!</p>\\n\"":1,"true":1,"\"<hr/><em>Java-based WebServer0</em><hr/>\\n\"":1,"\"that does not run a real Web service.\\n\"":1},"javaDoc":"Handler() handles one conversation with a Web client This is the only part of the program that \"knows\" HTTP","comments":"inputStream from Viewer outputStream to Viewer what Viewer sends us  Handler() handles one conversation with a Web client.\n     * This is the only part of the program that \"knows\" HTTP.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] argv) {\n    new Telnet().talkTo(argv);\n}\n","name":"main","className":"Telnet","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"getOutputStream":1,"getInputStream":1,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Socket":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":51,"StringLiteralExpr":4,"FieldAccessExpr":7,"AssignExpr":4,"MethodCallExpr":8},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":10},"text":"private void talkTo(String av[]) {\n    if (av.length >= 1)\n        host = av[0];\n    else\n        host = \"localhost\";\n    if (av.length >= 2)\n        portNum = Integer.parseInt(av[1]);\n    else\n        portNum = 23;\n    System.out.println(\"Host \" + host + \"; port \" + portNum);\n    try {\n        Socket s = new Socket(host, portNum);\n        // Connect the remote to our stdout\n        new Pipe(s.getInputStream(), System.out).start();\n        // Connect our stdin to the remote\n        new Pipe(System.in, s.getOutputStream()).start();\n    } catch (IOException e) {\n        System.out.println(e);\n        return;\n    }\n    System.out.println(\"Connected OK\");\n}\n","name":"talkTo","className":"Telnet","variables":{"Integer":1,"s":3,"av":2,"portNum":4,"e":1,"host":4},"constants":{"0":1,"\"localhost\"":1,"1":2,"23":1,"2":1,"\"Connected OK\"":1,"\"; port \"":1,"\"Host \"":1},"javaDoc":"","comments":"Connect the remote to our stdout Connect our stdin to the remote ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["InputStream","OutputStream"],"returnType":"Pipe","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Construct a Pipe to read from is and write to os */\nPipe(InputStream is, OutputStream os) {\n    this.is = new BufferedReader(new InputStreamReader(is));\n    this.os = new PrintStream(os);\n}\n","name":"Pipe","className":"Pipe","variables":{"os":1,"is":1},"constants":{},"javaDoc":"Construct a Pipe to read from is and write to os","comments":" Construct a Pipe to read from is and write to os ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"print":2,"flush":1,"getMessage":1,"readLine":1},"annotations":[],"exceptions":["RuntimeException","IOException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":17,"StringLiteralExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":4},"text":"/** Do the reading and writing. */\npublic void run() {\n    String line;\n    try {\n        while ((line = is.readLine()) != null) {\n            os.print(line);\n            os.print(\"\\r\\n\");\n            os.flush();\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(e.getMessage());\n    }\n}\n","name":"run","className":"Pipe","variables":{"os":3,"e":2,"line":2,"is":1},"constants":{"\"\\r\\n\"":1,"null":1},"javaDoc":"Do the reading and writing","comments":" Do the reading and writing. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getMessage":1,"System.err.println":4,"System.out.println":1},"annotations":[],"exceptions":["UnknownHostException","java.io.IOException","NoRouteToHostException","ConnectException"],"concepts":["ExceptionHandling"],"types":{"String":1,"int":1,"Socket":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":8,"NameExpr":39,"StringLiteralExpr":6,"FieldAccessExpr":6,"CharLiteralExpr":1,"ConditionalExpr":1,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":5,"ReturnStmt":4,"ExpressionStmt":7},"text":"public static void main(String[] argv) {\n    String server_name = argv.length == 1 ? argv[0] : \"localhost\";\n    int tcp_port = 80;\n    try (Socket sock = new Socket(server_name, tcp_port)) {\n        /* If we get here, we can read and write on the socket. */\n        System.out.println(\" *** Connected to \" + server_name + \" ***\");\n    /* Do some I/O here... */\n    } catch (UnknownHostException e) {\n        System.err.println(server_name + \" Unknown host\");\n        return;\n    } catch (NoRouteToHostException e) {\n        System.err.println(server_name + \" Unreachable\");\n        return;\n    } catch (ConnectException e) {\n        System.err.println(server_name + \" connect refused\");\n        return;\n    } catch (java.io.IOException e) {\n        System.err.println(server_name + ' ' + e.getMessage());\n        return;\n    }\n}\n","name":"main","className":"ConnectFriendly","variables":{"tcp_port":2,"server_name":7,"sock":1,"e":5,"argv":1},"constants":{"0":1,"\"localhost\"":1,"1":1,"\" Unknown host\"":1,"80":1,"\" connect refused\"":1,"\" *** Connected to \"":1,"\" ***\"":1,"\" Unreachable\"":1,"' '":1},"javaDoc":"","comments":"Do some I/O here If we get here we can read and write on the socket ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getInetAddress":1,"writeObject":1,"getOutputStream":1,"System.err.println":1,"close":1,"accept":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"ServerSocket":1,"ObjectOutputStream":1,"Socket":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":29,"StringLiteralExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":7},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public static void main(String[] argv) {\n    ServerSocket sock;\n    Socket clientSock;\n    try {\n        sock = new ServerSocket(TIME_PORT);\n        while ((clientSock = sock.accept()) != null) {\n            System.out.println(\"Accept from \" + clientSock.getInetAddress());\n            ObjectOutputStream os = new ObjectOutputStream(clientSock.getOutputStream());\n            // Construct and write the Object\n            os.writeObject(new Date());\n            os.close();\n        }\n    } catch (IOException e) {\n        System.err.println(e);\n    }\n}\n","name":"main","className":"DaytimeObjectServer","variables":{"sock":3,"os":3,"e":1,"clientSock":4,"TIME_PORT":1},"constants":{"\"Accept from \"":1,"null":1},"javaDoc":"","comments":"Construct and write the Object ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** main: construct and run */\npublic static void main(String[] argv) {\n    new DaytimeServer(PORT).runService();\n}\n","name":"main","className":"DaytimeServer","variables":{"PORT":1},"constants":{},"javaDoc":"main: construct and run","comments":" main: construct and run ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"DaytimeServer","methodCalls":{"exit":1,"System.err.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** Construct a DaytimeServer on the given port number */\npublic DaytimeServer(int port) {\n    try {\n        sock = new ServerSocket(port);\n    } catch (IOException e) {\n        System.err.println(\"I/O error in setup\\n\" + e);\n        System.exit(1);\n    }\n}\n","name":"DaytimeServer","className":"DaytimeServer","variables":{"sock":1,"port":1,"e":2,"System":1},"constants":{"1":1,"\"I/O error in setup\\n\"":1},"javaDoc":"Construct a DaytimeServer on the given port number","comments":" Construct a DaytimeServer on the given port number ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getInetAddress":1,"writeInt":1,"getHostName":1,"currentTimeMillis":1,"getOutputStream":1,"System.err.println":2,"close":1,"System.out.println":1,"accept":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"DataOutputStream":1,"Socket":1,"long":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":48,"StringLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":5,"MethodCallExpr":10,"AssignExpr":4},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":12},"text":"/** This handles the connections */\nprotected void runService() {\n    Socket ios = null;\n    DataOutputStream os = null;\n    while (true) {\n        try {\n            System.out.println(\"Waiting for connection on port \" + PORT);\n            ios = sock.accept();\n            System.err.println(\"Accepted from \" + ios.getInetAddress().getHostName());\n            os = new DataOutputStream(ios.getOutputStream());\n            long time = System.currentTimeMillis();\n            // Daytime Protocol is in seconds\n            time /= RDateClient.MSEC;\n            // Convert to Java time base.\n            time += RDateClient.BASE_DIFF;\n            // Write it, truncating cast to int since it is using\n            // the Internet Daytime protocol which uses 4 bytes.\n            // This will fail in the year 2038, along with all\n            // 32-bit timekeeping systems based from 1970.\n            // Remember, you read about the Y2038 crisis here first!\n            os.writeInt((int) time);\n            os.close();\n        } catch (IOException e) {\n            System.err.println(e);\n        }\n    }\n}\n","name":"runService","className":"DaytimeServer","variables":{"sock":1,"os":4,"PORT":1,"e":1,"time":4,"ios":4,"System":1},"constants":{"null":2,"\"Accepted from \"":1,"true":1,"\"Waiting for connection on port \"":1},"javaDoc":"This handles the connections","comments":"Write it truncating cast to int since it is using the Internet Daytime protocol which uses 4 bytes This will fail in the year 2038 along with all 32-bit timekeeping systems based from 1970 Daytime Protocol is in seconds Convert to Java time base Remember you read about the Y2038 crisis here first!  This handles the connections ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"readFile":1,"System.err.println":3},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"RemCat":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":6,"NameExpr":37,"StringLiteralExpr":5,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":3,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":6},"text":"/** The main program that drives this network client.\n     * @param argv[0] hostname, running TFTP server\n     * @param argv[1..n] filename(s), must be at least one\n     */\npublic static void main(String[] argv) throws IOException {\n    if (argv.length < 2) {\n        System.err.println(\"usage: rcat host filename[...]\");\n        System.exit(1);\n    }\n    if (debug)\n        System.err.println(\"Java RemCat starting\");\n    RemCat rc = new RemCat(argv[0]);\n    for (int i = 1; i < argv.length; i++) {\n        if (debug)\n            System.err.println(\"-- Starting file \" + argv[0] + \":\" + argv[i] + \"---\");\n        rc.readFile(argv[i]);\n    }\n}\n","name":"main","className":"RemCat","variables":{"rc":2,"debug":2,"i":5,"argv":4,"System":1},"constants":{"0":2,"1":2,"2":1,"\"usage: rcat host filename[...]\"":1,"\"Java RemCat starting\"":1,"\"-- Starting file \"":1,"\"---\"":1,"\":\"":1},"javaDoc":"The main program that drives this network client argv[0] hostname running TFTP server argv[1 n] filename(s) must be at least one","comments":" The main program that drives this network client.\n     * @param argv[0] hostname, running TFTP server\n     * @param argv[1..n] filename(s), must be at least one\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"RemCat","methodCalls":{"getByName":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"NameExpr":19,"FieldAccessExpr":1,"ArrayCreationExpr":1,"ThisExpr":1,"AssignExpr":6,"MethodCallExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":6},"text":"RemCat(String host) throws IOException {\n    super();\n    this.host = host;\n    servAddr = InetAddress.getByName(host);\n    sock = new DatagramSocket();\n    buffer = new byte[PACKET_SIZE];\n    outp = new DatagramPacket(buffer, PACKET_SIZE, servAddr, TFTP_PORT);\n    inp = new DatagramPacket(buffer, PACKET_SIZE);\n}\n","name":"RemCat","className":"RemCat","variables":{"sock":1,"TFTP_PORT":1,"servAddr":2,"outp":1,"host":1,"inp":1,"buffer":3,"InetAddress":1,"PACKET_SIZE":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"receive":1,"setLength":2,"System.out.write":1,"getPort":1,"arraycopy":2,"length":4,"getLength":5,"toString":2,"System.err.println":4,"send":2,"setPort":1,"getBytes":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"byte[]":1,"int":2},"expressions":{"IntegerLiteralExpr":13,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":8,"BinaryExpr":10,"NameExpr":128,"StringLiteralExpr":5,"FieldAccessExpr":5,"UnaryExpr":2,"AssignExpr":8,"MethodCallExpr":27},"statements":{"IfStmt":4,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":24,"DoStmt":1},"text":"/* Build a TFTP Read Request packet. This is messy because the\n     * fields have variable length. Numbers must be in\n     * network order, too; fortunately Java just seems \n     * naturally smart enough :-) to use network byte order.\n     */\nvoid readFile(String path) throws IOException {\n    buffer[0] = 0;\n    // read request\n    buffer[OFFSET_REQUEST] = OP_RRQ;\n    // number of chars into buffer\n    int p = 2;\n    // Convert filename String to bytes in buffer , using \"p\" as an\n    // offset indicator to get all the bits of this request\n    // in exactly the right spot.\n    // i.e., ASCII\n    byte[] bTemp = path.getBytes();\n    System.arraycopy(bTemp, 0, buffer, p, path.length());\n    p += path.length();\n    // null byte terminates string\n    buffer[p++] = 0;\n    // Similarly, convert MODE (\"stream\" or \"octet\") to bytes in buffer\n    // i.e., ASCII\n    bTemp = MODE.getBytes();\n    System.arraycopy(bTemp, 0, buffer, p, MODE.length());\n    p += MODE.length();\n    // null terminate\n    buffer[p++] = 0;\n    /* Send Read Request to tftp server */\n    outp.setLength(p);\n    sock.send(outp);\n    /* Loop reading data packets from the server until a short\n         * packet arrives; this indicates the end of the file.\n         */\n    int len = 0;\n    do {\n        sock.receive(inp);\n        if (debug)\n            System.err.println(\"Packet # \" + Byte.toString(buffer[OFFSET_PACKETNUM]) + \"RESPONSE CODE \" + Byte.toString(buffer[OFFSET_REQUEST]));\n        if (buffer[OFFSET_REQUEST] == OP_ERROR) {\n            System.err.println(\"rcat ERROR: \" + new String(buffer, 4, inp.getLength() - 4));\n            return;\n        }\n        if (debug)\n            System.err.println(\"Got packet of size \" + inp.getLength());\n        /* Print the data from the packet */\n        System.out.write(buffer, 4, inp.getLength() - 4);\n        /* Ack the packet. The block number we \n             * want to ack is already in buffer so \n             * we just change the opcode. The ACK is \n             * sent to the port number which the server \n             * just sent the data from, NOT to port \n             * TFTP_PORT.\n             */\n        buffer[OFFSET_REQUEST] = OP_ACK;\n        outp.setLength(4);\n        outp.setPort(inp.getPort());\n        sock.send(outp);\n    } while (inp.getLength() == PACKET_SIZE);\n    if (debug)\n        System.err.println(\"** ALL DONE** Leaving loop, last size \" + inp.getLength());\n}\n","name":"readFile","className":"RemCat","variables":{"debug":3,"MODE":3,"OP_ACK":1,"inp":6,"OFFSET_REQUEST":4,"System":2,"p":5,"OP_RRQ":1,"path":3,"sock":3,"len":1,"OP_ERROR":1,"outp":3,"Byte":2,"bTemp":2,"buffer":9,"OFFSET_PACKETNUM":1,"PACKET_SIZE":1},"constants":{"0":7,"2":1,"\"Packet # \"":1,"\"rcat ERROR: \"":1,"4":5,"\"** ALL DONE** Leaving loop, last size \"":1,"\"RESPONSE CODE \"":1,"\"Got packet of size \"":1},"javaDoc":"","comments":"Convert filename String to bytes in buffer using \"p\" as an offset indicator to get all the bits of this request in exactly the right spot Similarly convert MODE (\"stream\" or \"octet\") to bytes in buffer read request number of chars into buffer i e ASCII null byte terminates string i e ASCII null terminate Send Read Request to tftp server Loop reading data packets from the server until a short packet arrives; this indicates the end of the file Print the data from the packet Ack the packet The block number we want to ack is already in buffer so we just change the opcode The ACK is sent to the port number which the server just sent the data from NOT to port TFTP_PORT  Build a TFTP Read Request packet. This is messy because the\n     * fields have variable length. Numbers must be in\n     * network order, too; fortunately Java just seems \n     * naturally smart enough :-) to use network byte order.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"receive":1,"setLength":1,"getByName":1,"getLength":2,"System.err.println":1,"send":1,"close":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"byte[]":1,"DatagramSocket":1,"DatagramPacket":1,"String":1,"InetAddress":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":3,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":59,"StringLiteralExpr":5,"FieldAccessExpr":5,"ArrayCreationExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":14},"text":"/** The main program that drives this network client.\n     * @param argv[0] hostname, running daytime/udp server\n     */\npublic static void main(String[] argv) throws IOException {\n    if (argv.length < 1) {\n        System.err.println(\"usage: java DayTimeUDP host\");\n        System.exit(1);\n    }\n    String host = argv[0];\n    InetAddress servAddr = InetAddress.getByName(host);\n    DatagramSocket sock = new DatagramSocket();\n    //sock.connect(servAddr, DAYTIME_PORT);\n    byte[] buffer = new byte[PACKET_SIZE];\n    // The udp packet we will send and receive\n    DatagramPacket packet = new DatagramPacket(buffer, PACKET_SIZE, servAddr, DAYTIME_PORT);\n    /* Send empty max-length (-1 for null byte) packet to server */\n    packet.setLength(PACKET_SIZE - 1);\n    sock.send(packet);\n    System.out.println(\"Sent request\");\n    // Receive a packet and print it.\n    sock.receive(packet);\n    System.out.println(\"Got packet of size \" + packet.getLength());\n    System.out.print(\"Date on \" + host + \" is \" + new String(buffer, 0, packet.getLength()));\n    sock.close();\n}\n","name":"main","className":"DaytimeUDP","variables":{"sock":4,"servAddr":2,"DAYTIME_PORT":1,"host":2,"buffer":3,"packet":4,"argv":1,"InetAddress":1,"PACKET_SIZE":3,"System":1},"constants":{"0":2,"1":3,"\"usage: java DayTimeUDP host\"":1,"\"Date on \"":1,"\" is \"":1,"\"Sent request\"":1,"\"Got packet of size \"":1},"javaDoc":"The main program that drives this network client argv[0] hostname running daytime/udp server","comments":"sock connect(servAddr DAYTIME_PORT); The udp packet we will send and receive Send empty max-length (-1 for null byte) packet to server Receive a packet and print it  The main program that drives this network client.\n     * @param argv[0] hostname, running daytime/udp server\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void alert(String mesg) throws RemoteException;\n","name":"alert","className":"Client","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"TickerServerImpl","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct the object that implements the remote server.\n     * Called from main, after it has the SecurityManager in place.\n     */\npublic TickerServerImpl() throws RemoteException {\n    // sets up networking\n    super();\n}\n","name":"TickerServerImpl","className":"TickerServerImpl","variables":{},"constants":{},"javaDoc":"Construct the object that implements the remote server Called from main after it has the SecurityManager in place","comments":"sets up networking  Construct the object that implements the remote server.\n     * Called from main, after it has the SecurityManager in place.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Start background thread to track stocks :-) and alert users. */\npublic void start() {\n    new Thread(this).start();\n}\n","name":"start","className":"TickerServerImpl","variables":{},"constants":{},"javaDoc":"Start background thread to track stocks :-) and alert users","comments":" Start background thread to track stocks :-) and alert users. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Client"],"returnType":"void","methodCalls":{"add":1,"System.out.println":1},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** The remote method that \"does all the work\". This won't get\n     * called until the client starts up.\n     */\npublic void connect(Client da) throws RemoteException {\n    System.out.println(\"Adding client \" + da);\n    list.add(da);\n}\n","name":"connect","className":"TickerServerImpl","variables":{"list":1,"da":1},"constants":{"\"Adding client \"":1},"javaDoc":"The remote method that \"does all the work\" This won't get called until the client starts up","comments":" The remote method that \"does all the work\". This won't get\n     * called until the client starts up.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"nextFloat":1,"next":1,"iterator":1,"hasNext":1,"remove":1,"System.out.println":4},"annotations":[],"exceptions":["RemoteException","InterruptedException"],"concepts":["ExceptionHandling"],"types":{"Iterator":1,"String":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":44,"StringLiteralExpr":7,"ConditionalExpr":1,"UnaryExpr":1,"AssignExpr":1,"DoubleLiteralExpr":1,"BooleanLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":3,"MethodCallExpr":11},"statements":{"WhileStmt":2,"BlockStmt":6,"TryStmt":2,"ExpressionStmt":10},"text":"public void run() {\n    while (!done) {\n        try {\n            Thread.sleep(10 * 1000);\n            System.out.println(\"Tick\");\n        } catch (InterruptedException unexpected) {\n            System.out.println(\"WAHHH!\");\n            done = true;\n        }\n        Iterator it = list.iterator();\n        while (it.hasNext()) {\n            String mesg = (\"Your stock price went \" + (rand.nextFloat() > 0.5 ? \"up\" : \"down\") + \"!\");\n            // If this fails, remove them from the list\n            try {\n                ((Client) it.next()).alert(mesg);\n            } catch (RemoteException re) {\n                System.out.println(\"Exception alerting client, removing it.\");\n                System.out.println(re);\n                it.remove();\n            }\n        }\n    }\n}\n                 // Send the alert to the given user.\n\n","name":"run","className":"TickerServerImpl","variables":{"rand":1,"re":1,"unexpected":1,"it":4,"list":1,"done":2,"Thread":1,"mesg":1},"constants":{"\"!\"":1,"\"WAHHH!\"":1,"\"up\"":1,"\"down\"":1,"\"Tick\"":1,"0.5":1,"1000":1,"true":1,"\"Your stock price went \"":1,"\"Exception alerting client, removing it.\"":1,"10":1},"javaDoc":"","comments":"Send the alert to the given user If this fails remove them from the list ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Client"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void connect(Client d) throws RemoteException;\n","name":"connect","className":"TickerServer","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ClientProgram","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** No-argument constructor required as we are a Remote Object */\npublic ClientProgram() throws RemoteException {\n}\n","name":"ClientProgram","className":"ClientProgram","variables":{},"constants":{},"javaDoc":"No-argument constructor required as we are a Remote Object","comments":" No-argument constructor required as we are a Remote Object ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotBoundException","IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** This is the main program, just to get things started. */\npublic static void main(String[] argv) throws IOException, NotBoundException {\n    new ClientProgram().do_the_work();\n}\n","name":"main","className":"ClientProgram","variables":{},"constants":{},"javaDoc":"This is the main program just to get things started","comments":" This is the main program, just to get things started. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"lookup":1,"connect":1,"System.out.println":4},"annotations":[],"exceptions":["NotBoundException","IOException"],"concepts":["Casting"],"types":{"TickerServer":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":30,"StringLiteralExpr":6,"CastExpr":1,"FieldAccessExpr":5,"ThisExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"/** This is the server program part */\nprivate void do_the_work() throws IOException, NotBoundException {\n    System.out.println(\"Client starting\");\n    // First, register us with the RMI registry\n    // Naming.rebind(\"Client\", this);\n    // Now, find the server, and register with it\n    System.out.println(\"Finding server\");\n    TickerServer server = (TickerServer) Naming.lookup(\"rmi://\" + host + \"/\" + TickerServer.LOOKUP_NAME);\n    // This should cause the server to call us back.\n    System.out.println(\"Connecting to server\");\n    server.connect(this);\n    System.out.println(\"Client program ready.\");\n}\n","name":"do_the_work","className":"ClientProgram","variables":{"server":2,"host":1,"Naming":1},"constants":{"\"Finding server\"":1,"\"rmi://\"":1,"\"/\"":1,"\"Client starting\"":1,"\"Connecting to server\"":1,"\"Client program ready.\"":1},"javaDoc":"This is the server program part","comments":"First register us with the RMI registry Naming rebind(\"Client\" this); Now find the server and register with it This should cause the server to call us back  This is the server program part ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** This is the client callback */\npublic void alert(String message) throws RemoteException {\n    System.out.println(message);\n}\n","name":"alert","className":"ClientProgram","variables":{},"constants":{},"javaDoc":"This is the client callback","comments":" This is the client callback ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getRemoteDate":1,"getMessage":1,"showStatus":3,"toString":1,"System.err.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Date":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent evt) {\n    if (netConn == null) {\n        showStatus(\"Connection failed, bye\");\n        return;\n    }\n    try {\n        Date today = netConn.getRemoteDate();\n        // XX use a DateFormat...\n        showStatus(today.toString());\n    } catch (Exception ex) {\n        System.err.println(\"RemoteDate exception: \" + ex.getMessage());\n        showStatus(\"RemoteDate failed, see Java Console\");\n    }\n}\n","name":"actionPerformed","className":"","variables":{"netConn":2,"ex":2,"today":2},"constants":{"\"RemoteDate failed, see Java Console\"":1,"null":1,"\"RemoteDate exception: \"":1,"\"Connection failed, bye\"":1},"javaDoc":"","comments":"XX use a DateFormat ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"getRemoteDate":1,"lookup":1,"printStackTrace":1,"addActionListener":1,"getMessage":2,"showStatus":3,"toString":1,"System.err.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"Date":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":47,"CastExpr":1,"StringLiteralExpr":5,"FieldAccessExpr":3,"AssignExpr":2,"MethodCallExpr":13},"statements":{"IfStmt":1,"TryStmt":2,"BlockStmt":6,"ReturnStmt":1,"ExpressionStmt":10},"text":"public void init() {\n    try {\n        netConn = (RemoteDate) Naming.lookup(RemoteDate.LOOKUPNAME);\n    } catch (Exception e) {\n        System.err.println(\"RemoteDate exception: \" + e.getMessage());\n        e.printStackTrace();\n    }\n    add(b = new Button(\"Get Date\"));\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent evt) {\n            if (netConn == null) {\n                showStatus(\"Connection failed, bye\");\n                return;\n            }\n            try {\n                Date today = netConn.getRemoteDate();\n                // XX use a DateFormat...\n                showStatus(today.toString());\n            } catch (Exception ex) {\n                System.err.println(\"RemoteDate exception: \" + ex.getMessage());\n                showStatus(\"RemoteDate failed, see Java Console\");\n            }\n        }\n    });\n}\n","name":"init","className":"DateApplet","variables":{"netConn":3,"actionPerformed":1,"b":2,"evt":1,"ex":2,"e":3,"today":2,"Naming":1},"constants":{"\"RemoteDate failed, see Java Console\"":1,"\"Get Date\"":1,"null":1,"\"RemoteDate exception: \"":2,"\"Connection failed, bye\"":1},"javaDoc":"","comments":"XX use a DateFormat ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Date","methodCalls":{},"annotations":[],"exceptions":["java.rmi.RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** The method used to get the current date on the remote */\npublic Date getRemoteDate() throws java.rmi.RemoteException;\n","name":"getRemoteDate","className":"RemoteDate","variables":{},"constants":{},"javaDoc":"The method used to get the current date on the remote","comments":" The method used to get the current date on the remote ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"rebind":1,"System.err.println":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"RemoteDateImpl":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":26,"StringLiteralExpr":2,"FieldAccessExpr":4,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    try {\n        // Create an instance of the server object\n        RemoteDateImpl im = new RemoteDateImpl();\n        System.out.println(\"DateServer starting...\");\n        // Publish it in the RMI registry.\n        // Of course you have to have rmiregistry or equivalent running!\n        Naming.rebind(RemoteDate.LOOKUPNAME, im);\n        System.out.println(\"DateServer ready.\");\n         // You may want a SecurityManager for downloading of classes:\n\n         // System.setSecurityManager(new RMISecurityManager());\n\n    } catch (Exception e) {\n        System.err.println(e);\n        System.exit(1);\n    }\n}\n","name":"main","className":"DateServer","variables":{"im":1,"e":1,"Naming":1,"System":1},"constants":{"\"DateServer starting...\"":1,"1":1,"\"DateServer ready.\"":1},"javaDoc":"","comments":"You may want a SecurityManager for downloading of classes: System setSecurityManager(new RMISecurityManager()); Publish it in the RMI registry Create an instance of the server object Of course you have to have rmiregistry or equivalent running! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getRemoteDate":1,"lookup":1,"printStackTrace":1,"getMessage":1,"toString":1,"System.err.println":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Date":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":29,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":3,"AssignExpr":1,"MethodCallExpr":7},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    try {\n        netConn = (RemoteDate) Naming.lookup(RemoteDate.LOOKUPNAME);\n        Date today = netConn.getRemoteDate();\n        // Could use a DateFormat...\n        System.out.println(today.toString());\n    } catch (Exception e) {\n        System.err.println(\"RemoteDate exception: \" + e.getMessage());\n        e.printStackTrace();\n    }\n}\n","name":"main","className":"DateClient","variables":{"netConn":2,"e":3,"today":2,"Naming":1},"constants":{"\"RemoteDate exception: \"":1},"javaDoc":"","comments":"Could use a DateFormat ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"RemoteDateImpl","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct the object that implements the remote server.\n     * Called from main, after it has the SecurityManager in place.\n     */\npublic RemoteDateImpl() throws RemoteException {\n    // sets up networking\n    super();\n}\n","name":"RemoteDateImpl","className":"RemoteDateImpl","variables":{},"constants":{},"javaDoc":"Construct the object that implements the remote server Called from main after it has the SecurityManager in place","comments":"sets up networking  Construct the object that implements the remote server.\n     * Called from main, after it has the SecurityManager in place.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Date","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/** The remote method that \"does all the work\". This won't get\n     * called until the client starts up.\n     */\npublic Date getRemoteDate() throws RemoteException {\n    return new Date();\n}\n","name":"getRemoteDate","className":"RemoteDateImpl","variables":{},"constants":{},"javaDoc":"The remote method that \"does all the work\" This won't get called until the client starts up","comments":" The remote method that \"does all the work\". This won't get\n     * called until the client starts up.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new BSFAction();\n}\n","name":"main","className":"BSFAction","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showMessageDialog":1,"exec":1,"System.out.println":2},"annotations":[],"exceptions":["BSFException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":24,"StringLiteralExpr":4,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent evt) {\n    try {\n        // When the button is pressed, run the script.\n        System.out.println(\"Script output: -->\");\n        manager.exec(language, FILENAME, 0, 0, script);\n        System.out.println(\"<-- End of Script output.\");\n    } catch (BSFException bse) {\n        JOptionPane.showMessageDialog(jf, \"ERROR: \" + bse, \"Script Error\", JOptionPane.ERROR_MESSAGE);\n    }\n}\n","name":"actionPerformed","className":"","variables":{"manager":1,"bse":2,"JOptionPane":1},"constants":{"0":2,"\"Script output: -->\"":1,"\"<-- End of Script output.\"":1,"\"ERROR: \"":1,"\"Script Error\"":1},"javaDoc":"","comments":"When the button is pressed run the script ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent evt) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BSFAction","methodCalls":{"add":3,"setVisible":1,"getClass":1,"declareBean":1,"getName":1,"addActionListener":2,"getContentPane":1,"getLangFromFilename":1,"setLayout":1,"loadScriptingEngine":1,"pack":1,"registerScriptingEngine":1,"readerToString":1,"exit":1,"showMessageDialog":1,"toString":1,"System.err.println":1,"exec":1,"System.out.println":3},"annotations":[],"exceptions":["BSFException","Exception"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"Container":1,"JFrame":1,"JButton":2,"LabelText":1,"String[]":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":3,"VariableDeclarationExpr":6,"ArrayInitializerExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":13,"NameExpr":101,"ClassExpr":1,"FieldAccessExpr":5,"AssignExpr":4,"MethodCallExpr":24},"statements":{"TryStmt":2,"BlockStmt":6,"ReturnStmt":1,"ExpressionStmt":27},"text":"BSFAction() {\n    // Construct the Bean instance\n    LabelText bean = new LabelText(\"Message to Python script\");\n    try {\n        manager = new BSFManager();\n        // register scripting language\n        String[] fntypes = { \".py\" };\n        BSFManager.registerScriptingEngine(\"jpython\", \"org.apache.bsf.engines.jpython.JPythonEngine\", fntypes);\n        jpythonengine = manager.loadScriptingEngine(\"jpython\");\n        // Tell BSF about the bean.\n        manager.declareBean(\"bean\", bean, LabelText.class);\n        // Read the script file into BSF\n        language = BSFManager.getLangFromFilename(FILENAME);\n        script = FileIO.readerToString(new FileReader(FILENAME));\n    } catch (Exception ex) {\n        System.err.println(ex.toString());\n        return;\n    }\n    System.out.println(\"Scripting setup done, building GUI.\");\n    final JFrame jf = new JFrame(getClass().getName());\n    Container cp = jf.getContentPane();\n    cp.setLayout(new FlowLayout());\n    // add the LabelText\n    cp.add(bean);\n    JButton b = new JButton(\"Click me!\");\n    // and the button under it.\n    cp.add(b);\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent evt) {\n            try {\n                // When the button is pressed, run the script.\n                System.out.println(\"Script output: -->\");\n                manager.exec(language, FILENAME, 0, 0, script);\n                System.out.println(\"<-- End of Script output.\");\n            } catch (BSFException bse) {\n                JOptionPane.showMessageDialog(jf, \"ERROR: \" + bse, \"Script Error\", JOptionPane.ERROR_MESSAGE);\n            }\n        }\n    });\n    // A Quit button at the bottom\n    JButton qb = new JButton(\"Quit\");\n    cp.add(qb);\n    qb.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent evt) {\n            System.exit(0);\n        }\n    });\n    // Routine JFrame setup\n    jf.pack();\n    jf.setVisible(true);\n}\n","name":"BSFAction","className":"BSFAction","variables":{"b":2,"evt":2,"manager":4,"jpythonengine":1,"language":1,"BSFManager":2,"cp":5,"JOptionPane":1,"script":1,"System":1,"FileIO":1,"actionPerformed":2,"qb":2,"ex":2,"bse":2,"jf":4,"fntypes":1,"FILENAME":1,"bean":1},"constants":{"\"Quit\"":1,"\"<-- End of Script output.\"":1,"\"jpython\"":2,"\"ERROR: \"":1,"\"Scripting setup done, building GUI.\"":1,"\"bean\"":1,"0":3,"\"Script output: -->\"":1,"\".py\"":1,"true":1,"\"Script Error\"":1,"\"Message to Python script\"":1,"\"Click me!\"":1,"\"org.apache.bsf.engines.jpython.JPythonEngine\"":1},"javaDoc":"","comments":"Construct the Bean instance register scripting language Tell BSF about the bean Read the script file into BSF add the LabelText and the button under it When the button is pressed run the script A Quit button at the bottom Routine JFrame setup ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"registerScriptingEngine":1,"getClass":1,"eval":1,"getName":1,"toString":1,"System.err.println":1,"System.out.println":3},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Object":1,"BSFManager":1,"String[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayInitializerExpr":1,"BinaryExpr":2,"StringLiteralExpr":9,"NameExpr":36,"FieldAccessExpr":4,"MethodCallExpr":9},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    BSFManager manager = new BSFManager();\n    // register scripting language\n    String[] fntypes = { \".py\" };\n    BSFManager.registerScriptingEngine(\"jython\", \"org.apache.bsf.engines.jython.JythonEngine\", fntypes);\n    try {\n        // try an expression\n        Object r = manager.eval(\"jython\", \"testString\", 0, 0, \"22.0/7\");\n        System.out.println(\"Result type is \" + r.getClass().getName());\n        System.out.println(\"Result value is \" + r);\n    } catch (Exception ex) {\n        System.err.println(ex.toString());\n    }\n    System.out.println(\"Scripting demo done.\");\n    return;\n}\n","name":"main","className":"BSFSample","variables":{"r":3,"ex":2,"manager":2,"BSFManager":1,"fntypes":1},"constants":{"0":2,"\"Result value is \"":1,"\"org.apache.bsf.engines.jython.JythonEngine\"":1,"\"jython\"":2,"\"testString\"":1,"\"22.0/7\"":1,"\"Result type is \"":1,"\".py\"":1,"\"Scripting demo done.\"":1},"javaDoc":"","comments":"register scripting language try an expression ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getMessage":1,"System.out.println":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void displayMessage() {\n    System.out.println(messageProvider.getMessage());\n}\n","name":"displayMessage","className":"ConsoleViewer","variables":{"messageProvider":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Model"],"returnType":"void","methodCalls":{},"annotations":["Resource"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"@Resource(name = \"myModel\")\npublic void setModel(Model messageProvider) {\n    this.messageProvider = messageProvider;\n}\n","name":"setModel","className":"ConsoleViewer","variables":{"messageProvider":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic String getMessage() {\n    return \"This is some simple model data\";\n}\n","name":"getMessage","className":"SimpleModel","variables":{},"constants":{"\"This is some simple model data\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"displayMessage":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"SimpleModel":1,"ConsoleViewer":1,"Model":1,"View":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"CastExpr":1,"NameExpr":7,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    Model m = new SimpleModel();\n    View v = new ConsoleViewer();\n    ((ConsoleViewer) v).setModel(m);\n    v.displayMessage();\n}\n","name":"main","className":"ControllerTightlyCoupled","variables":{"v":3,"m":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"displayMessage":1,"getBean":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"AnnotationConfigApplicationContext":1,"ApplicationContext":1,"View":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"StringLiteralExpr":2,"NameExpr":6,"ClassExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    ApplicationContext ctx = new AnnotationConfigApplicationContext(\"di.spring\");\n    View v = ctx.getBean(\"myView\", View.class);\n    v.displayMessage();\n}\n","name":"main","className":"Controller","variables":{"ctx":2,"v":2},"constants":{"\"di.spring\"":1,"\"myView\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void displayMessage() {\n    System.out.println(message);\n}\n","name":"displayMessage","className":"ConsoleViewer","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"displayMessage":1,"instance":1,"select":1,"get":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Instance<Object>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":11,"ClassExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    final Instance<Object> weldInstance = new Weld().initialize().instance();\n    weldInstance.select(ConsoleViewer.class).get().displayMessage();\n}\n","name":"main","className":"CDIMain","variables":{"weldInstance":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["InjectionPoint"],"returnType":"String","methodCalls":{"getDeclaringClass":1,"getName":1,"getMember":2,"getSimpleName":1,"getString":1,"getBundle":1},"annotations":["Produces","MyModel"],"exceptions":["IOException"],"concepts":[],"types":{"ResourceBundle":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":18,"StringLiteralExpr":2,"MethodCallExpr":7},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"@Produces\n@MyModel\npublic String getModelData(InjectionPoint ip) throws IOException {\n    ResourceBundle props = ResourceBundle.getBundle(\"messages\");\n    return props.getString(ip.getMember().getDeclaringClass().getSimpleName() + \".\" + ip.getMember().getName());\n}\n","name":"getModelData","className":"Model","variables":{"ip":2,"ResourceBundle":1,"props":2},"constants":{"\".\"":1,"\"messages\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"displayMessage":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"SimpleModel":1,"ConsoleViewer":1,"Model":1,"View":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"CastExpr":1,"NameExpr":7,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    Model m = new SimpleModel();\n    View v = new ConsoleViewer();\n    ((ConsoleViewer) v).setModel(m);\n    v.displayMessage();\n}\n","name":"main","className":"ControllerTightlyCoupled","variables":{"v":3,"m":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"void displayMessage();\n","name":"displayMessage","className":"View","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"System.out.printf":1,"nextInt":2},"annotations":[],"exceptions":[],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"String":2,"int":2},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"StringLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    // BEGIN main\n    String sampleDate = \"25 Dec 1988\";\n    try (Scanner sDate = new Scanner(sampleDate)) {\n        int dayOfMonth = sDate.nextInt();\n        String month = sDate.next();\n        int year = sDate.nextInt();\n        System.out.printf(\"%d-%s-%02d%n\", year, month, dayOfMonth);\n    }\n// END main\n}\n","name":"main","className":"ScannerDemo","variables":{"month":1,"sDate":4,"dayOfMonth":1,"year":1,"sampleDate":2},"constants":{"\"%d-%s-%02d%n\"":1,"\"25 Dec 1988\"":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["PrintStream","OutputStream","boolean"],"returnType":"TeePrintStream","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":5,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":2},"text":"/** Construct a TeePrintStream given an existing PrintStream,\n     * an opened OutputStream, and a boolean to control auto-flush.\n     * This is the main constructor, to which others delegate via \"this\".\n     */\npublic TeePrintStream(PrintStream orig, OutputStream os, boolean flush) throws IOException {\n    super(os, true);\n    fileName = UNKNOWN_NAME;\n    parent = orig;\n}\n","name":"TeePrintStream","className":"TeePrintStream","variables":{"parent":1,"fileName":1,"os":1,"orig":1,"UNKNOWN_NAME":1},"constants":{"true":1},"javaDoc":"Construct a TeePrintStream given an existing PrintStream an opened OutputStream and a boolean to control auto-flush This is the main constructor to which others delegate via \"this\"","comments":" Construct a TeePrintStream given an existing PrintStream,\n     * an opened OutputStream, and a boolean to control auto-flush.\n     * This is the main constructor, to which others delegate via \"this\".\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintStream","OutputStream"],"returnType":"TeePrintStream","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a TeePrintStream given an existing PrintStream and\n     * an opened OutputStream.\n     */\npublic TeePrintStream(PrintStream orig, OutputStream os) throws IOException {\n    this(orig, os, true);\n}\n","name":"TeePrintStream","className":"TeePrintStream","variables":{"os":1,"orig":1},"constants":{"true":1},"javaDoc":"Construct a TeePrintStream given an existing PrintStream and an opened OutputStream","comments":" Construct a TeePrintStream given an existing PrintStream and\n     * an opened OutputStream.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintStream","String"],"returnType":"TeePrintStream","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/* Construct a TeePrintStream given an existing Stream and a filename.\n     */\npublic TeePrintStream(PrintStream os, String fn) throws IOException {\n    this(os, fn, true);\n}\n","name":"TeePrintStream","className":"TeePrintStream","variables":{"os":1,"fn":1},"constants":{"true":1},"javaDoc":"","comments":" Construct a TeePrintStream given an existing Stream and a filename.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintStream","String","boolean"],"returnType":"TeePrintStream","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/* Construct a TeePrintStream given an existing Stream, a filename,\n     * and a boolean to control the flush operation.\n     */\npublic TeePrintStream(PrintStream orig, String fn, boolean flush) throws IOException {\n    this(orig, new FileOutputStream(fn), flush);\n    fileName = fn;\n}\n","name":"TeePrintStream","className":"TeePrintStream","variables":{"fileName":1,"flush":1,"orig":1,"fn":2},"constants":{},"javaDoc":"","comments":" Construct a TeePrintStream given an existing Stream, a filename,\n     * and a boolean to control the flush operation.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"checkError":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** Return true if either stream has an error. */\npublic boolean checkError() {\n    return parent.checkError() || super.checkError();\n}\n","name":"checkError","className":"TeePrintStream","variables":{"parent":1},"constants":{},"javaDoc":"Return true if either stream has an error","comments":" Return true if either stream has an error. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"write":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** override write(). This is the actual \"tee\" operation. */\npublic void write(int x) {\n    // \"write once;\n    parent.write(x);\n    // write somewhere else.\"\n    super.write(x);\n}\n","name":"write","className":"TeePrintStream","variables":{"parent":1},"constants":{},"javaDoc":"override write() This is the actual \"tee\" operation","comments":"\"write once; write somewhere else \"  override write(). This is the actual \"tee\" operation. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["byte[]","int","int"],"returnType":"void","methodCalls":{"write":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":11,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** override write(). This is the actual \"tee\" operation. */\npublic void write(byte[] x, int o, int l) {\n    // \"write once;\n    parent.write(x, o, l);\n    // write somewhere else.\"\n    super.write(x, o, l);\n}\n","name":"write","className":"TeePrintStream","variables":{"parent":1},"constants":{},"javaDoc":"override write() This is the actual \"tee\" operation","comments":"\"write once; write somewhere else \"  override write(). This is the actual \"tee\" operation. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Close both streams. */\npublic void close() {\n    parent.close();\n    super.close();\n}\n","name":"close","className":"TeePrintStream","variables":{"parent":1},"constants":{},"javaDoc":"Close both streams","comments":" Close both streams. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"flush":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Flush both streams. */\npublic void flush() {\n    parent.flush();\n    super.flush();\n}\n","name":"flush","className":"TeePrintStream","variables":{"parent":1},"constants":{},"javaDoc":"Flush both streams","comments":" Flush both streams. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"writeInt":1,"close":1,"writeDouble":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"double":1,"DataOutputStream":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":5,"NameExpr":23,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":8},"text":"public static void main(String[] argv) throws IOException {\n    int i = 42;\n    double d = Math.PI;\n    String FILENAME = \"binary.dat\";\n    DataOutputStream os = new DataOutputStream(new FileOutputStream(FILENAME));\n    os.writeInt(i);\n    os.writeDouble(d);\n    os.close();\n    System.out.println(\"Wrote \" + i + \", \" + d + \" to file \" + FILENAME);\n}\n","name":"main","className":"WriteBinary","variables":{"d":2,"os":4,"i":2,"FILENAME":3},"constants":{"\"binary.dat\"":1,"\"Wrote \"":1,"\" to file \"":1,"\", \"":1,"42":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":17,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/* Driver - main program */\npublic static void main(String[] av) throws IOException {\n    if (av.length == 0)\n        new SimpleCalcStreamTok(new InputStreamReader(System.in)).doCalc();\n    else\n        for (int i = 0; i < av.length; i++) new SimpleCalcStreamTok(av[i]).doCalc();\n}\n","name":"main","className":"SimpleCalcStreamTok","variables":{"av":1,"i":4},"constants":{"0":2},"javaDoc":"","comments":" Driver - main program ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"SimpleCalcStreamTok","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct by filename */\npublic SimpleCalcStreamTok(String fileName) throws IOException {\n    this(new FileReader(fileName));\n}\n","name":"SimpleCalcStreamTok","className":"SimpleCalcStreamTok","variables":{"fileName":1},"constants":{},"javaDoc":"Construct by filename","comments":" Construct by filename ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader"],"returnType":"SimpleCalcStreamTok","methodCalls":{"slashSlashComments":1,"ordinaryChar":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"BooleanLiteralExpr":1,"NameExpr":12,"CharLiteralExpr":2,"AssignExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"/** Construct from an existing Reader */\npublic SimpleCalcStreamTok(Reader rdr) throws IOException {\n    tf = new StreamTokenizer(rdr);\n    // Control the input character set:\n    // treat \"//\" as comments\n    tf.slashSlashComments(true);\n    // used for subtraction\n    tf.ordinaryChar('-');\n    // used for division\n    tf.ordinaryChar('/');\n    s = new Stack();\n}\n","name":"SimpleCalcStreamTok","className":"SimpleCalcStreamTok","variables":{"rdr":1,"tf":4,"s":1},"constants":{"'-'":1,"true":1,"'/'":1},"javaDoc":"Construct from an existing Reader","comments":"Control the input character set: treat \"//\" as comments used for subtraction used for division  Construct from an existing Reader ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader","PrintWriter"],"returnType":"SimpleCalcStreamTok","methodCalls":{"setOutput":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/** Construct from a Reader and a PrintWriter\n     */\npublic SimpleCalcStreamTok(Reader in, PrintWriter out) throws IOException {\n    this(in);\n    setOutput(out);\n}\n","name":"SimpleCalcStreamTok","className":"SimpleCalcStreamTok","variables":{"in":1},"constants":{},"javaDoc":"Construct from a Reader and a PrintWriter","comments":" Construct from a Reader and a PrintWriter\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Change the output destination.\n     */\npublic void setOutput(PrintWriter out) {\n    this.out = out;\n}\n","name":"setOutput","className":"SimpleCalcStreamTok","variables":{"out":1},"constants":{},"javaDoc":"Change the output destination","comments":"\n     * Change the output destination.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"pop":8,"println":2,"nextToken":1,"push":5,"peek":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"double":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":60,"StringLiteralExpr":1,"FieldAccessExpr":5,"CharLiteralExpr":5,"EnclosedExpr":1,"AssignExpr":4,"MethodCallExpr":17},"statements":{"SwitchStmt":1,"WhileStmt":1,"BreakStmt":7,"BlockStmt":1,"SwitchEntryStmt":8,"ExpressionStmt":12},"text":"protected void doCalc() throws IOException {\n    int iType;\n    double tmp;\n    while ((iType = tf.nextToken()) != StreamTokenizer.TT_EOF) {\n        switch(iType) {\n            case // Found a number, push value to stack\n            StreamTokenizer.TT_NUMBER:\n                push(tf.nval);\n                break;\n            case StreamTokenizer.TT_WORD:\n                // Found a variable, save its name. Not used here.\n                variable = tf.sval;\n                break;\n            case '+':\n                // + operator is commutative.\n                push(pop() + pop());\n                break;\n            case '-':\n                // - operator: order matters.\n                tmp = pop();\n                push(pop() - tmp);\n                break;\n            case '*':\n                // Multiply is commutative\n                push(pop() * pop());\n                break;\n            case '/':\n                // Handle division carefully: order matters!\n                tmp = pop();\n                push(pop() / tmp);\n                break;\n            case '=':\n                out.println(peek());\n                break;\n            default:\n                out.println(\"What's this? iType = \" + iType);\n        }\n    }\n}\n","name":"doCalc","className":"SimpleCalcStreamTok","variables":{"tf":1,"tmp":5,"variable":1,"iType":4,"out":2},"constants":{"'-'":1,"'='":1,"'+'":1,"'*'":1,"\"What's this? iType = \"":1,"'/'":1},"javaDoc":"","comments":"Found a number push value to stack Found a variable save its name Not used here + operator is commutative - operator: order matters Multiply is commutative Handle division carefully: order matters! ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"push":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"void push(double val) {\n    s.push(new Double(val));\n}\n","name":"push","className":"SimpleCalcStreamTok","variables":{"val":1,"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"double","methodCalls":{"pop":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":5,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"double pop() {\n    return ((Double) s.pop()).doubleValue();\n}\n","name":"pop","className":"SimpleCalcStreamTok","variables":{"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"double","methodCalls":{"peek":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":5,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"double peek() {\n    return ((Double) s.peek()).doubleValue();\n}\n","name":"peek","className":"SimpleCalcStreamTok","variables":{"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeAllElements":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"void clearStack() {\n    s.removeAllElements();\n}\n","name":"clearStack","className":"SimpleCalcStreamTok","variables":{"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"MyData","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** This constructor is required by most APIs  */\npublic MyData() {\n// Nothing to do\n}\n","name":"MyData","className":"MyData","variables":{},"constants":{},"javaDoc":"This constructor is required by most APIs","comments":"Nothing to do  This constructor is required by most APIs  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"MyData","methodCalls":{"setPassword":1,"setUserName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public MyData(String name, String clear) {\n    setUserName(name);\n    setPassword(clear);\n}\n","name":"MyData","className":"MyData","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getUserName() {\n    return userName;\n}\n","name":"getUserName","className":"MyData","variables":{"userName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setUserName(String s) {\n    this.userName = s;\n}\n","name":"setUserName","className":"MyData","variables":{"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getPasswordCypher() {\n    return passwordCypher;\n}\n","name":"getPasswordCypher","className":"MyData","variables":{"passwordCypher":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"encrypt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Save the clear text p/w in the object, it won't get serialized\n     * So we must save the encryption! Encryption not shown here.\n     */\npublic void setPassword(String s) {\n    this.passwordClear = s;\n    passwordCypher = encrypt(passwordClear);\n}\n","name":"setPassword","className":"MyData","variables":{"s":1,"passwordCypher":1},"constants":{},"javaDoc":"Save the clear text p/w in the object it won't get serialized So we must save the encryption! Encryption not shown here","comments":" Save the clear text p/w in the object, it won't get serialized\n     * So we must save the encryption! Encryption not shown here.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"MyData[\" + userName + \",------]\";\n}\n","name":"toString","className":"MyData","variables":{"userName":1},"constants":{"\",------]\"":1,"\"MyData[\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** In real life this would use Java Cryptography */\nprotected String encrypt(String s) {\n    return \"fjslkjlqj2TOP+SECRETkjlskl\";\n}\n","name":"encrypt","className":"MyData","variables":{},"constants":{"\"fjslkjlqj2TOP+SECRETkjlskl\"":1},"javaDoc":"In real life this would use Java Cryptography","comments":" In real life this would use Java Cryptography ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the continuation mode */\npublic void setContinuationMode(boolean b) {\n    doContinue = b;\n}\n","name":"setContinuationMode","className":"ContLineReader","variables":{"b":1,"doContinue":1},"constants":{},"javaDoc":"Set the continuation mode","comments":" Set the continuation mode ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get the continuation mode */\npublic boolean getContinuationMode() {\n    return doContinue;\n}\n","name":"getContinuationMode","className":"ContLineReader","variables":{"doContinue":1},"constants":{},"javaDoc":"Get the continuation mode","comments":" Get the continuation mode ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/** Read one (possibly continued) line, stripping out the \\ that\n     * marks the end of each line but the last in a sequence.\n     */\npublic abstract String readLine() throws IOException;\n","name":"readLine","className":"ContLineReader","variables":{},"constants":{},"javaDoc":"Read one (possibly continued) line stripping out the \\ that marks the end of each line but the last in a sequence","comments":" Read one (possibly continued) line, stripping out the \\ that\n     * marks the end of each line but the last in a sequence.\n     ","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Read one real line. Provided as a convenience for the\n     * subclasses, so they don't embarrass themselves trying to\n     * call \"super.readLine()\" which isn't very practical...\n     */\npublic String readPhysicalLine() throws IOException {\n    return super.readLine();\n}\n","name":"readPhysicalLine","className":"ContLineReader","variables":{},"constants":{},"javaDoc":"Read one real line Provided as a convenience for the subclasses so they don't embarrass themselves trying to call \"super readLine()\" which isn't very practical","comments":" Read one real line. Provided as a convenience for the\n     * subclasses, so they don't embarrass themselves trying to\n     * call \"super.readLine()\" which isn't very practical...\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader"],"returnType":"ContLineReader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a ContLineReader with the default input-buffer size. */\npublic ContLineReader(Reader in) {\n    super(in);\n}\n","name":"ContLineReader","className":"ContLineReader","variables":{"in":1},"constants":{},"javaDoc":"Construct a ContLineReader with the default input-buffer size","comments":" Construct a ContLineReader with the default input-buffer size. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader","int"],"returnType":"ContLineReader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a ContLineReader using the given input-buffer size. */\npublic ContLineReader(Reader in, int sz) {\n    super(in, sz);\n}\n","name":"ContLineReader","className":"ContLineReader","variables":{"in":1,"sz":1},"constants":{},"javaDoc":"Construct a ContLineReader using the given input-buffer size","comments":" Construct a ContLineReader using the given input-buffer size. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Read a single character, returned as an int. */\npublic int read() throws IOException {\n    return super.read();\n}\n","name":"read","className":"ContLineReader","variables":{},"constants":{},"javaDoc":"Read a single character returned as an int","comments":" Read a single character, returned as an int. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char[]","int","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Read characters into a portion of an array. */\npublic int read(char[] cbuf, int off, int len) throws IOException {\n    return super.read(cbuf, off, len);\n}\n","name":"read","className":"ContLineReader","variables":{},"constants":{},"javaDoc":"Read characters into a portion of an array","comments":" Read characters into a portion of an array. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean markSupported() {\n    return false;\n}\n","name":"markSupported","className":"ContLineReader","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) throws IOException {\n    new SerialDemoXML().save();\n    new SerialDemoXML().dump();\n}\n","name":"main","className":"SerialDemoXML","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"writeObject":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"XMLEncoder":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/** Save the data to disk. */\npublic void write(Object theGraph) throws IOException {\n    XMLEncoder os = new XMLEncoder(new FileOutputStream(FILENAME));\n    os.writeObject(theGraph);\n    os.close();\n}\n","name":"write","className":"SerialDemoXML","variables":{"os":3,"FILENAME":1},"constants":{},"javaDoc":"Save the data to disk","comments":" Save the data to disk. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1,"System.out.println":1,"readObject":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"XMLDecoder":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":12,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"/** Display the data */\npublic void dump() throws IOException {\n    XMLDecoder inp = new XMLDecoder(new FileInputStream(FILENAME));\n    System.out.println(inp.readObject());\n    inp.close();\n}\n","name":"dump","className":"SerialDemoXML","variables":{"inp":3,"FILENAME":1},"constants":{},"javaDoc":"Display the data","comments":" Display the data ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] s) throws Exception {\n    // in parent class; calls write\n    new SerialDemoObjectStream().save();\n    // here\n    new SerialDemoObjectStream().dump();\n}\n","name":"main","className":"SerialDemoObjectStream","variables":{},"constants":{},"javaDoc":"","comments":"in parent class; calls write here ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"writeObject":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"ObjectOutputStream":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/** Does the actual serialization */\npublic void write(Object theGraph) throws IOException {\n    // Save the data to disk.\n    ObjectOutputStream os = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(FILENAME)));\n    os.writeObject(theGraph);\n    os.close();\n}\n","name":"write","className":"SerialDemoObjectStream","variables":{"os":3,"FILENAME":1},"constants":{},"javaDoc":"Does the actual serialization","comments":"Save the data to disk  Does the actual serialization ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1,"System.out.println":1,"readObject":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":12,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void dump() throws IOException, ClassNotFoundException {\n    ObjectInputStream is = new ObjectInputStream(new FileInputStream(FILENAME));\n    System.out.println(is.readObject());\n    is.close();\n}\n","name":"dump","className":"SerialDemoObjectStream","variables":{"is":3,"FILENAME":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"append":1,"System.out.println":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"String":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":9,"StringLiteralExpr":10,"NameExpr":45,"FieldAccessExpr":7,"CharLiteralExpr":3,"MethodCallExpr":9},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    Object anObject = new Object();\n    String myAnswer = \"no\";\n    int i = 42;\n    System.out.println(\"Hello, World of Java\");\n    System.out.println(\"An object is \" + anObject);\n    System.out.println(\"The answer is \" + myAnswer + \" at this time.\");\n    System.out.println(\"The answer is \" + i + '.');\n    System.out.println(\"The answer is \" + i + \".\");\n    System.out.println(i + '=' + \" the answer.\");\n    System.out.println(new StringBuffer(\"The answer is \").append(i).append('.'));\n// END main\n}\n","name":"main","className":"Stdout","variables":{"anObject":2,"i":4,"myAnswer":2},"constants":{"'.'":2,"'='":1,"\" the answer.\"":1,"\"An object is \"":1,"\".\"":1,"\" at this time.\"":1,"\"Hello, World of Java\"":1,"\"The answer is \"":4,"\"no\"":1,"42":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readOffset":1,"readMessage":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"ReadRandom":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":17,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] argv) throws IOException {\n    ReadRandom r = new ReadRandom(FILENAME);\n    System.out.println(\"Offset is \" + r.readOffset());\n    System.out.println(\"Message is \\\"\" + r.readMessage() + \"\\\".\");\n}\n","name":"main","className":"ReadRandom","variables":{"r":3,"FILENAME":1},"constants":{"\"Message is \\\"\"":1,"\"Offset is \"":1,"\"\\\".\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"ReadRandom","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":4,"StringLiteralExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Constructor: save filename, construct RandomAccessFile */\npublic ReadRandom(String fname) throws IOException {\n    fileName = fname;\n    seeker = new RandomAccessFile(fname, \"r\");\n}\n","name":"ReadRandom","className":"ReadRandom","variables":{"fname":2,"fileName":1,"seeker":1},"constants":{"\"r\"":1},"javaDoc":"Constructor: save filename construct RandomAccessFile","comments":" Constructor: save filename, construct RandomAccessFile ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"readInt":1,"seek":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Read the Offset field, defined to be at location 0 in the file. */\npublic int readOffset() throws IOException {\n    // move to very beginning\n    seeker.seek(0);\n    // and read the offset\n    return seeker.readInt();\n}\n","name":"readOffset","className":"ReadRandom","variables":{"seeker":2},"constants":{"0":1},"javaDoc":"Read the Offset field defined to be at location 0 in the file","comments":"move to very beginning and read the offset  Read the Offset field, defined to be at location 0 in the file. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"readOffset":1,"readLine":1,"seek":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":8,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Read the message at the given offset */\npublic String readMessage() throws IOException {\n    // move to the offset\n    seeker.seek(readOffset());\n    // and read the String\n    return seeker.readLine();\n}\n","name":"readMessage","className":"ReadRandom","variables":{"seeker":2},"constants":{},"javaDoc":"Read the message at the given offset","comments":"move to the offset and read the String  Read the message at the given offset ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"/* Driver - main program */\npublic static void main(String[] args) throws IOException {\n    if (args.length == 0)\n        new SimpleCalcScanner(new InputStreamReader(System.in)).doCalc();\n    else\n        for (String arg : args) {\n            new SimpleCalcScanner(arg).doCalc();\n        }\n}\n","name":"main","className":"SimpleCalcScanner","variables":{"args":1,"arg":2},"constants":{"0":1},"javaDoc":"","comments":" Driver - main program ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"SimpleCalcScanner","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a SimpleCalcScanner by name */\npublic SimpleCalcScanner(String fileName) throws IOException {\n    this(new FileReader(fileName));\n}\n","name":"SimpleCalcScanner","className":"SimpleCalcScanner","variables":{"fileName":1},"constants":{},"javaDoc":"Construct a SimpleCalcScanner by name","comments":" Construct a SimpleCalcScanner by name ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader"],"returnType":"SimpleCalcScanner","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Construct a SimpleCalcScanner from an open Reader */\npublic SimpleCalcScanner(Reader rdr) throws IOException {\n    scan = new Scanner(rdr);\n}\n","name":"SimpleCalcScanner","className":"SimpleCalcScanner","variables":{"rdr":1,"scan":1},"constants":{},"javaDoc":"Construct a SimpleCalcScanner from an open Reader","comments":" Construct a SimpleCalcScanner from an open Reader ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader","PrintWriter"],"returnType":"SimpleCalcScanner","methodCalls":{"setWriter":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/** Construct a SimpleCalcScanner from a Reader and a PrintWriter */\npublic SimpleCalcScanner(Reader rdr, PrintWriter pw) throws IOException {\n    this(rdr);\n    setWriter(pw);\n}\n","name":"SimpleCalcScanner","className":"SimpleCalcScanner","variables":{"rdr":1},"constants":{},"javaDoc":"Construct a SimpleCalcScanner from a Reader and a PrintWriter","comments":" Construct a SimpleCalcScanner from a Reader and a PrintWriter ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Change the output to go to a new PrintWriter */\npublic void setWriter(PrintWriter pw) {\n    out = pw;\n}\n","name":"setWriter","className":"SimpleCalcScanner","variables":{"pw":1,"out":1},"constants":{},"javaDoc":"Change the output to go to a new PrintWriter","comments":" Change the output to go to a new PrintWriter ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"next":1,"pop":8,"println":2,"equals":5,"hasNext":1,"hasNextDouble":1,"push":5,"nextDouble":1,"peek":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"double":1,"String":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":66,"StringLiteralExpr":6,"MethodCallExpr":25,"AssignExpr":2},"statements":{"IfStmt":6,"WhileStmt":1,"BlockStmt":9,"ExpressionStmt":11},"text":"protected void doCalc() throws IOException {\n    double tmp;\n    while (scan.hasNext()) {\n        if (scan.hasNextDouble()) {\n            push(scan.nextDouble());\n        } else {\n            String token = scan.next();\n            if (token.equals(\"+\")) {\n                // Found + operator, perform it immediately.\n                push(pop() + pop());\n            } else if (token.equals(\"-\")) {\n                // Found - operator, perform it (order matters).\n                tmp = pop();\n                push(pop() - tmp);\n            } else if (token.equals(\"*\")) {\n                // Multiply is commutative\n                push(pop() * pop());\n            } else if (token.equals(\"/\")) {\n                // Handle division carefully: order matters!\n                tmp = pop();\n                push(pop() / tmp);\n            } else if (token.equals(\"=\")) {\n                out.println(peek());\n            } else {\n                out.println(\"What's this? \" + token);\n            }\n        }\n    }\n}\n","name":"doCalc","className":"SimpleCalcScanner","variables":{"tmp":5,"scan":4,"token":7,"out":2},"constants":{"\"/\"":1,"\"-\"":1,"\"=\"":1,"\"+\"":1,"\"*\"":1,"\"What's this? \"":1},"javaDoc":"","comments":"Found + operator perform it immediately Found - operator perform it (order matters) Multiply is commutative Handle division carefully: order matters! ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"push":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"void push(double val) {\n    s.push(new Double(val));\n}\n","name":"push","className":"SimpleCalcScanner","variables":{"val":1,"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"double","methodCalls":{"pop":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":5,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"double pop() {\n    return ((Double) s.pop()).doubleValue();\n}\n","name":"pop","className":"SimpleCalcScanner","variables":{"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"double","methodCalls":{"peek":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":5,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"double peek() {\n    return ((Double) s.peek()).doubleValue();\n}\n","name":"peek","className":"SimpleCalcScanner","variables":{"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"removeAllElements":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"void clearStack() {\n    s.removeAllElements();\n}\n","name":"clearStack","className":"SimpleCalcScanner","variables":{"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"GoodNewline":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    GoodNewline jack = new GoodNewline(\"Jack Adolphus Schmidt, III\");\n    jack.print(System.out);\n}\n","name":"main","className":"GoodNewline","variables":{"jack":2},"constants":{"\"Jack Adolphus Schmidt, III\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["PrintStream"],"returnType":"void","methodCalls":{"println":2,"toString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"protected void print(PrintStream out) {\n    // classname and hashcode\n    out.println(toString());\n    // print name  on next line\n    out.println(myName);\n}\n","name":"print","className":"GoodNewline","variables":{"out":2},"constants":{},"javaDoc":"","comments":"classname and hashcode print name on next line ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"GoodNewline","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/* Constructor */\npublic GoodNewline(String s) {\n    myName = s;\n}\n","name":"GoodNewline","className":"GoodNewline","variables":{"s":1,"myName":1},"constants":{},"javaDoc":"","comments":" Constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"write":1},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"ArrayList":1,"List<MyData>":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"NameExpr":9,"StringLiteralExpr":4,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"/** The save method in an application */\npublic void save() throws IOException {\n    List<MyData> l = new ArrayList<>();\n    // Gather the data\n    l.add(new MyData(\"Ian Darwin\", \"secret_java_cook\"));\n    l.add(new MyData(\"Abby Brant\", \"dujordian\"));\n    write(l);\n}\n","name":"save","className":"SerialDemoAbstractBase","variables":{"l":3},"constants":{"\"Ian Darwin\"":1,"\"secret_java_cook\"":1,"\"Abby Brant\"":1,"\"dujordian\"":1},"javaDoc":"The save method in an application","comments":"Gather the data  The save method in an application ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/** Does the actual serialization */\npublic abstract void write(Object theGraph) throws IOException;\n","name":"write","className":"SerialDemoAbstractBase","variables":{},"constants":{},"javaDoc":"Does the actual serialization","comments":" Does the actual serialization ","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/** Reads the file and displays it. */\npublic abstract void dump() throws IOException, ClassNotFoundException;\n","name":"dump","className":"SerialDemoAbstractBase","variables":{},"constants":{},"javaDoc":"Reads the file and displays it","comments":" Reads the file and displays it. ","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":17,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] av) throws IOException {\n    if (av.length == 0)\n        new ScanStringTok(new InputStreamReader(System.in)).process();\n    else\n        for (int i = 0; i < av.length; i++) new ScanStringTok(av[i]).process();\n}\n","name":"main","className":"ScanStringTok","variables":{"av":1,"i":4},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"ScanStringTok","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Construct a file scanner by name */\npublic ScanStringTok(String fileName) throws IOException {\n    is = new LineNumberReader(new FileReader(fileName));\n}\n","name":"ScanStringTok","className":"ScanStringTok","variables":{"fileName":1,"is":1},"constants":{},"javaDoc":"Construct a file scanner by name","comments":" Construct a file scanner by name ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader"],"returnType":"ScanStringTok","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"CastExpr":1,"InstanceOfExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Construct a file scanner by existing Reader */\npublic ScanStringTok(Reader rdr) throws IOException {\n    // being buffered...\n    if (rdr instanceof LineNumberReader)\n        is = (LineNumberReader) rdr;\n    else\n        is = new LineNumberReader(rdr);\n}\n         // no point adding another level of buffering, if already\n\n","name":"ScanStringTok","className":"ScanStringTok","variables":{"rdr":3,"is":2},"constants":{},"javaDoc":"Construct a file scanner by existing Reader","comments":"no point adding another level of buffering if already being buffered  Construct a file scanner by existing Reader ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getLineNumber":1,"readLine":1,"System.err.println":2,"nextElement":3,"System.out.println":1},"annotations":[],"exceptions":["IOException","NoSuchElementException"],"concepts":["Casting","ExceptionHandling"],"types":{"StringTokenizer":1,"String":3},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":7,"BooleanLiteralExpr":1,"NameExpr":36,"StringLiteralExpr":5,"CastExpr":2,"FieldAccessExpr":3,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":8},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":8},"text":"protected void process() {\n    String s = null;\n    try {\n        while ((s = is.readLine()) != null) {\n            StringTokenizer st = new StringTokenizer(s, \"@\", true);\n            String user = (String) st.nextElement();\n            st.nextElement();\n            String host = (String) st.nextElement();\n            System.out.println(\"User name: \" + user + \"; host part: \" + host);\n        // Presumably you would now do something \n        // with the user and host parts...  \n        }\n    } catch (NoSuchElementException ix) {\n        System.err.println(\"Line \" + is.getLineNumber() + \": Invalid input \" + s);\n    } catch (IOException e) {\n        System.err.println(e);\n    }\n}\n","name":"process","className":"ScanStringTok","variables":{"st":4,"s":4,"e":1,"host":2,"is":2,"user":2,"ix":1},"constants":{"\"; host part: \"":1,"\": Invalid input \"":1,"null":2,"\"@\"":1,"\"User name: \"":1,"\"Line \"":1,"true":1},"javaDoc":"","comments":"Presumably you would now do something with the user and host parts ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Reader"],"returnType":"void","methodCalls":{"read":1,"System.out.print":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"void doFile(Reader is) throws IOException {\n    int c;\n    while ((c = is.read()) != -1) {\n        System.out.print((char) c);\n    }\n}\n","name":"doFile","className":"ReadCharsOneAtATime","variables":{"c":3,"is":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":2,"format":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Formatter":1,"Object":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"NameExpr":40,"StringLiteralExpr":4,"FieldAccessExpr":8,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    // The arguments to all these format methods consist of\n    // a format code String and 1 or more arguments.\n    // Each format code consists of the following:\n    // % - code lead-in\n    // N$ - which parameter number (1-based) after the code - OPTIONAL\n    // N - field width\n    // L - format letter (d: decimal(int); f: float; s: general; many more)\n    // For the full(!) story, see javadoc for java.util.Formatter.\n    // Most general (cumbersome) way of proceding.\n    Formatter fmtr = new Formatter();\n    Object result = fmtr.format(\"%1$04d - the year of %2$f\", 1956, Math.PI);\n    System.out.println(result);\n    // Shorter way using static String.format(), and\n    // default parameter numbering.\n    Object stringResult = String.format(\"%04d - the year of %f\", 1956, Math.PI);\n    System.out.println(stringResult);\n    // A shorter way using PrintStream/PrintWriter.format, more in line with\n    // other languages. But this way you must provide the newline delimiter \n    // using %n (do NOT use \\n as that is platform-dependent!).\n    System.out.printf(\"%04d - the year of %f%n\", 1956, Math.PI);\n    // Format doubles with more control\n    System.out.printf(\"PI is approximately %4.2f%n\", Math.PI);\n}\n","name":"main","className":"FormatterDemo","variables":{"result":1,"stringResult":1,"fmtr":2,"String":1},"constants":{"\"%1$04d - the year of %2$f\"":1,"\"%04d - the year of %f%n\"":1,"\"PI is approximately %4.2f%n\"":1,"\"%04d - the year of %f\"":1,"1956":3},"javaDoc":"","comments":"The arguments to all these format methods consist of a format code String and 1 or more arguments Each format code consists of the following: % - code lead-in N$ - which parameter number (1-based) after the code - OPTIONAL N - field width L - format letter (d: decimal(int); f: float; s: general; many more) For the full(!) story see javadoc for java util Formatter Shorter way using static String format() and A shorter way using PrintStream/PrintWriter format more in line with other languages But this way you must provide the newline delimiter Most general (cumbersome) way of proceding default parameter numbering using %n (do NOT use \\n as that is platform-dependent!) Format doubles with more control ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":2,"getTime":1,"getInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Date":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    // Format number as dates e.g., 2014-06-28\n    System.out.printf(\"%4d-%02d-%2d%n\", 2014, 6, 28);\n    // Format fields directly from a Date object: multiple fields from \"1$\"\n    // (hard-coded formatting for Date not advisable; see I18N chapter)\n    Date today = Calendar.getInstance().getTime();\n    // Might print e.g., July 4, 2015:\n    System.out.printf(\"Today is %1$tB %1$td, %1$tY%n\", today);\n}\n","name":"main","className":"FormatterDates","variables":{"today":1,"Calendar":1},"constants":{"\"%4d-%02d-%2d%n\"":1,"2014":1,"6":1,"28":1,"\"Today is %1$tB %1$td, %1$tY%n\"":1},"javaDoc":"","comments":"Format fields directly from a Date object: multiple fields from \"1$\" Format number as dates e g 2014-06-28 (hard-coded formatting for Date not advisable; see I18N chapter) Might print e g July 4 2015: ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"readLine":1,"System.err.println":2,"System.out.println":1},"annotations":[],"exceptions":["NumberFormatException","IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":30,"StringLiteralExpr":3,"FieldAccessExpr":4,"AssignExpr":2,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public static void main(String[] ap) {\n    String line = null;\n    int val = 0;\n    try {\n        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n        line = is.readLine();\n        val = Integer.parseInt(line);\n        System.out.println(\"I read this number: \" + val);\n    } catch (NumberFormatException ex) {\n        System.err.println(\"Not a valid number: \" + line);\n    } catch (IOException e) {\n        System.err.println(\"Unexpected IO ERROR: \" + e);\n    }\n}\n","name":"main","className":"ReadStdinInt","variables":{"val":3,"Integer":1,"ex":1,"e":2,"line":3,"is":2},"constants":{"0":1,"null":1,"\"I read this number: \"":1,"\"Unexpected IO ERROR: \"":1,"\"Not a valid number: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setMode":1,"endsWith":2,"unZip":1,"System.err.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"UnZip":1,"String":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":38,"StringLiteralExpr":5,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"ContinueStmt":1,"IfStmt":2,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":6},"text":"/** Simple main program, construct an UnZipper, process each\n     * .ZIP file from argv[] through that object.\n     */\npublic static void main(String[] argv) {\n    UnZip u = new UnZip();\n    for (int i = 0; i < argv.length; i++) {\n        if (\"-x\".equals(argv[i])) {\n            u.setMode(Mode.EXTRACT);\n            continue;\n        }\n        String candidate = argv[i];\n        // System.err.println(\"Trying path \" + candidate);\n        if (candidate.endsWith(\".zip\") || candidate.endsWith(\".jar\"))\n            u.unZip(candidate);\n        else\n            System.err.println(\"Not a zip file? \" + candidate);\n    }\n    System.err.println(\"All done!\");\n}\n","name":"main","className":"UnZip","variables":{"candidate":4,"u":3,"i":5,"argv":2},"constants":{"0":1,"\"Not a zip file? \"":1,"\"-x\"":1,"\"All done!\"":1,"\".zip\"":1,"\".jar\"":1},"javaDoc":"Simple main program construct an UnZipper process each ZIP file from argv[] through that object","comments":"System err println(\"Trying path \" + candidate);  Simple main program, construct an UnZipper, process each\n     * .ZIP file from argv[] through that object.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Mode"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the Mode (list, extract). */\nprotected void setMode(Mode m) {\n    mode = m;\n}\n","name":"setMode","className":"UnZip","variables":{"mode":1,"m":1},"constants":{},"javaDoc":"Set the Mode (list extract)","comments":" Set the Mode (list, extract). ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"entries":1,"hasMoreElements":1,"System.err.println":1,"getFile":1,"nextElement":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Enumeration":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":20,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":2,"MethodCallExpr":5},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** For a given Zip file, process each entry. */\npublic void unZip(String fileName) {\n    dirsMade = new TreeSet<String>();\n    try {\n        zippy = new ZipFile(fileName);\n        Enumeration all = zippy.entries();\n        while (all.hasMoreElements()) {\n            getFile((ZipEntry) all.nextElement());\n        }\n    } catch (IOException err) {\n        System.err.println(\"IO Error: \" + err);\n        return;\n    }\n}\n","name":"unZip","className":"UnZip","variables":{"all":3,"zippy":2,"fileName":1,"err":2,"dirsMade":1},"constants":{"\"IO Error: \"":1},"javaDoc":"For a given Zip file process each entry","comments":" For a given Zip file, process each entry. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ZipEntry"],"returnType":"void","methodCalls":{"add":1,"getName":1,"read":1,"getInputStream":1,"substring":2,"lastIndexOf":1,"contains":1,"mkdirs":1,"endsWith":1,"exists":1,"System.err.println":2,"write":1,"close":2,"isDirectory":2,"startsWith":1,"System.out.println":4},"annotations":[],"exceptions":["IllegalStateException","IOException"],"concepts":[],"types":{"InputStream":1,"FileOutputStream":1,"String":2,"File":1,"int":2},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":3,"VariableDeclarationExpr":7,"BinaryExpr":10,"NameExpr":104,"StringLiteralExpr":10,"CharLiteralExpr":1,"UnaryExpr":4,"AssignExpr":3,"BooleanLiteralExpr":1,"FieldAccessExpr":6,"EnclosedExpr":2,"MethodCallExpr":23},"statements":{"SwitchStmt":1,"IfStmt":8,"WhileStmt":1,"BreakStmt":2,"BlockStmt":8,"SwitchEntryStmt":3,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":19},"text":"/** Process one file from the zip, given its name.\n     * Either print the name, or create the file on disk.\n     */\nprotected void getFile(ZipEntry e) throws IOException {\n    String zipName = e.getName();\n    switch(mode) {\n        case EXTRACT:\n            if (zipName.startsWith(\"/\")) {\n                if (!warnedMkDir)\n                    System.out.println(\"Ignoring absolute paths\");\n                warnedMkDir = true;\n                zipName = zipName.substring(1);\n            }\n            // any directory entries, or put them in the wrong place.\n            if (zipName.endsWith(\"/\")) {\n                return;\n            }\n            // Else must be a file; open the file for output\n            // Get the directory part.\n            int ix = zipName.lastIndexOf('/');\n            if (ix > 0) {\n                String dirName = zipName.substring(0, ix);\n                if (!dirsMade.contains(dirName)) {\n                    File d = new File(dirName);\n                    // If it already exists as a dir, don't do anything\n                    if (!(d.exists() && d.isDirectory())) {\n                        // Try to create the directory, warn if it fails\n                        System.out.println(\"Creating Directory: \" + dirName);\n                        if (!d.mkdirs()) {\n                            System.err.println(\"Warning: unable to mkdir \" + dirName);\n                        }\n                        dirsMade.add(dirName);\n                    }\n                }\n            }\n            System.err.println(\"Creating \" + zipName);\n            FileOutputStream os = new FileOutputStream(zipName);\n            InputStream is = zippy.getInputStream(e);\n            int n = 0;\n            while ((n = is.read(b)) > 0) os.write(b, 0, n);\n            is.close();\n            os.close();\n            break;\n        case LIST:\n            // Not extracting, just list\n            if (e.isDirectory()) {\n                System.out.println(\"Directory \" + zipName);\n            } else {\n                System.out.println(\"File \" + zipName);\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"mode value (\" + mode + \") bad\");\n    }\n}\n             // if a directory, just return. We mkdir for every file,\n\n             // since some widely used Zip creators don't put out\n\n","name":"getFile","className":"UnZip","variables":{"zippy":1,"d":4,"os":3,"e":2,"is":3,"warnedMkDir":2,"n":2,"ix":2,"mode":2,"zipName":11,"LIST":1,"dirsMade":2,"EXTRACT":1,"dirName":4},"constants":{"\"File \"":1,"\") bad\"":1,"\"Creating \"":1,"0":5,"\"mode value (\"":1,"1":1,"\"Warning: unable to mkdir \"":1,"\"/\"":2,"true":1,"\"Creating Directory: \"":1,"\"Ignoring absolute paths\"":1,"\"Directory \"":1,"'/'":1},"javaDoc":"Process one file from the zip given its name Either print the name or create the file on disk","comments":"if a directory just return We mkdir for every file since some widely used Zip creators don't put out Else must be a file; open the file for output any directory entries or put them in the wrong place Get the directory part If it already exists as a dir don't do anything Try to create the directory warn if it fails Not extracting just list  Process one file from the zip, given its name.\n     * Either print the name, or create the file on disk.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readLine":1,"close":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":22,"StringLiteralExpr":1,"FieldAccessExpr":3,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"public static void main(String[] av) {\n    try {\n        BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n        String inputLine;\n        while ((inputLine = is.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        is.close();\n    } catch (IOException e) {\n        System.out.println(\"IOException: \" + e);\n    }\n}\n","name":"main","className":"CatStdin","variables":{"inputLine":2,"e":2,"is":3},"constants":{"null":1,"\"IOException: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BadNewline":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    BadNewline jack = new BadNewline(\"Jack Adolphus Schmidt, III\");\n    System.out.println(jack);\n}\n","name":"main","className":"BadNewline","variables":{"jack":1},"constants":{"\"Jack Adolphus Schmidt, III\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{"hashCode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * DON'T DO THIS. THIS IS BAD CODE.\n     */\npublic String toString() {\n    return \"BadNewlineDemo@\" + hashCode() + \"\\n\" + myName;\n}\n","name":"toString","className":"BadNewline","variables":{"myName":1},"constants":{"\"BadNewlineDemo@\"":1,"\"\\n\"":1},"javaDoc":"DON'T DO THIS THIS IS BAD CODE","comments":"\n     * DON'T DO THIS. THIS IS BAD CODE.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"BadNewline","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/* Constructor */\npublic BadNewline(String s) {\n    myName = s;\n}\n","name":"BadNewline","className":"BadNewline","variables":{"s":1,"myName":1},"constants":{},"javaDoc":"","comments":" Constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readLine":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"GZIPInputStream":1,"InputStreamReader":1,"BufferedReader":1,"String":2,"FileInputStream":1},"expressions":{"ObjectCreationExpr":4,"NullLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":14,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] argv) throws IOException {\n    String FILENAME = \"file.txt.gz\";\n    // Since there are 4 constructor calls here, I wrote them out in full.\n    // In real life you would probably nest these constructor calls.\n    FileInputStream fin = new FileInputStream(FILENAME);\n    GZIPInputStream gzis = new GZIPInputStream(fin);\n    InputStreamReader xover = new InputStreamReader(gzis);\n    BufferedReader is = new BufferedReader(xover);\n    String line;\n    // GZipInputStream \"gunzip\"s the data from the FileInputStream.\n    while ((line = is.readLine()) != null) System.out.println(\"Read: \" + line);\n}\n         // Now read lines of text: the BufferedReader puts them in lines,\n\n         // the InputStreamReader does Unicode conversion, and the\n\n","name":"main","className":"ReadGZIP","variables":{"xover":2,"line":3,"fin":2,"is":2,"FILENAME":2,"gzis":2},"constants":{"\"Read: \"":1,"null":1,"\"file.txt.gz\"":1},"javaDoc":"","comments":"Since there are 4 constructor calls here I wrote them out in full Now read lines of text: the BufferedReader puts them in lines the InputStreamReader does Unicode conversion and the In real life you would probably nest these constructor calls GZipInputStream \"gunzip\"s the data from the FileInputStream ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"console":1,"toUpperCase":1,"readLine":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    String name = System.console().readLine(\"What is your name?\");\n    System.out.println(\"Hello, \" + name.toUpperCase());\n}\n","name":"main","className":"ConsoleRead","variables":{"name":2,"System":1},"constants":{"\"What is your name?\"":1,"\"Hello, \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","LineNumberReader","PrintStream"],"returnType":"void","methodCalls":{"getLineNumber":2,"print":2,"println":1,"trim":2,"flush":1,"equals":2,"readLine":1,"System.err.println":3,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":11,"NameExpr":71,"StringLiteralExpr":6,"CharLiteralExpr":2,"UnaryExpr":2,"AssignExpr":3,"NullLiteralExpr":1,"BooleanLiteralExpr":2,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":16},"statements":{"IfStmt":7,"WhileStmt":1,"TryStmt":1,"BlockStmt":7,"ExpressionStmt":14},"text":"/** Get Marked parts of one file, given an open LineNumberReader.\n     * This is the main operation of this class, and can be used\n     * inside other programs or from the main() wrapper.\n     */\npublic void process(String fileName, LineNumberReader is, PrintStream out) {\n    int nLines = 0;\n    try {\n        String inputLine;\n        while ((inputLine = is.readLine()) != null) {\n            if (inputLine.trim().equals(START_MARK)) {\n                if (printing)\n                    // These go to stderr, so you can redirect the output\n                    System.err.println(\"ERROR: START INSIDE START, \" + fileName + ':' + is.getLineNumber());\n                printing = true;\n            } else if (inputLine.trim().equals(END_MARK)) {\n                if (!printing)\n                    System.err.println(\"ERROR: STOP WHILE STOPPED, \" + fileName + ':' + is.getLineNumber());\n                printing = false;\n            } else if (printing) {\n                if (number) {\n                    out.print(nLines);\n                    out.print(\": \");\n                }\n                out.println(inputLine);\n                ++nLines;\n            }\n        }\n        is.close();\n        // Must not close - caller may still need it.\n        out.flush();\n        if (nLines == 0)\n            System.err.println(\"ERROR: No marks in \" + fileName + \"; no output generated!\");\n    } catch (IOException e) {\n        System.out.println(\"IOException: \" + e);\n    }\n}\n","name":"process","className":"GetMark","variables":{"number":1,"fileName":3,"nLines":3,"inputLine":4,"e":2,"is":4,"printing":5,"out":4},"constants":{"0":2,"\"ERROR: STOP WHILE STOPPED, \"":1,"null":1,"':'":2,"true":1,"false":1,"\": \"":1,"\"IOException: \"":1,"\"ERROR: START INSIDE START, \"":1,"\"ERROR: No marks in \"":1,"\"; no output generated!\"":1},"javaDoc":"Get Marked parts of one file given an open LineNumberReader This is the main operation of this class and can be used inside other programs or from the main() wrapper","comments":"These go to stderr so you can redirect the output Must not close - caller may still need it  Get Marked parts of one file, given an open LineNumberReader.\n     * This is the main operation of this class, and can be used\n     * inside other programs or from the main() wrapper.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"process":2,"System.err.println":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["ExceptionHandling"],"types":{"PrintStream":1,"GetMark":1,"int":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":32,"StringLiteralExpr":1,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"/** This simple main program looks after filenames and\n     * opening files and such like for you, when GetMark is being\n     * used standalone.\n     * XXX TODO options parsing, allow include/exclude, number, etc.\n     * to be set from the command line.\n     */\npublic static void main(String[] av) {\n    GetMark o = new GetMark();\n    PrintStream pw = new PrintStream(System.out);\n    if (av.length == 0) {\n        o.process(\"standard input\", new LineNumberReader(new InputStreamReader(System.in)), pw);\n    } else {\n        for (int i = 0; i < av.length; i++) try {\n            o.process(av[i], new LineNumberReader(new FileReader(av[i])), pw);\n        } catch (FileNotFoundException e) {\n            System.err.println(e);\n        }\n    }\n}\n","name":"main","className":"GetMark","variables":{"av":2,"e":1,"pw":1,"i":5,"o":3},"constants":{"0":2,"\"standard input\"":1},"javaDoc":"This simple main program looks after filenames and opening files and such like for you when GetMark is being used standalone XXX TODO options parsing allow include/exclude number etc to be set from the command line","comments":" This simple main program looks after filenames and\n     * opening files and such like for you, when GetMark is being\n     * used standalone.\n     * XXX TODO options parsing, allow include/exclude, number, etc.\n     * to be set from the command line.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"console":1,"java.util.Arrays.fill":1,"readPassword":1,"System.out.println":1},"annotations":[],"exceptions":["RuntimeException"],"concepts":["ExceptionHandling"],"types":{"Console":1,"char[]":1},"expressions":{"NullLiteralExpr":3,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":23,"StringLiteralExpr":3,"FieldAccessExpr":3,"CharLiteralExpr":1,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":5,"TryStmt":1,"ThrowStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    Console cons;\n    if ((cons = System.console()) != null) {\n        char[] passwd = null;\n        try {\n            passwd = cons.readPassword(\"Password:\");\n            // In real life you would send the password into authentication code\n            System.out.println(\"Your password was: \" + new String(passwd));\n        } finally {\n            // Shred this in-memory copy for security reasons\n            if (passwd != null) {\n                java.util.Arrays.fill(passwd, ' ');\n            }\n        }\n    } else {\n        throw new RuntimeException(\"No console, can't get password\");\n    }\n}\n","name":"main","className":"ReadPassword","variables":{"passwd":4,"System":1,"cons":3},"constants":{"\"Your password was: \"":1,"\"Password:\"":1,"null":3,"' '":1,"\"No console, can't get password\"":1},"javaDoc":"","comments":"In real life you would send the password into authentication code Shred this in-memory copy for security reasons ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"read":1,"System.out.print":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"BufferedReader":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":13,"CastExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] argv) throws IOException {\n    // BEGIN main\n    BufferedReader is = new BufferedReader(new InputStreamReader(System.in));\n    int c;\n    while ((c = is.read()) != -1) {\n        System.out.print((char) c);\n    }\n// END main\n}\n","name":"main","className":"CharMode","variables":{"c":3,"is":2},"constants":{"1":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setErr":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int[]":1,"String":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":11,"FieldAccessExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] argv) throws IOException {\n    // BEGIN main\n    String LOGFILENAME = \"error.log\";\n    System.setErr(new PrintStream(new FileOutputStream(LOGFILENAME)));\n    System.out.println(\"Please look for errors in \" + LOGFILENAME);\n    // Now assume this is somebody else's code; you'll see it \n    //   writing to stderr...\n    int[] a = new int[5];\n    // here comes an ArrayIndexOutOfBoundsException\n    a[10] = 0;\n// END main\n}\n","name":"main","className":"Redirect","variables":{"a":2,"System":1,"LOGFILENAME":3},"constants":{"0":1,"5":1,"\"Please look for errors in \"":1,"\"error.log\"":1,"10":1},"javaDoc":"","comments":"Now assume this is somebody else's code; you'll see it END main BEGIN main writing to stderr here comes an ArrayIndexOutOfBoundsException ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.in.read":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":18,"StringLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":3,"AssignExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/** Simple test case */\npublic static void main(String[] ap) {\n    // BEGIN main\n    int b = 0;\n    try {\n        b = System.in.read();\n        System.out.println(\"Read this data: \" + (char) b);\n    } catch (Exception e) {\n        System.out.println(\"Caught \" + e);\n    }\n// END main\n}\n","name":"main","className":"ReadStdin","variables":{"b":3,"e":2},"constants":{"0":1,"\"Read this data: \"":1,"\"Caught \"":1},"javaDoc":"Simple test case","comments":"END main BEGIN main  Simple test case ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Line number of first line in current (possibly continued) line */\npublic int getLineNumber() {\n    return firstLineNumber;\n}\n","name":"getLineNumber","className":"IndentContLineReader","variables":{"firstLineNumber":1},"constants":{},"javaDoc":"Line number of first line in current (possibly continued) line","comments":" Line number of first line in current (possibly continued) line ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"length":1,"toString":2,"isWhitespace":1,"charAt":1,"append":1,"readPhysicalLine":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"StringBuffer":1,"String":2},"expressions":{"NullLiteralExpr":4,"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"SuperExpr":1,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":38,"UnaryExpr":1,"AssignExpr":5,"MethodCallExpr":9},"statements":{"IfStmt":4,"WhileStmt":1,"BreakStmt":1,"BlockStmt":6,"ReturnStmt":3,"ExpressionStmt":9},"text":"/** Read one (possibly continued) line, stripping out the '\\'s that\n     * mark the end of all but the last.\n     */\npublic String readLine() throws IOException {\n    String s;\n    // number in firstLineNumber.\n    if (prevLine != null) {\n        s = prevLine;\n        prevLine = null;\n    } else {\n        s = readPhysicalLine();\n    }\n    // save the line number of the first line.\n    firstLineNumber = super.getLineNumber();\n    // we are finished, so return it.\n    if (!doContinue || s == null)\n        return s;\n    // Otherwise, start building a stringbuffer\n    StringBuffer sb = new StringBuffer(s);\n    // Read as many continued lines as there are, if any.\n    while (true) {\n        String nextPart = readPhysicalLine();\n        if (nextPart == null) {\n            // Return what we have so far.\n            return sb.toString();\n        }\n        // If the next line begins with space, it's continuation\n        if (nextPart.length() > 0 && Character.isWhitespace(nextPart.charAt(0))) {\n            // and add line.\n            sb.append(nextPart);\n        } else {\n            // else we just read too far, so put in \"pushback\" holder\n            prevLine = nextPart;\n            break;\n         // If we saved a previous line, start with it. Else,\n\n         // read the first line of possible continuation. \n\n         // If non-null, put it into the StringBuffer and its line \n\n        }\n    }\n    // return what's left\n    return sb.toString();\n}\n         // Now we have one line. If we are not in continuation\n\n         // mode, or if a previous readPhysicalLine() returned null,\n\n                 // Egad! EOF within continued line.\n\n","name":"readLine","className":"IndentContLineReader","variables":{"prevLine":4,"nextPart":5,"s":6,"firstLineNumber":1,"Character":1,"doContinue":1,"sb":4},"constants":{"0":2,"null":4,"true":1},"javaDoc":"Read one (possibly continued) line stripping out the '\\'s that mark the end of all but the last","comments":"If we saved a previous line start with it Else read the first line of possible continuation If non-null put it into the StringBuffer and its line Now we have one line If we are not in continuation mode or if a previous readPhysicalLine() returned null number in firstLineNumber save the line number of the first line we are finished so return it Otherwise start building a stringbuffer Read as many continued lines as there are if any Egad! EOF within continued line Return what we have so far If the next line begins with space it's continuation and add line else we just read too far so put in \"pushback\" holder return what's left  Read one (possibly continued) line, stripping out the '\\'s that\n     * mark the end of all but the last.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader"],"returnType":"IndentContLineReader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct an IndentContLineReader with the default buffer size. */\npublic IndentContLineReader(Reader in) {\n    super(in);\n}\n","name":"IndentContLineReader","className":"IndentContLineReader","variables":{"in":1},"constants":{},"javaDoc":"Construct an IndentContLineReader with the default buffer size","comments":" Construct an IndentContLineReader with the default buffer size. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader","int"],"returnType":"IndentContLineReader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct an IndentContLineReader using the given buffer size. */\npublic IndentContLineReader(Reader in, int sz) {\n    super(in, sz);\n}\n","name":"IndentContLineReader","className":"IndentContLineReader","variables":{"in":1,"sz":1},"constants":{},"javaDoc":"Construct an IndentContLineReader using the given buffer size","comments":" Construct an IndentContLineReader using the given buffer size. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Document","PrintStream"],"returnType":"GenMIF","methodCalls":{"add":1,"setOut":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"NameExpr":14,"StringLiteralExpr":1,"AssignExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":6},"text":"/** Construct a converter object */\nGenMIF(Document doc, PrintStream pw) {\n    theDocument = doc;\n    msg = new PrintStream(pw);\n    smsg = new StyledPrintStream(msg);\n    // Reassign System.out to go there as well, so when we\n    // run other main classes, their output gets grabbed.\n    System.setOut(smsg);\n    indents = new ArrayList<>();\n    indents.add(\"\");\n}\n","name":"GenMIF","className":"GenMIF","variables":{"msg":2,"theDocument":1,"indents":2,"pw":1,"doc":1,"smsg":1,"System":1},"constants":{"\"\"":1},"javaDoc":"Construct a converter object","comments":"Reassign System out to go there as well so when we run other main classes their output gets grabbed  Construct a converter object ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"print":1,"size":1,"get":1,"toString":1,"append":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":27,"CharLiteralExpr":2,"ConditionalExpr":1,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"protected void indent() {\n    if (indent > indents.size()) {\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < indent; i++) {\n            sb.append(' ');\n            sb.append(' ');\n        }\n        indents.add(sb.toString());\n    }\n    msg.print(indents.get(indent > 0 ? indent - 1 : 0));\n}\n","name":"indent","className":"GenMIF","variables":{"msg":1,"indents":3,"indent":4,"i":3,"sb":4},"constants":{"0":3,"1":1,"' '":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":1,"indent":1,"push":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":11,"CharLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"protected void startTag(String tag) {\n    ++indent;\n    indent();\n    msg.println('<' + tag);\n    tagStack.push(tag);\n}\n","name":"startTag","className":"GenMIF","variables":{"msg":1,"tagStack":1,"indent":1,"tag":1},"constants":{"'<'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"pop":1,"println":1,"indent":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":9,"StringLiteralExpr":1,"CharLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"protected void endTag() {\n    indent();\n    msg.println('>' + \" # end of \" + tagStack.pop());\n    indent--;\n}\n","name":"endTag","className":"GenMIF","variables":{"msg":1,"tagStack":1,"indent":1},"constants":{"'>'":1,"\" # end of \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"println":1,"doRecursive":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Convert all the nodes in the current document. */\npublic void convertAll() {\n    msg.println(\"<MIFFile 3.00 -- MIF produced by XmlForm>\");\n    // start recursing the document\n    doRecursive(theDocument);\n}\n","name":"convertAll","className":"GenMIF","variables":{"msg":1},"constants":{"\"<MIFFile 3.00 -- MIF produced by XmlForm>\"":1},"javaDoc":"Convert all the nodes in the current document","comments":"start recursing the document  Convert all the nodes in the current document. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"item":1,"doNode":1,"getLength":1,"doRecursive":1,"getChildNodes":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"NodeList":1,"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":20,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"protected void doRecursive(Node n) {\n    NodeList kids;\n    if (n == null)\n        return;\n    doNode(n);\n    kids = n.getChildNodes();\n    int nkids = kids.getLength();\n    for (int i = 0; i < nkids; i++) {\n        doRecursive(kids.item(i));\n    }\n}\n","name":"doRecursive","className":"GenMIF","variables":{"i":3,"nkids":2,"n":2,"kids":4},"constants":{"0":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"getNodeValue":1,"getClass":1,"doElement":1,"getNodeType":2,"toString":1,"doCData":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":7,"NameExpr":32,"CastExpr":2,"StringLiteralExpr":2,"FieldAccessExpr":3,"CharLiteralExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":2,"ExpressionStmt":3},"text":"protected void doNode(Node p) {\n    if (p.getNodeType() == Node.ELEMENT_NODE)\n        doElement((Element) p);\n    else if (p.getNodeType() == Node.TEXT_NODE)\n        doCData((org.w3c.dom.CharacterData) p);\n    else\n        System.err.println(\"IGNORING non-Element: \" + p.getClass() + ':' + p.toString() + \"\\n\" + p.getNodeValue());\n}\n","name":"doNode","className":"GenMIF","variables":{"p":7},"constants":{"':'":1,"\"IGNORING non-Element: \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Element"],"returnType":"void","methodCalls":{"doChapter":1,"getClass":1,"doRun":1,"hashCode":1,"toLowerCase":1,"equals":14,"getTagName":1,"System.err.println":5,"doParagraph":5,"doPre":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":6,"NameExpr":109,"StringLiteralExpr":24,"FieldAccessExpr":5,"CharLiteralExpr":3,"MethodCallExpr":33},"statements":{"IfStmt":14,"BlockStmt":14,"ExpressionStmt":16},"text":"protected void doElement(Element p) {\n    String tag = p.getTagName().toLowerCase();\n    //\n    if (tag.equals(\"head\")) {\n        System.err.println(\">>>>Start HEAD\");\n    } else if (tag.equals(\"body\")) {\n        System.err.println(\">>>>Start BODY\");\n    } else if (tag.equals(\"chapter\")) {\n        doChapter(p);\n    //\n    // PARAGRAPH TAGS\n    // This is the application-specific bit of code.\n    // SHOULD BE MAP RULES, NOT HARD-CODED.\n    //\n    } else if (tag.equals(\"title\")) {\n        doParagraph(\"ChapterTitle\", p);\n    } else if (tag.equals(\"simplesect\")) {\n        doParagraph(\"HeadA\", p);\n    } else if (tag.equals(\"sect1\")) {\n        doParagraph(\"HeadA\", p);\n    } else if (tag.equals(\"para\")) {\n        doParagraph(\"Body\", p);\n    } else if (tag.equals(\"sect2\")) {\n        doParagraph(\"HeadB\", p);\n    } else if (tag.equals(\"programlisting\")) {\n        doPre(p);\n    } else if (tag.equals(\"graphic\")) {\n        doPre(p);\n    } else if (tag.equals(\"runoutput\")) {\n        doRun(p);\n    } else if (tag.equals(\"figure\")) {\n        doPre(p);\n    //\n    // STYLE TAGS\n    //\n    } else if (tag.equals(\"kb\")) {\n        // keyboard, map to code\n        System.err.println(\"<KB> handler not written yet\");\n    } else if (tag.equals(\"bt\")) {\n        // book title, map to Citation\n        System.err.println(\"<BT> handler not written yet\");\n    } else\n        System.err.println(\"IGNORING UNHANDLED TAG \" + tag + '(' + p.getClass() + '@' + p.hashCode() + ')');\n}\n         // STRUCTURE TAGS\n\n","name":"doElement","className":"GenMIF","variables":{"p":3,"tag":16},"constants":{"\"body\"":1,"')'":1,"\"<BT> handler not written yet\"":1,"\"graphic\"":1,"\"head\"":1,"\"chapter\"":1,"\"HeadA\"":2,"\"IGNORING UNHANDLED TAG \"":1,"'@'":1,"\">>>>Start BODY\"":1,"\"runoutput\"":1,"\"kb\"":1,"\"sect2\"":1,"\"ChapterTitle\"":1,"\"<KB> handler not written yet\"":1,"\">>>>Start HEAD\"":1,"\"Body\"":1,"'('":1,"\"title\"":1,"\"figure\"":1,"\"HeadB\"":1,"\"simplesect\"":1,"\"programlisting\"":1,"\"sect1\"":1,"\"para\"":1,"\"bt\"":1},"javaDoc":"","comments":" STRUCTURE TAGS   PARAGRAPH TAGS This is the application-specific bit of code SHOULD BE MAP RULES NOT HARD-CODED   STYLE TAGS  keyboard map to code book title map to Citation ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Element"],"returnType":"void","methodCalls":{"println":1,"makeUpParagraph":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"protected void doChapter(Element p) {\n    msg.println(\"# START OF CHAPTER\");\n    makeUpParagraph(\"ChapterStart\", null);\n}\n","name":"doChapter","className":"GenMIF","variables":{"msg":1},"constants":{"null":1,"\"# START OF CHAPTER\"":1,"\"ChapterStart\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":1,"startTag":2,"indent":1,"endTag":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":12,"StringLiteralExpr":4,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"protected void pgfTag(String s) {\n    startTag(\"Para\");\n    startTag(\"Pgf\");\n    indent();\n    msg.println(\"<PgfTag `\" + s + \"'>\");\n    // end of Pgf, not of Para!\n    endTag();\n}\n","name":"pgfTag","className":"GenMIF","variables":{"msg":1,"s":1},"constants":{"\"Pgf\"":1,"\"<PgfTag `\"":1,"\"Para\"":1,"\"'>\"":1},"javaDoc":"","comments":"end of Pgf not of Para! ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","Element"],"returnType":"void","methodCalls":{"pgfTag":1,"indent":1,"endTag":1,"doChildren":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/** Generate a paragraph from the input */\nprotected void doParagraph(String tag, Element p) {\n    indent();\n    pgfTag(tag);\n    doChildren(p);\n    endTag();\n}\n","name":"doParagraph","className":"GenMIF","variables":{},"constants":{},"javaDoc":"Generate a paragraph from the input","comments":" Generate a paragraph from the input ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"pgfTag":1,"indent":1,"endTag":1,"pgfString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":11,"MethodCallExpr":4},"statements":{"IfStmt":1,"ExpressionStmt":4},"text":"/** Synthesize a paragraph when we know its content.\n     * content can be null for things like Label paragraphs.\n     */\nprotected void makeUpParagraph(String tag, String contents) {\n    indent();\n    pgfTag(tag);\n    if (contents != null)\n        pgfString(contents);\n    endTag();\n}\n","name":"makeUpParagraph","className":"GenMIF","variables":{"contents":1},"constants":{"null":1},"javaDoc":"Synthesize a paragraph when we know its content content can be null for things like Label paragraphs","comments":" Synthesize a paragraph when we know its content.\n     * content can be null for things like Label paragraphs.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Element"],"returnType":"void","methodCalls":{"getNodeValue":1,"pgfTag":1,"getAttributes":1,"getProperty":1,"indent":1,"makeUpParagraph":2,"endTag":1,"toString":1,"System.err.println":1,"readLine":1,"getNamedItem":1,"pgfString":1},"annotations":[],"exceptions":["IOException","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"NamedNodeMap":1,"Node":1,"String":2,"LineNumberReader":1},"expressions":{"NullLiteralExpr":3,"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"BinaryExpr":7,"NameExpr":44,"StringLiteralExpr":9,"FieldAccessExpr":1,"CharLiteralExpr":1,"EnclosedExpr":2,"MethodCallExpr":13,"AssignExpr":3},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ThrowStmt":2,"ExpressionStmt":13},"text":"/** EXAMPLEs are longer than CODEs, and are not limited by //+ //-\n     * marks, which are therefore not required.\n     * XXX TODO wrap a TABLE around the output.\n     */\nprotected void doExample(Element p) {\n    NamedNodeMap attrs = p.getAttributes();\n    Node href;\n    if ((href = attrs.getNamedItem(\"HREF\")) == null)\n        throw new IllegalArgumentException(\"node \" + p + \"lacks required HREF Attribute\");\n    String fname = href.getNodeValue();\n    System.err.println(\"Making an EXAMPLE out of \" + fname);\n    makeUpParagraph(\"ExampleLabel\", null);\n    makeUpParagraph(\"ExampleTitle\", fname);\n    try {\n        fname = System.getProperty(\"codedir\", \".\") + '/' + fname;\n        LineNumberReader is = new LineNumberReader(new FileReader(fname));\n        String line;\n        while ((line = is.readLine()) != null) {\n            indent();\n            pgfTag(\"Code\");\n            pgfString(line);\n            // end of Para\n            endTag();\n        }\n    } catch (IOException e) {\n        throw new IllegalArgumentException(e.toString());\n    }\n}\n","name":"doExample","className":"GenMIF","variables":{"p":2,"fname":5,"e":2,"line":2,"is":2,"href":3,"System":1,"attrs":2},"constants":{"\"Making an EXAMPLE out of \"":1,"\"node \"":1,"\"ExampleTitle\"":1,"\"HREF\"":1,"null":3,"\"ExampleLabel\"":1,"\"codedir\"":1,"\".\"":1,"\"lacks required HREF Attribute\"":1,"\"Code\"":1,"'/'":1},"javaDoc":"EXAMPLEs are longer than CODEs and are not limited by //+ //- marks which are therefore not required XXX TODO wrap a TABLE around the output","comments":"end of Para  EXAMPLEs are longer than CODEs, and are not limited by //+ //-\n     * marks, which are therefore not required.\n     * XXX TODO wrap a TABLE around the output.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Element"],"returnType":"void","methodCalls":{"getNodeValue":1,"getClass":1,"getAttributes":1,"forName":1,"invoke":1,"getMethod":1,"System.err.println":2,"getNamedItem":1},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"NamedNodeMap":1,"Node":1,"Object":1,"String":1,"String[]":1,"Class<?>[]":1,"Method":1,"Class<?>":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":8,"BinaryExpr":5,"NameExpr":39,"StringLiteralExpr":6,"AssignExpr":1,"NullLiteralExpr":2,"ArrayInitializerExpr":2,"FieldAccessExpr":2,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":11},"text":"/** Run a java class' Main Program and capture the output.\n     */\nprotected void doRun(Element p) {\n    NamedNodeMap attrs = p.getAttributes();\n    Node myClass;\n    if ((myClass = attrs.getNamedItem(\"CLASS\")) == null)\n        throw new IllegalArgumentException(\"node \" + p + \"lacks required CLASS Attribute\");\n    String className = myClass.getNodeValue();\n    try {\n        // First, find the class.\n        Class<?> c = Class.forName(className);\n        // Create a dummy argv to pass it.\n        String[] argv = new String[0];\n        // Create the array of Argument Types\n        Class<?>[] argTypes = { // array is Object!\n        argv.getClass() };\n        // Now find the method\n        Method m = c.getMethod(\"main\", argTypes);\n        // Create the actual argument array\n        Object passedArgv[] = { argv };\n        // Now invoke the method.\n        System.err.println(\"Invoking \" + m + \"...\");\n        m.invoke(null, passedArgv);\n    } catch (Exception e) {\n        System.err.println(e);\n    }\n}\n         // makeUpParagraph(\"Example\", \"Example XX: \" + className);\n\n","name":"doRun","className":"GenMIF","variables":{"p":2,"argTypes":1,"c":2,"e":1,"myClass":3,"className":1,"Class":1,"argv":3,"m":3,"passedArgv":1,"attrs":2},"constants":{"0":1,"\"Invoking \"":1,"\"node \"":1,"\"...\"":1,"null":2,"\"main\"":1,"\"CLASS\"":1,"\"lacks required CLASS Attribute\"":1},"javaDoc":"Run a java class' Main Program and capture the output","comments":"makeUpParagraph(\"Example\" \"Example XX: \" + className); First find the class Create a dummy argv to pass it Create the array of Argument Types array is Object! Now find the method Create the actual argument array Now invoke the method  Run a java class' Main Program and capture the output.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["org.w3c.dom.CharacterData"],"returnType":"void","methodCalls":{"trim":1,"length":1,"getData":1,"pgfString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"MethodCallExpr":4},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"protected void doCData(org.w3c.dom.CharacterData p) {\n    String s = p.getData().trim();\n    // System.err.println(\"doCData: String: \" + s);\n    if (// Sun's parser returns extra 1-space \"Text\"s\n    s.length() == 0)\n        return;\n    pgfString(s);\n}\n","name":"doCData","className":"GenMIF","variables":{"p":1,"s":2},"constants":{"0":1},"javaDoc":"","comments":"System err println(\"doCData: String: \" + s); Sun's parser returns extra 1-space \"Text\"s ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"startTag":1,"indent":1,"endTag":1,"mifString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"protected void pgfString(String s) {\n    indent();\n    startTag(\"ParaLine\");\n    mifString(s);\n    endTag();\n}\n","name":"pgfString","className":"GenMIF","variables":{},"constants":{"\"ParaLine\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Element"],"returnType":"void","methodCalls":{"getNodeValue":1,"process":1,"getAttributes":1,"getProperty":1,"makeUpParagraph":1,"toString":1,"System.err.println":1,"getNamedItem":1},"annotations":[],"exceptions":["IOException","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"NamedNodeMap":1,"Node":1,"String":1,"LineNumberReader":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":7,"NameExpr":35,"StringLiteralExpr":8,"FieldAccessExpr":1,"CharLiteralExpr":1,"EnclosedExpr":1,"MethodCallExpr":8,"AssignExpr":2},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ThrowStmt":2,"ExpressionStmt":8},"text":"/** Code is inserted, but only between / / + and / / - tags */\nprotected void doCode(Element p) {\n    NamedNodeMap attrs = p.getAttributes();\n    Node href;\n    if ((href = attrs.getNamedItem(\"HREF\")) == null)\n        throw new IllegalArgumentException(\"node \" + p + \"lacks required HREF Attribute\");\n    String fname = href.getNodeValue();\n    System.err.println(\"En-CODE-ing \" + fname);\n    makeUpParagraph(\"Code\", \"// \" + fname);\n    try {\n        fname = System.getProperty(\"codedir\", \".\") + '/' + fname;\n        LineNumberReader is = new LineNumberReader(new FileReader(fname));\n        gm.process(fname, is, smsg);\n    } catch (IOException e) {\n        throw new IllegalArgumentException(e.toString());\n    }\n}\n","name":"doCode","className":"GenMIF","variables":{"p":2,"fname":6,"e":2,"gm":1,"is":1,"href":3,"System":1,"attrs":2},"constants":{"\"// \"":1,"\"node \"":1,"\"HREF\"":1,"null":1,"\"codedir\"":1,"\".\"":1,"\"lacks required HREF Attribute\"":1,"\"Code\"":1,"\"En-CODE-ing \"":1,"'/'":1},"javaDoc":"Code is inserted but only between / / + and / / - tags","comments":" Code is inserted, but only between / / + and / / - tags ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Element"],"returnType":"void","methodCalls":{"doParagraph":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"protected void doPre(Element p) {\n    doParagraph(\"Code\", p);\n}\n","name":"doPre","className":"GenMIF","variables":{},"constants":{"\"Code\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Element"],"returnType":"void","methodCalls":{"getClass":1,"item":1,"removeChild":2,"getLength":1,"getNodeType":2,"doCData":1,"doChildren":1,"System.err.println":1,"getChildNodes":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"NodeList":1,"Node":1,"int":2},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":5,"NameExpr":48,"CastExpr":2,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":11},"statements":{"ContinueStmt":1,"SwitchStmt":1,"IfStmt":1,"BreakStmt":3,"BlockStmt":2,"SwitchEntryStmt":3,"ForStmt":1,"ExpressionStmt":8},"text":"protected void doChildren(Element p) {\n    NodeList nodes = p.getChildNodes();\n    int numElem = nodes.getLength();\n    // System.err.println(\"Element has \" + numElem + \" children\");\n    for (int i = 0; i < numElem; i++) {\n        Node n = nodes.item(i);\n        if (n == null) {\n            continue;\n        }\n        // System.err.println(\"NODE \" + n.getNodeType());\n        switch(n.getNodeType()) {\n            case Node.TEXT_NODE:\n                // System.err.println(\"\\tCDATA: \" + n.getNodeValue());\n                doCData((CharacterData) n);\n                p.removeChild(n);\n                break;\n            case Node.ELEMENT_NODE:\n                // System.err.println(\"\\tELEMENT<\" + n.getNodeName() + \">\");\n                doChildren((Element) n);\n                p.removeChild(n);\n                break;\n            default:\n                System.err.println(\"Warning: unhandled child node \" + n.getNodeType() + \": \" + n.getClass());\n                break;\n        }\n    }\n}\n","name":"doChildren","className":"GenMIF","variables":{"p":3,"numElem":2,"nodes":3,"i":3,"n":7},"constants":{"0":1,"null":1,"\": \"":1,"\"Warning: unhandled child node \"":1},"javaDoc":"","comments":"System err println(\"Element has \" + numElem + \" children\"); System err println(\"NODE \" + n getNodeType()); System err println(\"\\tCDATA: \" + n getNodeValue()); System err println(\"\\tELEMENT<\" + n getNodeName() + \">\"); ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":1,"indent":1,"length":2,"toString":1,"append":14,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"char":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":64,"StringLiteralExpr":6,"CharLiteralExpr":14,"UnaryExpr":1,"MethodCallExpr":20},"statements":{"SwitchStmt":1,"BreakStmt":7,"BlockStmt":1,"SwitchEntryStmt":8,"ForStmt":1,"ExpressionStmt":18},"text":"/** Do the minumum needed to make \"line\" a valid MIF string. */\nprotected void mifString(String line) {\n    // Make new, big enough for translations\n    StringBuffer b = new StringBuffer(line.length() * 2);\n    b.append('<');\n    // maybe parameterize?\n    b.append(\"String\");\n    b.append(' ');\n    b.append('`');\n    // Process each character.\n    for (int i = 0; i < line.length(); i++) {\n        char c = line.charAt(i);\n        switch(c) {\n            case '\\\\':\n                b.append(\"\\\\\");\n                break;\n            case '\\t':\n                b.append(\"\\\\t\");\n                break;\n            case '\\'':\n                b.append(\"\\\\xd5 \");\n                break;\n            case '<':\n                b.append(\"\\\\<\");\n                break;\n            case '>':\n                b.append(\"\\\\>\");\n                break;\n            case '\\r':\n            case '\\n':\n                b.append(' ');\n                break;\n            default:\n                b.append(c);\n                break;\n        }\n    }\n    b.append(' ');\n    b.append('\\'');\n    b.append('>');\n    indent();\n    msg.println(b.toString());\n}\n","name":"mifString","className":"GenMIF","variables":{"msg":1,"b":16,"c":2,"line":3,"i":3},"constants":{"\"\\\\<\"":1,"\"\\\\xd5 \"":1,"'\\''":2,"\"\\\\>\"":1,"' '":3,"'`'":1,"0":1,"\"\\\\\"":1,"'>'":2,"2":1,"'<'":2,"'\\\\'":1,"\"String\"":1,"'\\r'":1,"\"\\\\t\"":1,"'\\t'":1,"'\\n'":1},"javaDoc":"Do the minumum needed to make \"line\" a valid MIF string","comments":"Make new big enough for translations maybe parameterize? Process each character  Do the minumum needed to make \"line\" a valid MIF string. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["PrintStream"],"returnType":"StyledPrintStream","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public StyledPrintStream(PrintStream p) {\n    super(p, true);\n}\n","name":"StyledPrintStream","className":"StyledPrintStream","variables":{"p":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"pgfTag":1,"indent":1,"endTag":1,"pgfString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void println(String s) {\n    indent();\n    pgfTag(\"Code\");\n    pgfString(s);\n    // end of Para\n    endTag();\n}\n","name":"println","className":"StyledPrintStream","variables":{},"constants":{"\"Code\"":1},"javaDoc":"","comments":"end of Para ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"XmlForm","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Construct a converter given an input filename */\npublic XmlForm(String fn) {\n    fileName = fn;\n}\n","name":"XmlForm","className":"XmlForm","variables":{"fileName":1,"fn":1},"constants":{},"javaDoc":"Construct a converter given an input filename","comments":" Construct a converter given an input filename ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{"getClass":2,"newDocumentBuilder":1,"getResourceAsStream":1,"convertAll":1,"getMessage":1,"newInstance":1,"parse":1,"System.err.println":9},"annotations":[],"exceptions":["Exception"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"GenMIF":1,"DocumentBuilderFactory":1,"DocumentBuilder":1,"InputStream":1,"XmlFormWalker":1,"Document":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":6,"NameExpr":77,"StringLiteralExpr":10,"FieldAccessExpr":9,"MethodCallExpr":17},"statements":{"IfStmt":3,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":15},"text":"/** Convert the file */\npublic void convert(boolean verbose) {\n    try {\n        if (verbose)\n            System.err.println(\">>>Parsing \" + fileName + \"...\");\n        // Make the document a URL so relative DTD works.\n        //String uri = \"file:\" + new File(fileName).getAbsolutePath();\n        InputStream uri = getClass().getResourceAsStream(fileName);\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.parse(uri);\n        if (verbose)\n            System.err.println(\">>>Walking \" + fileName + \"...\");\n        XmlFormWalker c = new GenMIF(doc, msg);\n        c.convertAll();\n    } catch (Exception ex) {\n        System.err.println(\"+================================+\");\n        System.err.println(\"|         *Parse Error*          |\");\n        System.err.println(\"+================================+\");\n        System.err.println(ex.getClass());\n        System.err.println(ex.getMessage());\n        System.err.println(\"+================================+\");\n    }\n    if (verbose)\n        System.err.println(\">>>Done \" + fileName + \"...\");\n}\n","name":"convert","className":"XmlForm","variables":{"msg":1,"factory":2,"fileName":3,"DocumentBuilderFactory":1,"c":2,"ex":3,"builder":2,"doc":2,"uri":1,"verbose":3},"constants":{"\"...\"":3,"\">>>Done \"":1,"\"|         *Parse Error*          |\"":1,"\">>>Parsing \"":1,"\"+================================+\"":3,"\">>>Walking \"":1},"javaDoc":"Convert the file","comments":"Make the document a URL so relative DTD works String uri = \"file:\" + new File(fileName) getAbsolutePath();  Convert the file ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.err.println":1,"close":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":21,"StringLiteralExpr":1,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] av) {\n    if (av.length == 0) {\n        System.err.println(\"Usage: XmlForm file\");\n        return;\n    }\n    for (int i = 0; i < av.length; i++) {\n        String name = av[i];\n        new XmlForm(name).convert(true);\n    }\n    msg.close();\n}\n","name":"main","className":"XmlForm","variables":{"msg":1,"av":1,"name":2,"i":4},"constants":{"0":2,"true":1,"\"Usage: XmlForm file\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Plotter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BooleanLiteralExpr":1,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"Plotter() {\n    penIsUp = true;\n    curx = 0;\n    cury = 0;\n}\n","name":"Plotter","className":"Plotter","variables":{"curx":1,"cury":1,"penIsUp":1},"constants":{"0":2,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"abstract void rmoveTo(int incrx, int incry);\n","name":"rmoveTo","className":"Plotter","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"abstract void moveTo(int absx, int absy);\n","name":"moveTo","className":"Plotter","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"abstract void penUp();\n","name":"penUp","className":"Plotter","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"abstract void penDown();\n","name":"penDown","className":"Plotter","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"abstract void penColor(int c);\n","name":"penColor","className":"Plotter","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":["String","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"abstract void setFont(String fName, int fSize);\n","name":"setFont","className":"Plotter","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"abstract void drawString(String s);\n","name":"drawString","className":"Plotter","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"rmoveTo":4,"penDown":1,"penUp":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"NameExpr":16,"UnaryExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"/** Draw a box of width w and height h */\npublic void drawBox(int w, int h) {\n    penDown();\n    rmoveTo(w, 0);\n    rmoveTo(0, h);\n    rmoveTo(-w, 0);\n    rmoveTo(0, -h);\n    penUp();\n}\n","name":"drawBox","className":"Plotter","variables":{"w":1,"h":1},"constants":{"0":4},"javaDoc":"Draw a box of width w and height h","comments":" Draw a box of width w and height h ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["java.awt.Dimension"],"returnType":"void","methodCalls":{"drawBox":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Draw a box given an AWT Dimension for its size */\npublic void drawBox(java.awt.Dimension d) {\n    drawBox(d.width, d.height);\n}\n","name":"drawBox","className":"Plotter","variables":{},"constants":{},"javaDoc":"Draw a box given an AWT Dimension for its size","comments":" Draw a box given an AWT Dimension for its size ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["java.awt.Rectangle"],"returnType":"void","methodCalls":{"drawBox":1,"moveTo":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":16,"FieldAccessExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Draw a box given an AWT Rectangle for its location and size */\npublic void drawBox(java.awt.Rectangle r) {\n    moveTo(r.x, r.y);\n    drawBox(r.width, r.height);\n}\n","name":"drawBox","className":"Plotter","variables":{},"constants":{},"javaDoc":"Draw a box given an AWT Rectangle for its location and size","comments":" Draw a box given an AWT Rectangle for its location and size ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Point","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/** Show the current location; useful for\n     * testing, if nothing else.\n     */\npublic Point getLocation() {\n    return new Point(curx, cury);\n}\n","name":"getLocation","className":"Plotter","variables":{"curx":1,"cury":1},"constants":{},"javaDoc":"Show the current location; useful for testing if nothing else","comments":" Show the current location; useful for\n     * testing, if nothing else.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"PlotterAWT","methodCalls":{"add":1,"setVisible":1,"getOsGraphics":1,"getContentPane":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Container":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":30,"StringLiteralExpr":1,"FieldAccessExpr":2,"AssignExpr":3,"MethodCallExpr":6},"statements":{"ExpressionStmt":8},"text":"PlotterAWT() {\n    f = new JFrame(\"Plotter\");\n    Container cp = f.getContentPane();\n    p = new PCanvas(MAXX, MAXY);\n    cp.add(p, BorderLayout.CENTER);\n    f.pack();\n    f.setVisible(true);\n    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    g = p.getOsGraphics();\n}\n","name":"PlotterAWT","className":"PlotterAWT","variables":{"p":2,"f":5,"MAXY":1,"MAXX":1,"g":1,"cp":2},"constants":{"true":1,"\"Plotter\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"repaint":1,"drawRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void drawBox(int w, int h) {\n    g.drawRect(curx, cury, w, h);\n    p.repaint();\n}\n","name":"drawBox","className":"PlotterAWT","variables":{"p":1,"g":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"moveTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":1},"text":"public void rmoveTo(int incrx, int incry) {\n    moveTo(curx += incrx, cury += incry);\n}\n","name":"rmoveTo","className":"PlotterAWT","variables":{"curx":1,"cury":1,"incry":1,"incrx":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"public void moveTo(int absx, int absy) {\n    if (!penIsUp)\n        g.drawLine(curx, cury, absx, absy);\n    curx = absx;\n    cury = absy;\n}\n","name":"moveTo","className":"PlotterAWT","variables":{"curx":1,"g":1,"cury":1,"penIsUp":1,"absy":1,"absx":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void setdir(float deg) {\n}\n","name":"setdir","className":"PlotterAWT","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"void penUp() {\n    penIsUp = true;\n}\n","name":"penUp","className":"PlotterAWT","variables":{"penIsUp":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"void penDown() {\n    penIsUp = false;\n}\n","name":"penDown","className":"PlotterAWT","variables":{"penIsUp":1},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"setColor":6},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"NameExpr":35,"FieldAccessExpr":5,"MethodCallExpr":6},"statements":{"SwitchStmt":1,"BreakStmt":6,"SwitchEntryStmt":6,"ExpressionStmt":6},"text":"void penColor(int c) {\n    switch(c) {\n        case 0:\n            g.setColor(Color.white);\n            break;\n        case 1:\n            g.setColor(Color.black);\n            break;\n        case 2:\n            g.setColor(Color.red);\n            break;\n        case 3:\n            g.setColor(Color.green);\n            break;\n        case 4:\n            g.setColor(Color.blue);\n            break;\n        default:\n            g.setColor(new Color(c));\n            break;\n    }\n}\n","name":"penColor","className":"PlotterAWT","variables":{"c":2,"g":6},"constants":{"0":1,"1":1,"2":1,"3":1,"4":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String","int"],"returnType":"void","methodCalls":{"getFontMetrics":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":11,"FieldAccessExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"void setFont(String fName, int fSize) {\n    font = new Font(fName, Font.BOLD, fSize);\n    fontMetrics = p.getFontMetrics(font);\n}\n","name":"setFont","className":"PlotterAWT","variables":{"p":1,"fName":1,"fSize":1,"fontMetrics":1,"font":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"stringWidth":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":11,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"void drawString(String s) {\n    g.drawString(s, curx, cury);\n    curx += fontMetrics.stringWidth(s);\n}\n","name":"drawString","className":"PlotterAWT","variables":{"curx":1,"g":1,"fontMetrics":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int","int"],"returnType":"PCanvas","methodCalls":{"setForeground":1,"setBackground":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":14,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"PCanvas(int w, int h) {\n    width = w;\n    height = h;\n    setBackground(Color.white);\n    setForeground(Color.red);\n}\n","name":"PCanvas","className":"PCanvas","variables":{"w":1,"width":1,"h":1,"height":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"Graphics","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Graphics getOsGraphics() {\n    return pg;\n}\n","name":"getOsGraphics","className":"PCanvas","variables":{"pg":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"createImage":1,"getGraphics":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":11,"MethodCallExpr":3,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/** This is called by AWT after the native window peer is created,\n         * and before paint() is called for the first time, so\n         * is a good time to create images and the like.\n         */\npublic void addNotify() {\n    super.addNotify();\n    offScreenImage = createImage(width, height);\n    // assert (offScreenImage != null);\n    pg = offScreenImage.getGraphics();\n}\n","name":"addNotify","className":"PCanvas","variables":{"offScreenImage":2,"pg":1},"constants":{},"javaDoc":"This is called by AWT after the native window peer is created and before paint() is called for the first time so is a good time to create images and the like","comments":"assert (offScreenImage != null);  This is called by AWT after the native window peer is created,\n         * and before paint() is called for the first time, so\n         * is a good time to create images and the like.\n         ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawImage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void paint(Graphics pg) {\n    pg.drawImage(offScreenImage, 0, 0, null);\n}\n","name":"paint","className":"PCanvas","variables":{"pg":1},"constants":{"0":2,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public Dimension getPreferredSize() {\n    return new Dimension(width, height);\n}\n","name":"getPreferredSize","className":"PCanvas","variables":{"width":1,"height":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"drawBox":3,"forName":1,"printStackTrace":1,"rmoveTo":1,"penColor":4,"penDown":2,"newInstance":1,"setFont":1,"System.err.println":2,"penUp":1,"drawString":1,"moveTo":2},"annotations":[],"exceptions":["ClassNotFoundException","Exception"],"concepts":["ExceptionHandling"],"types":{"Plotter":1,"Object":1,"Class<?>":1},"expressions":{"IntegerLiteralExpr":20,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":72,"StringLiteralExpr":6,"UnaryExpr":1,"InstanceOfExpr":1,"AssignExpr":1,"CastExpr":1,"FieldAccessExpr":3,"EnclosedExpr":1,"MethodCallExpr":20},"statements":{"IfStmt":2,"BlockStmt":4,"TryStmt":1,"ReturnStmt":3,"ThrowStmt":1,"ExpressionStmt":22},"text":"/** Construct a Plotter driver, and try it out. */\npublic static void main(String[] argv) {\n    Plotter r;\n    if (argv.length != 1) {\n        System.err.println(\"Usage: PlotDriver driverclass\");\n        return;\n    }\n    try {\n        Class<?> c = Class.forName(argv[0]);\n        Object o = c.newInstance();\n        if (!(o instanceof Plotter))\n            throw new ClassNotFoundException(\"Not instanceof Plotter\");\n        r = (Plotter) o;\n    } catch (ClassNotFoundException e) {\n        System.err.println(\"Sorry, class \" + argv[0] + \" not a plotter class\");\n        return;\n    } catch (Exception e) {\n        e.printStackTrace();\n        return;\n    }\n    r.penDown();\n    r.penColor(1);\n    r.moveTo(200, 200);\n    r.penColor(2);\n    r.drawBox(123, 200);\n    r.rmoveTo(10, 20);\n    r.penColor(3);\n    r.drawBox(123, 200);\n    r.penUp();\n    r.moveTo(300, 100);\n    r.penDown();\n    r.setFont(\"Helvetica\", 14);\n    r.drawString(\"Hello World\");\n    r.penColor(4);\n    r.drawBox(10, 10);\n}\n","name":"main","className":"PlotDriver","variables":{"r":17,"c":2,"e":3,"Class":1,"argv":2,"o":3},"constants":{"\"Helvetica\"":1,"14":1,"\"Hello World\"":1,"\"Sorry, class \"":1,"0":2,"1":2,"100":1,"200":4,"2":1,"123":2,"3":1,"300":1,"4":1,"\"Usage: PlotDriver driverclass\"":1,"\"Not instanceof Plotter\"":1,"\" not a plotter class\"":1,"20":1,"10":3},"javaDoc":"Construct a Plotter driver and try it out","comments":" Construct a Plotter driver, and try it out. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":["GeneratedValue","Id"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Id\n@GeneratedValue(strategy = GenerationType.AUTO)\npublic int getId() {\n    return id;\n}\n","name":"getId","className":"Address","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// Other accessors and methods omitted for brevity\n// END main\npublic void setId(int id) {\n    this.id = id;\n}\n","name":"setId","className":"Address","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getStreetAddress() {\n    return streetAddress;\n}\n","name":"getStreetAddress","className":"Address","variables":{"streetAddress":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setStreetAddress(String streetAddress) {\n    this.streetAddress = streetAddress;\n}\n","name":"setStreetAddress","className":"Address","variables":{"streetAddress":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getCity() {\n    return city;\n}\n","name":"getCity","className":"Address","variables":{"city":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setCity(String city) {\n    this.city = city;\n}\n","name":"setCity","className":"Address","variables":{"city":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getCountry() {\n    return country;\n}\n","name":"getCountry","className":"Address","variables":{"country":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setCountry(String country) {\n    this.country = country;\n}\n","name":"setCountry","className":"Address","variables":{"country":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Person","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public Person() {\n// required by JPA; must code it since we need 2-arg form.\n}\n","name":"Person","className":"Person","variables":{},"constants":{},"javaDoc":"","comments":"required by JPA; must code it since we need 2-arg form ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"Person","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Person(String firstName, String lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n","name":"Person","className":"Person","variables":{"firstName":1,"lastName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":["GeneratedValue","Id"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Id\n@GeneratedValue(strategy = GenerationType.AUTO, generator = \"my_poid_gen\")\npublic int getId() {\n    return id;\n}\n","name":"getId","className":"Person","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setId(int id) {\n    this.id = id;\n}\n","name":"setId","className":"Person","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getFirstName() {\n    return firstName;\n}\n","name":"getFirstName","className":"Person","variables":{"firstName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setFirstName(String firstName) {\n    this.firstName = firstName;\n}\n","name":"setFirstName","className":"Person","variables":{"firstName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Column"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Column(name = \"surname\")\npublic String getLastName() {\n    return lastName;\n}\n","name":"getLastName","className":"Person","variables":{"lastName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setLastName(String lastName) {\n    this.lastName = lastName;\n}\n","name":"setLastName","className":"Person","variables":{"lastName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getFullName":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic String toString() {\n    return getFullName();\n}\n","name":"toString","className":"Person","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"/* synthetic: cannot be used in JPA queries. */\nString","methodCalls":{"length":1,"toString":1,"append":4},"annotations":["Transient"],"exceptions":[],"concepts":[],"types":{"StringBuilder":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":1,"CharLiteralExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":3,"ReturnStmt":1,"ExpressionStmt":4},"text":"@Transient\npublic /* synthetic: cannot be used in JPA queries. */\nString getFullName() {\n    StringBuilder sb = new StringBuilder();\n    if (firstName != null)\n        sb.append(firstName).append(' ');\n    if (lastName != null)\n        sb.append(lastName);\n    if (sb.length() == 0)\n        sb.append(\"NO NAME\");\n    return sb.toString();\n}\n","name":"getFullName","className":"Person","variables":{"firstName":1,"lastName":1,"sb":6},"constants":{"0":1,"null":2,"\"NO NAME\"":1,"' '":1},"javaDoc":"","comments":"synthetic: cannot be used in JPA queries ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getAppletContext":1,"showDocument":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    if (targetURL != null) {\n        // showStatus(\"Going to \" + target);\n        getAppletContext().showDocument(targetURL);\n    }\n}\n","name":"actionPerformed","className":"","variables":{"targetURL":1},"constants":{"null":1},"javaDoc":"","comments":"showStatus(\"Going to \" + target); ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"parseInt":1,"getAppletContext":1,"add":1,"addActionListener":1,"getMessage":1,"setFont":1,"showDocument":1,"getParameter":6},"annotations":[],"exceptions":["MalformedURLException","IllegalArgumentException"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"Button":1,"String":2},"expressions":{"NullLiteralExpr":9,"ObjectCreationExpr":8,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":16,"NameExpr":67,"StringLiteralExpr":11,"FieldAccessExpr":1,"EnclosedExpr":3,"AssignExpr":11,"MethodCallExpr":13},"statements":{"IfStmt":9,"TryStmt":1,"BlockStmt":5,"ThrowStmt":4,"ExpressionStmt":15},"text":"/** Called from the browser to set up. We want to throw various\n     * kinds of exceptions but the API predefines that we don't, so we\n     * limit ourselves to the ubiquitous IllegalArgumentException.\n     */\npublic void init() {\n    // System.out.println(\"In LinkButton::init\");\n    try {\n        if ((targetName = getParameter(TARGET1)) == null)\n            throw new IllegalArgumentException(\"TARGET parameter REQUIRED\");\n        if ((targetHost = getParameter(TARGET2)) == null)\n            throw new IllegalArgumentException(\"TARGET parameter REQUIRED\");\n        String theURL = \"mailto:\" + targetName + \"@\" + targetHost;\n        subject = getParameter(\"subject\");\n        if (subject != null)\n            theURL += \"?subject=\" + subject;\n        targetURL = new URL(theURL);\n    } catch (MalformedURLException rsi) {\n        throw new IllegalArgumentException(\"MalformedURLException \" + rsi.getMessage());\n    }\n    // i.e., \"Send feedback\"\n    label = getParameter(\"label\");\n    if (label == null)\n        throw new IllegalArgumentException(\"LABEL is REQUIRED\");\n    // Now handle font stuff.\n    fontName = getParameter(\"font\");\n    if (fontName == null)\n        fontName = DEFAULTFONTNAME;\n    String s;\n    if ((s = getParameter(\"fontsize\")) != null)\n        fontSize = Integer.parseInt(s);\n    if (fontName != null || fontSize != 0) {\n        // System.out.println(\"Name \" + fontName + \", size \" + fontSize);\n        theFont = new Font(fontName, Font.BOLD, fontSize);\n    }\n    Button b = new Button(label);\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            if (targetURL != null) {\n                // showStatus(\"Going to \" + target);\n                getAppletContext().showDocument(targetURL);\n            }\n        }\n    });\n    if (theFont != null)\n        b.setFont(theFont);\n    add(b);\n}\n","name":"init","className":"MailtoButton","variables":{"targetName":2,"targetHost":2,"b":3,"theURL":3,"e":1,"subject":3,"rsi":2,"label":3,"Integer":1,"actionPerformed":1,"fontName":5,"s":2,"DEFAULTFONTNAME":1,"fontSize":3,"theFont":2,"targetURL":2},"constants":{"\"MalformedURLException \"":1,"0":1,"\"TARGET parameter REQUIRED\"":2,"null":9,"\"mailto:\"":1,"\"@\"":1,"\"label\"":1,"\"LABEL is REQUIRED\"":1,"\"font\"":1,"\"?subject=\"":1,"\"fontsize\"":1,"\"subject\"":1},"javaDoc":"Called from the browser to set up We want to throw various kinds of exceptions but the API predefines that we don't so we limit ourselves to the ubiquitous IllegalArgumentException","comments":"System out println(\"In LinkButton::init\"); i e \"Send feedback\" Now handle font stuff System out println(\"Name \" + fontName + \" size \" + fontSize); showStatus(\"Going to \" + target);  Called from the browser to set up. We want to throw various\n     * kinds of exceptions but the API predefines that we don't, so we\n     * limit ourselves to the ubiquitous IllegalArgumentException.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String[][]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"ArrayInitializerExpr":7,"StringLiteralExpr":18,"NameExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Give Parameter info to the AppletViewer, just for those\n     * writing HTML without hardcopy documentation :-)\n     */\npublic String[][] getParameterInfo() {\n    String info[][] = { { \"label\", \"string\", \"Text to display\" }, { \"fontname\", \"name\", \"Font to display it in\" }, { \"fontsize\", \"10-30?\", \"Size to display it at\" }, { \"username\", \"email-account\", \"Where do you want your mail to go today? Part 1\" }, { \"hostname\", \"host.domain\", \"Where do you want your mail to go today? Part 2\" }, { \"subject\", \"subject line\", \"What your Subject: field will be.\" } };\n    return info;\n}\n             // WARNING - these intentionally lie, to mislead spammers who\n\n             // are incautious enough to download and run (or strings) the\n\n             // .class file for this Applet.\n\n","name":"getParameterInfo","className":"MailtoButton","variables":{"info":2},"constants":{"\"username\"":1,"\"host.domain\"":1,"\"Size to display it at\"":1,"\"subject line\"":1,"\"email-account\"":1,"\"fontname\"":1,"\"hostname\"":1,"\"Font to display it in\"":1,"\"Where do you want your mail to go today? Part 2\"":1,"\"What your Subject: field will be.\"":1,"\"subject\"":1,"\"string\"":1,"\"label\"":1,"\"name\"":1,"\"Where do you want your mail to go today? Part 1\"":1,"\"Text to display\"":1,"\"fontsize\"":1,"\"10-30?\"":1},"javaDoc":"Give Parameter info to the AppletViewer just for those writing HTML without hardcopy documentation :-)","comments":"WARNING - these intentionally lie to mislead spammers who are incautious enough to download and run (or strings) the class file for this Applet  Give Parameter info to the AppletViewer, just for those\n     * writing HTML without hardcopy documentation :-)\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container","String","int","int"],"returnType":"MailComposeBean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":4},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a MailComposeBean with no default recipient */\nMailComposeBean(Container parent, String title, int height, int width) {\n    this(parent, title, null, height, width);\n}\n","name":"MailComposeBean","className":"MailComposeBean","variables":{"parent":1,"width":1,"title":1,"height":1},"constants":{"null":1},"javaDoc":"Construct a MailComposeBean with no default recipient","comments":" Construct a MailComposeBean with no default recipient ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"MailComposeBean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":2,"StringLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct a MailComposeBean with no arguments (needed for Beans) */\nMailComposeBean() {\n    this(null, \"Compose\", null, 300, 200);\n}\n","name":"MailComposeBean","className":"MailComposeBean","variables":{},"constants":{"200":1,"300":1,"null":2,"\"Compose\"":1},"javaDoc":"Construct a MailComposeBean with no arguments (needed for Beans)","comments":" Construct a MailComposeBean with no arguments (needed for Beans) ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showMessageDialog":1,"toString":1,"doSend":1,"System.err.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent e) {\n    try {\n        doSend();\n    } catch (Exception err) {\n        System.err.println(\"Error: \" + err);\n        JOptionPane.showMessageDialog(null, \"Sending error:\\n\" + err.toString(), \"Send failed\", JOptionPane.ERROR_MESSAGE);\n    }\n}\n","name":"actionPerformed","className":"","variables":{"err":3,"JOptionPane":1},"constants":{"\"Error: \"":1,"\"Sending error:\\n\"":1,"null":1,"\"Send failed\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"maybeKillParent":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    maybeKillParent();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container","String","String","int","int"],"returnType":"MailComposeBean","methodCalls":{"add":11,"createTitledBorder":1,"requestFocus":2,"showMessageDialog":1,"maybeKillParent":1,"setBorder":1,"addActionListener":2,"toString":1,"setLayout":3,"doSend":1,"System.err.println":1,"setText":1},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"JPanel":2,"Container":1},"expressions":{"ObjectCreationExpr":16,"IntegerLiteralExpr":7,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":129,"StringLiteralExpr":9,"AssignExpr":13,"NullLiteralExpr":2,"FieldAccessExpr":9,"ArrayCreationExpr":1,"ThisExpr":2,"MethodCallExpr":26},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":31},"text":"/** Constructor for MailComposeBean object.\n     *\n     * @param parent    Container parent. If JFrame or JInternalFrame,\n     *                    will setvisible(false) and dispose() when\n     *                    message has been sent. Not done if \"null\" or JPanel.\n     * @param title        Title to display in the titlebar\n     * @param recipient    Email address of recipient\n     * @param height    Height of mail compose window\n     * @param width        Width of mail compose window\n     */\nMailComposeBean(Container parent, String title, String recipient, int width, int height) {\n    super();\n    this.parent = parent;\n    mywidth = width;\n    myheight = height;\n    // THE GUI\n    Container cp = this;\n    cp.setLayout(new BorderLayout());\n    // Top is a JPanel for name, address, etc.\n    // Center is the TextArea.\n    // Bottom is a panel with Send and Cancel buttons.\n    JPanel tp = new JPanel();\n    tp.setLayout(new GridLayout(3, 2));\n    cp.add(BorderLayout.NORTH, tp);\n    tfs = new JTextField[MAXTF];\n    tp.add(new JLabel(\"To: \", JLabel.RIGHT));\n    tp.add(tfs[TO] = toTF = new JTextField(35));\n    if (recipient != null)\n        toTF.setText(recipient);\n    toTF.requestFocus();\n    tp.add(new JLabel(\"Subject: \", JLabel.RIGHT));\n    tp.add(tfs[SUBJ] = subjectTF = new JTextField(35));\n    subjectTF.requestFocus();\n    tp.add(new JLabel(\"Cc: \", JLabel.RIGHT));\n    tp.add(tfs[CC] = ccTF = new JTextField(35));\n    // Center is the TextArea\n    cp.add(BorderLayout.CENTER, msgText = new JTextArea(70, 10));\n    msgText.setBorder(BorderFactory.createTitledBorder(\"Message Text\"));\n    // Bottom is the apply/cancel button\n    JPanel bp = new JPanel();\n    bp.setLayout(new FlowLayout());\n    bp.add(sendButton = new JButton(\"Send\"));\n    sendButton.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            try {\n                doSend();\n            } catch (Exception err) {\n                System.err.println(\"Error: \" + err);\n                JOptionPane.showMessageDialog(null, \"Sending error:\\n\" + err.toString(), \"Send failed\", JOptionPane.ERROR_MESSAGE);\n            }\n        }\n    });\n    bp.add(cancelButton = new JButton(\"Cancel\"));\n    cancelButton.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            maybeKillParent();\n        }\n    });\n    cp.add(BorderLayout.SOUTH, bp);\n}\n","name":"MailComposeBean","className":"MailComposeBean","variables":{"tfs":4,"parent":1,"SUBJ":1,"bp":4,"actionPerformed":2,"cancelButton":2,"msgText":2,"toTF":3,"height":1,"CC":1,"BorderFactory":1,"err":3,"mywidth":1,"e":2,"cp":5,"MAXTF":1,"JOptionPane":1,"sendButton":2,"subjectTF":2,"width":1,"recipient":1,"myheight":1,"TO":1,"tp":8,"ccTF":1},"constants":{"35":3,"\"To: \"":1,"\"Send failed\"":1,"\"Cancel\"":1,"\"Message Text\"":1,"\"Error: \"":1,"\"Sending error:\\n\"":1,"2":1,"\"Subject: \"":1,"3":1,"null":2,"\"Cc: \"":1,"70":1,"\"Send\"":1,"10":1},"javaDoc":"Constructor for MailComposeBean object parent Container parent If JFrame or JInternalFrame will setvisible(false) and dispose() when message has been sent Not done if \"null\" or JPanel title Title to display in the titlebar recipient Email address of recipient height Height of mail compose window width Width of mail compose window","comments":"Top is a JPanel for name address etc Center is the TextArea THE GUI Bottom is a panel with Send and Cancel buttons Center is the TextArea Bottom is the apply/cancel button  Constructor for MailComposeBean object.\n     *\n     * @param parent    Container parent. If JFrame or JInternalFrame,\n     *                    will setvisible(false) and dispose() when\n     *                    message has been sent. Not done if \"null\" or JPanel.\n     * @param title        Title to display in the titlebar\n     * @param recipient    Email address of recipient\n     * @param height    Height of mail compose window\n     * @param width        Width of mail compose window\n     ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public Dimension getPreferredSize() {\n    return new Dimension(mywidth, myheight);\n}\n","name":"getPreferredSize","className":"MailComposeBean","variables":{"mywidth":1,"myheight":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"getPreferredSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public Dimension getMinimumSize() {\n    return getPreferredSize();\n}\n","name":"getMinimumSize","className":"MailComposeBean","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setSubject":1,"getProperty":3,"printStackTrace":2,"setToList":1,"setFrom":1,"getText":5,"length":1,"setServer":1,"setVerbose":1,"setBody":1,"showMessageDialog":4,"setCcList":1,"maybeKillParent":1,"equals":1,"getNextException":1,"toString":2,"doSend":1},"annotations":[],"exceptions":["MessagingException","Exception"],"concepts":["ExceptionHandling"],"types":{"FileProperties":1,"Mailer":1,"String":3},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":6,"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":10,"NameExpr":114,"StringLiteralExpr":11,"CastExpr":1,"FieldAccessExpr":8,"EnclosedExpr":1,"MethodCallExpr":28,"AssignExpr":1},"statements":{"IfStmt":3,"WhileStmt":1,"TryStmt":1,"BlockStmt":7,"ReturnStmt":2,"ExpressionStmt":20},"text":"/** Do the work: send the mail to the SMTP server.\n     *\n     * ASSERT: must have set at least one recipient.\n     */\npublic void doSend() {\n    try {\n        Mailer m = new Mailer();\n        FileProperties props = new FileProperties(MailConstants.PROPS_FILE_NAME);\n        String serverHost = props.getProperty(MailConstants.SEND_HOST);\n        if (serverHost == null) {\n            JOptionPane.showMessageDialog(parent, \"\\\"\" + MailConstants.SEND_HOST + \"\\\" must be set in properties\", \"No server!\", JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n        m.setServer(serverHost);\n        String tmp = props.getProperty(MailConstants.SEND_DEBUG);\n        m.setVerbose(tmp != null && tmp.equals(\"true\"));\n        String myAddress = props.getProperty(\"Mail.address\");\n        if (myAddress == null) {\n            JOptionPane.showMessageDialog(parent, \"\\\"Mail.address\\\" must be set in properties\", \"No From: address!\", JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n        m.setFrom(myAddress);\n        m.setToList(toTF.getText());\n        m.setCcList(ccTF.getText());\n        if (subjectTF.getText().length() != 0) {\n            m.setSubject(subjectTF.getText());\n        }\n        // Now copy the text from the Compose TextArea.\n        m.setBody(msgText.getText());\n        // XXX I18N: use setBody(msgText.getText(), charset)\n        // Finally, send the sucker!\n        m.doSend();\n        // Now hide the main window\n        maybeKillParent();\n    } catch (MessagingException me) {\n        me.printStackTrace();\n        while ((me = (MessagingException) me.getNextException()) != null) {\n            me.printStackTrace();\n        }\n        JOptionPane.showMessageDialog(null, \"Mail Sending Error:\\n\" + me.toString(), \"Error\", JOptionPane.ERROR_MESSAGE);\n    } catch (Exception e) {\n        JOptionPane.showMessageDialog(null, \"Mail Sending Error:\\n\" + e.toString(), \"Error\", JOptionPane.ERROR_MESSAGE);\n    }\n}\n             // m.setBccList(bccTF.getText());\n\n","name":"doSend","className":"MailComposeBean","variables":{"e":2,"tmp":3,"subjectTF":2,"me":6,"myAddress":2,"msgText":1,"toTF":1,"ccTF":1,"m":9,"JOptionPane":4,"serverHost":2,"props":4},"constants":{"0":1,"\"\\\"Mail.address\\\" must be set in properties\"":1,"\"Error\"":2,"null":6,"\"No From: address!\"":1,"\"\\\"\"":1,"\"\\\" must be set in properties\"":1,"\"Mail.address\"":1,"\"Mail Sending Error:\\n\"":2,"\"No server!\"":1,"\"true\"":1},"javaDoc":"Do the work: send the mail to the SMTP server ASSERT: must have set at least one recipient","comments":"m setBccList(bccTF getText()); XXX I18N: use setBody(msgText getText() charset) Now copy the text from the Compose TextArea Finally send the sucker! Now hide the main window  Do the work: send the mail to the SMTP server.\n     *\n     * ASSERT: must have set at least one recipient.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":15,"CastExpr":4,"EnclosedExpr":4,"InstanceOfExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":3,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"private void maybeKillParent() {\n    if (parent == null)\n        return;\n    if (parent instanceof Frame) {\n        ((Frame) parent).setVisible(true);\n        ((Frame) parent).dispose();\n    }\n    if (parent instanceof JInternalFrame) {\n        ((JInternalFrame) parent).setVisible(true);\n        ((JInternalFrame) parent).dispose();\n    }\n}\n","name":"maybeKillParent","className":"MailComposeBean","variables":{"parent":7},"constants":{"null":1,"true":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"setVisible":1,"exit":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void windowClosing(WindowEvent e) {\n    jf.setVisible(false);\n    jf.dispose();\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"jf":2,"System":1},"constants":{"0":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":2,"addWindowListener":1,"exit":1,"setSize":1,"setLocation":1,"setProperty":2,"getProperties":2,"getContentPane":1,"dispose":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"JFrame":1,"MailComposeBean":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":7,"VariableDeclarationExpr":2,"BooleanLiteralExpr":2,"StringLiteralExpr":7,"NameExpr":43,"MethodCallExpr":14},"statements":{"BlockStmt":1,"ExpressionStmt":13},"text":"/** Simple test case driver */\npublic static void main(String[] av) {\n    final JFrame jf = new JFrame(\"DarwinSys Compose Mail Tester\");\n    System.getProperties().setProperty(\"Mail.server\", \"mailhost\");\n    System.getProperties().setProperty(\"Mail.address\", \"nobody@home\");\n    MailComposeBean sm = new MailComposeBean(jf, \"Test Mailer\", \"spam-magnet@darwinsys.com\", 500, 400);\n    sm.setSize(500, 400);\n    jf.getContentPane().add(sm);\n    jf.setLocation(100, 100);\n    jf.setVisible(true);\n    jf.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            jf.setVisible(false);\n            jf.dispose();\n            System.exit(0);\n        }\n    });\n    jf.pack();\n}\n","name":"main","className":"MailComposeBean","variables":{"e":1,"windowClosing":1,"sm":2,"jf":9,"System":3},"constants":{"\"Test Mailer\"":1,"false":1,"0":1,"100":2,"\"nobody@home\"":1,"400":2,"500":2,"\"spam-magnet@darwinsys.com\"":1,"true":1,"\"DarwinSys Compose Mail Tester\"":1,"\"mailhost\"":1,"\"Mail.address\"":1,"\"Mail.server\"":1},"javaDoc":"Simple test case driver","comments":" Simple test case driver ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"MailReaderBean","methodCalls":{},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":5},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/* Construct a mail reader bean with all defaults.\n     */\npublic MailReaderBean() throws Exception {\n    this(\"imap\", \"mailhost\", \"user\", \"*\", \"/\");\n}\n","name":"MailReaderBean","className":"MailReaderBean","variables":{},"constants":{"\"imap\"":1,"\"/\"":1,"\"*\"":1,"\"mailhost\"":1,"\"user\"":1},"javaDoc":"","comments":" Construct a mail reader bean with all defaults.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TreeSelectionEvent"],"returnType":"void","methodCalls":{"getSubject":1,"getClass":1,"getSentDate":1,"getAllRecipients":1,"getContent":1,"getPath":2,"toString":4,"setCaretPosition":1,"System.err.println":1,"append":13,"setText":1,"getFrom":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Message":1,"Object":3,"Object[]":3},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":95,"StringLiteralExpr":13,"CastExpr":1,"FieldAccessExpr":3,"EnclosedExpr":1,"InstanceOfExpr":2,"MethodCallExpr":28},"statements":{"IfStmt":2,"BlockStmt":6,"TryStmt":1,"ForeachStmt":2,"ReturnStmt":1,"ExpressionStmt":21},"text":"public void valueChanged(TreeSelectionEvent evt) {\n    // yes, repeat it.\n    Object[] po = evt.getPath().getPath();\n    // last node in path\n    Object o = po[po.length - 1];\n    if (o instanceof FolderNode) {\n        // System.out.println(\"Select folder \" + o.toString());\n        return;\n    }\n    if (o instanceof MessageNode) {\n        bodyText.setText(\"\");\n        try {\n            Message m = ((MessageNode) o).m;\n            bodyText.append(\"To: \");\n            Object[] tos = m.getAllRecipients();\n            for (Object to : tos) {\n                bodyText.append(to.toString());\n                bodyText.append(\" \");\n            }\n            bodyText.append(\"\\n\");\n            bodyText.append(\"Subject: \" + m.getSubject() + \"\\n\");\n            bodyText.append(\"From: \");\n            Object[] froms = m.getFrom();\n            for (Object from : froms) {\n                bodyText.append(from.toString());\n                bodyText.append(\" \");\n            }\n            bodyText.append(\"\\n\");\n            bodyText.append(\"Date: \" + m.getSentDate() + \"\\n\");\n            bodyText.append(\"\\n\");\n            bodyText.append(m.getContent().toString());\n            // Start reading at top of message(!)\n            bodyText.setCaretPosition(0);\n        } catch (Exception e) {\n            bodyText.append(e.toString());\n        }\n    } else\n        System.err.println(\"UNEXPECTED SELECTION: \" + o.getClass());\n}\n","name":"valueChanged","className":"","variables":{"evt":1,"bodyText":15,"e":2,"tos":2,"from":2,"to":2,"froms":2,"m":6,"po":2,"o":5},"constants":{"\"\"":1,"0":1,"\"UNEXPECTED SELECTION: \"":1,"1":1,"\"Subject: \"":1,"\"From: \"":1,"\" \"":2,"\"To: \"":1,"\"Date: \"":1,"\"\\n\"":5},"javaDoc":"","comments":"yes repeat it last node in path System out println(\"Select folder \" + o toString()); Start reading at top of message(!) ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","String","String","String"],"returnType":"MailReaderBean","methodCalls":{"top.f.list":1,"getSubject":1,"getClass":1,"getStore":1,"getContent":1,"setDebug":1,"setBackground":1,"top.f.exists":1,"getDefaultInstance":1,"getFolder":1,"getSentDate":1,"getAllRecipients":1,"getPath":2,"System.err.println":1,"connect":1,"System.out.println":1,"getFrom":1,"listFolder":2,"getProperties":1,"length":1,"top.f.getType":1,"getDefaultFolder":1,"toString":4,"setCaretPosition":1,"getBackground":1,"addTreeSelectionListener":1,"append":13,"setText":1},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"JScrollPane":1,"Folder[]":1,"JTree":1,"boolean":1,"FolderNode":1,"Message":1,"Store":1,"TreeSelectionListener":1,"Object":3,"Folder":1,"Object[]":3,"Session":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":8,"VariableDeclarationExpr":16,"ArrayAccessExpr":1,"BinaryExpr":11,"NameExpr":183,"StringLiteralExpr":14,"UnaryExpr":1,"InstanceOfExpr":2,"AssignExpr":3,"NullLiteralExpr":2,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":8,"EnclosedExpr":1,"ThisExpr":2,"MethodCallExpr":47},"statements":{"IfStmt":5,"BlockStmt":11,"TryStmt":1,"ExplicitConstructorInvocationStmt":1,"ForeachStmt":3,"ReturnStmt":2,"ExpressionStmt":41},"text":"/* Construct a mail reader bean with all values. */\npublic MailReaderBean(String protocol, String host, String user, String password, String rootName) throws Exception {\n    super(VERTICAL_SPLIT);\n    boolean recursive = false;\n    // Start with a Mail Session object\n    Session session = Session.getDefaultInstance(System.getProperties(), null);\n    session.setDebug(false);\n    // Get a Store object for the given protocol\n    Store store = session.getStore(protocol);\n    store.connect(host, user, password);\n    // Get Folder object for root, and list it\n    // If root name = \"\", getDefaultFolder(), else getFolder(root)\n    FolderNode top;\n    if (rootName.length() != 0) {\n        // System.out.println(\"Getting folder \" + rootName + \".\");\n        top = new FolderNode(store.getFolder(rootName));\n    } else {\n        // System.out.println(\"Getting default folder.\");\n        top = new FolderNode(store.getDefaultFolder());\n    }\n    if (top == null || !top.f.exists()) {\n        System.out.println(\"Invalid folder \" + rootName);\n        return;\n    }\n    if (top.f.getType() == Folder.HOLDS_FOLDERS) {\n        Folder[] fs = top.f.list();\n        for (Folder f : fs) listFolder(top, new FolderNode(f), recursive);\n    } else\n        listFolder(top, top, false);\n    // Now that (all) the foldernodes and treenodes are in,\n    // construct a JTree object from the top of the list down,\n    // make the JTree scrollable (put in JScrollPane),\n    // and add it as the MailComposeBean's Northern child.\n    JTree tree = new JTree(top);\n    JScrollPane treeScroller = new JScrollPane(tree);\n    treeScroller.setBackground(tree.getBackground());\n    this.setTopComponent(treeScroller);\n    // The Southern (Bottom) child is a textarea to display the msg.\n    bodyText = new JTextArea(15, 80);\n    this.setBottomComponent(new JScrollPane(bodyText));\n    // Add a notification listener for the tree; this will\n    // display the clicked-upon message\n    TreeSelectionListener tsl = new TreeSelectionListener() {\n\n        public void valueChanged(TreeSelectionEvent evt) {\n            // yes, repeat it.\n            Object[] po = evt.getPath().getPath();\n            // last node in path\n            Object o = po[po.length - 1];\n            if (o instanceof FolderNode) {\n                // System.out.println(\"Select folder \" + o.toString());\n                return;\n            }\n            if (o instanceof MessageNode) {\n                bodyText.setText(\"\");\n                try {\n                    Message m = ((MessageNode) o).m;\n                    bodyText.append(\"To: \");\n                    Object[] tos = m.getAllRecipients();\n                    for (Object to : tos) {\n                        bodyText.append(to.toString());\n                        bodyText.append(\" \");\n                    }\n                    bodyText.append(\"\\n\");\n                    bodyText.append(\"Subject: \" + m.getSubject() + \"\\n\");\n                    bodyText.append(\"From: \");\n                    Object[] froms = m.getFrom();\n                    for (Object from : froms) {\n                        bodyText.append(from.toString());\n                        bodyText.append(\" \");\n                    }\n                    bodyText.append(\"\\n\");\n                    bodyText.append(\"Date: \" + m.getSentDate() + \"\\n\");\n                    bodyText.append(\"\\n\");\n                    bodyText.append(m.getContent().toString());\n                    // Start reading at top of message(!)\n                    bodyText.setCaretPosition(0);\n                } catch (Exception e) {\n                    bodyText.append(e.toString());\n                }\n            } else\n                System.err.println(\"UNEXPECTED SELECTION: \" + o.getClass());\n        }\n    };\n    tree.addTreeSelectionListener(tsl);\n}\n","name":"MailReaderBean","className":"MailReaderBean","variables":{"evt":2,"valueChanged":1,"e":2,"VERTICAL_SPLIT":1,"session":3,"rootName":2,"f":2,"tree":4,"treeScroller":2,"store":4,"tsl":1,"fs":2,"m":6,"recursive":1,"System":1,"o":5,"bodyText":17,"top":5,"tos":2,"from":2,"to":2,"froms":2,"Session":1,"po":2},"constants":{"\"\"":1,"\"UNEXPECTED SELECTION: \"":1,"\"From: \"":1,"15":1,"\" \"":2,"false":3,"\"To: \"":1,"\"Date: \"":1,"\"Invalid folder \"":1,"0":2,"1":1,"\"Subject: \"":1,"null":2,"80":1,"\"\\n\"":5},"javaDoc":"","comments":"Get Folder object for root and list it Now that (all) the foldernodes and treenodes are in construct a JTree object from the top of the list down make the JTree scrollable (put in JScrollPane) Add a notification listener for the tree; this will Start with a Mail Session object Get a Store object for the given protocol If root name = \"\" getDefaultFolder() else getFolder(root) System out println(\"Getting folder \" + rootName + \" \"); System out println(\"Getting default folder \"); and add it as the MailComposeBean's Northern child The Southern (Bottom) child is a textarea to display the msg display the clicked-upon message yes repeat it last node in path System out println(\"Select folder \" + o toString()); Start reading at top of message(!)  Construct a mail reader bean with all values. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["FolderNode","FolderNode","boolean"],"returnType":"void","methodCalls":{"add":1,"folder.f.list":1,"m.m.getFrom":1,"listFolder":1,"folder.f.getMessages":1,"folder.f.getType":2,"toString":1},"annotations":[],"exceptions":["Exception"],"concepts":["Recursion"],"types":{"Folder[]":1,"Message[]":1,"Message":1,"Address":1,"MessageNode":1,"String":1,"Folder":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":3,"VariableDeclarationExpr":7,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":53,"CastExpr":1,"FieldAccessExpr":7,"EnclosedExpr":3,"InstanceOfExpr":1,"MethodCallExpr":9,"AssignExpr":2},"statements":{"IfStmt":4,"BlockStmt":5,"ForeachStmt":2,"ExpressionStmt":9},"text":"/** Process one folder. */\nstatic void listFolder(FolderNode top, FolderNode folder, boolean recurse) throws Exception {\n    if ((folder.f.getType() & Folder.HOLDS_MESSAGES) != 0) {\n        Message[] msgs = folder.f.getMessages();\n        for (Message ms : msgs) {\n            MessageNode m = new MessageNode(ms);\n            Address from = m.m.getFrom()[0];\n            String fromAddress;\n            if (from instanceof InternetAddress)\n                fromAddress = ((InternetAddress) from).getAddress();\n            else\n                fromAddress = from.toString();\n            top.add(new MessageNode(ms));\n        }\n    }\n    if ((folder.f.getType() & Folder.HOLDS_FOLDERS) != 0) {\n        if (recurse) {\n            Folder[] fs = folder.f.list();\n            for (Folder f : fs) {\n                listFolder(new FolderNode(f), top, recurse);\n            }\n        }\n    }\n}\n","name":"listFolder","className":"MailReaderBean","variables":{"msgs":2,"top":1,"ms":3,"recurse":1,"f":2,"from":4,"fromAddress":3,"m":1,"fs":2},"constants":{"0":3},"javaDoc":"Process one folder","comments":" Process one folder. ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"getProperty":1,"setSize":1,"getContentPane":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":["Exception"],"concepts":["FinalVariables"],"types":{"MailReaderBean":1,"JFrame":1,"String":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":6,"NameExpr":27,"FieldAccessExpr":2,"MethodCallExpr":6,"AssignExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":8},"text":"/* Demo unit - main program */\npublic static void main(String[] args) throws Exception {\n    final JFrame jf = new JFrame(\"MailReaderBean\");\n    jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    String mbox = \"INBOX\";\n    if (args.length > 0)\n        mbox = args[0];\n    MailReaderBean mb = new MailReaderBean(\"imap\", \"localhost\", System.getProperty(\"user.name\"), \"*\", mbox);\n    jf.getContentPane().add(mb);\n    jf.setSize(640, 480);\n    jf.setVisible(true);\n}\n","name":"main","className":"MailReaderBean","variables":{"args":1,"mb":1,"jf":5,"mbox":3,"System":1},"constants":{"0":2,"\"localhost\"":1,"\"user.name\"":1,"\"imap\"":1,"640":1,"\"MailReaderBean\"":1,"true":1,"\"*\"":1,"480":1,"\"INBOX\"":1},"javaDoc":"","comments":" Demo unit - main program ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"showExceptions":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void run() {\n    ErrorUtil.showExceptions(gui, ex);\n}\n","name":"run","className":"","variables":{"ErrorUtil":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Thread","Throwable"],"returnType":"void","methodCalls":{"System.err.println":1,"invokeAndWait":1,"showExceptions":1},"annotations":[],"exceptions":["InvocationTargetException | InterruptedException"],"concepts":["InnerMethod","ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":3,"ExpressionStmt":3},"text":"public void uncaughtException(Thread t, final Throwable ex) {\n    try {\n        SwingUtilities.invokeAndWait(new Runnable() {\n\n            public void run() {\n                ErrorUtil.showExceptions(gui, ex);\n            }\n        });\n    } catch (InvocationTargetException | InterruptedException e) {\n        System.err.println(\"Sob! We failed: \" + e);\n    }\n}\n                             // Nothing we can really do here...\n\n","name":"uncaughtException","className":"","variables":{"e":2,"run":1,"SwingUtilities":1,"ErrorUtil":1},"constants":{"\"Sob! We failed: \"":1},"javaDoc":"","comments":"Nothing we can really do here ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void run() {\n    // Can't do this on any non-EDT thread    \n    gui.setVisible(true);\n}\n","name":"run","className":"","variables":{"gui":1},"constants":{"true":1},"javaDoc":"","comments":"Can't do this on any non-EDT thread ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setDefaultUncaughtExceptionHandler":1,"System.err.println":1,"invokeAndWait":1,"invokeLater":1,"showExceptions":1},"annotations":[],"exceptions":["InvocationTargetException | InterruptedException","Exception"],"concepts":["InnerMethod","ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":4,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":31,"StringLiteralExpr":1,"FieldAccessExpr":1,"MarkerAnnotationExpr":1,"MethodCallExpr":6,"AssignExpr":1},"statements":{"BlockStmt":5,"TryStmt":1,"ExpressionStmt":7},"text":"public static void main(String unused[]) throws Exception {\n    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n\n        public void uncaughtException(Thread t, final Throwable ex) {\n            try {\n                SwingUtilities.invokeAndWait(new Runnable() {\n\n                    public void run() {\n                        ErrorUtil.showExceptions(gui, ex);\n                    }\n                });\n            } catch (InvocationTargetException | InterruptedException e) {\n                System.err.println(\"Sob! We failed: \" + e);\n            }\n        }\n    });\n    gui = new CheckOpenMailRelayGui();\n    SwingUtilities.invokeLater(new Runnable() {\n\n        @Override\n        public void run() {\n            // Can't do this on any non-EDT thread    \n            gui.setVisible(true);\n        }\n    });\n}\n                             // Nothing we can really do here...\n\n","name":"main","className":"CheckOpenMailRelayGui","variables":{"ex":1,"t":1,"e":2,"uncaughtException":1,"run":2,"gui":2,"SwingUtilities":2,"ErrorUtil":1,"Override":1,"Thread":1},"constants":{"true":1,"\"Sob! We failed: \"":1},"javaDoc":"","comments":"Nothing we can really do here Can't do this on any non-EDT thread ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setEnabled":1,"println":1,"process":1,"trim":1,"getText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":17,"StringLiteralExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":4},"text":"public void run() {\n    String host = hostTextField.getText().trim();\n    out.println(\"Trying \" + host);\n    CheckOpenMailRelay.process(host, out);\n    goButton.setEnabled(true);\n}\n","name":"run","className":"","variables":{"CheckOpenMailRelay":1,"host":2,"goButton":1,"hostTextField":1,"out":1},"constants":{"true":1,"\"Trying \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setEnabled":2,"println":1,"process":1,"trim":1,"getText":1,"invokeLater":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":2,"BinaryExpr":1,"NameExpr":25,"StringLiteralExpr":1,"MethodCallExpr":7},"statements":{"BlockStmt":1,"ExpressionStmt":6},"text":"public void actionPerformed(ActionEvent evt) {\n    goButton.setEnabled(false);\n    SwingUtilities.invokeLater(new Runnable() {\n\n        public void run() {\n            String host = hostTextField.getText().trim();\n            out.println(\"Trying \" + host);\n            CheckOpenMailRelay.process(host, out);\n            goButton.setEnabled(true);\n        }\n    });\n}\n","name":"actionPerformed","className":"","variables":{"CheckOpenMailRelay":1,"host":2,"goButton":2,"run":1,"SwingUtilities":1,"hostTextField":1,"out":1},"constants":{"false":1,"true":1,"\"Trying \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent evt) {\n    results.setText(\"\");\n}\n","name":"actionPerformed","className":"","variables":{"results":1},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"CheckOpenMailRelayGui","methodCalls":{"add":7,"setEnabled":3,"println":1,"process":1,"trim":1,"getText":1,"addActionListener":3,"getContentPane":1,"setDefaultCloseOperation":1,"pack":1,"invokeLater":1,"setText":1},"annotations":[],"exceptions":["IOException"],"concepts":["InnerMethod"],"types":{"JPanel":1,"Container":1,"JButton":2,"String":1},"expressions":{"ObjectCreationExpr":13,"IntegerLiteralExpr":3,"VariableDeclarationExpr":5,"BooleanLiteralExpr":3,"BinaryExpr":1,"StringLiteralExpr":7,"NameExpr":92,"FieldAccessExpr":3,"AssignExpr":8,"MethodCallExpr":22},"statements":{"BlockStmt":3,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":27},"text":"/** Construct a GUI and some I/O plumbing to get the output\n     * of \"TestOpenMailRelay\" into the \"results\" textfield.\n     */\npublic CheckOpenMailRelayGui() throws IOException {\n    super(\"Tests for Open Mail Relays\");\n    runner = new ActionListener() {\n\n        public void actionPerformed(ActionEvent evt) {\n            goButton.setEnabled(false);\n            SwingUtilities.invokeLater(new Runnable() {\n\n                public void run() {\n                    String host = hostTextField.getText().trim();\n                    out.println(\"Trying \" + host);\n                    CheckOpenMailRelay.process(host, out);\n                    goButton.setEnabled(true);\n                }\n            });\n        }\n    };\n    JPanel p;\n    Container cp = getContentPane();\n    cp.add(BorderLayout.NORTH, p = new JPanel());\n    // The entry label and text field.\n    p.add(new JLabel(\"Host:\"));\n    p.add(hostTextField = new JTextField(10));\n    hostTextField.addActionListener(runner);\n    p.add(goButton = new JButton(\"Try\"));\n    goButton.addActionListener(runner);\n    JButton cb;\n    p.add(cb = new JButton(\"Clear Log\"));\n    cb.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent evt) {\n            results.setText(\"\");\n        }\n    });\n    JButton sb;\n    p.add(sb = new JButton(\"Save Log\"));\n    sb.setEnabled(false);\n    results = new JTextArea(20, 60);\n    // Add the text area to the main part of the window (CENTER).\n    // Wrap it in a JScrollPane to make it scroll automatically.\n    cp.add(BorderLayout.CENTER, new JScrollPane(results));\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    // end of GUI portion\n    pack();\n    out = new PrintStream(new TextAreaOutputStream(results));\n}\n","name":"CheckOpenMailRelayGui","className":"CheckOpenMailRelayGui","variables":{"evt":2,"CheckOpenMailRelay":1,"goButton":4,"run":1,"cp":3,"out":2,"sb":3,"p":7,"actionPerformed":2,"host":2,"SwingUtilities":1,"runner":1,"hostTextField":3,"results":4,"cb":3},"constants":{"\"Host:\"":1,"\"\"":1,"\"Tests for Open Mail Relays\"":1,"false":2,"true":1,"\"Clear Log\"":1,"60":1,"\"Save Log\"":1,"\"Trying \"":1,"\"Try\"":1,"20":1,"10":1},"javaDoc":"Construct a GUI and some I/O plumbing to get the output of \"TestOpenMailRelay\" into the \"results\" textfield","comments":"Add the text area to the main part of the window (CENTER) The entry label and text field Wrap it in a JScrollPane to make it scroll automatically end of GUI portion  Construct a GUI and some I/O plumbing to get the output\n     * of \"TestOpenMailRelay\" into the \"results\" textfield.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Message"],"returnType":"MessageNode","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"MessageNode(Message m) {\n    this.m = m;\n}\n","name":"MessageNode","className":"MessageNode","variables":{"m":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{"getSubject":1,"format":2,"toString":3,"append":1,"getFrom":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"StringBuffer":1,"Address":1,"String":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"NameExpr":33,"CastExpr":1,"StringLiteralExpr":1,"EnclosedExpr":1,"InstanceOfExpr":1,"MethodCallExpr":9,"AssignExpr":2},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":8},"text":"public String toString() {\n    try {\n        Address from = m.getFrom()[0];\n        String fromAddress;\n        if (from instanceof InternetAddress)\n            fromAddress = ((InternetAddress) from).getAddress();\n        else\n            fromAddress = from.toString();\n        StringBuffer sb = new StringBuffer();\n        fromFmt.format(fromAddress, sb, null);\n        sb.append(\"  \");\n        subjFmt.format(m.getSubject(), sb, null);\n        return sb.toString();\n    } catch (Exception e) {\n        return e.toString();\n    }\n}\n","name":"toString","className":"MessageNode","variables":{"fromFmt":1,"e":2,"from":4,"fromAddress":3,"subjFmt":1,"m":2,"sb":3},"constants":{"0":1,"null":2,"\"  \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MailClient","methodCalls":{},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Construct the MailClient JComponent a default Properties filename */\npublic MailClient() throws Exception {\n    this(PROPS_FILE_NAME);\n}\n","name":"MailClient","className":"MailClient","variables":{"PROPS_FILE_NAME":1},"constants":{},"javaDoc":"Construct the MailClient JComponent a default Properties filename","comments":" Construct the MailClient JComponent a default Properties filename ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"MailClient","methodCalls":{"add":4,"addTab":4,"getPassword":1,"getProperty":4,"showMessageDialog":1,"equals":2,"setProperty":1,"putAll":1,"getProperties":1,"length":1,"setLayout":1},"annotations":[],"exceptions":["Exception","IllegalArgumentException"],"concepts":["PolyMorphism"],"types":{"FileProperties":1,"JPanel":1,"JPasswordField":1,"JTabbedPane":1,"String":5,"Properties":1},"expressions":{"ObjectCreationExpr":13,"NullLiteralExpr":5,"IntegerLiteralExpr":2,"VariableDeclarationExpr":9,"BinaryExpr":15,"NameExpr":95,"StringLiteralExpr":13,"FieldAccessExpr":4,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":21,"AssignExpr":5},"statements":{"IfStmt":2,"BlockStmt":2,"ExplicitConstructorInvocationStmt":1,"ThrowStmt":1,"ExpressionStmt":22,"DoStmt":1},"text":"/** Construct the MailClient JComponent with a Properties filename */\npublic MailClient(String propsFileName) throws Exception {\n    super();\n    // Construct and load the Properties for the mail reader and sender.\n    Properties mailProps = new FileProperties(propsFileName);\n    // Gather some key values\n    String proto = mailProps.getProperty(RECV_PROTO);\n    String user = mailProps.getProperty(RECV_USER);\n    String pass = mailProps.getProperty(RECV_PASS);\n    String host = mailProps.getProperty(RECV_HOST);\n    if (proto == null)\n        throw new IllegalArgumentException(RECV_PROTO + \"==null\");\n    // Protocols other than \"mbox\" need a password.\n    if (!proto.equals(\"mbox\") && (pass == null || pass.equals(\"ASK\"))) {\n        String np;\n        do {\n            // Make JOptionPane prompt for password in no-echo.\n            // Create \"message\" using JPanel, JLabel, & JPasswordField\n            // Courtesy of Marc Loy.\n            JPanel p = new JPanel();\n            p.add(new JLabel(\"Password for \" + proto + \" user \" + user + \" on \" + host));\n            JPasswordField jpf = new JPasswordField(20);\n            p.add(jpf);\n            JOptionPane.showMessageDialog(null, p, \"Password request\", JOptionPane.QUESTION_MESSAGE);\n            np = new String(jpf.getPassword());\n        } while (np == null || (np != null && np.length() == 0));\n        mailProps.setProperty(RECV_PASS, np);\n    }\n    // Dump them all into System.properties so other code can find.\n    System.getProperties().putAll(mailProps);\n    // Construct the GUI\n    // System.out.println(\"Constructing GUI\");\n    setLayout(new BorderLayout());\n    JTabbedPane tbp = new JTabbedPane();\n    add(BorderLayout.CENTER, tbp);\n    tbp.addTab(\"Reading\", mrb = new MailReaderBean());\n    tbp.addTab(\"Sending\", mcb = new MailComposeFrame());\n    tbp.addTab(\"Aliases\", alb = new AliasBean());\n    tbp.addTab(\"List sending\", new JLabel(\"Under construction\", JLabel.CENTER));\n    add(BorderLayout.SOUTH, quitButton = new JButton(\"Exit\"));\n// System.out.println(\"Leaving Constructor\");\n}\n","name":"MailClient","className":"MailClient","variables":{"propsFileName":1,"jpf":2,"np":5,"tbp":5,"pass":3,"RECV_PROTO":1,"quitButton":1,"JOptionPane":1,"mcb":1,"System":1,"p":3,"mailProps":6,"alb":1,"proto":4,"host":2,"mrb":1,"user":2},"constants":{"\" on \"":1,"\"List sending\"":1,"\"Under construction\"":1,"\"Exit\"":1,"0":1,"\"mbox\"":1,"\" user \"":1,"null":5,"\"ASK\"":1,"\"Password request\"":1,"\"==null\"":1,"\"Password for \"":1,"\"Aliases\"":1,"\"Reading\"":1,"20":1,"\"Sending\"":1},"javaDoc":"Construct the MailClient JComponent with a Properties filename","comments":"Construct the GUI System out println(\"Leaving Constructor\"); Construct and load the Properties for the mail reader and sender Gather some key values Protocols other than \"mbox\" need a password Make JOptionPane prompt for password in no-echo Create \"message\" using JPanel JLabel & JPasswordField Courtesy of Marc Loy Dump them all into System properties so other code can find System out println(\"Constructing GUI\");  Construct the MailClient JComponent with a Properties filename ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setVisible":1,"exit":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent e) {\n    f.setVisible(false);\n    f.dispose();\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"f":2,"System":1},"constants":{"0":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"setVisible":1,"exit":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void windowClosing(WindowEvent e) {\n    f.setVisible(false);\n    f.dispose();\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"f":2,"System":1},"constants":{"0":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":3,"exit":2,"addWindowListener":1,"showMessageDialog":1,"forName":1,"getContentPane":1,"dispose":2,"pack":1,"comp.quitButton.addActionListener":1},"annotations":[],"exceptions":["ClassNotFoundException","Exception"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"JFrame":1,"MailClient":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":3,"BooleanLiteralExpr":3,"StringLiteralExpr":5,"NameExpr":59,"FieldAccessExpr":3,"MethodCallExpr":14,"AssignExpr":2},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":17},"text":"/** \"main program\" method - run the program */\npublic static void main(String[] av) throws Exception {\n    final JFrame f = new JFrame(\"MailClient\");\n    // Start by checking that the javax.mail package is installed!\n    try {\n        Class.forName(\"javax.mail.Session\");\n    } catch (ClassNotFoundException cnfe) {\n        JOptionPane.showMessageDialog(f, \"Sorry, the javax.mail package was not found\\n(\" + cnfe + \")\", \"Error\", JOptionPane.ERROR_MESSAGE);\n        return;\n    }\n    // create a MailClient object\n    MailClient comp;\n    if (av.length == 0)\n        comp = new MailClient();\n    else\n        comp = new MailClient(av[0]);\n    f.getContentPane().add(comp);\n    // Set up action handling for GUI\n    comp.quitButton.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            f.setVisible(false);\n            f.dispose();\n            System.exit(0);\n        }\n    });\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            f.setVisible(false);\n            f.dispose();\n            System.exit(0);\n        }\n    });\n    f.pack();\n    f.setVisible(true);\n}\n","name":"main","className":"MailClient","variables":{"comp":3,"actionPerformed":1,"cnfe":2,"av":1,"e":2,"windowClosing":1,"f":9,"Class":1,"JOptionPane":1,"System":2},"constants":{"0":4,"\"Error\"":1,"\"MailClient\"":1,"\"javax.mail.Session\"":1,"\"Sorry, the javax.mail package was not found\\n(\"":1,"false":2,"true":1,"\")\"":1},"javaDoc":"\"main program\" method - run the program","comments":"Start by checking that the javax mail package is installed! create a MailClient object Set up action handling for GUI  \"main program\" method - run the program ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setSubject":1,"setContent":2,"getProperty":1,"printStackTrace":1,"setFrom":1,"setDebug":1,"getDefaultInstance":1,"addRecipient":2,"setProperty":1,"System.err.println":1,"send":1,"addBodyPart":2,"setText":1},"annotations":[],"exceptions":["MessagingException","IOException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"FileProperties":1,"BodyPart":2,"InternetAddress":2,"Multipart":1,"MimeMultipart":1,"MimeBodyPart":2},"expressions":{"ObjectCreationExpr":8,"NullLiteralExpr":1,"VariableDeclarationExpr":6,"BooleanLiteralExpr":1,"NameExpr":85,"StringLiteralExpr":3,"FieldAccessExpr":8,"MethodCallExpr":16,"AssignExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":22},"text":"/** Do the work: send the mail to the SMTP server.  */\npublic void doSend() throws IOException, MessagingException {\n    // We need to pass info to the mail server as a Properties, since\n    // JavaMail (wisely) allows room for LOTS of properties...\n    FileProperties props = new FileProperties(MailConstants.PROPS_FILE_NAME);\n    // Copy the value of Mail.send.host into mail.smtp.host\n    props.setProperty(\"mail.smtp.host\", props.getProperty(MailConstants.SEND_HOST));\n    // Create the Session object\n    session = Session.getDefaultInstance(props, null);\n    // Verbose!\n    session.setDebug(true);\n    try {\n        // create a message\n        mesg = new MimeMessage(session);\n        // From Address - this should come from a Properties...\n        mesg.setFrom(new InternetAddress(\"nobody@host.domain\"));\n        // TO Address \n        InternetAddress toAddress = new InternetAddress(message_recip);\n        mesg.addRecipient(Message.RecipientType.TO, toAddress);\n        // CC Address\n        InternetAddress ccAddress = new InternetAddress(message_cc);\n        mesg.addRecipient(Message.RecipientType.CC, ccAddress);\n        // The Subject\n        mesg.setSubject(message_subject);\n        // Now the message body.\n        Multipart mp = new MimeMultipart();\n        BodyPart textPart = new MimeBodyPart();\n        // sets type to \"text/plain\"\n        textPart.setText(message_body);\n        BodyPart pixPart = new MimeBodyPart();\n        pixPart.setContent(html_data, \"text/html\");\n        // Collect the Parts into the MultiPart\n        mp.addBodyPart(textPart);\n        mp.addBodyPart(pixPart);\n        // Put the MultiPart into the Message\n        mesg.setContent(mp);\n        // Finally, send the message!\n        Transport.send(mesg);\n    } catch (MessagingException ex) {\n        System.err.println(ex);\n        ex.printStackTrace(System.err);\n    }\n}\n","name":"doSend","className":"SendMime","variables":{"message_cc":1,"mp":3,"session":3,"textPart":2,"toAddress":1,"props":3,"ccAddress":1,"ex":2,"pixPart":2,"message_recip":1,"Transport":1,"Session":1,"mesg":6},"constants":{"null":1,"true":1,"\"mail.smtp.host\"":1,"\"nobody@host.domain\"":1,"\"text/html\"":1},"javaDoc":"Do the work: send the mail to the SMTP server","comments":"We need to pass info to the mail server as a Properties since JavaMail (wisely) allows room for LOTS of properties Copy the value of Mail send host into mail smtp host Create the Session object Verbose! create a message From Address - this should come from a Properties TO Address CC Address The Subject Now the message body sets type to \"text/plain\" Collect the Parts into the MultiPart Put the MultiPart into the Message Finally send the message!  Do the work: send the mail to the SMTP server.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"doSend":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"SendMime":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Simple test case driver */\npublic static void main(String[] av) throws Exception {\n    SendMime sm = new SendMime();\n    sm.doSend();\n}\n","name":"main","className":"SendMime","variables":{"sm":2},"constants":{},"javaDoc":"Simple test case driver","comments":" Simple test case driver ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"console":1,"getProperty":5,"getStore":1,"listFolder":2,"getProperties":1,"length":1,"getDefaultFolder":1,"list":1,"setDebug":1,"getDefaultInstance":1,"getFolder":1,"exit":1,"load":1,"getType":1,"equals":1,"readPassword":1,"System.err.println":1,"connect":1,"open":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["FinalVariables"],"types":{"FileProperties":1,"Folder[]":1,"boolean":1,"Store":1,"String":6,"Folder":2,"Session":1,"char[]":1},"expressions":{"IntegerLiteralExpr":10,"ObjectCreationExpr":2,"VariableDeclarationExpr":14,"ArrayAccessExpr":6,"BinaryExpr":6,"NameExpr":143,"StringLiteralExpr":8,"AssignExpr":14,"NullLiteralExpr":7,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":13,"MethodCallExpr":26},"statements":{"IfStmt":5,"BlockStmt":9,"ForeachStmt":1,"ExpressionStmt":37},"text":"public static void main(String[] argv) throws Exception {\n    String fileName = MailConstants.PROPS_FILE_NAME;\n    String protocol = null;\n    String host = null;\n    String user = null;\n    String password = null;\n    String root = null;\n    // If argc == 1, assume it's a Properties file.\n    if (argv.length == 1) {\n        fileName = argv[0];\n        FileProperties fp = new FileProperties(fileName);\n        fp.load();\n        protocol = fp.getProperty(MailConstants.RECV_PROTO);\n        host = fp.getProperty(MailConstants.RECV_HOST);\n        user = fp.getProperty(MailConstants.RECV_USER);\n        password = fp.getProperty(MailConstants.RECV_PASS);\n        root = fp.getProperty(MailConstants.RECV_ROOT);\n    } else // If not, assume listing all args in long form.\n    if (argv.length == 5) {\n        protocol = argv[0];\n        host = argv[1];\n        user = argv[2];\n        password = argv[3];\n        root = argv[4];\n    } else // Otherwise give up.\n    {\n        System.err.println(\"Usage: MailLister protocol host user pw root\");\n        System.exit(0);\n    }\n    boolean recursive = false;\n    // Start with a JavaMail Session object\n    Session session = Session.getDefaultInstance(System.getProperties(), null);\n    session.setDebug(false);\n    // Get a Store object for the given protocol\n    Store store = session.getStore(protocol);\n    if (password.equals(\"*\")) {\n        final char[] passBytes = System.console().readPassword(\"Password:\", (Object[]) null);\n        password = new String(passBytes);\n    }\n    store.connect(host, user, password);\n    // Get Folder object for root, and list it\n    // If root name = \"\", getDefaultFolder(), else getFolder(root)\n    Folder rf;\n    if (root.length() != 0) {\n        System.out.println(\"Getting folder \" + root + \".\");\n        rf = store.getFolder(root);\n    } else {\n        System.out.println(\"Getting default folder.\");\n        rf = store.getDefaultFolder();\n    }\n    rf.open(Folder.READ_WRITE);\n    if (rf.getType() == Folder.HOLDS_FOLDERS) {\n        Folder[] fs = rf.list();\n        for (Folder f : fs) {\n            listFolder(f, \"\", recursive);\n        }\n    } else {\n        listFolder(rf, \"\", false);\n    }\n}\n","name":"main","className":"MailLister","variables":{"fileName":3,"session":3,"f":1,"fp":7,"store":4,"argv":6,"fs":2,"System":3,"recursive":1,"protocol":3,"password":5,"rf":6,"root":5,"host":3,"user":3,"passBytes":2,"Session":1},"constants":{"\"\"":2,"false":3,"0":4,"\"Getting default folder.\"":1,"1":2,"2":1,"\"Password:\"":1,"3":1,"null":7,"4":1,"5":1,"\".\"":1,"\"Usage: MailLister protocol host user pw root\"":1,"\"Getting folder \"":1,"\"*\"":1},"javaDoc":"","comments":"Get Folder object for root and list it If argc == 1 assume it's a Properties file If not assume listing all args in long form Otherwise give up Start with a JavaMail Session object Get a Store object for the given protocol If root name = \"\" getDefaultFolder() else getFolder(root) ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Folder","String","boolean"],"returnType":"void","methodCalls":{"hasNewMessages":1,"getSubject":1,"getName":1,"listFolder":1,"format":2,"list":1,"getMessages":1,"isSubscribed":1,"getType":2,"toString":2,"getFullName":1,"open":1,"append":1,"System.out.println":6,"getFrom":1},"annotations":[],"exceptions":["Exception"],"concepts":["Recursion"],"types":{"StringBuffer":1,"Folder[]":1,"Message[]":1,"Message":1,"Address":1,"String":1,"Folder":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":7,"ArrayAccessExpr":1,"BinaryExpr":14,"NameExpr":109,"StringLiteralExpr":7,"CharLiteralExpr":2,"UnaryExpr":1,"InstanceOfExpr":1,"AssignExpr":2,"NullLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":9,"EnclosedExpr":3,"MethodCallExpr":24},"statements":{"IfStmt":6,"BlockStmt":5,"ForeachStmt":2,"ExpressionStmt":18},"text":"static void listFolder(Folder folder, String tab, boolean recurse) throws Exception {\n    folder.open(Folder.READ_WRITE);\n    System.out.println(tab + \"Name: \" + folder.getName() + '(' + folder.getFullName() + ')');\n    if (!folder.isSubscribed())\n        System.out.println(tab + \"Not Subscribed\");\n    if ((folder.getType() & Folder.HOLDS_MESSAGES) != 0) {\n        if (folder.hasNewMessages())\n            System.out.println(tab + \"Has New Messages\");\n        else\n            System.out.println(tab + \"No New Messages\");\n        Message[] msgs = folder.getMessages();\n        for (Message m : msgs) {\n            Address from = m.getFrom()[0];\n            String fromAddress;\n            if (from instanceof InternetAddress)\n                fromAddress = ((InternetAddress) from).getAddress();\n            else\n                fromAddress = from.toString();\n            StringBuffer sb = new StringBuffer();\n            fromFmt.format(fromAddress, sb, null);\n            sb.append(\"  \");\n            subjFmt.format(m.getSubject(), sb, null);\n            System.out.println(sb.toString());\n        }\n    }\n    if ((folder.getType() & Folder.HOLDS_FOLDERS) != 0) {\n        System.out.println(tab + \"Is Directory\");\n    }\n    if (recurse) {\n        Folder[] fs = folder.list();\n        for (Folder f : fs) {\n            listFolder(f, tab + \"\", recurse);\n        }\n    }\n}\n","name":"listFolder","className":"MailLister","variables":{"msgs":2,"fromFmt":1,"folder":9,"tab":6,"recurse":1,"f":1,"from":4,"fromAddress":3,"subjFmt":1,"m":3,"fs":2,"sb":3},"constants":{"0":3,"\"\"":1,"\"No New Messages\"":1,"\"Is Directory\"":1,"null":2,"')'":1,"'('":1,"\"Not Subscribed\"":1,"\"Has New Messages\"":1,"\"Name: \"":1,"\"  \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":[],"returnType":"MailComposeBean","methodCalls":{"add":1,"toFront":1,"setLocation":1,"setContentPane":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MailComposeBean":1,"JInternalFrame":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"StringLiteralExpr":1,"NameExpr":20,"ThisExpr":1,"MethodCallExpr":5,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":7},"text":"/** To be useful here, a MailComposeBean has to be inside\n     * its own little JInternalFrame. \n     */\npublic MailComposeBean newSend() {\n    // Make the JInternalFrame wrapper\n    JInternalFrame jf = new JInternalFrame();\n    // Bake the actual Bean\n    MailComposeBean newBean = new MailComposeBean(this, \"Compose\", 400, 250);\n    // Arrange them on the diagonal.\n    jf.setLocation(nx += 10, ny += 10);\n    // Make the new Bean be the contents of the JInternalFrame\n    jf.setContentPane(newBean);\n    jf.pack();\n    jf.toFront();\n    // Add the JInternalFrame to the JDesktopPane\n    dtPane.add(jf);\n    return newBean;\n}\n","name":"newSend","className":"MailComposeFrame","variables":{"newBean":2,"dtPane":1,"nx":1,"ny":1,"jf":5},"constants":{"400":1,"\"Compose\"":1,"250":1,"10":2},"javaDoc":"To be useful here a MailComposeBean has to be inside its own little JInternalFrame","comments":"Make the JInternalFrame wrapper Bake the actual Bean Arrange them on the diagonal Make the new Bean be the contents of the JInternalFrame Add the JInternalFrame to the JDesktopPane  To be useful here, a MailComposeBean has to be inside\n     * its own little JInternalFrame. \n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"newSend":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    newSend();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MailComposeFrame","methodCalls":{"add":2,"newSend":1,"addActionListener":1,"setLayout":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":4,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":5,"AssignExpr":2},"statements":{"BlockStmt":1,"ExpressionStmt":7},"text":"/* Construct a MailComposeFrame, with a Compose button. */\npublic MailComposeFrame() {\n    setLayout(new BorderLayout());\n    dtPane = new JDesktopPane();\n    add(dtPane, BorderLayout.CENTER);\n    newButton = new JButton(\"Compose\");\n    newButton.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            newSend();\n        }\n    });\n    add(newButton, BorderLayout.SOUTH);\n}\n","name":"MailComposeFrame","className":"MailComposeFrame","variables":{"actionPerformed":1,"dtPane":1,"e":1,"newButton":2},"constants":{"\"Compose\"":1},"javaDoc":"","comments":" Construct a MailComposeFrame, with a Compose button. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":2,"converse":1,"getMessage":1,"System.err.println":2,"getCode":1,"System.out.println":1},"annotations":[],"exceptions":["SMTPException"],"concepts":["ExceptionHandling"],"types":{"SmtpTalk":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":36,"StringLiteralExpr":5,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":7},"text":"/** \n     * A simple main program showing the class in action.\n     *\n     * Could generalize to accept From arg, read msg on stdin\n     */\npublic static void main(String argv[]) {\n    if (argv.length != 2) {\n        System.err.println(\"Usage: java SmtpTalk host user\");\n        System.exit(EX_USAGE);\n    }\n    try {\n        SmtpTalk st = new SmtpTalk(argv[0]);\n        System.out.println(\"SMTP Talker ready\");\n        st.converse(\"mailer-daemon\", argv[1], \"Test message\", \"Hello there\");\n    } catch (SMTPException ig) {\n        System.err.println(ig.getMessage());\n        System.exit(ig.getCode());\n    }\n}\n","name":"main","className":"SmtpTalk","variables":{"st":2,"argv":2,"System":2,"ig":3},"constants":{"0":1,"1":1,"2":1,"\"SMTP Talker ready\"":1,"\"Usage: java SmtpTalk host user\"":1,"\"mailer-daemon\"":1,"\"Test message\"":1,"\"Hello there\"":1},"javaDoc":"A simple main program showing the class in action Could generalize to accept From arg read msg on stdin","comments":" \n     * A simple main program showing the class in action.\n     *\n     * Could generalize to accept From arg, read msg on stdin\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"SmtpTalk","methodCalls":{"die":4,"getOutputStream":1,"getInputStream":1},"annotations":[],"exceptions":["UnknownHostException","IOException","NoRouteToHostException","ConnectException"],"concepts":["ExceptionHandling"],"types":{"Socket":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":27,"StringLiteralExpr":4,"AssignExpr":3,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":5,"ExpressionStmt":7},"text":"/** Constructor taking a server hostname as argument.\n     */\nSmtpTalk(String server) {\n    host = server;\n    try (Socket s = new Socket(host, 25)) {\n        is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        os = new PrintStream(s.getOutputStream());\n    } catch (NoRouteToHostException e) {\n        die(EX_TEMPFAIL, \"No route to host \" + host);\n    } catch (ConnectException e) {\n        die(EX_TEMPFAIL, \"Connection Refused by \" + host);\n    } catch (UnknownHostException e) {\n        die(EX_NOHOST, \"Unknown host \" + host);\n    } catch (IOException e) {\n        die(EX_IOERR, \"I/O error setting up socket streams\\n\" + e);\n    }\n}\n","name":"SmtpTalk","className":"SmtpTalk","variables":{"server":1,"s":3,"os":1,"e":5,"host":5,"is":1},"constants":{"\"I/O error setting up socket streams\\n\"":1,"25":1,"\"Connection Refused by \"":1,"\"Unknown host \"":1,"\"No route to host \"":1},"javaDoc":"Constructor taking a server hostname as argument","comments":" Constructor taking a server hostname as argument.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"die":1,"readLine":1,"System.out.println":1,"startsWith":1},"annotations":[],"exceptions":["SMTPException","IOException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":20,"StringLiteralExpr":4,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"protected boolean expect_reply(String rspNum) throws SMTPException {\n    String s = null;\n    try {\n        s = is.readLine();\n    } catch (IOException e) {\n        die(EX_IOERR, \"I/O error reading from host \" + host + \" \" + e);\n    }\n    if (debug)\n        System.out.println(\"<<< \" + s);\n    return s.startsWith(rspNum + \" \");\n}\n","name":"expect_reply","className":"SmtpTalk","variables":{"s":4,"debug":1,"e":2,"rspNum":1,"host":1,"is":1},"constants":{"\"<<< \"":1,"null":1,"\" \"":2,"\"I/O error reading from host \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"send_cmd":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"protected void send_cmd(String cmd, String oprnd) {\n    send_cmd(cmd + \" \" + oprnd);\n}\n","name":"send_cmd","className":"SmtpTalk","variables":{"oprnd":1,"cmd":1},"constants":{"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"protected void send_cmd(String cmd) {\n    if (debug)\n        System.out.println(\">>> \" + cmd);\n    os.print(cmd + \"\\r\\n\");\n}\n","name":"send_cmd","className":"SmtpTalk","variables":{"debug":1,"os":1,"cmd":2},"constants":{"\"\\r\\n\"":1,"\">>> \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Send_text sends the body of the message. */\npublic void send_text(String text) {\n    os.print(text + \"\\r\\n\");\n}\n","name":"send_text","className":"SmtpTalk","variables":{"os":1,"text":1},"constants":{"\"\\r\\n\"":1},"javaDoc":"Send_text sends the body of the message","comments":" Send_text sends the body of the message. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["SMTPException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2},"statements":{"ThrowStmt":1},"text":"/** Convenience routine to print message & exit, like\n     * K&P error(), perl die(1,), ...\n     * @param    ret    Numeric value to pass back\n     * @param    msg    Error message to be printed on stdout.\n     */\nprotected void die(int ret, String msg) {\n    throw new SMTPException(ret, msg);\n}\n","name":"die","className":"SmtpTalk","variables":{"ret":1,"msg":1},"constants":{},"javaDoc":"Convenience routine to print message & exit like K&P error() perl die(1 ) ret Numeric value to pass back msg Error message to be printed on stdout","comments":" Convenience routine to print message & exit, like\n     * K&P error(), perl die(1,), ...\n     * @param    ret    Numeric value to pass back\n     * @param    msg    Error message to be printed on stdout.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","String","String","String"],"returnType":"void","methodCalls":{"expect_reply":7,"die":7,"hasMoreTokens":1,"send_text":5,"nextToken":1,"send_cmd":6},"annotations":[],"exceptions":["SMTPException"],"concepts":[],"types":{"StringTokenizer":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":9,"NameExpr":71,"StringLiteralExpr":30,"UnaryExpr":7,"MethodCallExpr":27},"statements":{"IfStmt":7,"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":20},"text":"/** send one Mail message to one or more recipients via smtp \n     * to server \"host\".\n     */\npublic void converse(String sender, String recipients, String subject, String body) throws SMTPException {\n    StringTokenizer st = new StringTokenizer(recipients);\n    if (!expect_reply(\"220\"))\n        die(EX_PROTOCOL, \"did not get SMTP greeting\");\n    send_cmd(\"HELO\", \"darwinsys.com\");\n    if (!expect_reply(\"250\"))\n        die(EX_PROTOCOL, \"did not ack our HELO\");\n    // no spaces!\n    send_cmd(\"MAIL\", \"From:<\" + sender + \">\");\n    if (!expect_reply(\"250\"))\n        die(EX_PROTOCOL, \"did not ack our MAIL\");\n    while (st.hasMoreTokens()) {\n        String r = st.nextToken();\n        send_cmd(\"RCPT\", \"To:<\" + r + \">\");\n        if (!expect_reply(\"250\"))\n            die(EX_PROTOCOL, \"didn't ack RCPT \" + r);\n    }\n    send_cmd(\"DATA\");\n    if (!expect_reply(\"354\"))\n        die(EX_PROTOCOL, \"did not want our DATA!\");\n    send_text(\"From: \" + sender);\n    send_text(\"To: \" + recipients);\n    send_text(\"Subject: \" + subject);\n    send_text(\"\");\n    send_text(body + \"\\r\");\n    send_cmd(\".\");\n    if (!expect_reply(\"250\"))\n        die(EX_PROTOCOL, \"Mail not accepted\");\n    send_cmd(\"QUIT\");\n    if (!expect_reply(\"221\"))\n        die(EX_PROTOCOL, \"Other end not closing down\");\n}\n","name":"converse","className":"SmtpTalk","variables":{"st":3,"r":3,"sender":2,"recipients":2,"subject":1,"body":1},"constants":{"\"darwinsys.com\"":1,"\"\"":1,"\"Mail not accepted\"":1,"\"354\"":1,"\"221\"":1,"\">\"":2,"\"From:<\"":1,"\"To: \"":1,"\"MAIL\"":1,"\"RCPT\"":1,"\"did not ack our MAIL\"":1,"\"Subject: \"":1,"\"To:<\"":1,"\"Other end not closing down\"":1,"\".\"":1,"\"did not get SMTP greeting\"":1,"\"HELO\"":1,"\"did not ack our HELO\"":1,"\"250\"":4,"\"220\"":1,"\"From: \"":1,"\"did not want our DATA!\"":1,"\"QUIT\"":1,"\"DATA\"":1,"\"\\r\"":1,"\"didn't ack RCPT \"":1},"javaDoc":"send one Mail message to one or more recipients via smtp to server \"host\"","comments":"no spaces!  send one Mail message to one or more recipients via smtp \n     * to server \"host\".\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getDefaultInstance":1,"addRecipient":2,"setSubject":1,"printStackTrace":1,"setFrom":1,"getNextException":1,"setDebug":1,"send":1,"put":1,"setText":1},"annotations":[],"exceptions":["MessagingException"],"concepts":["ExceptionHandling"],"types":{"InternetAddress":2,"Properties":1},"expressions":{"ObjectCreationExpr":5,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":55,"StringLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":11,"AssignExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":14},"text":"/** Do the work: send the mail to the SMTP server.  */\npublic void doSend() {\n    // We need to pass info to the mail server as a Properties, since\n    // JavaMail (wisely) allows room for LOTS of properties...\n    Properties props = new Properties();\n    // Your LAN must define the local SMTP server as \"mailhost\"\n    // for this simple-minded version to be able to send mail...\n    props.put(\"mail.smtp.host\", \"mailhost\");\n    // Create the Session object\n    session = Session.getDefaultInstance(props, null);\n    // Verbose!\n    session.setDebug(true);\n    try {\n        // create a message\n        mesg = new MimeMessage(session);\n        // From Address - this should come from a Properties...\n        mesg.setFrom(new InternetAddress(\"nobody@host.domain\"));\n        // TO Address \n        InternetAddress toAddress = new InternetAddress(message_recip);\n        mesg.addRecipient(Message.RecipientType.TO, toAddress);\n        // CC Address\n        InternetAddress ccAddress = new InternetAddress(message_cc);\n        mesg.addRecipient(Message.RecipientType.CC, ccAddress);\n        // The Subject\n        mesg.setSubject(message_subject);\n        // Now the message body.\n        mesg.setText(message_body);\n        // XXX I18N: use setText(msgText.getText(), charset)\n        // Finally, send the message!\n        Transport.send(mesg);\n    } catch (MessagingException ex) {\n        while ((ex = (MessagingException) ex.getNextException()) != null) {\n            ex.printStackTrace();\n        }\n    }\n}\n","name":"doSend","className":"Sender","variables":{"message_cc":1,"ex":4,"session":3,"message_recip":1,"Transport":1,"toAddress":1,"props":2,"Session":1,"mesg":6,"ccAddress":1},"constants":{"null":2,"true":1,"\"mail.smtp.host\"":1,"\"nobody@host.domain\"":1,"\"mailhost\"":1},"javaDoc":"Do the work: send the mail to the SMTP server","comments":"We need to pass info to the mail server as a Properties since Your LAN must define the local SMTP server as \"mailhost\" JavaMail (wisely) allows room for LOTS of properties for this simple-minded version to be able to send mail Create the Session object Verbose! XXX I18N: use setText(msgText getText() charset) create a message From Address - this should come from a Properties TO Address CC Address The Subject Now the message body Finally send the message!  Do the work: send the mail to the SMTP server.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"doSend":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Sender":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Simple test case driver */\npublic static void main(String[] av) {\n    Sender sm = new Sender();\n    sm.doSend();\n}\n","name":"main","className":"Sender","variables":{"sm":2},"constants":{},"javaDoc":"Simple test case driver","comments":" Simple test case driver ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["WebProxy"],"returnType":"Handler","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Construct a Handler */\nHandler(WebProxy parent) {\n    this.parent = parent;\n}\n","name":"Handler","className":"Handler","variables":{"parent":1},"constants":{},"javaDoc":"Construct a Handler","comments":" Construct a Handler ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Socket"],"returnType":"void","methodCalls":{"getInetAddress":1,"countTokens":1,"printStackTrace":1,"length":2,"getProtocol":1,"readLine":2,"getInputStream":1,"errorResponse":6,"substring":2,"put":1,"println":1,"trim":1,"flush":1,"nextToken":3,"getOutputStream":1,"System.err.println":2,"returnURL":1,"close":5,"indexOf":1,"System.out.println":4},"annotations":[],"exceptions":["FileNotFoundException","IOException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"Map<String, String>":1,"StringTokenizer":1,"HashMap":1,"String":7,"int":1,"URL":1,"RequestType":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":12,"VariableDeclarationExpr":12,"BinaryExpr":24,"NameExpr":175,"StringLiteralExpr":20,"CharLiteralExpr":1,"UnaryExpr":2,"AssignExpr":9,"NullLiteralExpr":2,"FieldAccessExpr":11,"EnclosedExpr":2,"MethodCallExpr":42},"statements":{"IfStmt":8,"WhileStmt":1,"TryStmt":1,"BlockStmt":11,"ReturnStmt":5,"ExpressionStmt":41},"text":"public void process(Socket clntSock) {\n    // what Viewer sends us.\n    String request;\n    RequestType methodType = RequestType.RQ_INVALID;\n    try {\n        System.out.println(\"Connection accepted from \" + clntSock.getInetAddress());\n        is = new BufferedReader(new InputStreamReader(clntSock.getInputStream()));\n        // Must do before any chance of errorResponse being called!\n        os = new PrintStream(clntSock.getOutputStream());\n        request = is.readLine();\n        if (request == null || request.length() == 0) {\n            // No point nattering: the sock died, nobody will hear\n            // us if we scream into cyberspace... \n            System.err.println(\"The sock has died...\");\n            return;\n        }\n        // Use a StringTokenizer to break the request into its three parts:\n        // HTTP method, resource name, and HTTP version\n        StringTokenizer st = new StringTokenizer(request);\n        if (st.countTokens() != 3) {\n            errorResponse(444, \"Unparseable input \" + request);\n            clntSock.close();\n            return;\n        }\n        String requestCommand = st.nextToken();\n        requestURL = st.nextToken();\n        String requestHTTPVersion = st.nextToken();\n        System.out.println(\"Request: Command \" + requestCommand + \", file \" + requestURL + \", version \" + requestHTTPVersion);\n        // First, check that rqCode is either GET or HEAD or ...\n        if (\"get\".equalsIgnoreCase(requestCommand))\n            methodType = RequestType.RQ_GET;\n        else if (\"head\".equalsIgnoreCase(requestCommand))\n            methodType = RequestType.RQ_HEAD;\n        else if (\"post\".equalsIgnoreCase(requestCommand))\n            methodType = RequestType.RQ_POST;\n        else {\n            errorResponse(400, \"invalid method: \" + requestCommand);\n            clntSock.close();\n            return;\n        }\n        // Read headers, up to the null line before the body,\n        // so the body can be read directly if it's a POST.\n        Map<String, String> headersMap = new HashMap<String, String>();\n        String hdrLine;\n        while ((hdrLine = is.readLine()) != null && hdrLine.length() != 0) {\n            int ix;\n            if ((ix = hdrLine.indexOf(':')) != -1) {\n                String hdrName = hdrLine.substring(0, ix);\n                String hdrValue = hdrLine.substring(ix + 1).trim();\n                Debug.println(\"hdr\", hdrName + \",\" + hdrValue);\n                headersMap.put(hdrName, hdrValue);\n            } else {\n                System.err.println(\"INVALID HEADER: \" + hdrLine);\n            }\n        }\n        if (methodType == RequestType.RQ_POST) {\n            errorResponse(501, \"Protocol not written yet\");\n            clntSock.close();\n            return;\n        }\n        // Make a URL from the request\n        URL url = new URL(requestURL);\n        String protocol = url.getProtocol();\n        if (!\"http\".equals(protocol)) {\n            errorResponse(401, \"protocol not supported: \" + requestURL);\n            clntSock.close();\n            return;\n        }\n        returnURL(url, os);\n        os.flush();\n        clntSock.close();\n        System.out.println(\"END OF REQUEST\");\n    } catch (FileNotFoundException e) {\n        errorResponse(404, \"Server can't find \" + requestURL);\n    } catch (IOException e) {\n        errorResponse(500, \"IO Error on proxy\");\n        System.out.println(\"IOException \" + e);\n        e.printStackTrace();\n    }\n}\n","name":"process","className":"Handler","variables":{"hdrValue":2,"request":6,"st":5,"os":2,"e":4,"clntSock":8,"is":3,"requestHTTPVersion":2,"url":2,"ix":3,"protocol":1,"methodType":5,"requestURL":5,"hdrName":2,"headersMap":2,"hdrLine":7,"Debug":1,"requestCommand":3},"constants":{"\"INVALID HEADER: \"":1,"\"hdr\"":1,"\"post\"":1,"\"IOException \"":1,"\"Protocol not written yet\"":1,"\"http\"":1,"\"head\"":1,"\", file \"":1,"':'":1,"\",\"":1,"\"Request: Command \"":1,"\"Unparseable input \"":1,"\"The sock has died...\"":1,"\"get\"":1,"\"protocol not supported: \"":1,"\"Server can't find \"":1,"\"invalid method: \"":1,"0":3,"1":2,"\"END OF REQUEST\"":1,"\", version \"":1,"3":1,"\"Connection accepted from \"":1,"null":2,"444":1,"400":1,"401":1,"500":1,"501":1,"404":1,"\"IO Error on proxy\"":1},"javaDoc":"","comments":"what Viewer sends us Use a StringTokenizer to break the request into its three parts: Read headers up to the null line before the body Must do before any chance of errorResponse being called! No point nattering: the sock died nobody will hear us if we scream into cyberspace HTTP method resource name and HTTP version First check that rqCode is either GET or HEAD or so the body can be read directly if it's a POST Make a URL from the request ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["URL","PrintStream"],"returnType":"void","methodCalls":{"read":1,"openStream":1,"write":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"InputStream":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":11,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"private void returnURL(URL url, PrintStream os) throws IOException {\n    InputStream is = url.openStream();\n    int c;\n    while ((c = is.read()) != -1) {\n        os.write(c);\n    }\n}\n","name":"returnURL","className":"Handler","variables":{"c":2,"os":1,"is":2,"url":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int","String"],"returnType":"void","methodCalls":{"println":12,"toString":1,"getString":1,"System.err.println":1,"close":1,"getBundle":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling"],"types":{"ResourceBundle":1,"String":2},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":16,"NameExpr":69,"StringLiteralExpr":19,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":17},"statements":{"IfStmt":1,"TryStmt":2,"BlockStmt":5,"ExpressionStmt":20},"text":"/** Sends an error response, by number, hopefully localized. */\nprotected void errorResponse(final int errNum, final String errMsg) {\n    // Check for localized messages\n    ResourceBundle messages = null;\n    try {\n        messages = ResourceBundle.getBundle(\"errors\");\n    } catch (MissingResourceException e) {\n        System.err.println(e);\n    }\n    String response = errMsg;\n    if (messages != null) {\n        try {\n            response = messages.getString(Integer.toString(errNum));\n        } catch (MissingResourceException e) {\n            response = errMsg;\n        }\n    }\n    // Generate and send the response\n    os.println(\"HTTP/1.0 \" + errNum + \" \" + response);\n    os.println(\"Content-type: text/html\");\n    os.println();\n    os.println(\"<html>\");\n    os.println(\"<head><title>Error \" + errNum + \"--\" + response + \"</title></head>\");\n    os.println(\"<h1>\" + errNum + \" \" + response + \"</h1>\");\n    os.println(\"<hr>\");\n    os.println(\"<address>Java Web Proxy,\");\n    String myAddr = \"http://www.darwinsys.com/freeware/\";\n    os.println(\"<a href=\\\"\" + myAddr + \"\\\">\" + myAddr + \"</a>\");\n    os.println(\"</address>\");\n    os.println(\"</html>\");\n    os.println();\n    os.close();\n}\n","name":"errorResponse","className":"Handler","variables":{"Integer":1,"os":13,"e":2,"errNum":3,"myAddr":3,"response":6,"errMsg":2,"messages":4,"ResourceBundle":1},"constants":{"\"<head><title>Error \"":1,"\"<html>\"":1,"\" \"":2,"\"<h1>\"":1,"\"\\\">\"":1,"\"<hr>\"":1,"\"<a href=\\\"\"":1,"\"</html>\"":1,"\"Content-type: text/html\"":1,"\"</address>\"":1,"\"--\"":1,"\"<address>Java Web Proxy,\"":1,"null":2,"\"errors\"":1,"\"</a>\"":1,"\"http://www.darwinsys.com/freeware/\"":1,"\"HTTP/1.0 \"":1,"\"</title></head>\"":1,"\"</h1>\"":1},"javaDoc":"Sends an error response by number hopefully localized","comments":"Check for localized messages Generate and send the response  Sends an error response, by number, hopefully localized. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createQuery":1,"forEach":1,"buildSessionFactory":1,"save":1,"commit":1,"getId":1,"configure":1,"list":1,"getLastName":1,"beginTransaction":2,"size":1,"openSession":1,"getFirstName":1,"close":1,"System.out.println":6},"annotations":["SuppressWarnings"],"exceptions":[],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"SessionFactory":1,"List<Person>":1,"Configuration":1,"Transaction":1,"Query":1,"AnnotationConfiguration":1,"Person":1,"int":1,"Session":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":8,"BinaryExpr":6,"LambdaExpr":1,"NameExpr":82,"StringLiteralExpr":7,"FieldAccessExpr":6,"CharLiteralExpr":1,"MethodCallExpr":21,"AssignExpr":3},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":22},"text":"@SuppressWarnings(\"unchecked\")\npublic static void main(String[] args) {\n    System.out.println(\"HibernateSimple.main()\");\n    Configuration cf = new AnnotationConfiguration();\n    cf.configure();\n    SessionFactory sf = null;\n    Session session = null;\n    try {\n        sf = cf.buildSessionFactory();\n        session = sf.openSession();\n        Transaction tx = session.beginTransaction();\n        // Create an entity in the database.\n        Person np = new Person(\"Tom\", \"Boots\");\n        System.out.println(np);\n        session.save(np);\n        tx.commit();\n        int id = np.getId();\n        System.out.println(\"Created Person with Id \" + id);\n        tx = session.beginTransaction();\n        Query query = session.createQuery(\"select p from Person p order by p.lastName\");\n        List<Person> list = query.list();\n        System.out.println(\"There are \" + list.size() + \" persons:\");\n        list.forEach( p -> System.out.println(p.getFirstName() + ' ' + p.getLastName()));\n        System.out.println();\n    } finally {\n        if (session != null) {\n            session.close();\n        }\n    }\n}\n","name":"main","className":"HibernateSimple","variables":{"p":3,"np":2,"cf":3,"sf":3,"tx":3,"session":8,"query":2,"id":2,"list":3},"constants":{"\" persons:\"":1,"\"HibernateSimple.main()\"":1,"\"There are \"":1,"null":3,"\"Tom\"":1,"\"select p from Person p order by p.lastName\"":1,"\"Boots\"":1,"\"Created Person with Id \"":1,"' '":1},"javaDoc":"","comments":"Create an entity in the database ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"forName":1,"prepareStatement":1,"readLine":1,"setInt":1,"createStatement":1,"getConnection":1,"setString":7,"nextToken":8,"close":3,"indexOf":2,"System.out.println":3,"executeUpdate":4,"startsWith":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"StringTokenizer":1,"Statement":1,"BufferedReader":1,"Connection":1,"PreparedStatement":1,"String":9,"int":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"IntegerLiteralExpr":11,"VariableDeclarationExpr":15,"BinaryExpr":12,"NameExpr":129,"StringLiteralExpr":23,"FieldAccessExpr":5,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":34,"AssignExpr":3},"statements":{"ContinueStmt":1,"IfStmt":4,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":36},"text":"public static void main(String[] fn) throws Exception {\n    BufferedReader is = new BufferedReader(new FileReader(TEXT_NAME));\n    // Load the database driver\n    Class.forName(\"jdbc.idbDriver\");\n    System.out.println(\"Getting Connection\");\n    Connection conn = DriverManager.getConnection(DB_URL, \"admin\", // user, password\n    \"\");\n    System.out.println(\"Creating Statement\");\n    Statement stmt = conn.createStatement();\n    System.out.println(\"Re-creating table and index\");\n    if (dropAndReCreate)\n        stmt.executeUpdate(\"DROP TABLE IF EXISTS users\");\n    stmt.executeUpdate(\"CREATE TABLE users (\\n\" + \"name     char(12) PRIMARY KEY,\\n\" + \"password char(20),\\n\" + \"fullName char(30),\\n\" + \"email    char(60),\\n\" + \"city     char(20),\\n\" + \"prov     char(20),\\n\" + \"country  char(20),\\n\" + \"privs    int\\n\" + \")\");\n    stmt.executeUpdate(\"CREATE INDEX nickIndex ON users (name)\");\n    stmt.close();\n    // put the data in the table\n    PreparedStatement ps = conn.prepareStatement(\"INSERT INTO users VALUES (?,?,?,?,?,?,?,?)\");\n    String line;\n    while ((line = is.readLine()) != null) {\n        if (line.startsWith(\"#\")) {\n            // comment\n            continue;\n        }\n        StringTokenizer st = new StringTokenizer(line, \":\");\n        String nick = st.nextToken();\n        String pass = st.nextToken();\n        String full = st.nextToken();\n        String email = st.nextToken();\n        String city = st.nextToken();\n        String prov = st.nextToken();\n        String ctry = st.nextToken();\n        // User u = new User(nick, pass, full, email,\n        //    city, prov, ctry);\n        String privs = st.nextToken();\n        int iprivs = 0;\n        if (privs.indexOf(\"A\") != -1) {\n            iprivs |= User.P_ADMIN;\n        }\n        if (privs.indexOf(\"E\") != -1) {\n            iprivs |= User.P_EDIT;\n        }\n        ps.setString(1, nick);\n        ps.setString(2, pass);\n        ps.setString(3, full);\n        ps.setString(4, email);\n        ps.setString(5, city);\n        ps.setString(6, prov);\n        ps.setString(7, ctry);\n        ps.setInt(8, iprivs);\n        ps.executeUpdate();\n    }\n    // All done with that statement\n    ps.close();\n    // All done with that DB connection\n    conn.close();\n    // All done with this program.\n    return;\n}\n","name":"main","className":"TextToJDBC","variables":{"st":9,"conn":4,"ps":11,"pass":1,"city":1,"line":4,"is":2,"dropAndReCreate":1,"nick":1,"ctry":1,"iprivs":3,"Class":1,"privs":3,"TEXT_NAME":1,"DriverManager":1,"prov":1,"stmt":5,"email":1,"full":1},"constants":{"\"#\"":1,"\"email    char(60),\\n\"":1,"\"CREATE INDEX nickIndex ON users (name)\"":1,"\"jdbc.idbDriver\"":1,"\"DROP TABLE IF EXISTS users\"":1,"\":\"":1,"\"Getting Connection\"":1,"\"password char(20),\\n\"":1,"\"INSERT INTO users VALUES (?,?,?,?,?,?,?,?)\"":1,"\"Re-creating table and index\"":1,"\"admin\"":1,"\"privs    int\\n\"":1,"\"prov     char(20),\\n\"":1,"\"country  char(20),\\n\"":1,"\"CREATE TABLE users (\\n\"":1,"\"E\"":1,"\"fullName char(30),\\n\"":1,"\"A\"":1,"\"Creating Statement\"":1,"\"name     char(12) PRIMARY KEY,\\n\"":1,"\"city     char(20),\\n\"":1,"0":1,"1":3,"2":1,"3":1,"null":1,"4":1,"5":1,"6":1,"7":1,"8":1,"\")\"":1},"javaDoc":"","comments":"Load the database driver user password put the data in the table User u = new User(nick pass full email comment city prov ctry); All done with that statement All done with that DB connection All done with this program ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createStatement":1,"next":1,"getConnection":1,"exit":1,"getProperty":2,"forName":1,"getString":2,"close":3,"System.out.println":2,"executeQuery":1},"annotations":[],"exceptions":["SQLException","IOException","ClassNotFoundException"],"concepts":[],"types":{"Statement":1,"Connection":1,"ResultSet":1,"String":2},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":3,"NameExpr":51,"StringLiteralExpr":6,"FieldAccessExpr":2,"MethodCallExpr":15},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":12},"text":"public static void main(String[] fn) throws ClassNotFoundException, SQLException, IOException {\n    // Load the database driver\n    Class.forName(JDConstants.getProperty(\"jabadot.jabadb.driver\"));\n    System.out.println(\"Getting Connection\");\n    Connection conn = DriverManager.getConnection(JDConstants.getProperty(\"jabadot.dburl\"));\n    Statement stmt = conn.createStatement();\n    ResultSet rs = stmt.executeQuery(\"SELECT * from jabadb where name='ian'\");\n    // Now retrieve (all) the rows that matched the query\n    while (rs.next()) {\n        // Field 1 is login name\n        String name = rs.getString(1);\n        // Password is field 2 - do not display.\n        // Column 3 is fullname\n        String fullName = rs.getString(3);\n        System.out.println(\"User \" + name + \" is named \" + fullName);\n    }\n    // All done with that resultset\n    rs.close();\n    // All done with that statement\n    stmt.close();\n    // All done with that DB connection\n    conn.close();\n    // All done with this program.\n    System.exit(0);\n}\n","name":"main","className":"UserQuery","variables":{"JDConstants":2,"rs":5,"conn":3,"name":2,"fullName":2,"Class":1,"DriverManager":1,"stmt":3,"System":1},"constants":{"0":1,"1":1,"3":1,"\"jabadot.dburl\"":1,"\"jabadot.jabadb.driver\"":1,"\" is named \"":1,"\"SELECT * from jabadb where name='ian'\"":1,"\"User \"":1,"\"Getting Connection\"":1},"javaDoc":"","comments":"Load the database driver Now retrieve (all) the rows that matched the query Password is field 2 - do not display Field 1 is login name Column 3 is fullname All done with that resultset All done with that statement All done with that DB connection All done with this program ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createEntityManagerFactory":1,"createQuery":1,"forEach":1,"createEntityManager":1,"commit":1,"getId":1,"getLastName":1,"size":1,"getResultList":1,"persist":1,"begin":2,"getFirstName":1,"close":2,"System.out.println":5,"getTransaction":2},"annotations":["SuppressWarnings"],"exceptions":[],"concepts":["ExceptionHandling"],"types":{"EntityTransaction":1,"EntityManager":1,"List<Person>":1,"Query":1,"EntityManagerFactory":1,"Person":1,"int":1},"expressions":{"NullLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":7,"LambdaExpr":1,"NameExpr":84,"StringLiteralExpr":8,"FieldAccessExpr":5,"CharLiteralExpr":1,"MethodCallExpr":22,"AssignExpr":3},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":22},"text":"@SuppressWarnings(\"unchecked\")\npublic static void main(String[] args) {\n    System.out.println(\"JPASimple.main()\");\n    EntityManagerFactory entityMgrFactory = null;\n    EntityManager entityManager = null;\n    try {\n        entityMgrFactory = Persistence.createEntityManagerFactory(\"jpademo\");\n        entityManager = entityMgrFactory.createEntityManager();\n        EntityTransaction transaction = entityManager.getTransaction();\n        transaction.begin();\n        // Create an entity in the database.\n        Person np = new Person(\"Tom\", \"Boots\");\n        System.out.println(np);\n        entityManager.persist(np);\n        transaction.commit();\n        int id = np.getId();\n        System.out.println(\"Created Person with Id \" + id);\n        transaction = entityManager.getTransaction();\n        transaction.begin();\n        Query query = entityManager.createQuery(\"select p from Person p order by p.lastName\");\n        List<Person> list = query.getResultList();\n        System.out.println(\"There are \" + list.size() + \" persons:\");\n        list.forEach( p -> System.out.println(p.getFirstName() + ' ' + p.getLastName()));\n    } finally {\n        if (entityManager != null)\n            entityManager.close();\n        if (entityMgrFactory != null)\n            entityMgrFactory.close();\n    }\n}\n","name":"main","className":"JPASimple","variables":{"Persistence":1,"p":3,"np":2,"entityManager":8,"entityMgrFactory":5,"query":2,"id":2,"list":3,"transaction":5},"constants":{"\" persons:\"":1,"\"jpademo\"":1,"\"JPASimple.main()\"":1,"\"There are \"":1,"null":4,"\"Tom\"":1,"\"select p from Person p order by p.lastName\"":1,"\"Boots\"":1,"\"Created Person with Id \"":1,"' '":1},"javaDoc":"","comments":"Create an entity in the database ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":["GeneratedValue","Id"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Id\n@GeneratedValue(strategy = GenerationType.AUTO)\npublic int getId() {\n    return id;\n}\n","name":"getId","className":"Address","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// Other accessors and methods omitted for brevity\n// END main\npublic void setId(int id) {\n    this.id = id;\n}\n","name":"setId","className":"Address","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getStreetAddress() {\n    return streetAddress;\n}\n","name":"getStreetAddress","className":"Address","variables":{"streetAddress":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setStreetAddress(String streetAddress) {\n    this.streetAddress = streetAddress;\n}\n","name":"setStreetAddress","className":"Address","variables":{"streetAddress":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getCity() {\n    return city;\n}\n","name":"getCity","className":"Address","variables":{"city":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setCity(String city) {\n    this.city = city;\n}\n","name":"setCity","className":"Address","variables":{"city":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getCountry() {\n    return country;\n}\n","name":"getCountry","className":"Address","variables":{"country":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setCountry(String country) {\n    this.country = country;\n}\n","name":"setCountry","className":"Address","variables":{"country":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"UserDBJDBC","methodCalls":{"next":1,"add":1,"forName":1,"getString":9,"prepareStatement":4,"executeQuery":1,"createStatement":1,"getConnection":1,"trim":2,"toString":2,"getDate":2,"getBoolean":2,"close":3,"System.out.println":3},"annotations":[],"exceptions":["IllegalStateException","SQLException","NamingException","IOException","ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"boolean":2,"User":1,"Statement":1,"Connection":1,"ResultSet":1,"String":9,"int":1,"java.sql.Date":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":18,"BinaryExpr":1,"NameExpr":134,"StringLiteralExpr":11,"FieldAccessExpr":3,"UnaryExpr":13,"MethodCallExpr":33,"AssignExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExplicitConstructorInvocationStmt":1,"ThrowStmt":1,"ExpressionStmt":30},"text":"/** Default constructor */\nprotected UserDBJDBC() throws NamingException, SQLException, IOException {\n    super();\n    System.out.println(\"UserDBJDBC.<init> starting...\");\n    System.out.println(\"Loading Driver Class\");\n    try {\n        Class.forName(\"org.hsqldb.jdbcDriver\");\n    } catch (ClassNotFoundException ex) {\n        System.out.println(\"FAILED: \" + ex.toString());\n        throw new IllegalStateException(ex.toString());\n    }\n    Connection conn = DriverManager.getConnection(\"jdbc:hsqldb:/home/ian/src/jabadot/WEB-INF/jabadot\", \"jabadmin\", \"fredonia\");\n    Statement stmt = conn.createStatement();\n    ResultSet rs = stmt.executeQuery(\"select * from users\");\n    while (rs.next()) {\n        //name:password:fullname:City:Prov:Country:privs\n        // Get the fields from the query.\n        // Could be an Entity EJB with CMP: this is unnecessarily \n        // chummy with the SQL. See CreateUserDatabase.java for field#'s!\n        int i = 1;\n        String nick = rs.getString(i++).trim();\n        String pass = rs.getString(i++).trim();\n        // System.err.println(nick + \" (\" + pass + \")\");\n        String first = rs.getString(i++);\n        String last = rs.getString(i++);\n        String email = rs.getString(i++);\n        String city = rs.getString(i++);\n        String prov = rs.getString(i++);\n        String ctry = rs.getString(i++);\n        java.sql.Date credt = rs.getDate(i++);\n        java.sql.Date lastlog = rs.getDate(i++);\n        String skin = rs.getString(i++);\n        boolean editPrivs = rs.getBoolean(i++);\n        boolean adminPrivs = rs.getBoolean(i++);\n        // Construct a user object from the fields\n        // System.out.println(\"Constructing User object\");\n        User u = new User(nick, pass, first, last, email, prov, ctry, credt, lastlog, skin, editPrivs, adminPrivs);\n        // System.out.println(\"Adding User object \" + u + \" to \" + users);\n        // Add it to the in-memory copy.\n        users.add(u);\n    // System.err.println(\"User \" + nick + \"; pass \" + pass.charAt(0));\n    }\n    // All done with that resultset\n    rs.close();\n    stmt.close();\n    // Set up the PreparedStatements now so we don't have to\n    // re-create them each time needed.\n    addUserStmt = conn.prepareStatement(SQL_INSERT_USER);\n    setPasswordStatement = conn.prepareStatement(\"update users SET password = ? where name = ?\");\n    setLastLoginStmt = conn.prepareStatement(\"update users SET lastLogin = ? where name = ?\");\n    deleteUserStmt = conn.prepareStatement(\"delete from users where name = ?\");\n    conn.close();\n}\n","name":"UserDBJDBC","className":"UserDBJDBC","variables":{"rs":16,"deleteUserStmt":1,"conn":7,"city":1,"skin":2,"editPrivs":2,"credt":2,"nick":2,"ctry":2,"lastlog":2,"DriverManager":1,"prov":2,"email":2,"setLastLoginStmt":1,"setPasswordStatement":1,"last":2,"pass":2,"i":14,"users":1,"ex":3,"u":1,"Class":1,"adminPrivs":2,"stmt":3,"first":2,"addUserStmt":1},"constants":{"\"update users SET lastLogin = ? where name = ?\"":1,"\"UserDBJDBC.<init> starting...\"":1,"1":1,"\"jdbc:hsqldb:/home/ian/src/jabadot/WEB-INF/jabadot\"":1,"\"Loading Driver Class\"":1,"\"delete from users where name = ?\"":1,"\"select * from users\"":1,"\"FAILED: \"":1,"\"jabadmin\"":1,"\"fredonia\"":1,"\"update users SET password = ? where name = ?\"":1,"\"org.hsqldb.jdbcDriver\"":1},"javaDoc":"Default constructor","comments":"Set up the PreparedStatements now so we don't have to name:password:fullname:City:Prov:Country:privs Get the fields from the query Could be an Entity EJB with CMP: this is unnecessarily Construct a user object from the fields System out println(\"Adding User object \" + u + \" to \" + users); System err println(\"User \" + nick + \"; pass \" + pass charAt(0)); chummy with the SQL See CreateUserDatabase java for field#'s! System err println(nick + \" (\" + pass + \")\"); System out println(\"Constructing User object\"); Add it to the in-memory copy All done with that resultset re-create them each time needed  Default constructor ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["User"],"returnType":"void","methodCalls":{"getName":1,"getCountry":1,"getLastName":1,"setString":9,"getPassword":1,"getSkin":1,"currentTimeMillis":1,"getProvince":1,"getEmail":1,"setDate":2,"getFirstName":1,"getCity":1,"setBoolean":2,"System.out.println":1,"executeUpdate":1},"annotations":[],"exceptions":["SQLException","IOException"],"concepts":["Synchronization"],"types":{"int":1,"java.sql.Date":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"SuperExpr":1,"BooleanLiteralExpr":2,"BinaryExpr":2,"NameExpr":98,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":14,"MethodCallExpr":26},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":19},"text":"/** Add one user to the list, both in-memory and on disk. */\npublic synchronized void addUser(User nu) throws IOException, SQLException {\n    // Add it to the in-memory list\n    super.addUser(nu);\n    // Copy fields from user to DB\n    // XXX WAY INCOMPLETE NOW\n    int i = 1;\n    addUserStmt.setString(i++, nu.getName());\n    addUserStmt.setString(i++, nu.getPassword());\n    addUserStmt.setString(i++, nu.getFirstName());\n    addUserStmt.setString(i++, nu.getLastName());\n    addUserStmt.setString(i++, nu.getEmail());\n    addUserStmt.setString(i++, nu.getCity());\n    addUserStmt.setString(i++, nu.getProvince());\n    addUserStmt.setString(i++, nu.getCountry());\n    java.sql.Date now = new java.sql.Date(System.currentTimeMillis());\n    addUserStmt.setDate(i++, now);\n    addUserStmt.setDate(i++, now);\n    addUserStmt.setString(i++, nu.getSkin());\n    addUserStmt.setBoolean(i++, false);\n    addUserStmt.setBoolean(i++, false);\n    --i;\n    if (i != 13) {\n        System.out.println(\"Warning: not enough fields set! i = \" + i);\n    }\n    // Store in persistent DB\n    addUserStmt.executeUpdate();\n}\n","name":"addUser","className":"UserDBJDBC","variables":{"nu":9,"now":1,"i":17,"System":1,"addUserStmt":14},"constants":{"1":1,"13":1,"false":2,"\"Warning: not enough fields set! i = \"":1},"javaDoc":"Add one user to the list both in-memory and on disk","comments":"Copy fields from user to DB Add it to the in-memory list XXX WAY INCOMPLETE NOW Store in persistent DB  Add one user to the list, both in-memory and on disk. ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"setString":1,"getUser":1,"remove":1,"executeUpdate":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"User":1,"int":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":18,"StringLiteralExpr":4,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":2,"ThrowStmt":2,"ExpressionStmt":4},"text":"public void deleteUser(String nick) throws SQLException {\n    // Find the user object\n    User u = getUser(nick);\n    if (u == null) {\n        throw new SQLException(\"User \" + nick + \" not in in-memory DB\");\n    }\n    deleteUserStmt.setString(1, nick);\n    int n = deleteUserStmt.executeUpdate();\n    if (n != 1) {\n        /*CANTHAPPEN */\n        throw new SQLException(\"ERROR: deleted \" + n + \" rows!!\");\n    }\n    // IFF we deleted it from the DB, also remove from the in-memory list\n    users.remove(u);\n}\n                          // not just one row??\n\n","name":"deleteUser","className":"UserDBJDBC","variables":{"nick":1,"deleteUserStmt":2,"u":2,"n":3,"users":1},"constants":{"1":2,"null":1,"\" rows!!\"":1,"\"ERROR: deleted \"":1,"\" not in in-memory DB\"":1,"\"User \"":1},"javaDoc":"","comments":"Find the user object not just one row?? CANTHAPPEN IFF we deleted it from the DB also remove from the in-memory list ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"setPassword":1,"setString":2,"getUser":1,"executeUpdate":1},"annotations":[],"exceptions":["SQLException"],"concepts":["Synchronization"],"types":{"User":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":18,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"public synchronized void setPassword(String nick, String newPass) throws SQLException {\n    // Find the user object\n    User u = getUser(nick);\n    // Change it in DB first; if this fails, the info in\n    // the in-memory copy won't be changed either.\n    setPasswordStatement.setString(1, newPass);\n    setPasswordStatement.setString(2, nick);\n    setPasswordStatement.executeUpdate();\n    // Change it in-memory\n    u.setPassword(newPass);\n}\n","name":"setPassword","className":"UserDBJDBC","variables":{"setPasswordStatement":3,"u":2},"constants":{"1":1,"2":1},"javaDoc":"","comments":"Change it in DB first; if this fails the info in Find the user object the in-memory copy won't be changed either Change it in-memory ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","java.util.Date"],"returnType":"void","methodCalls":{"setString":1,"getTime":1,"getUser":1,"setDate":1,"executeUpdate":1,"setLastLoginDate":1},"annotations":[],"exceptions":["SQLException"],"concepts":["Synchronization"],"types":{"User":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":20,"MethodCallExpr":6},"statements":{"ExpressionStmt":5},"text":"/** Update the Last Login Date field. */\npublic synchronized void setLoginDate(String nick, java.util.Date date) throws SQLException {\n    // Find the user object\n    User u = getUser(nick);\n    // Change it in DB first; if this fails, the date in\n    // the in-memory copy won't be changed either.\n    // Have to convert from java.util.Date to java.sql.Date here.\n    // Would be more efficient to use java.sql.Date everywhere.\n    setLastLoginStmt.setDate(1, new java.sql.Date(date.getTime()));\n    setLastLoginStmt.setString(2, nick);\n    setLastLoginStmt.executeUpdate();\n    // Change it in-memory\n    u.setLastLoginDate(date);\n}\n","name":"setLoginDate","className":"UserDBJDBC","variables":{"date":1,"u":2,"setLastLoginStmt":3},"constants":{"1":1,"2":1},"javaDoc":"Update the Last Login Date field","comments":"Change it in DB first; if this fails the date in the in-memory copy won't be changed either Have to convert from java util Date to java sql Date here Find the user object Would be more efficient to use java sql Date everywhere Change it in-memory  Update the Last Login Date field. ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getConnection":1,"forName":1,"setLogWriter":1,"getErrorCode":1,"getWarnings":1,"getMessage":1,"getSQLState":1,"getNextWarning":1,"close":1,"System.out.println":7},"annotations":[],"exceptions":["SQLException","ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"SQLWarning":1,"Connection":1,"String":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":6,"StringLiteralExpr":11,"NameExpr":70,"FieldAccessExpr":8,"EnclosedExpr":1,"MethodCallExpr":16,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":14},"text":"public static void main(String[] av) {\n    String dbURL = \"jdbc:odbc:Companies\";\n    try {\n        // Load the jdbc-odbc bridge driver\n        Class.forName(\"sun.jdbc.odbc.JdbcOdbcDriver\");\n        // Enable logging\n        DriverManager.setLogWriter(new PrintWriter((System.err)));\n        System.out.println(\"Getting Connection\");\n        Connection conn = // user, passwd\n        DriverManager.getConnection(dbURL, \"ian\", \"\");\n        // If a SQLWarning object is available, print its\n        // warning(s).  There may be multiple warnings chained.\n        SQLWarning warn = conn.getWarnings();\n        while (warn != null) {\n            System.out.println(\"SQLState: \" + warn.getSQLState());\n            System.out.println(\"Message:  \" + warn.getMessage());\n            System.out.println(\"Vendor:   \" + warn.getErrorCode());\n            System.out.println(\"\");\n            warn = warn.getNextWarning();\n        }\n        // Do something with the connection here...\n        // All done with that DB connection\n        conn.close();\n    } catch (ClassNotFoundException e) {\n        System.out.println(\"Can't load driver \" + e);\n    } catch (SQLException e) {\n        System.out.println(\"Database access failed \" + e);\n    }\n}\n","name":"main","className":"Connect","variables":{"warn":7,"conn":3,"e":4,"Class":1,"DriverManager":2,"dbURL":1},"constants":{"\"\"":2,"\"SQLState: \"":1,"\"jdbc:odbc:Companies\"":1,"null":1,"\"Database access failed \"":1,"\"sun.jdbc.odbc.JdbcOdbcDriver\"":1,"\"Message:  \"":1,"\"Getting Connection\"":1,"\"Vendor:   \"":1,"\"Can't load driver \"":1,"\"ian\"":1},"javaDoc":"","comments":"If a SQLWarning object is available print its warning(s) There may be multiple warnings chained Do something with the connection here Load the jdbc-odbc bridge driver Enable logging user passwd All done with that DB connection ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"updateRow":2,"setPassword":1,"getInt":1,"setString":2,"newFactory":1,"setUsername":1,"createCachedRowSet":1,"setCommand":1,"execute":1,"close":1,"setUrl":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"RowSet":1,"RowSetFactory":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":43,"StringLiteralExpr":7,"MethodCallExpr":14,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":13},"text":"public static void main(String[] args) throws Exception {\n    RowSet rs;\n    RowSetFactory rsFactory = RowSetProvider.newFactory();\n    rs = rsFactory.createCachedRowSet();\n    rs.setUrl(\"jdbc:postgresql:tmclub\");\n    rs.setUsername(\"ian\");\n    rs.setPassword(\"secret\");\n    rs.setCommand(\"select * from members where name like ?\");\n    rs.setString(1, \"I%\");\n    // This will cause the RowSet to connect, fetch its data, and\n    // disconnect\n    rs.execute();\n    // Suppose we want to update data:\n    while (rs.next()) {\n        if (rs.getInt(\"id\") == 42) {\n            rs.setString(1, \"Marvin\");\n            // Normal JDBC\n            rs.updateRow();\n            // This additional call tells the CachedRowSet to connect\n            // to its database and send the updated data back.\n            rs.updateRow();\n        }\n    }\n    // If we're all done...\n    rs.close();\n}\n         // Some time later, the client tries to do something.\n\n","name":"main","className":"CachedRowSetDemo","variables":{"rs":14,"RowSetProvider":1,"rsFactory":2},"constants":{"1":2,"\"I%\"":1,"\"id\"":1,"\"secret\"":1,"\"Marvin\"":1,"\"select * from members where name like ?\"":1,"\"jdbc:postgresql:tmclub\"":1,"\"ian\"":1,"42":1},"javaDoc":"","comments":"This will cause the RowSet to connect fetch its data and Some time later the client tries to do something disconnect Suppose we want to update data: This additional call tells the CachedRowSet to connect Normal JDBC to its database and send the updated data back If we're all done ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getName":2,"forName":2,"System.err.println":1,"System.out.println":2},"annotations":[],"exceptions":["ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Class<?>":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":28,"StringLiteralExpr":4,"FieldAccessExpr":3,"MethodCallExpr":7},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public static void main(String[] av) {\n    try {\n        // Try to load the jdbc-odbc bridge driver\n        // Should be present on Sun JDK implementations.\n        Class<?> c = Class.forName(\"sun.jdbc.odbc.JdbcOdbcDriver\");\n        System.out.println(\"Loaded \" + c.getName());\n        // Try to load an Oracle driver.\n        Class<?> d = Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n        System.out.println(\"Loaded \" + d.getName());\n    } catch (ClassNotFoundException ex) {\n        System.err.println(ex);\n    }\n}\n","name":"main","className":"LoadDriver","variables":{"c":2,"ex":1,"d":2,"Class":2},"constants":{"\"Loaded \"":2,"\"sun.jdbc.odbc.JdbcOdbcDriver\"":1,"\"oracle.jdbc.driver.OracleDriver\"":1},"javaDoc":"","comments":"Try to load the jdbc-odbc bridge driver Should be present on Sun JDK implementations Try to load an Oracle driver ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"transactionIsolationToString":1,"getConnection":1,"getDatabaseProductName":1,"getDefaultTransactionIsolation":1,"getDatabaseProductVersion":1,"getMetaData":1,"close":1,"System.out.println":6},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{"Connection":1,"DatabaseMetaData":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":54,"StringLiteralExpr":7,"FieldAccessExpr":6,"MethodCallExpr":13},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    try {\n        // Get the connection\n        Connection conn = ConnectionUtil.getConnection(args[0]);\n        // Get a Database MetaData as a way of interrogating \n        // the names of the tables in this database.\n        DatabaseMetaData meta = conn.getMetaData();\n        System.out.println(\"We are using \" + meta.getDatabaseProductName());\n        System.out.println(\"Version is \" + meta.getDatabaseProductVersion());\n        int txisolation = meta.getDefaultTransactionIsolation();\n        System.out.println(\"Database default transaction isolation is \" + txisolation + \" (\" + transactionIsolationToString(txisolation) + \").\");\n        conn.close();\n        System.out.println(\"All done!\");\n    } catch (SQLException ex) {\n        System.out.println(\"Database access failed:\");\n        System.out.println(ex);\n    }\n}\n","name":"main","className":"DatabaseMetaDemo","variables":{"args":1,"conn":3,"ex":1,"meta":4,"txisolation":2,"ConnectionUtil":1},"constants":{"0":1,"\"Database default transaction isolation is \"":1,"\"Database access failed:\"":1,"\"We are using \"":1,"\" (\"":1,"\"All done!\"":1,"\").\"":1,"\"Version is \"":1},"javaDoc":"","comments":"Get a Database MetaData as a way of interrogating Get the connection the names of the tables in this database ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":17,"StringLiteralExpr":6,"FieldAccessExpr":5},"statements":{"SwitchStmt":1,"SwitchEntryStmt":6,"ReturnStmt":5,"ThrowStmt":1},"text":"/** Convert a TransactionIsolation int (defined in java.sql.Connection)\n     * to the corresponding printable string.\n     * \n     * XXX Remove from here once darwinsys.jar gets committed.\n     */\npublic static String transactionIsolationToString(int txisolation) {\n    switch(txisolation) {\n        case Connection.TRANSACTION_NONE:\n            // transactions not supported.\n            return \"TRANSACTION_NONE\";\n        case Connection.TRANSACTION_READ_UNCOMMITTED:\n            // All three phenomena can occur\n            return \"TRANSACTION_NONE\";\n        case Connection.TRANSACTION_READ_COMMITTED:\n            // phantom reads can occur.\n            return \"TRANSACTION_READ_COMMITTED\";\n        case Connection.TRANSACTION_REPEATABLE_READ:\n            // phantom reads can occur.\n            return \"TRANSACTION_REPEATABLE_READ\";\n        case Connection.TRANSACTION_SERIALIZABLE:\n            // All three phenomena prvented; slowest!\n            return \"TRANSACTION_SERIALIZABLE\";\n        default:\n            throw new IllegalArgumentException(txisolation + \" not a valid TX_ISOLATION\");\n    }\n}\n             // Dirty reads are prevented; non-repeatable reads and \n\n                 // Dirty reads and non-repeatable reads are prevented;\n\n","name":"transactionIsolationToString","className":"DatabaseMetaDemo","variables":{"txisolation":2},"constants":{"\"TRANSACTION_SERIALIZABLE\"":1,"\"TRANSACTION_REPEATABLE_READ\"":1,"\"TRANSACTION_READ_COMMITTED\"":1,"\" not a valid TX_ISOLATION\"":1,"\"TRANSACTION_NONE\"":2},"javaDoc":"Convert a TransactionIsolation int (defined in java sql Connection) to the corresponding printable string XXX Remove from here once darwinsys jar gets committed","comments":"transactions not supported All three phenomena can occur Dirty reads are prevented; non-repeatable reads and phantom reads can occur Dirty reads and non-repeatable reads are prevented; phantom reads can occur All three phenomena prvented; slowest!  Convert a TransactionIsolation int (defined in java.sql.Connection)\n     * to the corresponding printable string.\n     * \n     * XXX Remove from here once darwinsys.jar gets committed.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void addType(String s) {\n    exts.add(s);\n}\n","name":"addType","className":"JFileFilter","variables":{"exts":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["File"],"returnType":"boolean","methodCalls":{"getName":1,"isFile":1,"endsWith":1,"isDirectory":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":3,"NameExpr":13,"MethodCallExpr":4},"statements":{"IfStmt":3,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":3},"text":"/** Return true if the given file is accepted by this filter. */\npublic boolean accept(File f) {\n    // ending in one of the extentions appear in the window.\n    if (f.isDirectory()) {\n        return true;\n    } else if (f.isFile()) {\n        for (String ext : exts) {\n            if (f.getName().endsWith(ext))\n                return true;\n        }\n    }\n    // A file that didn't match, or a weirdo (e.g. UNIX device file?).\n    return false;\n}\n         // Little trick: if you don't do this, only directory names\n\n","name":"accept","className":"JFileFilter","variables":{"ext":1,"f":3,"exts":1},"constants":{"true":2,"false":1},"javaDoc":"Return true if the given file is accepted by this filter","comments":"Little trick: if you don't do this only directory names ending in one of the extentions appear in the window A file that didn't match or a weirdo (e g UNIX device file?)  Return true if the given file is accepted by this filter. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the printable description of this filter. */\npublic void setDescription(String s) {\n    description = s;\n}\n","name":"setDescription","className":"JFileFilter","variables":{"s":1,"description":1},"constants":{},"javaDoc":"Set the printable description of this filter","comments":" Set the printable description of this filter. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the printable description of this filter. */\npublic String getDescription() {\n    return description;\n}\n","name":"getDescription","className":"JFileFilter","variables":{"description":1},"constants":{},"javaDoc":"Return the printable description of this filter","comments":" Return the printable description of this filter. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ButtonDemo","methodCalls":{"add":1,"setSize":1,"addActionListener":1,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"NameExpr":10,"StringLiteralExpr":1,"ThisExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":4},"text":"public ButtonDemo() {\n    setLayout(new FlowLayout());\n    add(b1 = new JButton(\"A button\"));\n    b1.addActionListener(this);\n    setSize(300, 200);\n}\n","name":"ButtonDemo","className":"ButtonDemo","variables":{"b1":2},"constants":{"200":1,"300":1,"\"A button\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    System.out.println(\"Thanks for pushing my button!\");\n}\n","name":"actionPerformed","className":"ButtonDemo","variables":{},"constants":{"\"Thanks for pushing my button!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] unuxed) {\n    new ButtonDemo().setVisible(true);\n}\n","name":"main","className":"ButtonDemo","variables":{},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"JFrameFlowLayout","methodCalls":{"add":2,"getContentPane":1,"setLayout":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Container":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"NameExpr":13,"StringLiteralExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"public JFrameFlowLayout() {\n    Container cp = getContentPane();\n    // Make sure it has a FlowLayout layoutmanager.\n    cp.setLayout(new FlowLayout());\n    // now add Components to \"cp\"...\n    cp.add(new JLabel(\"Wonderful?\"));\n    cp.add(new JButton(\"Yes!\"));\n    pack();\n}\n","name":"JFrameFlowLayout","className":"JFrameFlowLayout","variables":{"cp":4},"constants":{"\"Wonderful?\"":1,"\"Yes!\"":1},"javaDoc":"","comments":"Make sure it has a FlowLayout layoutmanager now add Components to \"cp\" ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// We need a main program to instantiate and show.\npublic static void main(String[] args) {\n    new JFrameFlowLayout().setVisible(true);\n}\n","name":"main","className":"JFrameFlowLayout","variables":{},"constants":{"true":1},"javaDoc":"","comments":" We need a main program to instantiate and show.","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":1,"getFrame":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void run() {\n    gui.getFrame().setVisible(true);\n}\n","name":"run","className":"","variables":{"gui":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setProperty":2,"getFrame":1,"invokeAndWait":1},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","FinalVariables"],"types":{"MacOsUiHints":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":17,"StringLiteralExpr":4,"MarkerAnnotationExpr":1,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) throws Exception {\n    // OS X Tester: \n    // check that the File Edit View menu appears atop the desktop not the window\n    System.setProperty(\"apple.laf.useScreenMenuBar\", \"true\");\n    // OS X Tester: check that this string appears in the Application Menu.\n    System.setProperty(\"com.apple.mrj.application.apple.menu.about.name\", \"MacOsUiHints\");\n    final MacOsUiHints gui = new MacOsUiHints();\n    SwingUtilities.invokeAndWait(new Runnable() {\n\n        @Override\n        public void run() {\n            gui.getFrame().setVisible(true);\n        }\n    });\n}\n","name":"main","className":"MacOsUiHints","variables":{"gui":2,"run":1,"SwingUtilities":1,"Override":1,"System":2},"constants":{"\"apple.laf.useScreenMenuBar\"":1,"true":1,"\"com.apple.mrj.application.apple.menu.about.name\"":1,"\"MacOsUiHints\"":1,"\"true\"":1},"javaDoc":"","comments":"OS X Tester: check that the File Edit View menu appears atop the desktop not the window OS X Tester: check that this string appears in the Application Menu ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"JFrame","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"protected JFrame getFrame() {\n    return jf;\n}\n","name":"getFrame","className":"MacOsUiHints","variables":{"jf":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent arg0) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MacOsUiHints","methodCalls":{"add":4,"setJMenuBar":1,"exit":1,"setSize":1,"addActionListener":1,"getContentPane":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"JButton":1,"JMenuBar":1,"JMenu":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"NameExpr":32,"StringLiteralExpr":5,"AssignExpr":1,"MethodCallExpr":9},"statements":{"BlockStmt":1,"ExpressionStmt":12},"text":"public MacOsUiHints() {\n    jf = new JFrame(\"MacOsUiHints\");\n    JButton button = new JButton(\"Exit\");\n    button.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent arg0) {\n            System.exit(0);\n        }\n    });\n    jf.getContentPane().add(button);\n    JMenuBar mb = new JMenuBar();\n    jf.setJMenuBar(mb);\n    JMenu fileMenu = new JMenu(\"File\");\n    mb.add(fileMenu);\n    fileMenu.add(new JMenuItem(\"Quit\"));\n    mb.add(new JMenu(\"Edit\"));\n    // Tester: see that Application->About produces our popup\n    // Ditto for Preferences and Shutdown.\n    // MacOSAppAdapter adapter =\n    //   new MacOSAppAdapter(jf, abouter, prefser, printer, shutter);\n    //adapter.register( );\n    jf.setSize(300, 200);\n}\n","name":"MacOsUiHints","className":"MacOsUiHints","variables":{"button":2,"actionPerformed":1,"mb":3,"arg0":1,"jf":4,"System":1,"fileMenu":2},"constants":{"0":1,"\"Quit\"":1,"200":1,"300":1,"\"File\"":1,"\"Edit\"":1,"\"MacOsUiHints\"":1,"\"Exit\"":1},"javaDoc":"","comments":"Tester: see that Application->About produces our popup Ditto for Preferences and Shutdown MacOSAppAdapter adapter = new MacOSAppAdapter(jf abouter prefser printer shutter); adapter register( ); ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void run() {\n    new ThreadBasedCatcher().setVisible(true);\n}\n","name":"run","className":"","variables":{},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":3,"BooleanLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ExpressionStmt":2},"text":"// BEGIN main\n// gui/ThreadBasedCatcher.java\npublic static void main(String[] args) {\n    new Thread(new Runnable() {\n\n        public void run() {\n            new ThreadBasedCatcher().setVisible(true);\n        }\n    }).start();\n}\n","name":"main","className":"ThreadBasedCatcher","variables":{"run":1},"constants":{"true":1},"javaDoc":"","comments":" gui/ThreadBasedCatcher.java","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["RuntimeException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"StringLiteralExpr":1},"statements":{"ThrowStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    throw new RuntimeException(\"You asked for it\");\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{"\"You asked for it\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Thread","Throwable"],"returnType":"void","methodCalls":{"getName":1,"toString":1,"showExceptions":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":2,"ThisExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public void uncaughtException(Thread t, Throwable ex) {\n    // END main\n    if (gui) {\n        ErrorUtil.showExceptions(ThreadBasedCatcher.this, ex);\n    }\n    // BEGIN main\n    System.out.println(\"You crashed thread \" + t.getName());\n    System.out.println(\"Exception was: \" + ex.toString());\n}\n","name":"uncaughtException","className":"","variables":{"ThreadBasedCatcher":1,"ex":1,"t":1,"gui":1,"ErrorUtil":1},"constants":{"\"You crashed thread \"":1,"\"Exception was: \"":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ThreadBasedCatcher","methodCalls":{"add":1,"getName":1,"addActionListener":1,"setDefaultUncaughtExceptionHandler":1,"getContentPane":1,"toString":1,"setDefaultCloseOperation":1,"pack":1,"showExceptions":1,"System.out.println":2},"annotations":[],"exceptions":["RuntimeException"],"concepts":["InnerMethod"],"types":{"Container":1,"JButton":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":45,"StringLiteralExpr":4,"FieldAccessExpr":3,"ThisExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":1,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":10},"text":"public ThreadBasedCatcher() {\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    Container cp = getContentPane();\n    JButton crasher = new JButton(\"Crash\");\n    cp.add(crasher);\n    crasher.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            throw new RuntimeException(\"You asked for it\");\n        }\n    });\n    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n\n        public void uncaughtException(Thread t, Throwable ex) {\n            // END main\n            if (gui) {\n                ErrorUtil.showExceptions(ThreadBasedCatcher.this, ex);\n            }\n            // BEGIN main\n            System.out.println(\"You crashed thread \" + t.getName());\n            System.out.println(\"Exception was: \" + ex.toString());\n        }\n    });\n    pack();\n}\n","name":"ThreadBasedCatcher","className":"ThreadBasedCatcher","variables":{"actionPerformed":1,"ThreadBasedCatcher":1,"ex":2,"t":2,"e":1,"crasher":2,"uncaughtException":1,"gui":1,"cp":2,"ErrorUtil":1,"Thread":1},"constants":{"\"You crashed thread \"":1,"\"Crash\"":1,"\"You asked for it\"":1,"\"Exception was: \"":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"addActionListener":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":14,"StringLiteralExpr":2,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":4},"text":"public void init() {\n    add(b1 = new Button(\"A button\"));\n    b1.addActionListener(handler);\n    add(b2 = new Button(\"Another button\"));\n    b2.addActionListener(handler);\n}\n","name":"init","className":"ButtonDemo2b","variables":{"b2":2,"b1":2},"constants":{"\"Another button\"":1,"\"A button\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSource":1,"showStatus":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent e) {\n    if (e.getSource() == b1)\n        showStatus(\"Thanks for pushing my first button!\");\n    else\n        showStatus(\"Thanks for pushing my second button!\");\n}\n","name":"actionPerformed","className":"ButtonHandler","variables":{"e":1,"b1":1},"constants":{"\"Thanks for pushing my first button!\"":1,"\"Thanks for pushing my second button!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ButtonDemo2L","methodCalls":{"add":2,"showMessageDialog":2,"addActionListener":2,"setDefaultCloseOperation":1,"setLayout":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JButton":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"LambdaExpr":2,"StringLiteralExpr":5,"NameExpr":27,"FieldAccessExpr":1,"ThisExpr":2,"MethodCallExpr":9,"AssignExpr":2},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":10},"text":"public ButtonDemo2L() {\n    super(\"ButtonDemo Lambda\");\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    setLayout(new FlowLayout());\n    JButton b;\n    add(b = new JButton(\"A button\"));\n    // Minimalist style\n    b.addActionListener( e -> JOptionPane.showMessageDialog(this, \"Thanks for pushing my first button!\"));\n    add(b = new JButton(\"Another button\"));\n    // Longer style, with { } around body.\n    b.addActionListener( e -> {\n        JOptionPane.showMessageDialog(this, \"Thanks for pushing my second button!\");\n    });\n    pack();\n}\n","name":"ButtonDemo2L","className":"ButtonDemo2L","variables":{"b":5,"e":2,"JOptionPane":2},"constants":{"\"Another button\"":1,"\"A button\"":1,"\"Thanks for pushing my first button!\"":1,"\"ButtonDemo Lambda\"":1,"\"Thanks for pushing my second button!\"":1},"javaDoc":"","comments":"Minimalist style Longer style with { } around body ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new ButtonDemo2L().setVisible(true);\n}\n","name":"main","className":"ButtonDemo2L","variables":{},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"ContentPane","methodCalls":{"add":1,"getContentPane":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Container":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public ContentPane() {\n    Container cp = getContentPane();\n    // now add Components to \"cp\"...\n    cp.add(new JLabel(\"A Really Simple Demo\", JLabel.CENTER));\n}\n","name":"ContentPane","className":"ContentPane","variables":{"cp":2},"constants":{"\"A Really Simple Demo\"":1},"javaDoc":"","comments":"now add Components to \"cp\" ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void run() {\n    demo.setVisible(true);\n}\n","name":"run","className":"","variables":{"demo":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"invokeLater":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables","PolyMorphism"],"types":{"JFrameDemo":1,"JFrame":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ExpressionStmt":3},"text":"// We need a main program to instantiate and show.\npublic static void main(String[] args) {\n    // Create the GUI (variable is final because used by inner class).\n    final JFrame demo = new JFrameDemo();\n    // Create a Runnable to set the main visible, and get Swing to invoke.\n    EventQueue.invokeLater(new Runnable() {\n\n        public void run() {\n            demo.setVisible(true);\n        }\n    });\n}\n","name":"main","className":"JFrameDemoSafe","variables":{"run":1,"demo":2,"EventQueue":1},"constants":{"true":1},"javaDoc":"","comments":"Create the GUI (variable is final because used by inner class) Create a Runnable to set the main visible and get Swing to invoke  We need a main program to instantiate and show.","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"getPreferredSize":1,"setLocation":1,"getContentPane":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Container":1,"JFrame":1,"Dimension":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":7,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":4,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":38,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":9},"text":"public void run() {\n    // create a Frame, and \"Component comp\" to it.\n    final JFrame f = new JFrame(\"CompRunner: \" + args[0]);\n    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    Container cp = f.getContentPane();\n    // Add the component under test\n    cp.add(BorderLayout.CENTER, comp);\n    // Set things reasonably sized.\n    Dimension d = comp.getPreferredSize();\n    if (d.width == 0 || d.height == 0) {\n        // component doesn't have working getPreferredSize() yet, pick a size.\n        f.setSize(300, 200);\n    } else {\n        f.pack();\n    }\n    f.setLocation(200, 200);\n    f.setVisible(true);\n}\n","name":"run","className":"","variables":{"args":1,"comp":1,"d":1,"f":7,"cp":2},"constants":{"0":3,"200":3,"300":1,"\"CompRunner: \"":1,"true":1},"javaDoc":"","comments":"create a Frame and \"Component comp\" to it Add the component under test Set things reasonably sized component doesn't have working getPreferredSize() yet pick a size ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"forName":1,"getContentPane":1,"newInstance":1,"pack":1,"invokeLater":1,"exit":4,"setSize":1,"getPreferredSize":1,"setLocation":1,"toString":1,"setDefaultCloseOperation":1,"System.err.println":5},"annotations":["SuppressWarnings"],"exceptions":["Exception"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"Container":1,"Class<Component>":1,"JFrame":1,"Object":1,"String":1,"Dimension":1},"expressions":{"IntegerLiteralExpr":13,"ObjectCreationExpr":2,"VariableDeclarationExpr":6,"ArrayAccessExpr":2,"BinaryExpr":10,"NameExpr":101,"StringLiteralExpr":7,"UnaryExpr":1,"InstanceOfExpr":1,"AssignExpr":2,"NullLiteralExpr":1,"BooleanLiteralExpr":1,"CastExpr":2,"FieldAccessExpr":10,"EnclosedExpr":1,"MethodCallExpr":21},"statements":{"IfStmt":3,"BlockStmt":9,"TryStmt":2,"ExpressionStmt":24},"text":"/** \"main program\" method - construct and show */\n@SuppressWarnings(\"unchecked\")\npublic static void main(final String[] args) {\n    if (args.length == 0) {\n        System.err.println(\"Usage: CompRunner ComponentSubclass\");\n        System.exit(1);\n    }\n    String className = args[0];\n    // create an instance of class named in \"className\", save in \"Component comp\".\n    Class<Component> clazz = null;\n    try {\n        clazz = (Class<Component>) Class.forName(className);\n    } catch (Exception e) {\n        System.err.println(\"ERROR: \" + className + \" not valid; probably not on CLASSPATH\");\n        System.exit(1);\n    }\n    try {\n        Object o = clazz.newInstance();\n        if (!(o instanceof Component)) {\n            System.err.println(\"ERROR: Class \" + className + \" is not a subclass of Component\");\n            System.exit(1);\n        }\n        comp = (Component) o;\n    } catch (Exception e) {\n        System.err.println(className + \" got exception in construction or initialization\");\n        System.err.println(e.toString());\n        System.exit(1);\n    }\n    // Java GUI events are not threadsafe, so start the GUI on the Event Thread\n    EventQueue.invokeLater(new Runnable() {\n\n        public void run() {\n            // create a Frame, and \"Component comp\" to it.\n            final JFrame f = new JFrame(\"CompRunner: \" + args[0]);\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            Container cp = f.getContentPane();\n            // Add the component under test\n            cp.add(BorderLayout.CENTER, comp);\n            // Set things reasonably sized.\n            Dimension d = comp.getPreferredSize();\n            if (d.width == 0 || d.height == 0) {\n                // component doesn't have working getPreferredSize() yet, pick a size.\n                f.setSize(300, 200);\n            } else {\n                f.pack();\n            }\n            f.setLocation(200, 200);\n            f.setVisible(true);\n        }\n    });\n}\n","name":"main","className":"CompRunner","variables":{"comp":2,"d":1,"e":3,"f":7,"className":4,"run":1,"cp":2,"System":4,"EventQueue":1,"o":3,"args":2,"Class":1,"clazz":3},"constants":{"\" not valid; probably not on CLASSPATH\"":1,"\"ERROR: \"":1,"\" got exception in construction or initialization\"":1,"\"ERROR: Class \"":1,"0":5,"1":4,"\"Usage: CompRunner ComponentSubclass\"":1,"200":3,"300":1,"null":1,"\" is not a subclass of Component\"":1,"\"CompRunner: \"":1,"true":1},"javaDoc":"\"main program\" method - construct and show","comments":"create an instance of class named in \"className\" save in \"Component comp\" Java GUI events are not threadsafe so start the GUI on the Event Thread create a Frame and \"Component comp\" to it Add the component under test Set things reasonably sized component doesn't have working getPreferredSize() yet pick a size  \"main program\" method - construct and show ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setVisible":1,"exit":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":7,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent e) {\n    setVisible(false);\n    dispose();\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"System":1},"constants":{"0":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JFrameDemo","methodCalls":{"add":1,"setVisible":1,"exit":1,"setLocation":1,"addActionListener":1,"getContentPane":1,"dispose":1,"setLayout":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Container":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":2,"NameExpr":30,"FieldAccessExpr":1,"MethodCallExpr":10,"AssignExpr":1},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":10},"text":"/** Construct the object including its GUI */\npublic JFrameDemo() {\n    super(\"JFrameDemo\");\n    Container cp = getContentPane();\n    cp.setLayout(new FlowLayout());\n    cp.add(quitButton = new JButton(\"Exit\"));\n    // Set up so that \"Close\" will exit the program, \n    // not just close the JFrame.\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    // This \"action handler\" will be explained later in the chapter.\n    quitButton.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            setVisible(false);\n            dispose();\n            System.exit(0);\n        }\n    });\n    pack();\n    setLocation(500, 400);\n}\n","name":"JFrameDemo","className":"JFrameDemo","variables":{"actionPerformed":1,"e":1,"quitButton":2,"cp":3,"System":1},"constants":{"0":1,"400":1,"500":1,"\"JFrameDemo\"":1,"false":1,"\"Exit\"":1},"javaDoc":"Construct the object including its GUI","comments":"Set up so that \"Close\" will exit the program not just close the JFrame This \"action handler\" will be explained later in the chapter  Construct the object including its GUI ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new JFrameDemo().setVisible(true);\n}\n","name":"main","className":"JFrameDemo","variables":{},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getForeground":1,"showDialog":1,"setForeground":1,"repaint":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":21,"StringLiteralExpr":2,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent actionEvent) {\n    Color ch = JColorChooser.showDialog(// parent\n    JColorChooserDemo.this, // title\n    \"Swing Demo Color Popup\", // default\n    demo.getForeground());\n    System.out.println(\"Your selected color is \" + ch);\n    if (ch != null) {\n        demo.setForeground(ch);\n        demo.repaint();\n    }\n}\n","name":"actionPerformed","className":"","variables":{"ch":3,"JColorChooserDemo":1,"JColorChooser":1,"demo":3},"constants":{"\"Your selected color is \"":1,"null":1},"javaDoc":"","comments":"parent title default ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JColorChooserDemo","methodCalls":{"add":2,"getForeground":1,"setToolTipText":2,"showDialog":1,"addActionListener":1,"setForeground":1,"getContentPane":1,"setDefaultCloseOperation":1,"repaint":1,"pack":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Container":1,"Color":1,"JButton":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"StringLiteralExpr":7,"NameExpr":58,"FieldAccessExpr":5,"ThisExpr":1,"MethodCallExpr":13,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":13},"text":"/** Constructor - set up the entire GUI for this program */\npublic JColorChooserDemo() {\n    super(\"Swing Color Demo\");\n    Container cp = getContentPane();\n    JButton jButton;\n    cp.add(jButton = new JButton(\"Change Color...\"), BorderLayout.NORTH);\n    jButton.setToolTipText(\"Click here to see the Color Chooser\");\n    jButton.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent actionEvent) {\n            Color ch = JColorChooser.showDialog(// parent\n            JColorChooserDemo.this, // title\n            \"Swing Demo Color Popup\", // default\n            demo.getForeground());\n            System.out.println(\"Your selected color is \" + ch);\n            if (ch != null) {\n                demo.setForeground(ch);\n                demo.repaint();\n            }\n        }\n    });\n    cp.add(BorderLayout.CENTER, demo = new JLabel(\"Your One True Color\", JLabel.CENTER));\n    demo.setToolTipText(\"This is the last color you chose\");\n    pack();\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n","name":"JColorChooserDemo","className":"JColorChooserDemo","variables":{"actionPerformed":1,"ch":3,"JColorChooserDemo":1,"jButton":4,"actionEvent":1,"cp":3,"JColorChooser":1,"demo":5},"constants":{"\"Your selected color is \"":1,"\"Swing Color Demo\"":1,"\"This is the last color you chose\"":1,"\"Change Color...\"":1,"\"Click here to see the Color Chooser\"":1,"null":1,"\"Your One True Color\"":1},"javaDoc":"Constructor - set up the entire GUI for this program","comments":"parent title default  Constructor - set up the entire GUI for this program ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** good old main */\npublic static void main(String[] argv) {\n    new JColorChooserDemo().setVisible(true);\n}\n","name":"main","className":"JColorChooserDemo","variables":{},"constants":{"true":1},"javaDoc":"good old main","comments":" good old main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"setVisible":1,"setSize":1,"getContentPane":1,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Container":1,"JFrame":1,"JSpinner":2,"String[]":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"ArrayInitializerExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":4,"NameExpr":21,"MethodCallExpr":6},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    JFrame jf = new JFrame(\"It Spins\");\n    Container cp = jf.getContentPane();\n    cp.setLayout(new GridLayout(0, 1));\n    // Create a JSpinner using one of the pre-defined SpinnerModels\n    JSpinner dates = new JSpinner(new SpinnerDateModel());\n    cp.add(dates);\n    // Create a JSPinner using a SpinnerListModel. \n    String[] data = { \"One\", \"Two\", \"Three\" };\n    JSpinner js = new JSpinner(new SpinnerListModel(data));\n    cp.add(js);\n    jf.setSize(100, 80);\n    jf.setVisible(true);\n}\n","name":"main","className":"SpinnerDemo","variables":{"data":2,"js":1,"dates":1,"jf":4,"cp":4},"constants":{"0":1,"1":1,"100":1,"\"It Spins\"":1,"80":1,"true":1,"\"One\"":1,"\"Two\"":1,"\"Three\"":1},"javaDoc":"","comments":"Create a JSpinner using one of the pre-defined SpinnerModels Create a JSPinner using a SpinnerListModel ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"addActionListener":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":12,"StringLiteralExpr":2,"ThisExpr":2,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":4},"text":"public void init() {\n    add(b1 = new Button(\"A button\"));\n    b1.addActionListener(this);\n    add(b2 = new Button(\"Another button\"));\n    b2.addActionListener(this);\n}\n","name":"init","className":"ButtonDemo2a","variables":{"b2":2,"b1":2},"constants":{"\"Another button\"":1,"\"A button\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSource":1,"showStatus":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent e) {\n    if (e.getSource() == b1)\n        showStatus(\"Thanks for pushing my first button!\");\n    else\n        showStatus(\"Thanks for pushing my second button!\");\n}\n","name":"actionPerformed","className":"ButtonDemo2a","variables":{"e":1,"b1":1},"constants":{"\"Thanks for pushing my first button!\"":1,"\"Thanks for pushing my second button!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Frame":1,"WindowDemo":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    Frame f = new WindowDemo();\n    f.setVisible(true);\n}\n","name":"main","className":"WindowDemo","variables":{"f":2},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"WindowDemo","methodCalls":{"addWindowListener":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"NameExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public WindowDemo() {\n    setSize(200, 100);\n    addWindowListener(new WindowDemoAdapter());\n}\n","name":"WindowDemo","className":"WindowDemo","variables":{},"constants":{"100":1,"200":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"random":1,"exit":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":2,"ThisExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public void windowClosing(WindowEvent e) {\n    // whimsy - close randomly, ~ 1 times in 3\n    if (Math.random() > 0.666) {\n        System.out.println(\"Goodbye!\");\n        // window will close\n        WindowDemo.this.setVisible(false);\n        // and be freed up.\n        WindowDemo.this.dispose();\n        System.exit(0);\n    }\n    System.out.println(\"You asked me to close, but not to I chose.\");\n}\n","name":"windowClosing","className":"WindowDemoAdapter","variables":{"Math":1,"WindowDemo":2,"System":1},"constants":{"0":1,"0.666":1,"\"Goodbye!\"":1,"\"You asked me to close, but not to I chose.\"":1,"false":1},"javaDoc":"","comments":"whimsy - close randomly ~ 1 times in 3 window will close and be freed up ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showOpenDialog":1,"getSelectedFile":1,"isFile":1,"getPath":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"File":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":27,"StringLiteralExpr":5,"FieldAccessExpr":3,"EnclosedExpr":1,"ConditionalExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent e) {\n    int returnVal = chooser.showOpenDialog(frame);\n    if (returnVal == JFileChooser.APPROVE_OPTION) {\n        File file = chooser.getSelectedFile();\n        System.out.println(\"You chose a \" + (file.isFile() ? \"file\" : \"directory\") + \" named: \" + file.getPath());\n    } else {\n        System.out.println(\"You did not choose a filesystem object.\");\n    }\n}\n","name":"actionPerformed","className":"","variables":{"returnVal":2,"file":3,"chooser":2},"constants":{"\"You did not choose a filesystem object.\"":1,"\"You chose a \"":1,"\"directory\"":1,"\"file\"":1,"\" named: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["JFrame"],"returnType":"JFileChooserDemo","methodCalls":{"add":1,"showOpenDialog":1,"addType":3,"getSelectedFile":1,"isFile":1,"addChoosableFileFilter":1,"addActionListener":1,"getPath":1,"setDescription":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"JFileChooser":1,"JFrame":1,"JButton":1,"JFileFilter":1,"File":1,"int":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":6,"BinaryExpr":4,"NameExpr":52,"StringLiteralExpr":10,"FieldAccessExpr":3,"EnclosedExpr":1,"ConditionalExpr":1,"MethodCallExpr":13},"statements":{"IfStmt":1,"BlockStmt":3,"ExpressionStmt":15},"text":"/** Constructor */\npublic JFileChooserDemo(JFrame f) {\n    final JFrame frame = f;\n    final JFileChooser chooser = new JFileChooser();\n    // If you want the user to select only directories, use this.\n    // Default is to allow selection of files only.\n    // Note if you set the selection mode to DIRECTORIES_ONLY,\n    // it no longer displays any files, even with the file view.\n    // chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);\n    // If want it to only show certain file types, use a FileFilter.\n    // N.B. JFileFilter is not in javax.swing; it is my implementation\n    // of interface javax.swing.filechooser.FileFilter, and is similar\n    // to the ExtentionFilter in demo/jfc accompanying the J2SE SDK.\n    JFileFilter filter = new JFileFilter();\n    filter.addType(\"java\");\n    filter.addType(\"class\");\n    filter.addType(\"jar\");\n    filter.setDescription(\"Java-related files\");\n    chooser.addChoosableFileFilter(filter);\n    JButton b = new JButton(\"Choose file...\");\n    add(b);\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            int returnVal = chooser.showOpenDialog(frame);\n            if (returnVal == JFileChooser.APPROVE_OPTION) {\n                File file = chooser.getSelectedFile();\n                System.out.println(\"You chose a \" + (file.isFile() ? \"file\" : \"directory\") + \" named: \" + file.getPath());\n            } else {\n                System.out.println(\"You did not choose a filesystem object.\");\n            }\n        }\n    });\n}\n","name":"JFileChooserDemo","className":"JFileChooserDemo","variables":{"filter":5,"actionPerformed":1,"b":2,"returnVal":2,"file":3,"e":1,"f":1,"chooser":4,"frame":1},"constants":{"\"You did not choose a filesystem object.\"":1,"\"Choose file...\"":1,"\"You chose a \"":1,"\"directory\"":1,"\"java\"":1,"\"file\"":1,"\"jar\"":1,"\"Java-related files\"":1,"\" named: \"":1,"\"class\"":1},"javaDoc":"Constructor","comments":"If you want the user to select only directories use this Default is to allow selection of files only Note if you set the selection mode to DIRECTORIES_ONLY it no longer displays any files even with the file view chooser setFileSelectionMode(JFileChooser DIRECTORIES_ONLY); If want it to only show certain file types use a FileFilter N B JFileFilter is not in javax swing; it is my implementation of interface javax swing filechooser FileFilter and is similar to the ExtentionFilter in demo/jfc accompanying the J2SE SDK  Constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"getContentPane":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":18,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    JFrame f = new JFrame(\"JFileChooser Demo\");\n    f.getContentPane().add(new JFileChooserDemo(f));\n    f.pack();\n    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    f.setVisible(true);\n}\n","name":"main","className":"JFileChooserDemo","variables":{"f":6},"constants":{"true":1,"\"JFileChooser Demo\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"showMessageDialog":1,"printStackTrace":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        JOptionPane.showMessageDialog(null, \"Hello Java\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"run","className":"","variables":{"e":2,"JOptionPane":1},"constants":{"\"Hello Java\"":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"showMessageDialog":1,"printStackTrace":1,"invokeLater":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"NameExpr":16,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":3,"TryStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) throws Exception {\n    System.out.println(\"RunOnEdt.main()\");\n    SwingUtilities.invokeLater(new Runnable() {\n\n        public void run() {\n            try {\n                JOptionPane.showMessageDialog(null, \"Hello Java\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    });\n}\n","name":"main","className":"RunOnEdt","variables":{"e":2,"run":1,"SwingUtilities":1,"JOptionPane":1},"constants":{"\"Hello Java\"":1,"\"RunOnEdt.main()\"":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"LNFSwitcher","methodCalls":{"add":10,"getSystemLookAndFeelClassName":1,"addActionListener":5,"getContentPane":1,"setDefaultCloseOperation":1,"setLayout":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JRadioButton":5,"ButtonGroup":1,"String":1},"expressions":{"ObjectCreationExpr":13,"VariableDeclarationExpr":7,"BooleanLiteralExpr":1,"NameExpr":85,"StringLiteralExpr":10,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":3,"MethodCallExpr":21},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":28},"text":"/** Construct a program... */\npublic LNFSwitcher() {\n    super();\n    theFrame = new JFrame(\"LNF Switcher\");\n    theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    cp = theFrame.getContentPane();\n    cp.setLayout(new FlowLayout());\n    ButtonGroup bg = new ButtonGroup();\n    JRadioButton bJava = new JRadioButton(\"Java\");\n    bJava.addActionListener(new LNFSetter(\"javax.swing.plaf.metal.MetalLookAndFeel\", bJava));\n    bg.add(bJava);\n    cp.add(bJava);\n    JRadioButton bMSW = new JRadioButton(\"MS-Windows\");\n    bMSW.addActionListener(new LNFSetter(\"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\", bMSW));\n    bg.add(bMSW);\n    cp.add(bMSW);\n    JRadioButton bMotif = new JRadioButton(\"Motif\");\n    bMotif.addActionListener(new LNFSetter(\"com.sun.java.swing.plaf.motif.MotifLookAndFeel\", bMotif));\n    bg.add(bMotif);\n    cp.add(bMotif);\n    JRadioButton bMac = new JRadioButton(\"Sun-MacOS\");\n    bMac.addActionListener(new LNFSetter(\"com.sun.java.swing.plaf.mac.MacLookAndFeel\", bMac));\n    bg.add(bMac);\n    cp.add(bMac);\n    String defaultLookAndFeel = UIManager.getSystemLookAndFeelClassName();\n    // System.out.println(defaultLookAndFeel);\n    JRadioButton bDefault = new JRadioButton(\"Default\");\n    bDefault.addActionListener(new LNFSetter(defaultLookAndFeel, bDefault));\n    bg.add(bDefault);\n    cp.add(bDefault);\n    (previousButton = bDefault).setSelected(true);\n    theFrame.pack();\n}\n","name":"LNFSwitcher","className":"LNFSwitcher","variables":{"bMac":3,"bDefault":4,"bMotif":3,"bMSW":3,"previousButton":1,"defaultLookAndFeel":2,"theFrame":4,"bg":6,"UIManager":1,"bJava":3,"cp":7},"constants":{"\"LNF Switcher\"":1,"\"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\"":1,"\"MS-Windows\"":1,"\"com.sun.java.swing.plaf.mac.MacLookAndFeel\"":1,"\"com.sun.java.swing.plaf.motif.MotifLookAndFeel\"":1,"\"Sun-MacOS\"":1,"true":1,"\"Java\"":1,"\"Default\"":1,"\"javax.swing.plaf.metal.MetalLookAndFeel\"":1,"\"Motif\"":1},"javaDoc":"Construct a program","comments":"System out println(defaultLookAndFeel);  Construct a program... ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","JRadioButton"],"returnType":"LNFSetter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Called to setup for button handling */\nLNFSetter(String lnfName, JRadioButton me) {\n    theLNFName = lnfName;\n    thisButton = me;\n}\n","name":"LNFSetter","className":"LNFSetter","variables":{"theLNFName":1,"thisButton":1,"lnfName":1,"me":1},"constants":{},"javaDoc":"Called to setup for button handling","comments":" Called to setup for button handling ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"showMessageDialog":1,"updateComponentTreeUI":1,"setSelected":1,"setLookAndFeel":1,"pack":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":23,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"/** Called when the button actually gets pressed. */\npublic void actionPerformed(ActionEvent e) {\n    try {\n        UIManager.setLookAndFeel(theLNFName);\n        SwingUtilities.updateComponentTreeUI(theFrame);\n        theFrame.pack();\n    } catch (Exception evt) {\n        JOptionPane.showMessageDialog(null, \"setLookAndFeel didn't work: \" + evt, \"UI Failure\", JOptionPane.INFORMATION_MESSAGE);\n        previousButton.setSelected(true);\n    }\n    previousButton = thisButton;\n}\n                                                          // reset the GUI to agree\n\n","name":"actionPerformed","className":"LNFSetter","variables":{"evt":2,"previousButton":2,"thisButton":1,"theFrame":1,"UIManager":1,"SwingUtilities":1,"JOptionPane":1},"constants":{"null":1,"\"UI Failure\"":1,"true":1,"\"setLookAndFeel didn't work: \"":1},"javaDoc":"Called when the button actually gets pressed","comments":"reset the GUI to agree  Called when the button actually gets pressed. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"o.theFrame.setVisible":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LNFSwitcher":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":5,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    LNFSwitcher o = new LNFSwitcher();\n    o.theFrame.setVisible(true);\n}\n","name":"main","className":"LNFSwitcher","variables":{"o":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"JFrame":1,"WindowDemo2":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    JFrame f = new WindowDemo2();\n    f.setVisible(true);\n}\n","name":"main","className":"WindowDemo2","variables":{"f":2},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"WindowDemo2","methodCalls":{"addWindowListener":1,"setSize":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public WindowDemo2() {\n    setSize(200, 100);\n    setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);\n    addWindowListener(new WindowDemoAdapter());\n}\n","name":"WindowDemo2","className":"WindowDemo2","variables":{},"constants":{"100":1,"200":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"random":1,"exit":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":2,"ThisExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"public void windowClosing(WindowEvent e) {\n    // whimsy - close randomly, ~ 1 times in 3\n    if (Math.random() > 0.666) {\n        System.out.println(\"Goodbye!\");\n        // window will close\n        WindowDemo2.this.setVisible(false);\n        // and be freed up.\n        WindowDemo2.this.dispose();\n        System.exit(0);\n    }\n    System.out.println(\"You asked me to close, but not to I chose.\");\n}\n","name":"windowClosing","className":"WindowDemoAdapter","variables":{"WindowDemo2":2,"Math":1,"System":1},"constants":{"0":1,"0.666":1,"\"Goodbye!\"":1,"\"You asked me to close, but not to I chose.\"":1,"false":1},"javaDoc":"","comments":"whimsy - close randomly ~ 1 times in 3 window will close and be freed up ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"TabPaneDemo","methodCalls":{"add":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"NameExpr":13,"StringLiteralExpr":4,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public TabPaneDemo() {\n    tabPane = new JTabbedPane();\n    tabPane.add(new JLabel(\"One\", JLabel.CENTER), \"First\");\n    tabPane.add(new JLabel(\"Two\", JLabel.CENTER), \"Second\");\n}\n","name":"TabPaneDemo","className":"TabPaneDemo","variables":{"tabPane":3},"constants":{"\"First\"":1,"\"Second\"":1,"\"One\"":1,"\"Two\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"getContentPane":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":13,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] a) {\n    JFrame f = new JFrame(\"Tab Demo\");\n    f.getContentPane().add(new TabPaneDemo().tabPane);\n    f.setSize(120, 100);\n    f.setVisible(true);\n}\n","name":"main","className":"TabPaneDemo","variables":{"f":4},"constants":{"\"Tab Demo\"":1,"100":1,"true":1,"120":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent evt) {\n    System.out.println(\"Thank you!\");\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{"\"Thank you!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JLabelHTMLDemo","methodCalls":{"add":1,"setSize":1,"addActionListener":1,"getContentPane":1,"setDefaultCloseOperation":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Container":1,"JButton":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":5,"StringLiteralExpr":8,"NameExpr":26,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":7},"text":"/** Construct the object including its GUI */\npublic JLabelHTMLDemo() {\n    super(\"JLabelHTMLDemo\");\n    Container cp = getContentPane();\n    JButton component = new JButton(\"<html>\" + \"<body bgcolor='white'>\" + \"<h1><font color='red'>Welcome</font></h1>\" + \"<p>This button will be formatted according to the usual \" + \"HTML rules for formatting of paragraphs.</p>\" + \"</body></html>\");\n    component.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent evt) {\n            System.out.println(\"Thank you!\");\n        }\n    });\n    cp.add(BorderLayout.CENTER, component);\n    setSize(200, 400);\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n}\n","name":"JLabelHTMLDemo","className":"JLabelHTMLDemo","variables":{"actionPerformed":1,"component":2,"evt":1,"cp":2},"constants":{"\"<html>\"":1,"\"<body bgcolor='white'>\"":1,"\"</body></html>\"":1,"200":1,"\"Thank you!\"":1,"400":1,"\"<p>This button will be formatted according to the usual \"":1,"\"HTML rules for formatting of paragraphs.</p>\"":1,"\"JLabelHTMLDemo\"":1,"\"<h1><font color='red'>Welcome</font></h1>\"":1},"javaDoc":"Construct the object including its GUI","comments":" Construct the object including its GUI ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new JLabelHTMLDemo().setVisible(true);\n}\n","name":"main","className":"JLabelHTMLDemo","variables":{},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"assertEquals":1,"getFullName":1},"annotations":["Test"],"exceptions":[],"concepts":[],"types":{"String":1,"Person":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"StringLiteralExpr":4,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"@Test\npublic void testNameConcat() {\n    Person p = new Person(\"Ian\", \"Darwin\");\n    String f = p.getFullName();\n    assertEquals(\"Name concatenation\", \"Ian Darwin\", f);\n}\n","name":"testNameConcat","className":"PersonTest","variables":{"p":2,"f":1},"constants":{"\"Ian Darwin\"":1,"\"Name concatenation\"":1,"\"Darwin\"":1,"\"Ian\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"equals":1,"assertThat":1,"getFullName":1},"annotations":["Test"],"exceptions":[],"concepts":[],"types":{"String":1,"Person":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"StringLiteralExpr":4,"NameExpr":8,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"@Test\npublic void testNameConcat() {\n    Person p = new Person(\"Ian\", \"Darwin\");\n    String f = p.getFullName();\n    assertThat(\"Name concatenation\", f, equals(\"Ian Darwin\"));\n}\n","name":"testNameConcat","className":"HamcrestDemo","variables":{"p":2,"f":1},"constants":{"\"Ian Darwin\"":1,"\"Name concatenation\"":1,"\"Darwin\"":1,"\"Ian\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":14,"StringLiteralExpr":2,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"AssertStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    int i = 4;\n    if (args.length == 1) {\n        i = Integer.parseInt(args[0]);\n    }\n    assert i > 0 : \"i is non-positive\";\n    System.out.println(\"Hello after an assertion\");\n}\n","name":"main","className":"AssertDemo","variables":{"Integer":1,"args":1,"i":3},"constants":{"0":2,"1":1,"4":1,"\"Hello after an assertion\"":1,"\"i is non-positive\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"not":1,"containsString":2,"equalTo":1,"assertThat":3,"getFullName":1},"annotations":["Test"],"exceptions":[],"concepts":[],"types":{"String":1,"Person":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"StringLiteralExpr":5,"NameExpr":20,"MethodCallExpr":8},"statements":{"ExpressionStmt":5},"text":"@Test\npublic void testNameConcat() {\n    Person p = new Person(\"Ian\", \"Darwin\");\n    String f = p.getFullName();\n    assertThat(f, containsString(\"Ian\"));\n    assertThat(f, equalTo(\"Ian Darwin\"));\n    // contrived, to show syntax\n    assertThat(f, not(containsString(\"/\")));\n}\n","name":"testNameConcat","className":"HamcrestDemo","variables":{"p":2,"f":1},"constants":{"\"Ian Darwin\"":1,"\"/\"":1,"\"Darwin\"":1,"\"Ian\"":2},"javaDoc":"","comments":"contrived to show syntax ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// declare native class\npublic native void displayHelloJni();\n","name":"displayHelloJni","className":"HelloJni","variables":{},"constants":{},"javaDoc":"","comments":" declare native class","isEmpty":true,"hasInnerClass":false,"modifier":257}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"displayHelloJni":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"HelloJni":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":7,"NameExpr":32,"StringLiteralExpr":5,"FieldAccessExpr":6,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"ForStmt":1,"ExpressionStmt":5},"text":"// Application main, call its display method\npublic static void main(String[] args) {\n    System.out.println(\"HelloJni starting; args.length=\" + args.length + \"...\");\n    for (int i = 0; i < args.length; i++) System.out.println(\"args[\" + i + \"]=\" + args[i]);\n    HelloJni hw = new HelloJni();\n    // call the native function\n    hw.displayHelloJni();\n    System.out.println(\"Back in Java, \\\"myNumber\\\" now \" + hw.myNumber);\n}\n","name":"main","className":"HelloJni","variables":{"args":1,"i":5,"hw":2},"constants":{"0":1,"\"]=\"":1,"\"...\"":1,"\"args[\"":1,"\"HelloJni starting; args.length=\"":1,"\"Back in Java, \\\"myNumber\\\" now \"":1},"javaDoc":"","comments":"call the native function  Application main, call its display method","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"get":1,"getInstance":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"Button":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":14,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ExpressionStmt":2},"text":"/**\n     * Construct the GUI\n     * @throws java.lang.IllegalArgumentException if constructed on a Sunday.\n     */\npublic void JavadocDemo() {\n    // We create and add a pushbutton here, \n    // but it doesn't do anything yet.\n    Button b = new Button(\"Hello\");\n    // connect Button into component\n    add(b);\n    // Totally capricious example of what you should not do\n    if (Calendar.getInstance().get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {\n        throw new IllegalArgumentException(\"Never On A Sunday\");\n    }\n}\n","name":"JavadocDemo","className":"JavadocDemo","variables":{"b":1,"Calendar":1},"constants":{"\"Hello\"":1,"\"Never On A Sunday\"":1},"javaDoc":"Construct the GUI @throws java lang IllegalArgumentException if constructed on a Sunday","comments":"We create and add a pushbutton here but it doesn't do anything yet connect Button into component Totally capricious example of what you should not do \n     * Construct the GUI\n     * @throws java.lang.IllegalArgumentException if constructed on a Sunday.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getSize":2,"setColor":3,"fillRect":2,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":40,"StringLiteralExpr":1,"FieldAccessExpr":5,"MethodCallExpr":8},"statements":{"ExpressionStmt":7},"text":"/** paint() is an AWT Component method, called when the \n     *  component needs to be painted. This one just draws colored\n     * boxes in the window.\n     *\n     * @param g A java.awt.Graphics that we use for all our\n     * drawing methods.\n     */\npublic void paint(Graphics g) {\n    int w = getSize().width, h = getSize().height;\n    g.setColor(Color.YELLOW);\n    g.fillRect(0, 0, w / 2, h);\n    g.setColor(Color.GREEN);\n    g.fillRect(w / 2, 0, w, h);\n    g.setColor(Color.BLACK);\n    g.drawString(\"Welcome to Java\", 50, 50);\n}\n","name":"paint","className":"JavadocDemo","variables":{"w":3,"g":6,"h":1},"constants":{"0":3,"2":2,"50":2,"\"Welcome to Java\"":1},"javaDoc":"paint() is an AWT Component method called when the component needs to be painted This one just draws colored boxes in the window g A java awt Graphics that we use for all our drawing methods","comments":" paint() is an AWT Component method, called when the \n     *  component needs to be painted. This one just draws colored\n     * boxes in the window.\n     *\n     * @param g A java.awt.Graphics that we use for all our\n     * drawing methods.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"doArgs":1},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"CrossRef":1,"CrossRefXML":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] argv) throws IOException {\n    CrossRef xref = new CrossRefXML();\n    xref.doArgs(argv);\n}\n","name":"main","className":"CrossRefXML","variables":{"xref":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Class<?>"],"returnType":"void","methodCalls":{"println":1,"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"/** Print the start of a class.\n     */\nprotected void startClass(Class<?> c) {\n    println(\"<class><classname>\" + c.getName() + \"</classname>\");\n}\n","name":"startClass","className":"CrossRefXML","variables":{"c":1},"constants":{"\"</classname>\"":1,"\"<class><classname>\"":1},"javaDoc":"Print the start of a class","comments":" Print the start of a class.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Field","Class<?>"],"returnType":"void","methodCalls":{"println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":3,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"protected void putField(Field fld, Class<?> c) {\n    println(\"<field>\" + fld + \"</field>\");\n}\n","name":"putField","className":"CrossRefXML","variables":{"fld":1},"constants":{"\"<field>\"":1,"\"</field>\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Method","Class<?>"],"returnType":"void","methodCalls":{"println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":3,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** put a Method's information to the standard output.\n     * Marked protected so you can override it (hint, hint).\n     */\nprotected void putMethod(Method method, Class<?> c) {\n    println(\"<method>\" + method + \"</method>\");\n}\n","name":"putMethod","className":"CrossRefXML","variables":{"method":1},"constants":{"\"</method>\"":1,"\"<method>\"":1},"javaDoc":"put a Method's information to the standard output Marked protected so you can override it (hint hint)","comments":" put a Method's information to the standard output.\n     * Marked protected so you can override it (hint, hint).\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Print the end of a class. \n     */\nprotected void endClass() {\n    println(\"</class>\");\n}\n","name":"endClass","className":"CrossRefXML","variables":{},"constants":{"\"</class>\"":1},"javaDoc":"Print the end of a class","comments":" Print the end of a class. \n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"forName":1,"work":1,"newInstance":1,"initialize":1,"terminate":1,"System.err.println":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"Class<Cooklet>":1,"Cooklet":1,"String":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":30,"StringLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":2,"MethodCallExpr":7,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":9},"text":"public static void main(String[] argv) {\n    System.out.println(\"Cookies Application Version 0.0\");\n    Cooklet cooklet = null;\n    String cookletClassName = argv[0];\n    try {\n        Class<Cooklet> cookletClass = (Class<Cooklet>) Class.forName(cookletClassName);\n        cooklet = cookletClass.newInstance();\n    } catch (Exception e) {\n        System.err.println(\"Error \" + cookletClassName + e);\n    }\n    cooklet.initialize();\n    cooklet.work();\n    cooklet.terminate();\n}\n","name":"main","className":"Cookies","variables":{"cooklet":5,"e":2,"cookletClassName":2,"Class":1,"argv":1,"cookletClass":2},"constants":{"0":1,"\"Error \"":1,"null":1,"\"Cookies Application Version 0.0\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void work() {\n    System.out.println(\"I am busy baking cookies.\");\n}\n","name":"work","className":"DemoCooklet","variables":{},"constants":{"\"I am busy baking cookies.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void terminate() {\n    System.out.println(\"I am shutting down my ovens now.\");\n}\n","name":"terminate","className":"DemoCooklet","variables":{},"constants":{"\"I am shutting down my ovens now.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":4,"StringLiteralExpr":1,"FieldAccessExpr":1,"ConditionalExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Main is where it all starts. \n     * Construct the GUI. Load the Applet. Start it running.\n     */\npublic static void main(String[] av) {\n    new AppletViewer(av.length == 0 ? \"HelloApplet\" : av[0]);\n}\n","name":"main","className":"AppletViewer","variables":{"av":1},"constants":{"0":2,"\"HelloApplet\"":1},"javaDoc":"Main is where it all starts Construct the GUI Load the Applet Start it running","comments":" Main is where it all starts. \n     * Construct the GUI. Load the Applet. Start it running.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"setVisible":1,"exit":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void windowClosing(WindowEvent e) {\n    f.setVisible(false);\n    f.dispose();\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"f":2,"System":1},"constants":{"0":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"AppletViewer","methodCalls":{"setVisible":2,"add":2,"setStub":1,"init":1,"start":1,"getContentPane":1,"showStatus":2,"setLayout":1,"addWindowListener":1,"exit":1,"loadApplet":1,"getSize":2,"setSize":1,"dispose":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Container":1,"Dimension":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"NullLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":2,"BinaryExpr":5,"NameExpr":80,"StringLiteralExpr":4,"FieldAccessExpr":5,"ThisExpr":1,"AssignExpr":4,"MethodCallExpr":18},"statements":{"IfStmt":2,"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ReturnStmt":1,"ExpressionStmt":21},"text":"/** Construct the GUI for an Applet Viewer */\nAppletViewer(String appName) {\n    super();\n    this.appName = appName;\n    f = new JFrame(\"AppletViewer\");\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            f.setVisible(false);\n            f.dispose();\n            System.exit(0);\n        }\n    });\n    Container cp = f.getContentPane();\n    cp.setLayout(new BorderLayout());\n    // AppletStub and AppletContext.\n    if (aa == null)\n        aa = new AppletAdapter();\n    // The AppletAdapter also gives us showStatus.\n    // Therefore, must add() it very early on, since the Applet's\n    // Constructor or its init() may use showStatus()\n    cp.add(BorderLayout.SOUTH, aa);\n    showStatus(\"Loading Applet \" + appName);\n    // sets ac and ai\n    loadApplet(appName, WIDTH, HEIGHT);\n    if (ai == null)\n        return;\n    // Now right away, tell the Applet how to find showStatus et al.\n    ai.setStub(aa);\n    // Connect the Applet to the Frame.\n    cp.add(BorderLayout.CENTER, ai);\n    Dimension d = ai.getSize();\n    d.height += aa.getSize().height;\n    f.setSize(d);\n    // make the Frame and all in it appear\n    f.setVisible(true);\n    showStatus(\"Applet \" + appName + \" loaded\");\n    // Here we pretend to be a browser!\n    ai.init();\n    ai.start();\n}\n         // Instantiate the AppletAdapter which gives us\n\n","name":"AppletViewer","className":"AppletViewer","variables":{"aa":3,"d":1,"e":1,"windowClosing":1,"appName":3,"f":7,"ai":5,"cp":4,"System":1},"constants":{"0":1,"\" loaded\"":1,"\"Applet \"":1,"null":2,"false":1,"true":1,"\"Loading Applet \"":1,"\"AppletViewer\"":1},"javaDoc":"Construct the GUI for an Applet Viewer","comments":"Instantiate the AppletAdapter which gives us The AppletAdapter also gives us showStatus Therefore must add() it very early on since the Applet's AppletStub and AppletContext Constructor or its init() may use showStatus() sets ac and ai Now right away tell the Applet how to find showStatus et al Connect the Applet to the Frame make the Frame and all in it appear Here we pretend to be a browser!  Construct the GUI for an Applet Viewer ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String","int","int"],"returnType":"void","methodCalls":{"setSize":1,"forName":1,"newInstance":1,"showStatus":2},"annotations":[],"exceptions":["ClassNotFoundException","Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":20,"CastExpr":1,"StringLiteralExpr":4,"AssignExpr":2,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":3,"ReturnStmt":2,"ExpressionStmt":5},"text":"/*\n     * Load the Applet into memory. Should do caching.\n     */\nvoid loadApplet(String appletName, int w, int h) {\n    // height =         ditto\n    try {\n        // get a Class object for the Applet subclass\n        ac = Class.forName(appletName);\n        // Construct an instance (as if using no-argument constructor)\n        ai = (Applet) ac.newInstance();\n    } catch (ClassNotFoundException e) {\n        showStatus(\"Applet subclass \" + appletName + \" did not load\");\n        return;\n    } catch (Exception e) {\n        showStatus(\"Applet \" + appletName + \" did not instantiate\");\n        return;\n    }\n    ai.setSize(w, h);\n}\n         // appletName = ... extract from the HTML CODE= somehow ...;\n\n         // width =         ditto\n\n","name":"loadApplet","className":"AppletViewer","variables":{"ac":2,"e":2,"ai":2,"Class":1,"appletName":2},"constants":{"\"Applet \"":1,"\" did not instantiate\"":1,"\" did not load\"":1,"\"Applet subclass \"":1},"javaDoc":"","comments":"appletName = extract from the HTML CODE= somehow ; width = ditto height = ditto get a Class object for the Applet subclass Construct an instance (as if using no-argument constructor) \n     * Load the Applet into memory. Should do caching.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getAppletContext":1,"showStatus":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void showStatus(String s) {\n    aa.getAppletContext().showStatus(s);\n}\n","name":"showStatus","className":"AppletViewer","variables":{"aa":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"doClass":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MyJavaP":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":21,"StringLiteralExpr":1,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/** Simple main program, construct self, process each class name\n     * found in argv.\n     */\npublic static void main(String[] argv) {\n    MyJavaP pp = new MyJavaP();\n    if (argv.length == 0) {\n        System.err.println(\"Usage: MyJavaP className [...]\");\n        System.exit(1);\n    } else\n        for (int i = 0; i < argv.length; i++) pp.doClass(argv[i]);\n}\n","name":"main","className":"MyJavaP","variables":{"pp":2,"i":4,"argv":1,"System":1},"constants":{"0":2,"1":1,"\"Usage: MyJavaP className [...]\"":1},"javaDoc":"Simple main program construct self process each class name found in argv","comments":" Simple main program, construct self, process each class name\n     * found in argv.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"getDeclaredFields":1,"getDeclaredMethods":1,"forName":1,"getConstructors":1,"isPrivate":2,"getModifiers":2,"System.err.println":2,"getAnnotations":3,"System.out.println":8},"annotations":[],"exceptions":["ClassNotFoundException","Exception"],"concepts":["FinalVariables","ExceptionHandling"],"types":{"Class<? extends Object>":1,"Field":2,"Constructor<? extends Object>[]":1,"Constructor<? extends Object>":1,"Method":2,"Annotation[]":3,"Annotation":3},"expressions":{"VariableDeclarationExpr":13,"BinaryExpr":10,"NameExpr":99,"StringLiteralExpr":11,"FieldAccessExpr":10,"UnaryExpr":2,"MethodCallExpr":21},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":10,"ForeachStmt":6,"ExpressionStmt":17},"text":"/** Format the fields and methods of one class, given its name.\n     */\nprotected void doClass(String className) {\n    try {\n        Class<? extends Object> c = Class.forName(className);\n        final Annotation[] annotations = c.getAnnotations();\n        for (Annotation a : annotations) {\n            System.out.println(a);\n        }\n        System.out.println(c + \" {\");\n        Field fields[] = c.getDeclaredFields();\n        for (Field f : fields) {\n            final Annotation[] fldAnnotations = f.getAnnotations();\n            for (Annotation a : fldAnnotations) {\n                System.out.println(a);\n            }\n            if (!Modifier.isPrivate(f.getModifiers()))\n                System.out.println(\"\\t\" + f + \";\");\n        }\n        Constructor<? extends Object>[] constructors = c.getConstructors();\n        for (Constructor<? extends Object> con : constructors) {\n            System.out.println(\"\\t\" + con + \";\");\n        }\n        Method methods[] = c.getDeclaredMethods();\n        for (Method m : methods) {\n            final Annotation[] methodAnnotations = m.getAnnotations();\n            for (Annotation a : methodAnnotations) {\n                System.out.println(a);\n            }\n            if (!Modifier.isPrivate(m.getModifiers())) {\n                System.out.println(\"\\t\" + m + \";\");\n            }\n        }\n        System.out.println(\"}\");\n    } catch (ClassNotFoundException e) {\n        System.err.println(\"Error: Class \" + className + \" not found!\");\n    } catch (Exception e) {\n        System.err.println(\"JavaP Error: \" + e);\n    }\n}\n","name":"doClass","className":"MyJavaP","variables":{"a":3,"c":6,"con":2,"e":3,"f":4,"fldAnnotations":2,"methods":2,"annotations":2,"className":1,"m":4,"constructors":2,"methodAnnotations":2,"Class":1,"fields":2,"Modifier":2},"constants":{"\"Error: Class \"":1,"\" not found!\"":1,"\"}\"":1,"\"\\t\"":3,"\";\"":3,"\"JavaP Error: \"":1,"\" {\"":1},"javaDoc":"Format the fields and methods of one class given its name","comments":" Format the fields and methods of one class, given its name.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"forName":1,"getConstructors":1,"printList":2,"System.err.println":1,"getMethods":1},"annotations":[],"exceptions":["ClassNotFoundException"],"concepts":[],"types":{"Constructor<?>[]":1,"Class<?>":1,"Method[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":24,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] argv) throws ClassNotFoundException {\n    if (argv.length == 0) {\n        System.err.println(\"Usage: ListMethods className\");\n        return;\n    }\n    Class<?> c = Class.forName(argv[0]);\n    Constructor<?>[] cons = c.getConstructors();\n    printList(\"Constructors\", cons);\n    Method[] meths = c.getMethods();\n    printList(\"Methods\", meths);\n}\n","name":"main","className":"ListMethods","variables":{"c":3,"meths":1,"Class":1,"argv":1,"cons":1},"constants":{"0":2,"\"Methods\"":1,"\"Constructors\"":1,"\"Usage: ListMethods className\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Object[]"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"static void printList(String s, Object[] o) {\n    System.out.println(\"*** \" + s + \" ***\");\n    for (int i = 0; i < o.length; i++) System.out.println(o[i].toString());\n}\n","name":"printList","className":"ListMethods","variables":{"s":1,"i":4,"o":1},"constants":{"0":1,"\"*** \"":1,"\" ***\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"java.lang.Package.getPackages":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"java.lang.Package[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":19,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    java.lang.Package[] all = java.lang.Package.getPackages();\n    for (int i = 0; i < all.length; i++) System.out.println(all[i]);\n// END main\n}\n","name":"main","className":"Packages","variables":{"all":2,"i":4},"constants":{"0":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Class<? extends Annotation>"],"returnType":"List<Class<?>>","methodCalls":{"add":1,"forName":1,"isAnnotationPresent":1,"getPackageContent":1},"annotations":[],"exceptions":["Exception"],"concepts":["PolyMorphism"],"types":{"List<Class<?>>":1,"ArrayList":1,"String[]":1,"String":1,"Class<?>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"NameExpr":18,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * Find all classes in the given package which have the given\n     * class-level annotation class.\n     */\npublic static List<Class<?>> findAnnotatedClasses(String packageName, Class<? extends Annotation> annotationClass) throws Exception {\n    List<Class<?>> ret = new ArrayList<>();\n    String[] classes = ClassesInPackage.getPackageContent(packageName);\n    for (String clazz : classes) {\n        Class<?> c = Class.forName(clazz);\n        if (c.isAnnotationPresent(annotationClass))\n            ret.add(c);\n    }\n    return ret;\n}\n","name":"findAnnotatedClasses","className":"PluginsViaAnnotations","variables":{"ret":3,"ClassesInPackage":1,"c":2,"classes":2,"Class":1,"clazz":1},"constants":{},"javaDoc":"Find all classes in the given package which have the given class-level annotation class","comments":"\n     * Find all classes in the given package which have the given\n     * class-level annotation class.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Class<? extends Annotation>"],"returnType":"List<Class<?>>","methodCalls":{"add":1,"forName":1,"isAnnotationPresent":1,"getPackageContent":1,"getMethods":1},"annotations":[],"exceptions":["Exception"],"concepts":["PolyMorphism"],"types":{"List<Class<?>>":1,"ArrayList":1,"String[]":1,"String":1,"Method":1,"Class<?>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"NameExpr":21,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * Find all classes in the given package which have the given\n     * method-level annotation class on at least one method.\n     */\npublic static List<Class<?>> findClassesWithAnnotatedMethods(String packageName, Class<? extends Annotation> methodAnnotationClass) throws Exception {\n    List<Class<?>> ret = new ArrayList<>();\n    String[] classes = ClassesInPackage.getPackageContent(packageName);\n    for (String clazz : classes) {\n        Class<?> c = Class.forName(clazz);\n        for (Method m : c.getMethods()) {\n            if (m.isAnnotationPresent(methodAnnotationClass)) {\n                ret.add(c);\n            }\n        }\n    }\n    return ret;\n}\n","name":"findClassesWithAnnotatedMethods","className":"PluginsViaAnnotations","variables":{"ret":3,"ClassesInPackage":1,"c":2,"classes":2,"Class":1,"clazz":1,"m":2},"constants":{},"javaDoc":"Find all classes in the given package which have the given method-level annotation class on at least one method","comments":"\n     * Find all classes in the given package which have the given\n     * method-level annotation class on at least one method.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"AppletAdapter","methodCalls":{"add":1,"getSize":2,"setSize":1,"showStatus":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":5,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":3},"text":"/** Construct the GUI for an Applet Status window */\nAppletAdapter() {\n    super();\n    // Must do this very early on, since the Applet's\n    // Constructor or its init() may use showStatus()\n    add(status = new Label());\n    // Give \"status\" the full width\n    status.setSize(getSize().width, status.getSize().height);\n    // now it can be said\n    showStatus(\"AppletAdapter constructed\");\n}\n","name":"AppletAdapter","className":"AppletAdapter","variables":{"status":3},"constants":{"\"AppletAdapter constructed\"":1},"javaDoc":"Construct the GUI for an Applet Status window","comments":"Must do this very early on since the Applet's Constructor or its init() may use showStatus() Give \"status\" the full width now it can be said  Construct the GUI for an Applet Status window ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Called when the applet wants to be resized.  */\npublic void appletResize(int w, int h) {\n// applet.setSize(w, h);\n}\n","name":"appletResize","className":"AppletAdapter","variables":{},"constants":{},"javaDoc":"Called when the applet wants to be resized","comments":"applet setSize(w h);  Called when the applet wants to be resized.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"AppletContext","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ThisExpr":1},"statements":{"ReturnStmt":1},"text":"/** Gets a reference to the applet's context.  */\npublic AppletContext getAppletContext() {\n    return this;\n}\n","name":"getAppletContext","className":"AppletAdapter","variables":{},"constants":{},"javaDoc":"Gets a reference to the applet's context","comments":" Gets a reference to the applet's context.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"URL","methodCalls":{"getClass":1,"getResource":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** Gets the base URL.  */\npublic URL getCodeBase() {\n    return getClass().getResource(\".\");\n}\n","name":"getCodeBase","className":"AppletAdapter","variables":{},"constants":{"\".\"":1},"javaDoc":"Gets the base URL","comments":" Gets the base URL.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"URL","methodCalls":{"getClass":1,"getResource":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** Gets the document URL.  */\npublic URL getDocumentBase() {\n    return getClass().getResource(\".\");\n}\n","name":"getDocumentBase","className":"AppletAdapter","variables":{},"constants":{"\".\"":1},"javaDoc":"Gets the document URL","comments":" Gets the document URL.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Returns the value of the named parameter in the HTML tag.  */\npublic String getParameter(String name) {\n    String value = null;\n    return value;\n}\n","name":"getParameter","className":"AppletAdapter","variables":{"value":2},"constants":{"null":1},"javaDoc":"Returns the value of the named parameter in the HTML tag","comments":" Returns the value of the named parameter in the HTML tag.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** Determines if the applet is active.  */\npublic boolean isActive() {\n    return true;\n}\n","name":"isActive","className":"AppletAdapter","variables":{},"constants":{"true":1},"javaDoc":"Determines if the applet is active","comments":" Determines if the applet is active.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Applet","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** Finds and returns the applet with the given name. */\npublic Applet getApplet(String an) {\n    return null;\n}\n","name":"getApplet","className":"AppletAdapter","variables":{},"constants":{"null":1},"javaDoc":"Finds and returns the applet with the given name","comments":" Finds and returns the applet with the given name. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean hasMoreElements() {\n    return false;\n}\n","name":"hasMoreElements","className":"AppletLister","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Applet","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public Applet nextElement() {\n    return null;\n}\n","name":"nextElement","className":"AppletLister","variables":{},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Enumeration<Applet>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["InnerMethod","InnerClass"],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":6},"statements":{"TypeDeclarationStmt":1,"BlockStmt":2,"ReturnStmt":3},"text":"/** Finds all the applets in the document\n     * XXX NOT REALLY IMPLEMENTED\n     */\npublic Enumeration<Applet> getApplets() {\n    class AppletLister implements Enumeration<Applet> {\n\n        public boolean hasMoreElements() {\n            return false;\n        }\n\n        public Applet nextElement() {\n            return null;\n        }\n    }\n    return new AppletLister();\n}\n","name":"getApplets","className":"AppletAdapter","variables":{"AppletLister":1,"hasMoreElements":1,"nextElement":1},"constants":{"null":1,"false":1},"javaDoc":"Finds all the applets in the document XXX NOT REALLY IMPLEMENTED","comments":" Finds all the applets in the document\n     * XXX NOT REALLY IMPLEMENTED\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["URL"],"returnType":"AudioClip","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** Create an audio clip for the given URL of a .au file */\npublic AudioClip getAudioClip(URL u) {\n    return null;\n}\n","name":"getAudioClip","className":"AppletAdapter","variables":{},"constants":{"null":1},"javaDoc":"Create an audio clip for the given URL of a au file","comments":" Create an audio clip for the given URL of a .au file ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["URL"],"returnType":"Image","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** Look up and create an Image object that can be paint()ed */\npublic Image getImage(URL u) {\n    return null;\n}\n","name":"getImage","className":"AppletAdapter","variables":{},"constants":{"null":1},"javaDoc":"Look up and create an Image object that can be paint()ed","comments":" Look up and create an Image object that can be paint()ed ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["URL"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Request to overlay the current page with a new one - ignored */\npublic void showDocument(URL u) {\n}\n","name":"showDocument","className":"AppletAdapter","variables":{},"constants":{},"javaDoc":"Request to overlay the current page with a new one - ignored","comments":" Request to overlay the current page with a new one - ignored ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["URL","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** as above but with a Frame target */\npublic void showDocument(URL u, String frame) {\n}\n","name":"showDocument","className":"AppletAdapter","variables":{},"constants":{},"javaDoc":"as above but with a Frame target","comments":" as above but with a Frame target ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Called by the Applet to display a message in the bottom line */\npublic void showStatus(String msg) {\n    if (msg == null)\n        msg = \"\";\n    status.setText(msg);\n}\n","name":"showStatus","className":"AppletAdapter","variables":{"msg":2,"status":1},"constants":{"\"\"":1,"null":1},"javaDoc":"Called by the Applet to display a message in the bottom line","comments":" Called by the Applet to display a message in the bottom line ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","InputStream"],"returnType":"void","methodCalls":{"put":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Associate the stream with the key. */\npublic void setStream(String key, InputStream stream) throws IOException {\n    streamMap.put(key, stream);\n}\n","name":"setStream","className":"AppletAdapter","variables":{"streamMap":1},"constants":{},"javaDoc":"Associate the stream with the key","comments":" Associate the stream with the key. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"InputStream","methodCalls":{"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public InputStream getStream(String key) {\n    return (InputStream) streamMap.get(key);\n}\n","name":"getStream","className":"AppletAdapter","variables":{"streamMap":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Iterator<String>","methodCalls":{"iterator":1,"keySet":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public Iterator<String> getStreamKeys() {\n    return streamMap.keySet().iterator();\n}\n","name":"getStreamKeys","className":"AppletAdapter","variables":{"streamMap":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getClass":1,"getInstance":1,"System.out.println":11},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":6,"NameExpr":62,"StringLiteralExpr":9,"FieldAccessExpr":11,"ClassExpr":6,"MethodCallExpr":14},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] argv) {\n    // BEGIN main\n    System.out.println(\"Trying the ClassName.class keyword:\");\n    System.out.println(\"Object class: \" + Object.class);\n    System.out.println(\"String class: \" + String.class);\n    System.out.println(\"String[] class: \" + String[].class);\n    System.out.println(\"Calendar class: \" + Calendar.class);\n    System.out.println(\"Current class: \" + ClassKeyword.class);\n    System.out.println(\"Class for int: \" + int.class);\n    System.out.println();\n    System.out.println(\"Trying the instance.getClass() method:\");\n    System.out.println(\"Sir Robin the Brave\".getClass());\n    System.out.println(Calendar.getInstance().getClass());\n// END main\n}\n","name":"main","className":"ClassKeyword","variables":{"Calendar":1},"constants":{"\"String[] class: \"":1,"\"Trying the ClassName.class keyword:\"":1,"\"Calendar class: \"":1,"\"Trying the instance.getClass() method:\"":1,"\"Current class: \"":1,"\"Object class: \"":1,"\"String class: \"":1,"\"Class for int: \"":1,"\"Sir Robin the Brave\"":1},"javaDoc":"","comments":"END main BEGIN main ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","String"],"returnType":"void","methodCalls":{"System.out.printf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void work(int i, String s) {\n    System.out.printf(\"Called: i=%d, s=%s%n\", i, s);\n}\n","name":"work","className":"X","variables":{},"constants":{"\"Called: i=%d, s=%s%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// The main code does not use this overload.\npublic void work(int i) {\n    System.out.println(\"Unexpected call!\");\n}\n","name":"work","className":"X","variables":{},"constants":{"\"Unexpected call!\"":1},"javaDoc":"","comments":" The main code does not use this overload.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"invoke":1,"getMethod":1,"System.err.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Class<?>[]":1,"Method":1,"Class<?>":1,"Object[]":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"ArrayInitializerExpr":2,"BinaryExpr":1,"NameExpr":14,"StringLiteralExpr":3,"ClassExpr":3,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"public static void main(String[] argv) {\n    try {\n        // or Class.forName(\"X\");\n        Class<?> clX = X.class;\n        // To find a method we need the array of matching Class types.\n        Class<?>[] argTypes = { int.class, String.class };\n        // Now find a Method object for the given method.\n        Method worker = clX.getMethod(\"work\", argTypes);\n        // To INVOKE the method, we need the invocation\n        // arguments, as an Object array.\n        Object[] theData = { 42, \"Chocolate Chips\" };\n        // The obvious last step: invoke the method.\n        // First arg is an instance, null if static method\n        worker.invoke(new X(), theData);\n    } catch (Exception e) {\n        System.err.println(\"Invoke() failed: \" + e);\n    }\n}\n","name":"main","className":"GetAndInvokeMethod","variables":{"argTypes":1,"theData":1,"e":2,"worker":2,"clX":2},"constants":{"\"Invoke() failed: \"":1,"\"work\"":1,"\"Chocolate Chips\"":1,"42":1},"javaDoc":"","comments":"To INVOKE the method we need the invocation The obvious last step: invoke the method or Class forName(\"X\"); To find a method we need the array of matching Class types Now find a Method object for the given method arguments as an Object array First arg is an instance null if static method ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) throws Exception {\n    new DefeatPrivacy().process();\n}\n","name":"main","className":"DefeatPrivacy","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getClass":1,"getDeclaredFields":1,"setAccessible":2,"get":1,"System.out.println":3},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Field":1,"X":1,"Class<? extends X>":1,"Field[]":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":2,"BinaryExpr":2,"NameExpr":37,"StringLiteralExpr":1,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":8},"text":"private void process() throws Exception {\n    X x = new X();\n    System.out.println(x);\n    // System.out.println(x.p); // Won't compile\n    System.out.println(x.q);\n    Class<? extends X> class1 = x.getClass();\n    Field[] flds = class1.getDeclaredFields();\n    for (Field f : flds) {\n        // bye-bye \"private\"\n        f.setAccessible(true);\n        System.out.println(f + \"==\" + f.get(x));\n        // reset to \"correct\" state\n        f.setAccessible(false);\n    }\n}\n","name":"process","className":"DefeatPrivacy","variables":{"class1":2,"f":5,"x":2,"flds":2},"constants":{"\"==\"":1,"true":1,"false":1},"javaDoc":"","comments":"System out println(x p); // Won't compile bye-bye \"private\" reset to \"correct\" state ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"String[]","methodCalls":{"add":2,"currentThread":1,"getName":2,"replace":1,"getProtocol":1,"getFile":1,"substring":1,"entries":1,"getResources":1,"getContextClassLoader":1,"hasMoreElements":2,"endsWith":1,"toArray":1,"listFiles":1,"indexOf":2,"nextElement":2,"startsWith":1},"annotations":[],"exceptions":["IllegalStateException","IOException"],"concepts":["FinalVariables","PolyMorphism"],"types":{"ArrayList":1,"Enumeration<URL>":1,"String":4,"JarFile":1,"JarEntry":1,"File":2,"Enumeration<JarEntry>":1,"URL":1,"int":2,"List<String>":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":14,"ArrayInitializerExpr":1,"BinaryExpr":5,"NameExpr":73,"StringLiteralExpr":7,"CharLiteralExpr":2,"UnaryExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":22},"statements":{"SwitchStmt":1,"IfStmt":1,"WhileStmt":2,"BreakStmt":2,"BlockStmt":4,"SwitchEntryStmt":3,"ForeachStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":15},"text":"/** This approach began as a contribution by Paul Kuit at\n     * http://stackoverflow.com/questions/1456930/, but his only\n     * handled single files in a directory in classpath, not in Jar files.\n     * N.B. Does NOT handle system classes!\n     * @param packageName\n     * @return\n     * @throws IOException\n     */\npublic static String[] getPackageContent(String packageName) throws IOException {\n    final String packageAsDirName = packageName.replace(\".\", \"/\");\n    final List<String> list = new ArrayList<>();\n    final Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(packageAsDirName);\n    while (urls.hasMoreElements()) {\n        URL url = urls.nextElement();\n        // System.out.println(\"URL = \" + url);\n        String file = url.getFile();\n        switch(url.getProtocol()) {\n            case \"file\":\n                // This is the easy case: \"file\" is \n                // the full path to the classpath directory\n                File dir = new File(file);\n                for (File f : dir.listFiles()) {\n                    list.add(packageAsDirName + \"/\" + f.getName());\n                }\n                break;\n            case \"jar\":\n                // This is the harder case; \"file\" is of the form\n                // \"jar:/home/ian/bleah/darwinsys.jar!com/darwinsys/io\"\n                // for some jar file that contains at least one class from \n                // the given package.\n                int colon = file.indexOf(':');\n                int bang = file.indexOf('!');\n                String jarFileName = file.substring(colon + 1, bang);\n                JarFile jarFile = new JarFile(jarFileName);\n                Enumeration<JarEntry> entries = jarFile.entries();\n                while (entries.hasMoreElements()) {\n                    JarEntry e = entries.nextElement();\n                    String jarEntryName = e.getName();\n                    if (!jarEntryName.endsWith(\"/\") && jarEntryName.startsWith(packageAsDirName)) {\n                        list.add(jarEntryName);\n                    }\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Dunno what to do with URL \" + url);\n        }\n    }\n    return list.toArray(new String[] {});\n}\n","name":"getPackageContent","className":"ClassesInPackage","variables":{"e":2,"jarEntryName":3,"f":2,"list":4,"dir":2,"url":4,"Thread":1,"packageAsDirName":2,"urls":3,"entries":3,"file":5,"jarFile":2,"bang":1,"colon":2,"packageName":1,"jarFileName":2},"constants":{"1":1,"':'":1,"\"/\"":3,"\".\"":1,"\"file\"":1,"\"Dunno what to do with URL \"":1,"\"jar\"":1,"'!'":1},"javaDoc":"This approach began as a contribution by Paul Kuit at http://stackoverflow com/questions/1456930/ but his only handled single files in a directory in classpath not in Jar files N B Does NOT handle system classes! packageName @throws IOException","comments":"System out println(\"URL = \" + url); This is the easy case: \"file\" is the full path to the classpath directory This is the harder case; \"file\" is of the form \"jar:/home/ian/bleah/darwinsys jar!com/darwinsys/io\" for some jar file that contains at least one class from the given package  This approach began as a contribution by Paul Kuit at\n     * http://stackoverflow.com/questions/1456930/, but his only\n     * handled single files in a directory in classpath, not in Jar files.\n     * N.B. Does NOT handle system classes!\n     * @param packageName\n     * @return\n     * @throws IOException\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getPackageContent":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String[]":1,"String":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":14,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) throws IOException {\n    String[] names = getPackageContent(\"com.darwinsys.io\");\n    for (String name : names) {\n        System.out.println(name);\n    }\n    System.out.println(\"Done\");\n}\n","name":"main","className":"ClassesInPackage","variables":{"names":2,"name":1},"constants":{"\"com.darwinsys.io\"":1,"\"Done\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"intFieldValue":1,"System.out.println":1},"annotations":[],"exceptions":["NoSuchFieldException","IllegalAccessException"],"concepts":["PolyMorphism"],"types":{"YearHolder":1,"Object":1,"FindField":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":9,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] unused) throws NoSuchFieldException, IllegalAccessException {\n    // Create instance of FindField\n    FindField gf = new FindField();\n    // Create instance of target class (YearHolder defined below).\n    Object o = new YearHolder();\n    // Use gf to extract a field from o.\n    System.out.println(\"The value of 'currentYear' is: \" + gf.intFieldValue(o, \"currentYear\"));\n}\n","name":"main","className":"FindField","variables":{"gf":2,"o":1},"constants":{"\"currentYear\"":1,"\"The value of 'currentYear' is: \"":1},"javaDoc":"","comments":"Create instance of FindField Create instance of target class (YearHolder defined below) Use gf to extract a field from o ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object","String"],"returnType":"int","methodCalls":{"getClass":1,"getInt":1,"getField":1},"annotations":[],"exceptions":["NoSuchFieldException","IllegalAccessException"],"concepts":[],"types":{"Field":1,"Class<?>":1,"int":1},"expressions":{"VariableDeclarationExpr":3,"NameExpr":12,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"int intFieldValue(Object o, String name) throws NoSuchFieldException, IllegalAccessException {\n    Class<?> c = o.getClass();\n    Field fld = c.getField(name);\n    int value = fld.getInt(o);\n    return value;\n}\n","name":"intFieldValue","className":"FindField","variables":{"c":2,"value":2,"o":1,"fld":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"doArgs":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"CrossRef":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Simple main program, construct self, process each .ZIP file\n     * found in CLASSPATH or in argv.\n     */\npublic static void main(String[] argv) throws IOException {\n    CrossRef xref = new CrossRef();\n    xref.doArgs(argv);\n}\n","name":"main","className":"CrossRef","variables":{"xref":2},"constants":{},"javaDoc":"Simple main program construct self process each ZIP file found in CLASSPATH or in argv","comments":" Simple main program, construct self, process each .ZIP file\n     * found in CLASSPATH or in argv.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Field","Field"],"returnType":"int","methodCalls":{"getName":2,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"MethodCallExpr":3},"statements":{"ReturnStmt":1},"text":"public int compare(Field o1, Field o2) {\n    return o1.getName().compareTo(o2.getName());\n}\n","name":"compare","className":"","variables":{"o1":1,"o2":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Method","Method"],"returnType":"int","methodCalls":{"getName":2,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"MethodCallExpr":3},"statements":{"ReturnStmt":1},"text":"public int compare(Method o1, Method o2) {\n    return o1.getName().compareTo(o2.getName());\n}\n","name":"compare","className":"","variables":{"o1":1,"o2":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Class<?>"],"returnType":"void","methodCalls":{"getDeclaredFields":1,"putField":1,"getDeclaredMethods":1,"getName":4,"printStackTrace":1,"endClass":1,"putMethod":1,"startClass":1,"sort":2,"compareTo":2,"isPrivate":2,"getModifiers":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","InnerMethod","ExceptionHandling"],"types":{"Field":1,"Method":1,"Field[]":1,"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":2,"NameExpr":76,"CastExpr":1,"FieldAccessExpr":2,"UnaryExpr":4,"MethodCallExpr":19},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":6,"ReturnStmt":2,"ForStmt":2,"ExpressionStmt":10},"text":"/**\n     * Print the fields and methods of one class.\n     */\nprotected void doClass(Class<?> c) {\n    startClass(c);\n    try {\n        Field[] fields = c.getDeclaredFields();\n        Arrays.sort(fields, new Comparator<Field>() {\n\n            public int compare(Field o1, Field o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n        for (int i = 0; i < fields.length; i++) {\n            Field field = (Field) fields[i];\n            if (!Modifier.isPrivate(field.getModifiers()))\n                putField(field, c);\n        // else System.err.println(\"private field ignored: \" + field);\n        }\n        Method methods[] = c.getDeclaredMethods();\n        Arrays.sort(methods, new Comparator<Method>() {\n\n            public int compare(Method o1, Method o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n        for (int i = 0; i < methods.length; i++) {\n            if (!Modifier.isPrivate(methods[i].getModifiers()))\n                putMethod(methods[i], c);\n        // else System.err.println(\"pvt: \" + methods[i]);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    endClass();\n}\n","name":"doClass","className":"CrossRef","variables":{"o1":4,"compare":2,"c":2,"o2":4,"field":2,"e":2,"methods":3,"i":9,"fields":2,"Arrays":2,"Modifier":2},"constants":{"0":2},"javaDoc":"Print the fields and methods of one class","comments":"else System err println(\"private field ignored: \" + field); else System err println(\"pvt: \" + methods[i]); \n     * Print the fields and methods of one class.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Field","Class<?>"],"returnType":"void","methodCalls":{"println":1,"getName":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":8,"StringLiteralExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"/** put a Field's information to the standard output.  */\nprotected void putField(Field fld, Class<?> c) {\n    println(fld.getName() + \" field \" + c.getName() + \" \");\n}\n","name":"putField","className":"CrossRef","variables":{"c":1,"fld":1},"constants":{"\" \"":1,"\" field \"":1},"javaDoc":"put a Field's information to the standard output","comments":" put a Field's information to the standard output.  ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Method","Class<?>"],"returnType":"void","methodCalls":{"println":1,"getName":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":9,"StringLiteralExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/** put a Method's information to the standard output.  */\nprotected void putMethod(Method method, Class<?> c) {\n    String methName = method.getName();\n    println(methName + \" method \" + c.getName() + \" \");\n}\n","name":"putMethod","className":"CrossRef","variables":{"methName":2,"c":1,"method":1},"constants":{"\" \"":1,"\" method \"":1},"javaDoc":"put a Method's information to the standard output","comments":" put a Method's information to the standard output.  ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Class<?>"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Print the start of a class. Unused in this version,\n     * designed to be overridden */\nprotected void startClass(Class<?> c) {\n}\n","name":"startClass","className":"CrossRef","variables":{},"constants":{},"javaDoc":"Print the start of a class Unused in this version designed to be overridden","comments":" Print the start of a class. Unused in this version,\n     * designed to be overridden ","isEmpty":true,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Print the end of a class. Unused in this version,\n     * designed to be overridden */\nprotected void endClass() {\n}\n","name":"endClass","className":"CrossRef","variables":{},"constants":{},"javaDoc":"Print the end of a class Unused in this version designed to be overridden","comments":" Print the end of a class. Unused in this version,\n     * designed to be overridden ","isEmpty":true,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Convenience routine, short for System.out.println */\nprotected final void println(String s) {\n    System.out.println(s);\n}\n","name":"println","className":"CrossRef","variables":{},"constants":{},"javaDoc":"Convenience routine short for System out println","comments":" Convenience routine, short for System.out.println ","isEmpty":false,"hasInnerClass":false,"modifier":20}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":17,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] av) throws IOException {\n    if (av.length == 0)\n        new PSFormatter(new InputStreamReader(System.in)).process();\n    else\n        for (int i = 0; i < av.length; i++) {\n            new PSFormatter(av[i]).process();\n        }\n}\n","name":"main","className":"PSFormatter","variables":{"av":1,"i":4},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"PSFormatter","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public PSFormatter(String fileName) throws IOException {\n    br = new BufferedReader(new FileReader(fileName));\n}\n","name":"PSFormatter","className":"PSFormatter","variables":{"br":1,"fileName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader"],"returnType":"PSFormatter","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"CastExpr":1,"InstanceOfExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public PSFormatter(Reader in) throws IOException {\n    if (in instanceof BufferedReader)\n        br = (BufferedReader) in;\n    else\n        br = new BufferedReader(in);\n}\n","name":"PSFormatter","className":"PSFormatter","variables":{"br":2,"in":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"startPage":2,"trim":1,"equals":1,"doLine":1,"readLine":1,"prologue":1,"startsWith":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":27,"StringLiteralExpr":3,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":9,"AssignExpr":1},"statements":{"ContinueStmt":1,"IfStmt":2,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"/** Main processing of the current input source. */\nprotected void process() throws IOException {\n    String line;\n    // emit PostScript prologue, once.\n    prologue();\n    // emit top-of-page (ending previous)\n    startPage();\n    while ((line = br.readLine()) != null) {\n        if (line.startsWith(\"\\f\") || line.trim().equals(\".bp\")) {\n            startPage();\n            continue;\n        }\n        doLine(line);\n    }\n    // finish last page, if not already done.\n    if (lineNum != 0)\n        System.out.println(\"showpage\");\n}\n","name":"process","className":"PSFormatter","variables":{"br":1,"line":4,"lineNum":1},"constants":{"0":1,"\"showpage\"":1,"null":1,"\"\\f\"":1,"\".bp\"":1},"javaDoc":"Main processing of the current input source","comments":"emit PostScript prologue once emit top-of-page (ending previous) finish last page if not already done  Main processing of the current input source. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1,"moveTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"/** Handle start of page details. */\nprotected void startPage() {\n    if (pageNum++ > 0)\n        System.out.println(\"showpage\");\n    lineNum = 0;\n    moveTo(leftMargin, topMargin);\n}\n","name":"startPage","className":"PSFormatter","variables":{"lineNum":1,"pageNum":1},"constants":{"0":2,"\"showpage\"":1},"javaDoc":"Handle start of page details","comments":" Handle start of page details. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"startPage":1,"trim":1,"length":2,"charAt":1,"moveTo":1,"System.out.println":1,"toPSString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":10,"NameExpr":38,"StringLiteralExpr":1,"CharLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":2,"UnaryExpr":4,"AssignExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":3,"BreakStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"/** Process one line from the current input */\nprotected void doLine(String line) {\n    tabPos = 0;\n    // count leading (not imbedded) tabs.\n    for (int i = 0; i < line.length(); i++) {\n        if (line.charAt(i) == '\\t')\n            tabPos++;\n        else\n            break;\n    }\n    // removes spaces AND tabs\n    String l = line.trim();\n    if (l.length() == 0) {\n        ++lineNum;\n        return;\n    }\n    moveTo(leftMargin + (tabPos * INCH), topMargin - (lineNum++ * leading));\n    System.out.println('(' + toPSString(l) + \") show\");\n    // If we just hit the bottom, start a new page\n    if (curY <= botMargin)\n        startPage();\n}\n","name":"doLine","className":"PSFormatter","variables":{"leftMargin":1,"topMargin":1,"line":3,"leading":1,"curY":1,"INCH":1,"tabPos":3,"i":3,"lineNum":2,"l":2,"botMargin":1},"constants":{"0":3,"\") show\"":1,"'('":1,"'\\t'":1},"javaDoc":"Process one line from the current input","comments":"count leading (not imbedded) tabs removes spaces AND tabs If we just hit the bottom start a new page  Process one line from the current input ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"length":1,"toString":1,"charAt":1,"append":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuilder":1,"char":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":23,"StringLiteralExpr":2,"CharLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"SwitchStmt":1,"BreakStmt":3,"BlockStmt":1,"SwitchEntryStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** Overly simplistic conversion to PS, e.g., breaks on \"foo\\)bar\" */\nprotected String toPSString(String o) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < o.length(); i++) {\n        char c = o.charAt(i);\n        switch(c) {\n            case '(':\n                sb.append(\"\\\\(\");\n                break;\n            case ')':\n                sb.append(\"\\\\)\");\n                break;\n            default:\n                sb.append(c);\n                break;\n        }\n    }\n    return sb.toString();\n}\n","name":"toPSString","className":"PSFormatter","variables":{"c":2,"i":3,"sb":5,"o":2},"constants":{"0":1,"\"\\\\)\"":1,"')'":1,"'('":1,"\"\\\\(\"":1},"javaDoc":"Overly simplistic conversion to PS e g breaks on \"foo\\)bar\"","comments":" Overly simplistic conversion to PS, e.g., breaks on \"foo\\)bar\" ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":11,"StringLiteralExpr":3,"FieldAccessExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"protected void moveTo(int x, int y) {\n    curX = x;\n    curY = y;\n    System.out.println(x + \" \" + y + \" \" + \"moveto\");\n}\n","name":"moveTo","className":"PSFormatter","variables":{"curX":1,"curY":1,"x":2,"y":2},"constants":{"\"moveto\"":1,"\" \"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":11,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"void prologue() {\n    System.out.println(\"%!PS-Adobe\");\n    System.out.println(\"/Courier findfont \" + points + \" scalefont setfont \");\n}\n","name":"prologue","className":"PSFormatter","variables":{"points":1},"constants":{"\"/Courier findfont \"":1,"\" scalefont setfont \"":1,"\"%!PS-Adobe\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] argv) {\n    System.out.println(\"Hello, World\");\n}\n","name":"main","className":"HelloWorld","variables":{},"constants":{"\"Hello, World\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Date":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] av) {\n    // Create a Date object for May 5, 1986\n    Date d = // EXPECT DEPRECATION WARNING\n    new Date(86, 04, 05);\n    System.out.println(\"Date is \" + d);\n}\n","name":"main","className":"Deprec","variables":{"d":2},"constants":{"04":1,"05":1,"\"Date is \"":1,"86":1},"javaDoc":"","comments":"Create a Date object for May 5 1986 EXPECT DEPRECATION WARNING ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"forName":1,"System.err.println":1},"annotations":[],"exceptions":["ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":9,"StringLiteralExpr":4,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    try {\n        Class.forName(\"javax.swing.JButton\");\n    } catch (ClassNotFoundException e) {\n        String failure = \"Sorry, but this version of MyApp needs \\n\" + \"a Java Runtime with JFC/Swing components\\n\" + \"having the final names (javax.swing.*)\";\n        System.err.println(failure);\n    }\n// No need to print anything here - the GUI should work...\n}\n             // Better to make something appear in the GUI. Either a \n\n             // JOptionPane, or: myPanel.add(new Label(failure));\n\n","name":"main","className":"CheckForSwing","variables":{"e":1,"failure":1,"Class":1},"constants":{"\"javax.swing.JButton\"":1,"\"having the final names (javax.swing.*)\"":1,"\"a Java Runtime with JFC/Swing components\\n\"":1,"\"Sorry, but this version of MyApp needs \\n\"":1},"javaDoc":"","comments":"No need to print anything here - the GUI should work Better to make something appear in the GUI Either a JOptionPane or: myPanel add(new Label(failure)); ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    // bug # 1\n    int n = name.length();\n    System.out.println(n);\n    // bug #2\n    name += \"; The end.\";\n    // #3\n    System.out.println(name);\n}\n","name":"main","className":"Buggy","variables":{"name":2,"n":1},"constants":{"\"; The end.\"":1},"javaDoc":"","comments":"bug # 1 bug #2 #3 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"startServer":2,"runServer":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Httpd":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":25,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public static void main(String argv[]) throws Exception {\n    System.out.println(\"DarwinSys JavaWeb Server 0.1 starting...\");\n    Httpd w = new Httpd();\n    if (argv.length == 2 && argv[0].equals(\"-p\")) {\n        w.startServer(Integer.parseInt(argv[1]));\n    } else {\n        w.startServer(HTTP);\n    }\n    w.runServer();\n// NOTREACHED\n}\n","name":"main","className":"Httpd","variables":{"Integer":1,"w":4,"argv":2},"constants":{"0":1,"1":1,"2":1,"\"DarwinSys JavaWeb Server 0.1 starting...\"":1,"\"-p\"":1},"javaDoc":"","comments":"NOTREACHED ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":4,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void run() {\n    new Handler(Httpd.this).process(clntSock);\n}\n","name":"run","className":"","variables":{"Httpd":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"start":1,"accept":1},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","FinalVariables"],"types":{"Socket":1,"Thread":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":12,"ThisExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/** Run the main loop of the Server. Each time a client connects,\n     * the ServerSocket accept() returns a new Socket for I/O, and\n     * we pass that to the Handler constructor, which creates a Thread,\n     * which we start.\n     */\nvoid runServer() throws Exception {\n    while (true) {\n        final Socket clntSock = sock.accept();\n        Thread t = new Thread() {\n\n            public void run() {\n                new Handler(Httpd.this).process(clntSock);\n            }\n        };\n        t.start();\n    }\n}\n","name":"runServer","className":"Httpd","variables":{"sock":1,"Httpd":1,"t":2,"clntSock":1,"run":1},"constants":{"true":1},"javaDoc":"Run the main loop of the Server Each time a client connects the ServerSocket accept() returns a new Socket for I/O and we pass that to the Handler constructor which creates a Thread which we start","comments":" Run the main loop of the Server. Each time a client connects,\n     * the ServerSocket accept() returns a new Socket for I/O, and\n     * we pass that to the Handler constructor, which creates a Thread,\n     * which we start.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"Httpd","methodCalls":{"getProperty":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":9,"StringLiteralExpr":5,"AssignExpr":3,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/** Construct a server object for a given port number */\nHttpd() throws Exception {\n    wsp = new FileProperties(\"httpd.properties\");\n    rootDir = wsp.getProperty(\"rootDir\", \".\");\n    mimeTypes = new FileProperties(wsp.getProperty(\"mimeProperties\", \"mime.properties\"));\n}\n","name":"Httpd","className":"Httpd","variables":{"mimeTypes":1,"wsp":3,"rootDir":1},"constants":{"\"rootDir\"":1,"\"httpd.properties\"":1,"\".\"":1,"\"mimeProperties\"":1,"\"mime.properties\"":1},"javaDoc":"Construct a server object for a given port number","comments":" Construct a server object for a given port number ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"parseInt":1,"getProperty":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":2,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":2,"BlockStmt":2,"ExpressionStmt":5},"text":"public void startServer(int portNum) throws Exception {\n    String portNumString = null;\n    if (portNum == HTTP) {\n        portNumString = wsp.getProperty(\"portNum\");\n        if (portNumString != null) {\n            portNum = Integer.parseInt(portNumString);\n        }\n    }\n    sock = new ServerSocket(portNum);\n    System.out.println(\"Listening on port \" + portNum);\n}\n","name":"startServer","className":"Httpd","variables":{"Integer":1,"sock":1,"portNum":4,"wsp":1,"HTTP":1,"portNumString":3},"constants":{"\"portNum\"":1,"null":2,"\"Listening on port \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"getProperty":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String getMimeType(String type) {\n    return mimeTypes.getProperty(type);\n}\n","name":"getMimeType","className":"Httpd","variables":{"mimeTypes":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"String","methodCalls":{"getProperty":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String getMimeType(String type, String dflt) {\n    return mimeTypes.getProperty(type, dflt);\n}\n","name":"getMimeType","className":"Httpd","variables":{"mimeTypes":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"getProperty":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String getServerProperty(String name) {\n    return wsp.getProperty(name);\n}\n","name":"getServerProperty","className":"Httpd","variables":{"wsp":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getRootDir() {\n    return rootDir;\n}\n","name":"getRootDir","className":"Httpd","variables":{"rootDir":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"HttpdConcurrent","methodCalls":{"newFixedThreadPool":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"public HttpdConcurrent() throws Exception {\n    super();\n    myThreadPool = Executors.newFixedThreadPool(5);\n}\n","name":"HttpdConcurrent","className":"HttpdConcurrent","variables":{"myThreadPool":1,"Executors":1},"constants":{"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"startServer":2,"runServer":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"HttpdConcurrent":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":25,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public static void main(String[] argv) throws Exception {\n    System.out.println(\"DarwinSys JavaWeb Server 0.1 starting...\");\n    HttpdConcurrent w = new HttpdConcurrent();\n    if (argv.length == 2 && argv[0].equals(\"-p\")) {\n        w.startServer(Integer.parseInt(argv[1]));\n    } else {\n        w.startServer(HTTP);\n    }\n    w.runServer();\n}\n","name":"main","className":"HttpdConcurrent","variables":{"Integer":1,"w":4,"argv":2},"constants":{"0":1,"1":1,"2":1,"\"DarwinSys JavaWeb Server 0.1 starting...\"":1,"\"-p\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":4,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void run() {\n    new Handler(HttpdConcurrent.this).process(clientSocket);\n}\n","name":"run","className":"","variables":{"HttpdConcurrent":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"execute":1,"accept":1},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","FinalVariables"],"types":{"Socket":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"ThisExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public void runServer() throws Exception {\n    while (true) {\n        final Socket clientSocket = sock.accept();\n        myThreadPool.execute(new Runnable() {\n\n            public void run() {\n                new Handler(HttpdConcurrent.this).process(clientSocket);\n            }\n        });\n    }\n}\n","name":"runServer","className":"HttpdConcurrent","variables":{"clientSocket":1,"sock":1,"HttpdConcurrent":1,"myThreadPool":1,"run":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setEnabled":2,"requestFocus":1,"login":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":2,"NameExpr":11,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent e) {\n    login();\n    loginButton.setEnabled(false);\n    logoutButton.setEnabled(true);\n    // set keyboard focus in right place!\n    tf.requestFocus();\n}\n","name":"actionPerformed","className":"","variables":{"tf":1,"loginButton":1,"logoutButton":1},"constants":{"false":1,"true":1},"javaDoc":"","comments":"set keyboard focus in right place! ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setEnabled":2,"logout":1,"requestFocus":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":2,"NameExpr":11,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent e) {\n    logout();\n    loginButton.setEnabled(true);\n    logoutButton.setEnabled(false);\n    loginButton.requestFocus();\n}\n","name":"actionPerformed","className":"","variables":{"loginButton":2,"logoutButton":1},"constants":{"true":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"println":1,"getText":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent e) {\n    if (loggedIn) {\n        pw.println(ChatProtocol.CMD_BCAST + tf.getText());\n        tf.setText(\"\");\n    }\n}\n","name":"actionPerformed","className":"","variables":{"tf":2,"loggedIn":1,"pw":1},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ChatClient","methodCalls":{"add":6,"requestFocus":3,"getText":1,"addActionListener":3,"setTitle":1,"setLayout":1,"login":1,"pack":1,"setEnabled":6,"logout":1,"println":1,"setEditable":1,"setFont":1,"setDefaultCloseOperation":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Panel":1},"expressions":{"ObjectCreationExpr":11,"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BooleanLiteralExpr":7,"BinaryExpr":1,"NameExpr":118,"StringLiteralExpr":5,"FieldAccessExpr":5,"ThisExpr":1,"AssignExpr":6,"MethodCallExpr":29},"statements":{"IfStmt":1,"BlockStmt":4,"ExpressionStmt":33},"text":"/** set up the GUI */\npublic ChatClient() {\n    cp = this;\n    cp.setTitle(TITLE);\n    cp.setLayout(new BorderLayout());\n    port = PORTNUM;\n    // The GUI\n    ta = new TextArea(14, 80);\n    // readonly\n    ta.setEditable(false);\n    ta.setFont(new Font(\"Monospaced\", Font.PLAIN, 11));\n    cp.add(BorderLayout.NORTH, ta);\n    Panel p = new Panel();\n    // The login button\n    p.add(loginButton = new Button(\"Login\"));\n    loginButton.setEnabled(true);\n    loginButton.requestFocus();\n    loginButton.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            login();\n            loginButton.setEnabled(false);\n            logoutButton.setEnabled(true);\n            // set keyboard focus in right place!\n            tf.requestFocus();\n        }\n    });\n    // The logout button\n    p.add(logoutButton = new Button(\"Logout\"));\n    logoutButton.setEnabled(false);\n    logoutButton.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            logout();\n            loginButton.setEnabled(true);\n            logoutButton.setEnabled(false);\n            loginButton.requestFocus();\n        }\n    });\n    p.add(new Label(\"Message here:\"));\n    tf = new TextField(40);\n    tf.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            if (loggedIn) {\n                pw.println(ChatProtocol.CMD_BCAST + tf.getText());\n                tf.setText(\"\");\n            }\n        }\n    });\n    p.add(tf);\n    cp.add(BorderLayout.SOUTH, p);\n    cp.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    cp.pack();\n}\n","name":"ChatClient","className":"ChatClient","variables":{"p":5,"actionPerformed":3,"tf":5,"port":1,"e":3,"loginButton":7,"loggedIn":1,"pw":1,"PORTNUM":1,"logoutButton":5,"cp":7,"ta":3},"constants":{"11":1,"\"\"":1,"14":1,"80":1,"false":4,"true":3,"\"Monospaced\"":1,"\"Login\"":1,"40":1,"\"Logout\"":1,"\"Message here:\"":1},"javaDoc":"set up the GUI","comments":"The GUI readonly The login button set keyboard focus in right place! The logout button  set up the GUI ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showStatus":1,"readLine":1,"append":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":12,"StringLiteralExpr":2,"EnclosedExpr":2,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"public void run() {\n    String line;\n    try {\n        while (loggedIn && ((line = is.readLine()) != null)) ta.append(line + \"\\n\");\n    } catch (IOException e) {\n        showStatus(\"Lost another client!\\n\" + e);\n        return;\n    }\n}\n","name":"run","className":"","variables":{"e":2,"line":3,"loggedIn":1,"is":1,"ta":1},"constants":{"null":1,"\"Lost another client!\\n\"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"println":1,"showStatus":4,"getOutputStream":1,"readLine":1,"getInputStream":1,"append":1},"annotations":[],"exceptions":["IOException"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"String":1},"expressions":{"ObjectCreationExpr":7,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":2,"BinaryExpr":11,"NameExpr":49,"StringLiteralExpr":8,"FieldAccessExpr":1,"EnclosedExpr":2,"MethodCallExpr":11,"AssignExpr":5},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ReturnStmt":3,"ExpressionStmt":13},"text":"/** LOG ME IN TO THE CHAT */\npublic void login() {\n    showStatus(\"In login!\");\n    if (loggedIn)\n        return;\n    try {\n        sock = new Socket(serverHost, port);\n        is = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n        pw = new PrintWriter(sock.getOutputStream(), true);\n        showStatus(\"Got socket\");\n        // FAKE LOGIN FOR NOW - no password needed\n        pw.println(ChatProtocol.CMD_LOGIN + userName);\n        loggedIn = true;\n    } catch (IOException e) {\n        showStatus(\"Can't get socket to \" + serverHost + \"/\" + port + \": \" + e);\n        cp.add(new Label(\"Can't get socket: \" + e));\n        return;\n    }\n    // Construct and start the reader: from server to textarea.\n    // Make a Thread to avoid lockups.\n    new Thread(new Runnable() {\n\n        public void run() {\n            String line;\n            try {\n                while (loggedIn && ((line = is.readLine()) != null)) ta.append(line + \"\\n\");\n            } catch (IOException e) {\n                showStatus(\"Lost another client!\\n\" + e);\n                return;\n            }\n        }\n    }).start();\n}\n","name":"login","className":"ChatClient","variables":{"sock":3,"port":2,"e":5,"line":3,"loggedIn":3,"pw":2,"is":2,"run":1,"userName":1,"cp":1,"ta":1,"serverHost":2},"constants":{"\"Can't get socket: \"":1,"null":1,"\"/\"":1,"\"In login!\"":1,"true":2,"\"Got socket\"":1,"\": \"":1,"\"Lost another client!\\n\"":1,"\"Can't get socket to \"":1,"\"\\n\"":1},"javaDoc":"LOG ME IN TO THE CHAT","comments":"Construct and start the reader: from server to textarea FAKE LOGIN FOR NOW - no password needed Make a Thread to avoid lockups  LOG ME IN TO THE CHAT ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NullLiteralExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Log me out, Scotty, there's no intelligent life here! */\npublic void logout() {\n    if (!loggedIn)\n        return;\n    loggedIn = false;\n    try {\n        if (sock != null)\n            sock.close();\n    } catch (IOException ign) {\n    }\n}\n             // so what?\n\n","name":"logout","className":"ChatClient","variables":{"sock":2,"ign":1,"loggedIn":2},"constants":{"null":1,"false":1},"javaDoc":"Log me out Scotty there's no intelligent life here!","comments":"so what?  Log me out, Scotty, there's no intelligent life here! ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void showStatus(String message) {\n    System.out.println(message);\n}\n","name":"showStatus","className":"ChatClient","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ChatClient":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/** A main method to allow the client to be run as an Application */\npublic static void main(String[] args) {\n    ChatClient room101 = new ChatClient();\n    room101.pack();\n    room101.setVisible(true);\n}\n","name":"main","className":"ChatClient","variables":{"room101":3},"constants":{"true":1},"javaDoc":"A main method to allow the client to be run as an Application","comments":" A main method to allow the client to be run as an Application ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"runServer":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"ChatServer":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":5},"text":"/** Main just constructs a ChatServer, which should never return */\npublic static void main(String[] argv) throws IOException {\n    System.out.println(\"DarwinSys ChatServer 0.1 starting...\");\n    if (argv.length == 1 && argv[0].equals(\"-debug\"))\n        DEBUG = true;\n    ChatServer w = new ChatServer();\n    // should never return.\n    w.runServer();\n    System.out.println(\"**ERROR* ChatServer 0.1 quitting\");\n}\n","name":"main","className":"ChatServer","variables":{"w":2,"argv":1,"DEBUG":1},"constants":{"0":1,"1":1,"\"DarwinSys ChatServer 0.1 starting...\"":1,"\"-debug\"":1,"true":1,"\"**ERROR* ChatServer 0.1 quitting\"":1},"javaDoc":"Main just constructs a ChatServer which should never return","comments":"should never return  Main just constructs a ChatServer, which should never return ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"ChatServer","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":3,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"/** Construct (and run!) a Chat Service \n     * @throws IOException\n     */\nChatServer() throws IOException {\n    clients = new ArrayList<>();\n    servSock = new ServerSocket(ChatProtocol.PORTNUM);\n    System.out.println(\"DarwinSys Chat Server Listening on port \" + ChatProtocol.PORTNUM);\n}\n","name":"ChatServer","className":"ChatServer","variables":{"servSock":1,"clients":1},"constants":{"\"DarwinSys Chat Server Listening on port \"":1},"javaDoc":"Construct (and run!) a Chat Service @throws IOException","comments":" Construct (and run!) a Chat Service \n     * @throws IOException\n     ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"getInetAddress":1,"add":1,"getHostName":1,"size":2,"log":1,"start":1,"send":1,"accept":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling","Synchronization"],"types":{"ChatHandler":1,"String":2,"Socket":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"BinaryExpr":5,"NameExpr":40,"StringLiteralExpr":5,"FieldAccessExpr":1,"MethodCallExpr":10,"AssignExpr":2},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":6,"SynchronizedStmt":1,"ExpressionStmt":11},"text":"public void runServer() {\n    try {\n        while (true) {\n            Socket userSocket = servSock.accept();\n            String hostName = userSocket.getInetAddress().getHostName();\n            System.out.println(\"Accepted from \" + hostName);\n            ChatHandler cl = new ChatHandler(userSocket, hostName);\n            String welcomeMessage;\n            synchronized (clients) {\n                clients.add(cl);\n                if (clients.size() == 1) {\n                    welcomeMessage = \"Welcome! you're the first one here\";\n                } else {\n                    welcomeMessage = \"Welcome! you're the latest of \" + clients.size() + \" users.\";\n                }\n            }\n            cl.start();\n            cl.send(CHATMASTER_ID, welcomeMessage);\n        }\n    } catch (IOException e) {\n        log(\"IO Exception in runServer: \" + e);\n    }\n}\n","name":"runServer","className":"ChatServer","variables":{"servSock":1,"hostName":3,"clients":4,"e":2,"userSocket":3,"welcomeMessage":3,"cl":3},"constants":{"1":1,"\"Accepted from \"":1,"true":1,"\" users.\"":1,"\"Welcome! you're the first one here\"":1,"\"Welcome! you're the latest of \"":1,"\"IO Exception in runServer: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"protected void log(String s) {\n    System.out.println(s);\n}\n","name":"log","className":"ChatServer","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Socket","String"],"returnType":"ChatHandler","methodCalls":{"getOutputStream":1,"getInputStream":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"BooleanLiteralExpr":1,"NameExpr":12,"AssignExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"/* Construct a Chat Handler */\npublic ChatHandler(Socket sock, String clnt) throws IOException {\n    clientSock = sock;\n    clientIP = clnt;\n    is = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n    pw = new PrintWriter(sock.getOutputStream(), true);\n}\n","name":"ChatHandler","className":"ChatHandler","variables":{"sock":3,"clnt":1,"clientIP":1,"pw":1,"clientSock":1,"is":1},"constants":{"true":1},"javaDoc":"","comments":" Construct a Chat Handler ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"broadcast":4,"lookup":1,"log":5,"readLine":1,"substring":3,"remove":1,"isValidLoginName":1,"size":4,"psend":2,"send":2,"indexOf":1,"close":1,"charAt":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling","Synchronization"],"types":{"char":1,"ChatHandler":1,"String":4,"int":1},"expressions":{"NullLiteralExpr":4,"IntegerLiteralExpr":6,"VariableDeclarationExpr":7,"BinaryExpr":35,"NameExpr":136,"StringLiteralExpr":23,"FieldAccessExpr":7,"EnclosedExpr":1,"UnaryExpr":1,"ThisExpr":1,"AssignExpr":5,"MethodCallExpr":29},"statements":{"ContinueStmt":2,"SwitchStmt":1,"IfStmt":6,"WhileStmt":1,"BreakStmt":3,"TryStmt":1,"BlockStmt":10,"SwitchEntryStmt":5,"SynchronizedStmt":1,"ReturnStmt":1,"ExpressionStmt":28},"text":"/** Each ChatHandler is a Thread, so here's the run() method,\n         * which handles this conversation.\n         */\npublic void run() {\n    String line;\n    try {\n        /*\n                 * We should stay in this loop as long as the Client remains\n                 * connected, so when this loop ends, we disconnect the client.\n                 */\n        while ((line = is.readLine()) != null) {\n            char c = line.charAt(0);\n            line = line.substring(1);\n            switch(c) {\n                case ChatProtocol.CMD_LOGIN:\n                    if (!ChatProtocol.isValidLoginName(line)) {\n                        send(CHATMASTER_ID, \"LOGIN \" + line + \" invalid\");\n                        log(\"LOGIN INVALID from \" + clientIP);\n                        continue;\n                    }\n                    login = line;\n                    broadcast(CHATMASTER_ID, login + \" joins us, for a total of \" + clients.size() + \" users\");\n                    break;\n                case ChatProtocol.CMD_MESG:\n                    if (login == null) {\n                        send(CHATMASTER_ID, \"please login first\");\n                        continue;\n                    }\n                    int where = line.indexOf(ChatProtocol.SEPARATOR);\n                    String recip = line.substring(0, where);\n                    String mesg = line.substring(where + 1);\n                    log(\"MESG: \" + login + \"-->\" + recip + \": \" + mesg);\n                    ChatHandler cl = lookup(recip);\n                    if (cl == null)\n                        psend(CHATMASTER_ID, recip + \" not logged in.\");\n                    else\n                        cl.psend(login, mesg);\n                    break;\n                case ChatProtocol.CMD_QUIT:\n                    broadcast(CHATMASTER_ID, \"Goodbye to \" + login + \"@\" + clientIP);\n                    close();\n                    // The end of this ChatHandler\n                    return;\n                case ChatProtocol.CMD_BCAST:\n                    if (login != null)\n                        broadcast(login, line);\n                    else\n                        log(\"B<L FROM \" + clientIP);\n                    break;\n                default:\n                    log(\"Unknown cmd \" + c + \" from \" + login + \"@\" + clientIP);\n            }\n        }\n    } catch (IOException e) {\n        log(\"IO Exception: \" + e);\n    } finally {\n        // the sock ended (darn it), so we're done, bye now\n        System.out.println(login + SEP + \"All Done\");\n        String message = \"This should never appear.\";\n        synchronized (clients) {\n            clients.remove(this);\n            if (clients.size() == 0) {\n                System.out.println(CHATMASTER_ID + SEP + \"I'm so lonely I could cry...\");\n            } else if (clients.size() == 1) {\n                message = \"Hey, you're talking to yourself again\";\n            } else {\n                message = \"There are now \" + clients.size() + \" users\";\n            }\n        }\n        broadcast(CHATMASTER_ID, message);\n    }\n}\n","name":"run","className":"ChatHandler","variables":{"recip":3,"c":3,"clients":6,"e":2,"line":10,"cl":3,"is":1,"login":8,"message":3,"ChatProtocol":1,"clientIP":4,"where":2,"CHATMASTER_ID":1,"mesg":2,"SEP":2},"constants":{"\"please login first\"":1,"\" users\"":2,"\"@\"":2,"\"This should never appear.\"":1,"\"B<L FROM \"":1,"\": \"":1,"\"Goodbye to \"":1,"0":3,"\"I'm so lonely I could cry...\"":1,"1":3,"\"All Done\"":1,"\"LOGIN \"":1,"\"-->\"":1,"\"Unknown cmd \"":1,"\" from \"":1,"null":4,"\" invalid\"":1,"\"IO Exception: \"":1,"\"MESG: \"":1,"\" not logged in.\"":1,"\"Hey, you're talking to yourself again\"":1,"\"There are now \"":1,"\"LOGIN INVALID from \"":1,"\" joins us, for a total of \"":1},"javaDoc":"Each ChatHandler is a Thread so here's the run() method which handles this conversation","comments":"We should stay in this loop as long as the Client remains connected so when this loop ends we disconnect the client The end of this ChatHandler the sock ended (darn it) so we're done bye now  Each ChatHandler is a Thread, so here's the run() method,\n         * which handles this conversation.\n         ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"log":2,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":2,"NameExpr":10,"StringLiteralExpr":2,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"protected void close() {\n    if (clientSock == null) {\n        log(\"close when not open\");\n        return;\n    }\n    try {\n        clientSock.close();\n        clientSock = null;\n    } catch (IOException e) {\n        log(\"Failure during close to \" + clientIP);\n    }\n}\n","name":"close","className":"ChatHandler","variables":{"e":1,"clientIP":1,"clientSock":3},"constants":{"null":2,"\"close when not open\"":1,"\"Failure during close to \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":6,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Send one message to this user */\npublic void send(String sender, String mesg) {\n    pw.println(sender + SEP + mesg);\n}\n","name":"send","className":"ChatHandler","variables":{"sender":1,"pw":1,"SEP":1,"mesg":1},"constants":{},"javaDoc":"Send one message to this user","comments":" Send one message to this user ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"send":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":4,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Send a private message */\nprotected void psend(String sender, String msg) {\n    send(\"<*\" + sender + \"*>\", msg);\n}\n","name":"psend","className":"ChatHandler","variables":{"sender":1},"constants":{"\"<*\"":1,"\"*>\"":1},"javaDoc":"Send a private message","comments":" Send a private message ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"forEach":1,"send":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"LambdaExpr":1,"NameExpr":29,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"IfStmt":2,"BlockStmt":1,"ExpressionStmt":5},"text":"/** Send one message to all users */\npublic void broadcast(String sender, String mesg) {\n    System.out.println(\"Broadcasting \" + sender + SEP + mesg);\n    clients.forEach( sib -> {\n        if (DEBUG)\n            System.out.println(\"Sending to \" + sib);\n        sib.send(sender, mesg);\n    });\n    if (DEBUG)\n        System.out.println(\"Done broadcast\");\n}\n","name":"broadcast","className":"ChatHandler","variables":{"clients":1,"sender":1,"sib":3,"DEBUG":2,"SEP":1,"mesg":1},"constants":{"\"Broadcasting \"":1,"\"Done broadcast\"":1,"\"Sending to \"":1},"javaDoc":"Send one message to all users","comments":" Send one message to all users ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"ChatHandler","methodCalls":{"cl.login.equals":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"ChatHandler":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"SynchronizedStmt":1,"ForeachStmt":1,"ReturnStmt":2},"text":"protected ChatHandler lookup(String nick) {\n    synchronized (clients) {\n        for (ChatHandler cl : clients) {\n            if (cl.login.equals(nick))\n                return cl;\n        }\n    }\n    return null;\n}\n","name":"lookup","className":"ChatHandler","variables":{"clients":2,"cl":2},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Present this ChatHandler as a String */\npublic String toString() {\n    return \"ChatHandler[\" + login + \"]\";\n}\n","name":"toString","className":"ChatHandler","variables":{"login":1},"constants":{"\"]\"":1,"\"ChatHandler[\"":1},"javaDoc":"Present this ChatHandler as a String","comments":" Present this ChatHandler as a String ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":["Before"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Method to be invoked before each test method */\n@Before\npublic void setUp() {\n    d1 = new EqualsDemo();\n    d2 = new EqualsDemo();\n}\n","name":"setUp","className":"EqualsDemoTest","variables":{"d1":1,"d2":1},"constants":{},"javaDoc":"Method to be invoked before each test method","comments":" Method to be invoked before each test method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"assertTrue":1,"equals":1},"annotations":["Test"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"@Test\npublic void testSymmetry() {\n    assertTrue(d1.equals(d1));\n}\n","name":"testSymmetry","className":"EqualsDemoTest","variables":{"d1":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"assertTrue":1,"equals":2},"annotations":["Test"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":10,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"@Test\npublic void testSymmetric() {\n    assertTrue(d1.equals(d2) && d2.equals(d1));\n}\n","name":"testSymmetric","className":"EqualsDemoTest","variables":{"d1":1,"d2":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"assertTrue":1,"equals":1},"annotations":["Test"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":5,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"@Test\npublic void testCaution() {\n    assertTrue(!d1.equals(null));\n}\n","name":"testCaution","className":"EqualsDemoTest","variables":{"d1":1},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parse":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"CSVImport":1,"String":2,"List<String>":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":2,"CharLiteralExpr":1,"MethodCallExpr":4,"AssignExpr":2},"statements":{"BlockStmt":2,"ForeachStmt":2,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    CSVImport parser = new CSVImport();\n    List<String> list = parser.parse(\"\\\"LU\\\",86.25,\\\"11/4/1998\\\",\\\"2:19PM\\\",+4.0625\");\n    for (String word : list) {\n        System.out.println(word);\n    }\n    // Now try with a non-default separator\n    parser = new CSVImport('|');\n    list = parser.parse(\"\\\"LU\\\"|86.25|\\\"11/4/1998\\\"|\\\"2:19PM\\\"|+4.0625\");\n    for (String word : list) {\n        System.out.println(word);\n    }\n}\n","name":"main","className":"CSVSimple","variables":{"parser":4,"list":4,"word":2},"constants":{"\"\\\"LU\\\",86.25,\\\"11/4/1998\\\",\\\"2:19PM\\\",+4.0625\"":1,"'|'":1,"\"\\\"LU\\\"|86.25|\\\"11/4/1998\\\"|\\\"2:19PM\\\"|+4.0625\"":1},"javaDoc":"","comments":"Now try with a non-default separator ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"testFiveCols":1,"testTwoCols":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \"main program\" method - construct and show */\npublic static void main(String[] av) {\n    testTwoCols();\n    testFiveCols();\n}\n","name":"main","className":"EntryLayoutTest","variables":{},"constants":{},"javaDoc":"\"main program\" method - construct and show","comments":" \"main program\" method - construct and show ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":6,"setVisible":1,"setLocation":1,"getContentPane":1,"setLayout":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Container":1,"JFrame":1,"double":1},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"ArrayInitializerExpr":1,"DoubleLiteralExpr":2,"BooleanLiteralExpr":1,"StringLiteralExpr":4,"NameExpr":49,"FieldAccessExpr":4,"MethodCallExpr":12},"statements":{"ExpressionStmt":14},"text":"static void testTwoCols() {\n    final JFrame f = new JFrame(\"EntryLayout Demonstration\");\n    Container cp = f.getContentPane();\n    double widths[] = { .33, .66 };\n    cp.setLayout(new EntryLayout(widths));\n    cp.add(new JLabel(\"Login:\", SwingConstants.RIGHT));\n    cp.add(new JTextField(10));\n    cp.add(new JLabel(\"Password:\", SwingConstants.RIGHT));\n    cp.add(new JPasswordField(20));\n    cp.add(new JLabel(\"Security Domain:\", SwingConstants.RIGHT));\n    cp.add(new JTextField(20));\n    // cp.add(new JLabel(\"Monkey wrench in works\"));\n    f.pack();\n    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    f.setLocation(200, 200);\n    f.setVisible(true);\n}\n","name":"testTwoCols","className":"EntryLayoutTest","variables":{"f":6,"widths":2,"cp":8},"constants":{"\"Password:\"":1,"200":2,"\"Login:\"":1,"\"Security Domain:\"":1,"true":1,"\"EntryLayout Demonstration\"":1,".33":1,".66":1,"20":2,"10":1},"javaDoc":"","comments":"cp add(new JLabel(\"Monkey wrench in works\")); ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":15,"setVisible":1,"setLocation":1,"getContentPane":1,"setLayout":1,"setDefaultCloseOperation":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"Container":1,"JFrame":1,"double":1},"expressions":{"ObjectCreationExpr":17,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"ArrayInitializerExpr":1,"DoubleLiteralExpr":5,"BooleanLiteralExpr":1,"StringLiteralExpr":4,"NameExpr":76,"FieldAccessExpr":4,"MethodCallExpr":21},"statements":{"ExpressionStmt":23},"text":"static void testFiveCols() {\n    final JFrame f = new JFrame(\"EntryLayout Five Columns\");\n    Container cp = f.getContentPane();\n    double widths[] = { .25, .33, .10, .10, .20 };\n    cp.setLayout(new EntryLayout(widths));\n    cp.add(new JLabel(\"Login:\", SwingConstants.RIGHT));\n    cp.add(new JTextField(10));\n    cp.add(new JCheckBox());\n    cp.add(new JCheckBox());\n    cp.add(new JCheckBox());\n    cp.add(new JLabel(\"Password:\", SwingConstants.RIGHT));\n    cp.add(new JPasswordField(20));\n    cp.add(new JCheckBox());\n    cp.add(new JCheckBox());\n    cp.add(new JCheckBox());\n    cp.add(new JLabel(\"Security Domain:\", SwingConstants.RIGHT));\n    cp.add(new JTextField(20));\n    cp.add(new JCheckBox());\n    cp.add(new JCheckBox());\n    cp.add(new JCheckBox());\n    f.pack();\n    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    f.setLocation(200, 200);\n    f.setVisible(true);\n}\n","name":"testFiveCols","className":"EntryLayoutTest","variables":{"f":6,"widths":2,"cp":17},"constants":{".25":1,"\"Password:\"":1,"200":2,"\"EntryLayout Five Columns\"":1,"\"Login:\"":1,"\"Security Domain:\"":1,"true":1,".20":1,".10":2,".33":1,"20":2,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":[],"returnType":"void","methodCalls":{"main":1,"System.out.println":1},"annotations":["Test"],"exceptions":["HeadlessException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"@Test\npublic void trivialTest() {\n    try {\n        main(null);\n    } catch (HeadlessException he) {\n        System.out.println(\"EntryLayoutTest.test(): cannot test Headless\");\n    }\n}\n","name":"trivialTest","className":"EntryLayoutTest","variables":{"he":1},"constants":{"\"EntryLayoutTest.test(): cannot test Headless\"":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"print":3,"getText":1,"assertEquals":1,"close":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":19,"StringLiteralExpr":2,"CharLiteralExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public void testOne() {\n    PrintWriter x = new PrintWriter(new TextAreaWriter(ta));\n    x.print(\"Hello\");\n    x.print(' ');\n    x.print(\"World\");\n    x.close();\n    assertEquals(HELLO_WORLD, ta.getText());\n}\n","name":"testOne","className":"TextAreaWriterTest","variables":{"x":5,"ta":2},"constants":{"\"Hello\"":1,"\"World\"":1,"' '":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"createMarshaller":1,"getColorName":1,"getAbsolutePath":1,"isVerbose":1,"equalTo":1,"createUnmarshaller":1,"assertEquals":3,"newInstance":1,"setVerbose":2,"assertThat":1,"delete":1,"getScreenName":1,"not":1,"unmarshal":1,"assertTrue":1,"marshal":1,"setScreenName":2,"exists":1,"setColorName":2,"close":1,"System.out.println":2},"annotations":["Test"],"exceptions":["Exception"],"concepts":["Casting","FinalVariables","PolyMorphism"],"types":{"Marshaller":1,"Configuration":3,"FileWriter":1,"JAXBContext":1,"Unmarshaller":1,"File":1,"Writer":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":8,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":90,"StringLiteralExpr":7,"CastExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":27},"statements":{"ExpressionStmt":24},"text":"@Test\npublic void test() throws Exception {\n    System.out.println(\"JAXB Testing\");\n    // Create a Config object, and test the empty config.\n    Configuration c = new Configuration();\n    assertEquals(c, c);\n    // The user sets their preferences...\n    c.setScreenName(\"idarwin\");\n    c.setColorName(\"inky green\");\n    c.setVerbose(true);\n    // We test a non-empty config\n    assertEquals(c, c);\n    Configuration c1 = new Configuration();\n    c1.setScreenName(c.getScreenName());\n    c1.setColorName(c.getColorName());\n    // negate field for test\n    c1.setVerbose(!c.isVerbose());\n    // Test non-equality\n    assertThat(c, not(equalTo(c1)));\n    // BEGIN main\n    // We set up JAXB: the context arg is the package name!\n    JAXBContext jc = JAXBContext.newInstance(\"xml.jaxb\");\n    Marshaller saver = jc.createMarshaller();\n    final File f = new File(\"config.save\");\n    // We save their preferences \n    // Configuration c = ... - set above\n    Writer saveFile = new FileWriter(f);\n    saver.marshal(c, saveFile);\n    saveFile.close();\n    // Confirm that the XML file got written\n    assertTrue(f.exists());\n    System.out.println(\"JAXB output saved in \" + f.getAbsolutePath());\n    // Sometime later, we read it back in.\n    Unmarshaller loader = jc.createUnmarshaller();\n    Configuration c2 = (Configuration) loader.unmarshal(f);\n    // Outside of the simulation, we test that what we\n    // read back is the same as what we started with.\n    assertEquals(\"saved and loaded back the object\", c, c2);\n    // END main\n    // Bit o' cleanup\n    f.delete();\n}\n","name":"test","className":"ConfigTest","variables":{"c":7,"f":5,"loader":2,"saver":2,"jc":3,"saveFile":2,"JAXBContext":1,"c1":4,"c2":1},"constants":{"\"xml.jaxb\"":1,"\"saved and loaded back the object\"":1,"\"idarwin\"":1,"\"JAXB output saved in \"":1,"\"inky green\"":1,"true":1,"\"JAXB Testing\"":1,"\"config.save\"":1},"javaDoc":"","comments":"BEGIN main We save their preferences Outside of the simulation we test that what we END main Create a Config object and test the empty config The user sets their preferences We test a non-empty config negate field for test Test non-equality We set up JAXB: the context arg is the package name! Configuration c = - set above Confirm that the XML file got written Sometime later we read it back in read back is the same as what we started with Bit o' cleanup ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"assertEquals":1,"readLine":1},"annotations":["Test"],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"String":2,"IndentContLineReader":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":7,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"@Test\npublic void testTwoLiner() throws IOException {\n    String input = \"Received: by foo.bar.com\\n\" + \" at 12:34:56 January 1, 2000\\n\";\n    String expected = \"Received: by foo.bar.com at 12:34:56 January 1, 2000\";\n    try (IndentContLineReader is = new IndentContLineReader(new StringReader(input))) {\n        assertEquals(\"2 liner\", expected, is.readLine());\n    }\n}\n","name":"testTwoLiner","className":"IndentContLineReaderTest","variables":{"input":2,"expected":1,"is":2},"constants":{"\"Received: by foo.bar.com at 12:34:56 January 1, 2000\"":1,"\" at 12:34:56 January 1, 2000\\n\"":1,"\"Received: by foo.bar.com\\n\"":1,"\"2 liner\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getLineNumber":2,"length":1,"readLine":2,"setContinuationMode":1,"close":1,"System.out.println":5},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1,"IndentContLineReader":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":8,"BooleanLiteralExpr":1,"NameExpr":51,"StringLiteralExpr":4,"FieldAccessExpr":5,"EnclosedExpr":2,"MethodCallExpr":12,"AssignExpr":2},"statements":{"WhileStmt":2,"BlockStmt":2,"ExpressionStmt":9},"text":"/** This is really a demo method, not a test, sorry. */\npublic void showReadingAMailMessageWithHeaders() throws IOException {\n    // BEGIN main\n    IndentContLineReader is = new IndentContLineReader(new StringReader(sampleTxt));\n    String aLine;\n    // Print Mail/News Header\n    System.out.println(\"----- Message Header -----\");\n    while ((aLine = is.readLine()) != null && aLine.length() > 0) {\n        System.out.println(is.getLineNumber() + \": \" + aLine);\n    }\n    // Make \"is\" behave like normal BufferedReader\n    is.setContinuationMode(false);\n    System.out.println();\n    // Print Message Body\n    System.out.println(\"----- Message Body -----\");\n    while ((aLine = is.readLine()) != null) {\n        System.out.println(is.getLineNumber() + \": \" + aLine);\n    }\n    is.close();\n// END main\n}\n","name":"showReadingAMailMessageWithHeaders","className":"IndentContLineReaderTest","variables":{"sampleTxt":1,"is":7,"aLine":6},"constants":{"0":1,"null":2,"\"----- Message Header -----\"":1,"false":1,"\": \"":2,"\"----- Message Body -----\"":1},"javaDoc":"This is really a demo method not a test sorry","comments":"END main BEGIN main Print Mail/News Header Make \"is\" behave like normal BufferedReader Print Message Body  This is really a demo method, not a test, sorry. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"addWindowListener":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Frame":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":2,"StringLiteralExpr":2,"NameExpr":16,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"/* Main method */\npublic static void main(String[] argv) {\n    Frame f = new Frame(\"Close Me\");\n    f.add(new Label(\"Try Titlebar Close\", Label.CENTER));\n    f.setSize(100, 100);\n    f.setVisible(true);\n    f.addWindowListener(new WindowCloser(f, true));\n}\n","name":"main","className":"WindowCloserDemo","variables":{"f":6},"constants":{"\"Try Titlebar Close\"":1,"100":2,"true":2,"\"Close Me\"":1},"javaDoc":"","comments":" Main method ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"copyFile":2,"System.err.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":12,"StringLiteralExpr":4,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public static void main(String[] av) {\n    try {\n        FileIO.copyFile(\"FileIO.java\", \"FileIO.bak\");\n        FileIO.copyFile(\"FileIO.class\", \"FileIO-class.bak\");\n    } catch (IOException e) {\n        System.err.println(e);\n    }\n}\n","name":"main","className":"FileIoDemo","variables":{"e":1,"FileIO":2},"constants":{"\"FileIO.java\"":1,"\"FileIO.bak\"":1,"\"FileIO-class.bak\"":1,"\"FileIO.class\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"release":1,"tryAcquire":1,"getService":1},"annotations":["Override"],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":13,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"TryStmt":2,"BlockStmt":5,"ExpressionStmt":2},"text":"@Override\npublic void run() {\n    try {\n        if (semaphore.tryAcquire(10, TimeUnit.MILLISECONDS)) {\n            try {\n                Teller.getService(count);\n            } finally {\n                semaphore.release();\n            }\n        }\n    } catch (InterruptedException ex) {\n    }\n}\n","name":"run","className":"","variables":{"ex":1,"Teller":1,"semaphore":2},"constants":{"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"release":1,"tryAcquire":1,"getService":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":22,"FieldAccessExpr":1,"MarkerAnnotationExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":7,"TryStmt":2,"ForStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    for (int i = 0; i < COUNT; i++) {\n        final int count = i;\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    if (semaphore.tryAcquire(10, TimeUnit.MILLISECONDS)) {\n                        try {\n                            Teller.getService(count);\n                        } finally {\n                            semaphore.release();\n                        }\n                    }\n                } catch (InterruptedException ex) {\n                }\n            }\n        }.start();\n    }\n}\n","name":"main","className":"Bank","variables":{"ex":1,"Teller":1,"count":1,"i":4,"semaphore":2,"COUNT":1,"run":1,"Override":1},"constants":{"0":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"sleep":1,"random":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":12,"StringLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"public static void getService(int i) {\n    try {\n        System.out.println(\"serving: \" + i);\n        Thread.sleep((long) (Math.random() * 10));\n    } catch (InterruptedException ex) {\n    }\n}\n","name":"getService","className":"Teller","variables":{"ex":1,"i":1,"Math":1,"Thread":1},"constants":{"\"serving: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setDaemon":1,"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Thread":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":8,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    Thread raceMonitor = new Thread(new RaceMonitor());\n    raceMonitor.setDaemon(true);\n    raceMonitor.start();\n    new HorseRace().manageRace();\n}\n","name":"main","className":"HorseRace","variables":{"raceMonitor":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"runRace":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ArrayList<Horse>":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":9,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public void manageRace() {\n    ArrayList<Horse> horseArray = new ArrayList<Horse>();\n    for (int i = 0; i < NUMBER_OF_HORSES; i++) {\n        horseArray.add(new Horse());\n    }\n    runRace(horseArray);\n}\n","name":"manageRace","className":"HorseRace","variables":{"NUMBER_OF_HORSES":1,"i":3,"horseArray":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"log":1,"run":1,"arriveAndAwaitAdvance":1},"annotations":["Override"],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":14,"StringLiteralExpr":1,"EnclosedExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"@Override\npublic void run() {\n    try {\n        Thread.sleep((new Random()).nextInt(1000));\n    } catch (InterruptedException ex) {\n    }\n    log(dev + \", please await all horses\");\n    manager.arriveAndAwaitAdvance();\n    horse.run();\n}\n","name":"run","className":"","variables":{"horse":1,"ex":1,"dev":1,"manager":1,"Thread":1},"constants":{"\", please await all horses\"":1,"1000":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Iterable<Horse>"],"returnType":"void","methodCalls":{"sleep":2,"log":4,"toString":1,"run":1,"arriveAndDeregister":1,"register":1,"arriveAndAwaitAdvance":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"Horse":1,"String":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":39,"StringLiteralExpr":5,"MarkerAnnotationExpr":1,"EnclosedExpr":1,"MethodCallExpr":13},"statements":{"BlockStmt":6,"TryStmt":2,"ForeachStmt":1,"ExpressionStmt":12},"text":"private void runRace(Iterable<Horse> team) {\n    log(\"Assign all horses, then start race\");\n    for (final Horse horse : team) {\n        final String dev = horse.toString();\n        log(\"assign \" + dev + \" to the race\");\n        manager.register();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep((new Random()).nextInt(1000));\n                } catch (InterruptedException ex) {\n                }\n                log(dev + \", please await all horses\");\n                manager.arriveAndAwaitAdvance();\n                horse.run();\n            }\n        }.start();\n    }\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException ex) {\n    }\n    log(\"All arrived at starting gate, start race\");\n    manager.arriveAndDeregister();\n}\n","name":"runRace","className":"HorseRace","variables":{"horse":3,"ex":2,"dev":3,"manager":3,"run":1,"team":1,"Override":1,"Thread":2},"constants":{"\", please await all horses\"":1,"\"Assign all horses, then start race\"":1,"\"All arrived at starting gate, start race\"":1,"\" to the race\"":1,"1000":2,"\"assign \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"private static void log(String msg) {\n    System.out.println(msg);\n}\n","name":"log","className":"HorseRace","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"log":1,"toString":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void run() {\n    log(toString() + \": running\");\n}\n","name":"run","className":"Horse","variables":{},"constants":{"\": running\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic String toString() {\n    return \"horse #\" + id;\n}\n","name":"toString","className":"Horse","variables":{"id":1},"constants":{"\"horse #\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"HorseRace.manager.getArrivedParties":1,"System.out.println":1},"annotations":["Override"],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":2},"text":"@Override\npublic void run() {\n    while (true) {\n        System.out.println(\"Number of horses ready to run: \" + HorseRace.manager.getArrivedParties());\n        try {\n            Thread.sleep(1);\n        } catch (InterruptedException ex) {\n        }\n    }\n}\n","name":"run","className":"RaceMonitor","variables":{"ex":1,"Thread":1},"constants":{"1":1,"\"Number of horses ready to run: \"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"double":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":15,"StringLiteralExpr":3,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":4},"text":"@Override\npublic void run() {\n    System.out.println(\"Computing series sum\");\n    double sum = 0;\n    for (double term : termArray) {\n        sum += term;\n    }\n    System.out.println(\"ln (1-\" + x + \") equals \" + -sum);\n}\n","name":"run","className":"","variables":{"termArray":1,"x":1,"sum":3,"term":2},"constants":{"0":1,"\") equals \"":1,"\"ln (1-\"":1,"\"Computing series sum\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"double":2,"int":1,"CyclicBarrier":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":31,"StringLiteralExpr":4,"FieldAccessExpr":3,"MarkerAnnotationExpr":1,"UnaryExpr":2,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":3,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    CyclicBarrier barrier = new CyclicBarrier(numberOfTerms, new Runnable() {\n\n        @Override\n        public void run() {\n            System.out.println(\"Computing series sum\");\n            double sum = 0;\n            for (double term : termArray) {\n                sum += term;\n            }\n            System.out.println(\"ln (1-\" + x + \") equals \" + -sum);\n        }\n    });\n    for (int i = 0; i < numberOfTerms; i++) {\n        new Thread(new TermCalc(barrier, i)).start();\n    }\n    System.out.println(\"Waiting...\");\n}\n","name":"main","className":"NaturalLogCalc","variables":{"barrier":2,"termArray":1,"x":1,"i":4,"sum":3,"term":2,"run":1,"numberOfTerms":2,"Override":1},"constants":{"0":2,"\") equals \"":1,"\"ln (1-\"":1,"\"Computing series sum\"":1,"\"Waiting...\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["CyclicBarrier","int"],"returnType":"TermCalc","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public TermCalc(CyclicBarrier barrier, int termIndex) {\n    this.barrier = barrier;\n    this.termIndex = termIndex;\n}\n","name":"TermCalc","className":"TermCalc","variables":{"termIndex":1,"barrier":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printStackTrace":2,"await":1,"pow":1,"System.out.println":1},"annotations":["Override"],"exceptions":["BrokenBarrierException","InterruptedException"],"concepts":["ExceptionHandling"],"types":{"double":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":7,"NameExpr":25,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":2,"MethodCallExpr":5,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":3,"ExpressionStmt":6},"text":"@Override\npublic void run() {\n    double result = Math.pow(x, termIndex + 1) / (termIndex + 1);\n    termArray[termIndex] = result;\n    System.out.println(\"Term \" + (termIndex + 1) + \": \" + result);\n    try {\n        barrier.await();\n    } catch (InterruptedException ex) {\n        ex.printStackTrace();\n    } catch (BrokenBarrierException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"run","className":"TermCalc","variables":{"result":3,"termIndex":4,"barrier":1,"ex":4,"termArray":1,"Math":1},"constants":{"1":3,"\": \"":1,"\"Term \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":1,"start":2,"System.in.read":1,"interrupt":2},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Thread":2},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":20,"FieldAccessExpr":1,"CharLiteralExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    Thread producer = new Thread(new Producer());\n    Thread consumer = new Thread(new Consumer());\n    producer.start();\n    consumer.start();\n    try {\n        while (System.in.read() != '\\n') {\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    producer.interrupt();\n    consumer.interrupt();\n}\n","name":"main","className":"ProductExchanger","variables":{"ex":2,"producer":3,"consumer":3},"constants":{"'\\n'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"sleep":1,"random":2,"isEmpty":1,"System.out.print":2,"ProductExchanger.exchanger.exchange":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":4,"BooleanLiteralExpr":1,"NameExpr":49,"CastExpr":2,"StringLiteralExpr":3,"FieldAccessExpr":5,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":10,"AssignExpr":2},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":6,"TryStmt":1,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":9},"text":"public void run() {\n    int j = 0;\n    while (okToRun) {\n        if (buffer.isEmpty()) {\n            try {\n                for (int i = 0; i < BUFFSIZE; i++) {\n                    buffer.add((int) (Math.random() * 100));\n                }\n                Thread.sleep((int) (Math.random() * 1000));\n                System.out.print(\"Producer Buffer: \");\n                for (int i : buffer) {\n                    System.out.print(i + \", \");\n                }\n                System.out.println();\n                System.out.println(\"Exchanging ...\");\n                buffer = ProductExchanger.exchanger.exchange(buffer);\n            } catch (InterruptedException ex) {\n                okToRun = false;\n            }\n        }\n    }\n}\n","name":"run","className":"Producer","variables":{"ex":1,"BUFFSIZE":1,"okToRun":2,"i":5,"j":1,"buffer":4,"Math":2,"Thread":1},"constants":{"0":2,"100":1,"\"Producer Buffer: \"":1,"\"Exchanging ...\"":1,"1000":1,"false":1,"\", \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"random":1,"isEmpty":1,"clear":1,"ProductExchanger.exchanger.exchange":1,"System.out.print":2,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":38,"StringLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":8,"AssignExpr":2},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":5,"TryStmt":1,"ForeachStmt":1,"ExpressionStmt":7},"text":"public void run() {\n    while (okToRun) {\n        try {\n            if (buffer.isEmpty()) {\n                buffer = ProductExchanger.exchanger.exchange(buffer);\n                System.out.print(\"Consumer Buffer: \");\n                for (int i : buffer) {\n                    System.out.print(i + \", \");\n                }\n                System.out.println(\"\\n\");\n                Thread.sleep((int) (Math.random() * 1000));\n                buffer.clear();\n            }\n        } catch (InterruptedException ex) {\n            okToRun = false;\n        }\n    }\n}\n","name":"run","className":"Consumer","variables":{"ex":1,"okToRun":2,"i":2,"buffer":4,"Math":1,"Thread":1},"constants":{"\"Consumer Buffer: \"":1,"1000":1,"false":1,"\", \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"sleep":1,"setDaemon":2,"start":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"LinkedTransferQueue":1,"int":1,"TransferQueue<String>":1,"Thread":2},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BooleanLiteralExpr":2,"BinaryExpr":1,"NameExpr":19,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"public static void main(String... args) {\n    TransferQueue<String> queue = new LinkedTransferQueue();\n    Thread producer = new Thread(new Producer(queue));\n    producer.setDaemon(true);\n    producer.start();\n    for (int i = 0; i < 10; i++) {\n        Thread consumer = new Thread(new Consumer(queue));\n        consumer.setDaemon(true);\n        consumer.start();\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException ex) {\n        }\n    }\n}\n","name":"main","className":"LuckyNumberGenerator","variables":{"ex":1,"producer":3,"i":3,"queue":3,"consumer":3,"Thread":1},"constants":{"0":1,"true":2,"2000":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["TransferQueue<String>"],"returnType":"Producer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"Producer(TransferQueue<String> queue) {\n    this.queue = queue;\n}\n","name":"Producer","className":"Producer","variables":{"queue":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":2,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"private String produce() {\n    return \" your lucky number \" + (new Random().nextInt(100));\n}\n","name":"produce","className":"Producer","variables":{},"constants":{"100":1,"\" your lucky number \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"transfer":1,"TimeUnit.SECONDS.sleep":1,"produce":1,"hasWaitingConsumer":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":13,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        while (true) {\n            if (queue.hasWaitingConsumer()) {\n                queue.transfer(produce());\n            }\n            TimeUnit.SECONDS.sleep(1);\n        }\n    } catch (InterruptedException ex) {\n    }\n}\n","name":"run","className":"Producer","variables":{"ex":1,"queue":2},"constants":{"1":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TransferQueue<String>"],"returnType":"Consumer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"Consumer(TransferQueue<String> queue) {\n    this.queue = queue;\n}\n","name":"Consumer","className":"Consumer","variables":{"queue":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"take":1,"currentThread":1,"getName":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":1},"text":"public void run() {\n    try {\n        System.out.println(\" Consumer \" + Thread.currentThread().getName() + queue.take());\n    } catch (InterruptedException ex) {\n    }\n}\n","name":"run","className":"Consumer","variables":{"ex":1,"queue":1,"Thread":1},"constants":{"\" Consumer \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":1,"System.in.read":1,"interrupt":2,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"Buyer":1,"Seller":1,"LinkedBlockingQueue":1,"Thread[]":2,"int":2,"BlockingQueue<Integer>":1,"Thread":2},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":6,"VariableDeclarationExpr":9,"ArrayAccessExpr":4,"BinaryExpr":3,"NameExpr":43,"StringLiteralExpr":2,"CharLiteralExpr":1,"UnaryExpr":2,"AssignExpr":2,"FieldAccessExpr":3,"ArrayCreationExpr":2,"MethodCallExpr":7},"statements":{"WhileStmt":1,"BlockStmt":6,"TryStmt":1,"EmptyStmt":1,"ForeachStmt":2,"ForStmt":2,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    System.out.printf(\"Hit Enter to terminate%n%n\");\n    BlockingQueue<Integer> orderQueue = new LinkedBlockingQueue<Integer>();\n    Seller seller = new Seller(orderQueue);\n    Thread[] sellerThread = new Thread[100];\n    for (int i = 0; i < 100; i++) {\n        sellerThread[i] = new Thread(seller);\n        sellerThread[i].start();\n    }\n    Buyer buyer = new Buyer(orderQueue);\n    Thread[] buyerThread = new Thread[100];\n    for (int i = 0; i < 100; i++) {\n        buyerThread[i] = new Thread(buyer);\n        buyerThread[i].start();\n    }\n    try {\n        while (System.in.read() != '\\n') ;\n    } catch (IOException ex) {\n    }\n    System.out.println(\"Terminating\");\n    for (Thread t : sellerThread) {\n        t.interrupt();\n    }\n    for (Thread t : buyerThread) {\n        t.interrupt();\n    }\n}\n","name":"main","className":"StockExchange","variables":{"seller":2,"orderQueue":3,"ex":1,"t":4,"buyerThread":4,"i":10,"sellerThread":4,"buyer":2},"constants":{"0":2,"\"Terminating\"":1,"100":4,"'\\n'":1,"\"Hit Enter to terminate%n%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["BlockingQueue"],"returnType":"Seller","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Seller(BlockingQueue orderQueue) {\n    this.orderQueue = orderQueue;\n}\n","name":"Seller","className":"Seller","variables":{"orderQueue":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"random":1,"currentThread":1,"getName":1,"put":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["Casting","ExceptionHandling"],"types":{"Integer":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":5,"BooleanLiteralExpr":2,"NameExpr":20,"CastExpr":1,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":4},"text":"public void run() {\n    while (shutdownRequest == false) {\n        Integer quantity = (int) (Math.random() * 100);\n        try {\n            orderQueue.put(quantity);\n            System.out.println(\"Sell order by \" + Thread.currentThread().getName() + \": \" + quantity);\n        } catch (InterruptedException iex) {\n            shutdownRequest = true;\n        }\n    }\n}\n","name":"run","className":"Seller","variables":{"orderQueue":1,"quantity":2,"shutdownRequest":2,"Math":1,"iex":1,"Thread":1},"constants":{"100":1,"false":1,"true":1,"\": \"":1,"\"Sell order by \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["BlockingQueue"],"returnType":"Buyer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Buyer(BlockingQueue orderQueue) {\n    this.orderQueue = orderQueue;\n}\n","name":"Buyer","className":"Buyer","variables":{"orderQueue":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"take":1,"currentThread":1,"getName":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["Casting","ExceptionHandling"],"types":{"Integer":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":4,"BooleanLiteralExpr":2,"NameExpr":16,"CastExpr":1,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":3},"text":"public void run() {\n    while (shutdownRequest == false) {\n        try {\n            Integer quantity = (Integer) orderQueue.take();\n            System.out.println(\"Buy order by \" + Thread.currentThread().getName() + \": \" + quantity);\n        } catch (InterruptedException iex) {\n            shutdownRequest = true;\n        }\n    }\n}\n","name":"run","className":"Buyer","variables":{"orderQueue":1,"quantity":2,"shutdownRequest":2,"iex":1,"Thread":1},"constants":{"\"Buy order by \"":1,"false":1,"true":1,"\": \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void drawShape() {\n}\n","name":"drawShape","className":"Shape","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"@Override\npublic void drawShape() {\n}\n","name":"drawShape","className":"drawShape","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getClass":2,"isAnnotationPresent":2,"getAnnotation":2,"doSomething":2,"System.out.println":8},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Shape":1,"Class":1,"WorkInProgress":2,"drawShape":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":5,"NameExpr":65,"StringLiteralExpr":4,"CastExpr":2,"ClassExpr":4,"FieldAccessExpr":8,"MethodCallExpr":16,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":4,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    Shape shape = new Shape();\n    Class cls = shape.getClass();\n    if (cls.isAnnotationPresent(WorkInProgress.class)) {\n        System.out.println(\"Shape class does require some work\");\n        WorkInProgress progress = (WorkInProgress) cls.getAnnotation(WorkInProgress.class);\n        System.out.println(progress.doSomething());\n    } else {\n        System.out.println(\"Shape is fully implemented\");\n    }\n    System.out.println();\n    drawShape line = new drawShape();\n    cls = line.getClass();\n    if (cls.isAnnotationPresent(WorkInProgress.class)) {\n        System.out.println(\"Line class does require some work\");\n        WorkInProgress progress = (WorkInProgress) cls.getAnnotation(WorkInProgress.class);\n        System.out.println(progress.doSomething());\n    } else {\n        System.out.println(\"Line is fully implemented\");\n    }\n    System.out.println();\n}\n","name":"main","className":"drawShape","variables":{"shape":2,"line":2,"progress":4,"cls":6},"constants":{"\"Line is fully implemented\"":1,"\"Shape class does require some work\"":1,"\"Line class does require some work\"":1,"\"Shape is fully implemented\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["float","float"],"returnType":"float","methodCalls":{},"annotations":["Task","WorkInProgress"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"@WorkInProgress\n@Task(description = \"Implement tax computations\", targetDate = \"Jan 1, 2012\", estimatedHours = 50, additionalNote = \"This implementation is critical for the final launch\")\npublic static float ComputeTax(float amount, float rate) {\n    return 0;\n}\n","name":"ComputeTax","className":"CustomAnnotation","variables":{},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseDouble":1,"exit":1,"System.out.printf":1,"values":1,"System.out.println":2,"performConversion":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Converter":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":35,"StringLiteralExpr":4,"FieldAccessExpr":4,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    if (args.length == 0) {\n        System.out.println(\"Usage: java UnitsConverter <weight in pounds>\");\n        System.exit(0);\n    }\n    numberToConvert = Double.parseDouble(args[0]);\n    System.out.println(\"lbs \" + args[0] + \" equals:\\n\");\n    for (Converter conv : Converter.values()) {\n        System.out.printf(\"%s: %f%n\", conv, conv.performConversion(numberToConvert));\n    }\n}\n","name":"main","className":"UnitsConverter","variables":{"args":2,"numberToConvert":1,"Converter":1,"conv":2,"Double":1,"System":1},"constants":{"0":4,"\"Usage: java UnitsConverter <weight in pounds>\"":1,"\"lbs \"":1,"\"%s: %f%n\"":1,"\" equals:\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1},"text":"double performConversion(double f) {\n    return f *= 0.45359237;\n}\n","name":"performConversion","className":"","variables":{"f":1},"constants":{"0.45359237":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1},"text":"double performConversion(double f) {\n    return f *= 2267.96185;\n}\n","name":"performConversion","className":"","variables":{"f":1},"constants":{"2267.96185":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1},"text":"double performConversion(double f) {\n    return f *= 453.59237;\n}\n","name":"performConversion","className":"","variables":{"f":1},"constants":{"453.59237":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1},"text":"double performConversion(double f) {\n    return f *= 16;\n}\n","name":"performConversion","className":"","variables":{"f":1},"constants":{"16":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1},"text":"double performConversion(double f) {\n    return f *= 0.071428571429;\n}\n","name":"performConversion","className":"","variables":{"f":1},"constants":{"0.071428571429":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"Converter(String symbol) {\n    this.symbol = symbol;\n}\n","name":"Converter","className":"","variables":{"symbol":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"@Override\npublic String toString() {\n    return symbol;\n}\n","name":"toString","className":"","variables":{"symbol":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"abstract double performConversion(double f);\n","name":"performConversion","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1024}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":1,"values":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"DaysOfTheWeek":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":19,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    System.out.println(\"Days of week:\");\n    for (DaysOfTheWeek day : DaysOfTheWeek.values()) {\n        System.out.printf(\"%s \", day);\n    }\n    System.out.println();\n}\n","name":"main","className":"WeekDaysList","variables":{"DaysOfTheWeek":1,"day":1},"constants":{"\"Days of week:\"":1,"\"%s \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{"toLowerCase":1,"substring":2},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":1,"NameExpr":10,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"@Override\npublic String toString() {\n    //only capitalize the first letter\n    String s = super.toString();\n    return s.substring(0, 1) + s.substring(1).toLowerCase();\n}\n","name":"toString","className":"","variables":{"s":3},"constants":{"0":1,"1":2},"javaDoc":"","comments":"only capitalize the first letter ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"saySomething":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Cat":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Cat c = new Cat();\n    c.saySomething();\n}\n","name":"main","className":"OverrideAnnotationDemoApp","variables":{"c":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"void saySomething() {\n    System.out.println(\"Animal talking\");\n}\n","name":"saySomething","className":"Animal","variables":{},"constants":{"\"Animal talking\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\nvoid saySomething() {\n    System.out.println(\"meow... meow\");\n}\n","name":"saySomething","className":"Cat","variables":{},"constants":{"\"meow... meow\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"isLowerCase":1,"isDigit":1,"isUpperCase":1,"isWhitespace":1,"isLetter":1,"System.out.println":5},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":57,"StringLiteralExpr":5,"FieldAccessExpr":5,"UnaryExpr":6,"MethodCallExpr":10},"statements":{"IfStmt":5,"BlockStmt":6,"ForStmt":1,"ExpressionStmt":11},"text":"public static void main(String args[]) throws Exception {\n    int digitCount = 0, letterCount = 0, lcCount = 0, ucCount = 0, wsCount = 0;\n    for (int i = 0; i < 0xFF; i++) {\n        if (Character.isDigit(i)) {\n            digitCount++;\n        }\n        if (Character.isLetter(i)) {\n            letterCount++;\n        }\n        if (Character.isLowerCase(i)) {\n            lcCount++;\n        }\n        if (Character.isUpperCase(i)) {\n            ucCount++;\n        }\n        if (Character.isWhitespace(i)) {\n            wsCount++;\n        }\n    }\n    System.out.println(\"No of digits: \" + digitCount);\n    System.out.println(\"No of letters: \" + letterCount);\n    System.out.println(\"No of lower case letters: \" + lcCount);\n    System.out.println(\"No of upper case letters: \" + ucCount);\n    System.out.println(\"No of white space characters: \" + wsCount);\n}\n","name":"main","className":"CharWrapper","variables":{"wsCount":3,"Character":5,"letterCount":3,"i":3,"ucCount":3,"digitCount":3,"lcCount":3},"constants":{"0":6,"\"No of white space characters: \"":1,"\"No of lower case letters: \"":1,"\"No of digits: \"":1,"\"No of letters: \"":1,"\"No of upper case letters: \"":1,"0xFF":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"writeObject":1,"close":2,"System.out.println":4,"readObject":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"ColorPalette":1,"ObjectOutputStream":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":36,"StringLiteralExpr":6,"CastExpr":1,"FieldAccessExpr":5,"MethodCallExpr":8},"statements":{"TryStmt":1,"BlockStmt":3,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    ColorPalette drawingColor = ColorPalette.GREEN;\n    try {\n        System.out.println(\"Saving color setting\");\n        ObjectOutputStream outStream = new ObjectOutputStream(new FileOutputStream(\"Settings.dat\"));\n        outStream.writeObject(drawingColor);\n        outStream.close();\n        ObjectInputStream inStream = new ObjectInputStream(new FileInputStream(\"Settings.dat\"));\n        System.out.println(\"Retrieved object: \" + (ColorPalette) inStream.readObject());\n        inStream.close();\n    } catch (IOException e) {\n        System.out.println(\"Error reading/writing object\");\n    } catch (ClassNotFoundException cfe) {\n        System.out.println(\"Class casting error\");\n    }\n}\n","name":"main","className":"EnumSerialization","variables":{"cfe":1,"e":1,"inStream":3,"drawingColor":1,"outStream":3},"constants":{"\"Retrieved object: \"":1,"\"Settings.dat\"":2,"\"Saving color setting\"":1,"\"Error reading/writing object\"":1,"\"Class casting error\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"doSomethingNew":1,"doSomething":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MyTestClass":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    MyTestClass testObject = new MyTestClass();\n    testObject.doSomething();\n    testObject.doSomethingNew(\"Bowling\");\n}\n","name":"main","className":"DeprecatedAnnotationDemo","variables":{"testObject":3},"constants":{"\"Bowling\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":["Deprecated"],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"@Deprecated\npublic void doSomething() {\n}\n","name":"doSomething","className":"MyTestClass","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void doSomethingNew(String SomeFun) {\n}\n","name":"doSomethingNew","className":"MyTestClass","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":4,"intValue":2,"equals":1,"compareTo":2,"System.out.println":9},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Integer":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":18,"StringLiteralExpr":17,"NameExpr":81,"FieldAccessExpr":9,"MethodCallExpr":18},"statements":{"ExpressionStmt":11},"text":"public static void main(String args[]) throws Exception {\n    // object construction\n    Integer n1 = new Integer(5);\n    Integer n2 = new Integer(\"10\");\n    // object value\n    System.out.println(\"n1 holds value: \" + n1.intValue());\n    System.out.println(\"n2 holds value: \" + n2.intValue());\n    // object equality\n    System.out.println(n1 + \" = \" + n2 + \" is \" + n1.equals(n2));\n    // object comparison\n    System.out.println(n1 + \" compared to \" + n2 + \" returns \" + n1.compareTo(n2));\n    System.out.println(n2 + \" compared to \" + n1 + \" returns \" + n2.compareTo(n1));\n    // parsing a string\n    System.out.println(\"The string holds int value: \" + Integer.parseInt(\"245\"));\n    System.out.println(\"The string holds int value: \" + Integer.parseInt(\"FF\", 16));\n    System.out.println(\"The string holds int value: \" + Integer.parseInt(\"100\", 8));\n    System.out.println(\"The string holds int value: \" + Integer.parseInt(\"Jim\", 27));\n}\n","name":"main","className":"TypeWrapperApp","variables":{"Integer":4,"n1":7,"n2":6},"constants":{"\"The string holds int value: \"":4,"16":1,"\"100\"":1,"27":1,"\"n2 holds value: \"":1,"\"245\"":1,"\" = \"":1,"\"FF\"":1,"\"10\"":1,"\" is \"":1,"\"Jim\"":1,"5":1,"\" returns \"":2,"\"n1 holds value: \"":1,"\" compared to \"":2,"8":1},"javaDoc":"","comments":"object construction object value object equality object comparison parsing a string ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// Constructor\nApple(int price) {\n    this.price = price;\n}\n","name":"Apple","className":"","variables":{"price":1},"constants":{},"javaDoc":"","comments":" Constructor","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"int getPrice() {\n    return price;\n}\n","name":"getPrice","className":"","variables":{"price":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"values":1,"getPrice":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Apple":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":17,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":2},"text":"public static void main(String args[]) {\n    System.out.println(\"Apple price list:\");\n    for (Apple apple : Apple.values()) {\n        System.out.println(apple + \" costs \" + apple.getPrice() + \" cents.\");\n    }\n}\n","name":"main","className":"ApplesEnum","variables":{"apple":3,"Apple":1},"constants":{"\" costs \"":1,"\" cents.\"":1,"\"Apple price list:\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["float","float"],"returnType":"float","methodCalls":{},"annotations":["Task","WorkInProgress"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"@WorkInProgress\n@Task(description = \"Implement tax computations\", estimatedHours = 50, additionalNote = \"This implementation is critical for the final launch\")\npublic static float ComputeTax(float amount, float rate) {\n    return 0;\n}\n","name":"ComputeTax","className":"RuntimeAnnotation","variables":{},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getClass":1,"getName":2,"isAnnotationPresent":3,"System.out.printf":1,"targetDate":1,"description":1,"getMessage":1,"getAnnotation":2,"additionalNote":1,"estimatedHours":1,"getMethods":1,"System.out.print":1,"System.out.println":5},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"RuntimeAnnotation":1,"Task":1,"Class":1,"WorkInProgress":1,"Method":1,"Method[]":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":9,"NameExpr":78,"CastExpr":2,"StringLiteralExpr":9,"ClassExpr":5,"FieldAccessExpr":7,"MethodCallExpr":21},"statements":{"IfStmt":3,"TryStmt":1,"BlockStmt":6,"ForeachStmt":1,"ExpressionStmt":12},"text":"public static void main(String args[]) {\n    try {\n        RuntimeAnnotation obj = new RuntimeAnnotation();\n        Class cls = obj.getClass();\n        WorkInProgress annotation = (WorkInProgress) cls.getAnnotation(WorkInProgress.class);\n        System.out.println(\"Class \" + cls.getName());\n        if (cls.isAnnotationPresent(WorkInProgress.class)) {\n            System.out.println(\"\\tThis class is not fully implemented\");\n        }\n        System.out.println(\"\\nList of methods:\");\n        Method[] methods = cls.getMethods();\n        for (Method method : methods) {\n            System.out.println(method.getName());\n            if (method.isAnnotationPresent(WorkInProgress.class)) {\n                System.out.println(\"\\tThis method is not fully implemented\");\n            }\n            if (method.isAnnotationPresent(Task.class)) {\n                Task annotationTask = (Task) method.getAnnotation(Task.class);\n                System.out.printf(\"\\tWhat TODO: \" + annotationTask.description() + \"%n\\tTarget date: \" + annotationTask.targetDate() + \"%n\\tEstimated hours: \" + annotationTask.estimatedHours() + \"%n\\tNote: \" + annotationTask.additionalNote() + \"%n\");\n            }\n        }\n    } catch (Exception e) {\n        System.out.print(e.getMessage());\n    }\n}\n","name":"main","className":"RuntimeAnnotation","variables":{"annotation":1,"method":5,"annotationTask":5,"e":2,"obj":2,"methods":2,"cls":5},"constants":{"\"\\nList of methods:\"":1,"\"%n\\tEstimated hours: \"":1,"\"%n\\tNote: \"":1,"\"\\tThis class is not fully implemented\"":1,"\"%n\"":1,"\"Class \"":1,"\"\\tWhat TODO: \"":1,"\"%n\\tTarget date: \"":1,"\"\\tThis method is not fully implemented\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"java.io.StringBufferInputStream":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    java.io.StringBufferInputStream in = new java.io.StringBufferInputStream(\"A sample string\");\n}\n","name":"main","className":"DeprecatedAnnotation","variables":{"in":1},"constants":{"\"A sample string\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":2,"adder":1,"System.out.println":3},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Integer":1,"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":6,"FieldAccessExpr":5,"MethodCallExpr":6},"statements":{"ExpressionStmt":8},"text":"public static void main(String args[]) throws Exception {\n    System.out.println(\"Demonstrating power of autoboxing/unboxing\");\n    Integer a = 100;\n    int b = 200;\n    int c = a + b;\n    System.out.println(\"Autoboxing in action: arithmetic expressions\");\n    System.out.printf(\"%d + %d = %d%n%n\", a, b, c);\n    System.out.println(\"Autoboxing in action: \" + \"method parameters and return types\");\n    System.out.printf(\"%d + %d = %d%n\", a, b, adder(a, b));\n}\n","name":"main","className":"Autobox","variables":{"a":2,"b":2,"c":1},"constants":{"100":1,"200":1,"\"Demonstrating power of autoboxing/unboxing\"":1,"\"%d + %d = %d%n%n\"":1,"\"method parameters and return types\"":1,"\"Autoboxing in action: arithmetic expressions\"":1,"\"Autoboxing in action: \"":1,"\"%d + %d = %d%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Integer","Integer"],"returnType":"Integer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"private static Integer adder(Integer a, Integer b) {\n    return a + b;\n}\n","name":"adder","className":"Autobox","variables":{"a":1,"b":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"dispose":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void windowClosing(WindowEvent evt) {\n    dispose();\n}\n","name":"windowClosing","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"IntrospectionTestApplication","methodCalls":{"add":1,"setVisible":1,"addWindowListener":1,"setResizable":1,"dispose":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":2,"BooleanLiteralExpr":2,"StringLiteralExpr":2,"NameExpr":23,"FieldAccessExpr":2,"MarkerAnnotationExpr":1,"MethodCallExpr":6,"AssignExpr":1},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":7},"text":"IntrospectionTestApplication() {\n    super(\"Introspection Test\");\n    setBounds(200, 200, 200, 200);\n    setResizable(false);\n    labelDisplay = new JLabel(\"Hello\", JLabel.CENTER);\n    add(labelDisplay, BorderLayout.CENTER);\n    addWindowListener(new WindowAdapter() {\n\n        @Override\n        public void windowClosing(WindowEvent evt) {\n            dispose();\n        }\n    });\n    setVisible(true);\n}\n","name":"IntrospectionTestApplication","className":"IntrospectionTestApplication","variables":{"evt":1,"windowClosing":1,"labelDisplay":1,"Override":1},"constants":{"\"Hello\"":1,"200":4,"false":1,"true":1,"\"Introspection Test\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String args[]) {\n    new IntrospectionTestApplication();\n}\n","name":"main","className":"IntrospectionTestApplication","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setDefaultString() {\n    displayString = \"Hello\";\n    labelDisplay.setText(displayString);\n}\n","name":"setDefaultString","className":"IntrospectionTestApplication","variables":{"displayString":1,"labelDisplay":1},"constants":{"\"Hello\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["short","short","short"],"returnType":"void","methodCalls":{"setForeground":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":8,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setDisplayColor(short red, short blue, short green) {\n    textColor = new Color(red, blue, green);\n    labelDisplay.setForeground(textColor);\n}\n","name":"setDisplayColor","className":"IntrospectionTestApplication","variables":{"red":1,"green":1,"blue":1,"textColor":1,"labelDisplay":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setDisplayString(String str) {\n    displayString = str;\n    labelDisplay.setText(displayString);\n}\n","name":"setDisplayString","className":"IntrospectionTestApplication","variables":{"str":1,"displayString":1,"labelDisplay":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setFontSize(int size) {\n    textFont = new Font(\"Arial\", Font.PLAIN, size);\n    labelDisplay.setFont(textFont);\n}\n","name":"setFontSize","className":"IntrospectionTestApplication","variables":{"size":1,"textFont":1,"labelDisplay":1},"constants":{"\"Arial\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"init":1,"setTitle":1,"setDefaultCloseOperation":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"LocalTimeConverter":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    LocalTimeConverter app = new LocalTimeConverter();\n    app.setTitle(\"Local Time Converter\");\n    app.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    app.init();\n    app.setBounds(100, 100, 700, 500);\n    app.setVisible(true);\n}\n","name":"main","className":"LocalTimeConverter","variables":{"app":6},"constants":{"\"Local Time Converter\"":1,"100":2,"500":1,"700":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getPoint":1,"getTimeZone":1,"getTime":1,"format":1,"show":1,"getSelectedValue":1,"computeTimeAtSelectedZone":1,"getX":1,"locationToIndex":1,"getY":1,"getDisplayName":1,"getTimeNowAsString":1,"getComponent":1,"isSelectionEmpty":1,"setText":2},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":8,"NameExpr":50,"CastExpr":1,"StringLiteralExpr":3,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":16,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":7},"text":"@Override\npublic void mouseClicked(MouseEvent e) {\n    localTime.setText(getTimeNowAsString());\n    int index = listOfZones.locationToIndex(e.getPoint());\n    if (index > -1 && !(listOfZones.isSelectionEmpty())) {\n        selectedZone = (String) listOfZones.getSelectedValue();\n        computeTimeAtSelectedZone();\n        // display time for remote zone in the popup\n        String timezoneName = TimeZone.getTimeZone(selectedZone).getDisplayName();\n        menuItem.setText(\"Local time @ \" + selectedZone + \" \" + sdf.format(calendar.getTime()) + \" \" + timezoneName);\n        popup.show(e.getComponent(), e.getX(), e.getY() + 10);\n    }\n}\n","name":"mouseClicked","className":"","variables":{"calendar":1,"localTime":1,"listOfZones":3,"TimeZone":1,"popup":1,"sdf":1,"e":4,"selectedZone":2,"index":2,"timezoneName":2,"menuItem":1},"constants":{"1":1,"\"Local time @ \"":1,"\" \"":2,"10":1},"javaDoc":"","comments":"display time for remote zone in the popup ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getTimeZone":3,"setTimeInMillis":1,"getOffset":2,"getTimeInMillis":1,"setTimeZone":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":1,"int":3},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":35,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":8},"statements":{"ExpressionStmt":8},"text":"private void computeTimeAtSelectedZone() {\n    // reset calendar to local timezone\n    calendar = new GregorianCalendar();\n    long currentTime = calendar.getTimeInMillis();\n    // get time offset of local timezone wrt GMT\n    int localOffset = calendar.getTimeZone().getOffset(Calendar.ZONE_OFFSET);\n    // get time offset of remote timezone wrt GMT\n    calendar.setTimeZone(TimeZone.getTimeZone(selectedZone));\n    int remoteOffset = calendar.getTimeZone().getOffset(Calendar.ZONE_OFFSET);\n    // difference in two timezones\n    int totalOffset = -remoteOffset + localOffset;\n    // add offset to current local time\n    currentTime -= totalOffset;\n    // set time in remote zone\n    calendar.setTimeInMillis(currentTime);\n}\n","name":"computeTimeAtSelectedZone","className":"","variables":{"calendar":6,"currentTime":2,"TimeZone":1,"localOffset":2,"remoteOffset":2,"totalOffset":2},"constants":{},"javaDoc":"","comments":"reset calendar to local timezone get time offset of local timezone wrt GMT get time offset of remote timezone wrt GMT difference in two timezones add offset to current local time set time in remote zone ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"getTimeZone":4,"getTime":1,"getOffset":2,"show":1,"getSelectedValue":1,"setBackground":1,"asList":1,"setLayoutOrientation":1,"toArray":1,"setTimeZone":1,"getTimeNowAsString":2,"setVisibleRowCount":1,"setFont":1,"isSelectionEmpty":1,"setHorizontalTextPosition":1,"add":3,"getPoint":1,"setForeground":2,"format":1,"getTimeInMillis":1,"setSelectionMode":1,"sort":1,"getAvailableIDs":1,"computeTimeAtSelectedZone":1,"getX":1,"locationToIndex":1,"getY":1,"addAll":1,"getDisplayName":1,"setTimeInMillis":1,"getComponent":1,"addMouseListener":1,"setText":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables","PolyMorphism"],"types":{"JScrollPane":1,"ArrayList":1,"JLabel":1,"String":1,"JMenuItem":1,"JPopupMenu":1,"JList":1,"int":4,"long":1,"List<String>":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":7,"VariableDeclarationExpr":12,"BinaryExpr":9,"NameExpr":173,"StringLiteralExpr":4,"MarkerAnnotationExpr":1,"UnaryExpr":4,"AssignExpr":3,"CastExpr":1,"FieldAccessExpr":11,"EnclosedExpr":1,"MethodCallExpr":42},"statements":{"IfStmt":1,"BlockStmt":3,"ExpressionStmt":35},"text":"private void init() {\n    final JPopupMenu popup = new JPopupMenu();\n    final JMenuItem menuItem = new JMenuItem();\n    popup.add(menuItem);\n    menuItem.setBackground(Color.yellow);\n    menuItem.setForeground(Color.blue);\n    final JLabel localTime = new JLabel(getTimeNowAsString(), JLabel.CENTER);\n    localTime.setHorizontalTextPosition(JLabel.CENTER);\n    localTime.setFont(new Font(\"Tahoma\", Font.PLAIN, 24));\n    localTime.setForeground(new Color(0, 0, 255));\n    add(localTime, BorderLayout.PAGE_START);\n    List<String> zoneList = new ArrayList<String>();\n    zoneList.addAll(Arrays.asList(TimeZone.getAvailableIDs()));\n    Collections.sort(zoneList);\n    final JList listOfZones = new JList(zoneList.toArray());\n    listOfZones.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);\n    listOfZones.setLayoutOrientation(JList.HORIZONTAL_WRAP);\n    listOfZones.setVisibleRowCount(-1);\n    listOfZones.addMouseListener(new MouseAdapter() {\n\n        private Calendar calendar;\n\n        private String selectedZone;\n\n        @Override\n        public void mouseClicked(MouseEvent e) {\n            localTime.setText(getTimeNowAsString());\n            int index = listOfZones.locationToIndex(e.getPoint());\n            if (index > -1 && !(listOfZones.isSelectionEmpty())) {\n                selectedZone = (String) listOfZones.getSelectedValue();\n                computeTimeAtSelectedZone();\n                // display time for remote zone in the popup\n                String timezoneName = TimeZone.getTimeZone(selectedZone).getDisplayName();\n                menuItem.setText(\"Local time @ \" + selectedZone + \" \" + sdf.format(calendar.getTime()) + \" \" + timezoneName);\n                popup.show(e.getComponent(), e.getX(), e.getY() + 10);\n            }\n        }\n\n        private void computeTimeAtSelectedZone() {\n            // reset calendar to local timezone\n            calendar = new GregorianCalendar();\n            long currentTime = calendar.getTimeInMillis();\n            // get time offset of local timezone wrt GMT\n            int localOffset = calendar.getTimeZone().getOffset(Calendar.ZONE_OFFSET);\n            // get time offset of remote timezone wrt GMT\n            calendar.setTimeZone(TimeZone.getTimeZone(selectedZone));\n            int remoteOffset = calendar.getTimeZone().getOffset(Calendar.ZONE_OFFSET);\n            // difference in two timezones\n            int totalOffset = -remoteOffset + localOffset;\n            // add offset to current local time\n            currentTime -= totalOffset;\n            // set time in remote zone\n            calendar.setTimeInMillis(currentTime);\n        }\n    });\n    JScrollPane listScroller = new JScrollPane(listOfZones);\n    add(listScroller, BorderLayout.CENTER);\n}\n","name":"init","className":"LocalTimeConverter","variables":{"calendar":8,"zoneList":3,"e":5,"localOffset":2,"selectedZone":3,"index":2,"menuItem":4,"computeTimeAtSelectedZone":1,"currentTime":2,"localTime":5,"listOfZones":9,"popup":3,"TimeZone":3,"sdf":1,"mouseClicked":1,"remoteOffset":2,"timezoneName":2,"listScroller":1,"Arrays":1,"Collections":1,"Override":1,"totalOffset":2},"constants":{"0":2,"1":2,"24":1,"255":1,"\"Local time @ \"":1,"\" \"":2,"\"Tahoma\"":1,"10":1},"javaDoc":"","comments":"display time for remote zone in the popup reset calendar to local timezone get time offset of local timezone wrt GMT get time offset of remote timezone wrt GMT difference in two timezones add offset to current local time set time in remote zone ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{"getDisplayName":1,"getTimeZone":1,"getTime":1,"format":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Calendar":1,"GregorianCalendar":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":12,"MethodCallExpr":4},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"private String getTimeNowAsString() {\n    Calendar calendar = new GregorianCalendar();\n    String strLocalTime = \"Local Time-\" + sdf.format(calendar.getTime()) + \" \" + calendar.getTimeZone().getDisplayName();\n    return strLocalTime;\n}\n","name":"getTimeNowAsString","className":"LocalTimeConverter","variables":{"calendar":3,"sdf":1,"strLocalTime":2},"constants":{"\"Local Time-\"":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"ClassBrowser","methodCalls":{"initComponents":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public ClassBrowser() {\n    initComponents();\n}\n","name":"ClassBrowser","className":"ClassBrowser","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setArgumentValue(String argumentValue) {\n    this.argumentValue = argumentValue;\n}\n","name":"setArgumentValue","className":"ClassBrowser","variables":{"argumentValue":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":12,"setViewportView":2,"setResizable":1,"addActionListener":2,"setTitle":1,"getContentPane":13,"setDefaultCloseOperation":1,"setLayout":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"GridBagConstraints":2},"expressions":{"ObjectCreationExpr":30,"IntegerLiteralExpr":88,"VariableDeclarationExpr":1,"DoubleLiteralExpr":4,"BooleanLiteralExpr":1,"NameExpr":295,"StringLiteralExpr":6,"FieldAccessExpr":65,"ThisExpr":2,"MethodCallExpr":34,"AssignExpr":69},"statements":{"ExpressionStmt":91},"text":"private void initComponents() {\n    setTitle(\"Class Browser\");\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    setResizable(false);\n    getContentPane().setLayout(new java.awt.GridBagLayout());\n    GridBagConstraints gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 0;\n    gridBagConstraints.gridwidth = 7;\n    gridBagConstraints.insets = new java.awt.Insets(11, 23, 0, 0);\n    getContentPane().add(new JLabel(\"Enter name of class file to be loaded & press accept\"), gridBagConstraints);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 7;\n    gridBagConstraints.gridy = 1;\n    gridBagConstraints.gridwidth = 9;\n    gridBagConstraints.gridheight = 2;\n    gridBagConstraints.insets = new java.awt.Insets(18, 18, 0, 20);\n    buttonAccept.addActionListener(this);\n    getContentPane().add(buttonAccept, gridBagConstraints);\n    jScrollPane1.setViewportView(listConstructors);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 4;\n    gridBagConstraints.gridwidth = 16;\n    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n    gridBagConstraints.ipadx = 257;\n    gridBagConstraints.ipady = 71;\n    gridBagConstraints.weightx = 1.0;\n    gridBagConstraints.weighty = 1.0;\n    gridBagConstraints.insets = new java.awt.Insets(6, 10, 0, 20);\n    getContentPane().add(jScrollPane1, gridBagConstraints);\n    jScrollPane2.setViewportView(listMethods);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 6;\n    gridBagConstraints.gridwidth = 16;\n    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n    gridBagConstraints.ipadx = 257;\n    gridBagConstraints.ipady = 81;\n    gridBagConstraints.weightx = 1.0;\n    gridBagConstraints.weighty = 1.0;\n    gridBagConstraints.insets = new java.awt.Insets(6, 10, 0, 20);\n    getContentPane().add(jScrollPane2, gridBagConstraints);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 8;\n    gridBagConstraints.gridy = 7;\n    gridBagConstraints.gridwidth = 8;\n    gridBagConstraints.insets = new java.awt.Insets(18, 17, 0, 0);\n    buttonInvoke.addActionListener(this);\n    getContentPane().add(buttonInvoke, gridBagConstraints);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 5;\n    gridBagConstraints.insets = new java.awt.Insets(11, 10, 0, 0);\n    getContentPane().add(new JLabel(\"Methods\"), gridBagConstraints);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 3;\n    gridBagConstraints.insets = new java.awt.Insets(1, 10, 0, 0);\n    getContentPane().add(new JLabel(\"Constructors\"), gridBagConstraints);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 1;\n    gridBagConstraints.gridwidth = 6;\n    gridBagConstraints.ipadx = 183;\n    gridBagConstraints.insets = new java.awt.Insets(19, 10, 0, 0);\n    getContentPane().add(textClassName, gridBagConstraints);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 8;\n    gridBagConstraints.gridwidth = 2;\n    gridBagConstraints.insets = new java.awt.Insets(29, 10, 0, 0);\n    getContentPane().add(new JLabel(\"Return Type\"), gridBagConstraints);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 9;\n    gridBagConstraints.gridwidth = 3;\n    gridBagConstraints.insets = new java.awt.Insets(6, 10, 11, 0);\n    getContentPane().add(new JLabel(\"Return Value\"), gridBagConstraints);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 3;\n    gridBagConstraints.gridy = 8;\n    gridBagConstraints.gridwidth = 2;\n    gridBagConstraints.ipadx = 48;\n    gridBagConstraints.insets = new java.awt.Insets(29, 16, 0, 0);\n    getContentPane().add(returnType, gridBagConstraints);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 3;\n    gridBagConstraints.gridy = 9;\n    gridBagConstraints.insets = new java.awt.Insets(6, 18, 11, 0);\n    getContentPane().add(returnValue, gridBagConstraints);\n    pack();\n}\n","name":"initComponents","className":"ClassBrowser","variables":{"gridBagConstraints":12,"buttonAccept":1,"jScrollPane1":1,"jScrollPane2":1,"buttonInvoke":1},"constants":{"23":1,"48":1,"\"Enter name of class file to be loaded & press accept\"":1,"29":2,"\"Class Browser\"":1,"257":2,"\"Constructors\"":1,"71":1,"\"Return Value\"":1,"10":7,"11":4,"16":3,"17":1,"18":4,"\"Return Type\"":1,"false":1,"19":1,"183":1,"0":28,"1":3,"2":3,"1.0":4,"3":4,"4":1,"\"Methods\"":1,"5":1,"6":6,"7":3,"8":4,"9":3,"81":1,"20":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"printStackTrace":1,"setBounds":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"ClassBrowser":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public static void main(String args[]) {\n    try {\n        // UIManager.setLookAndFeel(\"javax.swing.plaf.nimbus.NimbusLookAndFeel\");\n        ClassBrowser app = new ClassBrowser();\n        app.setBounds(220, 30, 470, 600);\n        app.setVisible(true);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"ClassBrowser","variables":{"app":3,"ex":2},"constants":{"220":1,"600":1,"true":1,"30":1,"470":1},"javaDoc":"","comments":"UIManager setLookAndFeel(\"javax swing plaf nimbus NimbusLookAndFeel\"); ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"displayMethods":1,"invokeSelectedMethod":1,"requestFocus":1,"forName":1,"getSource":1,"getText":1,"equals":1,"clear":2,"newInstance":1,"toString":1,"addElement":3,"setText":2},"annotations":["Override"],"exceptions":["Throwable","Exception"],"concepts":["ExceptionHandling"],"types":{"Object":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":54,"StringLiteralExpr":5,"MethodCallExpr":16,"AssignExpr":3},"statements":{"IfStmt":3,"BlockStmt":7,"TryStmt":2,"ReturnStmt":2,"ExpressionStmt":14},"text":"@Override\npublic void actionPerformed(ActionEvent aevt) {\n    Object source = aevt.getSource();\n    if (source == buttonAccept) {\n        strClassName = textClassName.getText();\n        if (strClassName.equals(\"\")) {\n            return;\n        }\n        constructors.clear();\n        methods.clear();\n        returnValue.setText(\"\");\n        returnType.setText(\"\");\n        try {\n            theClass = Class.forName(strClassName);\n        } catch (Throwable exp) {\n            constructors.addElement(\"You have entered the class name incorrectly\");\n            constructors.addElement(\"Please input a new class name\");\n            textClassName.requestFocus();\n            return;\n        }\n        try {\n            obj = theClass.newInstance();\n        } catch (Exception e) {\n            constructors.addElement(e.toString());\n        }\n        displayMethods();\n    } else if (source == buttonInvoke) {\n        invokeSelectedMethod();\n    }\n}\n","name":"actionPerformed","className":"ClassBrowser","variables":{"returnValue":1,"e":2,"methods":1,"source":3,"theClass":2,"aevt":1,"strClassName":2,"constructors":4,"obj":1,"buttonAccept":1,"Class":1,"exp":1,"textClassName":2,"buttonInvoke":1,"returnType":1},"constants":{"\"\"":3,"\"You have entered the class name incorrectly\"":1,"\"Please input a new class name\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getDeclaredMethods":1,"requestFocus":1,"getDeclaredConstructors":1,"addElement":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Constructor":1,"Method":1,"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":33,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":7},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":5},"text":"private void displayMethods() {\n    Method methodList[] = theClass.getDeclaredMethods();\n    Constructor constructorList[] = theClass.getDeclaredConstructors();\n    for (int count = 0; count < constructorList.length; count++) {\n        constructors.addElement(constructorList[count].toString());\n    }\n    for (int count = 0; count < methodList.length; count++) {\n        methods.addElement(methodList[count].toString());\n    }\n    listMethods.requestFocus();\n}\n","name":"displayMethods","className":"ClassBrowser","variables":{"constructors":1,"methods":1,"count":8,"listMethods":1,"methodList":2,"theClass":2,"constructorList":2},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"getDeclaredMethods":1,"getClass":1,"getName":1,"valueOf":1,"getSelectedIndex":1,"toString":2,"charAt":1,"setText":5,"System.out.println":1},"annotations":[],"exceptions":["java.lang.IllegalAccessException","Exception"],"concepts":["ExceptionHandling"],"types":{"Class":1,"Object":1,"Method":1,"int":2,"Object[]":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":8,"VariableDeclarationExpr":6,"ArrayAccessExpr":20,"BinaryExpr":1,"NameExpr":181,"StringLiteralExpr":3,"UnaryExpr":1,"AssignExpr":9,"BooleanLiteralExpr":2,"FieldAccessExpr":27,"EnclosedExpr":1,"ArrayCreationExpr":1,"ThisExpr":1,"MethodCallExpr":26},"statements":{"IfStmt":8,"BlockStmt":13,"TryStmt":1,"ForStmt":1,"ExpressionStmt":21},"text":"private void invokeSelectedMethod() {\n    returnType.setText(\"\");\n    returnValue.setText(\"\");\n    int index = listMethods.getSelectedIndex();\n    Method classMethods[] = theClass.getDeclaredMethods();\n    Class inputParameters[] = classMethods[index].getParameterTypes();\n    Object[] params = new Object[inputParameters.length];\n    for (int i = 0; i < inputParameters.length; i++) {\n        (new InputFrame(this, inputParameters[i].getName(), true)).setVisible(true);\n        if (inputParameters[i].isAssignableFrom(java.lang.Short.TYPE)) {\n            params[i] = new Short(argumentValue);\n        } else if (inputParameters[i].isAssignableFrom(java.lang.Boolean.TYPE)) {\n            params[i] = Boolean.valueOf(argumentValue);\n        } else if (inputParameters[i].isAssignableFrom(java.lang.Character.TYPE)) {\n            params[i] = new Character(argumentValue.charAt(0));\n        } else if (inputParameters[i].isAssignableFrom(java.lang.Byte.TYPE)) {\n            params[i] = new Byte(argumentValue);\n        } else if (inputParameters[i].isAssignableFrom(java.lang.Integer.TYPE)) {\n            params[i] = new Integer(argumentValue);\n        } else if (inputParameters[i].isAssignableFrom(java.lang.Long.TYPE)) {\n            params[i] = new Long(argumentValue);\n        } else if (inputParameters[i].isAssignableFrom(java.lang.Float.TYPE)) {\n            params[i] = new Float(argumentValue);\n        } else if (inputParameters[i].isAssignableFrom(java.lang.Double.TYPE)) {\n            params[i] = new Double(argumentValue);\n        } else {\n            params[i] = argumentValue;\n        }\n    }\n    try {\n        Object returnObject = classMethods[index].invoke(obj, params);\n        returnValue.setText(returnObject.toString());\n        returnType.setText(returnObject.getClass().getName());\n    } catch (java.lang.IllegalAccessException iae) {\n        System.out.println(\"Invalid operation\");\n    } catch (Exception e) {\n        returnValue.setText(e.toString());\n    }\n}\n","name":"invokeSelectedMethod","className":"ClassBrowser","variables":{"returnValue":3,"e":2,"index":3,"i":21,"theClass":1,"params":10,"argumentValue":8,"iae":1,"inputParameters":10,"classMethods":3,"returnObject":3,"listMethods":1,"Boolean":1,"returnType":2},"constants":{"\"\"":2,"0":2,"\"Invalid operation\"":1,"true":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["ClassBrowser","String","boolean"],"returnType":"InputFrame","methodCalls":{"init":1,"setTitle":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":3},"text":"InputFrame(ClassBrowser app, String name, boolean model) {\n    super(app, model);\n    setTitle(name);\n    this.app = app;\n    init();\n}\n","name":"InputFrame","className":"InputFrame","variables":{"app":2,"model":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":2,"addActionListener":1,"setLayout":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"NameExpr":13,"ThisExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"private void init() {\n    setBounds(50, 50, 200, 100);\n    setLayout(new FlowLayout());\n    add(inputText);\n    add(buttonOK);\n    buttonOK.addActionListener(this);\n}\n","name":"init","className":"InputFrame","variables":{"buttonOK":1},"constants":{"100":1,"200":1,"50":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSource":1,"getText":1,"dispose":1,"setArgumentValue":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":12,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"@Override\npublic void actionPerformed(ActionEvent evt) {\n    if (evt.getSource() == buttonOK) {\n        app.setArgumentValue(inputText.getText());\n        dispose();\n    }\n}\n","name":"actionPerformed","className":"InputFrame","variables":{"app":1,"evt":1,"inputText":1,"buttonOK":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getClass":1,"printGreeting":1,"forName":1,"printStackTrace":1,"invoke":1,"getMethod":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"DynamicInvoker":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayInitializerExpr":2,"NameExpr":25,"StringLiteralExpr":5,"FieldAccessExpr":2,"ArrayCreationExpr":2,"MethodCallExpr":7},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    DynamicInvoker app = new DynamicInvoker();\n    app.printGreeting(\"Jonny\", 5);\n    System.out.println(\"\\nDynamic invocation of printGreeting method\");\n    try {\n        app.getClass().getMethod(\"printGreeting\", new Class[] { Class.forName(\"java.lang.String\"), Integer.TYPE }).invoke(app, new Object[] { \"Sanjay\", new Integer(3) });\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"DynamicInvoker","variables":{"app":3,"ex":2,"Class":1},"constants":{"\"\\nDynamic invocation of printGreeting method\"":1,"\"java.lang.String\"":1,"3":1,"5":1,"\"Jonny\"":1,"\"Sanjay\"":1,"\"printGreeting\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"public void printGreeting(String name, int numberOfTimes) {\n    for (int i = 0; i < numberOfTimes; i++) {\n        System.out.println(\"Hello \" + name);\n    }\n}\n","name":"printGreeting","className":"DynamicInvoker","variables":{"name":1,"i":3,"numberOfTimes":1},"constants":{"0":1,"\"Hello \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"equals":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":3},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":6,"StringLiteralExpr":6,"NameExpr":33,"FieldAccessExpr":4,"EnclosedExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    String str1 = \"This is a test string\";\n    String str2 = new String(str1);\n    String str3 = \"This is a test string\";\n    System.out.println(\"str1.equals(str2) returns \" + str1.equals(str2));\n    System.out.println(\"str1==str2 returns \" + (str1 == str2));\n    System.out.println(\"str1.equals(str3) returns \" + str1.equals(str3));\n    System.out.println(\"str1==str3 returns \" + (str1 == str3));\n}\n","name":"main","className":"StringComparator","variables":{"str3":2,"str1":6,"str2":2},"constants":{"\"str1==str3 returns \"":1,"\"This is a test string\"":2,"\"str1==str2 returns \"":1,"\"str1.equals(str3) returns \"":1,"\"str1.equals(str2) returns \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseFloat":2,"contains":1,"split":1,"valueOf":1,"replace":2,"format":1,"substring":1,"System.out.println":8},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":3,"String[]":1,"float":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":79,"StringLiteralExpr":12,"FieldAccessExpr":8,"CharLiteralExpr":2,"MethodCallExpr":17,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForeachStmt":1,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    // retrieving a substring\n    String dateField = trade.substring(4, 14);\n    System.out.println(\"Substring field date equals \" + dateField);\n    // locating a character sequence\n    if (trade.contains(\"09/09/2009\")) {\n        System.out.println(\"This is a trade on 09/09/2009\");\n    }\n    // replacing a character\n    String str = trade.replace(',', ':');\n    System.out.println(\"After replacing delimiter: \" + str);\n    // replacing a character sequence\n    str = trade.replace(\"100\", \"101\");\n    System.out.println(\"After replacing trade price 100: \" + str);\n    System.out.println(\"Splitting string into its fields\");\n    String[] fields = trade.split(\",\");\n    for (String strFields : fields) {\n        System.out.println(\"\\t\" + strFields);\n    }\n    float hilowDifference = Float.parseFloat(fields[3]) - Float.parseFloat(fields[4]);\n    str = String.valueOf(hilowDifference);\n    System.out.println(\"Difference in Hi to Low price: $\" + str);\n    System.out.println(String.format(\"Formatted HiLow Difference: $%.02f\", hilowDifference));\n}\n","name":"main","className":"StocksEODParser","variables":{"str":6,"Float":2,"trade":5,"dateField":2,"String":2,"fields":4,"strFields":2,"hilowDifference":1},"constants":{"','":1,"14":1,"\"Formatted HiLow Difference: $%.02f\"":1,"\"101\"":1,"\"100\"":1,"\"This is a trade on 09/09/2009\"":1,"\"Substring field date equals \"":1,"\"After replacing trade price 100: \"":1,"\"09/09/2009\"":1,"3":1,"4":2,"':'":1,"\"After replacing delimiter: \"":1,"\"Splitting string into its fields\"":1,"\",\"":1,"\"\\t\"":1,"\"Difference in Hi to Low price: $\"":1},"javaDoc":"","comments":"retrieving a substring locating a character sequence replacing a character replacing a character sequence ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":10,"getInstance":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Calendar":1,"float":3,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"DoubleLiteralExpr":2,"BinaryExpr":4,"NameExpr":85,"StringLiteralExpr":14,"CastExpr":1,"FieldAccessExpr":16,"MethodCallExpr":11},"statements":{"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    float rate = 12.5f;\n    int quantity = 100;\n    float total = 1250;\n    System.out.printf(\"Rate: %1$.2f Quantity:%2$d Total:%3$.2f\\n\", rate, quantity, total);\n    System.out.printf(\"Total: %3$.2f Quantity:%2$d Rate:%1$.2f\\n\\n\", rate, quantity, total);\n    float f = (float) 123456789.98;\n    System.out.printf(\"US - Price: %,.2f\\n\", f);\n    System.out.printf(Locale.FRANCE, \"France - Price: %,.2f\\n\", f);\n    System.out.printf(Locale.GERMANY, \"German - Price: %,.2f\\n\", f);\n    System.out.printf(Locale.CHINA, \"China - Price: %,.2f\\n\\n\", f);\n    Calendar calendar = Calendar.getInstance();\n    System.out.printf(\"The current local time is %tr on \" + \"%<tA, %<tB %<te, %<tY.%n\", calendar);\n    System.out.printf(Locale.FRANCE, \"The current local time is %tr on \" + \"%<tA, %<tB %<te, %<tY.%n\", calendar);\n    System.out.printf(Locale.GERMANY, \"The current local time is %tr on \" + \"%<tA, %<tB %<te, %<tY.%n\", calendar);\n    System.out.printf(Locale.CHINA, \"The current local time is %tr on \" + \"%<tA, %<tB %<te, %<tY.%n\", calendar);\n}\n","name":"main","className":"StringFormatter","variables":{"calendar":1,"total":1,"quantity":1,"rate":1,"f":1,"Calendar":1},"constants":{"\"%<tA, %<tB %<te, %<tY.%n\"":4,"100":1,"\"China - Price: %,.2f\\n\\n\"":1,"\"Rate: %1$.2f Quantity:%2$d Total:%3$.2f\\n\"":1,"123456789.98":1,"\"Total: %3$.2f Quantity:%2$d Rate:%1$.2f\\n\\n\"":1,"\"The current local time is %tr on \"":4,"12.5f":1,"1250":1,"\"German - Price: %,.2f\\n\"":1,"\"US - Price: %,.2f\\n\"":1,"\"France - Price: %,.2f\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawString":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"@Override\npublic void paint(Graphics g) {\n    g.drawString(\"Java programming is easy\", 30, 30);\n}\n","name":"paint","className":"FirstApplet","variables":{"g":1},"constants":{"\"Java programming is easy\"":1,"30":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"add":1,"getX":3,"getY":3,"show":1,"setCursor":2,"getModifiers":2,"getComponent":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":5,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":57,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":13,"AssignExpr":4},"statements":{"IfStmt":3,"BlockStmt":4,"ExpressionStmt":8},"text":"@Override\npublic void mouseClicked(MouseEvent e) {\n    if (e.getModifiers() == InputEvent.BUTTON3_MASK) {\n        popMenu.show(e.getComponent(), e.getX(), e.getY());\n    } else if (e.getModifiers() == InputEvent.BUTTON1_MASK) {\n        if (!isDrawing) {\n            ptFirst = new Point(e.getX(), e.getY());\n            ptSecond = new Point(e.getX(), e.getY());\n            isDrawing = true;\n            setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));\n        } else {\n            isDrawing = false;\n            setCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n            lines.add(new Line(ptFirst, ptSecond, drawingColor));\n        }\n    }\n}\n","name":"mouseClicked","className":"","variables":{"popMenu":1,"isDrawing":3,"e":9,"drawingColor":1,"ptFirst":2,"lines":1,"ptSecond":2},"constants":{"true":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"repaint":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":12,"AssignExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"@Override\npublic void mouseMoved(MouseEvent e) {\n    if (isDrawing) {\n        ptOld = ptSecond;\n        ptSecond = new Point(e.getX(), e.getY());\n        repaint();\n    }\n}\n","name":"mouseMoved","className":"","variables":{"isDrawing":1,"ptOld":1,"e":2,"ptSecond":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":4,"getX":4,"getY":4,"addActionListener":3,"show":1,"addMouseMotionListener":1,"setCursor":2,"getModifiers":2,"getComponent":1,"repaint":1,"addMouseListener":1},"annotations":["Override"],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":12,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":104,"StringLiteralExpr":4,"FieldAccessExpr":4,"MarkerAnnotationExpr":2,"UnaryExpr":1,"ThisExpr":3,"AssignExpr":10,"MethodCallExpr":24},"statements":{"IfStmt":4,"BlockStmt":7,"ExpressionStmt":23},"text":"@Override\npublic void init() {\n    popMenu = new JPopupMenu(\"Colors\");\n    menuRed = new JMenuItem(\"Red\");\n    menuRed.addActionListener(this);\n    menuGreen = new JMenuItem(\"Green\");\n    menuGreen.addActionListener(this);\n    menuBlue = new JMenuItem(\"Blue\");\n    menuBlue.addActionListener(this);\n    popMenu.add(menuRed);\n    popMenu.add(menuGreen);\n    popMenu.add(menuBlue);\n    addMouseListener(new MouseAdapter() {\n\n        @Override\n        public void mouseClicked(MouseEvent e) {\n            if (e.getModifiers() == InputEvent.BUTTON3_MASK) {\n                popMenu.show(e.getComponent(), e.getX(), e.getY());\n            } else if (e.getModifiers() == InputEvent.BUTTON1_MASK) {\n                if (!isDrawing) {\n                    ptFirst = new Point(e.getX(), e.getY());\n                    ptSecond = new Point(e.getX(), e.getY());\n                    isDrawing = true;\n                    setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));\n                } else {\n                    isDrawing = false;\n                    setCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n                    lines.add(new Line(ptFirst, ptSecond, drawingColor));\n                }\n            }\n        }\n    });\n    addMouseMotionListener(new MouseMotionAdapter() {\n\n        @Override\n        public void mouseMoved(MouseEvent e) {\n            if (isDrawing) {\n                ptOld = ptSecond;\n                ptSecond = new Point(e.getX(), e.getY());\n                repaint();\n            }\n        }\n    });\n}\n","name":"init","className":"GraphicsEditor3","variables":{"popMenu":5,"menuBlue":2,"isDrawing":4,"ptOld":1,"e":13,"menuGreen":2,"drawingColor":1,"ptSecond":4,"menuRed":2,"mouseClicked":1,"ptFirst":2,"lines":1,"mouseMoved":1,"Override":2},"constants":{"\"Green\"":1,"\"Red\"":1,"true":1,"false":1,"\"Colors\"":1,"\"Blue\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"getStartPoint":2,"setColor":3,"getEndPoint":2,"hasNext":1,"drawLine":3,"getLineColor":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"Line":1,"Iterator<Line>":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":78,"FieldAccessExpr":13,"MethodCallExpr":14},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":8},"text":"@Override\npublic void paint(Graphics g) {\n    // erase old line\n    g.setColor(Color.white);\n    g.drawLine(ptFirst.x, ptFirst.y, ptOld.x, ptOld.y);\n    // draw new line\n    g.setColor(drawingColor);\n    g.drawLine(ptFirst.x, ptFirst.y, ptSecond.x, ptSecond.y);\n    Iterator<Line> it = lines.iterator();\n    while (it.hasNext()) {\n        Line line = it.next();\n        g.setColor(line.getLineColor());\n        g.drawLine(line.getStartPoint().x, line.getStartPoint().y, line.getEndPoint().x, line.getEndPoint().y);\n    }\n}\n","name":"paint","className":"GraphicsEditor3","variables":{"line":6,"g":6,"it":3,"lines":1},"constants":{},"javaDoc":"","comments":"erase old line draw new line ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSource":3},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":24,"FieldAccessExpr":3,"MethodCallExpr":3,"AssignExpr":3},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":3},"text":"@Override\npublic void actionPerformed(ActionEvent e) {\n    if (e.getSource() == menuRed) {\n        drawingColor = Color.red;\n    } else if (e.getSource() == menuGreen) {\n        drawingColor = Color.green;\n    } else if (e.getSource() == menuBlue) {\n        drawingColor = Color.blue;\n    }\n}\n","name":"actionPerformed","className":"GraphicsEditor3","variables":{"menuBlue":1,"e":3,"menuRed":1,"menuGreen":1,"drawingColor":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Point","Point"],"returnType":"Line","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Line(Point ptStart, Point ptEnd) {\n    this.ptStart = ptStart;\n    this.ptEnd = ptEnd;\n}\n","name":"Line","className":"Line","variables":{"ptEnd":1,"ptStart":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Point","Point","Color"],"returnType":"Line","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":3,"ThisExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public Line(Point ptStart, Point ptEnd, Color lineColor) {\n    this.ptStart = ptStart;\n    this.ptEnd = ptEnd;\n    this.lineColor = lineColor;\n}\n","name":"Line","className":"Line","variables":{"ptEnd":1,"lineColor":1,"ptStart":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Point","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Point getEndPoint() {\n    return ptEnd;\n}\n","name":"getEndPoint","className":"Line","variables":{"ptEnd":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Point","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Point getStartPoint() {\n    return ptStart;\n}\n","name":"getStartPoint","className":"Line","variables":{"ptStart":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Color","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Color getLineColor() {\n    return lineColor;\n}\n","name":"getLineColor","className":"Line","variables":{"lineColor":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"repaint":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":9,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"@Override\npublic void mouseClicked(MouseEvent e) {\n    pt = new Point(e.getX(), e.getY());\n    repaint();\n}\n","name":"mouseClicked","className":"","variables":{"pt":1,"e":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getX":1,"getY":1,"repaint":1,"addMouseListener":1},"annotations":["Override"],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":14,"MarkerAnnotationExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ExpressionStmt":3},"text":"@Override\npublic void init() {\n    addMouseListener(new MouseAdapter() {\n\n        @Override\n        public void mouseClicked(MouseEvent e) {\n            pt = new Point(e.getX(), e.getY());\n            repaint();\n        }\n    });\n}\n","name":"init","className":"GraphicsEditor","variables":{"pt":1,"e":3,"mouseClicked":1,"Override":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"format":1,"drawString":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":25,"StringLiteralExpr":1,"FieldAccessExpr":6,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"@Override\npublic void paint(Graphics g) {\n    if (pt.x > 0 && pt.x > 0) {\n        String printString = String.format(\"(%d, %d)\", pt.x, pt.y);\n        g.drawString(printString, pt.x, pt.y);\n    }\n}\n","name":"paint","className":"GraphicsEditor","variables":{"g":1,"String":1,"printString":1},"constants":{"0":2,"\"(%d, %d)\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"add":1,"requestFocus":1,"getX":1,"getY":1,"setCursor":2},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":4,"NameExpr":28,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"@Override\npublic void mouseClicked(MouseEvent e) {\n    textMode = !textMode;\n    if (textMode) {\n        requestFocus();\n        pt = new Point(e.getX(), e.getY());\n        setCursor(new Cursor(Cursor.TEXT_CURSOR));\n    } else {\n        captionList.add(new Caption(pt, strInput));\n        setCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n        strInput = \"\";\n    }\n}\n","name":"mouseClicked","className":"","variables":{"strInput":2,"pt":2,"e":2,"textMode":3,"captionList":1},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"getKeyChar":1,"repaint":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"@Override\npublic void keyTyped(KeyEvent e) {\n    strInput += e.getKeyChar();\n    repaint();\n}\n","name":"keyTyped","className":"","variables":{"strInput":1,"e":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"requestFocus":1,"getX":1,"getY":1,"addKeyListener":1,"getKeyChar":1,"setCursor":2,"repaint":1,"addMouseListener":1},"annotations":["Override"],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":6,"NameExpr":44,"StringLiteralExpr":1,"FieldAccessExpr":2,"MarkerAnnotationExpr":2,"UnaryExpr":1,"MethodCallExpr":10,"AssignExpr":4},"statements":{"IfStmt":1,"BlockStmt":4,"ExpressionStmt":11},"text":"@Override\npublic void init() {\n    addMouseListener(new MouseAdapter() {\n\n        @Override\n        public void mouseClicked(MouseEvent e) {\n            textMode = !textMode;\n            if (textMode) {\n                requestFocus();\n                pt = new Point(e.getX(), e.getY());\n                setCursor(new Cursor(Cursor.TEXT_CURSOR));\n            } else {\n                captionList.add(new Caption(pt, strInput));\n                setCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n                strInput = \"\";\n            }\n        }\n    });\n    addKeyListener(new KeyAdapter() {\n\n        @Override\n        public void keyTyped(KeyEvent e) {\n            strInput += e.getKeyChar();\n            repaint();\n        }\n    });\n}\n","name":"init","className":"KeyboardDemoApp","variables":{"strInput":3,"pt":2,"e":5,"mouseClicked":1,"textMode":3,"captionList":1,"Override":2,"keyTyped":1},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"next":1,"getPt":2,"iterator":1,"getStrDisplay":1,"hasNext":1,"drawString":2},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"Iterator<Caption>":1,"Caption":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":35,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"@Override\npublic void paint(Graphics g) {\n    g.drawString(strInput, pt.x, pt.y);\n    Iterator<Caption> it = captionList.iterator();\n    while (it.hasNext()) {\n        Caption caption = it.next();\n        g.drawString(caption.getStrDisplay(), caption.getPt().x, caption.getPt().y);\n    }\n}\n","name":"paint","className":"KeyboardDemoApp","variables":{"g":2,"caption":4,"it":3,"captionList":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Point","String"],"returnType":"Caption","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Caption(Point pt, String strDisplay) {\n    this.pt = pt;\n    this.strDisplay = strDisplay;\n}\n","name":"Caption","className":"Caption","variables":{"strDisplay":1,"pt":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Point","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Point getPt() {\n    return pt;\n}\n","name":"getPt","className":"Caption","variables":{"pt":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getStrDisplay() {\n    return strDisplay;\n}\n","name":"getStrDisplay","className":"Caption","variables":{"strDisplay":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"add":1,"getX":3,"getY":3,"show":1,"setCursor":2,"getModifiers":2,"getComponent":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":5,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":57,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":13,"AssignExpr":4},"statements":{"IfStmt":3,"BlockStmt":4,"ExpressionStmt":8},"text":"@Override\npublic void mouseClicked(MouseEvent e) {\n    if (e.getModifiers() == InputEvent.BUTTON3_MASK) {\n        popMenu.show(e.getComponent(), e.getX(), e.getY());\n    } else if (e.getModifiers() == InputEvent.BUTTON1_MASK) {\n        if (!isDrawing) {\n            ptFirst = new Point(e.getX(), e.getY());\n            ptSecond = new Point(e.getX(), e.getY());\n            isDrawing = true;\n            setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));\n        } else {\n            isDrawing = false;\n            setCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n            lines.add(new Line(ptFirst, ptSecond, drawingColor));\n        }\n    }\n}\n","name":"mouseClicked","className":"","variables":{"popMenu":1,"isDrawing":3,"e":9,"drawingColor":1,"ptFirst":2,"lines":1,"ptSecond":2},"constants":{"true":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"repaint":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":12,"AssignExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"@Override\npublic void mouseMoved(MouseEvent e) {\n    if (isDrawing) {\n        ptOld = ptSecond;\n        ptSecond = new Point(e.getX(), e.getY());\n        repaint();\n    }\n}\n","name":"mouseMoved","className":"","variables":{"isDrawing":1,"ptOld":1,"e":2,"ptSecond":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5,"getX":4,"getY":4,"addSeparator":1,"addActionListener":4,"show":1,"addMouseMotionListener":1,"setCursor":2,"getModifiers":2,"getComponent":1,"repaint":1,"addMouseListener":1},"annotations":["Override"],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":13,"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":115,"StringLiteralExpr":5,"FieldAccessExpr":4,"MarkerAnnotationExpr":2,"UnaryExpr":1,"ThisExpr":4,"AssignExpr":11,"MethodCallExpr":27},"statements":{"IfStmt":4,"BlockStmt":7,"ExpressionStmt":27},"text":"@Override\npublic void init() {\n    popMenu = new JPopupMenu(\"Colors\");\n    menuRed = new JMenuItem(\"Red\");\n    menuRed.addActionListener(this);\n    menuGreen = new JMenuItem(\"Green\");\n    menuGreen.addActionListener(this);\n    menuBlue = new JMenuItem(\"Blue\");\n    menuBlue.addActionListener(this);\n    menuCustom = new JMenuItem(\"Custom\");\n    menuCustom.addActionListener(this);\n    popMenu.add(menuRed);\n    popMenu.add(menuGreen);\n    popMenu.add(menuBlue);\n    popMenu.addSeparator();\n    popMenu.add(menuCustom);\n    addMouseListener(new MouseAdapter() {\n\n        @Override\n        public void mouseClicked(MouseEvent e) {\n            if (e.getModifiers() == InputEvent.BUTTON3_MASK) {\n                popMenu.show(e.getComponent(), e.getX(), e.getY());\n            } else if (e.getModifiers() == InputEvent.BUTTON1_MASK) {\n                if (!isDrawing) {\n                    ptFirst = new Point(e.getX(), e.getY());\n                    ptSecond = new Point(e.getX(), e.getY());\n                    isDrawing = true;\n                    setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));\n                } else {\n                    isDrawing = false;\n                    setCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n                    lines.add(new Line(ptFirst, ptSecond, drawingColor));\n                }\n            }\n        }\n    });\n    addMouseMotionListener(new MouseMotionAdapter() {\n\n        @Override\n        public void mouseMoved(MouseEvent e) {\n            if (isDrawing) {\n                ptOld = ptSecond;\n                ptSecond = new Point(e.getX(), e.getY());\n                repaint();\n            }\n        }\n    });\n}\n","name":"init","className":"GraphicsEditor4","variables":{"popMenu":7,"menuBlue":2,"isDrawing":4,"ptOld":1,"e":13,"menuGreen":2,"menuCustom":2,"drawingColor":1,"ptSecond":4,"menuRed":2,"mouseClicked":1,"ptFirst":2,"lines":1,"mouseMoved":1,"Override":2},"constants":{"\"Green\"":1,"\"Custom\"":1,"\"Red\"":1,"true":1,"false":1,"\"Colors\"":1,"\"Blue\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setClr(Color clr) {\n    this.drawingColor = clr;\n}\n","name":"setClr","className":"GraphicsEditor4","variables":{"clr":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"getStartPoint":2,"setColor":3,"getEndPoint":2,"hasNext":1,"drawLine":3,"getLineColor":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"Line":1,"Iterator<Line>":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":78,"FieldAccessExpr":13,"MethodCallExpr":14},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":8},"text":"@Override\npublic void paint(Graphics g) {\n    // erase old line\n    g.setColor(Color.white);\n    g.drawLine(ptFirst.x, ptFirst.y, ptOld.x, ptOld.y);\n    // draw new line\n    g.setColor(drawingColor);\n    g.drawLine(ptFirst.x, ptFirst.y, ptSecond.x, ptSecond.y);\n    Iterator<Line> it = lines.iterator();\n    while (it.hasNext()) {\n        Line line = it.next();\n        g.setColor(line.getLineColor());\n        g.drawLine(line.getStartPoint().x, line.getStartPoint().y, line.getEndPoint().x, line.getEndPoint().y);\n    }\n}\n","name":"paint","className":"GraphicsEditor4","variables":{"line":6,"g":6,"it":3,"lines":1},"constants":{},"javaDoc":"","comments":"erase old line draw new line ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSource":4},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":4,"BooleanLiteralExpr":1,"NameExpr":30,"StringLiteralExpr":1,"FieldAccessExpr":3,"EnclosedExpr":1,"ThisExpr":1,"MethodCallExpr":5,"AssignExpr":3},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":4},"text":"@Override\npublic void actionPerformed(ActionEvent e) {\n    if (e.getSource() == menuRed) {\n        drawingColor = Color.red;\n    } else if (e.getSource() == menuGreen) {\n        drawingColor = Color.green;\n    } else if (e.getSource() == menuBlue) {\n        drawingColor = Color.blue;\n    } else if (e.getSource() == menuCustom) {\n        (new ColorPalette(\"Color Palette\", this)).setVisible(true);\n    }\n}\n","name":"actionPerformed","className":"GraphicsEditor4","variables":{"menuBlue":1,"e":4,"menuRed":1,"menuGreen":1,"drawingColor":3,"menuCustom":1},"constants":{"true":1,"\"Color Palette\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Point","Point"],"returnType":"Line","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Line(Point ptStart, Point ptEnd) {\n    this.ptStart = ptStart;\n    this.ptEnd = ptEnd;\n}\n","name":"Line","className":"Line","variables":{"ptEnd":1,"ptStart":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Point","Point","Color"],"returnType":"Line","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":3,"ThisExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public Line(Point ptStart, Point ptEnd, Color clr) {\n    this.ptStart = ptStart;\n    this.ptEnd = ptEnd;\n    this.lineColor = clr;\n}\n","name":"Line","className":"Line","variables":{"ptEnd":1,"clr":1,"ptStart":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Point","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Point getEndPoint() {\n    return ptEnd;\n}\n","name":"getEndPoint","className":"Line","variables":{"ptEnd":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Point","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Point getStartPoint() {\n    return ptStart;\n}\n","name":"getStartPoint","className":"Line","variables":{"ptStart":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Color","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Color getLineColor() {\n    return lineColor;\n}\n","name":"getLineColor","className":"Line","variables":{"lineColor":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getBlueValue() {\n    return blueValue;\n}\n","name":"getBlueValue","className":"ColorPalette","variables":{"blueValue":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getGreenValue() {\n    return greenValue;\n}\n","name":"getGreenValue","className":"ColorPalette","variables":{"greenValue":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getRedValue() {\n    return redValue;\n}\n","name":"getRedValue","className":"ColorPalette","variables":{"redValue":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","GraphicsEditor4"],"returnType":"ColorPalette","methodCalls":{"setTitle":1,"initGUI":1},"annotations":[],"exceptions":["HeadlessException"],"concepts":[],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"public ColorPalette(String string, GraphicsEditor4 applet) throws HeadlessException {\n    setTitle(string);\n    this.applet = applet;\n    initGUI();\n}\n","name":"ColorPalette","className":"ColorPalette","variables":{"applet":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":8,"addAdjustmentListener":3,"setLayout":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":8,"NameExpr":36,"StringLiteralExpr":3,"ThisExpr":5,"MethodCallExpr":13,"AssignExpr":2},"statements":{"ExpressionStmt":15},"text":"private void initGUI() {\n    setLayout(new GridLayout(8, 1, 5, 5));\n    add(new JLabel(\"Red\"));\n    add(redScroll);\n    add(new JLabel(\"Green\"));\n    add(greenScroll);\n    add(new JLabel(\"Blue\"));\n    add(blueScroll);\n    messageCanvas = new MessageCanvas(this);\n    add(messageCanvas);\n    colorCanvas = new ColorCanvas(this);\n    add(colorCanvas);\n    redScroll.addAdjustmentListener(this);\n    blueScroll.addAdjustmentListener(this);\n    greenScroll.addAdjustmentListener(this);\n    setBounds(200, 200, 200, 200);\n}\n","name":"initGUI","className":"ColorPalette","variables":{"blueScroll":1,"redScroll":1,"greenScroll":1,"messageCanvas":1,"colorCanvas":1},"constants":{"\"Green\"":1,"1":1,"200":4,"5":2,"\"Red\"":1,"8":1,"\"Blue\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["AdjustmentEvent"],"returnType":"void","methodCalls":{"getValue":3,"setClr":1,"getAdjustable":3,"repaint":2},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":3,"NameExpr":36,"MethodCallExpr":9,"AssignExpr":3},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":6},"text":"@Override\npublic void adjustmentValueChanged(AdjustmentEvent e) {\n    if (e.getAdjustable() == redScroll) {\n        redValue = redScroll.getValue();\n    }\n    if (e.getAdjustable() == greenScroll) {\n        greenValue = greenScroll.getValue();\n    }\n    if (e.getAdjustable() == blueScroll) {\n        blueValue = blueScroll.getValue();\n    }\n    messageCanvas.repaint();\n    colorCanvas.repaint();\n    applet.setClr(new Color(redValue, greenValue, blueValue));\n}\n","name":"adjustmentValueChanged","className":"ColorPalette","variables":{"blueScroll":2,"redScroll":2,"e":3,"greenScroll":2,"redValue":2,"messageCanvas":1,"blueValue":2,"colorCanvas":1,"greenValue":2,"applet":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ColorPalette"],"returnType":"MessageCanvas","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"MessageCanvas(ColorPalette frame) {\n    this.frame = frame;\n}\n","name":"MessageCanvas","className":"MessageCanvas","variables":{"frame":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"getRedValue":1,"getGreenValue":1,"valueOf":3,"getBlueValue":1,"drawString":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":25,"StringLiteralExpr":3,"AssignExpr":3,"MethodCallExpr":7},"statements":{"ExpressionStmt":4},"text":"@Override\npublic void paint(Graphics g) {\n    strDisplay = \"Red:\" + String.valueOf(frame.getRedValue());\n    strDisplay += \" Green:\" + String.valueOf(frame.getGreenValue());\n    strDisplay += \" Blue:\" + String.valueOf(frame.getBlueValue());\n    g.drawString(strDisplay, 10, 10);\n}\n","name":"paint","className":"MessageCanvas","variables":{"strDisplay":3,"g":1,"String":3,"frame":3},"constants":{"\"Red:\"":1,"\" Green:\"":1,"\" Blue:\"":1,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ColorPalette"],"returnType":"ColorCanvas","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"ColorCanvas(ColorPalette applet) {\n    this.frame = applet;\n}\n","name":"ColorCanvas","className":"ColorCanvas","variables":{"applet":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":1,"getRedValue":1,"getGreenValue":1,"getBlueValue":1,"fillRect":1,"getBounds":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"Rectangle":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":23,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":3},"text":"@Override\npublic void paint(Graphics g) {\n    Rectangle rect = getBounds();\n    g.setColor(new Color(frame.getRedValue(), frame.getGreenValue(), frame.getBlueValue()));\n    g.fillRect(0, 0, rect.width, rect.height);\n}\n","name":"paint","className":"ColorCanvas","variables":{"rect":1,"g":2,"frame":3},"constants":{"0":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"add":1,"getX":2,"getY":2,"setCursor":2},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":5,"BooleanLiteralExpr":2,"NameExpr":32,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":4,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"@Override\npublic void mouseClicked(MouseEvent e) {\n    if (!isDrawing) {\n        ptFirst = new Point(e.getX(), e.getY());\n        ptSecond = new Point(e.getX(), e.getY());\n        isDrawing = true;\n        setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));\n    } else {\n        isDrawing = false;\n        setCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n        lines.add(new Line(ptFirst, ptSecond));\n    }\n}\n","name":"mouseClicked","className":"","variables":{"isDrawing":3,"e":4,"ptFirst":2,"lines":1,"ptSecond":2},"constants":{"true":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"repaint":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":12,"AssignExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"@Override\npublic void mouseMoved(MouseEvent e) {\n    if (isDrawing) {\n        ptOld = ptSecond;\n        ptSecond = new Point(e.getX(), e.getY());\n        repaint();\n    }\n}\n","name":"mouseMoved","className":"","variables":{"isDrawing":1,"ptOld":1,"e":2,"ptSecond":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"getX":3,"getY":3,"addMouseMotionListener":1,"setCursor":2,"repaint":1,"addMouseListener":1},"annotations":["Override"],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":8,"BooleanLiteralExpr":2,"NameExpr":54,"FieldAccessExpr":2,"MarkerAnnotationExpr":2,"UnaryExpr":1,"MethodCallExpr":12,"AssignExpr":6},"statements":{"IfStmt":2,"BlockStmt":5,"ExpressionStmt":12},"text":"@Override\npublic void init() {\n    addMouseListener(new MouseAdapter() {\n\n        @Override\n        public void mouseClicked(MouseEvent e) {\n            if (!isDrawing) {\n                ptFirst = new Point(e.getX(), e.getY());\n                ptSecond = new Point(e.getX(), e.getY());\n                isDrawing = true;\n                setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));\n            } else {\n                isDrawing = false;\n                setCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n                lines.add(new Line(ptFirst, ptSecond));\n            }\n        }\n    });\n    addMouseMotionListener(new MouseMotionAdapter() {\n\n        @Override\n        public void mouseMoved(MouseEvent e) {\n            if (isDrawing) {\n                ptOld = ptSecond;\n                ptSecond = new Point(e.getX(), e.getY());\n                repaint();\n            }\n        }\n    });\n}\n","name":"init","className":"GraphicsEditor2","variables":{"isDrawing":4,"ptOld":1,"e":8,"mouseClicked":1,"ptFirst":2,"lines":1,"mouseMoved":1,"Override":2,"ptSecond":4},"constants":{"true":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"getStartPoint":2,"setColor":2,"getEndPoint":2,"hasNext":1,"drawLine":3},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"Line":1,"Iterator<Line>":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":74,"FieldAccessExpr":14,"MethodCallExpr":12},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":7},"text":"@Override\npublic void paint(Graphics g) {\n    // erase earlier line\n    g.setColor(Color.white);\n    g.drawLine(ptFirst.x, ptFirst.y, ptOld.x, ptOld.y);\n    // draw new line\n    g.setColor(Color.red);\n    g.drawLine(ptFirst.x, ptFirst.y, ptSecond.x, ptSecond.y);\n    // draw all previous lines\n    Iterator<Line> it = lines.iterator();\n    while (it.hasNext()) {\n        Line line = it.next();\n        g.drawLine(line.getStartPoint().x, line.getStartPoint().y, line.getEndPoint().x, line.getEndPoint().y);\n    }\n}\n","name":"paint","className":"GraphicsEditor2","variables":{"line":5,"g":5,"it":3,"lines":1},"constants":{},"javaDoc":"","comments":"erase earlier line draw new line draw all previous lines ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Point","Point"],"returnType":"Line","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Line(Point ptStart, Point ptEnd) {\n    this.ptStart = ptStart;\n    this.ptEnd = ptEnd;\n}\n","name":"Line","className":"Line","variables":{"ptEnd":1,"ptStart":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Point","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Point getEndPoint() {\n    return ptEnd;\n}\n","name":"getEndPoint","className":"Line","variables":{"ptEnd":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Point","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Point getStartPoint() {\n    return ptStart;\n}\n","name":"getStartPoint","className":"Line","variables":{"ptStart":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":1,"System.in.read":1,"System.out.print":1,"System.out.println":6},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"char":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":45,"StringLiteralExpr":7,"CastExpr":1,"CharLiteralExpr":11,"FieldAccessExpr":8,"MethodCallExpr":9,"AssignExpr":1},"statements":{"SwitchStmt":1,"BreakStmt":5,"TryStmt":1,"BlockStmt":2,"SwitchEntryStmt":11,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    char c = ' ';\n    System.out.print(\"Guess my fruit by entering its first letter: \");\n    try {\n        c = (char) System.in.read();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    switch(c) {\n        case 'a':\n        case 'A':\n            System.out.println(\"Congratulations, you just won an apple!\");\n            break;\n        case 'b':\n        case 'B':\n            System.out.println(\"Congratulations, you just won a banana!\");\n            break;\n        case 'c':\n        case 'C':\n            System.out.println(\"Congratulations, you just won a cherry!\");\n            break;\n        case 'o':\n        case 'O':\n            System.out.println(\"Congratulations, you just won an orange!\");\n            break;\n        case 'p':\n        case 'P':\n            System.out.println(\"Congratulations, you just won a pear!\");\n            break;\n        default:\n            System.out.println(\"Please play again! (Hint: a, b, c, o, p)\");\n    }\n}\n","name":"main","className":"SwitchConstructApp","variables":{"c":3,"e":2},"constants":{"\"Congratulations, you just won a pear!\"":1,"\"Congratulations, you just won a banana!\"":1,"'c'":1,"'C'":1,"'b'":1,"'B'":1,"'a'":1,"'A'":1,"' '":1,"\"Congratulations, you just won a cherry!\"":1,"\"Congratulations, you just won an orange!\"":1,"\"Guess my fruit by entering its first letter: \"":1,"\"Please play again! (Hint: a, b, c, o, p)\"":1,"\"Congratulations, you just won an apple!\"":1,"'p'":1,"'P'":1,"'o'":1,"'O'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":24,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":3,"MethodCallExpr":3},"statements":{"ContinueStmt":1,"IfStmt":2,"BreakStmt":1,"BlockStmt":4,"ForStmt":2,"ExpressionStmt":5,"LabeledStmt":1},"text":"public static void main(String[] args) {\n    int n = 0;\n    System.out.println(\"List of Prime numbers\");\n    OuterLoop: for (int i = 2; ; i++) {\n        for (int j = 2; j < i; j++) {\n            if (i % j == 0) {\n                continue OuterLoop;\n            }\n        }\n        System.out.print(i + \" \");\n        n++;\n        if (n == 10) {\n            System.out.println();\n            break OuterLoop;\n        }\n    }\n}\n","name":"main","className":"LabeledBreakConstructApp","variables":{"i":5,"j":4,"n":3},"constants":{"0":2,"2":2,"\" \"":1,"\"List of Prime numbers\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":10,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    for (int i = 90; i < 100; i++) {\n        System.out.println(\"i = \" + i + \"\\tSquare = \" + i * i);\n    }\n}\n","name":"main","className":"ForLoopConstructApp","variables":{"i":6},"constants":{"100":1,"90":1,"\"\\tSquare = \"":1,"\"i = \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":10,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    int i = 90;\n    while (i < 100) {\n        System.out.println(\"i = \" + i + \"\\tSquare = \" + i * i);\n        i++;\n    }\n}\n","name":"main","className":"WhileConstructApp","variables":{"i":6},"constants":{"100":1,"90":1,"\"\\tSquare = \"":1,"\"i = \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":1,"toLowerCase":1,"readLine":1,"System.out.print":1,"System.out.println":6},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":50,"StringLiteralExpr":12,"FieldAccessExpr":8,"MethodCallExpr":10,"AssignExpr":2},"statements":{"SwitchStmt":1,"BreakStmt":5,"TryStmt":1,"BlockStmt":2,"SwitchEntryStmt":6,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    String strInput = null;\n    System.out.print(\"Guess my fruit by entering its first letter: \");\n    try {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        strInput = reader.readLine();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    strInput = strInput.toLowerCase();\n    switch(strInput) {\n        case \"a\":\n            System.out.println(\"Congratulations, you just won an apple!\");\n            break;\n        case \"b\":\n            System.out.println(\"Congratulations, you just won a banana!\");\n            break;\n        case \"c\":\n            System.out.println(\"Congratulations, you just won a cherry!\");\n            break;\n        case \"o\":\n            System.out.println(\"Congratulations, you just won an orange!\");\n            break;\n        case \"p\":\n            System.out.println(\"Congratulations, you just won a pear!\");\n            break;\n        default:\n            System.out.println(\"Please play again! (Hint: a, b, c, o, p)\");\n    }\n}\n","name":"main","className":"SwitchUsingStringsApp","variables":{"strInput":5,"e":2,"reader":2},"constants":{"\"c\"":1,"\"Congratulations, you just won a pear!\"":1,"\"b\"":1,"\"a\"":1,"\"Congratulations, you just won a banana!\"":1,"\"Congratulations, you just won a cherry!\"":1,"\"Congratulations, you just won an orange!\"":1,"\"Guess my fruit by entering its first letter: \"":1,"null":1,"\"p\"":1,"\"o\"":1,"\"Please play again! (Hint: a, b, c, o, p)\"":1,"\"Congratulations, you just won an apple!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":6,"CastExpr":1,"NameExpr":17,"StringLiteralExpr":3,"FieldAccessExpr":2,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"WhileStmt":1,"BreakStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    int count = 0;\n    while (true) {\n        int number = (int) (Math.random() * 100);\n        count++;\n        System.out.print(number + \" \");\n        if (number == 0) {\n            System.out.println(\"\\nThis time, there were \" + (count - 1) + \" random numbers generated before 0 was generated\");\n            break;\n        }\n    }\n}\n","name":"main","className":"BreakConstructApp","variables":{"number":3,"count":3,"Math":1},"constants":{"0":2,"100":1,"1":1,"\" \"":1,"\"\\nThis time, there were \"":1,"\" random numbers generated before 0 was generated\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":4,"CastExpr":1,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ContinueStmt":1,"IfStmt":1,"WhileStmt":1,"BreakStmt":1,"BlockStmt":3,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int count = 0;\n    while (true) {\n        int number = (int) (Math.random() * 100);\n        count++;\n        if (number != 9) {\n            continue;\n        } else {\n            System.out.println(\"\\nNumber 9 found after \" + count + \" iterations\");\n            break;\n        }\n    }\n}\n","name":"main","className":"ContinueConstructApp","variables":{"number":2,"count":3,"Math":1},"constants":{"0":1,"100":1,"\"\\nNumber 9 found after \"":1,"true":1,"9":1,"\" iterations\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":1,"System.in.read":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"char":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":6,"NameExpr":28,"StringLiteralExpr":3,"CastExpr":1,"CharLiteralExpr":5,"FieldAccessExpr":4,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    char c = ' ';\n    System.out.print(\"Guess my fruit by entering its first letter: \");\n    try {\n        c = (char) System.in.read();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    if (c == 'a' || c == 'A') {\n        System.out.println(\"Congratulations, you just won an apple!\");\n    }\n    if (c != 'a' && c != 'A') {\n        System.out.println(\"Please play again! (Hint: My fruit is green)\");\n    }\n}\n","name":"main","className":"IfConditionApp","variables":{"c":6,"e":2},"constants":{"\"Guess my fruit by entering its first letter: \"":1,"\"Congratulations, you just won an apple!\"":1,"'a'":2,"'A'":2,"\"Please play again! (Hint: My fruit is green)\"":1,"' '":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":1,"System.in.read":3,"System.out.println":5},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"char":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":47,"StringLiteralExpr":6,"CastExpr":1,"FieldAccessExpr":8,"CharLiteralExpr":8,"EnclosedExpr":2,"MethodCallExpr":9,"AssignExpr":1},"statements":{"SwitchStmt":1,"BreakStmt":3,"TryStmt":1,"BlockStmt":3,"SwitchEntryStmt":7,"ExpressionStmt":10,"DoStmt":1},"text":"public static void main(String[] args) {\n    char c;\n    try {\n        do {\n            System.out.println(\"Enter your choice (A for Apple, \" + \"B for Banana, C for Cherry, Q to quit): \");\n            c = (char) System.in.read();\n            switch(c) {\n                case 'a':\n                case 'A':\n                    System.out.println(\"Okay, have your apple\");\n                    break;\n                case 'b':\n                case 'B':\n                    System.out.println(\"Okay, have your banana\");\n                    break;\n                case 'c':\n                case 'C':\n                    System.out.println(\"Okay, have your cherry\");\n                    break;\n                default:\n                    System.out.println(\"You did not select the fruit\");\n            }\n            System.in.read();\n            System.in.read();\n        } while ((c != 'q') && (c != 'Q'));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"main","className":"DoWhileConstructApp","variables":{"c":5,"e":2},"constants":{"\"Enter your choice (A for Apple, \"":1,"\"Okay, have your apple\"":1,"\"Okay, have your cherry\"":1,"'c'":1,"'C'":1,"'b'":1,"'B'":1,"'a'":1,"'A'":1,"\"B for Banana, C for Cherry, Q to quit): \"":1,"\"You did not select the fruit\"":1,"'q'":1,"'Q'":1,"\"Okay, have your banana\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    new BucketBallGame().doTransfers();\n}\n","name":"main","className":"BucketBallGame","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":8,"UnaryExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"private void doTransfers() {\n    for (int i = 0; i < 10; i++) {\n        new Thread(new TransferThread(!RIGHT_TO_LEFT)).start();\n        new Thread(new TransferThread(RIGHT_TO_LEFT)).start();\n    }\n}\n","name":"doTransfers","className":"BucketBallGame","variables":{"i":3,"RIGHT_TO_LEFT":2},"constants":{"0":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["boolean","int"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":6,"ArrayAccessExpr":6,"BinaryExpr":3,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public void transfer(boolean direction, int numToTransfer) {\n    if (direction == RIGHT_TO_LEFT) {\n        bucket[0] += numToTransfer;\n        bucket[1] -= numToTransfer;\n    } else {\n        bucket[0] -= numToTransfer;\n        bucket[1] += numToTransfer;\n    }\n    System.out.println(\"Total: \" + (bucket[0] + bucket[1]));\n}\n","name":"transfer","className":"BucketBallGame","variables":{"bucket":6,"numToTransfer":4,"RIGHT_TO_LEFT":1,"direction":1},"constants":{"0":3,"1":3,"\"Total: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean"],"returnType":"TransferThread","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public TransferThread(boolean direction) {\n    this.direction = direction;\n}\n","name":"TransferThread","className":"TransferThread","variables":{"direction":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"random":2,"transfer":1},"annotations":["Override"],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":14,"CastExpr":2,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"@Override\npublic void run() {\n    for (int i = 0; i < 100; i++) {\n        transfer(direction, (int) (Math.random() * 2000));\n        try {\n            Thread.sleep((int) (Math.random() * 100));\n        } catch (InterruptedException ex) {\n        }\n    }\n}\n","name":"run","className":"TransferThread","variables":{"ex":1,"i":3,"Math":2,"Thread":1},"constants":{"0":1,"100":2,"2000":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Bucket":1},"expressions":{"ObjectCreationExpr":5,"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String args[]) {\n    Bucket bucket = new Bucket();\n    new Thread(new Producer(bucket)).start();\n    new Thread(new Consumer(bucket)).start();\n}\n","name":"main","className":"ProducerConsumerGame","variables":{"bucket":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Bucket"],"returnType":"Consumer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Consumer(Bucket bucket) {\n    this.bucket = bucket;\n}\n","name":"Consumer","className":"Consumer","variables":{"bucket":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":5,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"public void run() {\n    for (int i = 0; i < 10; i++) {\n        bucket.get();\n    }\n}\n","name":"run","className":"Consumer","variables":{"bucket":1,"i":3},"constants":{"0":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Bucket"],"returnType":"Producer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Producer(Bucket bucket) {\n    this.bucket = bucket;\n}\n","name":"Producer","className":"Producer","variables":{"bucket":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"random":1,"put":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":8,"CastExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"public void run() {\n    for (int i = 0; i < 10; i++) {\n        bucket.put((int) (Math.random() * 100));\n    }\n}\n","name":"run","className":"Producer","variables":{"bucket":1,"i":3,"Math":1},"constants":{"0":1,"100":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"wait":1,"notify":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling","Synchronization"],"types":{},"expressions":{"BinaryExpr":2,"BooleanLiteralExpr":2,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public synchronized int get() {\n    if (available == false) {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n        }\n    }\n    System.out.println(\"Consumer Got: \" + packOfBalls);\n    available = false;\n    notify();\n    return packOfBalls;\n}\n","name":"get","className":"Bucket","variables":{"e":1,"packOfBalls":2,"available":2},"constants":{"false":2,"\"Consumer Got: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"wait":1,"notify":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling","Synchronization"],"types":{},"expressions":{"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":15,"StringLiteralExpr":1,"FieldAccessExpr":2,"ThisExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":5},"text":"public synchronized void put(int packOfBalls) {\n    if (available) {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n        }\n    }\n    this.packOfBalls = packOfBalls;\n    available = true;\n    System.out.println(\"Producer Put: \" + packOfBalls);\n    notify();\n}\n","name":"put","className":"Bucket","variables":{"e":1,"packOfBalls":2,"available":2},"constants":{"\"Producer Put: \"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":[],"returnType":"SineWaveAnimator","methodCalls":{"setVisible":1,"setSize":1,"setTitle":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BooleanLiteralExpr":1,"NameExpr":9,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public SineWaveAnimator() {\n    setTitle(\"Sine Wave Animator\");\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    setSize(500, 200);\n    setVisible(true);\n}\n","name":"SineWaveAnimator","className":"SineWaveAnimator","variables":{},"constants":{"200":1,"\"Sine Wave Animator\"":1,"500":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setDaemon":1,"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"SineWaveAnimator":1,"Thread":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    SineWaveAnimator app = new SineWaveAnimator();\n    Thread animator = new Thread(app);\n    animator.setDaemon(true);\n    animator.start();\n}\n","name":"main","className":"SineWaveAnimator","variables":{"app":2,"animator":3},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"repaint":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":3},"text":"public void run() {\n    while (true) {\n        repaint();\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n        }\n        frame++;\n    }\n}\n","name":"run","className":"SineWaveAnimator","variables":{"e":1,"Thread":1,"frame":1},"constants":{"100":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"sin":2,"drawLine":1,"getBounds":1,"clearRect":1},"annotations":["Override"],"exceptions":[],"concepts":["Casting"],"types":{"Rectangle":1,"int":4},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"DoubleLiteralExpr":4,"BinaryExpr":10,"NameExpr":38,"CastExpr":2,"FieldAccessExpr":4,"EnclosedExpr":6,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"@Override\npublic void paint(Graphics g) {\n    Rectangle d = getBounds();\n    g.clearRect(0, 0, d.width, d.height);\n    int h = d.height / 2;\n    for (int x = 0; x < d.width; x++) {\n        int y1 = (int) ((1.0 + Math.sin((x - frame) * 0.09)) * h);\n        int y2 = (int) ((1.0 + Math.sin((x + frame) * 0.01)) * h);\n        g.drawLine(x, y1, x, y2);\n    }\n}\n","name":"paint","className":"SineWaveAnimator","variables":{"d":1,"g":2,"h":3,"x":5,"y1":1,"y2":1,"Math":2,"frame":2},"constants":{"0":3,"0.09":1,"2":1,"1.0":2,"0.01":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sleep":1,"setDaemon":1,"start":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"Thread":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    Thread primeNumberGenerator = new Thread(new WorkerThread());\n    primeNumberGenerator.setDaemon(true);\n    primeNumberGenerator.start();\n    try {\n        Thread.sleep(10);\n    } catch (InterruptedException e) {\n    }\n}\n","name":"main","className":"PrimeNumberGenerator","variables":{"e":1,"primeNumberGenerator":3,"Thread":1},"constants":{"true":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":5,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BreakStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":5},"text":"public void run() {\n    long i = 1;\n    while (true) {\n        long j;\n        for (j = 2; j < i; j++) {\n            long n = i % j;\n            if (n == 0) {\n                break;\n            }\n        }\n        if (i == j) {\n            System.out.print(\" \" + i);\n        }\n        i++;\n    }\n}\n","name":"run","className":"WorkerThread","variables":{"i":6,"j":6,"n":2},"constants":{"0":1,"1":1,"2":1,"\" \"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sleep":1,"read":1,"printStackTrace":1,"isInterrupted":1,"start":2,"interrupt":2,"System.out.println":3},"annotations":[],"exceptions":["IOException","InterruptedException"],"concepts":["ExceptionHandling"],"types":{"InputStreamReader":1,"Thread":2},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":42,"StringLiteralExpr":5,"FieldAccessExpr":4,"CharLiteralExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":2,"BlockStmt":7,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    Thread primeNumberGenerator = new Thread(new WorkerThread());\n    primeNumberGenerator.start();\n    InputStreamReader in = new InputStreamReader(System.in);\n    try {\n        while (in.read() != '\\n') {\n        }\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n    primeNumberGenerator.interrupt();\n    // }\n    if (primeNumberGenerator.isInterrupted()) {\n        System.out.println(\"\\nNumber generation has \" + \"already been interrupted\");\n    } else {\n        System.out.println(\"Number generator \" + \"is not currently running\");\n    }\n // uncomment the following lines to introduce a delay\n\n // before checking the interrupt status\n\n // try {\n\n // Thread.sleep(100);\n\n // } catch (InterruptedException ex) {\n\n    Thread lazyWorker = new Thread(new LazyWorker());\n    lazyWorker.start();\n    System.out.println(\"\\nRunning lazy worker\");\n    try {\n        Thread.sleep(100);\n    } catch (InterruptedException ex) {\n    }\n    lazyWorker.interrupt();\n}\n","name":"main","className":"ControlledPrimeNumberGenerator","variables":{"lazyWorker":3,"ex":3,"in":2,"primeNumberGenerator":4,"Thread":1},"constants":{"\"already been interrupted\"":1,"100":1,"\"\\nRunning lazy worker\"":1,"\"\\nNumber generation has \"":1,"'\\n'":1,"\"Number generator \"":1,"\"is not currently running\"":1},"javaDoc":"","comments":"uncomment the following lines to introduce a delay before checking the interrupt status try { Thread sleep(100); } catch (InterruptedException ex) { } ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"interrupted":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"long":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":6,"NameExpr":24,"StringLiteralExpr":3,"FieldAccessExpr":2,"UnaryExpr":2,"AssignExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":3,"WhileStmt":1,"BreakStmt":1,"BlockStmt":5,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"public void run() {\n    long i = 1;\n    while (true) {\n        long j;\n        for (j = 2; j < i; j++) {\n            long n = i % j;\n            if (n == 0) {\n                break;\n            }\n        }\n        if (i == j) {\n            System.out.print(\" \" + i);\n        }\n        i++;\n        if (Thread.interrupted()) {\n            System.out.println(\"\\nStopping prime \" + \"number generator\");\n            return;\n        }\n    }\n}\n","name":"run","className":"WorkerThread","variables":{"i":6,"j":6,"n":2,"Thread":1},"constants":{"0":1,"1":1,"2":1,"\"number generator\"":1,"\" \"":1,"\"\\nStopping prime \"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"toString":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"public void run() {\n    try {\n        Thread.sleep(100000);\n    } catch (InterruptedException ex) {\n        System.out.println(\"Lazy worker: \" + ex.toString());\n    }\n}\n","name":"run","className":"LazyWorker","variables":{"ex":2,"Thread":1},"constants":{"100000":1,"\"Lazy worker: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":18,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void innerMethod() {\n    System.out.println(\"Formal parameter (B): \" + b);\n    System.out.println(\"Outer Class variable (A): \" + a);\n    System.out.println(\"Inner Class variable (C): \" + c);\n}\n","name":"innerMethod","className":"Inner","variables":{"a":1,"b":1,"c":1},"constants":{"\"Formal parameter (B): \"":1,"\"Inner Class variable (C): \"":1,"\"Outer Class variable (A): \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["InnerMethod","InnerClass"],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":3,"NameExpr":24,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"TypeDeclarationStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"public void someMethod(final int b) {\n    class Inner {\n\n        int c = 30;\n\n        public void innerMethod() {\n            System.out.println(\"Formal parameter (B): \" + b);\n            System.out.println(\"Outer Class variable (A): \" + a);\n            System.out.println(\"Inner Class variable (C): \" + c);\n        }\n    }\n    new Inner().innerMethod();\n}\n","name":"someMethod","className":"Outer","variables":{"a":1,"b":1,"c":2,"innerMethod":1,"Inner":1},"constants":{"\"Formal parameter (B): \"":1,"\"Inner Class variable (C): \"":1,"\"Outer Class variable (A): \"":1,"30":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"someMethod":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Outer":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Outer outer = new Outer();\n    outer.someMethod(10);\n}\n","name":"main","className":"InnerClassWithinMethodExample","variables":{"outer":2},"constants":{"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["File","String"],"returnType":"boolean","methodCalls":{"endsWith":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean accept(File folder, String fileName) {\n    return fileName.endsWith(\".txt\");\n}\n","name":"accept","className":"","variables":{"fileName":1},"constants":{"\".txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"endsWith":1,"list":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"String[]":1,"File":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":21,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":2,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    File folder = new File(args[0]);\n    String[] list = folder.list(new FilenameFilter() {\n\n        public boolean accept(File folder, String fileName) {\n            return fileName.endsWith(\".txt\");\n        }\n    });\n    for (int i = 0; i < list.length; i++) {\n        System.out.println(list[i]);\n    }\n}\n","name":"main","className":"FileNameFilterExample","variables":{"args":1,"fileName":2,"folder":3,"i":4,"list":2,"accept":1},"constants":{"0":2,"\".txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":5,"ThisExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void someMethod(int size) {\n    System.out.println(\"Method parameter (size): \" + size);\n    System.out.println(\"Inner size: \" + this.size);\n    System.out.println(\"Outer size: \" + Outer.this.size);\n}\n","name":"someMethod","className":"Inner","variables":{"size":1,"Outer":1},"constants":{"\"Method parameter (size): \"":1,"\"Outer size: \"":1,"\"Inner size: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"someMethod":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Outer.Inner":1,"Outer":1,"Inner":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    Outer outer = new Outer();\n    Outer.Inner inner = outer.new Inner();\n    inner.someMethod(5);\n}\n","name":"main","className":"ShadowedVariableExample","variables":{"outer":2,"inner":2},"constants":{"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1,"UnaryExpr":1},"statements":{"ExpressionStmt":1},"text":"public void someMethod() {\n    counter++;\n}\n","name":"someMethod","className":"Inner","variables":{"counter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getCount() {\n    return counter;\n}\n","name":"getCount","className":"Outer","variables":{"counter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getCount":2,"someMethod":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Outer.Inner":1,"Outer":1,"Inner":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":23,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    Outer outer = new Outer();\n    Outer.Inner inner = outer.new Inner();\n    inner.someMethod();\n    System.out.println(\"Counter: \" + outer.getCount());\n    inner.someMethod();\n    System.out.println(\"Counter: \" + outer.getCount());\n}\n","name":"main","className":"InnerClassExample","variables":{"outer":4,"inner":3},"constants":{"\"Counter: \"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"DynamicOddsGenerator","methodCalls":{"random":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":9,"CastExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"public DynamicOddsGenerator() {\n    for (int i = 0; i < SIZE; i++) {\n        arrayOfInts[i] = (int) (Math.random() * SIZE);\n    }\n}\n","name":"DynamicOddsGenerator","className":"DynamicOddsGenerator","variables":{"SIZE":2,"i":4,"arrayOfInts":1,"Math":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"hasNext":1,"getNext":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"InnerOddsIterator":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public void printOdds() {\n    InnerOddsIterator iterator = this.new InnerOddsIterator();\n    while (iterator.hasNext()) {\n        int returnValue = iterator.getNext();\n        if (returnValue != -1) {\n            System.out.print(returnValue + \" \");\n        }\n    }\n    System.out.println();\n}\n","name":"printOdds","className":"DynamicOddsGenerator","variables":{"iterator":3,"returnValue":3},"constants":{"1":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean hasNext() {\n    return (next <= SIZE - 1);\n}\n","name":"hasNext","className":"InnerOddsIterator","variables":{"next":1,"SIZE":1},"constants":{"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":4,"UnaryExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"public int getNext() {\n    int retValue = arrayOfInts[next++];\n    if (retValue % 2 == 1) {\n        return retValue;\n    }\n    return -1;\n}\n","name":"getNext","className":"InnerOddsIterator","variables":{"next":1,"retValue":3,"arrayOfInts":1},"constants":{"1":2,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printOdds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"DynamicOddsGenerator":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String s[]) {\n    DynamicOddsGenerator numbers = new DynamicOddsGenerator();\n    numbers.printOdds();\n}\n","name":"main","className":"DynamicOddsGenerator","variables":{"numbers":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public float getMilesPerGallon();\n","name":"getMilesPerGallon","className":"MileageEfficiency","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getMilesPerGallon() {\n    return tripCounter / fuelConsumed;\n}\n","name":"getMilesPerGallon","className":"GasVehicle","variables":{"fuelConsumed":1,"tripCounter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public void makeTrip() {\n    tripCounter = 100;\n    fuelConsumed = 8.5f;\n}\n","name":"makeTrip","className":"GasVehicle","variables":{"fuelConsumed":1,"tripCounter":1},"constants":{"100":1,"8.5f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getMilesPerGallon() {\n    return tripCounter / kwPowerConsumed;\n}\n","name":"getMilesPerGallon","className":"ElectricVehicle","variables":{"kwPowerConsumed":1,"tripCounter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public void makeTrip() {\n    tripCounter = 100;\n    kwPowerConsumed = 5.6f;\n}\n","name":"makeTrip","className":"ElectricVehicle","variables":{"kwPowerConsumed":1,"tripCounter":1},"constants":{"100":1,"5.6f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getMilesPerGallon":2,"System.out.printf":2,"makeTrip":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"GasVehicle":1,"ElectricVehicle":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":22,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    GasVehicle gasolineVehicle = new GasVehicle();\n    gasolineVehicle.makeTrip();\n    System.out.printf(\"Efficiency of Gas Vehicle (miles/gallon): %.02f%n\", gasolineVehicle.getMilesPerGallon());\n    ElectricVehicle electricVehicle = new ElectricVehicle();\n    electricVehicle.makeTrip();\n    System.out.printf(\"Efficiency of Electric Vehicle (miles/kw): %.02f%n\", electricVehicle.getMilesPerGallon());\n}\n","name":"main","className":"TestDrive","variables":{"electricVehicle":3,"gasolineVehicle":3},"constants":{"\"Efficiency of Electric Vehicle (miles/kw): %.02f%n\"":1,"\"Efficiency of Gas Vehicle (miles/gallon): %.02f%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public static int getCount() {\n    return count;\n}\n","name":"getCount","className":"Ball","variables":{"count":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Ball","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1,"UnaryExpr":1},"statements":{"ExpressionStmt":1},"text":"public Ball() {\n    count++;\n}\n","name":"Ball","className":"Ball","variables":{"count":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":1,"getCount":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":14,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    for (int i = 0; i < 10000; i++) {\n        int number = (int) (Math.random() * 10);\n        if (number == 5) {\n            new Ball();\n        }\n    }\n    System.out.println(\"No of balls created: \" + Ball.getCount());\n}\n","name":"main","className":"BallGame","variables":{"Ball":1,"number":2,"i":3,"Math":1},"constants":{"0":1,"5":1,"10000":1,"\"No of balls created: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public float getMilesPerGallon();\n","name":"getMilesPerGallon","className":"MileageEfficiency","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public float getFuelEfficiency();\n","name":"getFuelEfficiency","className":"ExtendedMileageEfficiency","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public float getElectricEfficiency();\n","name":"getElectricEfficiency","className":"ExtendedMileageEfficiency","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getMilesPerGallon() {\n    return tripCounter / fuelConsumed;\n}\n","name":"getMilesPerGallon","className":"GasVehicle","variables":{"fuelConsumed":1,"tripCounter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public void makeTrip() {\n    tripCounter = 100;\n    fuelConsumed = 8.5f;\n}\n","name":"makeTrip","className":"GasVehicle","variables":{"fuelConsumed":1,"tripCounter":1},"constants":{"100":1,"8.5f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getMilesPerGallon() {\n    return tripCounter / kwPowerConsumed;\n}\n","name":"getMilesPerGallon","className":"ElectricVehicle","variables":{"kwPowerConsumed":1,"tripCounter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public void makeTrip() {\n    tripCounter = 100;\n    kwPowerConsumed = 5.6f;\n}\n","name":"makeTrip","className":"ElectricVehicle","variables":{"kwPowerConsumed":1,"tripCounter":1},"constants":{"100":1,"5.6f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getFuelEfficiency() {\n    return tripCounter / fuelConsumed;\n}\n","name":"getFuelEfficiency","className":"HybridVehicle","variables":{"fuelConsumed":1,"tripCounter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getElectricEfficiency() {\n    return tripCounter / kwPowerConsumed;\n}\n","name":"getElectricEfficiency","className":"HybridVehicle","variables":{"kwPowerConsumed":1,"tripCounter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{"getElectricEfficiency":1,"getFuelEfficiency":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":2,"BinaryExpr":3,"NameExpr":4,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public float getMilesPerGallon() {\n    return 0.8f * getFuelEfficiency() + 1.12f % getElectricEfficiency();\n}\n","name":"getMilesPerGallon","className":"HybridVehicle","variables":{},"constants":{"1.12f":1,"0.8f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":2,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public void makeTrip() {\n    tripCounter = 100;\n    fuelConsumed = 4.1f;\n    kwPowerConsumed = 3.4f;\n}\n","name":"makeTrip","className":"HybridVehicle","variables":{"fuelConsumed":1,"kwPowerConsumed":1,"tripCounter":1},"constants":{"100":1,"4.1f":1,"3.4f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getMilesPerGallon":3,"System.out.printf":3,"makeTrip":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"HybridVehicle":1,"GasVehicle":1,"ElectricVehicle":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":33,"StringLiteralExpr":4,"FieldAccessExpr":3,"MethodCallExpr":9},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    GasVehicle gasolineVehicle = new GasVehicle();\n    gasolineVehicle.makeTrip();\n    System.out.printf(\"Efficiency of Gas Vehicle (miles/gallon): %.02f%n\", gasolineVehicle.getMilesPerGallon());\n    ElectricVehicle electricVehicle = new ElectricVehicle();\n    electricVehicle.makeTrip();\n    System.out.printf(\"Efficiency of Electric Vehicle (miles/kw): %.02f%n\", electricVehicle.getMilesPerGallon());\n    HybridVehicle hybridVehicle = new HybridVehicle();\n    hybridVehicle.makeTrip();\n    System.out.printf(\"Efficiency of hybrid Vehicle \" + \"(miles/EnergyConsumed): %.02f%n\", hybridVehicle.getMilesPerGallon());\n}\n","name":"main","className":"EnhancedTestDrive","variables":{"electricVehicle":3,"hybridVehicle":3,"gasolineVehicle":3},"constants":{"\"Efficiency of Electric Vehicle (miles/kw): %.02f%n\"":1,"\"Efficiency of hybrid Vehicle \"":1,"\"(miles/EnergyConsumed): %.02f%n\"":1,"\"Efficiency of Gas Vehicle (miles/gallon): %.02f%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public float getMilesPerGallon();\n","name":"getMilesPerGallon","className":"MileageEfficiency","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public float getFuelEfficiency();\n","name":"getFuelEfficiency","className":"ExtendedMileageEfficiency","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public float getElectricEfficiency();\n","name":"getElectricEfficiency","className":"ExtendedMileageEfficiency","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void chargeBattery();\n","name":"chargeBattery","className":"BatteryLifeTracker","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public int getRemainingLife();\n","name":"getRemainingLife","className":"BatteryLifeTracker","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getMilesPerGallon() {\n    return tripCounter / fuelConsumed;\n}\n","name":"getMilesPerGallon","className":"GasVehicle","variables":{"fuelConsumed":1,"tripCounter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public void makeTrip() {\n    tripCounter = 100;\n    fuelConsumed = 8.5f;\n}\n","name":"makeTrip","className":"GasVehicle","variables":{"fuelConsumed":1,"tripCounter":1},"constants":{"100":1,"8.5f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getMilesPerGallon() {\n    return tripCounter / kwPowerConsumed;\n}\n","name":"getMilesPerGallon","className":"ElectricVehicle","variables":{"kwPowerConsumed":1,"tripCounter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public void makeTrip() {\n    tripCounter = 100;\n    kwPowerConsumed = 5.6f;\n}\n","name":"makeTrip","className":"ElectricVehicle","variables":{"kwPowerConsumed":1,"tripCounter":1},"constants":{"100":1,"5.6f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1,"UnaryExpr":1},"statements":{"ExpressionStmt":1},"text":"public void chargeBattery() {\n    numberOfRecharges++;\n}\n","name":"chargeBattery","className":"ElectricVehicle","variables":{"numberOfRecharges":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public int getRemainingLife() {\n    return MAX_NUMBER_OF_RECHARGES - numberOfRecharges;\n}\n","name":"getRemainingLife","className":"ElectricVehicle","variables":{"MAX_NUMBER_OF_RECHARGES":1,"numberOfRecharges":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getFuelEfficiency() {\n    return tripCounter / fuelConsumed;\n}\n","name":"getFuelEfficiency","className":"HybridVehicle","variables":{"fuelConsumed":1,"tripCounter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getElectricEfficiency() {\n    return tripCounter / kWPowerConsumed;\n}\n","name":"getElectricEfficiency","className":"HybridVehicle","variables":{"kWPowerConsumed":1,"tripCounter":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{"getElectricEfficiency":1,"getFuelEfficiency":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":2,"BinaryExpr":3,"NameExpr":4,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public float getMilesPerGallon() {\n    return 0.8f * getFuelEfficiency() + 1.12f % getElectricEfficiency();\n}\n","name":"getMilesPerGallon","className":"HybridVehicle","variables":{},"constants":{"1.12f":1,"0.8f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":2,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public void makeTrip() {\n    tripCounter = 100;\n    fuelConsumed = 4.1f;\n    kWPowerConsumed = 3.4f;\n}\n","name":"makeTrip","className":"HybridVehicle","variables":{"kWPowerConsumed":1,"fuelConsumed":1,"tripCounter":1},"constants":{"100":1,"4.1f":1,"3.4f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1,"UnaryExpr":1},"statements":{"ExpressionStmt":1},"text":"public void chargeBattery() {\n    noOfRecharges++;\n}\n","name":"chargeBattery","className":"HybridVehicle","variables":{"noOfRecharges":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public int getRemainingLife() {\n    return MAX_NUMBER_OF_RECHARGES - noOfRecharges;\n}\n","name":"getRemainingLife","className":"HybridVehicle","variables":{"MAX_NUMBER_OF_RECHARGES":1,"noOfRecharges":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getMilesPerGallon":3,"getRemainingLife":2,"chargeBattery":2,"System.out.printf":5,"makeTrip":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"HybridVehicle":1,"GasVehicle":1,"int":2,"ElectricVehicle":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"BinaryExpr":3,"NameExpr":59,"StringLiteralExpr":6,"FieldAccessExpr":5,"UnaryExpr":2,"MethodCallExpr":15},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    GasVehicle gasolineVehicle = new GasVehicle();\n    gasolineVehicle.makeTrip();\n    System.out.printf(\"Efficiency of Gas Vehicle (miles/gallon): %.02f%n\", gasolineVehicle.getMilesPerGallon());\n    ElectricVehicle electricVehicle = new ElectricVehicle();\n    electricVehicle.makeTrip();\n    System.out.printf(\"%nEfficiency of Electric Vehicle (miles/kw): %.02f%n\", electricVehicle.getMilesPerGallon());\n    for (int i = 0; i < 78; i++) {\n        electricVehicle.chargeBattery();\n    }\n    System.out.printf(\"The battery can be charged %d more times%n\", electricVehicle.getRemainingLife());\n    HybridVehicle hybridVehicle = new HybridVehicle();\n    hybridVehicle.makeTrip();\n    System.out.printf(\"%nEfficiency of hybrid Vehicle \" + \"(miles/EnergyConsumed): %.02f%n\", hybridVehicle.getMilesPerGallon());\n    for (int i = 0; i < 15; i++) {\n        hybridVehicle.chargeBattery();\n    }\n    System.out.printf(\"The battery can be charged %d more times%n\", hybridVehicle.getRemainingLife());\n}\n","name":"main","className":"FurtherEnhancedTestDrive","variables":{"electricVehicle":5,"hybridVehicle":5,"i":6,"gasolineVehicle":3},"constants":{"0":2,"\"%nEfficiency of hybrid Vehicle \"":1,"78":1,"15":1,"\"(miles/EnergyConsumed): %.02f%n\"":1,"\"The battery can be charged %d more times%n\"":2,"\"%nEfficiency of Electric Vehicle (miles/kw): %.02f%n\"":1,"\"Efficiency of Gas Vehicle (miles/gallon): %.02f%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public static void staticMethod() {\n// do something\n}\n","name":"staticMethod","className":"StaticMemberTestApp","variables":{},"constants":{},"javaDoc":"","comments":"do something ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void nonStaticMethod() {\n// do something else\n}\n","name":"nonStaticMethod","className":"StaticMemberTestApp","variables":{},"constants":{},"javaDoc":"","comments":"do something else ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nonStaticMethod":1,"staticMethod":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":6,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    i = 5;\n    // this does not compile\n    j = 10;\n    staticMethod();\n    // this does not compile\n    nonStaticMethod();\n}\n","name":"main","className":"StaticMemberTestApp","variables":{"i":1,"j":1},"constants":{"5":1,"10":1},"javaDoc":"","comments":"this does not compile this does not compile ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public static int getRedBallCount() {\n    return redBallCount;\n}\n","name":"getRedBallCount","className":"Ball","variables":{"redBallCount":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public static int getGreenBallCount() {\n    return greenBallCount;\n}\n","name":"getGreenBallCount","className":"Ball","variables":{"greenBallCount":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public static int getRadius() {\n    return radius;\n}\n","name":"getRadius","className":"Ball","variables":{"radius":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void setRadius(int radius) {\n    Ball.radius = radius;\n}\n","name":"setRadius","className":"Ball","variables":{"radius":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Color"],"returnType":"Ball","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":17,"FieldAccessExpr":5,"UnaryExpr":3,"ThisExpr":2,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public Ball(Color color) {\n    count++;\n    if (color == Color.RED) {\n        this.defaultColor = Color.RED;\n        redBallCount++;\n    } else {\n        this.defaultColor = Color.GREEN;\n        greenBallCount++;\n    }\n}\n","name":"Ball","className":"Ball","variables":{"redBallCount":1,"color":1,"greenBallCount":1,"count":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"System.out.printf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":14,"StringLiteralExpr":3,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public void setVelocity(double v) {\n    String strColor = null;\n    if (defaultColor == Color.RED) {\n        strColor = \"Red\";\n    } else {\n        strColor = \"Green\";\n    }\n    System.out.printf(\"Ball #%d:%-10s velocity set to %.02f%n\", count, strColor, v);\n}\n","name":"setVelocity","className":"Ball","variables":{"defaultColor":1,"strColor":3},"constants":{"\"Green\"":1,"null":1,"\"Red\"":1,"\"Ball #%d:%-10s velocity set to %.02f%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getGreenBallCount":1,"random":5,"getRedBallCount":1,"System.out.printf":1,"getRadius":1,"setRadius":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":4},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":10,"CastExpr":3,"NameExpr":58,"StringLiteralExpr":3,"FieldAccessExpr":5,"EnclosedExpr":3,"UnaryExpr":1,"MethodCallExpr":14},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    int numberOfBalls = (int) (Math.random() * 10);\n    int radius = (int) (Math.random() * 20) + 1;\n    Ball.setRadius(radius);\n    System.out.printf(\"Creating %d balls of radius %d%n\", numberOfBalls, Ball.getRadius());\n    for (int i = 0; i < numberOfBalls; i++) {\n        int number = (int) (Math.random() * 2);\n        if (number == 0) {\n            new Ball(Color.RED).setVelocity(Math.random() * 10);\n        } else {\n            new Ball(Color.GREEN).setVelocity(Math.random() * 10);\n        }\n    }\n    System.out.println(\"Number of red balls created: \" + Ball.getRedBallCount());\n    System.out.println(\"Number of green balls created: \" + Ball.getGreenBallCount());\n}\n","name":"main","className":"EnhancedBallGame","variables":{"Ball":4,"number":2,"i":3,"Math":5,"radius":1,"numberOfBalls":2},"constants":{"0":2,"1":1,"2":1,"\"Creating %d balls of radius %d%n\"":1,"\"Number of green balls created: \"":1,"\"Number of red balls created: \"":1,"20":1,"10":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getId() {\n    return id;\n}\n","name":"getId","className":"Asset","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setId(int id) {\n    this.id = id;\n}\n","name":"setId","className":"Asset","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getType() {\n    return type;\n}\n","name":"getType","className":"Asset","variables":{"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setType(String type) {\n    this.type = type;\n}\n","name":"setType","className":"Asset","variables":{"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":12,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void printDescription() {\n    System.out.println(\"Asset ID: \" + id);\n    System.out.println(\"Asset type: \" + type);\n}\n","name":"printDescription","className":"Asset","variables":{"id":1,"type":1},"constants":{"\"Asset ID: \"":1,"\"Asset type: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getAccountNumber() {\n    return accountNumber;\n}\n","name":"getAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setAccountNumber(int accountNumber) {\n    this.accountNumber = accountNumber;\n}\n","name":"setAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public float getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setBalance(float balance) {\n    this.balance = balance;\n}\n","name":"setBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getBankName() {\n    return bankName;\n}\n","name":"getBankName","className":"BankAccount","variables":{"bankName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setBankName(String bankName) {\n    this.bankName = bankName;\n}\n","name":"setBankName","className":"BankAccount","variables":{"bankName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void printDescription() {\n    super.printDescription();\n    System.out.println(\"Name: \" + bankName);\n    System.out.printf(\"Account #: %d%n\", accountNumber);\n    System.out.printf(\"Current balance: $%.02f%n\", balance);\n}\n","name":"printDescription","className":"BankAccount","variables":{"bankName":1},"constants":{"\"Account #: %d%n\"":1,"\"Current balance: $%.02f%n\"":1,"\"Name: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setInterestRate(float interestRate) {\n    this.interestRate = interestRate;\n}\n","name":"setInterestRate","className":"SavingsAccount","variables":{"interestRate":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void printDescription() {\n    System.out.println(\"A savings account\");\n    super.printDescription();\n    System.out.printf(\"Interest rate (%%): %.02f%n\", interestRate);\n}\n","name":"printDescription","className":"SavingsAccount","variables":{},"constants":{"\"A savings account\"":1,"\"Interest rate (%%): %.02f%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setOverdraftLimit(float overdraftLimit) {\n    this.overdraftLimit = overdraftLimit;\n}\n","name":"setOverdraftLimit","className":"CheckingAccount","variables":{"overdraftLimit":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void printDescription() {\n    System.out.println(\"A checking account\");\n    super.printDescription();\n    System.out.printf(\"Overdraft limit: $%.02f%n\", overdraftLimit);\n}\n","name":"printDescription","className":"CheckingAccount","variables":{},"constants":{"\"Overdraft limit: $%.02f%n\"":1,"\"A checking account\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printAllAssets":1,"createAssets":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"AssetMgmt":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    AssetMgmt manager = new AssetMgmt();\n    manager.createAssets();\n    manager.printAllAssets();\n}\n","name":"main","className":"AssetMgmt","variables":{"manager":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setAccountNumber":2,"setOverdraftLimit":1,"setId":2,"setBankName":2,"setInterestRate":1,"setType":2,"setBalance":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"DoubleLiteralExpr":4,"NameExpr":38,"StringLiteralExpr":4,"AssignExpr":2,"MethodCallExpr":12},"statements":{"ExpressionStmt":14},"text":"private void createAssets() {\n    tomSavingsAccount = new SavingsAccount();\n    tomSavingsAccount.setId(1001);\n    tomSavingsAccount.setType(\"Bank Account\");\n    tomSavingsAccount.setBankName(\"Citi bank\");\n    tomSavingsAccount.setAccountNumber(526702);\n    tomSavingsAccount.setBalance(15450.00f);\n    tomSavingsAccount.setInterestRate(3.0f);\n    iVisionBusinessAccount = new CheckingAccount();\n    iVisionBusinessAccount.setId(1002);\n    iVisionBusinessAccount.setType(\"Bank Account\");\n    iVisionBusinessAccount.setBankName(\"Bank of America\");\n    iVisionBusinessAccount.setAccountNumber(24689);\n    iVisionBusinessAccount.setBalance(678256.00f);\n    iVisionBusinessAccount.setOverdraftLimit(50000.00f);\n}\n","name":"createAssets","className":"AssetMgmt","variables":{"iVisionBusinessAccount":7,"tomSavingsAccount":7},"constants":{"15450.00f":1,"3.0f":1,"1002":1,"1001":1,"\"Bank of America\"":1,"526702":1,"24689":1,"50000.00f":1,"\"Citi bank\"":1,"\"Bank Account\"":2,"678256.00f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"printDescription":2,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":24,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"private void printAllAssets() {\n    String lineSeparator = \"-------------------\";\n    System.out.println(lineSeparator);\n    tomSavingsAccount.printDescription();\n    System.out.println(lineSeparator);\n    iVisionBusinessAccount.printDescription();\n    System.out.println(lineSeparator);\n}\n","name":"printAllAssets","className":"AssetMgmt","variables":{"iVisionBusinessAccount":1,"lineSeparator":1,"tomSavingsAccount":1},"constants":{"\"-------------------\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getId() {\n    return id;\n}\n","name":"getId","className":"Asset","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setId(int id) {\n    this.id = id;\n}\n","name":"setId","className":"Asset","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getType() {\n    return type;\n}\n","name":"getType","className":"Asset","variables":{"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setType(String type) {\n    this.type = type;\n}\n","name":"setType","className":"Asset","variables":{"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":12,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void printDescription() {\n    System.out.println(\"Asset ID: \" + id);\n    System.out.println(\"Asset type: \" + type);\n}\n","name":"printDescription","className":"Asset","variables":{"id":1,"type":1},"constants":{"\"Asset ID: \"":1,"\"Asset type: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getAccountNumber() {\n    return accountNumber;\n}\n","name":"getAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setAccountNumber(int accountNumber) {\n    this.accountNumber = accountNumber;\n}\n","name":"setAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public float getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setBalance(float balance) {\n    this.balance = balance;\n}\n","name":"setBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getBankName() {\n    return bankName;\n}\n","name":"getBankName","className":"BankAccount","variables":{"bankName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setBankName(String bankName) {\n    this.bankName = bankName;\n}\n","name":"setBankName","className":"BankAccount","variables":{"bankName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void printDescription() {\n    super.printDescription();\n    System.out.println(\"Name: \" + bankName);\n    System.out.printf(\"Account #: %d%n\", accountNumber);\n    System.out.printf(\"Current balance: $%.02f%n\", balance);\n}\n","name":"printDescription","className":"BankAccount","variables":{"bankName":1},"constants":{"\"Account #: %d%n\"":1,"\"Current balance: $%.02f%n\"":1,"\"Name: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getId() {\n    return id;\n}\n","name":"getId","className":"Asset","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setId(int id) {\n    this.id = id;\n}\n","name":"setId","className":"Asset","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getType() {\n    return type;\n}\n","name":"getType","className":"Asset","variables":{"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setType(String type) {\n    this.type = type;\n}\n","name":"setType","className":"Asset","variables":{"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":12,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void printDescription() {\n    System.out.println(\"Asset ID: \" + id);\n    System.out.println(\"Asset type: \" + type);\n}\n","name":"printDescription","className":"Asset","variables":{"id":1,"type":1},"constants":{"\"Asset ID: \"":1,"\"Asset type: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public float getNetWorth() {\n    return 0;\n}\n","name":"getNetWorth","className":"Asset","variables":{},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getAccountNumber() {\n    return accountNumber;\n}\n","name":"getAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setAccountNumber(int accountNumber) {\n    this.accountNumber = accountNumber;\n}\n","name":"setAccountNumber","className":"BankAccount","variables":{"accountNumber":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public float getBalance() {\n    return balance;\n}\n","name":"getBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setBalance(float balance) {\n    this.balance = balance;\n}\n","name":"setBalance","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getBankName() {\n    return bankName;\n}\n","name":"getBankName","className":"BankAccount","variables":{"bankName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setBankName(String bankName) {\n    this.bankName = bankName;\n}\n","name":"setBankName","className":"BankAccount","variables":{"bankName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void printDescription() {\n    super.printDescription();\n    System.out.println(\"Name: \" + bankName);\n    System.out.printf(\"Account #: %d%n\", accountNumber);\n    System.out.printf(\"Current balance: $%.02f%n\", balance);\n}\n","name":"printDescription","className":"BankAccount","variables":{"bankName":1},"constants":{"\"Account #: %d%n\"":1,"\"Current balance: $%.02f%n\"":1,"\"Name: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public float getNetWorth() {\n    return balance;\n}\n","name":"getNetWorth","className":"BankAccount","variables":{"balance":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setInterestRate(float interestRate) {\n    this.interestRate = interestRate;\n}\n","name":"setInterestRate","className":"SavingsAccount","variables":{"interestRate":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void printDescription() {\n    System.out.println(\"A savings account\");\n    super.printDescription();\n    System.out.printf(\"Interest rate (%%): %.02f%n\", interestRate);\n}\n","name":"printDescription","className":"SavingsAccount","variables":{},"constants":{"\"A savings account\"":1,"\"Interest rate (%%): %.02f%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setOverdraftLimit(float overdraftLimit) {\n    this.overdraftLimit = overdraftLimit;\n}\n","name":"setOverdraftLimit","className":"CheckingAccount","variables":{"overdraftLimit":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void printDescription() {\n    System.out.println(\"A checking account\");\n    super.printDescription();\n    System.out.printf(\"Overdraft limit: $%.02f%n\", overdraftLimit);\n}\n","name":"printDescription","className":"CheckingAccount","variables":{},"constants":{"\"Overdraft limit: $%.02f%n\"":1,"\"A checking account\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getTradeExchangeName() {\n    return tradeExchangeName;\n}\n","name":"getTradeExchangeName","className":"Security","variables":{"tradeExchangeName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setTradeExchangeName(String tradeExchangeName) {\n    this.tradeExchangeName = tradeExchangeName;\n}\n","name":"setTradeExchangeName","className":"Security","variables":{"tradeExchangeName":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void printDescription() {\n    super.printDescription();\n    System.out.println(\"Trade Exchange: \" + tradeExchangeName);\n}\n","name":"printDescription","className":"Security","variables":{"tradeExchangeName":1},"constants":{"\"Trade Exchange: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setMarketPrice(float marketPrice) {\n    this.marketPrice = marketPrice;\n}\n","name":"setMarketPrice","className":"Stock","variables":{"marketPrice":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setQuantityAtHand(int quantityAtHand) {\n    this.quantityAtHand = quantityAtHand;\n}\n","name":"setQuantityAtHand","className":"Stock","variables":{"quantityAtHand":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setSymbol(String symbol) {\n    this.symbol = symbol;\n}\n","name":"setSymbol","className":"Stock","variables":{"symbol":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":3,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":2,"NameExpr":32,"StringLiteralExpr":5,"FieldAccessExpr":5,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public void printDescription() {\n    System.out.println(\"Investment in securities\");\n    super.printDescription();\n    System.out.println(\"Stock: \" + symbol);\n    System.out.printf(\"Today's market price: $%.02f%n\", marketPrice);\n    System.out.printf(\"Quantity at Hand: %d%n\", quantityAtHand);\n    System.out.printf(\"Net worth: $%.02f%n\", marketPrice * quantityAtHand);\n}\n","name":"printDescription","className":"Stock","variables":{"symbol":1,"marketPrice":1,"quantityAtHand":1},"constants":{"\"Stock: \"":1,"\"Investment in securities\"":1,"\"Quantity at Hand: %d%n\"":1,"\"Net worth: $%.02f%n\"":1,"\"Today's market price: $%.02f%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getNetWorth() {\n    return marketPrice * quantityAtHand;\n}\n","name":"getNetWorth","className":"Stock","variables":{"marketPrice":1,"quantityAtHand":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setName(String name) {\n    this.name = name;\n}\n","name":"setName","className":"Bond","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setInvestedAmount(float investedAmount) {\n    this.investedAmount = investedAmount;\n}\n","name":"setInvestedAmount","className":"Bond","variables":{"investedAmount":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setMaturityDate(String maturityDate) {\n    this.maturityDate = maturityDate;\n}\n","name":"setMaturityDate","className":"Bond","variables":{"maturityDate":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":2,"NameExpr":25,"StringLiteralExpr":4,"FieldAccessExpr":4,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"public void printDescription() {\n    System.out.println(\"Investments in Bonds\");\n    super.printDescription();\n    System.out.println(\"Bond name: \" + name);\n    System.out.printf(\"Invested Amount: $%.02f%n\", investedAmount);\n    System.out.println(\"Maturity Date: \" + maturityDate);\n}\n","name":"printDescription","className":"Bond","variables":{"maturityDate":1,"name":1},"constants":{"\"Maturity Date: \"":1,"\"Bond name: \"":1,"\"Invested Amount: $%.02f%n\"":1,"\"Investments in Bonds\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public float getNetWorth() {\n    return investedAmount;\n}\n","name":"getNetWorth","className":"Bond","variables":{"investedAmount":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setName(String name) {\n    this.name = name;\n}\n","name":"setName","className":"RealEstate","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setBuiltUpArea(float builtUpArea) {\n    this.builtUpArea = builtUpArea;\n}\n","name":"setBuiltUpArea","className":"RealEstate","variables":{"builtUpArea":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setCurrentMarketRate(float currentMarketRate) {\n    this.currentMarketRate = currentMarketRate;\n}\n","name":"setCurrentMarketRate","className":"RealEstate","variables":{"currentMarketRate":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":3,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":2,"NameExpr":32,"StringLiteralExpr":5,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public void printDescription() {\n    System.out.println(\"Real Estate\");\n    super.printDescription();\n    System.out.println(\"Name: \" + name);\n    System.out.printf(\"Built-up Area: sq.ft. %.02f%n\", builtUpArea);\n    System.out.printf(\"Current Market Rate(per sq.ft.): $%.02f%n\", currentMarketRate);\n    System.out.printf(\"Net worth: $%.02f%n\", +builtUpArea * currentMarketRate);\n}\n","name":"printDescription","className":"RealEstate","variables":{"currentMarketRate":1,"builtUpArea":1,"name":1},"constants":{"\"Built-up Area: sq.ft. %.02f%n\"":1,"\"Current Market Rate(per sq.ft.): $%.02f%n\"":1,"\"Real Estate\"":1,"\"Name: \"":1,"\"Net worth: $%.02f%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public float getNetWorth() {\n    return builtUpArea * currentMarketRate;\n}\n","name":"getNetWorth","className":"RealEstate","variables":{"currentMarketRate":1,"builtUpArea":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printNetWorth":1,"printAllAssets":1,"createAssets":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"PortfolioManager":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    PortfolioManager manager = new PortfolioManager();\n    manager.createAssets();\n    manager.printAllAssets();\n    manager.printNetWorth();\n}\n","name":"main","className":"PortfolioManager","variables":{"manager":4},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setMarketPrice":1,"setName":2,"setQuantityAtHand":1,"setAccountNumber":2,"setOverdraftLimit":1,"setMaturityDate":1,"setBankName":2,"setInterestRate":1,"setType":5,"setBuiltUpArea":1,"setId":5,"setInvestedAmount":1,"setBalance":2,"setCurrentMarketRate":1,"setTradeExchangeName":2,"setSymbol":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"SavingsAccount":1,"RealEstate":1,"Bond":1,"CheckingAccount":1,"Stock":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":14,"VariableDeclarationExpr":5,"DoubleLiteralExpr":7,"ArrayAccessExpr":5,"NameExpr":97,"StringLiteralExpr":13,"MethodCallExpr":29,"AssignExpr":5},"statements":{"ExpressionStmt":39},"text":"private void createAssets() {\n    SavingsAccount tomSavingsAccount = new SavingsAccount();\n    tomSavingsAccount.setId(1001);\n    tomSavingsAccount.setType(\"Bank Account\");\n    tomSavingsAccount.setBankName(\"Citi bank\");\n    tomSavingsAccount.setAccountNumber(526702);\n    tomSavingsAccount.setBalance(15450.00f);\n    tomSavingsAccount.setInterestRate(3.0f);\n    tomAssets[0] = tomSavingsAccount;\n    CheckingAccount iVisionBusinessAccount = new CheckingAccount();\n    iVisionBusinessAccount.setId(1002);\n    iVisionBusinessAccount.setType(\"Bank Account\");\n    iVisionBusinessAccount.setBankName(\"Bank of America\");\n    iVisionBusinessAccount.setAccountNumber(24689);\n    iVisionBusinessAccount.setBalance(678256.00f);\n    iVisionBusinessAccount.setOverdraftLimit(50000.00f);\n    tomAssets[1] = iVisionBusinessAccount;\n    Stock ibmStocks = new Stock();\n    ibmStocks.setId(5001);\n    ibmStocks.setType(\"Security\");\n    ibmStocks.setTradeExchangeName(\"NYSE\");\n    ibmStocks.setSymbol(\"IBM\");\n    ibmStocks.setQuantityAtHand(100);\n    ibmStocks.setMarketPrice(129.61f);\n    tomAssets[2] = ibmStocks;\n    Bond aaplBonds = new Bond();\n    aaplBonds.setId(6000);\n    aaplBonds.setType(\"Bonds\");\n    aaplBonds.setTradeExchangeName(\"NYSE\");\n    aaplBonds.setName(\"Apple Inc\");\n    aaplBonds.setInvestedAmount(25000.00f);\n    aaplBonds.setMaturityDate(\"01/01/2015\");\n    tomAssets[3] = aaplBonds;\n    RealEstate texasEstate = new RealEstate();\n    texasEstate.setId(8000);\n    texasEstate.setType(\"Real Estate\");\n    texasEstate.setName(\"House in Texas\");\n    texasEstate.setBuiltUpArea(2250);\n    texasEstate.setCurrentMarketRate(950.00f);\n    tomAssets[4] = texasEstate;\n}\n","name":"createAssets","className":"PortfolioManager","variables":{"texasEstate":7,"tomAssets":5,"iVisionBusinessAccount":8,"ibmStocks":8,"tomSavingsAccount":8,"aaplBonds":8},"constants":{"5001":1,"15450.00f":1,"3.0f":1,"129.61f":1,"\"Real Estate\"":1,"25000.00f":1,"2250":1,"\"Security\"":1,"\"Bonds\"":1,"50000.00f":1,"\"Bank Account\"":2,"8000":1,"950.00f":1,"6000":1,"\"Bank of America\"":1,"526702":1,"24689":1,"\"Citi bank\"":1,"0":1,"1":1,"\"IBM\"":1,"100":1,"2":1,"\"House in Texas\"":1,"\"01/01/2015\"":1,"3":1,"4":1,"\"Apple Inc\"":1,"1002":1,"1001":1,"\"NYSE\"":2,"678256.00f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"printDescription":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Asset":1,"String":1},"expressions":{"VariableDeclarationExpr":2,"StringLiteralExpr":2,"NameExpr":21,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":5},"text":"private void printAllAssets() {\n    String lineSeparator = \"-------------------\";\n    System.out.println(\"Entire Portfolio\");\n    for (Asset asset : tomAssets) {\n        System.out.println(lineSeparator);\n        asset.printDescription();\n    }\n    System.out.println(lineSeparator);\n}\n","name":"printAllAssets","className":"PortfolioManager","variables":{"tomAssets":1,"lineSeparator":1,"asset":2},"constants":{"\"-------------------\"":1,"\"Entire Portfolio\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"getNetWorth":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Asset":1,"float":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":3},"text":"private void printNetWorth() {\n    float total = 0;\n    for (Asset asset : tomAssets) {\n        total += asset.getNetWorth();\n    }\n    System.out.println(\"Net Worth of Tom's entire portfolio: $\" + total);\n}\n","name":"printNetWorth","className":"PortfolioManager","variables":{"total":3,"tomAssets":1,"asset":2},"constants":{"0":1,"\"Net Worth of Tom's entire portfolio: $\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"Asset","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public Asset() {\n    System.out.println(\"Creating Asset ...\");\n}\n","name":"Asset","className":"Asset","variables":{},"constants":{"\"Creating Asset ...\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","String"],"returnType":"Asset","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Asset(int id, String type) {\n    this.id = id;\n    this.type = type;\n}\n","name":"Asset","className":"Asset","variables":{"id":1,"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":12,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void printDescription() {\n    System.out.println(\"Asset ID: \" + id);\n    System.out.println(\"Asset type: \" + type);\n}\n","name":"printDescription","className":"Asset","variables":{"id":1,"type":1},"constants":{"\"Asset ID: \"":1,"\"Asset type: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public BankAccount() {\n    System.out.println(\"Creating BankAccount ...\");\n}\n","name":"BankAccount","className":"BankAccount","variables":{},"constants":{"\"Creating BankAccount ...\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int","float","int","String"],"returnType":"BankAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":11,"FieldAccessExpr":3,"ThisExpr":3,"AssignExpr":3},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":3},"text":"public BankAccount(String bankName, int accountNumber, float balance, int id, String type) {\n    super(id, type);\n    this.bankName = bankName;\n    this.accountNumber = accountNumber;\n    this.balance = balance;\n}\n","name":"BankAccount","className":"BankAccount","variables":{"balance":1,"bankName":1,"id":1,"type":1,"accountNumber":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void printDescription() {\n    super.printDescription();\n    System.out.println(\"Name: \" + bankName);\n    System.out.println(\"Account #: \" + accountNumber);\n    System.out.println(\"Current balance: $\" + balance);\n}\n","name":"printDescription","className":"BankAccount","variables":{"balance":1,"bankName":1,"accountNumber":1},"constants":{"\"Current balance: $\"":1,"\"Account #: \"":1,"\"Name: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"SavingsAccount","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public SavingsAccount() {\n    System.out.println(\"Creating SavingsAccount ...\");\n}\n","name":"SavingsAccount","className":"SavingsAccount","variables":{},"constants":{"\"Creating SavingsAccount ...\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float","String","int","float","int","String"],"returnType":"SavingsAccount","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"public SavingsAccount(float interestRate, String bankName, int accountNumber, float balance, int id, String type) {\n    super(bankName, accountNumber, balance, id, type);\n    this.interestRate = interestRate;\n}\n","name":"SavingsAccount","className":"SavingsAccount","variables":{"interestRate":1,"balance":1,"bankName":1,"id":1,"accountNumber":1,"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void printDescription() {\n    System.out.println(\"A savings account\");\n    super.printDescription();\n    System.out.println(\"Interest rate (%): \" + interestRate);\n}\n","name":"printDescription","className":"SavingsAccount","variables":{"interestRate":1},"constants":{"\"A savings account\"":1,"\"Interest rate (%): \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printDescription":2,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"SavingsAccount":2,"String":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"DoubleLiteralExpr":2,"StringLiteralExpr":5,"NameExpr":34,"FieldAccessExpr":5,"MethodCallExpr":7},"statements":{"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    String lineSeparator = \"-------------------\";\n    SavingsAccount tomSavingsAccount = new SavingsAccount();\n    SavingsAccount jimSavingsAccount = new SavingsAccount(4.0f, \"AMEX\", 2015, 500.00f, 2005, \"Bank Account\");\n    System.out.println(lineSeparator);\n    System.out.println(\"Tom's Savings Account\");\n    tomSavingsAccount.printDescription();\n    System.out.println(lineSeparator);\n    System.out.println(\"Jim's Savings Account\");\n    jimSavingsAccount.printDescription();\n    System.out.println(lineSeparator);\n}\n","name":"main","className":"SuperConstructorApp","variables":{"lineSeparator":1,"jimSavingsAccount":2,"tomSavingsAccount":2},"constants":{"\"-------------------\"":1,"500.00f":1,"2005":1,"\"Jim's Savings Account\"":1,"2015":1,"4.0f":1,"\"AMEX\"":1,"\"Bank Account\"":1,"\"Tom's Savings Account\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Asset","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public Asset() {\n    System.out.println(\"Creating Asset ...\");\n}\n","name":"Asset","className":"Asset","variables":{},"constants":{"\"Creating Asset ...\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BankAccount","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public BankAccount() {\n    System.out.println(\"Creating BankAccount ...\");\n}\n","name":"BankAccount","className":"BankAccount","variables":{},"constants":{"\"Creating BankAccount ...\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"SavingsAccount","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public SavingsAccount() {\n    System.out.println(\"Creating SavingsAccount ...\");\n}\n","name":"SavingsAccount","className":"SavingsAccount","variables":{},"constants":{"\"Creating SavingsAccount ...\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"SavingsAccount":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    SavingsAccount tomSavingsAccount = new SavingsAccount();\n}\n","name":"main","className":"ObjectCreationProcess","variables":{"tomSavingsAccount":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"TimeOfDay","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public TimeOfDay(int hour, int mins) {\n    this.hour = hour;\n    this.mins = mins;\n}\n","name":"TimeOfDay","className":"TimeOfDay","variables":{"mins":1,"hour":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TimeOfDay"],"returnType":"TimeOfDay","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public TimeOfDay(TimeOfDay other) {\n    this(other.hour, other.mins);\n}\n","name":"TimeOfDay","className":"TimeOfDay","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":4,"StringLiteralExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"ThisExpr":2},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return (this.hour + \":\" + this.mins);\n}\n","name":"toString","className":"TimeOfDay","variables":{},"constants":{"\":\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"TimeOfDay":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    TimeOfDay currentTime = new TimeOfDay(12, 30);\n    TimeOfDay copyOfCurrentTime = new TimeOfDay(currentTime);\n    System.out.println(\"Original: \" + currentTime.toString());\n    System.out.println(\"Copy: \" + copyOfCurrentTime.toString());\n}\n","name":"main","className":"TimeOfDay","variables":{"currentTime":3,"copyOfCurrentTime":2},"constants":{"\"Copy: \"":1,"12":1,"30":1,"\"Original: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"writeInt":1,"newLine":1,"printStackTrace":1,"readLine":1,"getInputStream":1,"exit":1,"readUTF":1,"writeUTF":3,"getOutputStream":1,"close":5,"write":1,"connect":1,"System.out.println":3},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"DataOutputStream":1,"BufferedReader":1,"String":3,"DataInputStream":1,"Socket":1,"int":1,"BufferedWriter":1},"expressions":{"IntegerLiteralExpr":9,"ObjectCreationExpr":8,"VariableDeclarationExpr":9,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":90,"StringLiteralExpr":7,"UnaryExpr":1,"AssignExpr":5,"NullLiteralExpr":4,"FieldAccessExpr":4,"EnclosedExpr":3,"MethodCallExpr":22},"statements":{"SwitchStmt":1,"IfStmt":2,"WhileStmt":2,"BreakStmt":2,"BlockStmt":9,"TryStmt":2,"SwitchEntryStmt":2,"ExpressionStmt":29},"text":"public static void main(String[] args) {\n    Socket requestSocket = null;\n    if (args.length < 2) {\n        System.out.println(\"Usage: java CloudStore get/put filename\");\n        System.exit(0);\n    }\n    int cmd = 0;\n    switch(args[0]) {\n        case \"get\":\n            cmd = 1;\n            break;\n        case \"put\":\n            cmd = 0;\n            break;\n    }\n    String fileName = args[1];\n    try {\n        try {\n            requestSocket = new Socket();\n            requestSocket.connect(new InetSocketAddress(\"localhost\", 10000));\n            DataOutputStream writer = new DataOutputStream(requestSocket.getOutputStream());\n            writer.writeInt(cmd);\n            writer.writeUTF(fileName);\n            if (cmd == 0) {\n                //put\n                BufferedReader reader = new BufferedReader(new FileReader(fileName));\n                String str = null;\n                while ((str = reader.readLine()) != null) {\n                    writer.writeUTF(str);\n                }\n                writer.writeUTF(\"-1\");\n                System.out.println(fileName + \" uploaded successfully\");\n                reader.close();\n                writer.close();\n            } else {\n                //get\n                DataInputStream reader = new DataInputStream((requestSocket.getInputStream()));\n                BufferedWriter fileWriter = new BufferedWriter(new FileWriter(fileName));\n                String str = null;\n                while (!(str = reader.readUTF()).equalsIgnoreCase(\"-1\")) {\n                    fileWriter.write(str);\n                    fileWriter.newLine();\n                    System.out.println(str);\n                }\n                reader.close();\n                fileWriter.close();\n            }\n        } finally {\n            requestSocket.close();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"main","className":"CloudStore","variables":{"args":2,"str":4,"fileName":4,"e":2,"reader":6,"fileWriter":4,"requestSocket":6,"cmd":4,"writer":6,"System":1},"constants":{"0":5,"\"localhost\"":1,"\"get\"":1,"1":2,"2":1,"null":4,"\"put\"":1,"\" uploaded successfully\"":1,"10000":1,"\"-1\"":2,"\"Usage: java CloudStore get/put filename\"":1},"javaDoc":"","comments":"put get ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"receive":1,"getByName":1,"getLength":1,"joinGroup":1,"leaveGroup":1,"close":1,"getData":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"byte[]":1,"MulticastSocket":1,"DatagramPacket":1,"String":1,"InetAddress":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":5,"VariableDeclarationExpr":6,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":8},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) throws IOException {\n    MulticastSocket socket = new MulticastSocket(4446);\n    InetAddress address = InetAddress.getByName(\"230.0.0.1\");\n    socket.joinGroup(address);\n    for (int i = 0; i < 10; i++) {\n        byte[] buffer = new byte[256];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        String received = new String(packet.getData(), 0, packet.getLength());\n        System.out.println(\"Last Trade: \" + received);\n    }\n    socket.leaveGroup(address);\n    socket.close();\n}\n","name":"main","className":"StocksTrader","variables":{"address":1,"i":3,"received":2,"socket":5,"buffer":2,"packet":3,"InetAddress":1},"constants":{"0":2,"256":1,"\"230.0.0.1\"":1,"4446":1,"\"Last Trade: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"read":1,"printStackTrace":1,"getOutputStream":1,"getInputStream":1,"write":1,"close":1,"System.out.println":3,"accept":1},"annotations":[],"exceptions":["SocketException","IOException"],"concepts":["ExceptionHandling"],"types":{"byte":1,"InputStream":1,"OutputStream":1,"Socket":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"NameExpr":41,"StringLiteralExpr":3,"FieldAccessExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":11,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    byte buffer[] = new byte[512];\n    new Thread(new Monitor()).start();\n    try {\n        server = new ServerSocket(10000);\n        System.out.println(\"Server Started\");\n        System.out.println(\"Hit Enter to stop the server\");\n        while (true) {\n            Socket socketObject = server.accept();\n            InputStream reader = socketObject.getInputStream();\n            reader.read(buffer);\n            OutputStream writer = socketObject.getOutputStream();\n            writer.write(buffer);\n            socketObject.close();\n        }\n    } catch (SocketException e) {\n        System.out.println(\"Server is down\");\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"EchoServer","variables":{"server":2,"ex":2,"socketObject":4,"e":1,"reader":2,"buffer":1,"writer":2},"constants":{"\"Hit Enter to stop the server\"":1,"512":1,"\"Server is down\"":1,"10000":1,"true":1,"\"Server Started\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"private static void shutdownServer() {\n    try {\n        server.close();\n    } catch (IOException ex) {\n    }\n    System.exit(0);\n}\n","name":"shutdownServer","className":"EchoServer","variables":{"server":1,"ex":1,"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"shutdownServer":1,"System.in.read":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"FieldAccessExpr":1,"CharLiteralExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":1},"text":"public void run() {\n    try {\n        while (System.in.read() != '\\n') {\n        }\n    } catch (IOException ex) {\n    }\n    shutdownServer();\n}\n","name":"run","className":"Monitor","variables":{"ex":1},"constants":{"'\\n'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"submit":2,"printStackTrace":1,"newCachedThreadPool":1,"System.out.println":4,"accept":1},"annotations":[],"exceptions":["SocketException","IOException"],"concepts":["ExceptionHandling"],"types":{"Socket":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":38,"StringLiteralExpr":4,"FieldAccessExpr":4,"AssignExpr":2,"MethodCallExpr":9},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    try {\n        threadPool = Executors.newCachedThreadPool();\n        threadPool.submit(new Monitor());\n        server = new ServerSocket(10000);\n        System.out.println(\"Server listening on port 10000 ...\");\n        System.out.println(\"Hit Enter to stop the server\");\n        while (true) {\n            Socket socketObject = server.accept();\n            System.out.println(\"Thread created\");\n            threadPool.submit(new EchoThread(socketObject));\n        }\n    } catch (SocketException e) {\n        System.out.println(\"Server is down\");\n    } catch (IOException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"EchoMultiServer","variables":{"server":2,"ex":2,"socketObject":2,"e":1,"threadPool":3,"Executors":1},"constants":{"\"Thread created\"":1,"\"Server listening on port 10000 ...\"":1,"\"Hit Enter to stop the server\"":1,"\"Server is down\"":1,"10000":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1,"close":1,"shutdown":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"private static void shutdownServer() {\n    try {\n        server.close();\n    } catch (IOException ex) {\n    }\n    threadPool.shutdown();\n    System.exit(0);\n}\n","name":"shutdownServer","className":"EchoMultiServer","variables":{"server":1,"ex":1,"threadPool":1,"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"shutdownServer":1,"System.in.read":1},"annotations":["Override"],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"FieldAccessExpr":1,"CharLiteralExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":1},"text":"@Override\npublic void run() {\n    try {\n        while (System.in.read() != '\\n') {\n        }\n    } catch (IOException ex) {\n    }\n    shutdownServer();\n}\n","name":"run","className":"Monitor","variables":{"ex":1},"constants":{"'\\n'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Socket"],"returnType":"EchoThread","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public EchoThread(Socket socketObject) {\n    this.socketObject = socketObject;\n}\n","name":"EchoThread","className":"EchoThread","variables":{"socketObject":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"printStackTrace":1,"getOutputStream":1,"getInputStream":1,"write":1,"close":1},"annotations":["Override"],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"InputStream":1,"OutputStream":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":20,"MethodCallExpr":6},"statements":{"TryStmt":2,"BlockStmt":4,"ExpressionStmt":6},"text":"@Override\npublic void run() {\n    try {\n        try {\n            InputStream reader = socketObject.getInputStream();\n            reader.read(buffer);\n            OutputStream writer = socketObject.getOutputStream();\n            writer.write(buffer);\n        } finally {\n            socketObject.close();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"run","className":"EchoThread","variables":{"socketObject":3,"e":2,"reader":2,"writer":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getName":1,"openConnection":1,"System.out.printf":1,"getContent":1,"format":1,"setDefault":1,"getDomain":1,"getValue":1,"getMaxAge":1,"setCookiePolicy":1,"getCookies":1,"getCookieStore":1,"System.out.println":8,"getSecure":1},"annotations":[],"exceptions":["MalformedURLException","IOException"],"concepts":["ExceptionHandling"],"types":{"Object":1,"String":1,"List<HttpCookie>":1,"HttpCookie":1,"CookieManager":1,"URL":1,"URLConnection":1,"long":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":8,"BinaryExpr":7,"StringLiteralExpr":11,"NameExpr":87,"CastExpr":1,"FieldAccessExpr":9,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":22},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":6,"ForeachStmt":1,"ExpressionStmt":18},"text":"public static void main(String[] args) {\n    try {\n        String urlString = \"http://www.yahoo.com\";\n        CookieManager manager = new CookieManager();\n        manager.setCookiePolicy(new CustomCookiePolicy());\n        CookieHandler.setDefault(manager);\n        URL url = new URL(urlString);\n        URLConnection connection = url.openConnection();\n        Object obj = connection.getContent();\n        List<HttpCookie> cookies = manager.getCookieStore().getCookies();\n        for (HttpCookie cookie : cookies) {\n            System.out.println(\"Name: \" + cookie.getName());\n            System.out.println(\"Domain: \" + cookie.getDomain());\n            long age = cookie.getMaxAge();\n            if (age == -1) {\n                System.out.println(\"This cookie will expire when \" + \"browser closes\");\n            } else {\n                System.out.printf(\"This cookie will expire in %s \" + \"seconds%n\", sdf.format(age));\n            }\n            System.out.println(\"Secured: \" + ((Boolean) cookie.getSecure()).toString());\n            System.out.println(\"Value: \" + cookie.getValue());\n            System.out.println();\n        }\n    } catch (MalformedURLException e) {\n        System.out.println(\"Invalid URL\");\n    } catch (IOException e) {\n        System.out.println(\"Error in I/O operation\");\n    }\n}\n","name":"main","className":"CookieSpy","variables":{"manager":3,"cookie":6,"sdf":1,"e":2,"obj":1,"urlString":2,"connection":2,"url":2,"cookies":2,"age":2,"CookieHandler":1},"constants":{"\"This cookie will expire in %s \"":1,"1":1,"\"Error in I/O operation\"":1,"\"Secured: \"":1,"\"Invalid URL\"":1,"\"http://www.yahoo.com\"":1,"\"This cookie will expire when \"":1,"\"seconds%n\"":1,"\"Name: \"":1,"\"browser closes\"":1,"\"Domain: \"":1,"\"Value: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["URI","HttpCookie"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean shouldAccept(URI uri, HttpCookie cookie) {\n    // return uri.getHost().equals(\"yahoo.com\");\n    return true;\n}\n","name":"shouldAccept","className":"CustomCookiePolicy","variables":{},"constants":{"true":1},"javaDoc":"","comments":"return uri getHost() equals(\"yahoo com\"); ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getAllByName":2,"printStackTrace":1,"toString":1,"System.out.println":6,"getLocalHost":1},"annotations":[],"exceptions":["UnknownHostException"],"concepts":["ExceptionHandling"],"types":{"InetAddress[]":1,"InetAddress":2},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":50,"StringLiteralExpr":5,"FieldAccessExpr":6,"MethodCallExpr":11,"AssignExpr":2},"statements":{"TryStmt":1,"BlockStmt":4,"ForeachStmt":2,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    InetAddress[] inetHost = null;\n    try {\n        System.out.println(\"List of Google servers\");\n        inetHost = InetAddress.getAllByName(\"www.google.com\");\n        for (InetAddress address : inetHost) {\n            System.out.println(address);\n        }\n        System.out.println(\"\\nList of CNN servers\");\n        inetHost = InetAddress.getAllByName(\"cnn.com\");\n        for (InetAddress address : inetHost) {\n            System.out.println(address);\n        }\n        System.out.println(\"\\nLocal machine\");\n        System.out.println(InetAddress.getLocalHost().toString());\n    } catch (UnknownHostException ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"DNSLookup","variables":{"address":2,"ex":2,"inetHost":5,"InetAddress":3},"constants":{"\"\\nList of CNN servers\"":1,"\"www.google.com\"":1,"\"\\nLocal machine\"":1,"null":1,"\"cnn.com\"":1,"\"List of Google servers\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setDaemon":1,"start":1,"System.in.read":1,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Thread":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":26,"StringLiteralExpr":3,"FieldAccessExpr":4,"CharLiteralExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    try {\n        Thread tradesGenerator = new Thread(new StockTradesGenerator());\n        tradesGenerator.setDaemon(true);\n        tradesGenerator.start();\n        System.out.println(\"Stock trades broadcast server started\");\n        System.out.println(\"Hit Enter to stop server\");\n        while (System.in.read() != '\\n') {\n        }\n    } catch (IOException ex) {\n        System.out.println(\"Error starting server\");\n    }\n}\n","name":"main","className":"StockTradesServer","variables":{"ex":1,"tradesGenerator":3},"constants":{"\"Stock trades broadcast server started\"":1,"true":1,"\"Hit Enter to stop server\"":1,"\"Error starting server\"":1,"'\\n'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"StockTradesGenerator","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":["SocketException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NameExpr":6,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"public StockTradesGenerator() {\n    try {\n        broadcastSocket = new DatagramSocket(4445);\n    } catch (SocketException ex) {\n        System.out.println(\"Error making socket connection\");\n    }\n}\n","name":"StockTradesGenerator","className":"StockTradesGenerator","variables":{"ex":1,"broadcastSocket":1},"constants":{"\"Error making socket connection\"":1,"4445":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"random":2,"now":1,"generateRandomTrade":1,"format":1,"getByName":1,"send":1,"close":1,"getBytes":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"byte[]":1,"DatagramPacket":1,"String":1,"float":1,"InetAddress":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":6,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":44,"StringLiteralExpr":3,"AssignExpr":1,"BooleanLiteralExpr":1,"CastExpr":2,"FieldAccessExpr":2,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":11},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ExpressionStmt":11},"text":"public void run() {\n    byte[] buffer = new byte[80];\n    try {\n        while (true) {\n            int index = (int) (Math.random() * 5);\n            float trade = generateRandomTrade(index);\n            String lastTrade = String.format(\"%s %.2f @%s\", stockSymbols[index], trade, now());\n            buffer = lastTrade.getBytes();\n            try {\n                InetAddress groupBrodcastAddresses = InetAddress.getByName(\"230.0.0.1\");\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length, groupBrodcastAddresses, 4446);\n                broadcastSocket.send(packet);\n                Thread.sleep((long) (Math.random() * 2000));\n            } catch (Exception ex) {\n                System.out.println(\"Error in communication\");\n            }\n        }\n    } finally {\n        broadcastSocket.close();\n    }\n}\n","name":"run","className":"StockTradesGenerator","variables":{"broadcastSocket":2,"index":2,"lastTrade":2,"String":1,"Math":2,"packet":1,"stockSymbols":1,"Thread":1,"trade":1,"ex":1,"buffer":3,"InetAddress":1,"groupBrodcastAddresses":2},"constants":{"5":1,"\"230.0.0.1\"":1,"\"Error in communication\"":1,"80":1,"true":1,"\"%s %.2f @%s\"":1,"2000":1,"4446":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"float","methodCalls":{"random":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"float":1},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":1,"CastExpr":1,"NameExpr":10,"MethodCallExpr":1,"AssignExpr":5},"statements":{"SwitchStmt":1,"BreakStmt":5,"SwitchEntryStmt":5,"ReturnStmt":1,"ExpressionStmt":6},"text":"private float generateRandomTrade(int index) {\n    float trade = (float) Math.random();\n    switch(index) {\n        case 0:\n            trade += 118;\n            break;\n        case 1:\n            trade += 29;\n            break;\n        case 2:\n            trade += 8;\n            break;\n        case 3:\n            trade += 26;\n            break;\n        case 4:\n            trade += 14;\n            break;\n    }\n    return trade;\n}\n","name":"generateRandomTrade","className":"StockTradesGenerator","variables":{"trade":7,"index":1,"Math":1},"constants":{"0":1,"1":1,"2":1,"3":1,"14":1,"26":1,"4":1,"29":1,"118":1,"8":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{"getTime":1,"format":1,"getInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Calendar":1,"SimpleDateFormat":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":10,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"private String now() {\n    Calendar cal = Calendar.getInstance();\n    SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT_NOW);\n    return sdf.format(cal.getTime());\n}\n","name":"now","className":"StockTradesGenerator","variables":{"TIME_FORMAT_NOW":1,"sdf":2,"Calendar":1,"cal":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":1,"nextLine":1,"hasNextLine":1,"getOutputStream":1,"write":1,"getInputStream":1,"close":1,"getBytes":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"InputStream":1,"OutputStream":1,"String":2,"Socket":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"StringLiteralExpr":2,"NameExpr":31,"FieldAccessExpr":1,"MethodCallExpr":9},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    try {\n        Socket socketObject = new Socket(\"www.yahoo.com\", 80);\n        try {\n            OutputStream outStream = socketObject.getOutputStream();\n            String str = \"GET / HTTP/1.0\\n\\n\";\n            outStream.write(str.getBytes());\n            InputStream inStream = socketObject.getInputStream();\n            Scanner reader = new Scanner(inStream);\n            while (reader.hasNextLine()) {\n                String line = reader.nextLine();\n                System.out.println(line);\n            }\n        } finally {\n            socketObject.close();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"main","className":"HomePageReader","variables":{"str":2,"socketObject":4,"e":2,"inStream":2,"reader":3,"line":1,"outStream":2},"constants":{"\"GET / HTTP/1.0\\n\\n\"":1,"80":1,"\"www.yahoo.com\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"log":1,"getLogger":1,"close":1,"System.out.println":2,"accept":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Socket":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":5,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":34,"StringLiteralExpr":2,"FieldAccessExpr":3,"ClassExpr":1,"MethodCallExpr":9,"AssignExpr":2},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    Socket requestSocket = null;\n    new Thread(new Monitor()).start();\n    try {\n        server = new ServerSocket(10000);\n        System.out.println(\"Server started:\");\n        System.out.println(\"Hit Enter to stop server\");\n        try {\n            while (true) {\n                requestSocket = server.accept();\n                new Thread(new RequestProcessor(requestSocket)).start();\n            }\n        } finally {\n            requestSocket.close();\n        }\n    } catch (Exception ex) {\n        Logger.getLogger(CloudStorageServer.class.getName()).log(Level.SEVERE, null, ex);\n    }\n}\n","name":"main","className":"CloudStorageServer","variables":{"server":2,"ex":1,"requestSocket":4,"Logger":1},"constants":{"\"Server started:\"":1,"null":2,"10000":1,"true":1,"\"Hit Enter to stop server\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"private static void shutdownServer() {\n    try {\n        server.close();\n    } catch (IOException ex) {\n    }\n    System.exit(0);\n}\n","name":"shutdownServer","className":"CloudStorageServer","variables":{"server":1,"ex":1,"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"shutdownServer":1,"System.in.read":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"FieldAccessExpr":1,"CharLiteralExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":1},"text":"public void run() {\n    try {\n        while (System.in.read() != '\\n') {\n        }\n    } catch (IOException ex) {\n    }\n    shutdownServer();\n}\n","name":"run","className":"Monitor","variables":{"ex":1},"constants":{"'\\n'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Socket"],"returnType":"RequestProcessor","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public RequestProcessor(Socket requestSocket) {\n    this.requestSocket = requestSocket;\n}\n","name":"RequestProcessor","className":"RequestProcessor","variables":{"requestSocket":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"downloadFile":1,"uploadFile":1,"readUTF":1,"log":1,"getLogger":1,"getOutputStream":1,"readInt":1,"getInputStream":1,"System.out.println":1},"annotations":["Override"],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"DataOutputStream":1,"String":2,"DataInputStream":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":4,"NameExpr":44,"StringLiteralExpr":3,"FieldAccessExpr":2,"ClassExpr":1,"MethodCallExpr":10,"AssignExpr":3},"statements":{"IfStmt":3,"TryStmt":1,"BlockStmt":6,"ExpressionStmt":12},"text":"@Override\npublic void run() {\n    try {\n        DataInputStream reader = new DataInputStream(requestSocket.getInputStream());\n        DataOutputStream writer = new DataOutputStream(requestSocket.getOutputStream());\n        int cmd = reader.readInt();\n        String fileName = reader.readUTF();\n        String message;\n        if (cmd == 0) {\n            message = \"Put \";\n        } else {\n            message = \"Get \";\n        }\n        message += fileName + \" requested\";\n        System.out.println(message);\n        if (cmd == 0) {\n            uploadFile(reader, fileName);\n        } else if (cmd == 1) {\n            downloadFile(writer, fileName);\n        }\n    } catch (IOException ex) {\n        Logger.getLogger(CloudStorageServer.class.getName()).log(Level.SEVERE, null, ex);\n    }\n}\n","name":"run","className":"RequestProcessor","variables":{"fileName":2,"ex":1,"reader":3,"requestSocket":2,"writer":1,"cmd":4,"message":4,"Logger":1},"constants":{"0":2,"1":1,"null":1,"\" requested\"":1,"\"Get \"":1,"\"Put \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DataInputStream","String"],"returnType":"void","methodCalls":{"newLine":1,"readUTF":1,"log":1,"getLogger":1,"write":1,"close":2,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"String":1,"BufferedWriter":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":6,"StringLiteralExpr":6,"NameExpr":38,"FieldAccessExpr":2,"ClassExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":10,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"private void uploadFile(DataInputStream in, String fname) {\n    try {\n        BufferedWriter writer = new BufferedWriter(new FileWriter(\"server-\" + fname));\n        String str;\n        while (!(str = in.readUTF()).equals(\"-1\")) {\n            writer.write(str);\n            writer.newLine();\n        }\n        in.close();\n        writer.close();\n        System.out.println(\"'\" + fname + \"' saved under name '\" + \"server-\" + fname + \"'\");\n    } catch (IOException ex) {\n        Logger.getLogger(CloudStorageServer.class.getName()).log(Level.SEVERE, null, ex);\n    }\n}\n","name":"uploadFile","className":"RequestProcessor","variables":{"str":2,"fname":3,"ex":1,"in":2,"writer":4,"Logger":1},"constants":{"\"server-\"":2,"null":1,"\"-1\"":1,"\"'\"":2,"\"' saved under name '\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["DataOutputStream","String"],"returnType":"void","methodCalls":{"log":1,"writeUTF":2,"getLogger":1,"readLine":2,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":33,"ClassExpr":1,"FieldAccessExpr":1,"MethodCallExpr":9,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"private void downloadFile(DataOutputStream out, String fname) {\n    try {\n        BufferedReader reader = new BufferedReader(new FileReader(\"server-\" + fname));\n        String str = reader.readLine();\n        while (str != null) {\n            out.writeUTF(str);\n            str = reader.readLine();\n        }\n        out.writeUTF(\"-1\");\n        reader.close();\n        out.close();\n    } catch (IOException ex) {\n        Logger.getLogger(CloudStorageServer.class.getName()).log(Level.SEVERE, null, ex);\n    }\n}\n","name":"downloadFile","className":"RequestProcessor","variables":{"str":3,"fname":1,"ex":1,"reader":4,"Logger":1,"out":3},"constants":{"\"server-\"":1,"null":2,"\"-1\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":1,"nextLine":1,"openConnection":1,"hasNextLine":1,"getInputStream":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"InputStream":1,"String":2,"URL":1,"URLConnection":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":6,"StringLiteralExpr":1,"NameExpr":26,"FieldAccessExpr":1,"MethodCallExpr":7},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    try {\n        String strURL = \"http://www.oracle.com/us/technologies/java/index.html\";\n        URL url = new URL(strURL);\n        URLConnection connection = url.openConnection();\n        InputStream inStream = connection.getInputStream();\n        Scanner reader = new Scanner(inStream);\n        while (reader.hasNextLine()) {\n            String line = reader.nextLine();\n            System.out.println(line);\n        }\n        reader.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"main","className":"WebPageReader","variables":{"e":2,"inStream":2,"reader":4,"line":1,"connection":2,"strURL":2,"url":2},"constants":{"\"http://www.oracle.com/us/technologies/java/index.html\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":5},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int[][]":1,"int[]":2,"String[]":1,"int":2,"float[]":1},"expressions":{"IntegerLiteralExpr":16,"VariableDeclarationExpr":7,"ArrayInitializerExpr":7,"DoubleLiteralExpr":4,"BinaryExpr":7,"NameExpr":43,"StringLiteralExpr":13,"FieldAccessExpr":10,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    final int SIZE = 5;\n    int[] integerArray = new int[SIZE];\n    float[] floatArray = { 5.0f, 3.0f, 2.0f, 1.5f };\n    String[] weekDays = { \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" };\n    int[][] jaggedArray = { { 5, 4 }, { 10, 15, 12, 15, 18 }, { 6, 9, 10 }, { 12, 5, 8, 11 } };\n    System.out.println(\"integerArray length: \" + integerArray.length);\n    System.out.println(\"floatArray length: \" + floatArray.length);\n    System.out.println(\"Number of days in a week: \" + weekDays.length);\n    System.out.println(\"Length of jaggedArray: \" + jaggedArray.length);\n    int row = 0;\n    for (int[] memberRow : jaggedArray) {\n        System.out.println(\"\\tArray length for row \" + ++row + \": \" + memberRow.length);\n    }\n}\n","name":"main","className":"ArrayLengthApp","variables":{"memberRow":1,"floatArray":1,"integerArray":1,"weekDays":1,"SIZE":2,"jaggedArray":2,"row":2},"constants":{"\"\\tArray length for row \"":1,"3.0f":1,"\": \"":1,"5.0f":1,"\"integerArray length: \"":1,"\"Wednesday\"":1,"\"Monday\"":1,"10":2,"11":1,"\"Sunday\"":1,"12":2,"15":2,"2.0f":1,"18":1,"\"Length of jaggedArray: \"":1,"\"floatArray length: \"":1,"0":1,"\"Thursday\"":1,"4":1,"5":3,"\"Saturday\"":1,"6":1,"\"Number of days in a week: \"":1,"1.5f":1,"\"Tuesday\"":1,"8":1,"9":1,"\"Friday\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"printStackTrace":1,"readLine":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["FinalVariables","ExceptionHandling"],"types":{"BufferedReader":1,"int[]":1,"String":1,"int":4},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":2,"VariableDeclarationExpr":7,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":38,"StringLiteralExpr":3,"UnaryExpr":2,"AssignExpr":2,"CastExpr":1,"FieldAccessExpr":3,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":4,"ForStmt":2,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    final int NUMBER_OF_STUDENTS = 5;\n    int[] marks = new int[NUMBER_OF_STUDENTS];\n    try {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        for (int i = 0; i < NUMBER_OF_STUDENTS; i++) {\n            System.out.print(\"Enter marks for student #\" + (i + 1) + \": \");\n            String str = reader.readLine();\n            marks[i] = Integer.parseInt(str);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    int total = 0;\n    for (int i = 0; i < NUMBER_OF_STUDENTS; i++) {\n        total += marks[i];\n    }\n    System.out.println(\"Average Marks \" + (float) total / NUMBER_OF_STUDENTS);\n}\n","name":"main","className":"TestScoreAverage","variables":{"str":1,"Integer":1,"NUMBER_OF_STUDENTS":5,"total":3,"e":2,"reader":2,"i":9,"marks":3},"constants":{"0":3,"1":1,"5":1,"\"Average Marks \"":1,"\": \"":1,"\"Enter marks for student #\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":1,"System.out.print":4,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int[][]":1,"int":6},"expressions":{"IntegerLiteralExpr":9,"VariableDeclarationExpr":7,"ArrayAccessExpr":4,"BinaryExpr":14,"NameExpr":58,"StringLiteralExpr":7,"CharLiteralExpr":1,"UnaryExpr":5,"AssignExpr":1,"CastExpr":1,"FieldAccessExpr":6,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":7},"statements":{"BlockStmt":5,"ForStmt":5,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    final int MAX_STUDENTS = 50, MAX_SUBJECTS = 3;\n    int[][] marks = new int[MAX_STUDENTS][MAX_SUBJECTS];\n    // Adding data to the array\n    for (int id = 0; id < MAX_STUDENTS; id++) {\n        for (int subject = 0; subject < MAX_SUBJECTS; subject++) {\n            marks[id][subject] = (int) (Math.random() * 100);\n        }\n    }\n    // Printing Array\n    System.out.print(\"Student\\t\");\n    for (int subject = 0; subject < MAX_SUBJECTS; subject++) {\n        System.out.print(\"\\t\" + \"Subject \" + subject + \"\\t\");\n    }\n    System.out.println();\n    for (int id = 0; id < MAX_STUDENTS; id++) {\n        System.out.print(\"Student \" + (id + 1) + '\\t');\n        for (int subject = 0; subject < MAX_SUBJECTS; subject++) {\n            System.out.print(\"\\t\" + marks[id][subject] + \"\\t\");\n        }\n        System.out.println();\n    }\n}\n","name":"main","className":"MultiDimArrayApp","variables":{"subject":12,"MAX_STUDENTS":4,"MAX_SUBJECTS":5,"marks":3,"id":9,"Math":1},"constants":{"0":5,"\"Subject \"":1,"100":1,"\"Student \"":1,"1":1,"3":1,"\"\\t\"":4,"\"Student\\t\"":1,"50":1,"'\\t'":1},"javaDoc":"","comments":"Adding data to the array Printing Array ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getClass":4,"getName":5,"System.out.println":6,"getSuperclass":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int[][]":1,"int[]":1,"Class":1,"String[]":1,"int":1,"float[]":1},"expressions":{"IntegerLiteralExpr":15,"VariableDeclarationExpr":6,"ArrayInitializerExpr":7,"DoubleLiteralExpr":4,"BinaryExpr":5,"NameExpr":65,"StringLiteralExpr":12,"FieldAccessExpr":6,"ArrayCreationExpr":1,"MethodCallExpr":16,"AssignExpr":4},"statements":{"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    final int SIZE = 5;\n    int[] integerArray = new int[SIZE];\n    float[] floatArray = { 5.0f, 3.0f, 2.0f, 1.5f };\n    String[] weekDays = { \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" };\n    int[][] jaggedArray = { { 5, 4 }, { 10, 15, 12, 15, 18 }, { 6, 9, 10 }, { 12, 5, 8, 11 } };\n    Class cls = integerArray.getClass();\n    System.out.println(\"The class name of integerArray: \" + cls.getName());\n    cls = floatArray.getClass();\n    System.out.println(\"The class name of floatArray: \" + cls.getName());\n    cls = weekDays.getClass();\n    System.out.println(\"The class name of weekDays: \" + cls.getName());\n    cls = jaggedArray.getClass();\n    System.out.println(\"The class name of jaggedArray: \" + cls.getName());\n    System.out.println();\n    cls = cls.getSuperclass();\n    System.out.println(\"The super class of an array object: \" + cls.getName());\n}\n","name":"main","className":"ArrayClassNameApp","variables":{"floatArray":2,"integerArray":2,"weekDays":2,"SIZE":2,"jaggedArray":2,"cls":11},"constants":{"3.0f":1,"\"The class name of floatArray: \"":1,"\"The super class of an array object: \"":1,"5.0f":1,"\"Wednesday\"":1,"\"Monday\"":1,"10":2,"11":1,"\"Sunday\"":1,"12":2,"15":2,"2.0f":1,"18":1,"\"The class name of weekDays: \"":1,"\"The class name of jaggedArray: \"":1,"\"Thursday\"":1,"\"The class name of integerArray: \"":1,"4":1,"5":3,"\"Saturday\"":1,"6":1,"1.5f":1,"\"Tuesday\"":1,"8":1,"9":1,"\"Friday\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"clone":1,"toString":6,"System.out.println":10},"annotations":[],"exceptions":[],"concepts":[],"types":{"float[]":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"DoubleLiteralExpr":4,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":79,"StringLiteralExpr":8,"FieldAccessExpr":10,"MethodCallExpr":17,"AssignExpr":2},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    float[] floatArray = { 5.0f, 3.0f, 2.0f, 1.5f };\n    float[] floatArrayCopy = floatArray.clone();\n    System.out.println(Arrays.toString(floatArray) + \" - Original\");\n    System.out.println(Arrays.toString(floatArrayCopy) + \" - Copy\");\n    System.out.println();\n    System.out.println(\"Modifying the second element of the original array\");\n    floatArray[1] = 20;\n    System.out.println(Arrays.toString(floatArray) + \" - Original after modification\");\n    System.out.println(Arrays.toString(floatArrayCopy) + \" - Copy\");\n    System.out.println();\n    System.out.println(\"Modifying the third element of the copy array\");\n    floatArrayCopy[2] = 30;\n    System.out.println(Arrays.toString(floatArray) + \" - Original\");\n    System.out.println(Arrays.toString(floatArrayCopy) + \" - Copy array after modification\");\n}\n","name":"main","className":"ArrayCopyApp","variables":{"floatArray":3,"floatArrayCopy":2,"Arrays":6},"constants":{"2.0f":1,"3.0f":1,"\"Modifying the second element of the original array\"":1,"\" - Copy\"":2,"\" - Original\"":2,"1":1,"2":1,"\" - Original after modification\"":1,"\"Modifying the third element of the copy array\"":1,"5.0f":1,"1.5f":1,"\" - Copy array after modification\"":1,"30":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"OrderExecutor","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public OrderExecutor(int id) {\n    this.id = id;\n}\n","name":"OrderExecutor","className":"OrderExecutor","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"sleep":1,"currentTimeMillis":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"BinaryExpr":3,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public Object call() throws Exception {\n    try {\n        while (count < 50) {\n            count++;\n            Thread.sleep(new Random(System.currentTimeMillis() % 100).nextInt(10));\n        }\n        System.out.println(\"Successfully executed order: \" + id);\n    } catch (Exception ex) {\n        throw (ex);\n    }\n    return id;\n}\n","name":"call","className":"OrderExecutor","variables":{"ex":2,"count":2,"id":2,"System":1,"Thread":1},"constants":{"100":1,"50":1,"\"Successfully executed order: \"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"isCancelled":1,"printStackTrace":1,"System.out.printf":2,"awaitTermination":1,"shutdownNow":1,"SubmitOrder":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"Future":1,"int":2},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":48,"StringLiteralExpr":4,"FieldAccessExpr":5,"UnaryExpr":2,"MethodCallExpr":10},"statements":{"IfStmt":1,"BlockStmt":5,"TryStmt":1,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    System.out.printf(\"Submitting %d trades%n\", MAX_NUMBER_OF_ORDERS);\n    for (int i = 0; i < MAX_NUMBER_OF_ORDERS; i++) {\n        SubmitOrder(i);\n    }\n    new Thread(new EvilThread(ordersToProcess)).start();\n    System.out.println(\"Cancelling a few orders at random\");\n    try {\n        executor.awaitTermination(30, TimeUnit.SECONDS);\n    } catch (InterruptedException ex) {\n        ex.printStackTrace();\n    }\n    System.out.println(\"Checking status before shutdown\");\n    int count = 0;\n    for (Future f : ordersToProcess) {\n        if (f.isCancelled()) {\n            count++;\n        }\n    }\n    System.out.printf(\"%d trades cancelled%n\", count);\n    executor.shutdownNow();\n}\n","name":"main","className":"StocksOrderProcessor","variables":{"ordersToProcess":2,"ex":2,"executor":2,"f":2,"count":2,"i":3,"MAX_NUMBER_OF_ORDERS":1},"constants":{"0":2,"\"%d trades cancelled%n\"":1,"\"Cancelling a few orders at random\"":1,"\"Checking status before shutdown\"":1,"\"Submitting %d trades%n\"":1,"30":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"add":1,"submit":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"OrderExecutor":1,"Callable<Integer>":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"private static void SubmitOrder(int id) {\n    Callable<Integer> callable = new OrderExecutor(id);\n    ordersToProcess.add(executor.submit(callable));\n}\n","name":"SubmitOrder","className":"StocksOrderProcessor","variables":{"ordersToProcess":1,"callable":1,"executor":1,"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["List<Future>"],"returnType":"EvilThread","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public EvilThread(List<Future> futures) {\n    this.ordersToProcess = futures;\n}\n","name":"EvilThread","className":"EvilThread","variables":{"futures":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"cancel":1,"sleep":1,"printStackTrace":1,"currentTimeMillis":1,"get":1,"nextInt":2,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"boolean":1,"Random":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":4,"BooleanLiteralExpr":1,"NameExpr":39,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":1,"BlockStmt":5,"TryStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public void run() {\n    Random myNextKill = new Random(System.currentTimeMillis() % 100);\n    for (int i = 0; i < 100; i++) {\n        int index = myNextKill.nextInt(StocksOrderProcessor.MAX_NUMBER_OF_ORDERS);\n        boolean cancel = ordersToProcess.get(index).cancel(true);\n        if (cancel) {\n            System.out.println(\"Cancel Order Succeeded: \" + index);\n        } else {\n            System.out.println(\"Cancel Order Failed: \" + index);\n        }\n        try {\n            Thread.sleep(myNextKill.nextInt(100));\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n","name":"run","className":"EvilThread","variables":{"cancel":2,"ordersToProcess":1,"ex":2,"myNextKill":3,"i":3,"index":3,"System":1,"Thread":1},"constants":{"0":1,"100":3,"true":1,"\"Cancel Order Failed: \"":1,"\"Cancel Order Succeeded: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Summer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public Summer(int companyID) {\n    this.companyID = companyID;\n}\n","name":"Summer","className":"Summer","variables":{"companyID":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Integer","methodCalls":{"System.out.printf":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":14,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public Integer call() {\n    int sum = 0;\n    for (int col = 0; col < NUMBER_OF_MONTHS; col++) {\n        sum += salesMatrix[companyID][col];\n    }\n    System.out.printf(\"Totaling for client 1%02d completed%n\", companyID);\n    return sum;\n}\n","name":"call","className":"Summer","variables":{"col":4,"companyID":1,"NUMBER_OF_MONTHS":1,"salesMatrix":1,"sum":3},"constants":{"0":2,"\"Totaling for client 1%02d completed%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"printMatrix":1,"newFixedThreadPool":1,"submit":1,"System.out.printf":1,"get":1,"generateMatrix":1,"shutdown":1},"annotations":[],"exceptions":["Exception"],"concepts":["PolyMorphism"],"types":{"Callable<Integer>":1,"Future<Integer>":2,"ExecutorService":1,"Summer":1,"int":2,"HashSet":1,"Set<Future<Integer>>":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":2,"VariableDeclarationExpr":7,"BinaryExpr":1,"NameExpr":33,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":8,"AssignExpr":1},"statements":{"BlockStmt":2,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":11},"text":"public static void main(String args[]) throws Exception {\n    generateMatrix();\n    printMatrix();\n    ExecutorService executor = Executors.newFixedThreadPool(10);\n    Set<Future<Integer>> set = new HashSet<Future<Integer>>();\n    for (int row = 0; row < NUMBER_OF_CUSTOMERS; row++) {\n        Callable<Integer> callable = new Summer(row);\n        Future<Integer> future = executor.submit(callable);\n        set.add(future);\n    }\n    int sum = 0;\n    for (Future<Integer> future : set) {\n        sum += future.get();\n    }\n    System.out.printf(\"%nThe annual turnover (bags): %s%n%n\", sum);\n    executor.shutdown();\n}\n","name":"main","className":"AnnualSalesCalc","variables":{"set":3,"callable":1,"executor":3,"future":3,"sum":2,"Executors":1,"row":4,"NUMBER_OF_CUSTOMERS":1},"constants":{"0":2,"10":1,"\"%nThe annual turnover (bags): %s%n%n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"random":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":15,"CastExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":2,"MethodCallExpr":1},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":2},"text":"private static void generateMatrix() {\n    salesMatrix = new int[NUMBER_OF_CUSTOMERS][NUMBER_OF_MONTHS];\n    for (int i = 0; i < NUMBER_OF_CUSTOMERS; i++) {\n        for (int j = 0; j < NUMBER_OF_MONTHS; j++) {\n            salesMatrix[i][j] = (int) (Math.random() * 100);\n        }\n    }\n}\n","name":"generateMatrix","className":"AnnualSalesCalc","variables":{"NUMBER_OF_MONTHS":2,"salesMatrix":2,"i":4,"j":4,"Math":1,"NUMBER_OF_CUSTOMERS":2},"constants":{"0":2,"100":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.printf":5,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"String":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":49,"StringLiteralExpr":6,"FieldAccessExpr":7,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":8},"statements":{"BlockStmt":3,"ForeachStmt":1,"ForStmt":2,"ExpressionStmt":8},"text":"private static void printMatrix() {\n    System.out.print(\"\\t\\t\");\n    String[] monthDisplayNames = (new DateFormatSymbols()).getShortMonths();\n    for (String strName : monthDisplayNames) {\n        System.out.printf(\"%8s\", strName);\n    }\n    System.out.printf(\"%n%n\");\n    for (int i = 0; i < NUMBER_OF_CUSTOMERS; i++) {\n        System.out.printf(\"Client ID: 1%02d\", i);\n        for (int j = 0; j < NUMBER_OF_MONTHS; j++) {\n            System.out.printf(\"%8d\", salesMatrix[i][j]);\n        }\n        System.out.println();\n    }\n    System.out.printf(\"%n%n\");\n}\n","name":"printMatrix","className":"AnnualSalesCalc","variables":{"NUMBER_OF_MONTHS":1,"strName":1,"monthDisplayNames":2,"i":4,"salesMatrix":1,"j":4,"NUMBER_OF_CUSTOMERS":1},"constants":{"0":2,"\"%8d\"":1,"\"%8s\"":1,"\"\\t\\t\"":1,"\"%n%n\"":2,"\"Client ID: 1%02d\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Comparable[]"],"returnType":"void","methodCalls":{"invoke":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Comparable[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"private static void sort(Comparable[] objectArray) {\n    Comparable[] destArray = new Comparable[objectArray.length];\n    threadPool.invoke(new SortTask(objectArray, destArray, 0, objectArray.length - 1));\n}\n","name":"sort","className":"ParallelMergeSort","variables":{"objectArray":1,"threadPool":1,"destArray":2},"constants":{"0":1,"1":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Comparable[]","Comparable[]","int","int"],"returnType":"SortTask","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public SortTask(Comparable[] sourceArray, Comparable[] destArray, int lowerIndex, int upperIndex) {\n    this.sourceArray = sourceArray;\n    this.lowerIndex = lowerIndex;\n    this.upperIndex = upperIndex;\n    this.destArray = destArray;\n}\n","name":"SortTask","className":"SortTask","variables":{"sourceArray":1,"lowerIndex":1,"upperIndex":1,"destArray":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"insertionSort":1,"invokeAll":1,"merge":1},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":27,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"@Override\nprotected void compute() {\n    if (upperIndex - lowerIndex < THRESHOLD) {\n        insertionSort(sourceArray, lowerIndex, upperIndex);\n        return;\n    }\n    int midIndex = (lowerIndex + upperIndex) >>> 1;\n    invokeAll(new SortTask(sourceArray, destArray, lowerIndex, midIndex), new SortTask(sourceArray, destArray, midIndex + 1, upperIndex));\n    merge(sourceArray, destArray, lowerIndex, midIndex, upperIndex);\n}\n","name":"compute","className":"SortTask","variables":{"midIndex":3,"THRESHOLD":1,"sourceArray":2,"lowerIndex":3,"upperIndex":3,"destArray":2},"constants":{"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Comparable[]","Comparable[]","int","int","int"],"returnType":"void","methodCalls":{"arraycopy":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"ArrayAccessExpr":8,"BinaryExpr":10,"NameExpr":45,"UnaryExpr":4,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":7},"text":"private static void merge(Comparable[] sourceArray, Comparable[] destArray, int lowerIndex, int midIndex, int upperIndex) {\n    if (sourceArray[midIndex].compareTo(sourceArray[midIndex + 1]) <= 0) {\n        return;\n    }\n    System.arraycopy(sourceArray, lowerIndex, destArray, lowerIndex, midIndex - lowerIndex + 1);\n    int i = lowerIndex;\n    int j = midIndex + 1;\n    int k = lowerIndex;\n    while (k < j && j <= upperIndex) {\n        if (destArray[i].compareTo(sourceArray[j]) <= 0) {\n            sourceArray[k++] = destArray[i++];\n        } else {\n            sourceArray[k++] = sourceArray[j++];\n        }\n    }\n    System.arraycopy(destArray, i, sourceArray, k, j - k);\n}\n","name":"merge","className":"ParallelMergeSort","variables":{"midIndex":4,"sourceArray":6,"lowerIndex":3,"i":3,"j":6,"upperIndex":1,"k":5,"destArray":2,"System":2},"constants":{"0":2,"1":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Comparable[]","int","int"],"returnType":"void","methodCalls":{"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Comparable":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":5,"BinaryExpr":7,"NameExpr":22,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":5},"text":"private static void insertionSort(Comparable[] objectArray, int lowerIndex, int upperIndex) {\n    for (int i = lowerIndex + 1; i <= upperIndex; i++) {\n        int j = i;\n        Comparable tempObject = objectArray[j];\n        while (j > lowerIndex && tempObject.compareTo(objectArray[j - 1]) < 0) {\n            objectArray[j] = objectArray[j - 1];\n            --j;\n        }\n        objectArray[j] = tempObject;\n    }\n}\n","name":"insertionSort","className":"ParallelMergeSort","variables":{"objectArray":5,"tempObject":3,"lowerIndex":2,"i":4,"upperIndex":1,"j":8},"constants":{"0":1,"1":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["int"],"returnType":"Double[]","methodCalls":{"random":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Double[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":13,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static Double[] createRandomData(int length) {\n    Double[] data = new Double[length];\n    for (int i = 0; i < data.length; i++) {\n        data[i] = length * Math.random();\n    }\n    return data;\n}\n","name":"createRandomData","className":"ParallelMergeSort","variables":{"data":3,"length":2,"i":4,"Math":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"availableProcessors":1,"createRandomData":1,"System.out.printf":2,"sort":1,"getRuntime":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Double[]":1,"Double":2,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":42,"StringLiteralExpr":5,"CastExpr":1,"FieldAccessExpr":5,"MethodCallExpr":9,"AssignExpr":1},"statements":{"BlockStmt":2,"ForeachStmt":2,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    int processors = Runtime.getRuntime().availableProcessors();\n    System.out.println(\"No of processors: \" + processors);\n    threadPool = new ForkJoinPool(processors);\n    Double[] data = createRandomData(1000);\n    System.out.println(\"Original unsorted data:\");\n    for (Double d : data) {\n        System.out.printf(\"%3.2f \", (double) d);\n    }\n    sort(data);\n    System.out.println(\"\\n\\nSorted Array:\");\n    for (Double d : data) {\n        System.out.printf(\"%3.2f \", d);\n    }\n}\n","name":"main","className":"ParallelMergeSort","variables":{"Runtime":1,"data":3,"d":3,"processors":3,"threadPool":1},"constants":{"\"%3.2f \"":2,"\"\\n\\nSorted Array:\"":1,"1000":1,"\"Original unsorted data:\"":1,"\"No of processors: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","int"],"returnType":"Exp","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Exp(double m, int n) {\n    this.m = m;\n    this.n = n;\n}\n","name":"Exp","className":"Exp","variables":{"m":1,"n":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Double","methodCalls":{"sleep":1,"printStackTrace":1,"System.out.printf":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"public Double call() {\n    double result = 1;\n    for (int i = 0; i < n; i++) {\n        result *= m;\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        }\n    }\n    System.out.printf(\"%nComputed %.02f raised to %d%n\", m, n);\n    return result;\n}\n","name":"call","className":"Exp","variables":{"result":3,"ex":2,"i":3,"m":1,"n":1,"Thread":1},"constants":{"0":1,"1":1,"\"%nComputed %.02f raised to %d%n\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"unlock":1,"newFixedThreadPool":1,"submit":1,"printStackTrace":1,"System.out.printf":2,"random":2,"take":1,"size":1,"get":1,"lock":1,"shutdown":1,"System.out.println":1},"annotations":[],"exceptions":["ExecutionException","InterruptedException"],"concepts":["Casting","PolyMorphism","ExceptionHandling"],"types":{"ReentrantLock":1,"ArrayList<Callable<Double>>":1,"double":1,"ExecutorService":1,"ExecutorCompletionService":1,"Double":1,"int":3,"Callable<Double>":1,"Lock":1},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":4,"VariableDeclarationExpr":10,"BinaryExpr":5,"NameExpr":62,"CastExpr":2,"StringLiteralExpr":4,"FieldAccessExpr":3,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":15},"statements":{"BlockStmt":6,"TryStmt":1,"ForeachStmt":1,"ForStmt":2,"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    ExecutorService executor = Executors.newFixedThreadPool(10);\n    ArrayList<Callable<Double>> tasks = new ArrayList<Callable<Double>>();\n    for (int i = 0; i < 10; i++) {\n        double m = Math.random() * 10;\n        int n = (int) (Math.random() * 1000);\n        System.out.printf(\"Created task for computing: \" + \"%.02f raised to %d\\n\", m, n);\n        tasks.add(new Exp(m, n));\n    }\n    ExecutorCompletionService service = new ExecutorCompletionService(executor);\n    for (Callable<Double> task : tasks) {\n        service.submit(task);\n    }\n    Lock lock = new ReentrantLock();\n    for (int i = 0; i < tasks.size(); i++) {\n        try {\n            lock.lock();\n            Double d = (Double) service.take().get();\n            System.out.printf(\"Result: %E%n\", d);\n            lock.unlock();\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        } catch (ExecutionException ex) {\n            System.out.println(\"Error detected during task execution\");\n        }\n    }\n    executor.shutdown();\n}\n","name":"main","className":"MultipleServices","variables":{"task":1,"ex":3,"d":1,"executor":3,"service":3,"i":6,"lock":3,"Executors":1,"Math":2,"m":2,"tasks":4,"n":2},"constants":{"0":2,"\"Result: %E%n\"":1,"\"%.02f raised to %d\\n\"":1,"1000":1,"\"Created task for computing: \"":1,"\"Error detected during task execution\"":1,"10":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":2,"sleep":1,"getDateTimeInstance":1,"printStackTrace":1,"getTime":1,"format":1,"getInstance":1,"setText":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"Calendar":1,"DateFormat":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BooleanLiteralExpr":2,"BinaryExpr":4,"NameExpr":37,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":10},"statements":{"BlockStmt":3,"TryStmt":1,"ExpressionStmt":8},"text":"public void run() {\n    {\n        try {\n            appFrame.setVisible(true);\n            scanNumber++;\n            Calendar cal = Calendar.getInstance();\n            DateFormat df = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.MEDIUM);\n            statusString.setText(\" Scan \" + scanNumber + \" started at \" + df.format(cal.getTime()));\n            Thread.sleep(1000 + new Random().nextInt(10000));\n            appFrame.setVisible(false);\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n","name":"run","className":"","variables":{"df":2,"ex":2,"appFrame":2,"scanNumber":2,"Calendar":1,"DateFormat":1,"statusString":1,"cal":2,"Thread":1},"constants":{"\" started at \"":1,"true":1,"1000":1,"10000":1,"false":1,"\" Scan \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"cancel":1,"dispose":1,"shutdown":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public void run() {\n    scanManager.cancel(true);\n    scheduler.shutdown();\n    appFrame.dispose();\n}\n","name":"run","className":"","variables":{"scheduler":1,"scanManager":1,"appFrame":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":2,"scheduleAtFixedRate":1,"cancel":1,"printStackTrace":1,"getTime":1,"format":1,"sleep":1,"schedule":1,"getDateTimeInstance":1,"dispose":1,"getInstance":1,"shutdown":1,"setText":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"Runnable":1,"Calendar":1,"DateFormat":1,"ScheduledFuture<?>":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":5,"VariableDeclarationExpr":4,"BooleanLiteralExpr":3,"BinaryExpr":4,"NameExpr":59,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":15},"statements":{"BlockStmt":5,"TryStmt":1,"ExpressionStmt":14},"text":"public void scanDisk() {\n    final Runnable scanner = new Runnable() {\n\n        public void run() {\n            {\n                try {\n                    appFrame.setVisible(true);\n                    scanNumber++;\n                    Calendar cal = Calendar.getInstance();\n                    DateFormat df = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.MEDIUM);\n                    statusString.setText(\" Scan \" + scanNumber + \" started at \" + df.format(cal.getTime()));\n                    Thread.sleep(1000 + new Random().nextInt(10000));\n                    appFrame.setVisible(false);\n                } catch (InterruptedException ex) {\n                    ex.printStackTrace();\n                }\n            }\n        }\n    };\n    final ScheduledFuture<?> scanManager = scheduler.scheduleAtFixedRate(scanner, 1, 15, SECONDS);\n    scheduler.schedule(new Runnable() {\n\n        public void run() {\n            scanManager.cancel(true);\n            scheduler.shutdown();\n            appFrame.dispose();\n        }\n    }, 60, SECONDS);\n}\n","name":"scanDisk","className":"VirusScanner","variables":{"df":2,"scanManager":2,"Calendar":1,"run":2,"cal":2,"Thread":1,"scheduler":3,"ex":2,"appFrame":3,"scanNumber":2,"DateFormat":1,"statusString":1,"scanner":1},"constants":{"1":1,"15":1,"\" started at \"":1,"true":2,"1000":1,"10000":1,"false":1,"60":1,"\" Scan \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"getDefaultToolkit":1,"setLocation":1,"getWidth":2,"getScreenSize":1,"scanDisk":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Dimension":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":35,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":9},"statements":{"ExpressionStmt":8},"text":"public static void main(String args[]) {\n    appFrame = new JFrame();\n    Dimension dimension = Toolkit.getDefaultToolkit().getScreenSize();\n    appFrame.setSize(400, 70);\n    appFrame.setLocation(dimension.width / 2 - appFrame.getWidth() / 2, dimension.height / 2 - appFrame.getWidth() / 2);\n    statusString = new JLabel();\n    appFrame.add(statusString);\n    appFrame.setVisible(false);\n    app.scanDisk();\n}\n","name":"main","className":"VirusScanner","variables":{"app":1,"appFrame":7,"statusString":1,"Toolkit":1,"dimension":1},"constants":{"2":4,"400":1,"false":1,"70":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":1,"writeObject":1,"getCreditCard":2,"getId":2,"close":2,"System.out.println":4,"readObject":1},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"Customer":1,"ObjectOutputStream":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":6,"StringLiteralExpr":9,"NameExpr":49,"CastExpr":1,"FieldAccessExpr":4,"MethodCallExpr":13,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":12},"text":"public static void main(String args[]) throws IOException {\n    try {\n        Customer customer = new Customer(1, \"1234-5678-9876\");\n        System.out.println(\"Before saving object: \");\n        System.out.println(\"ID:\" + customer.getId() + \" CC:\" + customer.getCreditCard());\n        ObjectOutputStream outStream = new ObjectOutputStream(new FileOutputStream(\"customer.dat\"));\n        outStream.writeObject(customer);\n        outStream.close();\n        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"customer.dat\"));\n        customer = (Customer) inputStream.readObject();\n        System.out.println(\"After retrieving object: \");\n        System.out.println(\"ID:\" + customer.getId() + \" CC:\" + customer.getCreditCard());\n        inputStream.close();\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"main","className":"ExternalizableTestApp","variables":{"ex":2,"inputStream":3,"outStream":3,"customer":6},"constants":{"1":1,"\" CC:\"":2,"\"ID:\"":2,"\"After retrieving object: \"":1,"\"customer.dat\"":2,"\"1234-5678-9876\"":1,"\"Before saving object: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getCreditCard() {\n    return creditCard;\n}\n","name":"getCreditCard","className":"Customer","variables":{"creditCard":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getId() {\n    return id;\n}\n","name":"getId","className":"Customer","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Customer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":2,"StringLiteralExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Customer() {\n    id = 0;\n    creditCard = \"\";\n}\n","name":"Customer","className":"Customer","variables":{"id":1,"creditCard":1},"constants":{"0":1,"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","String"],"returnType":"Customer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Customer(int id, String ccNumber) {\n    this.id = id;\n    this.creditCard = ccNumber;\n}\n","name":"Customer","className":"Customer","variables":{"ccNumber":1,"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ObjectOutput"],"returnType":"void","methodCalls":{"printStackTrace":1,"encrypt":1,"writeUTF":1,"write":1,"System.out.println":2},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":25,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":6},"text":"public void writeExternal(ObjectOutput out) throws IOException {\n    try {\n        out.write(id);\n        encrypt();\n        out.writeUTF(creditCard);\n        System.out.println(\"After encryption: \");\n        System.out.println(\"ID:\" + id + \" CC:\" + creditCard);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"writeExternal","className":"Customer","variables":{"ex":2,"id":1,"creditCard":1,"out":2},"constants":{"\" CC:\"":1,"\"ID:\"":1,"\"After encryption: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ObjectInput"],"returnType":"void","methodCalls":{"read":1,"readUTF":1,"printStackTrace":1,"decrypt":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException","Exception"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":13,"AssignExpr":1,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n    try {\n        id = in.read();\n        String str = in.readUTF();\n        decrypt(str);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}\n","name":"readExternal","className":"Customer","variables":{"str":1,"ex":2,"in":2,"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"generateKey":1,"init":1,"getEncoded":1,"getInstance":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"byte[]":1,"SecretKey":1,"KeyGenerator":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"NameExpr":18,"StringLiteralExpr":3,"MethodCallExpr":5,"AssignExpr":2},"statements":{"ExpressionStmt":6},"text":"private static void createCipher() throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    kgen.init(128);\n    // Generate the secret key specs.\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    skeySpec = new SecretKeySpec(raw, \"AES\");\n    // Instantiate the cipher\n    cipher = Cipher.getInstance(\"AES\");\n}\n","name":"createCipher","className":"Customer","variables":{"cipher":1,"kgen":3,"skey":2,"raw":2,"Cipher":1,"skeySpec":1,"KeyGenerator":1},"constants":{"128":1,"\"AES\"":3},"javaDoc":"","comments":"Generate the secret key specs Instantiate the cipher ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"init":1,"getBytes":1,"doFinal":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"byte[]":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":15,"FieldAccessExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"private void encrypt() throws Exception {\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] buff = cipher.doFinal(creditCard.getBytes());\n    creditCard = new String(buff);\n}\n","name":"encrypt","className":"Customer","variables":{"cipher":2,"creditCard":2,"buff":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"init":1,"getBytes":1,"doFinal":1},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"byte[]":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":15,"FieldAccessExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"private void decrypt(String str) throws Exception {\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] buff = cipher.doFinal(str.getBytes());\n    creditCard = new String(buff);\n}\n","name":"decrypt","className":"Customer","variables":{"cipher":2,"str":1,"creditCard":1,"buff":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"login":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"ConsoleApp":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    ConsoleApp app = new ConsoleApp();\n    if (app.login()) {\n        System.out.println(\"Thanks for logging in!\");\n    } else {\n        System.out.println(\"Login failed!\");\n    }\n}\n","name":"main","className":"ConsoleApp","variables":{"app":2},"constants":{"\"Thanks for logging in!\"":1,"\"Login failed!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"console":1,"authenticate":1,"readPassword":1,"writer":1,"fill":1,"write":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Console":1,"int":1,"char[]":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":1,"BinaryExpr":3,"NameExpr":24,"StringLiteralExpr":3,"CharLiteralExpr":1,"UnaryExpr":2,"MethodCallExpr":6,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":7,"DoStmt":1},"text":"private boolean login() {\n    Console console = System.console();\n    boolean isAuthenticated = false;\n    if (console != null) {\n        int count = 0;\n        do {\n            char[] pwd = console.readPassword(\"[%s]\", \"Password:\");\n            isAuthenticated = authenticate(pwd);\n            // delete password from memory\n            Arrays.fill(pwd, ' ');\n            console.writer().write(\"\\n\");\n        } while (!isAuthenticated && ++count < MAX_LOGINS);\n    }\n    return isAuthenticated;\n}\n","name":"login","className":"ConsoleApp","variables":{"console":4,"count":2,"isAuthenticated":4,"pwd":1,"Arrays":1,"MAX_LOGINS":1,"System":1},"constants":{"0":1,"\"Password:\"":1,"null":1,"\"[%s]\"":1,"false":1,"' '":1,"\"\\n\"":1},"javaDoc":"","comments":"delete password from memory ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["char[]"],"returnType":"boolean","methodCalls":{"java.util.Arrays.fill":1,"java.util.Arrays.equals":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"char[]":1},"expressions":{"VariableDeclarationExpr":1,"ArrayInitializerExpr":1,"BooleanLiteralExpr":2,"NameExpr":27,"StringLiteralExpr":2,"CharLiteralExpr":11,"FieldAccessExpr":6,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":4},"text":"private boolean authenticate(char[] passwd) {\n    char[] secret = { 'M', 'c', 'G', 'R', 'A', 'W', 'H', 'I', 'L', 'L' };\n    if (java.util.Arrays.equals(passwd, secret)) {\n        java.util.Arrays.fill(passwd, ' ');\n        System.out.println(\"Authenticated\\n\");\n        return true;\n    } else {\n        System.out.println(\"Authentication failed\\n\");\n    }\n    return false;\n}\n","name":"authenticate","className":"ConsoleApp","variables":{"secret":1},"constants":{"'M'":1,"'L'":2,"'I'":1,"'H'":1,"'G'":1,"false":1,"'c'":1,"\"Authenticated\\n\"":1,"'A'":1,"' '":1,"\"Authentication failed\\n\"":1,"'W'":1,"true":1,"'R'":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"writeObject":1,"System.out.println":5,"readObject":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Line":1,"ObjectOutputStream":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":35,"StringLiteralExpr":7,"CastExpr":1,"FieldAccessExpr":5,"MethodCallExpr":7,"AssignExpr":1},"statements":{"TryStmt":2,"BlockStmt":5,"ExpressionStmt":8},"text":"public static void main(String args[]) {\n    Line line = new Line();\n    System.out.println(\"Before saving object:\\n\" + line);\n    try (ObjectOutputStream outStream = new ObjectOutputStream(new FileOutputStream(\"graph.dat\"))) {\n        outStream.writeObject(line);\n    } catch (IOException ex) {\n        System.out.println(\"Error writing object\");\n    }\n    try (ObjectInputStream inStream = new ObjectInputStream(new FileInputStream(\"graph.dat\"))) {\n        line = (Line) inStream.readObject();\n    } catch (IOException ioe) {\n        System.out.println(\"Error reading object\");\n    } catch (ClassNotFoundException cfe) {\n        System.out.println(\"Casting error\");\n    }\n    System.out.println(\"\\nAfter retrieving object:\\n\" + line);\n}\n","name":"main","className":"NestedObjectsApp","variables":{"ex":1,"cfe":1,"line":4,"inStream":2,"outStream":2,"ioe":1},"constants":{"\"Before saving object:\\n\"":1,"\"Error reading object\"":1,"\"\\nAfter retrieving object:\\n\"":1,"\"Error writing object\"":1,"\"Casting error\"":1,"\"graph.dat\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"Point","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n}\n","name":"Point","className":"Point","variables":{"x":1,"y":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","Color"],"returnType":"ColorPoint","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"public ColorPoint(int x, int y, Color color) {\n    super(x, y);\n    this.color = color;\n}\n","name":"ColorPoint","className":"ColorPoint","variables":{"color":1,"x":1,"y":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":9,"StringLiteralExpr":5,"NameExpr":3,"CharLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"@Override\npublic String toString() {\n    return \"Point{\" + \"x=\" + x + \" y=\" + y + '}' + \" ColorPoint{\" + \"color=\" + color + '}';\n}\n","name":"toString","className":"ColorPoint","variables":{"color":1,"x":1,"y":1},"constants":{"'}'":2,"\" ColorPoint{\"":1,"\"color=\"":1,"\"Point{\"":1,"\"x=\"":1,"\" y=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"@Override\npublic String toString() {\n    return \"StartPoint=\" + startPoint + \"\\nEndPoint=\" + endPoint;\n}\n","name":"toString","className":"Line","variables":{"endPoint":1,"startPoint":1},"constants":{"\"StartPoint=\"":1,"\"\\nEndPoint=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toString":1,"readObject":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"Product":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"StringLiteralExpr":1,"CastExpr":1,"NameExpr":11,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public static void main(String args[]) throws Exception {\n    ObjectInputStream is = new ObjectInputStream(new FileInputStream(\"product.dat\"));\n    Product p1 = (Product) is.readObject();\n    System.out.println(p1.toString());\n}\n","name":"main","className":"ProductReader","variables":{"p1":2,"is":2},"constants":{"\"product.dat\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"createFileList":1,"getFileNames":1,"mergeFiles":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"FileMerger":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":12,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"public static void main(String args[]) throws IOException {\n    FileMerger app = new FileMerger();\n    app.getFileNames();\n    if (!app.createFileList()) {\n        System.exit(0);\n    }\n    app.mergeFiles();\n}\n","name":"main","className":"FileMerger","variables":{"app":4,"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"equals":1,"readLine":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"StringLiteralExpr":4,"NameExpr":24,"FieldAccessExpr":3,"EnclosedExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BreakStmt":1,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":6},"text":"private void getFileNames() {\n    String fileName = \"\";\n    System.out.println(\"Enter file names (one on a line): \");\n    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n    while (true) {\n        try {\n            fileName = reader.readLine();\n        } catch (IOException e) {\n            System.out.println(\"Error reading keyboard\");\n        }\n        if ((fileName.equals(\"over\"))) {\n            break;\n        }\n        listOfFileNames.add(fileName);\n    }\n}\n","name":"getFileNames","className":"FileMerger","variables":{"fileName":3,"e":1,"reader":2,"listOfFileNames":1},"constants":{"\"\"":1,"\"Enter file names (one on a line): \"":1,"\"Error reading keyboard\"":1,"\"over\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"add":1,"hasMoreElements":1,"elements":1,"nextElement":1,"System.out.println":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["Casting","ExceptionHandling"],"types":{"Enumeration":1,"InputStream":1,"String":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":21,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"private boolean createFileList() {\n    Enumeration list = listOfFileNames.elements();\n    while (list.hasMoreElements()) {\n        String fileName = (String) list.nextElement();\n        InputStream inputStream = null;\n        try {\n            inputStream = new FileInputStream(fileName);\n        } catch (FileNotFoundException fe) {\n            System.out.println(\"File not found: \" + fileName);\n        }\n        fileList.add(inputStream);\n    }\n    return true;\n}\n","name":"createFileList","className":"FileMerger","variables":{"fileName":3,"listOfFileNames":1,"inputStream":2,"list":3,"fileList":1,"fe":1},"constants":{"\"File not found: \"":1,"null":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"elements":1,"write":1,"System.out.println":2},"annotations":[],"exceptions":["FileNotFoundException","IOException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"byte[]":1,"SequenceInputStream":1,"FileOutputStream":1,"OutputStream":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":2,"StringLiteralExpr":4,"NameExpr":23,"FieldAccessExpr":2,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"private void mergeFiles() throws FileNotFoundException {\n    try (OutputStream outStream = new FileOutputStream(\"monthlyDataFile.txt\");\n        SequenceInputStream inputStream = new SequenceInputStream(fileList.elements())) {\n        byte[] buffer = new byte[4096];\n        int numberRead = 0;\n        while ((numberRead = inputStream.read(buffer)) != -1) {\n            outStream.write(buffer, 0, numberRead);\n        }\n    } catch (IOException e) {\n        System.out.println(\"Error reading/writing file\");\n    }\n    System.out.println(\"Created monthlyDataFile.txt \" + \"in your current folder\");\n}\n","name":"mergeFiles","className":"FileMerger","variables":{"numberRead":2,"e":1,"inputStream":2,"buffer":1,"outStream":2,"fileList":1},"constants":{"0":2,"4096":1,"1":1,"\"Error reading/writing file\"":1,"\"in your current folder\"":1,"\"monthlyDataFile.txt\"":1,"\"Created monthlyDataFile.txt \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"writeObject":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"Product":1,"ObjectOutputStream":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"StringLiteralExpr":1,"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public static void main(String args[]) throws IOException {\n    Product p1 = new Product(100);\n    ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"product.dat\"));\n    os.writeObject(p1);\n    os.close();\n}\n","name":"main","className":"ProductWriter","variables":{"p1":1,"os":3},"constants":{"100":1,"\"product.dat\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["float"],"returnType":"Product","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":5,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"ThisExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Product(float price) {\n    this.price = price;\n    tax = (float) (price * 0.20);\n}\n","name":"Product","className":"Product","variables":{"price":2,"tax":1},"constants":{"0.20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createData":1,"readData":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"LiveData":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String args[]) throws IOException {\n    LiveData app = new LiveData();\n    app.createData();\n    app.readData();\n}\n","name":"main","className":"LiveData","variables":{"app":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"writeInt":1,"writeLong":1,"write":1,"writeDouble":4,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Trade":1,"DataOutputStream":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":52,"StringLiteralExpr":1,"FieldAccessExpr":8,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":8},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":11},"text":"public void createData() {\n    try {\n        outStream = new ByteArrayOutputStream();\n        DataOutputStream writer = new DataOutputStream(outStream);\n        for (int i = 0; i < 10; i++) {\n            Trade lastTrade = new Trade(i);\n            writer.writeInt(lastTrade.scripCode);\n            writer.write(lastTrade.time);\n            writer.writeDouble(lastTrade.bid);\n            writer.writeDouble(lastTrade.offer);\n            writer.writeDouble(lastTrade.high);\n            writer.writeDouble(lastTrade.low);\n            writer.writeLong(lastTrade.quantity);\n        }\n    } catch (Exception e) {\n        System.out.println(\"Error while writing data to buffer\");\n    }\n}\n","name":"createData","className":"LiveData","variables":{"e":1,"i":4,"lastTrade":1,"writer":8,"outStream":2},"constants":{"0":1,"\"Error while writing data to buffer\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"readLong":1,"readDouble":4,"toByteArray":1,"format":1,"length":1,"readInt":1,"delete":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"StringBuilder":1,"ByteArrayInputStream":1,"Formatter":1,"double":4,"String":1,"DataInputStream":1,"int":2,"long":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":5,"VariableDeclarationExpr":13,"BinaryExpr":7,"NameExpr":60,"StringLiteralExpr":8,"FieldAccessExpr":3,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":13},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":17},"text":"private void readData() {\n    byte[] timeBuffer = new byte[8];\n    StringBuilder sb = new StringBuilder();\n    Formatter formatter = new Formatter(sb, Locale.US);\n    ByteArrayInputStream inStream = new ByteArrayInputStream(outStream.toByteArray());\n    DataInputStream reader = new DataInputStream(inStream);\n    try {\n        for (int i = 0; i < 10; i++) {\n            int scripCode = reader.readInt();\n            reader.read(timeBuffer);\n            String time = new String(timeBuffer);\n            double bid = reader.readDouble();\n            double offer = reader.readDouble();\n            double high = reader.readDouble();\n            double low = reader.readDouble();\n            long volume = reader.readLong();\n            formatter.format(\"ScripCode: %2d\" + \"\\tTime: %s \" + \"\\tBid:$ %05.2f\" + \"\\tOffer:$ %05.2f\" + \"\\tHigh:$ %05.2f\" + \"\\tLow:$ %05.2f\" + \"\\tVolume: %d\", scripCode, time, bid, offer, high, low, volume);\n            System.out.println(sb);\n            sb.delete(0, sb.length());\n        }\n    } catch (Exception e) {\n        System.out.println(\"Error while reading data\");\n    }\n}\n","name":"readData","className":"LiveData","variables":{"timeBuffer":2,"e":1,"inStream":2,"reader":8,"i":3,"outStream":1,"sb":4,"formatter":2,"offer":1,"volume":1,"high":1,"low":1,"scripCode":1,"time":1,"bid":1},"constants":{"0":2,"\"\\tTime: %s \"":1,"\"\\tHigh:$ %05.2f\"":1,"\"Error while reading data\"":1,"\"\\tLow:$ %05.2f\"":1,"\"\\tOffer:$ %05.2f\"":1,"\"\\tVolume: %d\"":1,"8":1,"\"ScripCode: %2d\"":1,"\"\\tBid:$ %05.2f\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int"],"returnType":"Trade","methodCalls":{"random":5,"now":1,"getBytes":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":6,"BinaryExpr":6,"NameExpr":27,"StringLiteralExpr":1,"CastExpr":1,"EnclosedExpr":1,"AssignExpr":7,"MethodCallExpr":7},"statements":{"ExpressionStmt":7},"text":"public Trade(int i) {\n    scripCode = i + 1;\n    time = now(\"hh:mm:ss\").getBytes();\n    bid = Math.random() * 100;\n    offer = Math.random() * 100;\n    high = Math.random() * 100;\n    low = Math.random() * 100;\n    quantity = (long) (Math.random() * 100000000);\n}\n","name":"Trade","className":"Trade","variables":{"offer":1,"high":1,"quantity":1,"low":1,"scripCode":1,"i":1,"time":1,"bid":1,"Math":5},"constants":{"1":1,"100":4,"100000000":1,"\"hh:mm:ss\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"getTime":1,"format":1,"getInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Calendar":1,"SimpleDateFormat":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":10,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"private String now(String dateFormat) {\n    Calendar cal = Calendar.getInstance();\n    SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);\n    return sdf.format(cal.getTime());\n}\n","name":"now","className":"Trade","variables":{"sdf":2,"dateFormat":1,"Calendar":1,"cal":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readAndPrint":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"PrintCalc":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public static void main(String args[]) {\n    PrintCalc app = new PrintCalc();\n    try {\n        app.readAndPrint();\n    } catch (IOException e) {\n        System.out.println(\"Error encountered during printing\");\n    }\n}\n","name":"main","className":"PrintCalc","variables":{"app":2,"e":1},"constants":{"\"Error encountered during printing\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":3,"unread":3,"close":1,"System.out.print":3},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"PushbackInputStream":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":48,"CastExpr":2,"StringLiteralExpr":1,"FieldAccessExpr":4,"CharLiteralExpr":4,"EnclosedExpr":3,"AssignExpr":3,"MethodCallExpr":10},"statements":{"SwitchStmt":1,"IfStmt":2,"WhileStmt":1,"BreakStmt":2,"BlockStmt":5,"SwitchEntryStmt":2,"ExpressionStmt":9},"text":"private void readAndPrint() throws IOException {\n    PushbackInputStream f = new PushbackInputStream(System.in, 3);\n    int c, c1, c2;\n    while ((c = f.read()) != 'q') {\n        switch(c) {\n            case '.':\n                System.out.print((char) c);\n                if ((c1 = f.read()) == '0') {\n                    if ((c2 = f.read()) == '0') {\n                        System.out.print(\"**\");\n                    } else {\n                        f.unread(c2);\n                        f.unread(c1);\n                    }\n                } else {\n                    f.unread(c1);\n                }\n                break;\n            default:\n                System.out.print((char) c);\n                break;\n        }\n    }\n    f.close();\n}\n","name":"readAndPrint","className":"PrintCalc","variables":{"c":5,"f":8,"c1":2,"c2":2},"constants":{"'.'":1,"\"**\"":1,"3":1,"'q'":1,"'0'":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"parseFile":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"WordAndNumberParser":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":15,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"public static void main(String args[]) throws IOException {\n    if (args.length < 1) {\n        System.out.println(\"Usage: java WordAndNumberParser <filename>\");\n        System.exit(0);\n    }\n    WordAndNumberParser app = new WordAndNumberParser();\n    app.parseFile(args[0]);\n}\n","name":"main","className":"WordAndNumberParser","variables":{"app":2,"args":1,"System":1},"constants":{"0":2,"1":1,"\"Usage: java WordAndNumberParser <filename>\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"slashStarComments":1,"nextToken":1,"slashSlashComments":1,"tokenizer.sval.equals":1,"toString":1,"System.out.println":5},"annotations":[],"exceptions":["FileNotFoundException","IOException"],"concepts":["ExceptionHandling"],"types":{"FileReader":1,"int":2,"StreamTokenizer":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"BooleanLiteralExpr":2,"BinaryExpr":8,"NameExpr":67,"StringLiteralExpr":5,"FieldAccessExpr":12,"UnaryExpr":2,"MethodCallExpr":10},"statements":{"IfStmt":3,"WhileStmt":1,"TryStmt":1,"BlockStmt":7,"ReturnStmt":1,"ExpressionStmt":12},"text":"private void parseFile(String fileName) {\n    int wordCount = 0;\n    int numberCount = 0;\n    try (FileReader reader = new FileReader(fileName)) {\n        StreamTokenizer tokenizer = new StreamTokenizer(reader);\n        tokenizer.slashSlashComments(true);\n        tokenizer.slashStarComments(true);\n        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) {\n            if (tokenizer.ttype == StreamTokenizer.TT_WORD) {\n                wordCount++;\n            } else if (tokenizer.ttype == StreamTokenizer.TT_NUMBER) {\n                numberCount++;\n            }\n            if (tokenizer.sval != null && tokenizer.sval.equals(\"DataInputStream\")) {\n                System.out.println(tokenizer.toString());\n            }\n        }\n    } catch (FileNotFoundException fe) {\n        System.out.println(\"File not found: \" + fileName);\n        return;\n    } catch (IOException ioe) {\n        System.out.println(\"Error parsing file\");\n    }\n    System.out.println(\"Number of words: \" + wordCount);\n    System.out.println(\"Number of numerals: \" + numberCount);\n}\n","name":"parseFile","className":"WordAndNumberParser","variables":{"fileName":2,"wordCount":3,"reader":2,"numberCount":3,"ioe":1,"tokenizer":5,"fe":1},"constants":{"0":2,"\"Number of words: \"":1,"\"File not found: \"":1,"null":1,"\"DataInputStream\"":1,"\"Number of numerals: \"":1,"\"Error parsing file\"":1,"true":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"double","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":7,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"double getDistance() {\n    return (Math.sqrt(x * x + y * y));\n}\n","name":"getDistance","className":"Point","variables":{"x":2,"y":2,"Math":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getDistance":2,"format":2,"length":1,"delete":1,"System.out.println":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuilder":1,"double":1,"Formatter":1,"Point":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":5,"VariableDeclarationExpr":5,"BinaryExpr":8,"NameExpr":86,"StringLiteralExpr":10,"FieldAccessExpr":16,"MethodCallExpr":13,"AssignExpr":5},"statements":{"ExpressionStmt":20},"text":"public static void main(String[] args) {\n    System.out.println(\"Creating a Point object ... \");\n    Point p1 = new Point();\n    System.out.println(\"Initializing object ...\");\n    p1.x = 3;\n    p1.y = 4;\n    double distance = p1.getDistance();\n    StringBuilder sb = new StringBuilder();\n    Formatter formatter = new Formatter(sb, Locale.US);\n    formatter.format(\"Distance of Point p1(\" + p1.x + \",\" + p1.y + \") from origin is %.02f\", distance);\n    System.out.println(sb);\n    System.out.println();\n    sb.delete(0, sb.length());\n    System.out.println(\"Creating another Point object ... \");\n    Point p2 = new Point();\n    System.out.println(\"Initializing object ...\");\n    p2.x = 8;\n    p2.y = 9;\n    distance = p2.getDistance();\n    formatter.format(\"Distance of Point p2(\" + p2.x + \",\" + p2.y + \") from origin is %.02f\", distance);\n    System.out.println(sb);\n}\n","name":"main","className":"TestPoint","variables":{"formatter":3,"p1":2,"p2":2,"distance":2,"sb":4},"constants":{"\") from origin is %.02f\"":2,"0":1,"3":1,"4":1,"\"Creating another Point object ... \"":1,"\",\"":2,"8":1,"9":1,"\"Initializing object ...\"":2,"\"Distance of Point p2(\"":1,"\"Creating a Point object ... \"":1,"\"Distance of Point p1(\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Point","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Point() {\n    x = 10;\n    y = 10;\n}\n","name":"Point","className":"Point","variables":{"x":1,"y":1},"constants":{"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getX() {\n    return x;\n}\n","name":"getX","className":"Point","variables":{"x":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getY() {\n    return y;\n}\n","name":"getY","className":"Point","variables":{"y":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Point":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":21,"StringLiteralExpr":5,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    System.out.println(\"Creating a Point object ... \");\n    Point p = new Point();\n    System.out.println(\"\\nPrinting Point object\");\n    System.out.println(\"Point p (\" + p.getX() + \", \" + p.getY() + \")\");\n}\n","name":"main","className":"CustomConstructorApp","variables":{"p":3},"constants":{"\"\\nPrinting Point object\"":1,"\"Creating a Point object ... \"":1,"\")\"":1,"\"Point p (\"":1,"\", \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Point":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":32,"StringLiteralExpr":6,"FieldAccessExpr":8,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    System.out.println(\"Creating a Point object ... \");\n    Point p = new Point();\n    System.out.println(\"Initializing data members ...\");\n    p.x = 4;\n    p.y = 5;\n    System.out.println(\"Printing object\");\n    System.out.println(\"Point p (\" + p.x + \", \" + p.y + \")\");\n}\n","name":"main","className":"TestPoint","variables":{"p":1},"constants":{"\"Printing object\"":1,"4":1,"5":1,"\"Creating a Point object ... \"":1,"\")\"":1,"\"Point p (\"":1,"\", \"":1,"\"Initializing data members ...\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["float"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setMoney(float money) {\n    this.money = money;\n}\n","name":"setMoney","className":"Wallet","variables":{"money":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"public boolean pullOutMoney(float amount) {\n    if (money >= amount) {\n        money -= amount;\n        return true;\n    }\n    return false;\n}\n","name":"pullOutMoney","className":"Wallet","variables":{"amount":2,"money":2},"constants":{"true":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setMoney":1,"pullOutMoney":3,"System.out.println":10},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Wallet":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"NameExpr":67,"StringLiteralExpr":10,"FieldAccessExpr":10,"MethodCallExpr":14,"AssignExpr":2},"statements":{"IfStmt":3,"BlockStmt":6,"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    Wallet wallet = new Wallet();\n    System.out.println(\"Putting $500 in the wallet\\n\");\n    wallet.setMoney(500);\n    System.out.println(\"Pulling out $100 ...\");\n    boolean isMoneyInWallet = wallet.pullOutMoney(100);\n    if (isMoneyInWallet) {\n        System.out.println(\"Got it!\");\n    } else {\n        System.out.println(\"Nope, not enough money\");\n    }\n    System.out.println(\"\\nPulling out $300 ...\");\n    isMoneyInWallet = wallet.pullOutMoney(300);\n    if (isMoneyInWallet) {\n        System.out.println(\"Got it!\");\n    } else {\n        System.out.println(\"Nope, not enough money\");\n    }\n    System.out.println(\"\\nPulling out $200 ...\");\n    isMoneyInWallet = wallet.pullOutMoney(200);\n    if (isMoneyInWallet) {\n        System.out.println(\"Got it!\");\n    } else {\n        System.out.println(\"Nope, not enough money\");\n    }\n}\n","name":"main","className":"Person","variables":{"wallet":5,"isMoneyInWallet":6},"constants":{"100":1,"\"Pulling out $100 ...\"":1,"\"\\nPulling out $200 ...\"":1,"200":1,"300":1,"\"Putting $500 in the wallet\\n\"":1,"500":1,"\"Got it!\"":3,"\"\\nPulling out $300 ...\"":1,"\"Nope, not enough money\"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MyFrame":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    MyFrame frame = new MyFrame(\"Integer Adder\");\n    frame.setVisible(true);\n    frame.setSize(500, 100);\n}\n","name":"main","className":"TextFieldDemo","variables":{"frame":3},"constants":{"100":1,"\"Integer Adder\"":1,"500":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"MyFrame","methodCalls":{"add":8,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":2,"NameExpr":40,"StringLiteralExpr":4,"FieldAccessExpr":4,"ThisExpr":4,"MethodCallExpr":11},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":11},"text":"public MyFrame(String str) {\n    super(str);\n    this.setLayout(new GridLayout(2, 4));\n    add(new JLabel(\"Number1\", JLabel.CENTER));\n    add(new JLabel(\"Number2\", JLabel.CENTER));\n    add(new JLabel(\"Operator\", JLabel.CENTER));\n    add(new JLabel(\"Result\", JLabel.CENTER));\n    add(number1);\n    add(number2);\n    add(adder);\n    add(result);\n    adder.addActionListener(this);\n    this.addWindowListener(this);\n}\n","name":"MyFrame","className":"MyFrame","variables":{"str":1,"adder":1},"constants":{"2":1,"\"Operator\"":1,"4":1,"\"Result\"":1,"\"Number2\"":1,"\"Number1\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"parseInt":2,"getSource":1,"getText":2,"valueOf":1,"equals":1,"getMessage":1,"setText":1,"System.out.println":1},"annotations":[],"exceptions":["NumberFormatException"],"concepts":["ExceptionHandling"],"types":{"int":3},"expressions":{"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":35,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":10},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent evt) {\n    if (evt.getSource().equals(adder)) {\n        try {\n            int num1 = Integer.parseInt(number1.getText());\n            int num2 = Integer.parseInt(number2.getText());\n            int answer = num1 + num2;\n            result.setText(String.valueOf(answer));\n        } catch (NumberFormatException ne) {\n            System.out.println(\"Number parsing error \" + ne.getMessage());\n        }\n    }\n}\n","name":"actionPerformed","className":"MyFrame","variables":{"Integer":2,"result":1,"evt":1,"answer":1,"ne":2,"num1":2,"number1":1,"number2":1,"String":1,"num2":2},"constants":{"\"Number parsing error \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowActivated(WindowEvent e) {\n}\n","name":"windowActivated","className":"MyFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowClosed(WindowEvent e) {\n}\n","name":"windowClosed","className":"MyFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"MyFrame","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowDeactivated(WindowEvent e) {\n}\n","name":"windowDeactivated","className":"MyFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowDeiconified(WindowEvent e) {\n}\n","name":"windowDeiconified","className":"MyFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowIconified(WindowEvent e) {\n}\n","name":"windowIconified","className":"MyFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowOpened(WindowEvent e) {\n}\n","name":"windowOpened","className":"MyFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MyFrame":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    MyFrame frame = new MyFrame(\"Button Demo\");\n    frame.setSize(200, 200);\n    frame.setVisible(true);\n}\n","name":"main","className":"ButtonDemo","variables":{"frame":3},"constants":{"200":2,"\"Button Demo\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"MyFrame","methodCalls":{"add":3,"addActionListener":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":16,"StringLiteralExpr":3,"ThisExpr":2,"MethodCallExpr":5},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":5},"text":"public MyFrame(String str) {\n    super(str);\n    add(messageButton, \"North\");\n    add(closeButton, \"South\");\n    add(label, \"Center\");\n    messageButton.addActionListener(this);\n    closeButton.addActionListener(this);\n}\n","name":"MyFrame","className":"MyFrame","variables":{"str":1,"messageButton":1,"closeButton":1},"constants":{"\"North\"":1,"\"Center\"":1,"\"South\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setVisible":2,"exit":1,"getSource":2,"getText":1,"equals":3,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":2,"NameExpr":32,"StringLiteralExpr":3,"MethodCallExpr":11},"statements":{"IfStmt":3,"BlockStmt":4,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent evt) {\n    if (evt.getSource().equals(messageButton)) {\n        if (messageButton.getText().equals(\"Show\")) {\n            label.setVisible(true);\n            messageButton.setText(\"Hide\");\n        } else {\n            label.setVisible(false);\n            messageButton.setText(\"Show\");\n        }\n    } else if (evt.getSource().equals(closeButton)) {\n        System.exit(0);\n    }\n}\n","name":"actionPerformed","className":"MyFrame","variables":{"evt":2,"messageButton":3,"label":2,"System":1},"constants":{"0":1,"\"Hide\"":1,"\"Show\"":2,"true":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MyFrame":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    MyFrame frame = new MyFrame(\"List Demo\");\n    frame.setBounds(20, 50, 400, 300);\n    frame.setVisible(true);\n}\n","name":"main","className":"ListDemoApp","variables":{"frame":3},"constants":{"300":1,"400":1,"true":1,"50":1,"\"List Demo\"":1,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"MyFrame","methodCalls":{"add":7,"addActionListener":2,"setSelectionMode":1,"setLayout":1,"createTitledBorder":2,"addWindowListener":1,"exit":1,"setSelectionForeground":2,"setBorder":2,"setSelectionBackground":2,"createLineBorder":2,"setModel":1,"addElement":8,"setSelectedIndex":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"JPanel":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":16,"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":137,"StringLiteralExpr":12,"FieldAccessExpr":9,"ThisExpr":3,"MethodCallExpr":34,"AssignExpr":3},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":34},"text":"public MyFrame(String title) {\n    super(title);\n    addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    sourceModel = new DefaultListModel();\n    sourceModel.addElement(\"Banana\");\n    sourceModel.addElement(\"Apple\");\n    sourceModel.addElement(\"Orange\");\n    sourceModel.addElement(\"Mango\");\n    sourceModel.addElement(\"Pineapple\");\n    sourceModel.addElement(\"Kiwi\");\n    sourceModel.addElement(\"Strawberry\");\n    sourceModel.addElement(\"Peach\");\n    source = new JList(sourceModel);\n    source.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    source.setBorder(BorderFactory.createTitledBorder(BorderFactory.createLineBorder(Color.DARK_GRAY, 5), \"\" + \"Shop\", 0, 0, null, Color.RED));\n    source.setSelectedIndex(0);\n    source.setSelectionBackground(Color.BLACK);\n    source.setSelectionForeground(Color.WHITE);\n    destModel = new DefaultListModel();\n    dest.setModel(destModel);\n    dest.setSelectionBackground(Color.BLACK);\n    dest.setSelectionForeground(Color.WHITE);\n    dest.setBorder(BorderFactory.createTitledBorder(BorderFactory.createLineBorder(Color.DARK_GRAY, 5), \"\" + \"Fruit Basket\", 0, 0, null, Color.RED));\n    // Building GUI\n    JPanel panel = new JPanel();\n    panel.setLayout(new GridLayout(4, 1, 20, 20));\n    panel.add(new JLabel());\n    panel.add(addButton);\n    panel.add(removeButton);\n    panel.add(new JLabel());\n    this.setLayout(new GridLayout(1, 3, 20, 20));\n    add(source);\n    add(panel);\n    add(dest);\n    // Setting event handlers\n    addButton.addActionListener(this);\n    removeButton.addActionListener(this);\n}\n","name":"MyFrame","className":"MyFrame","variables":{"BorderFactory":4,"e":1,"windowClosing":1,"destModel":1,"removeButton":1,"sourceModel":10,"addButton":1,"source":6,"title":1,"dest":4,"panel":6,"System":1},"constants":{"\"\"":2,"\"Mango\"":1,"\"Strawberry\"":1,"\"Kiwi\"":1,"\"Peach\"":1,"\"Shop\"":1,"0":6,"1":2,"3":1,"null":2,"4":1,"\"Orange\"":1,"5":2,"\"Apple\"":1,"\"Fruit Basket\"":1,"\"Pineapple\"":1,"\"Banana\"":1,"20":4},"javaDoc":"","comments":"Building GUI Setting event handlers ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSource":2,"equals":2,"getSelectedValue":4,"addElement":2,"setSelectedIndex":4,"removeElement":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"String":2},"expressions":{"NullLiteralExpr":4,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":54,"CastExpr":2,"MethodCallExpr":16},"statements":{"IfStmt":6,"BlockStmt":6,"ExpressionStmt":10},"text":"public void actionPerformed(ActionEvent evt) {\n    if (evt.getSource().equals(addButton)) {\n        if (source.getSelectedValue() != null) {\n            String str = (String) source.getSelectedValue();\n            if (str != null) {\n                destModel.addElement(str);\n                dest.setSelectedIndex(0);\n                sourceModel.removeElement(str);\n                source.setSelectedIndex(0);\n            }\n        }\n    }\n    if (evt.getSource().equals(removeButton)) {\n        if (dest.getSelectedValue() != null) {\n            String str = (String) dest.getSelectedValue();\n            if (str != null) {\n                sourceModel.addElement(str);\n                source.setSelectedIndex(0);\n                destModel.removeElement(str);\n                dest.setSelectedIndex(0);\n            }\n        }\n    }\n}\n","name":"actionPerformed","className":"MyFrame","variables":{"str":4,"evt":2,"destModel":2,"sourceModel":2,"source":4,"dest":4},"constants":{"0":4,"null":4},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"read":1,"printStackTrace":1,"write":1},"annotations":[],"exceptions":["Exception"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"byte[]":1,"InputStream":1,"FileOutputStream":1,"OutputStream":1,"FileInputStream":1,"int":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":13,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    try (InputStream fis = new FileInputStream(new File(\"src.txt\"));\n        OutputStream fos = new FileOutputStream(new File(\"dest.txt\"))) {\n        byte[] buf = new byte[8192];\n        int i;\n        while ((i = fis.read(buf)) != -1) {\n            fos.write(buf, 0, i);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"main","className":"FileCopy","variables":{"fis":2,"buf":1,"e":2,"i":2,"fos":2},"constants":{"0":1,"1":1,"8192":1,"\"src.txt\"":1,"\"dest.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"length":1,"getMessage":3,"readLine":2,"openStream":1,"close":1,"System.out.print":1,"System.out.println":6},"annotations":[],"exceptions":["MalformedURLException","IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"URL":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":5,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"BinaryExpr":8,"NameExpr":68,"StringLiteralExpr":7,"FieldAccessExpr":8,"MethodCallExpr":15,"AssignExpr":2},"statements":{"ContinueStmt":1,"IfStmt":1,"WhileStmt":1,"BlockStmt":6,"TryStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    String urlStr = null;\n    while (true) {\n        try {\n            System.out.print(\"Enter url: \");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            urlStr = reader.readLine();\n            if (urlStr.length() == 0) {\n                System.out.println(\"No url specified:\");\n                continue;\n            }\n            System.out.println(\"Opening \" + urlStr);\n            URL url = new URL(urlStr);\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            System.out.println(reader.readLine());\n            reader.close();\n        } catch (MalformedURLException e) {\n            System.out.println(\"Invalid URL \" + urlStr + \": \" + e.getMessage());\n        } catch (IOException e) {\n            System.out.println(\"Unable to execute \" + urlStr + \": \" + e.getMessage());\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n","name":"main","className":"MultipleExceptionsExample","variables":{"e":6,"reader":5,"urlStr":7,"url":2},"constants":{"0":1,"\"Opening \"":1,"null":1,"\"Enter url: \"":1,"true":1,"\"Unable to execute \"":1,"\"No url specified:\"":1,"\": \"":2,"\"Invalid URL \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readData":1,"getMessage":1,"openDataFile":1,"close":1,"System.out.println":4},"annotations":[],"exceptions":["FileNotFoundException","NumberFormatException","IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"ModifiedCentralizedExceptionHandlerApp":1,"String":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":32,"StringLiteralExpr":5,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"TryStmt":1,"BlockStmt":5,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    String urlStr = null;\n    try {\n        ModifiedCentralizedExceptionHandlerApp app = new ModifiedCentralizedExceptionHandlerApp();\n        app.openDataFile(\"data.txt\");\n        app.readData();\n        reader.close();\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Specified file not found\");\n    } catch (IOException e) {\n        System.out.println(\"Error closing file\");\n    } catch (NumberFormatException ne) {\n        System.out.println(\"Invalid number format, skipping rest\");\n    } catch (Exception ex) {\n        System.out.println(\"Unknown error: \" + ex.getMessage());\n    }\n}\n","name":"main","className":"ModifiedCentralizedExceptionHandlerApp","variables":{"app":3,"ex":2,"e":2,"reader":1,"ne":1,"urlStr":1},"constants":{"\"Specified file not found\"":1,"\"data.txt\"":1,"\"Unknown error: \"":1,"\"Invalid number format, skipping rest\"":1,"null":1,"\"Error closing file\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"void openDataFile(String fileName) throws FileNotFoundException {\n    reader = new BufferedReader(new FileReader(fileName));\n}\n","name":"openDataFile","className":"ModifiedCentralizedExceptionHandlerApp","variables":{"fileName":1,"reader":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"parseInt":1,"readLine":1,"System.out.println":1},"annotations":[],"exceptions":["NumberFormatException","IOException"],"concepts":[],"types":{"String":1,"int":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":14,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"void readData() throws IOException, NumberFormatException {\n    String str;\n    while ((str = reader.readLine()) != null) {\n        int n = Integer.parseInt(str);\n        System.out.println(n);\n    }\n}\n","name":"readData","className":"ModifiedCentralizedExceptionHandlerApp","variables":{"str":2,"Integer":1,"reader":1,"n":1},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"makeConnection":1,"getMessage":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"HTMLWebBrowser":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":11,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    HTMLWebBrowser app = new HTMLWebBrowser();\n    try {\n        app.makeConnection();\n    } catch (Exception e) {\n        System.out.println(e.getMessage());\n    }\n}\n","name":"main","className":"CustomBrowser","variables":{"app":2,"e":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void makeConnection() {\n}\n","name":"makeConnection","className":"WebBrowser","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"initCause":1},"annotations":[],"exceptions":["MalformedURLException","RuntimeException"],"concepts":["ExceptionHandling"],"types":{"RuntimeException":1,"URL":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"StringLiteralExpr":2,"NameExpr":5,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":3},"text":"public void makeConnection() throws RuntimeException {\n    try {\n        URL url = new URL(\"http://www.oracle.com\");\n    } catch (MalformedURLException e) {\n        RuntimeException ae = new RuntimeException(\"Invalid url\");\n        ae.initCause(e);\n        throw ae;\n    }\n}\n","name":"makeConnection","className":"HTMLWebBrowser","variables":{"ae":3,"e":1,"url":1},"constants":{"\"http://www.oracle.com\"":1,"\"Invalid url\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"init":1,"printVisitorList":1,"registerVisitor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"VisitorRoster":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    VisitorRoster roster = new VisitorRoster();\n    roster.init();\n    roster.registerVisitor();\n    roster.printVisitorList();\n}\n","name":"main","className":"VisitorRoster","variables":{"roster":4},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"private void init() {\n    visitors = new String[MAX_CAPACITY];\n}\n","name":"init","className":"VisitorRoster","variables":{"visitors":1,"MAX_CAPACITY":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"abs":1,"toString":1,"nextLong":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Random":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"private void registerVisitor() {\n    Random r = new Random();\n    System.out.println(\"Registering visitors\");\n    for (int i = 0; i < MAX_CAPACITY; i++) {\n        visitors[i] = Long.toString(Math.abs(r.nextLong()), 36);\n    }\n}\n","name":"registerVisitor","className":"VisitorRoster","variables":{"visitors":1,"r":2,"Long":1,"i":4,"MAX_CAPACITY":1,"Math":1},"constants":{"0":1,"36":1,"\"Registering visitors\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":14,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"private void printVisitorList() {\n    System.out.println(\"\\nToday's Visitors:\");\n    int i = 0;\n    while (i <= MAX_CAPACITY) {\n        System.out.println(\"Visitor ID # \" + visitors[i++]);\n    }\n}\n","name":"printVisitorList","className":"VisitorRoster","variables":{"visitors":1,"i":3,"MAX_CAPACITY":1},"constants":{"0":1,"\"\\nToday's Visitors:\"":1,"\"Visitor ID # \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":3,"getMessage":2,"takeTour":1,"System.out.println":1},"annotations":[],"exceptions":["TooHotException","TooColdException"],"concepts":["ExceptionHandling"],"types":{"Tourist":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":34,"StringLiteralExpr":3,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"ContinueStmt":2,"BlockStmt":5,"TryStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    for (int i = 0; i < 10; i++) {\n        Tourist person = new Tourist();\n        try {\n            person.takeTour();\n            System.out.printf(\"Tourist %d say: This is cool%n\", i + 1);\n        } catch (TooHotException hx) {\n            System.out.printf(\"Tourist %d say: %s%n\", i + 1, hx.getMessage());\n            continue;\n        } catch (TooColdException hx) {\n            System.out.printf(\"Tourist %d say: %s%n\", i + 1, hx.getMessage());\n            continue;\n        } finally {\n            System.out.println();\n        }\n    }\n}\n","name":"main","className":"Tourist","variables":{"hx":4,"person":2,"i":6},"constants":{"0":1,"1":3,"\"Tourist %d say: This is cool%n\"":1,"10":1,"\"Tourist %d say: %s%n\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"random":1,"System.out.println":1},"annotations":[],"exceptions":["TooHotException","TooColdException"],"concepts":["Casting"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"CastExpr":1,"NameExpr":11,"StringLiteralExpr":3,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":2,"BlockStmt":2,"ThrowStmt":2,"ExpressionStmt":2},"text":"void takeTour() throws TooHotException, TooColdException {\n    int temperature = (int) (Math.random() * 100);\n    System.out.println(\"temperature = \" + temperature);\n    if (temperature > 60) {\n        throw new TooHotException(\"Too hot here\");\n    } else if (temperature < 10) {\n        throw new TooColdException(\"Too cold here\");\n    }\n}\n","name":"takeTour","className":"Tourist","variables":{"temperature":4,"Math":1},"constants":{"100":1,"\"temperature = \"":1,"\"Too hot here\"":1,"\"Too cold here\"":1,"60":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"TooColdException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public TooColdException(String message) {\n    super(message);\n}\n","name":"TooColdException","className":"TooColdException","variables":{"message":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"TooHotException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public TooHotException(String message) {\n    super(message);\n}\n","name":"TooHotException","className":"TooHotException","variables":{"message":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"generate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    generate(3);\n}\n","name":"main","className":"FibonacciGenerator","variables":{},"constants":{"3":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"getStackTrace":1,"getMethodName":1,"generate":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"StackTraceElement[]":1,"Throwable":1,"StackTraceElement":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":3,"ForeachStmt":1,"ReturnStmt":2,"ExpressionStmt":3},"text":"public static int generate(int n) {\n    Throwable t = new Throwable();\n    StackTraceElement[] frames = t.getStackTrace();\n    for (StackTraceElement frame : frames) {\n        System.out.println(\"Calling: \" + frame.getMethodName());\n    }\n    if (n <= 2) {\n        return 1;\n    } else {\n        return generate(n - 1) + generate(n - 2);\n    }\n}\n","name":"generate","className":"FibonacciGenerator","variables":{"t":2,"frames":2,"n":3,"frame":2},"constants":{"1":2,"2":2,"\"Calling: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readData":1,"getMessage":1,"openDataFile":1,"close":1,"System.out.println":2},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"CentralizedExceptionHandlerApp":1,"String":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":22,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":3,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    String urlStr = null;\n    try {\n        CentralizedExceptionHandlerApp app = new CentralizedExceptionHandlerApp();\n        app.openDataFile(\"data.txt\");\n        app.readData();\n        reader.close();\n    } catch (IOException e) {\n        System.out.println(\"Error closing file\");\n    } catch (Exception ex) {\n        System.out.println(\"Unknown error: \" + ex.getMessage());\n    }\n}\n","name":"main","className":"CentralizedExceptionHandlerApp","variables":{"app":3,"ex":2,"e":1,"reader":1,"urlStr":1},"constants":{"\"data.txt\"":1,"\"Unknown error: \"":1,"null":1,"\"Error closing file\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":7,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"void openDataFile(String fileName) {\n    try {\n        reader = new BufferedReader(new FileReader(fileName));\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Specified file not found\");\n    }\n}\n","name":"openDataFile","className":"CentralizedExceptionHandlerApp","variables":{"fileName":1,"e":1,"reader":1},"constants":{"\"Specified file not found\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"parseInt":1,"readLine":1,"System.out.println":3},"annotations":[],"exceptions":["NumberFormatException","IOException"],"concepts":["ExceptionHandling"],"types":{"String":1,"int":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":24,"StringLiteralExpr":2,"FieldAccessExpr":3,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":5},"text":"void readData() {\n    String str;\n    try {\n        while ((str = reader.readLine()) != null) {\n            int n = Integer.parseInt(str);\n            System.out.println(n);\n        }\n    } catch (IOException e) {\n        System.out.println(\"Error while reading data\");\n    } catch (NumberFormatException ne) {\n        System.out.println(\"Invalid number format, skipping rest\");\n    }\n}\n","name":"readData","className":"CentralizedExceptionHandlerApp","variables":{"str":2,"Integer":1,"e":1,"reader":1,"ne":1,"n":1},"constants":{"\"Error while reading data\"":1,"\"Invalid number format, skipping rest\"":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"pop":7,"push":8,"System.out.println":22},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Stack<BigDecimal>":1,"Stack<Float>":1,"String":1,"Stack<Long>":1,"int":1,"Stack":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":4,"VariableDeclarationExpr":6,"DoubleLiteralExpr":2,"BinaryExpr":1,"NameExpr":161,"StringLiteralExpr":14,"CastExpr":1,"LongLiteralExpr":2,"FieldAccessExpr":23,"UnaryExpr":1,"MethodCallExpr":37},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":35},"text":"public static void main(String args[]) {\n    // long type stack\n    System.out.println(\"Creating 'long' stack:\");\n    Stack<Long> longStack = new Stack<Long>();\n    System.out.println(\"Pushing 5\");\n    longStack.push(5L);\n    System.out.println(\"Pushing 10\");\n    longStack.push(10L);\n    System.out.println(\"Emptying stack\");\n    System.out.println(longStack.pop());\n    System.out.println(longStack.pop());\n    System.out.println();\n    // float type stack\n    System.out.println(\"Creating 'float' stack:\");\n    Stack<Float> floatStack = new Stack<Float>();\n    System.out.println(\"Pushing 5.0\");\n    floatStack.push(5.0f);\n    System.out.println(\"Pushing 10.0\");\n    floatStack.push(10.0f);\n    System.out.println(\"Emptying stack\");\n    System.out.println(floatStack.pop());\n    System.out.println(floatStack.pop());\n    System.out.println();\n    // BigDecimal type stack\n    System.out.println(\"Creating 'BigDecimal' stack:\");\n    Stack<BigDecimal> bigDecimalStack = new Stack<BigDecimal>();\n    System.out.println(\"Pushing bigdecimal 12.5E+7\");\n    bigDecimalStack.push(new BigDecimal(\"12.5E+7\"));\n    System.out.println(\"Pushing bigdecimal 125\");\n    bigDecimalStack.push(new BigDecimal(125, MathContext.DECIMAL128));\n    System.out.println(\"Emptying stack\");\n    System.out.println(bigDecimalStack.pop());\n    System.out.println(bigDecimalStack.pop());\n    System.out.println();\n    // Stack without using generics\n    Stack oldtypeStack = new Stack();\n    oldtypeStack.push(10);\n    oldtypeStack.push(\"test string\");\n    for (int i = 0; i < 2; i++) {\n        String str = (String) oldtypeStack.pop();\n        System.out.println(str);\n    }\n}\n","name":"main","className":"StackDemoApp","variables":{"str":1,"longStack":5,"floatStack":5,"bigDecimalStack":5,"oldtypeStack":4,"i":3},"constants":{"\"Creating 'float' stack:\"":1,"\"Pushing 10.0\"":1,"\"Pushing 5.0\"":1,"\"12.5E+7\"":1,"10.0f":1,"10L":1,"0":1,"\"Emptying stack\"":3,"2":1,"\"Creating 'BigDecimal' stack:\"":1,"\"Pushing 5\"":1,"125":1,"\"Creating 'long' stack:\"":1,"\"Pushing bigdecimal 12.5E+7\"":1,"\"Pushing bigdecimal 125\"":1,"5L":1,"5.0f":1,"\"test string\"":1,"\"Pushing 10\"":1,"10":1},"javaDoc":"","comments":"long type stack float type stack BigDecimal type stack Stack without using generics ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["T"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"void push(T data) {\n    ptr++;\n    stack[ptr] = data;\n}\n","name":"push","className":"Stack","variables":{"stack":1,"data":1,"ptr":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"T","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"CastExpr":1,"NameExpr":2,"UnaryExpr":1},"statements":{"ReturnStmt":1},"text":"T pop() {\n    return (T) stack[ptr--];\n}\n","name":"pop","className":"Stack","variables":{"stack":1,"ptr":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":1,"get":1,"nextInt":1,"put":8,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"HashMap<Integer, String>":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":8,"VariableDeclarationExpr":3,"NameExpr":45,"StringLiteralExpr":10,"FieldAccessExpr":3,"MethodCallExpr":12},"statements":{"ExpressionStmt":13},"text":"public static void main(String args[]) {\n    HashMap<Integer, String> mapOFPlanets = new HashMap<Integer, String>();\n    mapOFPlanets.put(1, \"Mercury\");\n    mapOFPlanets.put(2, \"Venus\");\n    mapOFPlanets.put(3, \"Earth\");\n    mapOFPlanets.put(4, \"Mars\");\n    mapOFPlanets.put(5, \"Jupiter\");\n    mapOFPlanets.put(6, \"Saturn\");\n    mapOFPlanets.put(7, \"Uranus\");\n    mapOFPlanets.put(8, \"Neptune\");\n    System.out.println(\"Enter the desired position: \");\n    Scanner scanner = new Scanner(System.in);\n    int i = scanner.nextInt();\n    System.out.printf(\"Solar system position %d is taken by %s%n\", i, mapOFPlanets.get(i));\n}\n","name":"main","className":"PlanetMap","variables":{"scanner":2,"i":1,"mapOFPlanets":10},"constants":{"\"Earth\"":1,"\"Mars\"":1,"\"Jupiter\"":1,"\"Mercury\"":1,"\"Enter the desired position: \"":1,"\"Solar system position %d is taken by %s%n\"":1,"\"Venus\"":1,"1":1,"2":1,"3":1,"\"Neptune\"":1,"4":1,"\"Uranus\"":1,"5":1,"6":1,"7":1,"8":1,"\"Saturn\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"dumpStack":2,"push":3,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"NumberStack<Number>":1,"NumberStack<Long>":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":35,"StringLiteralExpr":4,"LongLiteralExpr":3,"FieldAccessExpr":4,"MethodCallExpr":9},"statements":{"ExpressionStmt":11},"text":"public static void main(String args[]) {\n    System.out.println(\"Creating 'Long' stack:\");\n    NumberStack<Long> longStack = new NumberStack<Long>();\n    longStack.push(5L);\n    longStack.push(10L);\n    System.out.println(\"Creating 'Number' stack:\");\n    NumberStack<Number> numberStack = new NumberStack<Number>();\n    numberStack.push(10L);\n    System.out.println(\"\\nDumping 'Long' stack\");\n    dumpStack(longStack);\n    System.out.println(\"\\nDumping 'Number' stack\");\n    dumpStack(numberStack);\n}\n","name":"main","className":"WildCardDemoApp","variables":{"longStack":3,"numberStack":2},"constants":{"\"Creating 'Long' stack:\"":1,"\"\\nDumping 'Long' stack\"":1,"\"\\nDumping 'Number' stack\"":1,"5L":1,"\"Creating 'Number' stack:\"":1,"10L":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["NumberStack<?>"],"returnType":"void","methodCalls":{"getStack":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Number":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":1},"text":"static void dumpStack(NumberStack<?> stack) {\n    for (Number n : stack.getStack()) {\n        System.out.println(n);\n    }\n}\n","name":"dumpStack","className":"WildCardDemoApp","variables":{"stack":1,"n":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":[],"returnType":"Number[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Number[] getStack() {\n    return stack;\n}\n","name":"getStack","className":"NumberStack","variables":{"stack":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["T"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"void push(T data) {\n    ptr++;\n    stack[ptr] = data;\n}\n","name":"push","className":"NumberStack","variables":{"stack":1,"data":1,"ptr":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"T","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"CastExpr":1,"NameExpr":2,"UnaryExpr":1},"statements":{"ReturnStmt":1},"text":"T pop() {\n    return (T) stack[ptr--];\n}\n","name":"pop","className":"NumberStack","variables":{"stack":1,"ptr":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printCheckedList":2,"expurgate":1,"expurgateCheckedList":1,"buildList":1,"buildCheckedList":1,"printList":2,"System.out.println":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"FamousQuotes":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":64,"StringLiteralExpr":8,"FieldAccessExpr":7,"MethodCallExpr":15},"statements":{"ExpressionStmt":17},"text":"public static void main(String[] args) {\n    FamousQuotes app = new FamousQuotes();\n    System.out.println(\"Without using generics\\n\");\n    app.buildList();\n    app.printList();\n    System.out.println();\n    System.out.println(\"With generic classes\\n\");\n    app.buildCheckedList();\n    app.printCheckedList();\n    System.out.println(\"\\nNon-generics version of expurgate\\n\");\n    String strAuthor = \"Winston Churchill\";\n    System.out.println(\"After removing quotes by \" + strAuthor);\n    app.expurgate(listOfFamousQuotes, \"Winston Churchill\");\n    app.printList();\n    System.out.println(\"\\nGenerics version of expurgate\\n\");\n    System.out.println(\"After removing quotes by \" + strAuthor);\n    app.expurgateCheckedList(listOfFamousQuotesTypechecked, strAuthor);\n    app.printCheckedList();\n}\n","name":"main","className":"FamousQuotes","variables":{"app":9,"strAuthor":3},"constants":{"\"With generic classes\\n\"":1,"\"Without using generics\\n\"":1,"\"\\nNon-generics version of expurgate\\n\"":1,"\"\\nGenerics version of expurgate\\n\"":1,"\"After removing quotes by \"":2,"\"Winston Churchill\"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":10,"StringLiteralExpr":3,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"void buildList() {\n    listOfFamousQuotes = new ArrayList();\n    listOfFamousQuotes.add(\"Where there is love there is life - Mahatma Gandhi\");\n    listOfFamousQuotes.add(\"A joke is a very serious thing - Winston Churchill\");\n    listOfFamousQuotes.add(\"In the end, everything is a gag - Charlie Chaplin\");\n// listOfFamousQuotes.add(100); // add this to generate runtime error\n}\n","name":"buildList","className":"FamousQuotes","variables":{"listOfFamousQuotes":4},"constants":{"\"Where there is love there is life - Mahatma Gandhi\"":1,"\"In the end, everything is a gag - Charlie Chaplin\"":1,"\"A joke is a very serious thing - Winston Churchill\"":1},"javaDoc":"","comments":"listOfFamousQuotes add(100); // add this to generate runtime error ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":10,"StringLiteralExpr":3,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"void buildCheckedList() {\n    listOfFamousQuotesTypechecked = new ArrayList<String>();\n    listOfFamousQuotesTypechecked.add(\"Where there is love there is life - Mahatma Gandhi\");\n    listOfFamousQuotesTypechecked.add(\"A joke is a very serious thing - Winston Churchill\");\n    listOfFamousQuotesTypechecked.add(\"In the end, everything is a gag - Charlie Chaplin\");\n}\n","name":"buildCheckedList","className":"FamousQuotes","variables":{"listOfFamousQuotesTypechecked":4},"constants":{"\"Where there is love there is life - Mahatma Gandhi\"":1,"\"In the end, everything is a gag - Charlie Chaplin\"":1,"\"A joke is a very serious thing - Winston Churchill\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"next":1,"iterator":1,"hasNext":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Iterator":1,"String":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":15,"CastExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"void printList() {\n    Iterator listIterator = listOfFamousQuotes.iterator();\n    while (listIterator.hasNext()) {\n        String quote = (String) listIterator.next();\n        System.out.println(quote);\n    }\n}\n","name":"printList","className":"FamousQuotes","variables":{"quote":1,"listOfFamousQuotes":1,"listIterator":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"next":1,"iterator":1,"hasNext":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Iterator<String>":1,"String":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":15,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"void printCheckedList() {\n    Iterator<String> quoteIterator = listOfFamousQuotesTypechecked.iterator();\n    while (quoteIterator.hasNext()) {\n        String quote = quoteIterator.next();\n        System.out.println(quote);\n    }\n}\n","name":"printCheckedList","className":"FamousQuotes","variables":{"quote":1,"quoteIterator":3,"listOfFamousQuotesTypechecked":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Collection","String"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"hasNext":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Iterator":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":15,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":1},"text":"void expurgate(Collection c, String strAuthor) {\n    for (Iterator i = c.iterator(); i.hasNext(); ) {\n        if (((String) i.next()).contains(strAuthor)) {\n            i.remove();\n        }\n    }\n}\n","name":"expurgate","className":"FamousQuotes","variables":{"c":1,"i":4},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Collection<String>","String"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"contains":1,"hasNext":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Iterator<String>":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":15,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":1},"text":"void expurgateCheckedList(Collection<String> c, String strAuthor) {\n    for (Iterator<String> i = c.iterator(); i.hasNext(); ) {\n        if (i.next().contains(strAuthor)) {\n            i.remove();\n        }\n    }\n}\n","name":"expurgateCheckedList","className":"FamousQuotes","variables":{"c":1,"i":4},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String args[]) {\n    System.out.println(\"Hello World!\");\n}\n","name":"main","className":"HelloWorld","variables":{},"constants":{"\"Hello World!\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.in.read":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"byte":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":17,"StringLiteralExpr":2,"FieldAccessExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public static void main(String args[]) {\n    try {\n        byte buffer[] = new byte[100];\n        System.out.print(\"Enter your name: \");\n        System.in.read(buffer);\n        System.out.println(\"Hello \" + new String(buffer));\n    } catch (Exception e) {\n    }\n}\n // catch the exception as good practice\n\n // I will discuss exception-handling in chapter 08.\n\n","name":"main","className":"Greetings","variables":{"e":1,"buffer":2},"constants":{"100":1,"\"Hello \"":1,"\"Enter your name: \"":1},"javaDoc":"","comments":"catch the exception as good practice I will discuss exception-handling in chapter 08 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MyFrame":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    MyFrame frame = new MyFrame(\"FlowLayout Demo\");\n    frame.setSize(500, 300);\n    frame.setVisible(true);\n}\n","name":"main","className":"FlowLayoutDemoApp","variables":{"frame":3},"constants":{"300":1,"500":1,"true":1,"\"FlowLayout Demo\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"MyFrame","methodCalls":{"add":5,"setComponentOrientation":1,"getContentPane":1,"setDefaultCloseOperation":1,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Container":1,"JButton":1},"expressions":{"ObjectCreationExpr":6,"VariableDeclarationExpr":2,"NameExpr":41,"StringLiteralExpr":5,"FieldAccessExpr":2,"MethodCallExpr":9,"AssignExpr":4},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":14},"text":"public MyFrame(String title) {\n    super(title);\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    Container pane = getContentPane();\n    pane.setLayout(new FlowLayout());\n    pane.setComponentOrientation(ComponentOrientation.LEFT_TO_RIGHT);\n    JButton button = new JButton(\"ONE\");\n    pane.add(button);\n    button = new JButton(\"TWO\");\n    pane.add(button);\n    button = new JButton(\"THREE\");\n    pane.add(button);\n    button = new JButton(\"FOUR\");\n    pane.add(button);\n    button = new JButton(\"FIVE\");\n    pane.add(button);\n}\n","name":"MyFrame","className":"MyFrame","variables":{"button":5,"title":1,"pane":8},"constants":{"\"THREE\"":1,"\"ONE\"":1,"\"TWO\"":1,"\"FOUR\"":1,"\"FIVE\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MobileKeypad","methodCalls":{"setTitle":1,"setDefaultCloseOperation":1,"initGUI":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public MobileKeypad() {\n    setTitle(\"Mobile Keypad\");\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    initGUI();\n}\n","name":"MobileKeypad","className":"MobileKeypad","variables":{},"constants":{"\"Mobile Keypad\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MobileKeypad":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    MobileKeypad app = new MobileKeypad();\n    app.setSize(220, 240);\n    app.setVisible(true);\n}\n","name":"main","className":"MobileKeypad","variables":{"app":3},"constants":{"220":1,"true":1,"240":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":12,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":13,"IntegerLiteralExpr":2,"NameExpr":26,"StringLiteralExpr":12,"MethodCallExpr":13},"statements":{"ExpressionStmt":13},"text":"private void initGUI() {\n    setLayout(new GridLayout(4, 3));\n    add(new JButton(\"1\"));\n    add(new JButton(\"2\"));\n    add(new JButton(\"3\"));\n    add(new JButton(\"4\"));\n    add(new JButton(\"5\"));\n    add(new JButton(\"6\"));\n    add(new JButton(\"7\"));\n    add(new JButton(\"8\"));\n    add(new JButton(\"9\"));\n    add(new JButton(\"+\"));\n    add(new JButton(\"0\"));\n    add(new JButton(\"#\"));\n}\n","name":"initGUI","className":"MobileKeypad","variables":{},"constants":{"\"#\"":1,"\"9\"":1,"\"8\"":1,"\"7\"":1,"\"6\"":1,"\"5\"":1,"\"4\"":1,"\"3\"":1,"\"2\"":1,"3":1,"\"1\"":1,"4":1,"\"0\"":1,"\"+\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"TabFrame":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    TabFrame frame = new TabFrame(\"Tab Demo\");\n    frame.setSize(500, 200);\n    frame.setVisible(true);\n}\n","name":"main","className":"TabDemoApp","variables":{"frame":3},"constants":{"\"Tab Demo\"":1,"200":1,"500":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"TabFrame","methodCalls":{"setDefaultCloseOperation":1,"initGUI":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":2},"text":"public TabFrame(String title) {\n    super(title);\n    setDefaultCloseOperation(EXIT_ON_CLOSE);\n    initGUI();\n}\n","name":"TabFrame","className":"TabFrame","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"addTab":2,"getContentPane":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JTabbedPane":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"NameExpr":14,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void initGUI() {\n    JTabbedPane tabbedPane = new JTabbedPane();\n    //Create the \"cards\".\n    tabbedPane.addTab(\"Address\", new AddressPanel());\n    tabbedPane.addTab(\"Memo\", new MemoPanel());\n    getContentPane().add(tabbedPane, BorderLayout.CENTER);\n}\n","name":"initGUI","className":"TabFrame","variables":{"tabbedPane":3},"constants":{"\"Memo\"":1,"\"Address\"":1},"javaDoc":"","comments":"Create the \"cards\" ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MemoPanel","methodCalls":{"add":3,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":4,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public MemoPanel() {\n    setLayout(new BoxLayout(this, BoxLayout.PAGE_AXIS));\n    add(new JLabel(\"Enter Memo\"));\n    add(new JTextField());\n    add(new JButton(\"OK\"));\n}\n","name":"MemoPanel","className":"MemoPanel","variables":{},"constants":{"\"OK\"":1,"\"Enter Memo\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{"Dimension":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"SuperExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"@Override\npublic Dimension getPreferredSize() {\n    Dimension size = super.getPreferredSize();\n    size.width += 20;\n    return size;\n}\n","name":"getPreferredSize","className":"","variables":{"size":2},"constants":{"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"AddressPanel","methodCalls":{"add":10,"setLayout":3},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"JPanel":2,"Dimension":1},"expressions":{"ObjectCreationExpr":13,"IntegerLiteralExpr":15,"VariableDeclarationExpr":3,"SuperExpr":1,"NameExpr":65,"StringLiteralExpr":4,"FieldAccessExpr":7,"MarkerAnnotationExpr":1,"MethodCallExpr":14,"AssignExpr":1},"statements":{"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":17},"text":"public AddressPanel() {\n    setLayout(new BorderLayout(10, 0));\n    JPanel leftPanel = new JPanel() {\n\n        @Override\n        public Dimension getPreferredSize() {\n            Dimension size = super.getPreferredSize();\n            size.width += 20;\n            return size;\n        }\n    };\n    leftPanel.setLayout(new GridLayout(4, 1, 10, 10));\n    leftPanel.add(new JLabel(\"Name\", JLabel.RIGHT));\n    leftPanel.add(new JLabel(\"Address 1\", JLabel.RIGHT));\n    leftPanel.add(new JLabel(\"Address 2\", JLabel.RIGHT));\n    leftPanel.add(new JLabel(\"City\", JLabel.RIGHT));\n    add(leftPanel, BorderLayout.LINE_START);\n    JPanel rightPanel = new JPanel();\n    rightPanel.setLayout(new GridLayout(4, 1, 10, 10));\n    rightPanel.add(new JTextField(20));\n    rightPanel.add(new JTextField(10));\n    rightPanel.add(new JTextField(15));\n    rightPanel.add(new JTextField(5));\n    add(rightPanel, BorderLayout.CENTER);\n}\n","name":"AddressPanel","className":"AddressPanel","variables":{"size":2,"leftPanel":6,"getPreferredSize":1,"rightPanel":6,"Override":1},"constants":{"0":1,"\"Address 1\"":1,"1":2,"\"Address 2\"":1,"\"City\"":1,"4":2,"15":1,"5":1,"\"Name\"":1,"20":2,"10":6},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"log":4,"setLookAndFeel":1,"getLogger":4},"annotations":[],"exceptions":["UnsupportedLookAndFeelException","ClassNotFoundException","InstantiationException","IllegalAccessException"],"concepts":["ExceptionHandling"],"types":{"ContactsDatabase":1},"expressions":{"NullLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":47,"StringLiteralExpr":1,"ClassExpr":4,"FieldAccessExpr":4,"MethodCallExpr":13},"statements":{"TryStmt":1,"BlockStmt":5,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    try {\n        UIManager.setLookAndFeel(\"javax.swing.plaf.nimbus.NimbusLookAndFeel\");\n    } catch (ClassNotFoundException ex) {\n        Logger.getLogger(ContactsDatabase.class.getName()).log(Level.SEVERE, null, ex);\n    } catch (InstantiationException ex) {\n        Logger.getLogger(ContactsDatabase.class.getName()).log(Level.SEVERE, null, ex);\n    } catch (IllegalAccessException ex) {\n        Logger.getLogger(ContactsDatabase.class.getName()).log(Level.SEVERE, null, ex);\n    } catch (UnsupportedLookAndFeelException ex) {\n        Logger.getLogger(ContactsDatabase.class.getName()).log(Level.SEVERE, null, ex);\n    }\n    ContactsDatabase mDIFrame = new ContactsDatabase();\n}\n","name":"main","className":"ContactsDatabase","variables":{"mDIFrame":1,"ex":4,"UIManager":1,"Logger":4},"constants":{"null":4,"\"javax.swing.plaf.nimbus.NimbusLookAndFeel\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"ContactsDatabase","methodCalls":{"initGUI":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public ContactsDatabase() {\n    initGUI();\n}\n","name":"ContactsDatabase","className":"ContactsDatabase","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":15,"setVisible":1,"createVerticalStrut":2,"setResizable":1,"addActionListener":2,"getContentPane":1,"setLayout":1,"createTitledBorder":2,"createVerticalBox":2,"createRigidArea":2,"setSize":1,"setBorder":2,"setModel":1,"setDefaultCloseOperation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Container":1,"Box":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":10,"VariableDeclarationExpr":2,"BooleanLiteralExpr":2,"NameExpr":114,"StringLiteralExpr":4,"FieldAccessExpr":1,"ThisExpr":2,"MethodCallExpr":34,"AssignExpr":5},"statements":{"ExpressionStmt":32},"text":"private void initGUI() {\n    Box verticalBoxRight, verticalBoxLeft;\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    Container contentPane = getContentPane();\n    contentPane.setLayout(new GridLayout(1, 2));\n    verticalBoxLeft = Box.createVerticalBox();\n    verticalBoxLeft.add(Box.createRigidArea(new Dimension(70, 20)));\n    verticalBoxLeft.add(new JLabel(\"Name\"));\n    verticalBoxLeft.add(jTextFieldName);\n    verticalBoxLeft.add(Box.createVerticalStrut(10));\n    verticalBoxLeft.add(new JLabel(\"Mobile #\"));\n    verticalBoxLeft.add(jTextFieldMobile);\n    verticalBoxLeft.add(Box.createVerticalStrut(25));\n    verticalBoxLeft.add(jButtonAdd);\n    jButtonAdd.addActionListener(this);\n    informationPanel = new JPanel();\n    informationPanel.add(verticalBoxLeft);\n    informationPanel.setBorder(BorderFactory.createTitledBorder(\"Information\"));\n    contactList = new JList();\n    contactList.setModel(new DefaultListModel());\n    verticalBoxRight = Box.createVerticalBox();\n    verticalBoxRight.add(new JScrollPane(contactList));\n    verticalBoxRight.add(Box.createRigidArea(new Dimension(80, 10)));\n    verticalBoxRight.add(jButtonClear);\n    jButtonClear.addActionListener(this);\n    listPanel = new JPanel();\n    listPanel.setBorder(BorderFactory.createTitledBorder(\"Contacts\"));\n    listPanel.add(verticalBoxRight);\n    contentPane.add(informationPanel);\n    contentPane.add(listPanel);\n    setSize(600, 250);\n    setResizable(false);\n    setVisible(true);\n}\n","name":"initGUI","className":"ContactsDatabase","variables":{"BorderFactory":2,"contactList":3,"listPanel":3,"Box":6,"jButtonClear":1,"verticalBoxRight":5,"verticalBoxLeft":10,"contentPane":4,"informationPanel":3,"jButtonAdd":1},"constants":{"25":1,"\"Name\"":1,"false":1,"250":1,"1":1,"2":1,"\"Information\"":1,"\"Mobile #\"":1,"600":1,"80":1,"true":1,"70":1,"\"Contacts\"":1,"20":1,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getModel":1,"getSource":1,"getText":2,"setModel":1,"addElement":1,"setText":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"DefaultListModel":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":25,"CastExpr":1,"StringLiteralExpr":3,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent e) {\n    if (e.getSource() == jButtonAdd) {\n        DefaultListModel contactsModel = (DefaultListModel) contactList.getModel();\n        contactsModel.addElement(jTextFieldName.getText() + \" \" + jTextFieldMobile.getText());\n        jTextFieldName.setText(\"\");\n        jTextFieldMobile.setText(\"\");\n    } else {\n        contactList.setModel(new DefaultListModel());\n    }\n}\n","name":"actionPerformed","className":"ContactsDatabase","variables":{"jTextFieldMobile":2,"contactList":2,"jTextFieldName":2,"e":1,"contactsModel":2,"jButtonAdd":1},"constants":{"\"\"":2,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"CalcInterface","methodCalls":{"initGUI":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public CalcInterface() {\n    super.setTitle(\"Calc\");\n    initGUI();\n}\n","name":"CalcInterface","className":"CalcInterface","variables":{},"constants":{"\"Calc\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":23,"setBorder":1,"getContentPane":24,"setDefaultCloseOperation":1,"setLayout":1,"setFont":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"GridBagConstraints":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":60,"VariableDeclarationExpr":1,"NameExpr":331,"StringLiteralExpr":1,"FieldAccessExpr":61,"MethodCallExpr":52,"AssignExpr":54},"statements":{"ExpressionStmt":83},"text":"private void initGUI() {\n    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\n    GridBagConstraints constraints = new GridBagConstraints();\n    constraints.ipady = 15;\n    constraints.ipadx = 10;\n    constraints.fill = java.awt.GridBagConstraints.BOTH;\n    getContentPane().setLayout(new GridBagLayout());\n    jLabelOutput.setFont(new Font(\"Monospaced\", 1, 24));\n    jLabelOutput.setBorder(new MetalBorders.TextFieldBorder());\n    constraints.insets = new Insets(10, 10, 10, 10);\n    constraints.gridwidth = GridBagConstraints.REMAINDER;\n    getContentPane().add(jLabelOutput, constraints);\n    constraints.insets = new Insets(0, 0, 0, 0);\n    constraints.gridwidth = 1;\n    constraints.gridx = 0;\n    constraints.gridy = 1;\n    getContentPane().add(jButtonMC, constraints);\n    constraints.gridx = 1;\n    constraints.gridy = 1;\n    getContentPane().add(jButtonMPlus, constraints);\n    constraints.gridx = 2;\n    constraints.gridy = 1;\n    getContentPane().add(jButtonMMinus, constraints);\n    constraints.gridx = 3;\n    constraints.gridy = 1;\n    getContentPane().add(jButtonMR, constraints);\n    constraints.gridx = 0;\n    constraints.gridy = 2;\n    getContentPane().add(jButtonC, constraints);\n    constraints.gridx = 1;\n    constraints.gridy = 2;\n    getContentPane().add(jButtonAddSub, constraints);\n    constraints.gridx = 2;\n    constraints.gridy = 2;\n    getContentPane().add(jButtondiv, constraints);\n    constraints.gridx = 3;\n    constraints.gridy = 2;\n    getContentPane().add(jButtonMul, constraints);\n    constraints.gridx = 0;\n    constraints.gridy = 3;\n    getContentPane().add(jButtonSeven, constraints);\n    constraints.gridx = 1;\n    constraints.gridy = 3;\n    getContentPane().add(jButtonEight, constraints);\n    constraints.gridx = 2;\n    constraints.gridy = 3;\n    getContentPane().add(jButtonNine, constraints);\n    constraints.gridx = 3;\n    constraints.gridy = 3;\n    getContentPane().add(jButtonSub, constraints);\n    constraints.gridx = 0;\n    constraints.gridy = 4;\n    getContentPane().add(jButtonFour, constraints);\n    constraints.gridx = 1;\n    constraints.gridy = 4;\n    getContentPane().add(jButtonFive, constraints);\n    constraints.gridx = 2;\n    constraints.gridy = 4;\n    getContentPane().add(jButtonSix, constraints);\n    constraints.gridx = 3;\n    constraints.gridy = 4;\n    getContentPane().add(jButtonAdd, constraints);\n    constraints.gridx = 0;\n    constraints.gridy = 5;\n    getContentPane().add(jButtonOne, constraints);\n    constraints.gridx = 1;\n    constraints.gridy = 5;\n    getContentPane().add(jButtonTwo, constraints);\n    constraints.gridx = 2;\n    constraints.gridy = 5;\n    getContentPane().add(jButtonThree, constraints);\n    constraints.gridx = 0;\n    constraints.gridy = 6;\n    constraints.gridwidth = 2;\n    getContentPane().add(jButtonZero, constraints);\n    constraints.gridwidth = 1;\n    constraints.gridx = 2;\n    constraints.gridy = 6;\n    getContentPane().add(jButtonDot, constraints);\n    constraints.gridx = 3;\n    constraints.gridy = 5;\n    constraints.gridheight = 2;\n    getContentPane().add(jButtonEqual, constraints);\n    pack();\n}\n","name":"initGUI","className":"CalcInterface","variables":{"jLabelOutput":2,"constraints":1},"constants":{"0":10,"1":12,"24":1,"2":12,"3":9,"15":1,"4":4,"5":4,"6":2,"\"Monospaced\"":1,"10":5},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String args[]) {\n    new CalcInterface().setVisible(true);\n}\n","name":"main","className":"CalcInterface","variables":{},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ColorFrame":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    ColorFrame frame = new ColorFrame(\"CardLayout Demo\");\n    frame.setSize(500, 300);\n    frame.setVisible(true);\n}\n","name":"main","className":"CardLayoutDemoApp","variables":{"frame":3},"constants":{"300":1,"\"CardLayout Demo\"":1,"500":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"ColorFrame","methodCalls":{"addListSelectionListener":1,"add":12,"addActionListener":2,"getContentPane":1,"setDefaultCloseOperation":1,"setLayout":1,"setSelectedIndex":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"Container":1},"expressions":{"IntegerLiteralExpr":9,"ObjectCreationExpr":10,"VariableDeclarationExpr":2,"ArrayAccessExpr":7,"NameExpr":97,"FieldAccessExpr":9,"ThisExpr":3,"MethodCallExpr":19},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":20},"text":"public ColorFrame(String title) {\n    super(title);\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    cmdNext.addActionListener(this);\n    cmdPrevious.addActionListener(this);\n    colorList.addListSelectionListener(this);\n    displayPanel.setLayout(cards);\n    displayPanel.add(colors[0], new ColorPanel(Color.RED));\n    displayPanel.add(colors[1], new ColorPanel(Color.ORANGE));\n    displayPanel.add(colors[2], new ColorPanel(Color.YELLOW));\n    displayPanel.add(colors[3], new ColorPanel(Color.GREEN));\n    displayPanel.add(colors[4], new ColorPanel(Color.BLUE));\n    displayPanel.add(colors[5], new ColorPanel(new Color(0x6600FF)));\n    displayPanel.add(colors[6], new ColorPanel(new Color(0x8B00FF)));\n    JPanel cmdPanel = new JPanel();\n    cmdPanel.add(cmdPrevious);\n    cmdPanel.add(cmdNext);\n    Container pane = getContentPane();\n    pane.add(colorList, BorderLayout.LINE_START);\n    pane.add(displayPanel, BorderLayout.CENTER);\n    pane.add(cmdPanel, BorderLayout.PAGE_END);\n    colorList.setSelectedIndex(selectedColorIndex);\n}\n","name":"ColorFrame","className":"ColorFrame","variables":{"cmdNext":1,"displayPanel":8,"title":1,"pane":4,"cmdPrevious":1,"colors":7,"colorList":2,"cmdPanel":3},"constants":{"0":1,"1":1,"0x6600FF":1,"2":1,"3":1,"4":1,"5":1,"6":1,"0x8B00FF":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"next":1,"previous":1,"getSource":2,"show":1,"setSelectedIndex":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":42,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":7,"AssignExpr":2},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":9},"text":"public void actionPerformed(ActionEvent evt) {\n    cards.show(displayPanel, colors[selectedColorIndex]);\n    if (evt.getSource() == cmdNext) {\n        cards.next(displayPanel);\n        selectedColorIndex++;\n        if (selectedColorIndex > colors.length - 1) {\n            selectedColorIndex = 0;\n        }\n        colorList.setSelectedIndex(selectedColorIndex);\n    } else if (evt.getSource() == cmdPrevious) {\n        cards.previous(displayPanel);\n        selectedColorIndex--;\n        if (selectedColorIndex < 0) {\n            selectedColorIndex = colors.length - 1;\n        }\n        colorList.setSelectedIndex(selectedColorIndex);\n    }\n}\n","name":"actionPerformed","className":"ColorFrame","variables":{"evt":2,"cmdNext":1,"cards":3,"selectedColorIndex":7,"colors":1,"cmdPrevious":1,"colorList":2},"constants":{"0":2,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ListSelectionEvent"],"returnType":"void","methodCalls":{"show":1,"getSelectedIndex":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":10,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void valueChanged(ListSelectionEvent lse) {\n    selectedColorIndex = colorList.getSelectedIndex();\n    cards.show(displayPanel, colors[selectedColorIndex]);\n}\n","name":"valueChanged","className":"ColorFrame","variables":{"cards":1,"selectedColorIndex":2,"colors":1,"colorList":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"ColorPanel","methodCalls":{"add":1,"format":1,"setBackground":1,"getRGB":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":2,"FieldAccessExpr":2,"ThisExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":3},"text":"public ColorPanel(Color color) {\n    setBackground(color);\n    this.setLayout(new BorderLayout());\n    add(new JLabel(\"Value: \" + String.format(\"%X\", color.getRGB()), SwingConstants.CENTER), BorderLayout.CENTER);\n}\n","name":"ColorPanel","className":"ColorPanel","variables":{"color":1,"String":1},"constants":{"\"%X\"":1,"\"Value: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":3,"read":1,"printStackTrace":1,"write":1,"close":2,"System.out.println":5},"annotations":[],"exceptions":["FileNotFoundException","IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"InputStream":1,"byte":1,"OutputStream":1,"int":1},"expressions":{"IntegerLiteralExpr":12,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":4,"BinaryExpr":4,"NameExpr":62,"StringLiteralExpr":5,"UnaryExpr":1,"AssignExpr":3,"NullLiteralExpr":2,"FieldAccessExpr":6,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":13},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":11,"TryStmt":4,"ExpressionStmt":18},"text":"public static void main(String[] args) {\n    int numberRead = 0;\n    InputStream readerStream = null;\n    OutputStream writerStream = null;\n    byte buffer[] = new byte[512];\n    if (args.length < 2) {\n        System.out.println(\"Usage: java FileCopy file1 file2\");\n        System.exit(0);\n    }\n    try {\n        readerStream = new FileInputStream(args[0]);\n    } catch (FileNotFoundException fe) {\n        System.out.println(args[0] + \" not found\");\n        System.exit(0);\n    }\n    try {\n        writerStream = new FileOutputStream(args[1]);\n    } catch (FileNotFoundException fe) {\n        System.out.println(args[1] + \" not found\");\n        System.exit(0);\n    }\n    try {\n        while ((numberRead = readerStream.read(buffer)) != -1) {\n            writerStream.write(buffer, 0, numberRead);\n        }\n    } catch (IOException ioe) {\n        System.out.println(\"Error reading/writing file\");\n    } finally {\n        try {\n            readerStream.close();\n            writerStream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    System.out.println(\"1 file copied!\");\n}\n","name":"main","className":"FileCopy","variables":{"args":4,"numberRead":2,"e":2,"writerStream":4,"buffer":1,"System":3,"ioe":1,"readerStream":4,"fe":2},"constants":{"0":7,"\" not found\"":2,"1":3,"2":1,"\"Usage: java FileCopy file1 file2\"":1,"\"1 file copied!\"":1,"null":2,"512":1,"\"Error reading/writing file\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"newLine":1,"printStackTrace":1,"readLine":1,"write":1,"System.out.println":1},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":2,"BufferedWriter":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":21,"FieldAccessExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":6,"ForeachStmt":1,"ExpressionStmt":5},"text":"public static void concenateFile(String... fileName) {\n    String str = null;\n    try (BufferedWriter writer = new BufferedWriter(new FileWriter(\"CombinedFile.txt\"))) {\n        for (String name : fileName) {\n            try (BufferedReader reader = new BufferedReader(new FileReader(name))) {\n                while ((str = reader.readLine()) != null) {\n                    writer.write(str);\n                    writer.newLine();\n                }\n            } catch (IOException e) {\n                System.out.println(\"Error reading/writing file\");\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"concenateFile","className":"Concatenate","variables":{"str":2,"fileName":1,"e":3,"reader":2,"name":2,"writer":3},"constants":{"null":2,"\"Error reading/writing file\"":1,"\"CombinedFile.txt\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"concenateFile":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":19,"StringLiteralExpr":2,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    if (args.length < 0) {\n        System.out.println(\"Usage: java Concatenate file1 file2\");\n        System.exit(0);\n    }\n    concenateFile(args);\n    System.out.println(\"Successfully created CombinedFile.txt\");\n}\n","name":"main","className":"Concatenate","variables":{"System":1},"constants":{"0":2,"\"Successfully created CombinedFile.txt\"":1,"\"Usage: java Concatenate file1 file2\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"getLineNumber":1,"printStackTrace":1,"getMessage":1,"readLine":1,"close":1,"System.out.println":4},"annotations":[],"exceptions":["FileNotFoundException","IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"LineNumberReader":1},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":4,"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":43,"StringLiteralExpr":3,"FieldAccessExpr":5,"MethodCallExpr":10,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":8,"TryStmt":2,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    LineNumberReader reader = null;\n    if (args.length < 1) {\n        System.out.println(\"Usage: java LineCounter <filename>\");\n        System.exit(0);\n    }\n    try {\n        reader = new LineNumberReader(new FileReader(args[0]));\n        while (reader.readLine() != null) {\n        }\n        System.out.println(\"Line number of the last line in the file is: \" + reader.getLineNumber() + 1);\n    } catch (FileNotFoundException fe) {\n        System.out.println(fe.getMessage());\n    } catch (IOException e) {\n        System.out.println(\"Error reading file\");\n    } finally {\n        try {\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n","name":"main","className":"LineCounter","variables":{"args":1,"e":3,"reader":5,"System":1,"fe":2},"constants":{"0":2,"1":2,"\"Usage: java LineCounter <filename>\"":1,"\"Error reading file\"":1,"null":2,"\"Line number of the last line in the file is: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":2,"read":1,"printStackTrace":1,"close":2,"System.out.println":4},"annotations":[],"exceptions":["FileNotFoundException","IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"InputStream":1,"int":1},"expressions":{"IntegerLiteralExpr":8,"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":6,"NameExpr":47,"StringLiteralExpr":5,"FieldAccessExpr":5,"UnaryExpr":2,"MethodCallExpr":10,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":8,"TryStmt":2,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    int count = 0;\n    InputStream streamReader = null;\n    if (args.length < 1) {\n        System.out.println(\"Usage: java FileLength <filename>\");\n        System.exit(0);\n    }\n    try {\n        streamReader = new FileInputStream(args[0]);\n        while (streamReader.read() != -1) {\n            count++;\n        }\n        System.out.println(args[0] + \" length = \" + count);\n        streamReader.close();\n    } catch (FileNotFoundException fe) {\n        System.out.println(\"File \" + args[0] + \" was not found\");\n        System.exit(0);\n    } catch (IOException ie) {\n        System.out.println(\"Error reading file\");\n    } finally {\n        try {\n            streamReader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n","name":"main","className":"FileLength","variables":{"args":3,"e":2,"streamReader":5,"count":3,"ie":1,"System":2,"fe":1},"constants":{"0":6,"1":2,"\"File \"":1,"\"Error reading file\"":1,"null":1,"\"Usage: java FileLength <filename>\"":1,"\" was not found\"":1,"\" length = \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":2,"read":1,"printStackTrace":1,"getMessage":1,"write":1,"close":2,"System.out.println":3},"annotations":[],"exceptions":["FileNotFoundException","IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"char":1,"FileReader":1,"int":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":52,"StringLiteralExpr":2,"UnaryExpr":1,"AssignExpr":3,"NullLiteralExpr":2,"FieldAccessExpr":5,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":8,"TryStmt":2,"ExpressionStmt":15},"text":"public static void main(String[] args) {\n    int numberRead = 0;\n    FileReader reader = null;\n    PrintWriter writer = null;\n    char buffer[] = new char[512];\n    if (args.length < 1) {\n        System.out.println(\"Usage: java FileView filename\");\n        System.exit(0);\n    }\n    try {\n        reader = new FileReader(args[0]);\n        writer = new PrintWriter(System.out);\n        while ((numberRead = reader.read(buffer)) != -1) {\n            writer.write(buffer, 0, numberRead);\n        }\n    } catch (FileNotFoundException fe) {\n        System.out.println(fe.getMessage());\n        System.exit(0);\n    } catch (IOException ioe) {\n        System.out.println(\"Error reading/writing file\");\n    } finally {\n        try {\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n","name":"main","className":"FileView","variables":{"args":1,"numberRead":2,"e":2,"reader":4,"writer":4,"buffer":1,"System":2,"ioe":1,"fe":2},"constants":{"0":5,"1":2,"null":2,"512":1,"\"Error reading/writing file\"":1,"\"Usage: java FileView filename\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printStackTrace":2,"writeObject":3,"close":2,"System.out.println":2,"readObject":1},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"ObjectOutputStream":1,"int":1,"ObjectInputStream":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":7,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":38,"StringLiteralExpr":9,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":10},"statements":{"TryStmt":2,"BlockStmt":6,"ForStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    ObjectOutputStream objectWriter = null;\n    ObjectInputStream objectReader = null;\n    try {\n        objectWriter = new ObjectOutputStream(new FileOutputStream(\"student.dat\"));\n        objectWriter.writeObject(new Student(1, \"John\", \"Mayor\"));\n        objectWriter.writeObject(new Student(2, \"Sam\", \"Abel\"));\n        objectWriter.writeObject(new Student(3, \"Anita\", \"Motwani\"));\n        System.out.println(\"Printing list of students in the database:\");\n        objectReader = new ObjectInputStream(new FileInputStream(\"student.dat\"));\n        for (int i = 0; i < 3; i++) {\n            System.out.println(objectReader.readObject());\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            objectWriter.close();\n            objectReader.close();\n        } catch (IOException ie) {\n            ie.printStackTrace();\n        }\n    }\n}\n","name":"main","className":"ObjectSerializationApp","variables":{"objectWriter":6,"e":2,"i":3,"ie":2,"objectReader":4},"constants":{"\"Sam\"":1,"\"Anita\"":1,"\"student.dat\"":2,"0":1,"1":1,"2":1,"\"Printing list of students in the database:\"":1,"3":2,"null":2,"\"Mayor\"":1,"\"Motwani\"":1,"\"John\"":1,"\"Abel\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","String","String"],"returnType":"Student","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":3,"ThisExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public Student(int id, String firstName, String lastName) {\n    this.id = id;\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n","name":"Student","className":"Student","variables":{"firstName":1,"lastName":1,"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"StringLiteralExpr":3,"NameExpr":3,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return (\"ID:\" + id + \" \" + firstName + \" \" + lastName);\n}\n","name":"toString","className":"Student","variables":{"firstName":1,"lastName":1,"id":1},"constants":{"\"ID:\"":1,"\" \"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"printStackTrace":1,"get":1,"newDirectoryStream":1,"getFileName":1,"close":1,"System.out.println":3},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"Path":2,"DirectoryStream<Path>":1},"expressions":{"IntegerLiteralExpr":4,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":42,"StringLiteralExpr":2,"FieldAccessExpr":4,"MethodCallExpr":9,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":8,"TryStmt":2,"ForeachStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    if (args.length < 1) {\n        System.out.println(\"Usage: DirListing DirectoryName\");\n        System.exit(0);\n    }\n    Path dirPath = Paths.get(args[0]);\n    DirectoryStream<Path> directory = null;\n    try {\n        directory = Files.newDirectoryStream(dirPath);\n        for (Path p : directory) {\n            System.out.println(p.getFileName());\n        }\n    } catch (Exception ie) {\n        System.out.println(\"Invalid path specified:\" + args[0]);\n    } finally {\n        try {\n            if (directory != null) {\n                directory.close();\n            }\n        } catch (IOException ie) {\n            ie.printStackTrace();\n        }\n    }\n}\n","name":"main","className":"DirListing","variables":{"args":2,"p":2,"dirPath":1,"Paths":1,"Files":1,"ie":3,"directory":5,"System":1},"constants":{"0":3,"1":1,"null":2,"\"Invalid path specified:\"":1,"\"Usage: DirListing DirectoryName\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"format":7,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuilder":1,"Formatter":1,"int":1},"expressions":{"IntegerLiteralExpr":13,"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":6,"NameExpr":73,"StringLiteralExpr":7,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":15,"MethodCallExpr":8},"statements":{"ExpressionStmt":26},"text":"public static void main(String[] args) {\n    int m = 0xFFFFFFFF, n = 0x80000000, result;\n    result = m & n;\n    StringBuilder builder = new StringBuilder();\n    Formatter formatter = new Formatter(builder, Locale.US);\n    formatter.format(\"Logical AND: %X & %X = %X\\n\", m, n, result);\n    m = 0x0000FFFF;\n    n = 0xFFFF0000;\n    result = m | n;\n    formatter.format(\"Logical OR: %X & %X = %X\\n\", m, n, result);\n    m = 0x8000FFFF;\n    n = 0xFFFF8000;\n    result = m ^ n;\n    formatter.format(\"Logical XOR: %X & %X = %X\\n\", m, n, result);\n    m = 0x7FFF0000;\n    result = ~m;\n    formatter.format(\"Logical NOT: ~%X = %X\\n\", m, result);\n    m = 0xFFFF0000;\n    result = m << 4;\n    formatter.format(\"Left Shift: %X << 4 = %X\\n\", m, result);\n    m = 0xFFFF0000;\n    result = m >> 4;\n    formatter.format(\"Right Shift: %X >> 4 = %X\\n\", m, result);\n    m = 0xFFFF0000;\n    result = m >>> 1;\n    formatter.format(\"Right Shift with zero fill: %X >>> 1 = %X\", m, result);\n    System.out.println(builder);\n}\n","name":"main","className":"BitwiseOperators","variables":{"result":8,"formatter":8,"builder":2,"m":14,"n":6},"constants":{"0x0000FFFF":1,"\"Logical AND: %X & %X = %X\\n\"":1,"0x7FFF0000":1,"0xFFFFFFFF":1,"\"Logical NOT: ~%X = %X\\n\"":1,"\"Right Shift: %X >> 4 = %X\\n\"":1,"0xFFFF8000":1,"\"Logical XOR: %X & %X = %X\\n\"":1,"0x80000000":1,"\"Left Shift: %X << 4 = %X\\n\"":1,"0xFFFF0000":4,"1":1,"\"Right Shift with zero fill: %X >>> 1 = %X\"":1,"\"Logical OR: %X & %X = %X\\n\"":1,"0x8000FFFF":1,"4":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":34,"NameExpr":64,"StringLiteralExpr":18,"FieldAccessExpr":6,"UnaryExpr":1,"AssignExpr":6,"MethodCallExpr":6},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    int m = 20, n = 12, result;\n    result = m + n;\n    System.out.println(\"Addition: \" + m + \" + \" + n + \" = \" + result);\n    result = m - n;\n    System.out.println(\"Subtraction: \" + m + \" - \" + n + \" = \" + result);\n    result = m * n;\n    System.out.println(\"Multiplication: \" + m + \" * \" + n + \" = \" + result);\n    result = m / n;\n    System.out.println(\"Integer Division: \" + m + \" / \" + n + \" = \" + result);\n    result = m % n;\n    System.out.println(\"Remainder: \" + m + \" % \" + n + \" = \" + result);\n    result = -m;\n    System.out.println(\"Unary: \" + \" -\" + m + \" = \" + result);\n}\n","name":"main","className":"ArithmeticOperators","variables":{"result":13,"m":13,"n":11},"constants":{"\" * \"":1,"12":1,"\"Addition: \"":1,"\" + \"":1,"\"Unary: \"":1,"\"Integer Division: \"":1,"\" % \"":1,"\"Multiplication: \"":1,"\" = \"":6,"\"Remainder: \"":1,"\"Subtraction: \"":1,"\" -\"":1,"\" / \"":1,"20":1,"\" - \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":12,"NameExpr":27,"StringLiteralExpr":6,"FieldAccessExpr":2,"ConditionalExpr":2,"EnclosedExpr":2,"AssignExpr":3,"MethodCallExpr":2},"statements":{"ExpressionStmt":6},"text":"public static void main(String args[]) {\n    int m = 10, n = 20, max;\n    max = (m > n) ? m : n;\n    System.out.println(\"max of \" + m + \" and \" + n + \": \" + max);\n    n = 5;\n    max = (m > n) ? m : n;\n    System.out.println(\"max of \" + m + \" and \" + n + \": \" + max);\n}\n","name":"main","className":"ConditionalOperator","variables":{"max":5,"m":7,"n":8},"constants":{"\" and \"":2,"5":1,"\"max of \"":2,"\": \"":2,"20":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":53,"StringLiteralExpr":10,"FieldAccessExpr":5,"EnclosedExpr":5,"MethodCallExpr":5,"AssignExpr":13},"statements":{"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    int m = 10, n = 5;\n    System.out.printf(\"m = %d, n = %d %nAfter (m += n) operation \" + \"m becomes %d%n%n\", m, n, (m += n));\n    m = 10;\n    n = 5;\n    System.out.printf(\"m = %d, n = %d %nAfter (m -= n) operation \" + \"m becomes %d%n%n\", m, n, (m -= n));\n    m = 10;\n    n = 5;\n    System.out.printf(\"m = %d, n = %d %nAfter (m *= n) operation \" + \"m becomes %d%n%n\", m, n, (m *= n));\n    m = 10;\n    n = 5;\n    System.out.printf(\"m = %d, n = %d %nAfter (m /= n) operation \" + \"m becomes %d%n%n\", m, n, (m /= n));\n    m = 13;\n    n = 5;\n    System.out.printf(\"m = %d, n = %d %nAfter (m %%= n) operation \" + \"m becomes %d%n%n\", m, n, (m %= n));\n}\n","name":"main","className":"AssignmentOperators","variables":{"m":10,"n":10},"constants":{"\"m = %d, n = %d %nAfter (m -= n) operation \"":1,"\"m = %d, n = %d %nAfter (m += n) operation \"":1,"\"m = %d, n = %d %nAfter (m /= n) operation \"":1,"13":1,"5":5,"\"m becomes %d%n%n\"":5,"\"m = %d, n = %d %nAfter (m *= n) operation \"":1,"\"m = %d, n = %d %nAfter (m %%= n) operation \"":1,"10":4},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.printf":6,"System.in.read":2,"System.out.println":9},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":12,"NameExpr":115,"StringLiteralExpr":11,"CastExpr":2,"FieldAccessExpr":17,"MethodCallExpr":17,"AssignExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":18},"text":"public static void main(String[] args) {\n    int m = 0, n = 0;\n    System.out.println(\"Enter two characters without a space and hit return\");\n    try {\n        m = System.in.read();\n        n = System.in.read();\n    } catch (Exception ex) {\n    }\n    System.out.println(\"Character \" + (char) m + \" has ASCII value = \" + m);\n    System.out.println(\"Character \" + (char) n + \" has ASCII value = \" + n);\n    System.out.printf(\"(%c > %c)returns \", m, n);\n    System.out.println(m > n);\n // provide an exception handler here\n\n    System.out.printf(\"(%c < %c)returns \", m, n);\n    System.out.println(m < n);\n    System.out.printf(\"(%c >= %c)returns \", m, n);\n    System.out.println(m >= n);\n    System.out.printf(\"(%c <= %c)returns \", m, n);\n    System.out.println(m <= n);\n    System.out.printf(\"(%c != %c)returns \", m, n);\n    System.out.println(m != n);\n    System.out.printf(\"(%c == %c)returns \", m, n);\n    System.out.println(m == n);\n}\n","name":"main","className":"RelationalOperators","variables":{"ex":1,"m":10,"n":10},"constants":{"0":2,"\"(%c <= %c)returns \"":1,"\"Character \"":2,"\" has ASCII value = \"":2,"\"(%c > %c)returns \"":1,"\"(%c != %c)returns \"":1,"\"Enter two characters without a space and hit return\"":1,"\"(%c == %c)returns \"":1,"\"(%c < %c)returns \"":1,"\"(%c >= %c)returns \"":1},"javaDoc":"","comments":"provide an exception handler here ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"float":1,"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":9,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    int bigInteger = 1987654321;\n    float floatNumber = bigInteger;\n    int loss = bigInteger - (int) floatNumber;\n    System.out.println(\"Precision loss: \" + loss);\n}\n","name":"main","className":"IntToFloatConverter","variables":{"loss":2,"bigInteger":3,"floatNumber":2},"constants":{"\"Precision loss: \"":1,"1987654321":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":18},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":1,"BinaryExpr":12,"NameExpr":116,"StringLiteralExpr":18,"FieldAccessExpr":18,"UnaryExpr":4,"MethodCallExpr":18,"AssignExpr":10},"statements":{"ExpressionStmt":29},"text":"public static void main(String[] args) {\n    int m = 10, n = 10;\n    System.out.println(\"Using increment operator:\");\n    System.out.println(\"Pre-increment: m = ++n\");\n    System.out.println(\"Initial value of n: \" + n);\n    m = ++n;\n    System.out.println(\"Value of m now: \" + m);\n    System.out.println(\"Value of n now: \" + n);\n    m = 10;\n    n = 10;\n    System.out.println(\"Post-increment: m = n++\");\n    System.out.println(\"Initial value of n: \" + n);\n    m = n++;\n    System.out.println(\"Value of m now: \" + m);\n    System.out.println(\"Value of n now: \" + n);\n    m = 10;\n    n = 10;\n    System.out.println(\"\\nUsing decrement operator:\");\n    System.out.println(\"Pre-decrement: m = --n\");\n    System.out.println(\"Initial value of n: \" + n);\n    m = --n;\n    System.out.println(\"Value of m now: \" + m);\n    System.out.println(\"Value of n now: \" + n);\n    m = 10;\n    n = 10;\n    System.out.println(\"Post-decrement: m = n--\");\n    System.out.println(\"Initial value of n: \" + n);\n    m = n--;\n    System.out.println(\"Value of m now: \" + m);\n    System.out.println(\"Value of n now: \" + n);\n}\n","name":"main","className":"IncDecOperators","variables":{"m":12,"n":16},"constants":{"\"Pre-increment: m = ++n\"":1,"\"\\nUsing decrement operator:\"":1,"\"Post-decrement: m = n--\"":1,"\"Value of m now: \"":4,"\"Value of n now: \"":4,"\"Post-increment: m = n++\"":1,"\"Using increment operator:\"":1,"\"Pre-decrement: m = --n\"":1,"\"Initial value of n: \"":4,"10":8},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"char":1,"float":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"DoubleLiteralExpr":1,"BinaryExpr":12,"NameExpr":37,"CastExpr":2,"StringLiteralExpr":8,"CharLiteralExpr":1,"FieldAccessExpr":4,"UnaryExpr":1,"AssignExpr":5,"MethodCallExpr":4},"statements":{"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    float f = 12.25f;\n    int i = -200;\n    char c = 'A';\n    // floating point to integer conversion\n    i = (int) f;\n    System.out.println(\"float type \" + f + \" assigned to an int produces \" + i);\n    f = i;\n    System.out.println(\"int type \" + i + \" assigned to a float produces \" + f);\n    i = c;\n    System.out.println(\"char type \" + c + \" assigned to an int produces \" + i);\n    i = 66;\n    c = (char) i;\n    System.out.println(\"int type \" + i + \" assigned to a char produces \" + c);\n}\n","name":"main","className":"TypeConversion","variables":{"c":5,"f":5,"i":10},"constants":{"66":1,"200":1,"\" assigned to an int produces \"":2,"\" assigned to a char produces \"":1,"12.25f":1,"\"int type \"":2,"\" assigned to a float produces \"":1,"'A'":1,"\"float type \"":1,"\"char type \"":1},"javaDoc":"","comments":"floating point to integer conversion ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":3,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":7,"NameExpr":40,"StringLiteralExpr":3,"FieldAccessExpr":6,"EnclosedExpr":5,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    int m = 5, n = 2;\n    System.out.print(\"(m == n)&&(m == m) returns \");\n    System.out.println((m == n) && (m == m));\n    System.out.print(\"(m == n)||(m == m)) returns \");\n    System.out.println((m == n) || (m == m));\n    System.out.print(\"!(m == m) returns \");\n    System.out.println(!(m == m));\n}\n","name":"main","className":"LogicalOperators","variables":{"m":9,"n":3},"constants":{"\"(m == n)||(m == m)) returns \"":1,"2":1,"5":1,"\"(m == n)&&(m == m) returns \"":1,"\"!(m == m) returns \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":14,"next":2,"iterator":1,"removeAll":1,"listIterator":1,"hasNext":2,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"ListIterator<String>":1,"Iterator<String>":1,"LinkedList":3,"List<String>":3},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":4,"NameExpr":88,"StringLiteralExpr":17,"FieldAccessExpr":4,"MethodCallExpr":25},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":2,"ExpressionStmt":25},"text":"public static void main(String[] args) {\n    List<String> maleTeam = new LinkedList<>();\n    maleTeam.add(\"John\");\n    maleTeam.add(\"Tom\");\n    maleTeam.add(\"Sam\");\n    maleTeam.add(\"Vijay\");\n    maleTeam.add(\"Anthony\");\n    System.out.println(\"Male Team: \" + maleTeam);\n    List<String> femaleTeam = new LinkedList<>();\n    femaleTeam.add(\"Catherine\");\n    femaleTeam.add(\"Mary\");\n    femaleTeam.add(\"Shilpa\");\n    femaleTeam.add(\"Jane\");\n    femaleTeam.add(\"Anita\");\n    System.out.println(\"Female Team: \" + femaleTeam);\n    ListIterator<String> maleListIterator = maleTeam.listIterator();\n    Iterator<String> femaleListIterator = femaleTeam.iterator();\n    while (femaleListIterator.hasNext()) {\n        if (maleListIterator.hasNext()) {\n            maleListIterator.next();\n        }\n        maleListIterator.add(femaleListIterator.next());\n    }\n    System.out.println(\"Mixed Team: \" + maleTeam);\n    List<String> disqualify = new LinkedList<>();\n    disqualify.add(\"Sam\");\n    disqualify.add(\"Tom\");\n    disqualify.add(\"Shilpa\");\n    maleTeam.removeAll(disqualify);\n    System.out.println(\"Qualified Team: \" + maleTeam);\n}\n","name":"main","className":"SoccerTeam","variables":{"maleTeam":11,"disqualify":4,"femaleTeam":8,"maleListIterator":4,"femaleListIterator":3},"constants":{"\"Qualified Team: \"":1,"\"Male Team: \"":1,"\"Sam\"":2,"\"Anita\"":1,"\"Shilpa\"":2,"\"Mary\"":1,"\"Catherine\"":1,"\"Mixed Team: \"":1,"\"Tom\"":2,"\"Jane\"":1,"\"Vijay\"":1,"\"Female Team: \"":1,"\"Anthony\"":1,"\"John\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"subList":1,"max":1,"clear":1,"sort":2,"binarySearch":1,"frequency":1,"random":1,"min":1,"size":1,"addAll":2,"shuffle":1,"System.out.println":8},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Set<Integer>":1,"ArrayList":1,"List<Integer>":2,"int":3,"HashSet":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":7,"VariableDeclarationExpr":6,"BinaryExpr":16,"NameExpr":102,"CastExpr":1,"StringLiteralExpr":11,"FieldAccessExpr":8,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":22},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":20},"text":"public static void main(String[] args) {\n    List<Integer> list = new ArrayList<>();\n    for (int i = 0; i < 100; i++) {\n        list.add((int) (Math.random() * 100));\n    }\n    Collections.sort(list);\n    System.out.println(\"Sorted Array: \" + list);\n    int testNumber = 10;\n    int index = Collections.binarySearch(list, testNumber);\n    if (index >= 0) {\n        System.out.println(\"Number \" + testNumber + \" found at index: \" + index);\n    } else {\n        System.out.println(\"Number \" + testNumber + \" not found\");\n    }\n    System.out.println(\"Max number: \" + Collections.max(list));\n    System.out.println(\"Min number: \" + Collections.min(list));\n    System.out.println(\"Frequency of \" + testNumber + \": \" + Collections.frequency(list, testNumber));\n    Set<Integer> sortedList = new HashSet<>();\n    sortedList.addAll(list);\n    System.out.println(\"Number of distinct elements: \" + sortedList.size());\n    list.clear();\n    list.addAll(sortedList);\n    Collections.shuffle(list);\n    List<Integer> topTenList = list.subList(0, 10);\n    Collections.sort(topTenList);\n    System.out.println(\"Top 10: \" + topTenList);\n}\n","name":"main","className":"CollectionAlgorithms","variables":{"testNumber":4,"topTenList":2,"i":3,"index":3,"sortedList":3,"list":6,"Math":1,"Collections":7},"constants":{"\"Number of distinct elements: \"":1,"\"Sorted Array: \"":1,"\"Top 10: \"":1,"\"Min number: \"":1,"\" found at index: \"":1,"\"Frequency of \"":1,"\": \"":1,"\"Number \"":2,"0":3,"100":2,"\" not found\"":1,"\"Max number: \"":1,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"random":1,"addAll":1,"isEmpty":1,"System.out.print":2,"remove":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Integer":1,"PriorityQueue<Integer>":1,"ArrayList":1,"List<Integer>":1,"PriorityQueue":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":40,"CastExpr":1,"StringLiteralExpr":4,"FieldAccessExpr":4,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":9},"statements":{"WhileStmt":1,"BlockStmt":3,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"public static void main(String[] args) {\n    List<Integer> list = new ArrayList<>();\n    for (int i = 0; i < 100; i++) {\n        list.add((int) (Math.random() * 10));\n    }\n    PriorityQueue<Integer> threadQueue = new PriorityQueue<>();\n    threadQueue.addAll(list);\n    System.out.println(\"Waiting threads...\");\n    for (Integer thread : threadQueue) {\n        System.out.print(thread + \",\");\n    }\n    System.out.println(\"\\nDeploying threads...\");\n    while (!threadQueue.isEmpty()) {\n        System.out.print(threadQueue.remove() + \",\");\n    }\n}\n","name":"main","className":"ThreadScheduler","variables":{"threadQueue":5,"i":3,"thread":2,"list":2,"Math":1},"constants":{"0":1,"100":1,"\"Waiting threads...\"":1,"\"\\nDeploying threads...\"":1,"\",\"":2,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Player","Player"],"returnType":"int","methodCalls":{"getName":2,"compareTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"MethodCallExpr":3},"statements":{"ReturnStmt":1},"text":"public int compare(Player a, Player b) {\n    return a.getName().compareTo(b.getName());\n}\n","name":"compare","className":"","variables":{"a":1,"b":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":5,"getName":2,"addAll":1,"compareTo":1,"System.out.println":4,"printSet":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism"],"types":{"SortedSet<Player>":2,"TreeSet":2},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"NameExpr":55,"StringLiteralExpr":9,"FieldAccessExpr":4,"MethodCallExpr":15},"statements":{"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    SortedSet<Player> ageSortedTeam = new TreeSet<>();\n    ageSortedTeam.add(new Player(\"John\", 21));\n    ageSortedTeam.add(new Player(\"Sam\", 20));\n    ageSortedTeam.add(new Player(\"Anthony\", 18));\n    ageSortedTeam.add(new Player(\"Bill\", 19));\n    ageSortedTeam.add(new Player(\"Jack\", 22));\n    System.out.println(\"Team - by age\");\n    printSet(ageSortedTeam);\n    System.out.println(\"-------------------\");\n    SortedSet<Player> nameSortedTeam = new TreeSet<>(new Comparator<Player>() {\n\n        public int compare(Player a, Player b) {\n            return a.getName().compareTo(b.getName());\n        }\n    });\n    nameSortedTeam.addAll(ageSortedTeam);\n    System.out.println(\"Team - alphabetical\");\n    printSet(nameSortedTeam);\n    System.out.println(\"-------------------\");\n}\n","name":"main","className":"SortableTeam","variables":{"a":2,"nameSortedTeam":2,"b":2,"compare":1,"ageSortedTeam":6},"constants":{"22":1,"\"Bill\"":1,"\"-------------------\"":2,"\"Sam\"":1,"\"Jack\"":1,"18":1,"19":1,"\"Team - alphabetical\"":1,"\"Team - by age\"":1,"\"Anthony\"":1,"\"John\"":1,"20":1,"21":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Set"],"returnType":"void","methodCalls":{"next":1,"getAge":1,"iterator":1,"getName":1,"hasNext":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Player":1,"Iterator":1},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":20,"CastExpr":1,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"static void printSet(Set set) {\n    Iterator iterator = set.iterator();\n    while (iterator.hasNext()) {\n        Player player = (Player) iterator.next();\n        System.out.println(player.getName() + \" - Age:\" + player.getAge());\n    }\n}\n","name":"printSet","className":"SortableTeam","variables":{"iterator":3,"set":1,"player":3},"constants":{"\" - Age:\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String","int"],"returnType":"Player","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Player(String name, int age) {\n    this.name = name;\n    this.age = age;\n}\n","name":"Player","className":"Player","variables":{"name":1,"age":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getAge() {\n    return age;\n}\n","name":"getAge","className":"Player","variables":{"age":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"FieldAccessExpr":1,"ThisExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return this.name;\n}\n","name":"getName","className":"Player","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Player"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":4,"FieldAccessExpr":1},"statements":{"ReturnStmt":1},"text":"public int compareTo(Player other) {\n    return age - other.age;\n}\n","name":"compareTo","className":"Player","variables":{"age":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"next":1,"iterator":1,"size":1,"nextLine":1,"hasNext":1,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Scanner":1,"Set<String>":1,"Iterator<String>":1,"String":1,"int":1,"HashSet":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":2,"NameExpr":52,"StringLiteralExpr":5,"FieldAccessExpr":6,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":12,"AssignExpr":1},"statements":{"WhileStmt":2,"BlockStmt":2,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    int count = 0;\n    Set<String> words = new HashSet<>();\n    Scanner in = new Scanner(System.in);\n    String str;\n    while (!(str = in.nextLine()).equals(\"\")) {\n        count++;\n        words.add(str);\n    }\n    System.out.println(\". . .\");\n    System.out.println(\"Total number of words entered: \" + count);\n    System.out.println(\"Distinct words: \" + words.size());\n    System.out.println(\". . .\");\n    Iterator<String> iterator = words.iterator();\n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n}\n","name":"main","className":"DistinctWordSet","variables":{"str":2,"iterator":3,"in":2,"count":3,"words":4},"constants":{"0":1,"\"\"":1,"\". . .\"":2,"\"Total number of words entered: \"":1,"\"Distinct words: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"get":1,"printList":2,"put":6,"remove":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":6,"BinaryExpr":1,"NameExpr":38,"StringLiteralExpr":28,"FieldAccessExpr":2,"MethodCallExpr":12},"statements":{"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    wordList.put(\"Abate\", new Word(\"verb\", \"subside\", \"alienate,increase,extend,amplify,continue,enlarge\"));\n    wordList.put(\"Abeyance\", new Word(\"noun\", \"suspended action\", \"continuance\"));\n    wordList.put(\"Abscond\", new Word(\"verb\", \"depart secretly and hide\", \"appear,emerge, show,stay,remain\"));\n    wordList.put(\"Abstemious\", new Word(\"adj\", \"sparing in eating and drinking\", \"intemperate,glutonous\"));\n    wordList.put(\"Admonish\", new Word(\"verb\", \"warn, reprove\", \"acclaim,commend,praise,compliment,countenance\"));\n    printList();\n    // Look up a value\n    System.out.println(\"\\nValue for abscond \" + wordList.get(\"Abscond\"));\n    // Modify an entry\n    wordList.put(\"Abate\", new Word(\"verb\", \"subside,moderate\", \"alienate,increase,extend,amplify,continue,enlarge\"));\n    // Remove entry\n    wordList.remove(\"Abstemious\");\n    System.out.print(\"\\nAfter modifications:\");\n    printList();\n}\n","name":"main","className":"GREWordList","variables":{"wordList":8},"constants":{"\"noun\"":1,"\"Abate\"":2,"\"depart secretly and hide\"":1,"\"sparing in eating and drinking\"":1,"\"\\nValue for abscond \"":1,"\"\\nAfter modifications:\"":1,"\"suspended action\"":1,"\"Abstemious\"":2,"\"Admonish\"":1,"\"subside,moderate\"":1,"\"adj\"":1,"\"warn, reprove\"":1,"\"verb\"":4,"\"Abeyance\"":1,"\"intemperate,glutonous\"":1,"\"continuance\"":1,"\"subside\"":1,"\"Abscond\"":2,"\"appear,emerge, show,stay,remain\"":1,"\"acclaim,commend,praise,compliment,countenance\"":1,"\"alienate,increase,extend,amplify,continue,enlarge\"":2},"javaDoc":"","comments":"Look up a value Modify an entry Remove entry ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getKey":1,"getValue":1,"entrySet":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Word":1,"String":1,"Map.Entry<String, Word>":1},"expressions":{"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":4},"text":"private static void printList() {\n    System.out.println(\"\\nAll Entries:\");\n    for (Map.Entry<String, Word> entry : wordList.entrySet()) {\n        String key = entry.getKey();\n        Word value = entry.getValue();\n        System.out.println(\"key=\" + key + \", value=\" + value);\n    }\n}\n","name":"printList","className":"GREWordList","variables":{"entry":3,"wordList":1,"value":2,"key":2},"constants":{"\", value=\"":1,"\"\\nAll Entries:\"":1,"\"key=\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getAntonym() {\n    return antonym;\n}\n","name":"getAntonym","className":"Word","variables":{"antonym":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getSynonym() {\n    return synonym;\n}\n","name":"getSynonym","className":"Word","variables":{"synonym":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getType() {\n    return type;\n}\n","name":"getType","className":"Word","variables":{"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","String"],"returnType":"Word","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":3,"ThisExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public Word(String type, String synonym, String antonym) {\n    this.type = type;\n    this.synonym = synonym;\n    this.antonym = antonym;\n}\n","name":"Word","className":"Word","variables":{"synonym":1,"antonym":1,"type":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":["Override"],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":6,"StringLiteralExpr":4,"NameExpr":3},"statements":{"ReturnStmt":1},"text":"@Override\npublic String toString() {\n    return \"[\" + type + \"; \" + synonym + \"; \" + antonym + \"]\";\n}\n","name":"toString","className":"Word","variables":{"synonym":1,"antonym":1,"type":1},"constants":{"\"]\"":1,"\"[\"":1,"\"; \"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"IntListVer1","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic IntListVer1() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"IntListVer1","className":"IntListVer1","variables":{"DEFAULT_CAP":1},"constants":{},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"IntListVer1","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic IntListVer1(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new int[initialCap];\n    iSize = 0;\n}\n","name":"IntListVer1","className":"IntListVer1","variables":{"iValues":1,"iSize":1,"initialCap":3},"constants":{"0":2,"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean[][]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"String":1,"boolean[]":1},"expressions":{"VariableDeclarationExpr":3,"StringLiteralExpr":4,"NameExpr":12,"FieldAccessExpr":1,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ForeachStmt":2,"ExpressionStmt":5},"text":"public static void show(boolean[][] grid) {\n    String s = \"\";\n    for (boolean[] row : grid) {\n        for (boolean val : row) if (val)\n            s += \"*\";\n        else\n            s += \".\";\n        s += \"\\n\";\n    }\n    System.out.println(s);\n}\n","name":"show","className":"Life","variables":{"val":2,"s":4,"grid":1,"row":2},"constants":{"\"\"":1,"\".\"":1,"\"*\"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"boolean[][]","methodCalls":{"random":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2,"boolean[][]":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"DoubleLiteralExpr":1,"ArrayAccessExpr":2,"BinaryExpr":3,"BooleanLiteralExpr":1,"NameExpr":11,"ArrayCreationExpr":1,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static boolean[][] gen() {\n    boolean[][] grid = new boolean[10][10];\n    for (int r = 0; r < 10; r++) for (int c = 0; c < 10; c++) if (Math.random() > 0.7)\n        grid[r][c] = true;\n    return grid;\n}\n","name":"gen","className":"Life","variables":{"r":4,"c":4,"grid":3,"Math":1},"constants":{"0":2,"true":1,"0.7":1,"10":4},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"gen":1,"nextLine":1,"show":3,"length":1,"nextGen":2,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"boolean[][]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":37,"FieldAccessExpr":3,"MethodCallExpr":10,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    boolean[][] world = gen();\n    show(world);\n    System.out.println();\n    world = nextGen(world);\n    show(world);\n    Scanner s = new Scanner(System.in);\n    while (s.nextLine().length() == 0) {\n        System.out.println();\n        world = nextGen(world);\n        show(world);\n    }\n}\n","name":"main","className":"Life","variables":{"world":3,"s":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["boolean[][]"],"returnType":"boolean[][]","methodCalls":{"numNeighbors":1,"occupiedNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3,"boolean[][]":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":32,"FieldAccessExpr":4,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"public static boolean[][] nextGen(boolean[][] world) {\n    boolean[][] newWorld = new boolean[world.length][world[0].length];\n    int num;\n    for (int r = 0; r < world.length; r++) {\n        for (int c = 0; c < world[0].length; c++) {\n            num = numNeighbors(world, r, c);\n            if (occupiedNext(num, world[r][c]))\n                newWorld[r][c] = true;\n        }\n    }\n    return newWorld;\n}\n","name":"nextGen","className":"Life","variables":{"r":5,"world":3,"c":5,"newWorld":3,"num":2},"constants":{"0":4,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","boolean"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":6,"BooleanLiteralExpr":3,"NameExpr":5,"EnclosedExpr":1,"UnaryExpr":1},"statements":{"IfStmt":2,"ReturnStmt":3},"text":"public static boolean occupiedNext(int numNeighbors, boolean occupied) {\n    if (occupied && (numNeighbors == 2 || numNeighbors == 3))\n        return true;\n    else if (!occupied && numNeighbors == 3)\n        return true;\n    else\n        return false;\n}\n","name":"occupiedNext","className":"Life","variables":{"numNeighbors":3,"occupied":2},"constants":{"2":1,"3":2,"true":2,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["boolean[][]","int","int"],"returnType":"int","methodCalls":{"inbounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"ArrayAccessExpr":4,"BinaryExpr":7,"NameExpr":21,"ConditionalExpr":1,"UnaryExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":2},"text":"private static int numNeighbors(boolean[][] world, int row, int col) {\n    int num = world[row][col] ? -1 : 0;\n    for (int r = row - 1; r <= row + 1; r++) for (int c = col - 1; c <= col + 1; c++) if (inbounds(world, r, c) && world[r][c])\n        num++;\n    return num;\n}\n","name":"numNeighbors","className":"Life","variables":{"col":3,"r":4,"world":2,"c":4,"num":3,"row":3},"constants":{"0":1,"1":5},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["boolean[][]","int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"ArrayAccessExpr":1,"BinaryExpr":7,"NameExpr":10,"FieldAccessExpr":2},"statements":{"ReturnStmt":1},"text":"private static boolean inbounds(boolean[][] world, int r, int c) {\n    return r >= 0 && r < world.length && c >= 0 && c < world[0].length;\n}\n","name":"inbounds","className":"Life","variables":{"r":2,"c":2,"world":1},"constants":{"0":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"inBounds":1,"cellPicked":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"ArrayAccessExpr":6,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":23,"UnaryExpr":5,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":2,"ForStmt":2,"ExpressionStmt":2},"text":"public void cellPicked(int row, int col) {\n    if (inBounds(row, col) && !myShow[row][col]) {\n        myShow[row][col] = true;\n        if (myTruth[row][col] == 0) {\n            for (int r = -1; r <= 1; r++) for (int c = -1; c <= 1; c++) cellPicked(row + r, col + c);\n        }\n    }\n}\n","name":"cellPicked","className":"MineSweeper","variables":{"col":4,"r":4,"c":4,"myShow":2,"myTruth":1,"row":4},"constants":{"0":1,"1":4,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"ArrayAccessExpr":1,"BinaryExpr":7,"NameExpr":10,"FieldAccessExpr":2},"statements":{"ReturnStmt":1},"text":"public boolean inBounds(int row, int col) {\n    return 0 <= row && row < myTruth.length && 0 <= col && col < myTruth[0].length;\n}\n","name":"inBounds","className":"MineSweeper","variables":{"col":2,"myTruth":1,"row":2},"constants":{"0":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"nanoTime":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n\t start the stop watch.\n\t*/\npublic void start() {\n    startTime = System.nanoTime();\n}\n","name":"start","className":"Stopwatch","variables":{"startTime":1,"System":1},"constants":{},"javaDoc":"start the stop watch","comments":"\n\t start the stop watch.\n\t","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"nanoTime":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n\t stop the stop watch.\n\t*/\npublic void stop() {\n    stopTime = System.nanoTime();\n}\n","name":"stop","className":"Stopwatch","variables":{"stopTime":1,"System":1},"constants":{},"javaDoc":"stop the stop watch","comments":"\n\t stop the stop watch.\n\t","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":3,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n\telapsed time in seconds.\n\t@return the time recorded on the stopwatch in seconds\n\t*/\npublic double time() {\n    return (stopTime - startTime) / NANOS_PER_SEC;\n}\n","name":"time","className":"Stopwatch","variables":{"NANOS_PER_SEC":1,"stopTime":1,"startTime":1},"constants":{},"javaDoc":"elapsed time in seconds the time recorded on the stopwatch in seconds","comments":"\n\telapsed time in seconds.\n\t@return the time recorded on the stopwatch in seconds\n\t","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"time":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return \"elapsed time: \" + time() + \" seconds.\";\n}\n","name":"toString","className":"Stopwatch","variables":{},"constants":{"\" seconds.\"":1,"\"elapsed time: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2,"EnclosedExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n\telapsed time in nanoseconds.\n\t@return the time recorded on the stopwatch in nanoseconds\n\t*/\npublic long timeInNanoseconds() {\n    return (stopTime - startTime);\n}\n","name":"timeInNanoseconds","className":"Stopwatch","variables":{"stopTime":1,"startTime":1},"constants":{},"javaDoc":"elapsed time in nanoseconds the time recorded on the stopwatch in nanoseconds","comments":"\n\telapsed time in nanoseconds.\n\t@return the time recorded on the stopwatch in nanoseconds\n\t","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Directory"],"returnType":"int","methodCalls":{"getSize":1,"getSubs":1,"getFiles":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"File[]":1,"Directory[]":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":5,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":27,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"public int getSize(Directory dir) {\n    int total = 0;\n    //check files\n    File[] files = dir.getFiles();\n    for (int i = 0; i < files.length; i++) total += files[i].getSize();\n    //get sub directories and check them\n    Directory[] subs = dir.getSubs();\n    for (int i = 0; i < subs.length; i++) total += getSize(subs[i]);\n    return total;\n}\n","name":"getSize","className":"RecursionExampleDirectory","variables":{"total":4,"subs":2,"files":2,"i":8,"dir":2},"constants":{"0":3},"javaDoc":"","comments":"check files get sub directories and check them ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getSize":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"RecursionExampleDirectory":1,"Directory":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":9,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    RecursionExampleDirectory r = new RecursionExampleDirectory();\n    Directory d = new Directory();\n    System.out.println(r.getSize(d));\n}\n","name":"main","className":"RecursionExampleDirectory","variables":{"r":2,"d":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"fact":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":8,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"//pre: n >= 0\npublic static int fact(int n) {\n    int result = 0;\n    if (n == 0)\n        result = 1;\n    else\n        result = n * fact(n - 1);\n    return result;\n}\n","name":"fact","className":"RecursionExampleDirectory","variables":{"result":4,"n":3},"constants":{"0":2,"1":2},"javaDoc":"","comments":"pre: n >= 0","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"int","methodCalls":{"pow":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":9,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"//pre: exp >= 0\npublic static int pow(int base, int exp) {\n    int result = 0;\n    if (exp == 0)\n        result = 1;\n    else\n        result = base * pow(base, exp - 1);\n    return result;\n}\n","name":"pow","className":"RecursionExampleDirectory","variables":{"result":4,"exp":2,"base":1},"constants":{"0":2,"1":2},"javaDoc":"","comments":"pre: exp >= 0","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"fib":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"BinaryExpr":6,"NameExpr":11,"AssignExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"//slow fib\n//pre: n >= 1\npublic static int fib(int n) {\n    int result = 0;\n    if (n == 1 || n == 2)\n        result = 1;\n    else\n        result = fib(n - 1) + fib(n - 2);\n    return result;\n}\n","name":"fib","className":"RecursionExampleDirectory","variables":{"result":4,"n":4},"constants":{"0":1,"1":3,"2":2},"javaDoc":"","comments":"pre: n >= 1","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int","int"],"returnType":"int","methodCalls":{"minWasted":2,"min":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":32,"FieldAccessExpr":1,"AssignExpr":4,"MethodCallExpr":3},"statements":{"IfStmt":3,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":7},"text":"public static int minWasted(int[] items, int itemNum, int capLeft) {\n    int result = 0;\n    if (itemNum >= items.length)\n        result = capLeft;\n    else if (capLeft == 0)\n        result = 0;\n    else {\n        int minWithout = minWasted(items, itemNum + 1, capLeft);\n        if (capLeft <= items[itemNum]) {\n            int minWith = minWasted(items, itemNum + 1, capLeft - items[itemNum]);\n            result = Math.min(minWith, minWithout);\n        } else\n            result = minWithout;\n    }\n    return result;\n}\n","name":"minWasted","className":"RecursionExampleDirectory","variables":{"result":6,"minWithout":2,"itemNum":5,"minWith":1,"capLeft":4,"Math":1,"items":2},"constants":{"0":3,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Directory","methodCalls":{"random":3},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":4},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":27,"UnaryExpr":2,"AssignExpr":4,"CastExpr":3,"FieldAccessExpr":2,"EnclosedExpr":3,"ArrayCreationExpr":2,"MethodCallExpr":3},"statements":{"ForStmt":2,"ExpressionStmt":6},"text":"public Directory() {\n    int numSubs = (int) (Math.random() * 3);\n    mySubs = new Directory[numSubs];\n    int numFiles = (int) (Math.random() * 10);\n    myFiles = new File[numFiles];\n    for (int i = 0; i < myFiles.length; i++) myFiles[i] = new File((int) (Math.random() * 1000));\n    for (int i = 0; i < mySubs.length; i++) mySubs[i] = new Directory();\n}\n","name":"Directory","className":"Directory","variables":{"numSubs":2,"myFiles":2,"numFiles":2,"i":8,"Math":3,"mySubs":2},"constants":{"0":2,"3":1,"1000":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Directory[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Directory[] getSubs() {\n    return mySubs;\n}\n","name":"getSubs","className":"Directory","variables":{"mySubs":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"File[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public File[] getFiles() {\n    return myFiles;\n}\n","name":"getFiles","className":"Directory","variables":{"myFiles":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"File","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public File(int size) {\n    iMySize = size;\n}\n","name":"File","className":"File","variables":{"size":1,"iMySize":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getSize() {\n    return iMySize;\n}\n","name":"getSize","className":"File","variables":{"iMySize":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"stop":2,"getPrimes":1,"start":2,"printTest":5,"isPrime":4,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Stopwatch":1,"boolean[]":1,"int":3},"expressions":{"IntegerLiteralExpr":20,"ObjectCreationExpr":3,"VariableDeclarationExpr":6,"BinaryExpr":8,"NameExpr":73,"StringLiteralExpr":5,"FieldAccessExpr":6,"UnaryExpr":3,"MethodCallExpr":20},"statements":{"IfStmt":2,"BlockStmt":2,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":21},"text":"/**\n\t * @param args\n\t */\npublic static void main(String[] args) {\n    printTest(10, 4);\n    printTest(2, 2);\n    printTest(54161329, 4);\n    printTest(1882341361, 2);\n    printTest(36, 9);\n    System.out.println(isPrime(54161329) + \" expect false\");\n    System.out.println(isPrime(1882341361) + \" expect true\");\n    System.out.println(isPrime(2) + \" expect true\");\n    int numPrimes = 0;\n    Stopwatch s = new Stopwatch();\n    s.start();\n    for (int i = 2; i < 10000000; i++) {\n        if (isPrime(i)) {\n            numPrimes++;\n        }\n    }\n    s.stop();\n    System.out.println(numPrimes + \" \" + s);\n    s.start();\n    boolean[] primes = getPrimes(10000000);\n    int np = 0;\n    for (boolean b : primes) if (b)\n        np++;\n    s.stop();\n    System.out.println(np + \" \" + s);\n    System.out.println(new BigInteger(1024, 10, new Random()));\n}\n","name":"main","className":"PrimeEx","variables":{"primes":2,"np":3,"b":2,"s":7,"numPrimes":3,"i":3},"constants":{"54161329":2,"36":1,"1882341361":2,"\" \"":2,"\" expect true\"":2,"0":2,"2":5,"\" expect false\"":1,"4":2,"1024":1,"10000000":2,"9":1,"10":2},"javaDoc":"args","comments":"\n\t * @param args\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"boolean[]","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":1,"boolean[]":1,"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":5,"BooleanLiteralExpr":2,"NameExpr":27,"FieldAccessExpr":2,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":6},"text":"public static boolean[] getPrimes(int max) {\n    boolean[] result = new boolean[max + 1];\n    for (int i = 2; i < result.length; i++) result[i] = true;\n    final double LIMIT = Math.sqrt(max);\n    for (int i = 2; i <= LIMIT; i++) {\n        if (result[i]) {\n            // cross out all multiples;\n            int index = 2 * i;\n            while (index < result.length) {\n                result[index] = false;\n                index += i;\n            }\n        }\n    }\n    return result;\n}\n","name":"getPrimes","className":"PrimeEx","variables":{"result":5,"max":1,"i":10,"index":4,"LIMIT":2,"Math":1},"constants":{"1":1,"2":3,"true":1,"false":1},"javaDoc":"","comments":"cross out all multiples; ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"stop":1,"numFactors":1,"start":1,"time":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Stopwatch":1,"int":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":7,"NameExpr":37,"StringLiteralExpr":6,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"IfStmt":1,"ExpressionStmt":8},"text":"public static void printTest(int num, int expectedFactors) {\n    Stopwatch st = new Stopwatch();\n    st.start();\n    int actualFactors = numFactors(num);\n    st.stop();\n    System.out.println(\"Testing \" + num + \" expect \" + expectedFactors + \", \" + \"actual \" + actualFactors);\n    if (actualFactors == expectedFactors)\n        System.out.println(\"PASSED\");\n    else\n        System.out.println(\"FAILED\");\n    System.out.println(st.time());\n}\n","name":"printTest","className":"PrimeEx","variables":{"st":4,"num":1,"actualFactors":3,"expectedFactors":2},"constants":{"\"actual \"":1,"\"Testing \"":1,"\" expect \"":1,"\", \"":1,"\"FAILED\"":1,"\"PASSED\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"boolean","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"boolean":1,"double":1,"int":1},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":3,"BinaryExpr":9,"BooleanLiteralExpr":1,"NameExpr":16,"StringLiteralExpr":1,"ConditionalExpr":1,"EnclosedExpr":1,"MethodCallExpr":1,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"// pre: num >= 2\npublic static boolean isPrime(int num) {\n    assert num >= 2 : \"failed precondition. num must be >= 2. num: \" + num;\n    final double LIMIT = Math.sqrt(num);\n    boolean isPrime = (num == 2) ? true : num % 2 != 0;\n    int div = 3;\n    while (div <= LIMIT && isPrime) {\n        isPrime = num % div != 0;\n        div += 2;\n    }\n    return isPrime;\n}\n","name":"isPrime","className":"PrimeEx","variables":{"div":4,"num":5,"LIMIT":2,"Math":1,"isPrime":4},"constants":{"0":2,"2":4,"3":1,"true":1,"\"failed precondition. num must be >= 2. num: \"":1},"javaDoc":"","comments":" pre: num >= 2","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"double":1,"int":2},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"BinaryExpr":7,"NameExpr":16,"StringLiteralExpr":1,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":2,"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"// pre: num >= 2\npublic static int numFactors(int num) {\n    assert num >= 2 : \"failed precondition. num must be >= 2. num: \" + num;\n    int result = 0;\n    final double SQRT = Math.sqrt(num);\n    for (int i = 1; i < SQRT; i++) {\n        if (num % i == 0) {\n            result += 2;\n        }\n    }\n    if (num % SQRT == 0)\n        result++;\n    return result;\n}\n","name":"numFactors","className":"PrimeEx","variables":{"result":4,"SQRT":3,"num":4,"i":4,"Math":1},"constants":{"0":3,"1":1,"2":2,"\"failed precondition. num must be >= 2. num: \"":1},"javaDoc":"","comments":" pre: num >= 2","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"createFreqTableURL":1,"createTable":1,"sum":2,"System.out.println":8},"annotations":[],"exceptions":["FileNotFoundException","IOException"],"concepts":["ExceptionHandling"],"types":{"int[]":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":18,"NameExpr":76,"StringLiteralExpr":14,"UnaryExpr":2,"AssignExpr":2,"ArrayInitializerExpr":1,"CastExpr":2,"FieldAccessExpr":11,"ArrayCreationExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":2,"BlockStmt":7,"TryStmt":1,"ForStmt":2,"ExpressionStmt":11},"text":"// program to create a frequency table.\n// Example of simple try catch blocks to deal with checked exceptions\npublic static void main(String[] args) {\n    int[] freqs = createFreqTableURL(\"http://www.utexas.edu/\");\n    if (freqs.length == 0)\n        System.out.println(\"No frequency table created due to problems when reading from file\");\n    else {\n        for (int i = 0; i < NUM_ASCII_CHAR; i++) {\n            System.out.println(\"charcater code: \" + i + \" ,character: \" + (char) i + \" ,frequency: \" + freqs[i]);\n        }\n        System.out.println(\"Total characters in file: \" + sum(freqs));\n    }\n    freqs = new int[] {};\n    try {\n        freqs = createTable(\"ciaFactBook2008.txt\");\n    } catch (FileNotFoundException e) {\n        System.out.println(\"File not found. Unable to create freq table\" + e);\n    } catch (IOException e) {\n        System.out.println(\"Problem while reading from file. Unable to create freq table\" + e);\n    }\n    if (freqs.length == 0)\n        System.out.println(\"No frequency table created due to problems when reading from file\");\n    else {\n        for (int i = 0; i < freqs.length; i++) {\n            System.out.println(\"charcater code: \" + i + \" ,character: \" + (char) i + \" ,frequency: \" + freqs[i]);\n        }\n        System.out.println(\"Total characters in file: \" + sum(freqs));\n    }\n}\n","name":"main","className":"FreqTableExampleOriginal","variables":{"NUM_ASCII_CHAR":1,"e":4,"freqs":5,"i":12},"constants":{"0":4,"\"Problem while reading from file. Unable to create freq table\"":1,"\" ,frequency: \"":2,"\"File not found. Unable to create freq table\"":1,"\"No frequency table created due to problems when reading from file\"":2,"\"ciaFactBook2008.txt\"":1,"\"http://www.utexas.edu/\"":1,"\"charcater code: \"":2,"\"Total characters in file: \"":2,"\" ,character: \"":2},"javaDoc":"","comments":" Example of simple try catch blocks to deal with checked exceptions","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":5,"StringLiteralExpr":2,"AssignExpr":1},"statements":{"BlockStmt":1,"AssertStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"// return sum of ints in list\n// list may not be null\nprivate static int sum(int[] list) {\n    assert list != null : \"Failed precondition, sum: parameter list\" + \" may not be null.\";\n    int total = 0;\n    for (int x : list) {\n        total += x;\n    }\n    return total;\n}\n","name":"sum","className":"FreqTableExampleOriginal","variables":{"total":3,"x":2,"list":2},"constants":{"0":1,"\" may not be null.\"":1,"null":1,"\"Failed precondition, sum: parameter list\"":1},"javaDoc":"","comments":" list may not be null","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"read":1,"ready":1,"openStream":1,"close":1,"System.out.println":3},"annotations":[],"exceptions":["MalformedURLException","IOException","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"InputStreamReader":1,"int[]":1,"URL":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":8,"NameExpr":43,"StringLiteralExpr":5,"UnaryExpr":1,"AssignExpr":2,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":4,"ArrayCreationExpr":3,"MethodCallExpr":7},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":11},"text":"// pre: url != null\n// Connect to the URL specified by the String url.\n// Map characters to index in array.\n// All non ASCII character dumped into one element of array\n// If IOException occurs message printed and array of\n// length 0 returned.\npublic static int[] createFreqTableURL(String url) {\n    if (url == null)\n        throw new IllegalArgumentException(\"Violation of precondition. parameter url must not be null.\");\n    int[] freqs = new int[NUM_ASCII_CHAR];\n    try {\n        URL inputURL = new URL(url);\n        InputStreamReader in = new InputStreamReader(inputURL.openStream());\n        while (in.ready()) {\n            int c = in.read();\n            if (0 <= c && c < freqs.length)\n                freqs[c]++;\n            else\n                System.out.println(\"Non ASCII char: \" + c + \" \" + (char) c);\n        }\n        in.close();\n    } catch (MalformedURLException e) {\n        System.out.println(\"Bad URL.\");\n        freqs = new int[0];\n    } catch (IOException e) {\n        System.out.println(\"Unable to read from resource.\" + e);\n        freqs = new int[0];\n    }\n    return freqs;\n}\n","name":"createFreqTableURL","className":"FreqTableExampleOriginal","variables":{"c":6,"NUM_ASCII_CHAR":1,"in":4,"e":3,"freqs":5,"inputURL":2,"url":2},"constants":{"0":3,"\"Bad URL.\"":1,"\"Non ASCII char: \"":1,"null":1,"\" \"":1,"\"Violation of precondition. parameter url must not be null.\"":1,"\"Unable to read from resource.\"":1},"javaDoc":"","comments":" length 0 returned.","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"read":1,"ready":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["FileNotFoundException","IOException"],"concepts":[],"types":{"int[]":1,"FileReader":1,"File":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":26,"CastExpr":1,"FieldAccessExpr":2,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"// Connect to the file specified by the String fileName.\n// Assumes it is in same directory as compiled code.\n// Map characters to index in array.\npublic static int[] createTable(String fileName) throws FileNotFoundException, IOException {\n    int[] freqs = new int[NUM_ASCII_CHAR];\n    File f = new File(fileName);\n    FileReader r = new FileReader(f);\n    while (r.ready()) {\n        int ch = r.read();\n        //                freqs[INDEX_NON_ASCII]++;\n        if (0 <= ch && ch < freqs.length)\n            freqs[ch]++;\n        else\n            System.out.println((char) ch);\n    }\n    r.close();\n    return freqs;\n}\n //            if( 0 <= ch && ch <= NUM_ASCII_CHAR)\n\n //                freqs[ch]++;\n\n //            else\n\n","name":"createTable","className":"FreqTableExampleOriginal","variables":{"fileName":1,"r":4,"NUM_ASCII_CHAR":1,"ch":5,"f":2,"freqs":3},"constants":{"0":1},"javaDoc":"","comments":"if( 0 <= ch && ch <= NUM_ASCII_CHAR) freqs[ch]++; else freqs[INDEX_NON_ASCII]++;  Map characters to index in array.","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"SortedIntList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public SortedIntList(int initialCap) {\n    //call IntList constructor\n    super(initialCap);\n}\n","name":"SortedIntList","className":"SortedIntList","variables":{"initialCap":1},"constants":{},"javaDoc":"","comments":"call IntList constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"SortedIntList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public SortedIntList() {\n    super();\n}\n","name":"SortedIntList","className":"SortedIntList","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"size":1,"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":3,"NameExpr":12,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"//override add\npublic void add(int value) {\n    //search for location to insert value\n    int pos = 0;\n    while (pos < size() && value > get(pos)) {\n        pos++;\n    }\n    super.insert(pos, value);\n}\n","name":"add","className":"SortedIntList","variables":{"pos":3,"value":1},"constants":{"0":1},"javaDoc":"","comments":"search for location to insert value override add","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"size":1,"containsKey":1,"get":2,"hasNext":1,"keySet":1,"put":2,"System.out.println":3},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"Scanner":1,"Map<String, Integer>":1,"String":2,"TreeMap":1,"File":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":3,"StringLiteralExpr":3,"NameExpr":50,"FieldAccessExpr":3,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ForeachStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    try {\n        File f = new File(\"ciaFactBook2008.txt\");\n        Scanner sc;\n        sc = new Scanner(f);\n        // sc.useDelimiter(\"[^a-zA-Z']+\");\n        Map<String, Integer> wordCount = new TreeMap<String, Integer>();\n        while (sc.hasNext()) {\n            String word = sc.next();\n            if (!wordCount.containsKey(word))\n                wordCount.put(word, 1);\n            else\n                wordCount.put(word, wordCount.get(word) + 1);\n        }\n        // show results\n        for (String word : wordCount.keySet()) System.out.println(word + \" \" + wordCount.get(word));\n        System.out.println(wordCount.size());\n    } catch (IOException e) {\n        System.out.println(\"Unable to read from file.\");\n    }\n}\n","name":"main","className":"SimpleWordCounter","variables":{"sc":4,"wordCount":8,"e":1,"f":2,"word":3},"constants":{"1":2,"\" \"":1,"\"Unable to read from file.\"":1,"\"ciaFactBook2008.txt\"":1},"javaDoc":"","comments":"sc useDelimiter(\"[^a-zA-Z']+\"); show results ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"next":1,"printStackTrace":1,"openConnection":1,"hasNext":1,"getInputStream":1,"close":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"URL":1,"URLConnection":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":30,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    try {\n        URL mySite = new URL(\"http://www.cs.utexas.edu/~scottm\");\n        URLConnection yc = mySite.openConnection();\n        Scanner in = new Scanner(new InputStreamReader(yc.getInputStream()));\n        int count = 0;\n        while (in.hasNext()) {\n            System.out.println(in.next());\n            count++;\n        }\n        System.out.println(\"Number of tokens: \" + count);\n        in.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n","name":"main","className":"URLExpSimple","variables":{"mySite":2,"in":4,"e":2,"count":3,"yc":2},"constants":{"0":1,"\"http://www.cs.utexas.edu/~scottm\"":1,"\"Number of tokens: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"DemoClass","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public DemoClass() {\n    // assign default value\n    x = 0;\n}\n","name":"DemoClass","className":"DemoClass","variables":{"x":1},"constants":{"0":1},"javaDoc":"","comments":"assign default value ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"DemoClass","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public DemoClass(int x) {\n    // use this.x to refer to the instance variable x\n    // use x to refer to a local variable x (more specifically,\n    // method parameter x)\n    this.x = x;\n}\n","name":"DemoClass","className":"DemoClass","variables":{"x":1},"constants":{},"javaDoc":"","comments":"use this x to refer to the instance variable x use x to refer to a local variable x (more specifically method parameter x) ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DemoClass"],"returnType":"DemoClass","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"FieldAccessExpr":2,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public DemoClass(DemoClass otherDemo) {\n    // copy the value from the otherDemo\n    this.x = otherDemo.x;\n}\n","name":"DemoClass","className":"DemoClass","variables":{},"constants":{},"javaDoc":"","comments":"copy the value from the otherDemo ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"ReturnStmt":1},"text":"// static method (aka class method)\npublic static void s1() {\n    return;\n}\n","name":"s1","className":"DemoClass","variables":{},"constants":{},"javaDoc":"","comments":" static method (aka class method)","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"ReturnStmt":1},"text":"// instance method\npublic void i1() {\n    return;\n}\n","name":"i1","className":"DemoClass","variables":{},"constants":{},"javaDoc":"","comments":" instance method","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"s1":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"// static calling static OK\n// static calling instance is a compile-time error\npublic static void s2() {\n    //        i1();     // compile-time error\n    // DemoClass.s1\n    s1();\n    return;\n}\n","name":"s2","className":"DemoClass","variables":{},"constants":{},"javaDoc":"","comments":"i1(); // compile-time error DemoClass s1  static calling instance is a compile-time error","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"i1":1,"s1":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"// instance calling static OK\n// instance calling instance OK\npublic void i2() {\n    // DemoClass.s1();\n    s1();\n    // this.i1();\n    i1();\n    return;\n}\n","name":"i2","className":"DemoClass","variables":{},"constants":{},"javaDoc":"","comments":"DemoClass s1(); this i1();  instance calling instance OK","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"overload":8,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"DoubleLiteralExpr":2,"BooleanLiteralExpr":1,"NameExpr":21,"StringLiteralExpr":1,"CastExpr":2,"LongLiteralExpr":1,"FieldAccessExpr":1,"CharLiteralExpr":1,"MethodCallExpr":9},"statements":{"ExpressionStmt":9},"text":"// call various versions of overload() based on their \n// list of parameters (aka function signatures)\npublic void overloadTester() {\n    System.out.println(\"overloadTester:\\n\");\n    overload((byte) 1);\n    overload((short) 1);\n    overload(1);\n    overload(1L);\n    overload(1.0f);\n    overload(1.0);\n    overload('1');\n    overload(true);\n}\n","name":"overloadTester","className":"DemoClass","variables":{},"constants":{"1":3,"1.0":1,"\"overloadTester:\\n\"":1,"1.0f":1,"true":1,"1L":1,"'1'":1},"javaDoc":"","comments":" list of parameters (aka function signatures)","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["byte"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(byte b) {\n    System.out.println(\"byte\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"byte\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["short"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(short s) {\n    System.out.println(\"short\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"short\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(int i) {\n    System.out.println(\"int\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"int\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["long"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(long l) {\n    System.out.println(\"long\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"long\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(float f) {\n    System.out.println(\"float\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"float\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(double d) {\n    System.out.println(\"double\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"double\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(char c) {\n    System.out.println(\"char\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"char\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void overload(boolean b) {\n    System.out.println(\"boolean\");\n}\n","name":"overload","className":"DemoClass","variables":{},"constants":{"\"boolean\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"overloadTester":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"DemoClass":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    DemoClass dc = new DemoClass();\n    dc.overloadTester();\n}\n","name":"main","className":"DemoClass","variables":{"dc":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"toBinaryString":1,"toBinary":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":5,"NameExpr":27,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":2,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    for (int i = -5; i < 33; i++) {\n        System.out.println(i + \": \" + toBinary(i));\n        System.out.println(i);\n        //always another way\n        System.out.println(i + \": \" + Integer.toBinaryString(i));\n    }\n}\n","name":"main","className":"BinaryConverter","variables":{"Integer":1,"i":5},"constants":{"33":1,"5":1,"\": \"":2},"javaDoc":"","comments":"always another way ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"String","methodCalls":{"abs":1,"all0sAnd1s":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"String":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":2,"BinaryExpr":10,"NameExpr":24,"StringLiteralExpr":3,"EnclosedExpr":1,"AssignExpr":5,"MethodCallExpr":2},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":1,"AssertStmt":2,"ReturnStmt":1,"ExpressionStmt":7},"text":"/*\n     * pre: none\n     * post: returns a String with base10Num in base 2\n     */\npublic static String toBinary(int base10Num) {\n    boolean isNeg = base10Num < 0;\n    base10Num = Math.abs(base10Num);\n    String result = \"\";\n    while (base10Num > 1) {\n        result = (base10Num % 2) + result;\n        base10Num /= 2;\n    }\n    assert base10Num == 0 || base10Num == 1 : \"value is not <= 1: \" + base10Num;\n    result = base10Num + result;\n    assert all0sAnd1s(result);\n    if (isNeg)\n        result = \"-\" + result;\n    return result;\n}\n","name":"toBinary","className":"BinaryConverter","variables":{"result":8,"base10Num":9,"isNeg":2,"Math":1},"constants":{"0":2,"\"\"":1,"1":2,"2":2,"\"-\"":1,"\"value is not <= 1: \"":1},"javaDoc":"","comments":"\n     * pre: none\n     * post: returns a String with base10Num in base 2\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"length":1,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"char":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":16,"StringLiteralExpr":1,"CharLiteralExpr":2,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"/*\n     * pre: cal != null\n     * post: return true if val consists only of characters 1 and 0, false otherwise\n     */\npublic static boolean all0sAnd1s(String val) {\n    assert val != null : \"Failed precondition all0sAnd1s. parameter cannot be null\";\n    boolean all = true;\n    int i = 0;\n    char c;\n    while (all && i < val.length()) {\n        c = val.charAt(i);\n        all = c == '0' || c == '1';\n        i++;\n    }\n    return all;\n}\n","name":"all0sAnd1s","className":"BinaryConverter","variables":{"val":3,"all":4,"c":4,"i":3},"constants":{"0":1,"null":1,"\"Failed precondition all0sAnd1s. parameter cannot be null\"":1,"true":1,"'1'":1,"'0'":1},"javaDoc":"","comments":"\n     * pre: cal != null\n     * post: return true if val consists only of characters 1 and 0, false otherwise\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"factorial":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    final int NUM_FACTS = 100;\n    for (int i = 0; i < NUM_FACTS; i++) System.out.println(i + \"! is \" + factorial(i));\n}\n","name":"main","className":"Factorial","variables":{"i":4,"NUM_FACTS":2},"constants":{"0":1,"100":1,"\"! is \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":6,"UnaryExpr":1,"AssignExpr":1},"statements":{"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static int factorial(int n) {\n    int result = 1;\n    for (int i = 2; i <= n; i++) result *= i;\n    return result;\n}\n","name":"factorial","className":"Factorial","variables":{"result":3,"i":4,"n":1},"constants":{"1":1,"2":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"bubblesort":4,"showList":4,"findAndPrintPairs":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":34,"VariableDeclarationExpr":1,"ArrayInitializerExpr":4,"NameExpr":30,"ArrayCreationExpr":3,"UnaryExpr":2,"MethodCallExpr":9,"AssignExpr":3},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    int[] list = { 1, 2, 3, 4, 1, 2, 3 };\n    findAndPrintPairs(list, 5);\n    bubblesort(list);\n    showList(list);\n    list = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };\n    bubblesort(list);\n    showList(list);\n    list = new int[] { 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2 };\n    bubblesort(list);\n    showList(list);\n    list = new int[] { 1 };\n    bubblesort(list);\n    showList(list);\n}\n","name":"main","className":"ArrayExamples","variables":{"list":4},"constants":{"11":2,"0":1,"1":6,"2":5,"3":4,"4":3,"5":3,"6":2,"7":2,"8":2,"9":2,"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":16,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":2,"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"// pre: list != null, list.length > 0\n// post: return index of minimum element of array\npublic static int findMin(int[] list) {\n    assert list != null && list.length > 0 : \"failed precondition\";\n    int indexOfMin = 0;\n    for (int i = 1; i < list.length; i++) {\n        if (list[i] < list[indexOfMin]) {\n            indexOfMin = i;\n        }\n    }\n    return indexOfMin;\n}\n","name":"findMin","className":"ArrayExamples","variables":{"indexOfMin":4,"i":5,"list":3},"constants":{"0":2,"1":1,"null":1,"\"failed precondition\"":1},"javaDoc":"","comments":" post: return index of minimum element of array","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"void","methodCalls":{"min":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":19,"StringLiteralExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":2},"statements":{"BlockStmt":1,"AssertStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/*\n\t *pre: list != null, newSize >= 0\n\t *post: nothing. the method does not succeed it resizing the\n\t * argument\n\t */\npublic static void badResize(int[] list, int newSize) {\n    assert list != null && newSize >= 0 : \"failed precondition\";\n    int[] temp = new int[newSize];\n    int limit = Math.min(list.length, newSize);\n    for (int i = 0; i < limit; i++) {\n        temp[i] = list[i];\n    }\n    // uh oh!! Changing pointer, not pointee. This breaks the\n    // relationship between the parameter and argument\n    list = temp;\n}\n","name":"badResize","className":"ArrayExamples","variables":{"temp":3,"limit":2,"i":5,"newSize":2,"list":3,"Math":1},"constants":{"0":2,"null":1,"\"failed precondition\"":1},"javaDoc":"","comments":"uh oh!! Changing pointer not pointee This breaks the relationship between the parameter and argument \n\t *pre: list != null, newSize >= 0\n\t *post: nothing. the method does not succeed it resizing the\n\t * argument\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"int[]","methodCalls":{"min":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"BlockStmt":1,"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/*\n\t *pre: list != null, newSize >= 0\n\t *post: returns an array of size newSize. Elements from 0 to newSize - 1\n\t *\twill be copied into the new array\n\t */\npublic static int[] goodResize(int[] list, int newSize) {\n    assert list != null && newSize >= 0 : \"failed precondition\";\n    int[] result = new int[newSize];\n    int limit = Math.min(list.length, newSize);\n    for (int i = 0; i < limit; i++) {\n        result[i] = list[i];\n    }\n    return result;\n}\n","name":"goodResize","className":"ArrayExamples","variables":{"result":3,"limit":2,"i":5,"newSize":2,"list":2,"Math":1},"constants":{"0":2,"null":1,"\"failed precondition\"":1},"javaDoc":"","comments":"\n\t *pre: list != null, newSize >= 0\n\t *post: returns an array of size newSize. Elements from 0 to newSize - 1\n\t *\twill be copied into the new array\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]","int"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":15,"NameExpr":29,"StringLiteralExpr":6,"FieldAccessExpr":3,"UnaryExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"AssertStmt":1,"ForStmt":2,"ExpressionStmt":1},"text":"/*\n\t *pre: list != null\n\t *post: prints out the indices and values of all pairs of numbers\n\t *in list such that list[a] + list[b] = target\n\t */\npublic static void findAndPrintPairs(int[] list, int target) {\n    assert list != null : \"failed precondition\";\n    for (int i = 0; i < list.length; i++) {\n        for (int j = i + 1; j < list.length; j++) {\n            if (list[i] + list[j] == target) {\n                System.out.println(\"The two elements at indices \" + i + \" and \" + j + \" are \" + list[i] + \" and \" + list[j] + \" add up to \" + target);\n            }\n        }\n    }\n}\n","name":"findAndPrintPairs","className":"ArrayExamples","variables":{"i":7,"j":6,"list":5,"target":2},"constants":{"0":1,"\" add up to \"":1,"1":1,"\"The two elements at indices \"":1,"\" and \"":2,"\" are \"":1,"null":1,"\"failed precondition\"":1},"javaDoc":"","comments":"\n\t *pre: list != null\n\t *post: prints out the indices and values of all pairs of numbers\n\t *in list such that list[a] + list[b] = target\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"isAscending":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":3},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":16,"NameExpr":38,"StringLiteralExpr":3,"UnaryExpr":2,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":3,"FieldAccessExpr":3,"EnclosedExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"AssertStmt":3,"ForStmt":2,"ExpressionStmt":7},"text":"/*\n\t *pre: list != null;\n\t *post: sort the elements of list so that they are in ascending order\n\t */\npublic static void bubblesort(int[] list) {\n    assert list != null : \"failed precondition\";\n    int temp;\n    boolean changed = true;\n    for (int i = 0; i < list.length && changed; i++) {\n        changed = false;\n        for (int j = 0; j < list.length - i - 1; j++) {\n            assert (j > 0) && (j + 1 < list.length) : \"loop counter j \" + j + \"is out of bounds.\";\n            if (list[j] > list[j + 1]) {\n                changed = true;\n                temp = list[j + 1];\n                list[j + 1] = list[j];\n                list[j] = temp;\n            }\n        }\n    }\n    assert isAscending(list);\n}\n","name":"bubblesort","className":"ArrayExamples","variables":{"temp":3,"i":4,"j":12,"list":7,"changed":4},"constants":{"0":3,"1":5,"null":1,"\"is out of bounds.\"":1,"true":2,"false":1,"\"failed precondition\"":1,"\"loop counter j \"":1},"javaDoc":"","comments":"\n\t *pre: list != null;\n\t *post: sort the elements of list so that they are in ascending order\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public static void showList(int[] list) {\n    for (int i = 0; i < list.length; i++) System.out.print(list[i] + \" \");\n    System.out.println();\n}\n","name":"showList","className":"ArrayExamples","variables":{"i":4,"list":1},"constants":{"0":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":7,"NameExpr":17,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/* \tpre: list != null\n\t\tpost: return true if list is sorted in ascedning order, false otherwise\n\t*/\npublic static boolean isAscending(int[] list) {\n    boolean ascending = true;\n    int index = 1;\n    while (ascending && index < list.length) {\n        assert index >= 0 && index < list.length;\n        ascending = (list[index - 1] <= list[index]);\n        index++;\n    }\n    return ascending;\n}\n","name":"isAscending","className":"ArrayExamples","variables":{"index":7,"ascending":4,"list":2},"constants":{"0":1,"1":2,"true":1},"javaDoc":"","comments":" \tpre: list != null\n\t\tpost: return true if list is sorted in ascedning order, false otherwise\n\t","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addOne":1,"printList":3,"addOneError":1,"sumListEnhanced":1,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1,"int":1},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"BinaryExpr":1,"NameExpr":49,"StringLiteralExpr":6,"FieldAccessExpr":6,"MethodCallExpr":12},"statements":{"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    int[] list = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int sum = sumListEnhanced(list);\n    System.out.println(\"Sum of elements in list: \" + sum);\n    System.out.println(\"Original List\");\n    printList(list);\n    System.out.println(\"Calling addOne\");\n    addOne(list);\n    System.out.println(\"List after call to addOne\");\n    printList(list);\n    System.out.println(\"Calling addOneError\");\n    addOneError(list);\n    System.out.println(\"List after call to addOneError. Note elements of list did not change.\");\n    printList(list);\n}\n","name":"main","className":"EnhancedFor","variables":{"sum":2,"list":1},"constants":{"\"Sum of elements in list: \"":1,"\"Calling addOneError\"":1,"1":1,"2":1,"3":1,"\"Original List\"":1,"\"List after call to addOneError. Note elements of list did not change.\"":1,"4":1,"5":1,"\"List after call to addOne\"":1,"6":1,"7":1,"8":1,"9":1,"10":1,"\"Calling addOne\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"// pre: list != null\n// post: return sum of elements\n// uses enhanced for loop\npublic static int sumListEnhanced(int[] list) {\n    int total = 0;\n    for (int val : list) {\n        total += val;\n    }\n    return total;\n}\n","name":"sumListEnhanced","className":"EnhancedFor","variables":{"val":2,"total":3,"list":1},"constants":{"0":1},"javaDoc":"","comments":" uses enhanced for loop","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"int","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":16,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"// pre: list != null\n// post: return sum of elements\n// use traditional for loop\npublic static int sumListOld(int[] list) {\n    int total = 0;\n    for (int i = 0; i < list.length; i++) {\n        total += list[i];\n        System.out.println(list[i]);\n    }\n    return total;\n}\n","name":"sumListOld","className":"EnhancedFor","variables":{"total":3,"i":5,"list":2},"constants":{"0":2},"javaDoc":"","comments":" use traditional for loop","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":1},"text":"// pre: list != null\n// post: none.\n// The code appears to add one to every element in the list, but does not\npublic static void addOneError(int[] list) {\n    for (int val : list) {\n        val = val + 1;\n    }\n}\n","name":"addOneError","className":"EnhancedFor","variables":{"val":3,"list":1},"constants":{"1":1},"javaDoc":"","comments":" The code appears to add one to every element in the list, but does not","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":7,"FieldAccessExpr":1,"UnaryExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":1},"text":"// pre: list != null\n// post: adds one to every element of list\npublic static void addOne(int[] list) {\n    for (int i = 0; i < list.length; i++) {\n        list[i]++;\n    }\n}\n","name":"addOne","className":"EnhancedFor","variables":{"i":4,"list":1},"constants":{"0":1},"javaDoc":"","comments":" post: adds one to every element of list","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int[]"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":18,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"public static void printList(int[] list) {\n    System.out.println(\"index, value\");\n    for (int i = 0; i < list.length; i++) {\n        System.out.println(i + \", \" + list[i]);\n    }\n}\n","name":"printList","className":"EnhancedFor","variables":{"i":5,"list":1},"constants":{"0":1,"\", \"":1,"\"index, value\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"UnsortedHashSet","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":1,"CastExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public UnsortedHashSet() {\n    con = (LinkedList<E>[]) (new LinkedList[10]);\n}\n","name":"UnsortedHashSet","className":"UnsortedHashSet","variables":{"con":1},"constants":{"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{"abs":1,"hashCode":1,"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"DoubleLiteralExpr":1,"ArrayAccessExpr":4,"BinaryExpr":6,"NameExpr":34,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":3,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"public boolean add(E obj) {\n    int oldSize = size;\n    int index = Math.abs(obj.hashCode()) % con.length;\n    if (con[index] == null)\n        con[index] = new LinkedList<E>();\n    if (!con[index].contains(obj)) {\n        con[index].add(obj);\n        size++;\n    }\n    if (1.0 * size / con.length > LOAD_FACTOR_LIMIT)\n        resize();\n    return oldSize != size;\n}\n","name":"add","className":"UnsortedHashSet","variables":{"con":4,"size":4,"obj":1,"index":5,"Math":1,"oldSize":2,"LOAD_FACTOR_LIMIT":1},"constants":{"1.0":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"UnsortedHashSet<E>":1,"E":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":23,"UnaryExpr":1,"AssignExpr":2,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ForeachStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"private void resize() {\n    UnsortedHashSet<E> temp = new UnsortedHashSet<E>();\n    temp.con = (LinkedList<E>[]) (new LinkedList[con.length * 2 + 1]);\n    for (int i = 0; i < con.length; i++) {\n        if (con[i] != null)\n            for (E e : con[i]) temp.add(e);\n    }\n    con = temp.con;\n}\n","name":"resize","className":"UnsortedHashSet","variables":{"temp":2,"con":3,"e":1,"i":5},"constants":{"0":1,"1":1,"2":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int size() {\n    return size;\n}\n","name":"size","className":"UnsortedHashSet","variables":{"size":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["E"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Add an item to the end of this list.\n\t * <br>pre: none\n\t * <br>post: size() = old size() + 1, get(size() - 1) = item\n\t * @param item the data to be added to the end of this list\n\t */\nvoid add(E item);\n","name":"add","className":"IList","variables":{},"constants":{},"javaDoc":"Add an item to the end of this list <br>pre: none <br>post: size() = old size() + 1 get(size() - 1) = item item the data to be added to the end of this list","comments":"\n\t * Add an item to the end of this list.\n\t * <br>pre: none\n\t * <br>post: size() = old size() + 1, get(size() - 1) = item\n\t * @param item the data to be added to the end of this list\n\t ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int","E"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Insert an item at a specified position in the list.\n\t * <br>pre: 0 <= pos <= size()\n\t * <br>post: size() = old size() + 1, get(pos) = item, all elements in\n\t * the list with a positon >= pos have a position = old position + 1\n\t * @param pos the position to insert the data at in the list\n\t * @param item the data to add to the list\n\t*/\nvoid insert(int pos, E item);\n","name":"insert","className":"IList","variables":{},"constants":{},"javaDoc":"Insert an item at a specified position in the list <br>pre: 0 <= pos <= size() <br>post: size() = old size() + 1 get(pos) = item all elements in the list with a positon >= pos have a position = old position + 1 pos the position to insert the data at in the list item the data to add to the list","comments":"\n\t * Insert an item at a specified position in the list.\n\t * <br>pre: 0 <= pos <= size()\n\t * <br>post: size() = old size() + 1, get(pos) = item, all elements in\n\t * the list with a positon >= pos have a position = old position + 1\n\t * @param pos the position to insert the data at in the list\n\t * @param item the data to add to the list\n\t","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int","E"],"returnType":"E","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Change the data at the specified position in the list.\n\t * the old data at that position is returned.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: get(pos) = item, return the\n\t * old get(pos)\n     * @param pos the position in the list to overwrite\t \n\t * @param item the new item that will overwrite the old item\n\t * @return the old data at the specified position\n\t */\nE set(int pos, E item);\n","name":"set","className":"IList","variables":{},"constants":{},"javaDoc":"Change the data at the specified position in the list the old data at that position is returned <br>pre: 0 <= pos < size() <br>post: get(pos) = item return the old get(pos) pos the position in the list to overwrite item the new item that will overwrite the old item the old data at the specified position","comments":"\n\t * Change the data at the specified position in the list.\n\t * the old data at that position is returned.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: get(pos) = item, return the\n\t * old get(pos)\n     * @param pos the position in the list to overwrite\t \n\t * @param item the new item that will overwrite the old item\n\t * @return the old data at the specified position\n\t ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int"],"returnType":"E","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Get an element from the list.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the item at pos\n\t * @param pos specifies which element to get\n\t * @return the element at the specified position in the list\n\t */\nE get(int pos);\n","name":"get","className":"IList","variables":{},"constants":{},"javaDoc":"Get an element from the list <br>pre: 0 <= pos < size() <br>post: return the item at pos pos specifies which element to get the element at the specified position in the list","comments":"\n\t * Get an element from the list.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the item at pos\n\t * @param pos specifies which element to get\n\t * @return the element at the specified position in the list\n\t ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int"],"returnType":"E","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Remove an element in the list based on position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: size() = old size() - 1, all elements of\n\t * list with a positon > pos have a position = old position - 1\n\t * @param pos the position of the element to remove from the list\n\t * @return the data at position pos\n\t */\nE remove(int pos);\n","name":"remove","className":"IList","variables":{},"constants":{},"javaDoc":"Remove an element in the list based on position <br>pre: 0 <= pos < size() <br>post: size() = old size() - 1 all elements of list with a positon > pos have a position = old position - 1 pos the position of the element to remove from the list the data at position pos","comments":"\n\t * Remove an element in the list based on position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: size() = old size() - 1, all elements of\n\t * list with a positon > pos have a position = old position - 1\n\t * @param pos the position of the element to remove from the list\n\t * @return the data at position pos\n\t ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["E"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Remove the first occurrence of obj in this list.\n\t * Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t * <br>pre: none\n\t * <br>post: if obj is in this list the first occurence has been removed and size() = old size() - 1. \n\t * If obj is not present the list is not altered in any way.\n\t * @param obj The item to remove from this list.\n\t * @return Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t */\nboolean remove(E obj);\n","name":"remove","className":"IList","variables":{},"constants":{},"javaDoc":"Remove the first occurrence of obj in this list Return <tt>true</tt> if this list changed as a result of this call <tt>false</tt> otherwise <br>pre: none <br>post: if obj is in this list the first occurence has been removed and size() = old size() - 1 If obj is not present the list is not altered in any way obj The item to remove from this list Return <tt>true</tt> if this list changed as a result of this call <tt>false</tt> otherwise","comments":"\n\t * Remove the first occurrence of obj in this list.\n\t * Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t * <br>pre: none\n\t * <br>post: if obj is in this list the first occurence has been removed and size() = old size() - 1. \n\t * If obj is not present the list is not altered in any way.\n\t * @param obj The item to remove from this list.\n\t * @return Return <tt>true</tt> if this list changed as a result of this call, <tt>false</tt> otherwise.\n\t ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int","int"],"returnType":"IList<E>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Return a sublist of elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n\t * This list is not changed as a result of this call.\n\t * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n\t * <br>post: return a list whose size is stop - start and contains the elements at positions start through stop - 1 in this list.\n\t * @param start index of the first element of the sublist.\n\t * @param stop stop - 1 is the index of the last element of the sublist.\n\t * @return a list with <tt>stop - start</tt> elements, The elements are from positions <tt>start</tt> inclusive to\n\t * <tt>stop</tt> exclusive in this list.\n\t */\nIList<E> getSubList(int start, int stop);\n","name":"getSubList","className":"IList","variables":{},"constants":{},"javaDoc":"Return a sublist of elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive This list is not changed as a result of this call <br>pre: <tt>0 <= start < size() start <= stop <= size()</tt> <br>post: return a list whose size is stop - start and contains the elements at positions start through stop - 1 in this list start index of the first element of the sublist stop stop - 1 is the index of the last element of the sublist a list with <tt>stop - start</tt> elements The elements are from positions <tt>start</tt> inclusive to <tt>stop</tt> exclusive in this list","comments":"\n\t * Return a sublist of elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n\t * This list is not changed as a result of this call.\n\t * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n\t * <br>post: return a list whose size is stop - start and contains the elements at positions start through stop - 1 in this list.\n\t * @param start index of the first element of the sublist.\n\t * @param stop stop - 1 is the index of the last element of the sublist.\n\t * @return a list with <tt>stop - start</tt> elements, The elements are from positions <tt>start</tt> inclusive to\n\t * <tt>stop</tt> exclusive in this list.\n\t ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Return the size of this list. In other words the number of elements in this list.\n\t * <br>pre: none\n\t * <br>post: return the number of items in this list\n\t * @return the number of items in this list\n\t */\nint size();\n","name":"size","className":"IList","variables":{},"constants":{},"javaDoc":"Return the size of this list In other words the number of elements in this list <br>pre: none <br>post: return the number of items in this list the number of items in this list","comments":"\n\t * Return the size of this list. In other words the number of elements in this list.\n\t * <br>pre: none\n\t * <br>post: return the number of items in this list\n\t * @return the number of items in this list\n\t ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["E"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Find the position of an element in the list.\n\t * <br>pre: none\n\t * <br>post: return the index of the first element equal to item\n\t * or -1 if item is not present\n\t * @param item the element to search for in the list\n\t * @return return the index of the first element equal to item or a -1 if item is not present\n\t */\nint indexOf(E item);\n","name":"indexOf","className":"IList","variables":{},"constants":{},"javaDoc":"Find the position of an element in the list <br>pre: none <br>post: return the index of the first element equal to item or -1 if item is not present item the element to search for in the list return the index of the first element equal to item or a -1 if item is not present","comments":"\n\t * Find the position of an element in the list.\n\t * <br>pre: none\n\t * <br>post: return the index of the first element equal to item\n\t * or -1 if item is not present\n\t * @param item the element to search for in the list\n\t * @return return the index of the first element equal to item or a -1 if item is not present\n\t ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["E","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * find the position of an element in the list starting at a specified position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the index of the first element equal to item starting at pos\n\t * or -1 if item is not present from position pos onward\n\t * @param item the element to search for in the list\n\t * @param pos the position in the list to start searching from\n\t * @return starting from the specified position return the index of the first element equal to item or a -1 if item is not present between pos and the end of the list\n\t */\nint indexOf(E item, int pos);\n","name":"indexOf","className":"IList","variables":{},"constants":{},"javaDoc":"find the position of an element in the list starting at a specified position <br>pre: 0 <= pos < size() <br>post: return the index of the first element equal to item starting at pos or -1 if item is not present from position pos onward item the element to search for in the list pos the position in the list to start searching from starting from the specified position return the index of the first element equal to item or a -1 if item is not present between pos and the end of the list","comments":"\n\t * find the position of an element in the list starting at a specified position.\n\t * <br>pre: 0 <= pos < size()\n\t * <br>post: return the index of the first element equal to item starting at pos\n\t * or -1 if item is not present from position pos onward\n\t * @param item the element to search for in the list\n\t * @param pos the position in the list to start searching from\n\t * @return starting from the specified position return the index of the first element equal to item or a -1 if item is not present between pos and the end of the list\n\t ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * return the list to an empty state.\n\t * <br>pre: none\n\t * <br>post: size() = 0\n\t */\nvoid makeEmpty();\n","name":"makeEmpty","className":"IList","variables":{},"constants":{},"javaDoc":"return the list to an empty state <br>pre: none <br>post: size() = 0","comments":"\n\t * return the list to an empty state.\n\t * <br>pre: none\n\t * <br>post: size() = 0\n\t ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"Iterator<E>","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t* return an Iterator for this list.\n\t* <br>pre: none\n\t* <br>post: return an Iterator object for this List\n\t*/\nIterator<E> iterator();\n","name":"iterator","className":"IList","variables":{},"constants":{},"javaDoc":"return an Iterator for this list <br>pre: none <br>post: return an Iterator object for this List","comments":"\n\t* return an Iterator for this list.\n\t* <br>pre: none\n\t* <br>post: return an Iterator object for this List\n\t","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n     * Remove all elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n     * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n     * <br>post: <tt>size() = old size() - (stop - start)</tt>\n     * @param start position at beginning of range of elements to be removed\n     * @param stop stop - 1 is the position at the end of the range of elements to be removed\n     */\nvoid removeRange(int start, int stop);\n","name":"removeRange","className":"IList","variables":{},"constants":{},"javaDoc":"Remove all elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive <br>pre: <tt>0 <= start < size() start <= stop <= size()</tt> <br>post: <tt>size() = old size() - (stop - start)</tt> start position at beginning of range of elements to be removed stop stop - 1 is the position at the end of the range of elements to be removed","comments":"\n     * Remove all elements in this list from <tt>start</tt> inclusive to <tt>stop</tt> exclusive.\n     * <br>pre: <tt>0 <= start < size(), start <= stop <= size()</tt>\n     * <br>post: <tt>size() = old size() - (stop - start)</tt>\n     * @param start position at beginning of range of elements to be removed\n     * @param stop stop - 1 is the position at the end of the range of elements to be removed\n     ","isEmpty":true,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n     * Return a String version of this list enclosed in\n     * square brackets, []. Elements are in\n     * are in order based on position in the \n     * list with the first element\n     * first. Adjacent elements are seperated by comma's\n     * @return a String representation of this IList\n     */\npublic String toString();\n","name":"toString","className":"IList","variables":{},"constants":{},"javaDoc":"Return a String version of this list enclosed in square brackets [] Elements are in are in order based on position in the list with the first element first Adjacent elements are seperated by comma's a String representation of this IList","comments":"\n     * Return a String version of this list enclosed in\n     * square brackets, []. Elements are in\n     * are in order based on position in the \n     * list with the first element\n     * first. Adjacent elements are seperated by comma's\n     * @return a String representation of this IList\n     ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n     * Determine if this IList is equal to other. Two\n     * ILists are equal if they contain the same elements\n     * in the same order.\n     * @return true if this IList is equal to other, false otherwise\n     */\npublic boolean equals(Object other);\n","name":"equals","className":"IList","variables":{},"constants":{},"javaDoc":"Determine if this IList is equal to other Two ILists are equal if they contain the same elements in the same order true if this IList is equal to other false otherwise","comments":"\n     * Determine if this IList is equal to other. Two\n     * ILists are equal if they contain the same elements\n     * in the same order.\n     * @return true if this IList is equal to other, false otherwise\n     ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"insert":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(Object x) {\n    insert(iSize, x);\n}\n","name":"add","className":"GenericList","variables":{},"constants":{},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public Object get(int pos) {\n    return iValues[pos];\n}\n","name":"get","className":"GenericList","variables":{"iValues":1,"pos":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"ensureCapcity":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":2,"NameExpr":14,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/**\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     */\npublic void insert(int pos, Object obj) {\n    ensureCapcity();\n    for (int i = iSize; i > pos; i--) {\n        iValues[i] = iValues[i - 1];\n    }\n    iValues[pos] = obj;\n    iSize++;\n}\n","name":"insert","className":"GenericList","variables":{"iValues":3,"iSize":2,"pos":2,"obj":1,"i":5},"constants":{"1":1},"javaDoc":"Insert obj at position pos post: get(pos) = x size() = old size() + 1 pos 0 <= pos <= size() obj The element to add","comments":"\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":4,"NameExpr":14,"UnaryExpr":2,"AssignExpr":2},"statements":{"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public Object remove(int pos) {\n    Object removedValue = iValues[pos];\n    for (int i = pos; i < iSize - 1; i++) iValues[i] = iValues[i + 1];\n    iValues[iSize - 1] = null;\n    iSize--;\n    return removedValue;\n}\n","name":"remove","className":"GenericList","variables":{"iValues":4,"removedValue":2,"iSize":3,"pos":2,"i":5},"constants":{"1":3,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"private void ensureCapcity() {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n}\n         // is there extra capacity available?\n\n","name":"ensureCapcity","className":"GenericList","variables":{"iSize":1},"constants":{},"javaDoc":"","comments":"is there extra capacity available? if not resize ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int size() {\n    return iSize;\n}\n","name":"size","className":"GenericList","variables":{"iSize":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object[]":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    Object[] temp = new Object[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"GenericList","variables":{"temp":2,"iValues":1,"System":1},"constants":{"0":2,"2":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":7,"StringLiteralExpr":4,"NameExpr":15,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i].toString() + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"GenericList","variables":{"result":5,"iValues":2,"iSize":4,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":33,"StringLiteralExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"GenericList","variables":{"result":9,"iValues":2,"iSize":3,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"GenericList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic GenericList() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"GenericList","className":"GenericList","variables":{"DEFAULT_CAP":1},"constants":{},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"GenericList","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic GenericList(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new Object[initialCap];\n    iSize = 0;\n}\n","name":"GenericList","className":"GenericList","variables":{"iValues":1,"iSize":1,"initialCap":3},"constants":{"0":2,"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1,"size":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":1,"GenericList":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":32,"UnaryExpr":1,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":2,"ThisExpr":4,"MethodCallExpr":5},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other is not null and refers to an IntList\n        GenericList otherList = (GenericList) other;\n        result = this.size() == otherList.size();\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i].equals(otherList.iValues[i]);\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"GenericList","variables":{"result":8,"other":4,"iSize":1,"i":5,"otherList":2},"constants":{"0":1,"null":1,"false":2,"true":1},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other is not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"substring":1,"System.out.println":8},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":8,"int":2},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":10,"BinaryExpr":18,"StringLiteralExpr":15,"NameExpr":62,"FieldAccessExpr":8,"MethodCallExpr":9,"AssignExpr":1},"statements":{"ExpressionStmt":19},"text":"public static void main(String[] args) {\n    String s1 = \"Computer Science\";\n    int x = 307;\n    String s2 = s1 + \" \" + x;\n    String s3 = s2.substring(10, 17);\n    String s4 = \"is fun\";\n    String s5 = s2 + s4;\n    System.out.println(\"s1: \" + s1);\n    System.out.println(\"s2: \" + s2);\n    System.out.println(\"s3: \" + s3);\n    System.out.println(\"s4: \" + s4);\n    System.out.println(\"s5: \" + s5);\n    //showing effect of precedence\n    x = 3;\n    int y = 5;\n    String s6 = x + y + \"total\";\n    String s7 = \"total \" + x + y;\n    String s8 = \" \" + x + y + \"total\";\n    System.out.println(\"s6: \" + s6);\n    System.out.println(\"s7: \" + s7);\n    System.out.println(\"s8: \" + s8);\n}\n","name":"main","className":"StringExample","variables":{"s3":2,"s4":3,"s5":2,"s6":2,"s7":2,"s8":2,"x":6,"y":4,"s1":3,"s2":4},"constants":{"\"Computer Science\"":1,"\" \"":2,"\"s6: \"":1,"\"s7: \"":1,"17":1,"\"s8: \"":1,"\"s4: \"":1,"\"s5: \"":1,"\"s2: \"":1,"\"s3: \"":1,"\"s1: \"":1,"\"is fun\"":1,"\"total \"":1,"3":1,"5":1,"\"total\"":2,"307":1,"10":1},"javaDoc":"","comments":"showing effect of precedence ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    go();\n}\n","name":"main","className":"ObjectVarsAsParameters","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setSize":1,"alterPointee":1,"alterPointer":1,"System.out.println":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"BinaryExpr":8,"NameExpr":33,"StringLiteralExpr":8,"FieldAccessExpr":4,"MethodCallExpr":7},"statements":{"ExpressionStmt":8},"text":"public static void go() {\n    Rectangle r1 = new Rectangle(0, 0, 5, 5);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n    // could have been \n    //System.out.prinltn(\"r1\" + r1.toString());\n    r1.setSize(10, 15);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n    alterPointee(r1);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n    alterPointer(r1);\n    System.out.println(\"In method go. r1 \" + r1 + \"\\n\");\n}\n","name":"go","className":"ObjectVarsAsParameters","variables":{"r1":6},"constants":{"0":2,"\"In method go. r1 \"":4,"15":1,"5":2,"\"\\n\"":4,"10":1},"javaDoc":"","comments":"could have been System out prinltn(\"r1\" + r1 toString()); ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Rectangle"],"returnType":"void","methodCalls":{"setSize":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":4,"NameExpr":15,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public static void alterPointee(Rectangle r) {\n    System.out.println(\"In method alterPointee. r \" + r + \"\\n\");\n    r.setSize(20, 30);\n    System.out.println(\"In method alterPointee. r \" + r + \"\\n\");\n}\n","name":"alterPointee","className":"ObjectVarsAsParameters","variables":{"r":3},"constants":{"\"In method alterPointee. r \"":2,"30":1,"\"\\n\"":2,"20":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Rectangle"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"BinaryExpr":4,"NameExpr":13,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"public static void alterPointer(Rectangle r) {\n    System.out.println(\"In method alterPointer. r \" + r + \"\\n\");\n    r = new Rectangle(5, 10, 30, 35);\n    System.out.println(\"In method alterPointer. r \" + r + \"\\n\");\n}\n","name":"alterPointer","className":"ObjectVarsAsParameters","variables":{"r":3},"constants":{"35":1,"5":1,"\"In method alterPointer. r \"":2,"30":1,"\"\\n\"":2,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"equals":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"IntListVer1":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    IntListVer1 list1 = new IntListVer1();\n    IntListVer1 list2 = new IntListVer1(100);\n    //equal when empty?\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n}\n","name":"main","className":"IntListTesterVer1","variables":{"list1":3,"list2":2},"constants":{"\"list1: \"":1,"100":1,"\"list2: \"":1,"\"list1.equals(list2): \"":1},"javaDoc":"","comments":"equal when empty? ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"countWords":1,"countWordsOurBinarySearchTree":1,"countWordsCollection":2,"countWordsOurUnsortedSet":1,"countWordsOurHash":1,"System.out.println":4},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"int[]":1,"String[]":2,"String":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"ArrayInitializerExpr":2,"ArrayAccessExpr":3,"BinaryExpr":2,"StringLiteralExpr":11,"NameExpr":42,"FieldAccessExpr":4,"MethodCallExpr":10},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":12},"text":"public static void main(String[] args) throws Exception {\n    String[] allFileNames = { \"hounds.txt\", \"huckfinn.txt\", \"oz.txt\", \"war.txt\", \"ciaFactBook2008.txt\" };\n    String[] noCIA = { \"hounds.txt\", \"huckfinn.txt\", \"oz.txt\", \"war.txt\" };\n    countWords(new BinarySearchTree<String>(), allFileNames[0]);\n    for (String s : allFileNames) {\n        System.out.println(s);\n        countWordsOurUnsortedSet(s);\n        countWordsOurBinarySearchTree(s);\n        countWordsOurHash(s);\n        countWordsCollection(new TreeSet<String>(), s);\n        int[] result = countWordsCollection(new HashSet<String>(), s);\n        System.out.println(result[0] + \" total words.\");\n        System.out.println(result[1] + \" distinct words.\");\n        System.out.println();\n    }\n}\n","name":"main","className":"UnsortedSetTest","variables":{"allFileNames":3,"result":3,"s":1,"noCIA":1},"constants":{"0":2,"1":1,"\"huckfinn.txt\"":2,"\" total words.\"":1,"\"hounds.txt\"":2,"\"ciaFactBook2008.txt\"":1,"\"oz.txt\"":2,"\"war.txt\"":2,"\" distinct words.\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Collection<String>","String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"getClass":1,"stop":1,"size":2,"clear":1,"start":1,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Scanner":1,"Stopwatch":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayInitializerExpr":1,"BinaryExpr":4,"NameExpr":42,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":11},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"// return total num words, and num distinct words\npublic static int[] countWordsCollection(Collection<String> c, String fileName) throws Exception {\n    c.clear();\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for \" + c.getClass() + \" : \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n //        System.out.println(c.size() + \" distinct words\");\n\n","name":"countWordsCollection","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":1,"total":4,"c":5},"constants":{"0":1,"\"Time for \"":1,"\" : \\n\"":1},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \");  return total num words, and num distinct words","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"stop":1,"size":2,"start":1,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Scanner":1,"Stopwatch":1,"UnsortedHashSet<String>":1,"int":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":9},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"// GACKY GACKY GACKY repition. Look into removing repetition with reflection\n// we assume there will be add and size methods\npublic static int[] countWordsOurHash(String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    UnsortedHashSet<String> c = new UnsortedHashSet<String>();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for our hashtable (closed address hashing): \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n //        System.out.println(c.size() + \" distinct words\");\n\n","name":"countWordsOurHash","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":1,"total":4,"c":4},"constants":{"0":1,"\"Time for our hashtable (closed address hashing): \\n\"":1},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \");  we assume there will be add and size methods","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"stop":1,"size":2,"start":1,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Scanner":1,"Stopwatch":1,"int":1,"UnsortedSet<String>":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":9},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"public static int[] countWordsOurUnsortedSet(String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    UnsortedSet<String> c = new UnsortedSet<String>();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for our unsorted set based on ArrayList: \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n //        System.out.println(c.size() + \" distinct words\");\n\n","name":"countWordsOurUnsortedSet","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":1,"total":4,"c":4},"constants":{"0":1,"\"Time for our unsorted set based on ArrayList: \\n\"":1},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \"); ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"int[]","methodCalls":{"add":1,"next":1,"stop":1,"size":2,"start":1,"hasNext":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{"Scanner":1,"BinarySearchTree<String>":1,"Stopwatch":1,"int":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayInitializerExpr":1,"BinaryExpr":2,"NameExpr":36,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":9},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"public static int[] countWordsOurBinarySearchTree(String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    BinarySearchTree<String> c = new BinarySearchTree<String>();\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        c.add(fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for our binary search tree: \\n\" + st);\n    //        System.out.println(total + \" total words including duplicates: \");\n    assert total >= c.size();\n    System.out.println();\n    return new int[] { total, c.size() };\n}\n //        System.out.println(c.size() + \" distinct words\");\n\n","name":"countWordsOurBinarySearchTree","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":1,"total":4,"c":4},"constants":{"0":1,"\"Time for our binary search tree: \\n\"":1},"javaDoc":"","comments":"System out println(c size() + \" distinct words\"); System out println(total + \" total words including duplicates: \"); ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object","String"],"returnType":"int[]","methodCalls":{"next":1,"getClass":4,"stop":1,"start":1,"toString":1,"hasNext":1,"invoke":2,"getMethod":2,"getMethods":1,"System.out.println":3},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"Scanner":1,"Stopwatch":1,"Method":2,"int":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":3,"NameExpr":61,"StringLiteralExpr":4,"UnaryExpr":1,"ArrayInitializerExpr":1,"CastExpr":1,"FieldAccessExpr":3,"ClassExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":17},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":13},"text":"// a try at reflection. Not working on Binary Search tree from class. \n// Hunch. Due to add method taking in Comparable, not Object!\n// Alterantives: search list of methods for name?\npublic static int[] countWords(Object c, String fileName) throws Exception {\n    Scanner fileScanner = new Scanner(new File(fileName));\n    Stopwatch st = new Stopwatch();\n    System.out.println(Arrays.toString(c.getClass().getMethods()));\n    Method addMethod = c.getClass().getMethod(\"add\", Object.class);\n    st.start();\n    int total = 0;\n    while (fileScanner.hasNext()) {\n        addMethod.invoke(c, fileScanner.next());\n        total++;\n    }\n    st.stop();\n    System.out.println(\"Time for \" + c.getClass() + \": \" + st);\n    Method sizeMethod = c.getClass().getMethod(\"size\");\n    int distictWords = (Integer) sizeMethod.invoke(c);\n    //        System.out.println(distictWords + \" distinct words\");\n    //        System.out.println(total + \" total words including duplicates: \");\n    System.out.println();\n    return new int[] { total, distictWords };\n}\n","name":"countWords","className":"UnsortedSetTest","variables":{"fileScanner":3,"st":4,"fileName":1,"total":3,"c":4,"distictWords":2,"Arrays":1,"sizeMethod":2,"addMethod":2},"constants":{"0":1,"\"size\"":1,"\"Time for \"":1,"\": \"":1,"\"add\"":1},"javaDoc":"","comments":"System out println(distictWords + \" distinct words\"); System out println(total + \" total words including duplicates: \");  Alterantives: search list of methods for name?","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"nextLine":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scanner":1,"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    System.out.print(\"Enter your name: \");\n    String name = s.nextLine();\n    System.out.println(\"Hello \" + name + \"!\");\n}\n","name":"main","className":"ScannerAndKeyboard","variables":{"s":2,"name":2},"constants":{"\"!\"":1,"\"Hello \"":1,"\"Enter your name: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Die","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor.<p>\n     * pre: none<br>\n     * post: getNumSides() = DEFAULT_SIDES, getResult() = 1\n     */\npublic Die() {\n    this(DEFAULT_SIDES);\n}\n","name":"Die","className":"Die","variables":{"DEFAULT_SIDES":1},"constants":{},"javaDoc":"Default constructor <p> pre: none<br> post: getNumSides() = DEFAULT_SIDES getResult() = 1","comments":"\n     * Default constructor.<p>\n     * pre: none<br>\n     * post: getNumSides() = DEFAULT_SIDES, getResult() = 1\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Die","methodCalls":{"getResult":1,"getNumSides":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":6,"NameExpr":10,"StringLiteralExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"AssertStmt":2,"ExpressionStmt":2},"text":"/**\n     * Create a Die with numSides sides<p>\n     * pre: numSides > 1<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     */\npublic Die(int numSides) {\n    assert numSides > 1 : \"Violation of precondition: numSides = \" + numSides + \"numSides must be greater than 1\";\n    iMyNumSides = numSides;\n    iMyResult = 1;\n    assert getResult() == 1 && getNumSides() == numSides;\n}\n","name":"Die","className":"Die","variables":{"iMyResult":1,"numSides":4,"iMyNumSides":1},"constants":{"\"Violation of precondition: numSides = \"":1,"1":3,"\"numSides must be greater than 1\"":1},"javaDoc":"Create a Die with numSides sides<p> pre: numSides > 1<br> post: getNumSides() = numSides getResult() = 1<br> An exception will be generated if the preconditions are not met","comments":"\n     * Create a Die with numSides sides<p>\n     * pre: numSides > 1<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Die","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":5,"NameExpr":8,"StringLiteralExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Create a Die with numSides and top side and result set to result<p>\n     * pre: numSides > 1, 1 <= result <= numSides<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     */\npublic Die(int numSides, int result) {\n    assert numSides > 1 && 1 <= result && result <= numSides : \"Violation of precondition\";\n    iMyNumSides = numSides;\n    iMyResult = result;\n}\n","name":"Die","className":"Die","variables":{"result":3,"iMyResult":1,"numSides":3,"iMyNumSides":1},"constants":{"1":2,"\"Violation of precondition\"":1},"javaDoc":"Create a Die with numSides and top side and result set to result<p> pre: numSides > 1 1 <= result <= numSides<br> post: getNumSides() = numSides getResult() = 1<br> An exception will be generated if the preconditions are not met","comments":"\n     * Create a Die with numSides and top side and result set to result<p>\n     * pre: numSides > 1, 1 <= result <= numSides<br>\n     * post: getNumSides() = numSides, getResult() = 1<br>\n     * An exception will be generated if the preconditions are not met\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getResult":2,"nextInt":1,"getNumSides":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":4,"NameExpr":12,"EnclosedExpr":2,"AssignExpr":1,"MethodCallExpr":4},"statements":{"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n     * roll this Die. Every side has an equal chance of being the new result<p>\n     * pre: none<br>\n     * post: 1 <= getResult() <= getNumSides()\n     * @return the result of the Die after the roll\n     */\npublic int roll() {\n    iMyResult = ourRandNumGen.nextInt(iMyNumSides) + 1;\n    assert (1 <= getResult()) && (getResult() <= getNumSides());\n    return iMyResult;\n}\n","name":"roll","className":"Die","variables":{"ourRandNumGen":1,"iMyResult":2},"constants":{"1":2},"javaDoc":"roll this Die Every side has an equal chance of being the new result<p> pre: none<br> post: 1 <= getResult() <= getNumSides() the result of the Die after the roll","comments":"\n     * roll this Die. Every side has an equal chance of being the new result<p>\n     * pre: none<br>\n     * post: 1 <= getResult() <= getNumSides()\n     * @return the result of the Die after the roll\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * return how many sides this Die has<p>\n     * pre: none<br>\n     * post: return how many sides this Die has\n     * @return the number of sides on this Die\n     */\npublic int getNumSides() {\n    return iMyNumSides;\n}\n","name":"getNumSides","className":"Die","variables":{"iMyNumSides":1},"constants":{},"javaDoc":"return how many sides this Die has<p> pre: none<br> post: return how many sides this Die has the number of sides on this Die","comments":"\n     * return how many sides this Die has<p>\n     * pre: none<br>\n     * post: return how many sides this Die has\n     * @return the number of sides on this Die\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * get the current result or top number of this Die<p>\n     * pre: none<br>\n     * post: return the number on top of this Die\n     * @return the current result of this Die\n     */\npublic int getResult() {\n    return iMyResult;\n}\n","name":"getResult","className":"Die","variables":{"iMyResult":1},"constants":{},"javaDoc":"get the current result or top number of this Die<p> pre: none<br> post: return the number on top of this Die the current result of this Die","comments":"\n     * get the current result or top number of this Die<p>\n     * pre: none<br>\n     * post: return the number on top of this Die\n     * @return the current result of this Die\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Die":1,"boolean":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BooleanLiteralExpr":4,"BinaryExpr":6,"NameExpr":23,"CastExpr":1,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4,"MethodCallExpr":2},"statements":{"IfStmt":3,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"/**\n     * returns true if this Die and the parameter otherObj are equal<p>\n     * pre: none<br>\n     * post: return true if the parameter is a Die object with the same number of sides as this Die and currently has the same result.\n     * @return true if the the two Dice are equal, false otherwise\n     */\npublic boolean equals(Object otherObj) {\n    boolean result = true;\n    if (otherObj == null)\n        result = false;\n    else if (this == otherObj)\n        result = true;\n    else if (this.getClass() != otherObj.getClass())\n        result = false;\n    else {\n        Die otherDie = (Die) otherObj;\n        result = this.iMyResult == otherDie.iMyResult && this.iMyNumSides == otherDie.iMyNumSides;\n    }\n    return result;\n}\n","name":"equals","className":"Die","variables":{"result":6,"otherDie":1,"otherObj":4},"constants":{"null":1,"true":2,"false":2},"javaDoc":"returns true if this Die and the parameter otherObj are equal<p> pre: none<br> post: return true if the parameter is a Die object with the same number of sides as this Die and currently has the same result true if the the two Dice are equal false otherwise","comments":"\n     * returns true if this Die and the parameter otherObj are equal<p>\n     * pre: none<br>\n     * post: return true if the parameter is a Die object with the same number of sides as this Die and currently has the same result.\n     * @return true if the the two Dice are equal, false otherwise\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getResult":1,"getNumSides":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":4,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n     * returns a String containing information about this Die<p>\n     * pre: none<br>\n     * post: return a String with information about the current state of this Die\n     * @return: A String with the number of sides and current result of this Die\n     */\npublic String toString() {\n    return \"Num sides \" + getNumSides() + \" result \" + getResult();\n}\n","name":"toString","className":"Die","variables":{},"constants":{"\" result \"":1,"\"Num sides \"":1},"javaDoc":"returns a String containing information about this Die<p> pre: none<br> post: return a String with information about the current state of this Die : A String with the number of sides and current result of this Die","comments":"\n     * returns a String containing information about this Die<p>\n     * pre: none<br>\n     * post: return a String with information about the current state of this Die\n     * @return: A String with the number of sides and current result of this Die\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"hasNextInt":1,"nextInt":1,"System.out.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":17,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    try {\n        Scanner s = new Scanner(new File(\"scores.dat\"));\n        while (s.hasNextInt()) {\n            System.out.println(s.nextInt());\n        }\n    } catch (IOException e) {\n        System.out.println(e);\n    }\n}\n","name":"main","className":"ReadAndPrintScores","variables":{"s":3,"e":1},"constants":{"\"scores.dat\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"makeSet":3,"toString":6,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle[]":1,"String[]":1,"Object[]":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":12,"VariableDeclarationExpr":3,"ArrayInitializerExpr":3,"BinaryExpr":6,"StringLiteralExpr":18,"NameExpr":60,"FieldAccessExpr":6,"MethodCallExpr":15},"statements":{"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    String[] words = { \"A\", \"B\", \"B\", \"D\", \"C\", \"A\" };\n    System.out.println(\"original: \" + Arrays.toString(words));\n    System.out.println(\"as a set: \" + Arrays.toString(makeSet(words)));\n    Rectangle[] rectList = { new Rectangle(), new Rectangle(), new Rectangle(0, 1, 2, 3), new Rectangle(0, 1, 2, 3) };\n    System.out.println(\"original: \" + Arrays.toString(rectList));\n    System.out.println(\"as a set: \" + Arrays.toString(makeSet(rectList)));\n    Object[] mixed = { \"A\", \"C\", \"A\", \"B\", new Rectangle(), new Rectangle(), \"A\", new Rectangle(0, 1, 2, 3), \"D\" };\n    System.out.println(\"original: \" + Arrays.toString(mixed));\n    System.out.println(\"as a set: \" + Arrays.toString(makeSet(mixed)));\n}\n","name":"main","className":"CreateASet","variables":{"rectList":1,"words":1,"mixed":1,"Arrays":6},"constants":{"\"D\"":2,"0":3,"\"C\"":2,"1":3,"\"B\"":3,"2":3,"\"A\"":5,"\"as a set: \"":3,"3":3,"\"original: \"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object[]"],"returnType":"Object[]","methodCalls":{"noNulls":1,"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"Object[]":2,"int":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":6,"ArrayAccessExpr":4,"BinaryExpr":4,"NameExpr":39,"StringLiteralExpr":2,"UnaryExpr":5,"AssignExpr":4,"NullLiteralExpr":1,"BooleanLiteralExpr":1,"FieldAccessExpr":2,"ArrayCreationExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"AssertStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":12},"text":"/**\n     * An example of polymorphism in action. The method relies\n     * on Java's inheritance requirement and polymorhphism to call\n     * the correct equals method.\n     * @param data != null, no elements of data are null\n     * @return a Set (no duplicates) of the elements in data.\n     */\npublic static Object[] makeSet(Object[] data) {\n    assert data != null : \"Failed precondition makeSet. parameter cannot be null\";\n    assert noNulls(data) : \"Failed precondition makeSet. no elements of parameter can be null\";\n    Object[] result = new Object[data.length];\n    int numUnique = 0;\n    boolean found;\n    int indexInResult;\n    for (int i = 0; i < data.length; i++) {\n        // maybe should break this out into another method\n        indexInResult = 0;\n        found = false;\n        while (!found && indexInResult < numUnique) {\n            found = data[i].equals(result[indexInResult]);\n            indexInResult++;\n        }\n        if (!found) {\n            result[numUnique] = data[i];\n            numUnique++;\n        }\n    }\n    Object[] result2 = new Object[numUnique];\n    System.arraycopy(result, 0, result2, 0, numUnique);\n    return result2;\n}\n","name":"makeSet","className":"CreateASet","variables":{"result":3,"found":5,"data":3,"numUnique":5,"indexInResult":5,"i":5,"result2":2,"System":1},"constants":{"0":5,"null":1,"\"Failed precondition makeSet. parameter cannot be null\"":1,"\"Failed precondition makeSet. no elements of parameter can be null\"":1,"false":1},"javaDoc":"An example of polymorphism in action The method relies on Java's inheritance requirement and polymorhphism to call the correct equals method data != null no elements of data are null a Set (no duplicates) of the elements in data","comments":"maybe should break this out into another method \n     * An example of polymorphism in action. The method relies\n     * on Java's inheritance requirement and polymorhphism to call\n     * the correct equals method.\n     * @param data != null, no elements of data are null\n     * @return a Set (no duplicates) of the elements in data.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object[]"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"int":1},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":4,"BooleanLiteralExpr":1,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"// pre: data != null\n// return true if all elements of data are non null,\n// false otherwise\nprivate static boolean noNulls(Object[] data) {\n    assert data != null : \"Failed precondition makeSet. parameter cannot be null\";\n    boolean good = true;\n    int i = 0;\n    while (good && i < data.length) {\n        good = data[i] != null;\n        i++;\n    }\n    return good;\n}\n","name":"noNulls","className":"CreateASet","variables":{"data":2,"i":4,"good":4},"constants":{"0":1,"null":2,"\"Failed precondition makeSet. parameter cannot be null\"":1,"true":1},"javaDoc":"","comments":" false otherwise","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"ListNode","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n\t * default constructor\n\t * pre: none<br>\n\t * post: getData() = null, getNext() = null\n\t */\npublic ListNode() {\n    this(null, null);\n}\n","name":"ListNode","className":"ListNode","variables":{},"constants":{"null":2},"javaDoc":"default constructor pre: none<br> post: getData() = null getNext() = null","comments":"\n\t * default constructor\n\t * pre: none<br>\n\t * post: getData() = null, getNext() = null\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","ListNode"],"returnType":"ListNode","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n\t * create a ListNode that holds the specified data and refers to the specified next element\n\t * pre: none<br>\n\t * post: getData() = item, getNext() = next\n\t * @param item the  data this ListNode should hold\n\t * @param next the next node in the list\n\t */\npublic ListNode(Object data, ListNode next) {\n    myData = data;\n    myNext = next;\n}\n","name":"ListNode","className":"ListNode","variables":{"next":1,"myNext":1,"data":1,"myData":1},"constants":{},"javaDoc":"create a ListNode that holds the specified data and refers to the specified next element pre: none<br> post: getData() = item getNext() = next item the data this ListNode should hold next the next node in the list","comments":"\n\t * create a ListNode that holds the specified data and refers to the specified next element\n\t * pre: none<br>\n\t * post: getData() = item, getNext() = next\n\t * @param item the  data this ListNode should hold\n\t * @param next the next node in the list\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n\t * return the data in this node\n\t * pre: none<br>\n\t * @return the data this ListNode holds\n\t */\npublic Object getData() {\n    return myData;\n}\n","name":"getData","className":"ListNode","variables":{"myData":1},"constants":{},"javaDoc":"return the data in this node pre: none<br> the data this ListNode holds","comments":"\n\t * return the data in this node\n\t * pre: none<br>\n\t * @return the data this ListNode holds\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ListNode","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n\t * return the ListNode this ListNode refers to\n\t * pre: none<br>\n\t * @return the ListNode this ListNode refers to (normally the next one in a list)\n\t */\npublic ListNode getNext() {\n    return myNext;\n}\n","name":"getNext","className":"ListNode","variables":{"myNext":1},"constants":{},"javaDoc":"return the ListNode this ListNode refers to pre: none<br> the ListNode this ListNode refers to (normally the next one in a list)","comments":"\n\t * return the ListNode this ListNode refers to\n\t * pre: none<br>\n\t * @return the ListNode this ListNode refers to (normally the next one in a list)\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n\t * set the data in this node\n\t * The old data is over written.<br>\n\t * pre: none<br>\n\t * @param data the new data for this ListNode to hold\n\t */\npublic void setData(Object data) {\n    myData = data;\n}\n","name":"setData","className":"ListNode","variables":{"data":1,"myData":1},"constants":{},"javaDoc":"set the data in this node The old data is over written <br> pre: none<br> data the new data for this ListNode to hold","comments":"\n\t * set the data in this node\n\t * The old data is over written.<br>\n\t * pre: none<br>\n\t * @param data the new data for this ListNode to hold\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ListNode"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n\t * set the next node this ListNode refers to\n\t * pre: none<br>\n\t * @param next the next node this ListNode should refer to\n\t */\npublic void setNext(ListNode next) {\n    myNext = next;\n}\n","name":"setNext","className":"ListNode","variables":{"next":1,"myNext":1},"constants":{},"javaDoc":"set the next node this ListNode refers to pre: none<br> next the next node this ListNode should refer to","comments":"\n\t * set the next node this ListNode refers to\n\t * pre: none<br>\n\t * @param next the next node this ListNode should refer to\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":4,"stop":2,"equals":3,"start":2,"toString":3,"System.out.println":14,"toStringUsingStringBuffer":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"IntListVer2":2,"Stopwatch":1,"int":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":7,"VariableDeclarationExpr":5,"BinaryExpr":13,"NameExpr":132,"StringLiteralExpr":14,"FieldAccessExpr":14,"UnaryExpr":1,"MethodCallExpr":29,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":2,"ExpressionStmt":28},"text":"public static void main(String[] args) {\n    IntListVer2 list1 = new IntListVer2();\n    IntListVer2 list2 = new IntListVer2(100);\n    //equal when empty?\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n    //add elements\n    for (int i = 0; i < 100; i += 5) {\n        list1.add(i);\n        list2.add(i);\n    }\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n    list2.add(200);\n    System.out.println(\"Added 200 to list2.\");\n    System.out.println(\"list1.equals(list2): \" + list1.equals(list2));\n    System.out.println(\"list1: \" + list1);\n    System.out.println(\"list2: \" + list2);\n    System.out.println(\"Testing efficieny of StringBuffer versus using String.\");\n    System.out.println(\"Increasing list1 size to 10000.\");\n    Stopwatch s = new Stopwatch();\n    list1 = new IntListVer2();\n    for (int i = 0; i < 10000; i++) list1.add(i);\n    s.start();\n    list1.toString();\n    s.stop();\n    System.out.println(\"Time to build String using String class: \" + s.toString());\n    s.start();\n    list1.toStringUsingStringBuffer();\n    s.stop();\n    System.out.println(\"Time to build String using StringBuffer class: \" + s.toString());\n}\n","name":"main","className":"IntListTesterVer2","variables":{"list1":12,"s":7,"list2":6,"i":6},"constants":{"\"Added 200 to list2.\"":1,"\"Testing efficieny of StringBuffer versus using String.\"":1,"\"list1.equals(list2): \"":3,"\"list1: \"":3,"0":2,"100":2,"\"list2: \"":3,"200":1,"\"Increasing list1 size to 10000.\"":1,"5":1,"\"Time to build String using StringBuffer class: \"":1,"10000":1,"\"Time to build String using String class: \"":1},"javaDoc":"","comments":"equal when empty? add elements ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"go":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    go();\n}\n","name":"main","className":"PrimitiveParameters","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"moreParameters":1,"falseSwap":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":9,"NameExpr":29,"StringLiteralExpr":6,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":7},"text":"public static void go() {\n    int x = 3;\n    int y = 2;\n    System.out.println(\"In method go. x: \" + x + \" y: \" + y);\n    falseSwap(x, y);\n    System.out.println(\"in method go. x: \" + x + \" y: \" + y);\n    moreParameters(x, y);\n    System.out.println(\"in method go. x: \" + x + \" y: \" + y);\n}\n","name":"go","className":"PrimitiveParameters","variables":{"x":4,"y":4},"constants":{"\"in method go. x: \"":2,"2":1,"3":1,"\"In method go. x: \"":1,"\" y: \"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":6,"NameExpr":19,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":5},"text":"public static void falseSwap(int x, int y) {\n    System.out.println(\"in method falseSwap. x: \" + x + \" y: \" + y);\n    int temp = x;\n    x = y;\n    y = temp;\n    System.out.println(\"in method falseSwap. x: \" + x + \" y: \" + y);\n}\n","name":"falseSwap","className":"PrimitiveParameters","variables":{"temp":2,"x":4,"y":4},"constants":{"\"in method falseSwap. x: \"":2,"\" y: \"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"falseSwap":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":10,"NameExpr":29,"StringLiteralExpr":6,"FieldAccessExpr":3,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":6},"text":"public static void moreParameters(int a, int b) {\n    System.out.println(\"in method moreParameters. a: \" + a + \" b: \" + b);\n    a = a * b;\n    b = 12;\n    System.out.println(\"in method moreParameters. a: \" + a + \" b: \" + b);\n    falseSwap(b, a);\n    System.out.println(\"in method moreParameters. a: \" + a + \" b: \" + b);\n}\n","name":"moreParameters","className":"PrimitiveParameters","variables":{"a":5,"b":5},"constants":{"\"in method moreParameters. a: \"":3,"12":1,"\" b: \"":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"GenericListIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"private GenericListIterator() {\n    position = 0;\n    removeOK = false;\n}\n","name":"GenericListIterator","className":"GenericListIterator","variables":{"position":1,"removeOK":1},"constants":{"0":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public boolean hasNext() {\n    return position < iSize;\n}\n","name":"hasNext","className":"GenericListIterator","variables":{"iSize":1,"position":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BooleanLiteralExpr":1,"NameExpr":5,"UnaryExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"public Object next() {\n    Object result = iValues[position];\n    position++;\n    removeOK = true;\n    return result;\n}\n","name":"next","className":"GenericListIterator","variables":{"result":2,"iValues":1,"position":2,"removeOK":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"UnaryExpr":2,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":3},"text":"public void remove() {\n    if (!removeOK)\n        throw new IllegalStateException();\n    // which element should be removed??\n    removeOK = false;\n    GenericListVersion2.this.remove(position - 1);\n    position--;\n}\n","name":"remove","className":"GenericListIterator","variables":{"GenericListVersion2":1,"position":2,"removeOK":2},"constants":{"1":1,"false":1},"javaDoc":"","comments":"which element should be removed?? ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"public Iterator iterator() {\n    return new GenericListIterator();\n}\n","name":"iterator","className":"GenericListVersion2","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Collection"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":4,"ThisExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"ForeachStmt":1,"ExpressionStmt":1},"text":"public void addAll(Collection c) {\n    // for each loop\n    for (Object obj : c) {\n        this.add(obj);\n    }\n}\n","name":"addAll","className":"GenericListVersion2","variables":{"c":1,"obj":1},"constants":{},"javaDoc":"","comments":"for each loop ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"insert":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(Object x) {\n    insert(iSize, x);\n}\n","name":"add","className":"GenericListVersion2","variables":{},"constants":{},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public Object get(int pos) {\n    return iValues[pos];\n}\n","name":"get","className":"GenericListVersion2","variables":{"iValues":1,"pos":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"ensureCapcity":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":2,"NameExpr":14,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/**\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     */\npublic void insert(int pos, Object obj) {\n    ensureCapcity();\n    for (int i = iSize; i > pos; i--) {\n        iValues[i] = iValues[i - 1];\n    }\n    iValues[pos] = obj;\n    iSize++;\n}\n","name":"insert","className":"GenericListVersion2","variables":{"iValues":3,"iSize":2,"pos":2,"obj":1,"i":5},"constants":{"1":1},"javaDoc":"Insert obj at position pos post: get(pos) = x size() = old size() + 1 pos 0 <= pos <= size() obj The element to add","comments":"\n     * Insert obj at position pos.\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param obj The element to add.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":4,"NameExpr":14,"UnaryExpr":2,"AssignExpr":2},"statements":{"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public Object remove(int pos) {\n    Object removedValue = iValues[pos];\n    for (int i = pos; i < iSize - 1; i++) iValues[i] = iValues[i + 1];\n    iValues[iSize - 1] = null;\n    iSize--;\n    return removedValue;\n}\n","name":"remove","className":"GenericListVersion2","variables":{"iValues":4,"removedValue":2,"iSize":3,"pos":2,"i":5},"constants":{"1":3,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"private void ensureCapcity() {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n}\n         // is there extra capacity available?\n\n","name":"ensureCapcity","className":"GenericListVersion2","variables":{"iSize":1},"constants":{},"javaDoc":"","comments":"is there extra capacity available? if not resize ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int size() {\n    return iSize;\n}\n","name":"size","className":"GenericListVersion2","variables":{"iSize":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object[]":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    Object[] temp = new Object[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"GenericListVersion2","variables":{"temp":2,"iValues":1,"System":1},"constants":{"0":2,"2":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":7,"StringLiteralExpr":4,"NameExpr":15,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i].toString() + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"GenericListVersion2","variables":{"result":5,"iValues":2,"iSize":4,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":33,"StringLiteralExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"GenericListVersion2","variables":{"result":9,"iValues":2,"iSize":3,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"GenericListVersion2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic GenericListVersion2() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"GenericListVersion2","className":"GenericListVersion2","variables":{"DEFAULT_CAP":1},"constants":{},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"GenericListVersion2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic GenericListVersion2(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new Object[initialCap];\n    iSize = 0;\n}\n","name":"GenericListVersion2","className":"GenericListVersion2","variables":{"iValues":1,"iSize":1,"initialCap":3},"constants":{"0":2,"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1,"size":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":1,"GenericListVersion2":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":32,"UnaryExpr":1,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":2,"ThisExpr":4,"MethodCallExpr":5},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other is not null and refers to an IntList\n        GenericListVersion2 otherList = (GenericListVersion2) other;\n        result = this.size() == otherList.size();\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i].equals(otherList.iValues[i]);\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"GenericListVersion2","variables":{"result":8,"other":4,"iSize":1,"i":5,"otherList":2},"constants":{"0":1,"null":1,"false":2,"true":1},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other is not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"exit":1,"split":1,"nextLine":3,"hasNext":1,"System.out.print":2,"canRedeem":1,"System.out.println":4},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"Scanner":2,"Airline":1,"ArrayList<Airline>":1,"String":3,"String[]":1,"ArrayList<String>":2},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":7,"IntegerLiteralExpr":1,"VariableDeclarationExpr":10,"BinaryExpr":6,"NameExpr":72,"StringLiteralExpr":9,"FieldAccessExpr":7,"AssignExpr":4,"MethodCallExpr":14},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":22},"text":"public static void main(String[] args) {\n    Scanner scannerToReadAirlines = null;\n    try {\n        scannerToReadAirlines = new Scanner(new File(\"airlines.txt\"));\n    } catch (IOException e) {\n        System.out.println(\"Could not connect to file airlines.txt.\");\n        System.exit(0);\n    }\n    if (scannerToReadAirlines != null) {\n        ArrayList<Airline> airlinesPartnersNetwork = new ArrayList<Airline>();\n        Airline newAirline;\n        String lineFromFile;\n        String[] airlineNames;\n        while (scannerToReadAirlines.hasNext()) {\n            lineFromFile = scannerToReadAirlines.nextLine();\n            airlineNames = lineFromFile.split(\",\");\n            newAirline = new Airline(airlineNames);\n            airlinesPartnersNetwork.add(newAirline);\n        }\n        System.out.println(airlinesPartnersNetwork);\n        Scanner keyboard = new Scanner(System.in);\n        System.out.print(\"Enter airline miles are on: \");\n        String start = keyboard.nextLine();\n        System.out.print(\"Enter goal airline: \");\n        String goal = keyboard.nextLine();\n        ArrayList<String> pathForMiles = new ArrayList<String>();\n        ArrayList<String> airlinesVisited = new ArrayList<String>();\n        if (canRedeem(start, goal, pathForMiles, airlinesVisited, airlinesPartnersNetwork))\n            System.out.println(\"Path to redeem miles: \" + pathForMiles);\n        else\n            System.out.println(\"Cannot convert miles from \" + start + \" to \" + goal + \".\");\n    }\n}\n","name":"main","className":"AirlineProblem","variables":{"airlineNames":3,"keyboard":3,"scannerToReadAirlines":5,"goal":2,"e":1,"airlinesVisited":1,"start":2,"newAirline":2,"lineFromFile":3,"pathForMiles":2,"System":1,"airlinesPartnersNetwork":2},"constants":{"0":1,"\"Could not connect to file airlines.txt.\"":1,"\"Enter goal airline: \"":1,"null":2,"\" to \"":1,"\".\"":1,"\"airlines.txt\"":1,"\",\"":1,"\"Path to redeem miles: \"":1,"\"Cannot convert miles from \"":1,"\"Enter airline miles are on: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","ArrayList<String>","ArrayList<String>","ArrayList<Airline>"],"returnType":"boolean","methodCalls":{"add":3,"contains":1,"getName":1,"size":2,"equals":2,"get":2,"getPartners":1,"canRedeem":1,"remove":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"boolean":1,"String[]":1,"int":2},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BooleanLiteralExpr":4,"BinaryExpr":7,"NameExpr":68,"FieldAccessExpr":1,"UnaryExpr":7,"MethodCallExpr":14,"AssignExpr":3},"statements":{"IfStmt":5,"WhileStmt":2,"BlockStmt":4,"ReturnStmt":4,"ExpressionStmt":13},"text":"private static boolean canRedeem(String current, String goal, ArrayList<String> pathForMiles, ArrayList<String> airlinesVisited, ArrayList<Airline> network) {\n    if (current.equals(goal)) {\n        //base case 1, I have found a path!\n        pathForMiles.add(current);\n        return true;\n    } else if (airlinesVisited.contains(current))\n        // don't go into a cycle\n        return false;\n    else {\n        // I have not been here and it isn't\n        // the goal so check its partners\n        // now I have been here\n        airlinesVisited.add(current);\n        // add this to the path\n        pathForMiles.add(current);\n        // find this airline in the network\n        int pos = -1;\n        int index = 0;\n        while (pos == -1 && index < network.size()) {\n            if (network.get(index).getName().equals(current))\n                pos = index;\n            index++;\n        }\n        //if not in the network, no partners\n        if (pos == -1)\n            return false;\n        // loop through partners\n        index = 0;\n        String[] partners = network.get(pos).getPartners();\n        boolean foundPath = false;\n        while (!foundPath && index < partners.length) {\n            foundPath = canRedeem(partners[index], goal, pathForMiles, airlinesVisited, network);\n            index++;\n        }\n        if (!foundPath)\n            pathForMiles.remove(pathForMiles.size() - 1);\n        return foundPath;\n    }\n}\n             // base case 2, I have already been here\n\n","name":"canRedeem","className":"AirlineProblem","variables":{"current":1,"pos":4,"partners":2,"airlinesVisited":2,"index":8,"pathForMiles":4,"foundPath":5,"network":3},"constants":{"0":2,"1":4,"true":1,"false":3},"javaDoc":"","comments":"base case 1 I have found a path! base case 2 I have already been here don't go into a cycle I have not been here and it isn't the goal so check its partners now I have been here add this to the path find this airline in the network if not in the network no partners loop through partners ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String[]"],"returnType":"Airline","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"AssertStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"//pre: data != null, data.length > 0\npublic Airline(String[] data) {\n    assert data != null && data.length > 0 : \"Failed precondition\";\n    name = data[0];\n    partners = new ArrayList<String>();\n    for (int i = 1; i < data.length; i++) partners.add(data[i]);\n}\n","name":"Airline","className":"Airline","variables":{"data":3,"partners":2,"name":1,"i":4},"constants":{"0":2,"\"Failed precondition\"":1,"1":1,"null":1},"javaDoc":"","comments":"pre: data != null, data.length > 0","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String[]","methodCalls":{"size":1,"toArray":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"ArrayCreationExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public String[] getPartners() {\n    return partners.toArray(new String[partners.size()]);\n}\n","name":"getPartners","className":"Airline","variables":{"partners":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"contains":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean isPartner(String name) {\n    return partners.contains(name);\n}\n","name":"isPartner","className":"Airline","variables":{"partners":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getName() {\n    return name;\n}\n","name":"getName","className":"Airline","variables":{"name":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":2,"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public String toString() {\n    return name + \", partners: \" + partners;\n}\n","name":"toString","className":"Airline","variables":{"partners":1,"name":1},"constants":{"\", partners: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color[][]","int"],"returnType":"Color[][]","methodCalls":{"rectangularMatrix":1,"aveOfNeighbors":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color[][]":1,"int":2},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":3,"ArrayAccessExpr":5,"BinaryExpr":10,"NameExpr":37,"StringLiteralExpr":1,"UnaryExpr":2,"AssignExpr":1,"NullLiteralExpr":1,"FieldAccessExpr":6,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":2,"AssertStmt":1,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":2},"text":"/*\n\t *pre: image != null, image.length > 1, image[0].length > 1\n\t *\timage is a rectangular matrix, neighberhoodSize > 0\n\t *post: return a smoothed version of image\n\t */\npublic Color[][] smooth(Color[][] image, int neighberhoodSize) {\n    //check precondition\n    assert image != null && image.length > 1 && image[0].length > 1 && (neighberhoodSize > 0) && rectangularMatrix(image) : \"Violation of precondition: smooth\";\n    Color[][] result = new Color[image.length][image[0].length];\n    for (int row = 0; row < image.length; row++) {\n        for (int col = 0; col < image[0].length; col++) {\n            result[row][col] = aveOfNeighbors(image, row, col, neighberhoodSize);\n        }\n    }\n    return result;\n}\n","name":"smooth","className":"FilterExample","variables":{"result":3,"image":4,"neighberhoodSize":1,"col":4,"row":4},"constants":{"0":6,"1":2,"null":1,"\"Violation of precondition: smooth\"":1},"javaDoc":"","comments":"check precondition \n\t *pre: image != null, image.length > 1, image[0].length > 1\n\t *\timage is a rectangular matrix, neighberhoodSize > 0\n\t *post: return a smoothed version of image\n\t ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color[][]","int","int","int"],"returnType":"Color","methodCalls":{"inBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":6},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":6,"ArrayAccessExpr":6,"BinaryExpr":10,"NameExpr":43,"UnaryExpr":3,"MethodCallExpr":4,"AssignExpr":3},"statements":{"IfStmt":1,"BlockStmt":3,"AssertStmt":1,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":8},"text":"// helper method that determines the average color of a neighberhood\n// around a particular cell.\nprivate Color aveOfNeighbors(Color[][] image, int row, int col, int neighberhoodSize) {\n    int numNeighbors = 0;\n    int red = 0;\n    int green = 0;\n    int blue = 0;\n    for (int r = row - neighberhoodSize; r <= row + neighberhoodSize; r++) {\n        for (int c = col - neighberhoodSize; c <= col + neighberhoodSize; c++) {\n            if (inBounds(image, r, c)) {\n                numNeighbors++;\n                red += image[r][c].getRed();\n                green += image[r][c].getGreen();\n                blue += image[r][c].getBlue();\n            }\n        }\n    }\n    assert numNeighbors > 0;\n    return new Color(red / numNeighbors, green / numNeighbors, blue / numNeighbors);\n}\n","name":"aveOfNeighbors","className":"FilterExample","variables":{"red":3,"neighberhoodSize":4,"col":2,"image":3,"numNeighbors":6,"r":6,"green":3,"c":6,"blue":3,"row":2},"constants":{"0":5},"javaDoc":"","comments":" around a particular cell.","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Color[][]","int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"ArrayAccessExpr":1,"BinaryExpr":7,"NameExpr":10,"FieldAccessExpr":2,"EnclosedExpr":4},"statements":{"ReturnStmt":1},"text":"//helper method to determine if given coordinates are in bounds\nprivate boolean inBounds(Color[][] image, int row, int col) {\n    return (row >= 0) && (row <= image.length) && (col >= 0) && (col < image[0].length);\n}\n","name":"inBounds","className":"FilterExample","variables":{"col":2,"image":1,"row":2},"constants":{"0":3},"javaDoc":"","comments":"helper method to determine if given coordinates are in bounds","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Color[][]"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["FinalVariables"],"types":{"boolean":1,"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":3,"NameExpr":16,"FieldAccessExpr":3,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"//private method to ensure mat is rectangular\nprivate boolean rectangularMatrix(Color[][] mat) {\n    boolean isRectangular = true;\n    int row = 1;\n    final int COLUMNS = mat[0].length;\n    while (isRectangular && row < mat.length) {\n        isRectangular = (mat[row].length == COLUMNS);\n        row++;\n    }\n    return isRectangular;\n}\n","name":"rectangularMatrix","className":"FilterExample","variables":{"mat":2,"COLUMNS":2,"row":4,"isRectangular":4},"constants":{"0":1,"1":1,"true":1},"javaDoc":"","comments":"private method to ensure mat is rectangular","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"Iterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"public Iterator iterator() {\n    return new LLIterator();\n}\n","name":"iterator","className":"LinkedList","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"LLIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":4,"UnaryExpr":1,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"private LLIterator() {\n    nextNode = head;\n    removeOK = false;\n    posToRemove = -1;\n}\n","name":"LLIterator","className":"LLIterator","variables":{"head":1,"nextNode":1,"posToRemove":1,"removeOK":1},"constants":{"1":1,"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean hasNext() {\n    return nextNode != null;\n}\n","name":"hasNext","className":"LLIterator","variables":{"nextNode":1},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"hasNext":1,"getNext":1,"getData":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":12,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":2},"statements":{"AssertStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public Object next() {\n    assert hasNext();\n    Object result = nextNode.getData();\n    nextNode = nextNode.getNext();\n    removeOK = true;\n    posToRemove++;\n    return result;\n}\n","name":"next","className":"LLIterator","variables":{"result":2,"nextNode":3,"posToRemove":1,"removeOK":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":7,"UnaryExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"AssertStmt":1,"ExpressionStmt":3},"text":"public void remove() {\n    assert removeOK;\n    removeOK = false;\n    LinkedList.this.remove(posToRemove);\n    posToRemove--;\n}\n","name":"remove","className":"LLIterator","variables":{"posToRemove":1,"removeOK":2,"LinkedList":1},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":2},"text":"public void makeEmpty() {\n    // let GC do its job!!!!!!!\n    head = tail = null;\n    size = 0;\n}\n","name":"makeEmpty","className":"LinkedList","variables":{"head":1,"size":1,"tail":1},"constants":{"0":1,"null":1},"javaDoc":"","comments":"let GC do its job!!!!!!! ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"setNext":1,"getNext":5,"getData":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":8,"NameExpr":42,"UnaryExpr":2,"AssignExpr":6,"MethodCallExpr":8},"statements":{"IfStmt":3,"BlockStmt":2,"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"public Object remove(int pos) {\n    assert pos >= 0 && pos < size;\n    Object result;\n    if (pos == 0) {\n        result = head.getData();\n        head = head.getNext();\n        if (size == 1)\n            tail = null;\n    } else {\n        Node temp = head;\n        for (int i = 1; i < pos; i++) temp = temp.getNext();\n        result = temp.getNext().getData();\n        temp.setNext(temp.getNext().getNext());\n        if (pos == size - 1)\n            tail = temp;\n    }\n    size--;\n    return result;\n}\n","name":"remove","className":"LinkedList","variables":{"result":4,"head":4,"temp":7,"size":4,"pos":5,"tail":2,"i":3},"constants":{"0":2,"1":3,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Object","methodCalls":{"getNext":1,"getData":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"Object":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":6,"NameExpr":22,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"public Object get(int pos) {\n    assert pos >= 0 && pos < size;\n    // array based list\n    // return myCon[pos]\n    Object result;\n    if (pos == size - 1)\n        //O(1)\n        result = tail.getData();\n    else {\n        Node temp = head;\n        for (int i = 0; i < pos; i++) temp = temp.getNext();\n        result = temp.getData();\n    // average case O(N) :((((\n    }\n    return result;\n}\n","name":"get","className":"LinkedList","variables":{"result":4,"head":1,"temp":4,"size":2,"pos":4,"tail":1,"i":3},"constants":{"0":2,"1":1},"javaDoc":"","comments":"array based list return myCon[pos] O(1) average case O(N) :(((( ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","Object"],"returnType":"void","methodCalls":{"add":1,"setNext":1,"getNext":2,"addFirst":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":2,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":6,"NameExpr":29,"UnaryExpr":2,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":1,"AssertStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public void insert(int pos, Object obj) {\n    assert pos >= 0 && pos <= size;\n    // addFirst?\n    if (pos == 0)\n        // O(1)\n        addFirst(obj);\n    else // add last?\n    if (pos == size)\n        //at end O(1)\n        add(obj);\n    else {\n        // general case\n        Node temp = head;\n        for (int i = 1; i < pos; i++) temp = temp.getNext();\n        // I know temp is pointing at the\n        // node at position pos - 1\n        Node newNode = new Node(obj, temp.getNext());\n        temp.setNext(newNode);\n        size++;\n    }\n}\n","name":"insert","className":"LinkedList","variables":{"head":1,"temp":5,"size":3,"pos":5,"obj":1,"i":3,"newNode":1},"constants":{"0":2,"1":1},"javaDoc":"","comments":"addFirst? O(1) add last? at end O(1) I know temp is pointing at the general case node at position pos - 1 ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"setNext":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":5},"text":"public void add(Object obj) {\n    Node newNode = new Node(obj, null);\n    if (size == 0)\n        head = newNode;\n    else\n        tail.setNext(newNode);\n    tail = newNode;\n    size++;\n}\n","name":"add","className":"LinkedList","variables":{"head":1,"size":2,"obj":1,"tail":2,"newNode":3},"constants":{"0":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"public void addFirst(Object obj) {\n    if (size == 0)\n        add(obj);\n    else {\n        Node newNode = new Node(obj, head);\n        head = newNode;\n        size++;\n    }\n}\n","name":"addFirst","className":"LinkedList","variables":{"head":2,"size":2,"obj":1,"newNode":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getNext":1,"getData":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":13,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public String toString() {\n    String result = \"\";\n    Node temp = head;\n    for (int i = 0; i < size; i++) {\n        result += temp.getData() + \" \";\n        temp = temp.getNext();\n    }\n    return result;\n}\n","name":"toString","className":"LinkedList","variables":{"result":3,"head":1,"temp":4,"size":1,"i":3},"constants":{"\"\"":1,"0":1,"\" \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":15,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"AssertStmt":1,"ExpressionStmt":3},"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(int x) {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n    assert 0 <= iSize && iSize < iValues.length;\n    iValues[iSize] = x;\n    iSize++;\n}\n         // is there extra capacity available?\n\n","name":"add","className":"IntListVer2","variables":{"iValues":1,"iSize":5,"x":1},"constants":{"0":1},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"is there extra capacity available? if not resize \n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    int[] temp = new int[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"IntListVer2","variables":{"temp":2,"iValues":1,"System":1},"constants":{"0":2,"2":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":7,"StringLiteralExpr":4,"NameExpr":13,"UnaryExpr":1,"AssignExpr":3},"statements":{"IfStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i] + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"IntListVer2","variables":{"result":5,"iValues":2,"iSize":4,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":33,"StringLiteralExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"IntListVer2","variables":{"result":9,"iValues":2,"iSize":3,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"IntListVer2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic IntListVer2() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"IntListVer2","className":"IntListVer2","variables":{"DEFAULT_CAP":1},"constants":{},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"IntListVer2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic IntListVer2(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new int[initialCap];\n    iSize = 0;\n}\n","name":"IntListVer2","className":"IntListVer2","variables":{"iValues":1,"iSize":1,"initialCap":3},"constants":{"0":2,"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":1,"IntListVer2":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":30,"UnaryExpr":1,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":4,"ThisExpr":4,"MethodCallExpr":2},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other ris not null and refers to an IntList\n        IntListVer2 otherIntList = (IntListVer2) other;\n        result = this.iSize == otherIntList.iSize;\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i] == otherIntList.iValues[i];\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"IntListVer2","variables":{"result":8,"other":4,"iSize":1,"i":5,"otherIntList":1},"constants":{"0":1,"null":1,"false":2,"true":1},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other ris not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"IntListVer3","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Default constructor. Creates an empty list.\n     */\npublic IntListVer3() {\n    //redirect to single int constructor\n    this(DEFAULT_CAP);\n//other statments could go here.\n}\n","name":"IntListVer3","className":"IntListVer3","variables":{"DEFAULT_CAP":1},"constants":{},"javaDoc":"Default constructor Creates an empty list","comments":"other statments could go here redirect to single int constructor \n     * Default constructor. Creates an empty list.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"IntListVer3","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":3,"NameExpr":5,"StringLiteralExpr":2,"ArrayCreationExpr":1,"AssignExpr":2},"statements":{"AssertStmt":1,"ExpressionStmt":2},"text":"/**\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     */\npublic IntListVer3(int initialCap) {\n    assert initialCap > 0 : \"Violation of precondition. IntListVer1(int initialCap):\" + \"initialCap must be greater than 0. Value of initialCap: \" + initialCap;\n    iValues = new int[initialCap];\n    iSize = 0;\n}\n","name":"IntListVer3","className":"IntListVer3","variables":{"iValues":1,"iSize":1,"initialCap":3},"constants":{"0":2,"\"Violation of precondition. IntListVer1(int initialCap):\"":1,"\"initialCap must be greater than 0. Value of initialCap: \"":1},"javaDoc":"Constructor to allow user of class to specify initial capacity in case they intend to add a lot of elements to new list Creates an empty list initialCap > 0","comments":"\n     * Constructor to allow user of class to specify \n     * initial capacity in case they intend to add a lot\n     * of elements to new list. Creates an empty list.\n     * @param initialCap > 0\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"insert":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     */\npublic void add(int x) {\n    //example of loose coupling\n    insert(iSize, x);\n}\n","name":"add","className":"IntListVer3","variables":{},"constants":{},"javaDoc":"Default add method Add x to the end of this IntList Size of the list goes up by 1 x The value to add to the end of this list","comments":"example of loose coupling \n     * Default add method. Add x to the end of this IntList.\n     * Size of the list goes up by 1.\n     * @param x The value to add to the end of this list.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":7,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"AssertStmt":1,"ReturnStmt":1},"text":"/**\n     * Retrieve an element from the list based on position.\n     * @param pos 0 <= pos < size()\n     * @return The element at the given position.\n     */\npublic int get(int pos) {\n    assert 0 <= pos && pos < size() : \"Failed precondition get. \" + \"pos it out of bounds. Value of pos: \" + pos;\n    return iValues[pos];\n}\n","name":"get","className":"IntListVer3","variables":{"iValues":1,"pos":4},"constants":{"0":1,"\"Failed precondition get. \"":1,"\"pos it out of bounds. Value of pos: \"":1},"javaDoc":"Retrieve an element from the list based on position pos 0 <= pos < size() The element at the given position","comments":"\n     * Retrieve an element from the list based on position.\n     * @param pos 0 <= pos < size()\n     * @return The element at the given position.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"size":1,"ensureCapcity":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":7,"NameExpr":19,"StringLiteralExpr":2,"UnaryExpr":2,"MethodCallExpr":2,"AssignExpr":2},"statements":{"BlockStmt":1,"AssertStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/**\n     * Insert x at position pos. Elements with a position equal\n     * to pos or more are shifted to the right. (One added to their\n     * position.)\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param x\n     */\npublic void insert(int pos, int x) {\n    assert 0 <= pos && pos <= size() : \"Failed precondition insert. \" + \"pos is invalid. Value of pos: \" + pos;\n    ensureCapcity();\n    for (int i = iSize; i > pos; i--) {\n        iValues[i] = iValues[i - 1];\n    }\n    iValues[pos] = x;\n    iSize++;\n}\n","name":"insert","className":"IntListVer3","variables":{"iValues":3,"iSize":2,"pos":5,"x":1,"i":5},"constants":{"0":1,"1":1,"\"Failed precondition insert. \"":1,"\"pos is invalid. Value of pos: \"":1},"javaDoc":"Insert x at position pos Elements with a position equal to pos or more are shifted to the right (One added to their position ) post: get(pos) = x size() = old size() + 1 pos 0 <= pos <= size() x","comments":"\n     * Insert x at position pos. Elements with a position equal\n     * to pos or more are shifted to the right. (One added to their\n     * position.)\n     * post: get(pos) = x, size() = old size() + 1\n     * @param pos 0 <= pos <= size()\n     * @param x\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":8,"NameExpr":17,"StringLiteralExpr":2,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":1},"statements":{"AssertStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n     * Remove an element from the list based on position.\n     * Elements with a position greater than pos\n     * are shifted to the left. (One subtracted from their\n     * position.)\n     * @param pos 0 <= pos < size()\n     * @return The element that is removed.\n     */\npublic int remove(int pos) {\n    assert 0 <= pos && pos < size() : \"Failed precondition remove. \" + \"pos it out of bounds. Value of pos: \" + pos;\n    int removedValue = iValues[pos];\n    for (int i = pos; i < iSize - 1; i++) iValues[i] = iValues[i + 1];\n    iSize--;\n    return removedValue;\n}\n","name":"remove","className":"IntListVer3","variables":{"iValues":3,"removedValue":2,"iSize":2,"pos":5,"i":5},"constants":{"0":1,"1":2,"\"Failed precondition remove. \"":1,"\"pos it out of bounds. Value of pos: \"":1},"javaDoc":"Remove an element from the list based on position Elements with a position greater than pos are shifted to the left (One subtracted from their position ) pos 0 <= pos < size() The element that is removed","comments":"\n     * Remove an element from the list based on position.\n     * Elements with a position greater than pos\n     * are shifted to the left. (One subtracted from their\n     * position.)\n     * @param pos 0 <= pos < size()\n     * @return The element that is removed.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"private void ensureCapcity() {\n    // if not, resize\n    if (iSize == iValues.length)\n        resize();\n}\n         // is there extra capacity available?\n\n","name":"ensureCapcity","className":"IntListVer3","variables":{"iSize":1},"constants":{},"javaDoc":"","comments":"is there extra capacity available? if not resize ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * Returns the size of the list.\n     * @return The size of the list.\n     */\npublic int size() {\n    return iSize;\n}\n","name":"size","className":"IntListVer3","variables":{"iSize":1},"constants":{},"javaDoc":"Returns the size of the list The size of the list","comments":"\n     * Returns the size of the list.\n     * @return The size of the list.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"// resize internal storage container by a factor of 2\nprivate void resize() {\n    int[] temp = new int[iValues.length * 2];\n    System.arraycopy(iValues, 0, temp, 0, iValues.length);\n    iValues = temp;\n}\n","name":"resize","className":"IntListVer3","variables":{"temp":2,"iValues":1,"System":1},"constants":{"0":2,"2":1},"javaDoc":"","comments":" resize internal storage container by a factor of 2","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":7,"StringLiteralExpr":4,"NameExpr":13,"UnaryExpr":1,"AssignExpr":3},"statements":{"IfStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * Return a String version of this list. Size and \n     * elements included.\n     */\npublic String toString() {\n    // we could make this more effecient by using a StringBuffer.\n    // See alternative version\n    String result = \"size: \" + iSize + \", elements: [\";\n    for (int i = 0; i < iSize - 1; i++) result += iValues[i] + \", \";\n    if (iSize > 0)\n        result += iValues[iSize - 1];\n    result += \"]\";\n    return result;\n}\n","name":"toString","className":"IntListVer3","variables":{"result":5,"iValues":2,"iSize":4,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"Return a String version of this list Size and elements included","comments":"we could make this more effecient by using a StringBuffer See alternative version \n     * Return a String version of this list. Size and \n     * elements included.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"append":7},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":33,"StringLiteralExpr":4,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"// Would not really have this and toString available\n// both included just for testing\npublic String toStringUsingStringBuffer() {\n    StringBuffer result = new StringBuffer();\n    result.append(\"size: \");\n    result.append(iSize);\n    result.append(\", elements: [\");\n    for (int i = 0; i < iSize - 1; i++) {\n        result.append(iValues[i]);\n        result.append(\", \");\n    }\n    if (iSize > 0)\n        result.append(iValues[iSize - 1]);\n    result.append(\"]\");\n    return result.toString();\n}\n","name":"toStringUsingStringBuffer","className":"IntListVer3","variables":{"result":9,"iValues":2,"iSize":3,"i":4},"constants":{"0":2,"1":2,"\"]\"":1,"\", \"":1,"\", elements: [\"":1,"\"size: \"":1},"javaDoc":"","comments":" both included just for testing","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getClass":1,"size":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"boolean":1,"IntListVer3":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":30,"UnaryExpr":1,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":2,"ThisExpr":4,"MethodCallExpr":4},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    */\npublic boolean equals(Object other) {\n    boolean result;\n    if (other == null)\n        // we know this is not null so can't be equal\n        result = false;\n    else if (this == other)\n        // quick check if this and other refer to same IntList object\n        result = true;\n    else if (this.getClass() != other.getClass())\n        // other is not an IntList they can't be equal\n        result = false;\n    else {\n        // other is not null and refers to an IntList\n        IntListVer3 otherIntList = (IntListVer3) other;\n        result = this.size() == otherIntList.size();\n        int i = 0;\n        while (i < iSize && result) {\n            result = this.iValues[i] == otherIntList.iValues[i];\n            i++;\n        }\n    }\n    return result;\n}\n","name":"equals","className":"IntListVer3","variables":{"result":8,"other":4,"iSize":1,"i":5,"otherIntList":2},"constants":{"0":1,"null":1,"false":2,"true":1},"javaDoc":"Return true if this IntList is equal to other <br> pre: none other The object to comapre to this true if other is a non null IntList object that is the same size as this IntList and has the same elements in the same order false otherwise","comments":"we know this is not null so can't be equal quick check if this and other refer to same IntList object other is not an IntList they can't be equal other is not null and refers to an IntList \n    * Return true if this IntList is equal to other.<br>\n    * pre: none\n    * @param other The object to comapre to this\n    * @return true if other is a non null, IntList object\n    * that is the same size as this IntList and has the\n    * same elements in the same order, false otherwise.\n    ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"println":1,"nextInt":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["FinalVariables","ExceptionHandling"],"types":{"PrintStream":1,"Random":1,"int":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":17,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    try {\n        PrintStream writer = new PrintStream(new File(\"randInts.txt\"));\n        Random r = new Random();\n        final int LIMIT = 100;\n        for (int i = 0; i < LIMIT; i++) {\n            writer.println(r.nextInt());\n        }\n        writer.close();\n    } catch (IOException e) {\n        System.out.println(\"An error occured while trying to write to the file\");\n    }\n}\n","name":"main","className":"WriteToFile","variables":{"r":2,"e":1,"i":3,"LIMIT":2,"writer":3},"constants":{"0":1,"100":1,"\"randInts.txt\"":1,"\"An error occured while trying to write to the file\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"countWordsViaGUI":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    countWordsViaGUI();\n}\n","name":"main","className":"WordCount","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"countWordsWithArrayList":1,"nextLine":2,"toLowerCase":1,"start":1,"getFile":1,"parseInt":1,"stop":1,"showWords":1,"setLookAndFeel":1,"close":2,"System.out.print":2,"charAt":1,"System.out.println":3},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Scanner":2,"Stopwatch":1,"ArrayList<String>":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":3,"NameExpr":66,"StringLiteralExpr":5,"FieldAccessExpr":6,"CharLiteralExpr":1,"MethodCallExpr":18},"statements":{"TryStmt":1,"BlockStmt":3,"ExpressionStmt":16,"DoStmt":1},"text":"// allow user to pick file to exam via GUI.\n// allow multiple picks\npublic static void countWordsViaGUI() {\n    setLookAndFeel();\n    try {\n        Scanner key = new Scanner(System.in);\n        do {\n            System.out.println(\"Opening GUI to choose file.\");\n            Scanner fileScanner = new Scanner(getFile());\n            Stopwatch st = new Stopwatch();\n            st.start();\n            ArrayList<String> words = countWordsWithArrayList(fileScanner);\n            st.stop();\n            System.out.println(\"time to count: \" + st);\n            System.out.print(\"Enter number of words to display: \");\n            int numWordsToShow = Integer.parseInt(key.nextLine());\n            showWords(words, numWordsToShow);\n            fileScanner.close();\n            System.out.print(\"Perform another count? \");\n        } while (key.nextLine().toLowerCase().charAt(0) == 'y');\n        key.close();\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Problem reading the data file. Exiting the program.\" + e);\n    }\n}\n","name":"countWordsViaGUI","className":"WordCount","variables":{"Integer":1,"fileScanner":2,"st":4,"numWordsToShow":1,"e":2,"words":1,"key":4},"constants":{"0":1,"\"time to count: \"":1,"'y'":1,"\"Problem reading the data file. Exiting the program.\"":1,"\"Enter number of words to display: \"":1,"\"Opening GUI to choose file.\"":1,"\"Perform another count? \"":1},"javaDoc":"","comments":" allow multiple picks","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Scanner"],"returnType":"ArrayList<String>","methodCalls":{"size":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"// determine distinct words in a file using an array list\nprivate static ArrayList<String> countWordsWithArrayList(Scanner fileScanner) {\n    System.out.println(\"Total number of words: \" + numWords);\n    System.out.println(\"number of distincy words: \" + result.size());\n    return result;\n}\n","name":"countWordsWithArrayList","className":"WordCount","variables":{"result":2,"numWords":1},"constants":{"\"Total number of words: \"":1,"\"number of distincy words: \"":1},"javaDoc":"","comments":" determine distinct words in a file using an array list","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Scanner"],"returnType":"Map<String, Integer>","methodCalls":{"size":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"// determine distinct words in a file and frequency of each word with a Map\nprivate static Map<String, Integer> countWordsWithMap(Scanner fileScanner) {\n    System.out.println(\"Total number of words: \" + numWords);\n    System.out.println(\"number of distincy words: \" + result.size());\n    return result;\n}\n","name":"countWordsWithMap","className":"WordCount","variables":{"result":2,"numWords":1},"constants":{"\"Total number of words: \"":1,"\"number of distincy words: \"":1},"javaDoc":"","comments":" determine distinct words in a file and frequency of each word with a Map","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["ArrayList<String>","int"],"returnType":"void","methodCalls":{"size":1,"get":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":16,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"private static void showWords(ArrayList<String> words, int numWordsToShow) {\n    for (int i = 0; i < words.size() && i < numWordsToShow; i++) System.out.println(words.get(i));\n}\n","name":"showWords","className":"WordCount","variables":{"numWordsToShow":1,"words":2,"i":4},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Map<String, Integer>","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"private static void showWords(Map<String, Integer> words, int numWordsToShow) {\n}\n","name":"showWords","className":"WordCount","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"timingExpWithArrayList":2,"timingExpWithMap":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayInitializerExpr":2,"StringLiteralExpr":5,"NameExpr":12,"MethodCallExpr":4},"statements":{"EmptyStmt":1,"ExpressionStmt":6},"text":"// perform a series of experiments on files. Determine average time to\n// count words in files of various sizes\nprivate static void performExp() {\n    String[] smallerWorks = { \"smallWords.txt\", \"2BR02B.txt\", \"Alice.txt\", \"SherlockHolmes.txt\" };\n    ;\n    String[] bigFile = { \"ciaFactBook2008.txt\" };\n    timingExpWithArrayList(smallerWorks, 50);\n    timingExpWithArrayList(bigFile, 3);\n    timingExpWithMap(smallerWorks, 50);\n    timingExpWithMap(bigFile, 3);\n}\n","name":"performExp","className":"WordCount","variables":{"bigFile":1,"smallerWorks":1},"constants":{"\"SherlockHolmes.txt\"":1,"\"Alice.txt\"":1,"3":2,"\"ciaFactBook2008.txt\"":1,"\"smallWords.txt\"":1,"50":2,"\"2BR02B.txt\"":1},"javaDoc":"","comments":" count words in files of various sizes","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String[]","int"],"returnType":"void","methodCalls":{"stop":1,"size":1,"start":1,"time":1,"countWordsWithMap":1,"close":1,"System.out.println":3},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["FinalVariables","ExceptionHandling"],"types":{"Scanner":1,"double[]":1,"Map<String, Integer>":1,"double":1,"Stopwatch":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":3,"VariableDeclarationExpr":8,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":52,"StringLiteralExpr":1,"FieldAccessExpr":5,"ArrayCreationExpr":1,"UnaryExpr":2,"MethodCallExpr":9,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":4,"ForeachStmt":1,"ForStmt":2,"ExpressionStmt":12},"text":"// pre: titles != null, elements of titles refer to files in the\n// same path as this program, numExp >= 0\n// read words from files and print average time to cound words.\nprivate static void timingExpWithMap(String[] titles, int numExp) {\n    try {\n        double[] times = new double[titles.length];\n        final int NUM_EXP = 50;\n        for (int i = 0; i < NUM_EXP; i++) {\n            for (int j = 0; j < titles.length; j++) {\n                Scanner fileScanner = new Scanner(new File(titles[j]));\n                Stopwatch st = new Stopwatch();\n                st.start();\n                Map<String, Integer> words = countWordsWithMap(fileScanner);\n                st.stop();\n                System.out.println(words.size());\n                times[j] += st.time();\n                fileScanner.close();\n            }\n        }\n        for (double a : times) System.out.println(a / NUM_EXP);\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Problem reading the data file. Exiting the program.\" + e);\n    }\n}\n","name":"timingExpWithMap","className":"WordCount","variables":{"fileScanner":2,"st":4,"a":2,"times":3,"e":2,"words":2,"i":3,"j":5,"titles":1,"NUM_EXP":3},"constants":{"0":2,"\"Problem reading the data file. Exiting the program.\"":1,"50":1},"javaDoc":"","comments":" read words from files and print average time to cound words.","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["String[]","int"],"returnType":"void","methodCalls":{"stop":1,"countWordsWithArrayList":1,"start":1,"time":1,"close":1,"System.out.println":2},"annotations":[],"exceptions":["FileNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Scanner":1,"double[]":1,"Stopwatch":1,"ArrayList<String>":1,"int":3},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":3,"VariableDeclarationExpr":7,"ArrayAccessExpr":4,"BinaryExpr":8,"NameExpr":51,"StringLiteralExpr":3,"UnaryExpr":3,"AssignExpr":1,"FieldAccessExpr":5,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":7},"statements":{"TryStmt":1,"BlockStmt":4,"ForStmt":3,"ExpressionStmt":10},"text":"// pre: titles != null, elements of titles refer to files in the\n// same path as this program, numExp >= 0\n// read words from files and print average time to cound words.\nprivate static void timingExpWithArrayList(String[] titles, int numExp) {\n    try {\n        double[] times = new double[titles.length];\n        for (int i = 0; i < numExp; i++) {\n            for (int j = 0; j < titles.length; j++) {\n                Scanner fileScanner = new Scanner(new File(titles[j]));\n                Stopwatch st = new Stopwatch();\n                st.start();\n                ArrayList<String> words = countWordsWithArrayList(fileScanner);\n                st.stop();\n                times[j] += st.time();\n                fileScanner.close();\n            }\n        }\n        for (int i = 0; i < titles.length; i++) System.out.println(\"Average time for \" + titles[i] + \": \" + (times[i] / numExp));\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Problem reading the data file. Exiting the program.\" + e);\n    }\n}\n","name":"timingExpWithArrayList","className":"WordCount","variables":{"fileScanner":2,"st":4,"times":3,"e":2,"words":1,"i":8,"j":5,"titles":2,"numExp":2},"constants":{"0":3,"\"Problem reading the data file. Exiting the program.\"":1,"\": \"":1,"\"Average time for \"":1},"javaDoc":"","comments":" read words from files and print average time to cound words.","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"void","methodCalls":{"getSystemLookAndFeelClassName":1,"setLookAndFeel":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"// try to set look and feel to same as system\nprivate static void setLookAndFeel() {\n    try {\n        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n    } catch (Exception e) {\n        System.out.println(\"Unable to set look at feel to local settings. \" + \"Continuing with default Java look and feel.\");\n    }\n}\n","name":"setLookAndFeel","className":"WordCount","variables":{"e":1,"UIManager":2},"constants":{"\"Unable to set look at feel to local settings. \"":1,"\"Continuing with default Java look and feel.\"":1},"javaDoc":"","comments":" try to set look and feel to same as system","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":[],"returnType":"File","methodCalls":{"showOpenDialog":1,"getSelectedFile":1,"grabFocus":1,"setDialogTitle":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFileChooser":1,"File":1,"int":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":18,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"/** Method to choose a file using a window.\n     * @return the file chosen by the user. Returns null if no file picked.\n     */\nprivate static File getFile() {\n    // create a GUI window to pick the text to evaluate\n    JFileChooser chooser = new JFileChooser(\".\");\n    chooser.setDialogTitle(\"Select File To Count Words:\");\n    int retval = chooser.showOpenDialog(null);\n    File f = null;\n    chooser.grabFocus();\n    if (retval == JFileChooser.APPROVE_OPTION)\n        f = chooser.getSelectedFile();\n    return f;\n}\n","name":"getFile","className":"WordCount","variables":{"f":3,"chooser":5,"retval":2},"constants":{"\"Select File To Count Words:\"":1,"null":2,"\".\"":1},"javaDoc":"Method to choose a file using a window the file chosen by the user Returns null if no file picked","comments":"create a GUI window to pick the text to evaluate  Method to choose a file using a window.\n     * @return the file chosen by the user. Returns null if no file picked.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":10}
